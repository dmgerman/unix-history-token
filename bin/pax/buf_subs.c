begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Keith Muller.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Keith Muller of the University of California, San Diego.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)buf_subs.c	8.2 (Berkeley) 4/18/94";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"pax.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * routines which implement archive and file buffering  */
end_comment

begin_define
define|#
directive|define
name|MINFBSZ
value|512
end_define

begin_comment
comment|/* default block size for hole detect */
end_comment

begin_define
define|#
directive|define
name|MAXFLT
value|10
end_define

begin_comment
comment|/* default media read error limit */
end_comment

begin_comment
comment|/*  * Need to change bufmem to dynamic allocation when the upper  * limit on blocking size is removed (though that will violate pax spec)  * MAXBLK define and tests will also need to be updated.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|bufmem
index|[
name|MAXBLK
operator|+
name|BLKMULT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i/o buffer + pushback id space */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* normal start of i/o buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bufend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end or last char in i/o buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bufpt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* read/write point in i/o buffer */
end_comment

begin_decl_stmt
name|int
name|blksz
init|=
name|MAXBLK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* block input/output size in bytes */
end_comment

begin_decl_stmt
name|int
name|wrblksz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user spec output size in bytes */
end_comment

begin_decl_stmt
name|int
name|maxflt
init|=
name|MAXFLT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MAX consecutive media errors */
end_comment

begin_decl_stmt
name|int
name|rdblksz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first read blksize (tapes only) */
end_comment

begin_decl_stmt
name|off_t
name|wrlimit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of bytes written per archive vol */
end_comment

begin_decl_stmt
name|off_t
name|wrcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of bytes written on current vol */
end_comment

begin_decl_stmt
name|off_t
name|rdcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of bytes read on current vol */
end_comment

begin_comment
comment|/*  * wr_start()  *	set up the buffering system to operate in a write mode  * Return:  *	0 if ok, -1 if the user specified write block size violates pax spec  */
end_comment

begin_function
name|int
name|wr_start
parameter_list|(
name|void
parameter_list|)
block|{
name|buf
operator|=
operator|&
operator|(
name|bufmem
index|[
name|BLKMULT
index|]
operator|)
expr_stmt|;
comment|/* 	 * Check to make sure the write block size meets pax specs. If the user 	 * does not specify a blocksize, we use the format default blocksize. 	 * We must be picky on writes, so we do not allow the user to create an 	 * archive that might be hard to read elsewhere. If all ok, we then 	 * open the first archive volume 	 */
if|if
condition|(
operator|!
name|wrblksz
condition|)
name|wrblksz
operator|=
name|frmt
operator|->
name|bsz
expr_stmt|;
if|if
condition|(
name|wrblksz
operator|>
name|MAXBLK
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Write block size of %d too large, maximum is: %d"
argument_list|,
name|wrblksz
argument_list|,
name|MAXBLK
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|wrblksz
operator|%
name|BLKMULT
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Write block size of %d is not a %d byte multiple"
argument_list|,
name|wrblksz
argument_list|,
name|BLKMULT
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|wrblksz
operator|>
name|MAXBLK_POSIX
condition|)
block|{
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"Write block size of %d larger than POSIX max %d, archive may not be portable"
argument_list|,
name|wrblksz
argument_list|,
name|MAXBLK_POSIX
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * we only allow wrblksz to be used with all archive operations 	 */
name|blksz
operator|=
name|rdblksz
operator|=
name|wrblksz
expr_stmt|;
if|if
condition|(
operator|(
name|ar_open
argument_list|(
name|arcname
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|ar_next
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wrcnt
operator|=
literal|0
expr_stmt|;
name|bufend
operator|=
name|buf
operator|+
name|wrblksz
expr_stmt|;
name|bufpt
operator|=
name|buf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rd_start()  *	set up buffering system to read an archive  * Return:  *	0 if ok, -1 otherwise  */
end_comment

begin_function
name|int
name|rd_start
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * leave space for the header pushback (see get_arc()). If we are 	 * going to append and user specified a write block size, check it 	 * right away 	 */
name|buf
operator|=
operator|&
operator|(
name|bufmem
index|[
name|BLKMULT
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|act
operator|==
name|APPND
operator|)
operator|&&
name|wrblksz
condition|)
block|{
if|if
condition|(
name|wrblksz
operator|>
name|MAXBLK
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Write block size %d too large, maximum is: %d"
argument_list|,
name|wrblksz
argument_list|,
name|MAXBLK
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|wrblksz
operator|%
name|BLKMULT
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Write block size %d is not a %d byte multiple"
argument_list|,
name|wrblksz
argument_list|,
name|BLKMULT
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * open the archive 	 */
if|if
condition|(
operator|(
name|ar_open
argument_list|(
name|arcname
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|ar_next
argument_list|()
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bufend
operator|=
name|buf
operator|+
name|rdblksz
expr_stmt|;
name|bufpt
operator|=
name|bufend
expr_stmt|;
name|rdcnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cp_start()  *	set up buffer system for copying within the file system  */
end_comment

begin_function
name|void
name|cp_start
parameter_list|(
name|void
parameter_list|)
block|{
name|buf
operator|=
operator|&
operator|(
name|bufmem
index|[
name|BLKMULT
index|]
operator|)
expr_stmt|;
name|rdblksz
operator|=
name|blksz
operator|=
name|MAXBLK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * appnd_start()  *	Set up the buffering system to append new members to an archive that  *	was just read. The last block(s) of an archive may contain a format  *	specific trailer. To append a new member, this trailer has to be  *	removed from the archive. The first byte of the trailer is replaced by  *	the start of the header of the first file added to the archive. The  *	format specific end read function tells us how many bytes to move  *	backwards in the archive to be positioned BEFORE the trailer. Two  *	different postions have to be adjusted, the O.S. file offset (e.g. the  *	position of the tape head) and the write point within the data we have  *	stored in the read (soon to become write) buffer. We may have to move  *	back several records (the number depends on the size of the archive  *	record and the size of the format trailer) to read up the record where  *	the first byte of the trailer is recorded. Trailers may span (and  *	overlap) record boundries.  *	We first calculate which record has the first byte of the trailer. We  *	move the OS file offset back to the start of this record and read it  *	up. We set the buffer write pointer to be at this byte (the byte where  *	the trailer starts). We then move the OS file pointer back to the  *	start of this record so a flush of this buffer will replace the record  *	in the archive.  *	A major problem is rewriting this last record. For archives stored  *	on disk files, this is trival. However, many devices are really picky  *	about the conditions under which they will allow a write to occur.  *	Often devices restrict the conditions where writes can be made writes,  *	so it may not be feasable to append archives stored on all types of  *	devices.  * Return:  *	0 for success, -1 for failure  */
end_comment

begin_function
name|int
name|appnd_start
parameter_list|(
name|off_t
name|skcnt
parameter_list|)
block|{
specifier|register
name|int
name|res
decl_stmt|;
name|off_t
name|cnt
decl_stmt|;
if|if
condition|(
name|exit_val
operator|!=
literal|0
condition|)
block|{
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"Cannot append to an archive that may have flaws."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * if the user did not specify a write blocksize, inherit the size used 	 * in the last archive volume read. (If a is set we still use rdblksz 	 * until next volume, cannot shift sizes within a single volume). 	 */
if|if
condition|(
operator|!
name|wrblksz
condition|)
name|wrblksz
operator|=
name|blksz
operator|=
name|rdblksz
expr_stmt|;
else|else
name|blksz
operator|=
name|rdblksz
expr_stmt|;
comment|/* 	 * make sure that this volume allows appends 	 */
if|if
condition|(
name|ar_app_ok
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Calculate bytes to move back and move in front of record where we 	 * need to start writing from. Remember we have to add in any padding 	 * that might be in the buffer after the trailer in the last block. We 	 * travel skcnt + padding ROUNDED UP to blksize. 	 */
name|skcnt
operator|+=
name|bufend
operator|-
name|bufpt
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|=
operator|(
name|skcnt
operator|/
name|blksz
operator|)
operator|*
name|blksz
operator|)
operator|<
name|skcnt
condition|)
name|cnt
operator|+=
name|blksz
expr_stmt|;
if|if
condition|(
name|ar_rev
argument_list|(
operator|(
name|off_t
operator|)
name|cnt
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * We may have gone too far if there is valid data in the block we are 	 * now in front of, read up the block and position the pointer after 	 * the valid data. 	 */
if|if
condition|(
operator|(
name|cnt
operator|-=
name|skcnt
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* 		 * watch out for stupid tape drives. ar_rev() will set rdblksz 		 * to be real physical blocksize so we must loop until we get 		 * the old rdblksz (now in blksz). If ar_rev() fouls up the 		 * determination of the physical block size, we will fail. 		 */
name|bufpt
operator|=
name|buf
expr_stmt|;
name|bufend
operator|=
name|buf
operator|+
name|blksz
expr_stmt|;
while|while
condition|(
name|bufpt
operator|<
name|bufend
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|ar_read
argument_list|(
name|bufpt
argument_list|,
name|rdblksz
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|out
goto|;
name|bufpt
operator|+=
name|res
expr_stmt|;
block|}
if|if
condition|(
name|ar_rev
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|bufpt
operator|-
name|buf
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
name|bufpt
operator|=
name|buf
operator|+
name|cnt
expr_stmt|;
name|bufend
operator|=
name|buf
operator|+
name|blksz
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * buffer is empty 		 */
name|bufend
operator|=
name|buf
operator|+
name|blksz
expr_stmt|;
name|bufpt
operator|=
name|buf
expr_stmt|;
block|}
name|rdblksz
operator|=
name|blksz
expr_stmt|;
name|rdcnt
operator|-=
name|skcnt
expr_stmt|;
name|wrcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * At this point we are ready to write. If the device requires special 	 * handling to write at a point were previously recorded data resides, 	 * that is handled in ar_set_wr(). From now on we operate under normal 	 * ARCHIVE mode (write) conditions 	 */
if|if
condition|(
name|ar_set_wr
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|act
operator|=
name|ARCHIVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|out
label|:
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Unable to rewrite archive trailer, cannot append."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rd_sync()  *	A read error occurred on this archive volume. Resync the buffer and  *	try to reset the device (if possible) so we can continue to read. Keep  *	trying to do this until we get a valid read, or we reach the limit on  *	consecutive read faults (at which point we give up). The user can  *	adjust the read error limit through a command line option.  * Returns:  *	0 on success, and -1 on failure  */
end_comment

begin_function
name|int
name|rd_sync
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|errcnt
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|res
decl_stmt|;
comment|/* 	 * if the user says bail out on first fault, we are out of here... 	 */
if|if
condition|(
name|maxflt
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|act
operator|==
name|APPND
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Unable to append when there are archive read errors."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * poke at device and try to get past media error 	 */
if|if
condition|(
name|ar_rdsync
argument_list|()
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ar_next
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
name|rdcnt
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|ar_read
argument_list|(
name|buf
argument_list|,
name|blksz
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* 			 * All right! got some data, fill that buffer 			 */
name|bufpt
operator|=
name|buf
expr_stmt|;
name|bufend
operator|=
name|buf
operator|+
name|res
expr_stmt|;
name|rdcnt
operator|+=
name|res
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Oh well, yet another failed read... 		 * if error limit reached, ditch. o.w. poke device to move past 		 * bad media and try again. if media is badly damaged, we ask 		 * the poor (and upset user at this point) for the next archive 		 * volume. remember the goal on reads is to get the most we 		 * can extract out of the archive. 		 */
if|if
condition|(
operator|(
name|maxflt
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|++
name|errcnt
operator|>
name|maxflt
operator|)
condition|)
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"Archive read error limit (%d) reached"
argument_list|,
name|maxflt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ar_rdsync
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ar_next
argument_list|()
operator|<
literal|0
condition|)
break|break;
name|rdcnt
operator|=
literal|0
expr_stmt|;
name|errcnt
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pback()  *	push the data used during the archive id phase back into the I/O  *	buffer. This is required as we cannot be sure that the header does NOT  *	overlap a block boundry (as in the case we are trying to recover a  *	flawed archived). This was not designed to be used for any other  *	purpose. (What software engineering, HA!)  *	WARNING: do not even THINK of pback greater than BLKMULT, unless the  *	pback space is increased.  */
end_comment

begin_function
name|void
name|pback
parameter_list|(
name|char
modifier|*
name|pt
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|bufpt
operator|-=
name|cnt
expr_stmt|;
name|memcpy
argument_list|(
name|bufpt
argument_list|,
name|pt
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * rd_skip()  *	skip foward in the archive during a archive read. Used to get quickly  *	past file data and padding for files the user did NOT select.  * Return:  *	0 if ok, -1 failure, and 1 when EOF on the archive volume was detected.  */
end_comment

begin_function
name|int
name|rd_skip
parameter_list|(
name|off_t
name|skcnt
parameter_list|)
block|{
name|off_t
name|res
decl_stmt|;
name|off_t
name|cnt
decl_stmt|;
name|off_t
name|skipped
init|=
literal|0
decl_stmt|;
comment|/* 	 * consume what data we have in the buffer. If we have to move foward 	 * whole records, we call the low level skip function to see if we can 	 * move within the archive without doing the expensive reads on data we 	 * do not want. 	 */
if|if
condition|(
name|skcnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|res
operator|=
name|MIN
argument_list|(
operator|(
name|bufend
operator|-
name|bufpt
operator|)
argument_list|,
name|skcnt
argument_list|)
expr_stmt|;
name|bufpt
operator|+=
name|res
expr_stmt|;
name|skcnt
operator|-=
name|res
expr_stmt|;
comment|/* 	 * if skcnt is now 0, then no additional i/o is needed 	 */
if|if
condition|(
name|skcnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * We have to read more, calculate complete and partial record reads 	 * based on rdblksz. we skip over "cnt" complete records 	 */
name|res
operator|=
name|skcnt
operator|%
name|rdblksz
expr_stmt|;
name|cnt
operator|=
operator|(
name|skcnt
operator|/
name|rdblksz
operator|)
operator|*
name|rdblksz
expr_stmt|;
comment|/* 	 * if the skip fails, we will have to resync. ar_fow will tell us 	 * how much it can skip over. We will have to read the rest. 	 */
if|if
condition|(
name|ar_fow
argument_list|(
name|cnt
argument_list|,
operator|&
name|skipped
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|res
operator|+=
name|cnt
operator|-
name|skipped
expr_stmt|;
name|rdcnt
operator|+=
name|skipped
expr_stmt|;
comment|/* 	 * what is left we have to read (which may be the whole thing if 	 * ar_fow() told us the device can only read to skip records); 	 */
while|while
condition|(
name|res
operator|>
literal|0L
condition|)
block|{
name|cnt
operator|=
name|bufend
operator|-
name|bufpt
expr_stmt|;
comment|/* 		 * if the read fails, we will have to resync 		 */
if|if
condition|(
operator|(
name|cnt
operator|<=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cnt
operator|=
name|buf_fill
argument_list|()
operator|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cnt
operator|=
name|MIN
argument_list|(
name|cnt
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|bufpt
operator|+=
name|cnt
expr_stmt|;
name|res
operator|-=
name|cnt
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wr_fin()  *	flush out any data (and pad if required) the last block. We always pad  *	with zero (even though we do not have to). Padding with 0 makes it a  *	lot easier to recover if the archive is damaged. zero paddding SHOULD  *	BE a requirement....  */
end_comment

begin_function
name|void
name|wr_fin
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|bufpt
operator|>
name|buf
condition|)
block|{
name|memset
argument_list|(
name|bufpt
argument_list|,
literal|0
argument_list|,
name|bufend
operator|-
name|bufpt
argument_list|)
expr_stmt|;
name|bufpt
operator|=
name|bufend
expr_stmt|;
operator|(
name|void
operator|)
name|buf_flush
argument_list|(
name|blksz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wr_rdbuf()  *	fill the write buffer from data passed to it in a buffer (usually used  *	by format specific write routines to pass a file header). On failure we  *	punt. We do not allow the user to continue to write flawed archives.  *	We assume these headers are not very large (the memory copy we use is  *	a bit expensive).  * Return:  *	0 if buffer was filled ok, -1 o.w. (buffer flush failure)  */
end_comment

begin_function
name|int
name|wr_rdbuf
parameter_list|(
specifier|register
name|char
modifier|*
name|out
parameter_list|,
specifier|register
name|int
name|outcnt
parameter_list|)
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
comment|/* 	 * while there is data to copy copy into the write buffer. when the 	 * write buffer fills, flush it to the archive and continue 	 */
while|while
condition|(
name|outcnt
operator|>
literal|0
condition|)
block|{
name|cnt
operator|=
name|bufend
operator|-
name|bufpt
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|<=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cnt
operator|=
name|buf_flush
argument_list|(
name|blksz
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * only move what we have space for 		 */
name|cnt
operator|=
name|MIN
argument_list|(
name|cnt
argument_list|,
name|outcnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bufpt
argument_list|,
name|out
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|bufpt
operator|+=
name|cnt
expr_stmt|;
name|out
operator|+=
name|cnt
expr_stmt|;
name|outcnt
operator|-=
name|cnt
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rd_wrbuf()  *	copy from the read buffer into a supplied buffer a specified number of  *	bytes. If the read buffer is empty fill it and continue to copy.  *	usually used to obtain a file header for processing by a format  *	specific read routine.  * Return  *	number of bytes copied to the buffer, 0 indicates EOF on archive volume,  *	-1 is a read error  */
end_comment

begin_function
name|int
name|rd_wrbuf
parameter_list|(
specifier|register
name|char
modifier|*
name|in
parameter_list|,
specifier|register
name|int
name|cpcnt
parameter_list|)
block|{
specifier|register
name|int
name|res
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|int
name|incnt
init|=
name|cpcnt
decl_stmt|;
comment|/* 	 * loop until we fill the buffer with the requested number of bytes 	 */
while|while
condition|(
name|incnt
operator|>
literal|0
condition|)
block|{
name|cnt
operator|=
name|bufend
operator|-
name|bufpt
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|<=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cnt
operator|=
name|buf_fill
argument_list|()
operator|)
operator|<=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * read error, return what we got (or the error if 			 * no data was copied). The caller must know that an 			 * error occured and has the best knowledge what to 			 * do with it 			 */
if|if
condition|(
operator|(
name|res
operator|=
name|cpcnt
operator|-
name|incnt
operator|)
operator|>
literal|0
condition|)
return|return
operator|(
name|res
operator|)
return|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
comment|/* 		 * calculate how much data to copy based on whats left and 		 * state of buffer 		 */
name|cnt
operator|=
name|MIN
argument_list|(
name|cnt
argument_list|,
name|incnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|in
argument_list|,
name|bufpt
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|bufpt
operator|+=
name|cnt
expr_stmt|;
name|incnt
operator|-=
name|cnt
expr_stmt|;
name|in
operator|+=
name|cnt
expr_stmt|;
block|}
return|return
operator|(
name|cpcnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wr_skip()  *	skip forward during a write. In other words add padding to the file.  *	we add zero filled padding as it makes flawed archives much easier to  *	recover from. the caller tells us how many bytes of padding to add  *	This routine was not designed to add HUGE amount of padding, just small  *	amounts (a few 512 byte blocks at most)  * Return:  *	0 if ok, -1 if there was a buf_flush failure  */
end_comment

begin_function
name|int
name|wr_skip
parameter_list|(
name|off_t
name|skcnt
parameter_list|)
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
comment|/* 	 * loop while there is more padding to add 	 */
while|while
condition|(
name|skcnt
operator|>
literal|0L
condition|)
block|{
name|cnt
operator|=
name|bufend
operator|-
name|bufpt
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|<=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cnt
operator|=
name|buf_flush
argument_list|(
name|blksz
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cnt
operator|=
name|MIN
argument_list|(
name|cnt
argument_list|,
name|skcnt
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bufpt
argument_list|,
literal|0
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|bufpt
operator|+=
name|cnt
expr_stmt|;
name|skcnt
operator|-=
name|cnt
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wr_rdfile()  *	fill write buffer with the contents of a file. We are passed an	open  *	file descriptor to the file an the archive structure that describes the  *	file we are storing. The variable "left" is modified to contain the  *	number of bytes of the file we were NOT able to write to the archive.  *	it is important that we always write EXACTLY the number of bytes that  *	the format specific write routine told us to. The file can also get  *	bigger, so reading to the end of file would create an improper archive,  *	we just detect this case and warn the user. We never create a bad  *	archive if we can avoid it. Of course trying to archive files that are  *	active is asking for trouble. It we fail, we pass back how much we  *	could NOT copy and let the caller deal with it.  * Return:  *	0 ok, -1 if archive write failure. a short read of the file returns a  *	0, but "left" is set to be greater than zero.  */
end_comment

begin_function
name|int
name|wr_rdfile
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|,
name|int
name|ifd
parameter_list|,
name|off_t
modifier|*
name|left
parameter_list|)
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|int
name|res
init|=
literal|0
decl_stmt|;
specifier|register
name|off_t
name|size
init|=
name|arcn
operator|->
name|sb
operator|.
name|st_size
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* 	 * while there are more bytes to write 	 */
while|while
condition|(
name|size
operator|>
literal|0L
condition|)
block|{
name|cnt
operator|=
name|bufend
operator|-
name|bufpt
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|<=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cnt
operator|=
name|buf_flush
argument_list|(
name|blksz
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
operator|*
name|left
operator|=
name|size
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cnt
operator|=
name|MIN
argument_list|(
name|cnt
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
name|bufpt
argument_list|,
name|cnt
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
name|size
operator|-=
name|res
expr_stmt|;
name|bufpt
operator|+=
name|res
expr_stmt|;
block|}
comment|/* 	 * better check the file did not change during this operation 	 * or the file read failed. 	 */
if|if
condition|(
name|res
operator|<
literal|0
condition|)
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Read fault on %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|!=
literal|0L
condition|)
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File changed size during read %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fstat
argument_list|(
name|ifd
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed stat on %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|!=
name|sb
operator|.
name|st_mtime
condition|)
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File %s was modified during copy to archive"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
operator|*
name|left
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rd_wrfile()  *	extract the contents of a file from the archive. If we are unable to  *	extract the entire file (due to failure to write the file) we return  *	the numbers of bytes we did NOT process. This way the caller knows how  *	many bytes to skip past to find the next archive header. If the failure  *	was due to an archive read, we will catch that when we try to skip. If  *	the format supplies a file data crc value, we calculate the actual crc  *	so that it can be compared to the value stored in the header  * NOTE:  *	We call a special function to write the file. This function attempts to  *	restore file holes (blocks of zeros) into the file. When files are  *	sparse this saves space, and is a LOT faster. For non sparse files  *	the performance hit is small. As of this writing, no archive supports  *	information on where the file holes are.  * Return:  *	0 ok, -1 if archive read failure. if we cannot write the entire file,  *	we return a 0 but "left" is set to be the amount unwritten  */
end_comment

begin_function
name|int
name|rd_wrfile
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|,
name|int
name|ofd
parameter_list|,
name|off_t
modifier|*
name|left
parameter_list|)
block|{
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
specifier|register
name|off_t
name|size
init|=
name|arcn
operator|->
name|sb
operator|.
name|st_size
decl_stmt|;
specifier|register
name|int
name|res
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|fnm
init|=
name|arcn
operator|->
name|name
decl_stmt|;
name|int
name|isem
init|=
literal|1
decl_stmt|;
name|int
name|rem
decl_stmt|;
name|int
name|sz
init|=
name|MINFBSZ
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|u_long
name|crc
init|=
literal|0L
decl_stmt|;
comment|/* 	 * pass the blocksize of the file being written to the write routine, 	 * if the size is zero, use the default MINFBSZ 	 */
if|if
condition|(
name|fstat
argument_list|(
name|ofd
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|st_blksize
operator|>
literal|0
condition|)
name|sz
operator|=
operator|(
name|int
operator|)
name|sb
operator|.
name|st_blksize
expr_stmt|;
block|}
else|else
name|syswarn
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Unable to obtain block size for file %s"
argument_list|,
name|fnm
argument_list|)
expr_stmt|;
name|rem
operator|=
name|sz
expr_stmt|;
operator|*
name|left
operator|=
literal|0L
expr_stmt|;
comment|/* 	 * Copy the archive to the file the number of bytes specified. We have 	 * to assume that we want to recover file holes as none of the archive 	 * formats can record the location of file holes. 	 */
while|while
condition|(
name|size
operator|>
literal|0L
condition|)
block|{
name|cnt
operator|=
name|bufend
operator|-
name|bufpt
expr_stmt|;
comment|/* 		 * if we get a read error, we do not want to skip, as we may 		 * miss a header, so we do not set left, but if we get a write 		 * error, we do want to skip over the unprocessed data. 		 */
if|if
condition|(
operator|(
name|cnt
operator|<=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cnt
operator|=
name|buf_fill
argument_list|()
operator|)
operator|<=
literal|0
operator|)
condition|)
break|break;
name|cnt
operator|=
name|MIN
argument_list|(
name|cnt
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|file_write
argument_list|(
name|ofd
argument_list|,
name|bufpt
argument_list|,
name|cnt
argument_list|,
operator|&
name|rem
argument_list|,
operator|&
name|isem
argument_list|,
name|sz
argument_list|,
name|fnm
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
operator|*
name|left
operator|=
name|size
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|docrc
condition|)
block|{
comment|/* 			 * update the actual crc value 			 */
name|cnt
operator|=
name|res
expr_stmt|;
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
name|crc
operator|+=
operator|*
name|bufpt
operator|++
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
name|bufpt
operator|+=
name|res
expr_stmt|;
name|size
operator|-=
name|res
expr_stmt|;
block|}
comment|/* 	 * if the last block has a file hole (all zero), we must make sure this 	 * gets updated in the file. We force the last block of zeros to be 	 * written. just closing with the file offset moved forward may not put 	 * a hole at the end of the file. 	 */
if|if
condition|(
name|isem
operator|&&
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|>
literal|0L
operator|)
condition|)
name|file_flush
argument_list|(
name|ofd
argument_list|,
name|fnm
argument_list|,
name|isem
argument_list|)
expr_stmt|;
comment|/* 	 * if we failed from archive read, we do not want to skip 	 */
if|if
condition|(
operator|(
name|size
operator|>
literal|0L
operator|)
operator|&&
operator|(
operator|*
name|left
operator|==
literal|0L
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * some formats record a crc on file data. If so, then we compare the 	 * calculated crc to the crc stored in the archive 	 */
if|if
condition|(
name|docrc
operator|&&
operator|(
name|size
operator|==
literal|0L
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|crc
operator|!=
name|crc
operator|)
condition|)
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Actual crc does not match expected crc %s"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cp_file()  *	copy the contents of one file to another. used during -rw phase of pax  *	just as in rd_wrfile() we use a special write function to write the  *	destination file so we can properly copy files with holes.  */
end_comment

begin_function
name|void
name|cp_file
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|,
name|int
name|fd1
parameter_list|,
name|int
name|fd2
parameter_list|)
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|off_t
name|cpcnt
init|=
literal|0L
decl_stmt|;
specifier|register
name|int
name|res
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|fnm
init|=
name|arcn
operator|->
name|name
decl_stmt|;
specifier|register
name|int
name|no_hole
init|=
literal|0
decl_stmt|;
name|int
name|isem
init|=
literal|1
decl_stmt|;
name|int
name|rem
decl_stmt|;
name|int
name|sz
init|=
name|MINFBSZ
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* 	 * check for holes in the source file. If none, we will use regular 	 * write instead of file write. 	 */
if|if
condition|(
operator|(
call|(
name|off_t
call|)
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_blocks
operator|*
name|BLKMULT
argument_list|)
operator|)
operator|>=
name|arcn
operator|->
name|sb
operator|.
name|st_size
condition|)
operator|++
name|no_hole
expr_stmt|;
comment|/* 	 * pass the blocksize of the file being written to the write routine, 	 * if the size is zero, use the default MINFBSZ 	 */
if|if
condition|(
name|fstat
argument_list|(
name|fd2
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|st_blksize
operator|>
literal|0
condition|)
name|sz
operator|=
name|sb
operator|.
name|st_blksize
expr_stmt|;
block|}
else|else
name|syswarn
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Unable to obtain block size for file %s"
argument_list|,
name|fnm
argument_list|)
expr_stmt|;
name|rem
operator|=
name|sz
expr_stmt|;
comment|/* 	 * read the source file and copy to destination file until EOF 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|cnt
operator|=
name|read
argument_list|(
name|fd1
argument_list|,
name|buf
argument_list|,
name|blksz
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|no_hole
condition|)
name|res
operator|=
name|write
argument_list|(
name|fd2
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|file_write
argument_list|(
name|fd2
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|,
operator|&
name|rem
argument_list|,
operator|&
name|isem
argument_list|,
name|sz
argument_list|,
name|fnm
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|cnt
condition|)
break|break;
name|cpcnt
operator|+=
name|cnt
expr_stmt|;
block|}
comment|/* 	 * check to make sure the copy is valid. 	 */
if|if
condition|(
name|res
operator|<
literal|0
condition|)
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed write during copy of %s to %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cpcnt
operator|!=
name|arcn
operator|->
name|sb
operator|.
name|st_size
condition|)
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File %s changed size during copy to %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fstat
argument_list|(
name|fd1
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed stat of %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|!=
name|sb
operator|.
name|st_mtime
condition|)
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File %s was modified during copy to %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * if the last block has a file hole (all zero), we must make sure this 	 * gets updated in the file. We force the last block of zeros to be 	 * written. just closing with the file offset moved forward may not put 	 * a hole at the end of the file. 	 */
if|if
condition|(
operator|!
name|no_hole
operator|&&
name|isem
operator|&&
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|>
literal|0L
operator|)
condition|)
name|file_flush
argument_list|(
name|fd2
argument_list|,
name|fnm
argument_list|,
name|isem
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * buf_fill()  *	fill the read buffer with the next record (or what we can get) from  *	the archive volume.  * Return:  *	Number of bytes of data in the read buffer, -1 for read error, and  *	0 when finished (user specified termination in ar_next()).  */
end_comment

begin_function
name|int
name|buf_fill
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|static
name|int
name|fini
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fini
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * try to fill the buffer. on error the next archive volume is 		 * opened and we try again. 		 */
if|if
condition|(
operator|(
name|cnt
operator|=
name|ar_read
argument_list|(
name|buf
argument_list|,
name|blksz
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|bufpt
operator|=
name|buf
expr_stmt|;
name|bufend
operator|=
name|buf
operator|+
name|cnt
expr_stmt|;
name|rdcnt
operator|+=
name|cnt
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
comment|/* 		 * errors require resync, EOF goes to next archive 		 */
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|ar_next
argument_list|()
operator|<
literal|0
condition|)
block|{
name|fini
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rdcnt
operator|=
literal|0
expr_stmt|;
block|}
name|exit_val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * buf_flush()  *	force the write buffer to the archive. We are passed the number of  *	bytes in the buffer at the point of the flush. When we change archives  *	the record size might change. (either larger or smaller).  * Return:  *	0 if all is ok, -1 when a write error occurs.  */
end_comment

begin_function
name|int
name|buf_flush
parameter_list|(
specifier|register
name|int
name|bufcnt
parameter_list|)
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|int
name|push
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|totcnt
init|=
literal|0
decl_stmt|;
comment|/* 	 * if we have reached the user specified byte count for each archive 	 * volume, prompt for the next volume. (The non-standrad -R flag). 	 * NOTE: If the wrlimit is smaller than wrcnt, we will always write 	 * at least one record. We always round limit UP to next blocksize. 	 */
if|if
condition|(
operator|(
name|wrlimit
operator|>
literal|0
operator|)
operator|&&
operator|(
name|wrcnt
operator|>
name|wrlimit
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"User specified archive volume byte limit reached."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar_next
argument_list|()
operator|<
literal|0
condition|)
block|{
name|wrcnt
operator|=
literal|0
expr_stmt|;
name|exit_val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|wrcnt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * The new archive volume might have changed the size of the 		 * write blocksize. if so we figure out if we need to write 		 * (one or more times), or if there is now free space left in 		 * the buffer (it is no longer full). bufcnt has the number of 		 * bytes in the buffer, (the blocksize, at the point we were 		 * CALLED). Push has the amount of "extra" data in the buffer 		 * if the block size has shrunk from a volume change. 		 */
name|bufend
operator|=
name|buf
operator|+
name|blksz
expr_stmt|;
if|if
condition|(
name|blksz
operator|>
name|bufcnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|blksz
operator|<
name|bufcnt
condition|)
name|push
operator|=
name|bufcnt
operator|-
name|blksz
expr_stmt|;
block|}
comment|/* 	 * We have enough data to write at least one archive block 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * write a block and check if it all went out ok 		 */
name|cnt
operator|=
name|ar_write
argument_list|(
name|buf
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|blksz
condition|)
block|{
comment|/* 			 * the write went ok 			 */
name|wrcnt
operator|+=
name|cnt
expr_stmt|;
name|totcnt
operator|+=
name|cnt
expr_stmt|;
if|if
condition|(
name|push
operator|>
literal|0
condition|)
block|{
comment|/* we have extra data to push to the front. 				 * check for more than 1 block of push, and if 				 * so we loop back to write again 				 */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|bufend
argument_list|,
name|push
argument_list|)
expr_stmt|;
name|bufpt
operator|=
name|buf
operator|+
name|push
expr_stmt|;
if|if
condition|(
name|push
operator|>=
name|blksz
condition|)
block|{
name|push
operator|-=
name|blksz
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|bufpt
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|totcnt
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Oh drat we got a partial write! 			 * if format doesnt care about alignment let it go, 			 * we warned the user in ar_write().... but this means 			 * the last record on this volume violates pax spec.... 			 */
name|totcnt
operator|+=
name|cnt
expr_stmt|;
name|wrcnt
operator|+=
name|cnt
expr_stmt|;
name|bufpt
operator|=
name|buf
operator|+
name|cnt
expr_stmt|;
name|cnt
operator|=
name|bufcnt
operator|-
name|cnt
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|bufpt
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|bufpt
operator|=
name|buf
operator|+
name|cnt
expr_stmt|;
if|if
condition|(
operator|!
name|frmt
operator|->
name|blkalgn
operator|||
operator|(
operator|(
name|cnt
operator|%
name|frmt
operator|->
name|blkalgn
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|totcnt
operator|)
return|;
break|break;
block|}
comment|/* 		 * All done, go to next archive 		 */
name|wrcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ar_next
argument_list|()
operator|<
literal|0
condition|)
break|break;
comment|/* 		 * The new archive volume might also have changed the block 		 * size. if so, figure out if we have too much or too little 		 * data for using the new block size 		 */
name|bufend
operator|=
name|buf
operator|+
name|blksz
expr_stmt|;
if|if
condition|(
name|blksz
operator|>
name|bufcnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|blksz
operator|<
name|bufcnt
condition|)
name|push
operator|=
name|bufcnt
operator|-
name|blksz
expr_stmt|;
block|}
comment|/* 	 * write failed, stop pax. we must not create a bad archive! 	 */
name|exit_val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

