begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Keith Muller.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Keith Muller of the University of California, San Diego.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: tables.c,v 1.4.2.3 1997/09/14 13:07:34 jkh Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
specifier|const
name|sccsid
index|[]
init|=
literal|"@(#)tables.c	8.1 (Berkeley) 5/31/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pax.h"
end_include

begin_include
include|#
directive|include
file|"tables.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * Routines for controlling the contents of all the different databases pax  * keeps. Tables are dynamically created only when they are needed. The  * goal was speed and the ability to work with HUGE archives. The databases  * were kept simple, but do have complex rules for when the contents change.  * As of this writing, the posix library functions were more complex than  * needed for this application (pax databases have very short lifetimes and  * do not survive after pax is finished). Pax is required to handle very  * large archives. These database routines carefully combine memory usage and  * temporary file storage in ways which will not significantly impact runtime  * performance while allowing the largest possible archives to be handled.  * Trying to force the fit to the posix databases routines was not considered  * time well spent.  */
end_comment

begin_decl_stmt
specifier|static
name|HRDLNK
modifier|*
modifier|*
name|ltab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hard link table for detecting hard links */
end_comment

begin_decl_stmt
specifier|static
name|FTM
modifier|*
modifier|*
name|ftab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file time table for updating arch */
end_comment

begin_decl_stmt
specifier|static
name|NAMT
modifier|*
modifier|*
name|ntab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interactive rename storage table */
end_comment

begin_decl_stmt
specifier|static
name|DEVT
modifier|*
modifier|*
name|dtab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device/inode mapping tables */
end_comment

begin_decl_stmt
specifier|static
name|ATDIR
modifier|*
modifier|*
name|atab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file tree directory time reset table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dirfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* storage for setting created dir time/mode */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|dircnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* entries in dir time/mode storage */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ffd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tmp file for file time table name storage */
end_comment

begin_decl_stmt
specifier|static
name|DEVT
modifier|*
name|chk_dev
name|__P
argument_list|(
operator|(
name|dev_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * hard link table routines  *  * The hard link table tries to detect hard links to files using the device and  * inode values. We do this when writing an archive, so we can tell the format  * write routine that this file is a hard link to another file. The format  * write routine then can store this file in whatever way it wants (as a hard  * link if the format supports that like tar, or ignore this info like cpio).  * (Actually a field in the format driver table tells us if the format wants  * hard link info. if not, we do not waste time looking for them). We also use  * the same table when reading an archive. In that situation, this table is  * used by the format read routine to detect hard links from stored dev and  * inode numbers (like cpio). This will allow pax to create a link when one  * can be detected by the archive format.  */
end_comment

begin_comment
comment|/*  * lnk_start  *	Creates the hard link table.  * Return:  *	0 if created, -1 if failure  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|lnk_start
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|int
name|lnk_start
argument_list|()
endif|#
directive|endif
block|{
if|if
condition|(
name|ltab
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|ltab
operator|=
operator|(
name|HRDLNK
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|L_TAB_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|HRDLNK
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Cannot allocate memory for hard link table"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * chk_lnk()  *	Looks up entry in hard link hash table. If found, it copies the name  *	of the file it is linked to (we already saw that file) into ln_name.  *	lnkcnt is decremented and if goes to 1 the node is deleted from the  *	database. (We have seen all the links to this file). If not found,  *	we add the file to the database if it has the potential for having  *	hard links to other files we may process (it has a link count> 1)  * Return:  *	if found returns 1; if not found returns 0; -1 on error  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|chk_lnk
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|)
else|#
directive|else
name|int
name|chk_lnk
argument_list|(
name|arcn
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|HRDLNK
modifier|*
name|pt
decl_stmt|;
specifier|register
name|HRDLNK
modifier|*
modifier|*
name|ppt
decl_stmt|;
specifier|register
name|u_int
name|indx
decl_stmt|;
if|if
condition|(
name|ltab
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * ignore those nodes that cannot have hard links 	 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_DIR
operator|)
operator|||
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|<=
literal|1
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * hash inode number and look for this file 	 */
name|indx
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|)
operator|%
name|L_TAB_SZ
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|=
name|ltab
index|[
name|indx
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * it's hash chain in not empty, walk down looking for it 		 */
name|ppt
operator|=
operator|&
operator|(
name|ltab
index|[
name|indx
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|ino
operator|==
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|)
operator|&&
operator|(
name|pt
operator|->
name|dev
operator|==
name|arcn
operator|->
name|sb
operator|.
name|st_dev
operator|)
condition|)
break|break;
name|ppt
operator|=
operator|&
operator|(
name|pt
operator|->
name|fow
operator|)
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
block|}
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * found a link. set the node type and copy in the 			 * name of the file it is to link to. we need to 			 * handle hardlinks to regular files differently than 			 * other links. 			 */
name|arcn
operator|->
name|ln_nlen
operator|=
name|l_strncpy
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
name|pt
operator|->
name|name
argument_list|,
name|PAXPATHLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|ln_name
index|[
name|PAXPATHLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|type
operator|==
name|PAX_REG
condition|)
name|arcn
operator|->
name|type
operator|=
name|PAX_HRG
expr_stmt|;
else|else
name|arcn
operator|->
name|type
operator|=
name|PAX_HLK
expr_stmt|;
comment|/* 			 * if we have found all the links to this file, remove 			 * it from the database 			 */
if|if
condition|(
operator|--
name|pt
operator|->
name|nlink
operator|<=
literal|1
condition|)
block|{
operator|*
name|ppt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * we never saw this file before. It has links so we add it to the 	 * front of this hash chain 	 */
if|if
condition|(
operator|(
name|pt
operator|=
operator|(
name|HRDLNK
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HRDLNK
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|arcn
operator|->
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pt
operator|->
name|dev
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_dev
expr_stmt|;
name|pt
operator|->
name|ino
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_ino
expr_stmt|;
name|pt
operator|->
name|nlink
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
expr_stmt|;
name|pt
operator|->
name|fow
operator|=
name|ltab
index|[
name|indx
index|]
expr_stmt|;
name|ltab
index|[
name|indx
index|]
operator|=
name|pt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
block|}
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Hard link table out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * purg_lnk  *	remove reference for a file that we may have added to the data base as  *	a potential source for hard links. We ended up not using the file, so  *	we do not want to accidently point another file at it later on.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|purg_lnk
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|)
else|#
directive|else
name|void
name|purg_lnk
argument_list|(
name|arcn
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|HRDLNK
modifier|*
name|pt
decl_stmt|;
specifier|register
name|HRDLNK
modifier|*
modifier|*
name|ppt
decl_stmt|;
specifier|register
name|u_int
name|indx
decl_stmt|;
if|if
condition|(
name|ltab
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * do not bother to look if it could not be in the database 	 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|<=
literal|1
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_DIR
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HLK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
condition|)
return|return;
comment|/* 	 * find the hash chain for this inode value, if empty return 	 */
name|indx
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|)
operator|%
name|L_TAB_SZ
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|=
name|ltab
index|[
name|indx
index|]
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * walk down the list looking for the inode/dev pair, unlink and 	 * free if found 	 */
name|ppt
operator|=
operator|&
operator|(
name|ltab
index|[
name|indx
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|ino
operator|==
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|)
operator|&&
operator|(
name|pt
operator|->
name|dev
operator|==
name|arcn
operator|->
name|sb
operator|.
name|st_dev
operator|)
condition|)
break|break;
name|ppt
operator|=
operator|&
operator|(
name|pt
operator|->
name|fow
operator|)
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
block|}
if|if
condition|(
name|pt
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * remove and free it 	 */
operator|*
name|ppt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * lnk_end()  *	pull apart a existing link table so we can reuse it. We do this between  *	read and write phases of append with update. (The format may have  *	used the link table, and we need to start with a fresh table for the  *	write phase  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|lnk_end
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|void
name|lnk_end
argument_list|()
endif|#
directive|endif
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|HRDLNK
modifier|*
name|pt
decl_stmt|;
specifier|register
name|HRDLNK
modifier|*
name|ppt
decl_stmt|;
if|if
condition|(
name|ltab
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|L_TAB_SZ
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ltab
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|pt
operator|=
name|ltab
index|[
name|i
index|]
expr_stmt|;
name|ltab
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * free up each entry on this chain 		 */
while|while
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|ppt
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|ppt
operator|->
name|fow
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ppt
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ppt
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_decl_stmt

begin_comment
comment|/*  * modification time table routines  *  * The modification time table keeps track of last modification times for all  * files stored in an archive during a write phase when -u is set. We only  * add a file to the archive if it is newer than a file with the same name  * already stored on the archive (if there is no other file with the same  * name on the archive it is added). This applies to writes and appends.  * An append with an -u must read the archive and store the modification time  * for every file on that archive before starting the write phase. It is clear  * that this is one HUGE database. To save memory space, the actual file names  * are stored in a scatch file and indexed by an in memory hash table. The  * hash table is indexed by hashing the file path. The nodes in the table store  * the length of the filename and the lseek offset within the scratch file  * where the actual name is stored. Since there are never any deletions to this  * table, fragmentation of the scratch file is never a issue. Lookups seem to  * not exhibit any locality at all (files in the database are rarely  * looked up more than once...). So caching is just a waste of memory. The  * only limitation is the amount of scatch file space available to store the  * path names.  */
end_comment

begin_comment
comment|/*  * ftime_start()  *	create the file time hash table and open for read/write the scratch  *	file. (after created it is unlinked, so when we exit we leave  *	no witnesses).  * Return:  *	0 if the table and file was created ok, -1 otherwise  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|ftime_start
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|int
name|ftime_start
argument_list|()
endif|#
directive|endif
block|{
name|char
modifier|*
name|pt
decl_stmt|;
if|if
condition|(
name|ftab
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|ftab
operator|=
operator|(
name|FTM
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|F_TAB_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|FTM
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Cannot allocate memory for file time table"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * get random name and create temporary scratch file, unlink name 	 * so it will get removed on exit 	 */
if|if
condition|(
operator|(
name|pt
operator|=
name|tempnam
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffd
operator|=
name|open
argument_list|(
name|pt
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
name|S_IRWXU
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to open temporary file: %s"
argument_list|,
name|pt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|pt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * chk_ftime()  *	looks up entry in file time hash table. If not found, the file is  *	added to the hash table and the file named stored in the scratch file.  *	If a file with the same name is found, the file times are compared and  *	the most recent file time is retained. If the new file was younger (or  *	was not in the database) the new file is selected for storage.  * Return:  *	0 if file should be added to the archive, 1 if it should be skipped,  *	-1 on error  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|chk_ftime
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|)
else|#
directive|else
name|int
name|chk_ftime
argument_list|(
name|arcn
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|FTM
modifier|*
name|pt
decl_stmt|;
specifier|register
name|int
name|namelen
decl_stmt|;
specifier|register
name|u_int
name|indx
decl_stmt|;
name|char
name|ckname
index|[
name|PAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * no info, go ahead and add to archive 	 */
if|if
condition|(
name|ftab
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * hash the pathname and look up in table 	 */
name|namelen
operator|=
name|arcn
operator|->
name|nlen
expr_stmt|;
name|indx
operator|=
name|st_hash
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|namelen
argument_list|,
name|F_TAB_SZ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|=
name|ftab
index|[
name|indx
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * the hash chain is not empty, walk down looking for match 		 * only read up the path names if the lengths match, speeds 		 * up the search a lot 		 */
while|while
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|namelen
operator|==
name|namelen
condition|)
block|{
comment|/* 				 * potential match, have to read the name 				 * from the scratch file. 				 */
if|if
condition|(
name|lseek
argument_list|(
name|ffd
argument_list|,
name|pt
operator|->
name|seek
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|pt
operator|->
name|seek
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed ftime table seek"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|ffd
argument_list|,
name|ckname
argument_list|,
name|namelen
argument_list|)
operator|!=
name|namelen
condition|)
block|{
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed ftime table read"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 				 * if the names match, we are done 				 */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ckname
argument_list|,
name|arcn
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
condition|)
break|break;
block|}
comment|/* 			 * try the next entry on the chain 			 */
name|pt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
block|}
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * found the file, compare the times, save the newer 			 */
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|>
name|pt
operator|->
name|mtime
condition|)
block|{
comment|/* 				 * file is newer 				 */
name|pt
operator|->
name|mtime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * file is older 			 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * not in table, add it 	 */
if|if
condition|(
operator|(
name|pt
operator|=
operator|(
name|FTM
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FTM
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * add the name at the end of the scratch file, saving the 		 * offset. add the file to the head of the hash chain 		 */
if|if
condition|(
operator|(
name|pt
operator|->
name|seek
operator|=
name|lseek
argument_list|(
name|ffd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|ffd
argument_list|,
name|arcn
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
operator|==
name|namelen
condition|)
block|{
name|pt
operator|->
name|mtime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
expr_stmt|;
name|pt
operator|->
name|namelen
operator|=
name|namelen
expr_stmt|;
name|pt
operator|->
name|fow
operator|=
name|ftab
index|[
name|indx
index|]
expr_stmt|;
name|ftab
index|[
name|indx
index|]
operator|=
name|pt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed write to file time table"
argument_list|)
expr_stmt|;
block|}
else|else
name|sys_warn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed seek on file time table"
argument_list|)
expr_stmt|;
block|}
else|else
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"File time table ran out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interactive rename table routines  *  * The interactive rename table keeps track of the new names that the user  * assignes to files from tty input. Since this map is unique for each file  * we must store it in case there is a reference to the file later in archive  * (a link). Otherwise we will be unable to find the file we know was  * extracted. The remapping of these files is stored in a memory based hash  * table (it is assumed since input must come from /dev/tty, it is unlikely to  * be a very large table).  */
end_comment

begin_comment
comment|/*  * name_start()  *	create the interactive rename table  * Return:  *	0 if successful, -1 otherwise  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|name_start
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|int
name|name_start
argument_list|()
endif|#
directive|endif
block|{
if|if
condition|(
name|ntab
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|ntab
operator|=
operator|(
name|NAMT
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|N_TAB_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|NAMT
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Cannot allocate memory for interactive rename table"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * add_name()  *	add the new name to old name mapping just created by the user.  *	If an old name mapping is found (there may be duplicate names on an  *	archive) only the most recent is kept.  * Return:  *	0 if added, -1 otherwise  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|add_name
argument_list|(
specifier|register
name|char
operator|*
name|oname
argument_list|,
name|int
name|onamelen
argument_list|,
name|char
operator|*
name|nname
argument_list|)
else|#
directive|else
name|int
name|add_name
argument_list|(
name|oname
argument_list|,
name|onamelen
argument_list|,
name|nname
argument_list|)
decl|register
name|char
modifier|*
name|oname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|onamelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|nname
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|NAMT
modifier|*
name|pt
decl_stmt|;
specifier|register
name|u_int
name|indx
decl_stmt|;
if|if
condition|(
name|ntab
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * should never happen 		 */
name|pax_warn
argument_list|(
literal|0
argument_list|,
literal|"No interactive rename table, links may fail\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * look to see if we have already mapped this file, if so we 	 * will update it 	 */
name|indx
operator|=
name|st_hash
argument_list|(
name|oname
argument_list|,
name|onamelen
argument_list|,
name|N_TAB_SZ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|=
name|ntab
index|[
name|indx
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * look down the has chain for the file 		 */
while|while
condition|(
operator|(
name|pt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|oname
argument_list|,
name|pt
operator|->
name|oname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|pt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * found an old mapping, replace it with the new one 			 * the user just input (if it is different) 			 */
if|if
condition|(
name|strcmp
argument_list|(
name|nname
argument_list|,
name|pt
operator|->
name|nname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
operator|->
name|nname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|->
name|nname
operator|=
name|strdup
argument_list|(
name|nname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Cannot update rename table"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * this is a new mapping, add it to the table 	 */
if|if
condition|(
operator|(
name|pt
operator|=
operator|(
name|NAMT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NAMT
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|oname
operator|=
name|strdup
argument_list|(
name|oname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|nname
operator|=
name|strdup
argument_list|(
name|nname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pt
operator|->
name|fow
operator|=
name|ntab
index|[
name|indx
index|]
expr_stmt|;
name|ntab
index|[
name|indx
index|]
operator|=
name|pt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
operator|->
name|oname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
block|}
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Interactive rename table out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * sub_name()  *	look up a link name to see if it points at a file that has been  *	remapped by the user. If found, the link is adjusted to contain the  *	new name (oname is the link to name)  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|sub_name
argument_list|(
specifier|register
name|char
operator|*
name|oname
argument_list|,
name|int
operator|*
name|onamelen
argument_list|)
else|#
directive|else
name|void
name|sub_name
argument_list|(
name|oname
argument_list|,
name|onamelen
argument_list|)
decl|register
name|char
modifier|*
name|oname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|onamelen
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|NAMT
modifier|*
name|pt
decl_stmt|;
specifier|register
name|u_int
name|indx
decl_stmt|;
if|if
condition|(
name|ntab
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * look the name up in the hash table 	 */
name|indx
operator|=
name|st_hash
argument_list|(
name|oname
argument_list|,
operator|*
name|onamelen
argument_list|,
name|N_TAB_SZ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|=
name|ntab
index|[
name|indx
index|]
operator|)
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * walk down the hash cahin looking for a match 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|oname
argument_list|,
name|pt
operator|->
name|oname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * found it, replace it with the new name 			 * and return (we know that oname has enough space) 			 */
operator|*
name|onamelen
operator|=
name|l_strncpy
argument_list|(
name|oname
argument_list|,
name|pt
operator|->
name|nname
argument_list|,
name|PAXPATHLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|oname
index|[
name|PAXPATHLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|pt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
block|}
comment|/* 	 * no match, just return 	 */
return|return;
block|}
end_block

begin_comment
comment|/*  * device/inode mapping table routines  * (used with formats that store device and inodes fields)  *  * device/inode mapping tables remap the device field in a archive header. The  * device/inode fields are used to determine when files are hard links to each  * other. However these values have very little meaning outside of that. This  * database is used to solve one of two different problems.  *  * 1) when files are appended to an archive, while the new files may have hard  * links to each other, you cannot determine if they have hard links to any  * file already stored on the archive from a prior run of pax. We must assume  * that these inode/device pairs are unique only within a SINGLE run of pax  * (which adds a set of files to an archive). So we have to make sure the  * inode/dev pairs we add each time are always unique. We do this by observing  * while the inode field is very dense, the use of the dev field is fairly  * sparse. Within each run of pax, we remap any device number of a new archive  * member that has a device number used in a prior run and already stored in a  * file on the archive. During the read phase of the append, we store the  * device numbers used and mark them to not be used by any file during the  * write phase. If during write we go to use one of those old device numbers,  * we remap it to a new value.  *  * 2) Often the fields in the archive header used to store these values are  * too small to store the entire value. The result is an inode or device value  * which can be truncated. This really can foul up an archive. With truncation  * we end up creating links between files that are really not links (after  * truncation the inodes are the same value). We address that by detecting  * truncation and forcing a remap of the device field to split truncated  * inodes away from each other. Each truncation creates a pattern of bits that  * are removed. We use this pattern of truncated bits to partition the inodes  * on a single device to many different devices (each one represented by the  * truncated bit pattern). All inodes on the same device that have the same  * truncation pattern are mapped to the same new device. Two inodes that  * truncate to the same value clearly will always have different truncation  * bit patterns, so they will be split from away each other. When we spot  * device truncation we remap the device number to a non truncated value.  * (for more info see table.h for the data structures involved).  */
end_comment

begin_comment
comment|/*  * dev_start()  *	create the device mapping table  * Return:  *	0 if successful, -1 otherwise  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|dev_start
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|int
name|dev_start
argument_list|()
endif|#
directive|endif
block|{
if|if
condition|(
name|dtab
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|dtab
operator|=
operator|(
name|DEVT
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|D_TAB_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|DEVT
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Cannot allocate memory for device mapping table"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * add_dev()  *	add a device number to the table. this will force the device to be  *	remapped to a new value if it be used during a write phase. This  *	function is called during the read phase of an append to prohibit the  *	use of any device number already in the archive.  * Return:  *	0 if added ok, -1 otherwise  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|add_dev
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|)
else|#
directive|else
name|int
name|add_dev
argument_list|(
name|arcn
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
name|chk_dev
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_dev
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * chk_dev()  *	check for a device value in the device table. If not found and the add  *	flag is set, it is added. This does NOT assign any mapping values, just  *	adds the device number as one that need to be remapped. If this device  *	is alread mapped, just return with a pointer to that entry.  * Return:  *	pointer to the entry for this device in the device map table. Null  *	if the add flag is not set and the device is not in the table (it is  *	not been seen yet). If add is set and the device cannot be added, null  *	is returned (indicates an error).  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
specifier|static
name|DEVT
modifier|*
name|chk_dev
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|add
parameter_list|)
else|#
directive|else
function|static DEVT * chk_dev
parameter_list|(
name|dev
parameter_list|,
name|add
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|add
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|DEVT
modifier|*
name|pt
decl_stmt|;
specifier|register
name|u_int
name|indx
decl_stmt|;
if|if
condition|(
name|dtab
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * look to see if this device is already in the table 	 */
name|indx
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|dev
operator|)
operator|%
name|D_TAB_SZ
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|=
name|dtab
index|[
name|indx
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|pt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pt
operator|->
name|dev
operator|!=
name|dev
operator|)
condition|)
name|pt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
comment|/* 		 * found it, return a pointer to it 		 */
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pt
operator|)
return|;
block|}
comment|/* 	 * not in table, we add it only if told to as this may just be a check 	 * to see if a device number is being used. 	 */
if|if
condition|(
name|add
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * allocate a node for this device and add it to the front of the hash 	 * chain. Note we do not assign remaps values here, so the pt->list 	 * list must be NULL. 	 */
if|if
condition|(
operator|(
name|pt
operator|=
operator|(
name|DEVT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DEVT
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Device map table out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|pt
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|pt
operator|->
name|list
operator|=
name|NULL
expr_stmt|;
name|pt
operator|->
name|fow
operator|=
name|dtab
index|[
name|indx
index|]
expr_stmt|;
name|dtab
index|[
name|indx
index|]
operator|=
name|pt
expr_stmt|;
return|return
operator|(
name|pt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * map_dev()  *	given an inode and device storage mask (the mask has a 1 for each bit  *	the archive format is able to store in a header), we check for inode  *	and device truncation and remap the device as required. Device mapping  *	can also occur when during the read phase of append a device number was  *	seen (and was marked as do not use during the write phase). WE ASSUME  *	that unsigned longs are the same size or bigger than the fields used  *	for ino_t and dev_t. If not the types will have to be changed.  * Return:  *	0 if all ok, -1 otherwise.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|map_dev
argument_list|(
specifier|register
name|ARCHD
operator|*
name|arcn
argument_list|,
name|u_long
name|dev_mask
argument_list|,
name|u_long
name|ino_mask
argument_list|)
else|#
directive|else
name|int
name|map_dev
argument_list|(
name|arcn
argument_list|,
name|dev_mask
argument_list|,
name|ino_mask
argument_list|)
decl|register
name|ARCHD
modifier|*
name|arcn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|dev_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|ino_mask
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|DEVT
modifier|*
name|pt
decl_stmt|;
specifier|register
name|DLIST
modifier|*
name|dpt
decl_stmt|;
specifier|static
name|dev_t
name|lastdev
init|=
literal|0
decl_stmt|;
comment|/* next device number to try */
name|int
name|trc_ino
init|=
literal|0
decl_stmt|;
name|int
name|trc_dev
init|=
literal|0
decl_stmt|;
name|ino_t
name|trunc_bits
init|=
literal|0
decl_stmt|;
name|ino_t
name|nino
decl_stmt|;
if|if
condition|(
name|dtab
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * check for device and inode truncation, and extract the truncated 	 * bit pattern. 	 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_dev
operator|&
operator|(
name|dev_t
operator|)
name|dev_mask
operator|)
operator|!=
name|arcn
operator|->
name|sb
operator|.
name|st_dev
condition|)
operator|++
name|trc_dev
expr_stmt|;
if|if
condition|(
operator|(
name|nino
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|&
operator|(
name|ino_t
operator|)
name|ino_mask
operator|)
operator|!=
name|arcn
operator|->
name|sb
operator|.
name|st_ino
condition|)
block|{
operator|++
name|trc_ino
expr_stmt|;
name|trunc_bits
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|&
call|(
name|ino_t
call|)
argument_list|(
operator|~
name|ino_mask
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * see if this device is already being mapped, look up the device 	 * then find the truncation bit pattern which applies 	 */
if|if
condition|(
operator|(
name|pt
operator|=
name|chk_dev
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_dev
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * this device is already marked to be remapped 		 */
for|for
control|(
name|dpt
operator|=
name|pt
operator|->
name|list
init|;
name|dpt
operator|!=
name|NULL
condition|;
name|dpt
operator|=
name|dpt
operator|->
name|fow
control|)
if|if
condition|(
name|dpt
operator|->
name|trunc_bits
operator|==
name|trunc_bits
condition|)
break|break;
if|if
condition|(
name|dpt
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * we are being remapped for this device and pattern 			 * change the device number to be stored and return 			 */
name|arcn
operator|->
name|sb
operator|.
name|st_dev
operator|=
name|dpt
operator|->
name|dev
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|=
name|nino
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * this device is not being remapped YET. if we do not have any 		 * form of truncation, we do not need a remap 		 */
if|if
condition|(
operator|!
name|trc_ino
operator|&&
operator|!
name|trc_dev
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * we have truncation, have to add this as a device to remap 		 */
if|if
condition|(
operator|(
name|pt
operator|=
name|chk_dev
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_dev
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* 		 * if we just have a truncated inode, we have to make sure that 		 * all future inodes that do not truncate (they have the 		 * truncation pattern of all 0's) continue to map to the same 		 * device number. We probably have already written inodes with 		 * this device number to the archive with the truncation 		 * pattern of all 0's. So we add the mapping for all 0's to the 		 * same device number. 		 */
if|if
condition|(
operator|!
name|trc_dev
operator|&&
operator|(
name|trunc_bits
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|dpt
operator|=
operator|(
name|DLIST
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DLIST
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|dpt
operator|->
name|trunc_bits
operator|=
literal|0
expr_stmt|;
name|dpt
operator|->
name|dev
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_dev
expr_stmt|;
name|dpt
operator|->
name|fow
operator|=
name|pt
operator|->
name|list
expr_stmt|;
name|pt
operator|->
name|list
operator|=
name|dpt
expr_stmt|;
block|}
block|}
comment|/* 	 * look for a device number not being used. We must watch for wrap 	 * around on lastdev (so we do not get stuck looking forever!) 	 */
while|while
condition|(
operator|++
name|lastdev
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|chk_dev
argument_list|(
name|lastdev
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
comment|/* 		 * found an unused value. If we have reached truncation point 		 * for this format we are hosed, so we give up. Otherwise we 		 * mark it as being used. 		 */
if|if
condition|(
operator|(
operator|(
name|lastdev
operator|&
operator|(
operator|(
name|dev_t
operator|)
name|dev_mask
operator|)
operator|)
operator|!=
name|lastdev
operator|)
operator|||
operator|(
name|chk_dev
argument_list|(
name|lastdev
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|bad
goto|;
break|break;
block|}
if|if
condition|(
operator|(
name|lastdev
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|(
name|dpt
operator|=
operator|(
name|DLIST
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DLIST
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * got a new device number, store it under this truncation pattern. 	 * change the device number this file is being stored with. 	 */
name|dpt
operator|->
name|trunc_bits
operator|=
name|trunc_bits
expr_stmt|;
name|dpt
operator|->
name|dev
operator|=
name|lastdev
expr_stmt|;
name|dpt
operator|->
name|fow
operator|=
name|pt
operator|->
name|list
expr_stmt|;
name|pt
operator|->
name|list
operator|=
name|dpt
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_dev
operator|=
name|lastdev
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|=
name|nino
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Unable to fix truncated inode/device field when storing %s"
argument_list|,
name|arcn
operator|->
name|name
argument_list|)
expr_stmt|;
name|pax_warn
argument_list|(
literal|0
argument_list|,
literal|"Archive may create improper hard links when extracted"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * directory access/mod time reset table routines (for directories READ by pax)  *  * The pax -t flag requires that access times of archive files to be the same  * before being read by pax. For regular files, access time is restored after  * the file has been copied. This database provides the same functionality for  * directories read during file tree traversal. Restoring directory access time  * is more complex than files since directories may be read several times until  * all the descendants in their subtree are visited by fts. Directory access  * and modification times are stored during the fts pre-order visit (done  * before any descendants in the subtree is visited) and restored after the  * fts post-order visit (after all the descendants have been visited). In the  * case of premature exit from a subtree (like from the effects of -n), any  * directory entries left in this database are reset during final cleanup  * operations of pax. Entries are hashed by inode number for fast lookup.  */
end_comment

begin_comment
comment|/*  * atdir_start()  *	create the directory access time database for directories READ by pax.  * Return:  *	0 is created ok, -1 otherwise.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|atdir_start
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|int
name|atdir_start
argument_list|()
endif|#
directive|endif
block|{
if|if
condition|(
name|atab
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|atab
operator|=
operator|(
name|ATDIR
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|A_TAB_SZ
argument_list|,
sizeof|sizeof
argument_list|(
name|ATDIR
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Cannot allocate space for directory access time table"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * atdir_end()  *	walk through the directory access time table and reset the access time  *	of any directory who still has an entry left in the database. These  *	entries are for directories READ by pax  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|atdir_end
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|void
name|atdir_end
argument_list|()
endif|#
directive|endif
block|{
specifier|register
name|ATDIR
modifier|*
name|pt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|atab
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * for each non-empty hash table entry reset all the directories 	 * chained there. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|A_TAB_SZ
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|pt
operator|=
name|atab
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * remember to force the times, set_ftime() looks at pmtime 		 * and patime, which only applies to things CREATED by pax, 		 * not read by pax. Read time reset is controlled by -t. 		 */
for|for
control|(
init|;
name|pt
operator|!=
name|NULL
condition|;
name|pt
operator|=
name|pt
operator|->
name|fow
control|)
name|set_ftime
argument_list|(
name|pt
operator|->
name|name
argument_list|,
name|pt
operator|->
name|mtime
argument_list|,
name|pt
operator|->
name|atime
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/*  * add_atdir()  *	add a directory to the directory access time table. Table is hashed  *	and chained by inode number. This is for directories READ by pax  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|void
name|add_atdir
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|time_t
name|mtime
parameter_list|,
name|time_t
name|atime
parameter_list|)
else|#
directive|else
function|void add_atdir
parameter_list|(
name|fname
parameter_list|,
name|dev
parameter_list|,
name|ino
parameter_list|,
name|mtime
parameter_list|,
name|atime
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|time_t
name|atime
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|ATDIR
modifier|*
name|pt
decl_stmt|;
specifier|register
name|u_int
name|indx
decl_stmt|;
if|if
condition|(
name|atab
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * make sure this directory is not already in the table, if so just 	 * return (the older entry always has the correct time). The only 	 * way this will happen is when the same subtree can be traversed by 	 * different args to pax and the -n option is aborting fts out of a 	 * subtree before all the post-order visits have been made). 	 */
name|indx
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|ino
operator|)
operator|%
name|A_TAB_SZ
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|=
name|atab
index|[
name|indx
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|ino
operator|==
name|ino
operator|)
operator|&&
operator|(
name|pt
operator|->
name|dev
operator|==
name|dev
operator|)
condition|)
break|break;
name|pt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
block|}
comment|/* 		 * oops, already there. Leave it alone. 		 */
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
return|return;
block|}
comment|/* 	 * add it to the front of the hash chain 	 */
if|if
condition|(
operator|(
name|pt
operator|=
operator|(
name|ATDIR
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ATDIR
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|fname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pt
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|pt
operator|->
name|ino
operator|=
name|ino
expr_stmt|;
name|pt
operator|->
name|mtime
operator|=
name|mtime
expr_stmt|;
name|pt
operator|->
name|atime
operator|=
name|atime
expr_stmt|;
name|pt
operator|->
name|fow
operator|=
name|atab
index|[
name|indx
index|]
expr_stmt|;
name|atab
index|[
name|indx
index|]
operator|=
name|pt
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
block|}
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Directory access time reset table ran out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * get_atdir()  *	look up a directory by inode and device number to obtain the access  *	and modification time you want to set to. If found, the modification  *	and access time parameters are set and the entry is removed from the  *	table (as it is no longer needed). These are for directories READ by  *	pax  * Return:  *	0 if found, -1 if not found.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|int
name|get_atdir
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|time_t
modifier|*
name|mtime
parameter_list|,
name|time_t
modifier|*
name|atime
parameter_list|)
else|#
directive|else
function|int get_atdir
parameter_list|(
name|dev
parameter_list|,
name|ino
parameter_list|,
name|mtime
parameter_list|,
name|atime
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|time_t
modifier|*
name|mtime
decl_stmt|;
name|time_t
modifier|*
name|atime
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|ATDIR
modifier|*
name|pt
decl_stmt|;
specifier|register
name|ATDIR
modifier|*
modifier|*
name|ppt
decl_stmt|;
specifier|register
name|u_int
name|indx
decl_stmt|;
if|if
condition|(
name|atab
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * hash by inode and search the chain for an inode and device match 	 */
name|indx
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|ino
operator|)
operator|%
name|A_TAB_SZ
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|=
name|atab
index|[
name|indx
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ppt
operator|=
operator|&
operator|(
name|atab
index|[
name|indx
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pt
operator|->
name|ino
operator|==
name|ino
operator|)
operator|&&
operator|(
name|pt
operator|->
name|dev
operator|==
name|dev
operator|)
condition|)
break|break;
comment|/* 		 * no match, go to next one 		 */
name|ppt
operator|=
operator|&
operator|(
name|pt
operator|->
name|fow
operator|)
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
block|}
comment|/* 	 * return if we did not find it. 	 */
if|if
condition|(
name|pt
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * found it. return the times and remove the entry from the table. 	 */
operator|*
name|ppt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
operator|*
name|mtime
operator|=
name|pt
operator|->
name|mtime
expr_stmt|;
operator|*
name|atime
operator|=
name|pt
operator|->
name|atime
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * directory access mode and time storage routines (for directories CREATED  * by pax).  *  * Pax requires that extracted directories, by default, have their access/mod  * times and permissions set to the values specified in the archive. During the  * actions of extracting (and creating the destination subtree during -rw copy)  * directories extracted may be modified after being created. Even worse is  * that these directories may have been created with file permissions which  * prohibits any descendants of these directories from being extracted. When  * directories are created by pax, access rights may be added to permit the  * creation of files in their subtree. Every time pax creates a directory, the  * times and file permissions specified by the archive are stored. After all  * files have been extracted (or copied), these directories have their times  * and file modes reset to the stored values. The directory info is restored in  * reverse order as entries were added to the data file from root to leaf. To  * restore atime properly, we must go backwards. The data file consists of  * records with two parts, the file name followed by a DIRDATA trailer. The  * fixed sized trailer contains the size of the name plus the off_t location in  * the file. To restore we work backwards through the file reading the trailer  * then the file name.  */
end_comment

begin_comment
comment|/*  * dir_start()  *	set up the directory time and file mode storage for directories CREATED  *	by pax.  * Return:  *	0 if ok, -1 otherwise  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|dir_start
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|int
name|dir_start
argument_list|()
endif|#
directive|endif
block|{
name|char
modifier|*
name|pt
decl_stmt|;
if|if
condition|(
name|dirfd
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|pt
operator|=
name|tempnam
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * unlink the file so it goes away at termination by itself 	 */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dirfd
operator|=
name|open
argument_list|(
name|pt
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|pt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Unable to create temporary file for directory times: %s"
argument_list|,
name|pt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * add_dir()  *	add the mode and times for a newly CREATED directory  *	name is name of the directory, psb the stat buffer with the data in it,  *	frc_mode is a flag that says whether to force the setting of the mode  *	(ignoring the user set values for preserving file mode). Frc_mode is  *	for the case where we created a file and found that the resulting  *	directory was not writeable and the user asked for file modes to NOT  *	be preserved. (we have to preserve what was created by default, so we  *	have to force the setting at the end. this is stated explicitly in the  *	pax spec)  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|void
name|add_dir
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nlen
parameter_list|,
name|struct
name|stat
modifier|*
name|psb
parameter_list|,
name|int
name|frc_mode
parameter_list|)
else|#
directive|else
function|void add_dir
parameter_list|(
name|name
parameter_list|,
name|nlen
parameter_list|,
name|psb
parameter_list|,
name|frc_mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|nlen
decl_stmt|;
name|struct
name|stat
modifier|*
name|psb
decl_stmt|;
name|int
name|frc_mode
decl_stmt|;
endif|#
directive|endif
block|{
name|DIRDATA
name|dblk
decl_stmt|;
if|if
condition|(
name|dirfd
operator|<
literal|0
condition|)
return|return;
comment|/* 	 * get current position (where file name will start) so we can store it 	 * in the trailer 	 */
if|if
condition|(
operator|(
name|dblk
operator|.
name|npos
operator|=
name|lseek
argument_list|(
name|dirfd
argument_list|,
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Unable to store mode and times for directory: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * write the file name followed by the trailer 	 */
name|dblk
operator|.
name|nlen
operator|=
name|nlen
operator|+
literal|1
expr_stmt|;
name|dblk
operator|.
name|mode
operator|=
name|psb
operator|->
name|st_mode
operator|&
literal|0xffff
expr_stmt|;
name|dblk
operator|.
name|mtime
operator|=
name|psb
operator|->
name|st_mtime
expr_stmt|;
name|dblk
operator|.
name|atime
operator|=
name|psb
operator|->
name|st_atime
expr_stmt|;
name|dblk
operator|.
name|frc_mode
operator|=
name|frc_mode
expr_stmt|;
if|if
condition|(
operator|(
name|write
argument_list|(
name|dirfd
argument_list|,
name|name
argument_list|,
name|dblk
operator|.
name|nlen
argument_list|)
operator|==
name|dblk
operator|.
name|nlen
operator|)
operator|&&
operator|(
name|write
argument_list|(
name|dirfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dblk
argument_list|,
sizeof|sizeof
argument_list|(
name|dblk
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|dblk
argument_list|)
operator|)
condition|)
block|{
operator|++
name|dircnt
expr_stmt|;
return|return;
block|}
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Unable to store mode and times for created directory: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * proc_dir()  *	process all file modes and times stored for directories CREATED  *	by pax  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|proc_dir
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|void
name|proc_dir
argument_list|()
endif|#
directive|endif
block|{
name|char
name|name
index|[
name|PAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|DIRDATA
name|dblk
decl_stmt|;
name|u_long
name|cnt
decl_stmt|;
if|if
condition|(
name|dirfd
operator|<
literal|0
condition|)
return|return;
comment|/* 	 * read backwards through the file and process each directory 	 */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|dircnt
condition|;
operator|++
name|cnt
control|)
block|{
comment|/* 		 * read the trailer, then the file name, if this fails 		 * just give up. 		 */
if|if
condition|(
name|lseek
argument_list|(
name|dirfd
argument_list|,
operator|-
operator|(
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|dblk
argument_list|)
operator|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|read
argument_list|(
name|dirfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dblk
argument_list|,
sizeof|sizeof
argument_list|(
name|dblk
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|dblk
argument_list|)
condition|)
break|break;
if|if
condition|(
name|lseek
argument_list|(
name|dirfd
argument_list|,
name|dblk
operator|.
name|npos
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|read
argument_list|(
name|dirfd
argument_list|,
name|name
argument_list|,
name|dblk
operator|.
name|nlen
argument_list|)
operator|!=
name|dblk
operator|.
name|nlen
condition|)
break|break;
if|if
condition|(
name|lseek
argument_list|(
name|dirfd
argument_list|,
name|dblk
operator|.
name|npos
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
break|break;
comment|/* 		 * frc_mode set, make sure we set the file modes even if 		 * the user didn't ask for it (see file_subs.c for more info) 		 */
if|if
condition|(
name|pmode
operator|||
name|dblk
operator|.
name|frc_mode
condition|)
name|set_pmode
argument_list|(
name|name
argument_list|,
name|dblk
operator|.
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|patime
operator|||
name|pmtime
condition|)
name|set_ftime
argument_list|(
name|name
argument_list|,
name|dblk
operator|.
name|mtime
argument_list|,
name|dblk
operator|.
name|atime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|dirfd
argument_list|)
expr_stmt|;
name|dirfd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
name|dircnt
condition|)
name|pax_warn
argument_list|(
literal|1
argument_list|,
literal|"Unable to set mode and times for created directories"
argument_list|)
expr_stmt|;
return|return;
block|}
end_decl_stmt

begin_comment
comment|/*  * database independent routines  */
end_comment

begin_comment
comment|/*  * st_hash()  *	hashes filenames to a u_int for hashing into a table. Looks at the tail  *	end of file, as this provides far better distribution than any other  *	part of the name. For performance reasons we only care about the last  *	MAXKEYLEN chars (should be at LEAST large enough to pick off the file  *	name). Was tested on 500,000 name file tree traversal from the root  *	and gave almost a perfectly uniform distribution of keys when used with  *	prime sized tables (MAXKEYLEN was 128 in test). Hashes (sizeof int)  *	chars at a time and pads with 0 for last addition.  * Return:  *	the hash value of the string MOD (%) the table size.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|u_int
name|st_hash
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|tabsz
parameter_list|)
else|#
directive|else
function|u_int st_hash
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|tabsz
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|tabsz
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
name|pt
decl_stmt|;
specifier|register
name|char
modifier|*
name|dest
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_int
name|key
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|steps
decl_stmt|;
specifier|register
name|int
name|res
decl_stmt|;
name|u_int
name|val
decl_stmt|;
comment|/* 	 * only look at the tail up to MAXKEYLEN, we do not need to waste 	 * time here (remember these are pathnames, the tail is what will 	 * spread out the keys) 	 */
if|if
condition|(
name|len
operator|>
name|MAXKEYLEN
condition|)
block|{
name|pt
operator|=
operator|&
operator|(
name|name
index|[
name|len
operator|-
name|MAXKEYLEN
index|]
operator|)
expr_stmt|;
name|len
operator|=
name|MAXKEYLEN
expr_stmt|;
block|}
else|else
name|pt
operator|=
name|name
expr_stmt|;
comment|/* 	 * calculate the number of u_int size steps in the string and if 	 * there is a runt to deal with 	 */
name|steps
operator|=
name|len
operator|/
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|res
operator|=
name|len
operator|%
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
comment|/* 	 * add up the value of the string in unsigned integer sized pieces 	 * too bad we cannot have unsigned int aligned strings, then we 	 * could avoid the expensive copy. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|steps
condition|;
operator|++
name|i
control|)
block|{
name|end
operator|=
name|pt
operator|+
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|val
expr_stmt|;
while|while
condition|(
name|pt
operator|<
name|end
condition|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|pt
operator|++
expr_stmt|;
name|key
operator|+=
name|val
expr_stmt|;
block|}
comment|/* 	 * add in the runt padded with zero to the right 	 */
if|if
condition|(
name|res
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|pt
operator|+
name|res
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|val
expr_stmt|;
while|while
condition|(
name|pt
operator|<
name|end
condition|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|pt
operator|++
expr_stmt|;
name|key
operator|+=
name|val
expr_stmt|;
block|}
comment|/* 	 * return the result mod the table size 	 */
return|return
operator|(
name|key
operator|%
name|tabsz
operator|)
return|;
block|}
end_function

end_unit

