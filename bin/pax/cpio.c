begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Keith Muller.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Keith Muller of the University of California, San Diego.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)cpio.c	8.1 (Berkeley) 5/31/93";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"pax.h"
end_include

begin_include
include|#
directive|include
file|"cpio.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_function_decl
specifier|static
name|int
name|rd_nm
parameter_list|(
name|ARCHD
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rd_ln_nm
parameter_list|(
name|ARCHD
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|com_rd
parameter_list|(
name|ARCHD
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Routines which support the different cpio versions  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|swp_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* binary cpio header byte swap */
end_comment

begin_comment
comment|/*  * Routines common to all versions of cpio  */
end_comment

begin_comment
comment|/*  * cpio_strd()  *	Fire up the hard link detection code  * Return:  *      0 if ok -1 otherwise (the return values of lnk_start())  */
end_comment

begin_function
name|int
name|cpio_strd
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|lnk_start
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cpio_trail()  *	Called to determine if a header block is a valid trailer. We are  *	passed the block, the in_sync flag (which tells us we are in resync  *	mode; looking for a valid header), and cnt (which starts at zero)  *	which is used to count the number of empty blocks we have seen so far.  * Return:  *	0 if a valid trailer, -1 if not a valid trailer,  */
end_comment

begin_function
name|int
name|cpio_trail
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
comment|/* 	 * look for trailer id in file we are about to process 	 */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|TRAILER
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * com_rd()  *	operations common to all cpio read functions.  * Return:  *	0  */
end_comment

begin_function
specifier|static
name|int
name|com_rd
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
name|arcn
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|arcn
operator|->
name|pat
operator|=
name|NULL
expr_stmt|;
name|arcn
operator|->
name|org_name
operator|=
name|arcn
operator|->
name|name
expr_stmt|;
switch|switch
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|&
name|C_IFMT
condition|)
block|{
case|case
name|C_ISFIFO
case|:
name|arcn
operator|->
name|type
operator|=
name|PAX_FIF
expr_stmt|;
break|break;
case|case
name|C_ISDIR
case|:
name|arcn
operator|->
name|type
operator|=
name|PAX_DIR
expr_stmt|;
break|break;
case|case
name|C_ISBLK
case|:
name|arcn
operator|->
name|type
operator|=
name|PAX_BLK
expr_stmt|;
break|break;
case|case
name|C_ISCHR
case|:
name|arcn
operator|->
name|type
operator|=
name|PAX_CHR
expr_stmt|;
break|break;
case|case
name|C_ISLNK
case|:
name|arcn
operator|->
name|type
operator|=
name|PAX_SLK
expr_stmt|;
break|break;
case|case
name|C_ISOCK
case|:
name|arcn
operator|->
name|type
operator|=
name|PAX_SCK
expr_stmt|;
break|break;
case|case
name|C_ISCTG
case|:
case|case
name|C_ISREG
case|:
default|default:
comment|/* 		 * we have file data, set up skip (pad is set in the format 		 * specific sections) 		 */
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|=
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|&
literal|0xfff
operator|)
operator||
name|C_ISREG
expr_stmt|;
name|arcn
operator|->
name|type
operator|=
name|PAX_REG
expr_stmt|;
name|arcn
operator|->
name|skip
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_size
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chk_lnk
argument_list|(
name|arcn
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cpio_end_wr()  *	write the special file with the name trailer in the proper format  * Return:  *	result of the write of the trailer from the cpio specific write func  */
end_comment

begin_function
name|int
name|cpio_endwr
parameter_list|(
name|void
parameter_list|)
block|{
name|ARCHD
name|last
decl_stmt|;
comment|/* 	 * create a trailer request and call the proper format write function 	 */
name|memset
argument_list|(
operator|&
name|last
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|.
name|nlen
operator|=
sizeof|sizeof
argument_list|(
name|TRAILER
argument_list|)
operator|-
literal|1
expr_stmt|;
name|last
operator|.
name|type
operator|=
name|PAX_REG
expr_stmt|;
name|last
operator|.
name|sb
operator|.
name|st_nlink
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|last
operator|.
name|name
argument_list|,
name|TRAILER
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|frmt
operator|->
name|wr
call|)
argument_list|(
operator|&
name|last
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rd_nam()  *	read in the file name which follows the cpio header  * Return:  *	0 if ok, -1 otherwise  */
end_comment

begin_function
specifier|static
name|int
name|rd_nm
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|,
name|int
name|nsz
parameter_list|)
block|{
comment|/* 	 * do not even try bogus values 	 */
if|if
condition|(
operator|(
name|nsz
operator|==
literal|0
operator|)
operator|||
operator|(
name|nsz
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|arcn
operator|->
name|name
argument_list|)
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Cpio file name length %d is out of range"
argument_list|,
name|nsz
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * read the name and make sure it is not empty and is \0 terminated 	 */
if|if
condition|(
operator|(
name|rd_wrbuf
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|nsz
argument_list|)
operator|!=
name|nsz
operator|)
operator|||
operator|(
name|arcn
operator|->
name|name
index|[
name|nsz
operator|-
literal|1
index|]
operator|!=
literal|'\0'
operator|)
operator|||
operator|(
name|arcn
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Cpio file name in header is corrupted"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rd_ln_nm()  *	read in the link name for a file with links. The link name is stored  *	like file data (and is NOT \0 terminated!)  * Return:  *	0 if ok, -1 otherwise  */
end_comment

begin_function
specifier|static
name|int
name|rd_ln_nm
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
comment|/* 	 * check the length specified for bogus values 	 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|size_t
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|>=
sizeof|sizeof
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|NET2_STAT
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Cpio link name length is invalid: %lu"
argument_list|,
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
else|#
directive|else
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Cpio link name length is invalid: %ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * read in the link name and \0 terminate it 	 */
if|if
condition|(
name|rd_wrbuf
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
operator|(
name|int
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Cpio link name read error"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|arcn
operator|->
name|ln_nlen
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_size
expr_stmt|;
name|arcn
operator|->
name|ln_name
index|[
name|arcn
operator|->
name|ln_nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * watch out for those empty link names 	 */
if|if
condition|(
name|arcn
operator|->
name|ln_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Cpio link name is corrupt"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines common to the extended byte oriented cpio format  */
end_comment

begin_comment
comment|/*  * cpio_id()  *      determine if a block given to us is a valid extended byte oriented  *	cpio header  * Return:  *      0 if a valid header, -1 otherwise  */
end_comment

begin_function
name|int
name|cpio_id
parameter_list|(
name|char
modifier|*
name|blk
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|size
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|HD_CPIO
argument_list|)
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|blk
argument_list|,
name|AMAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|AMAGIC
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cpio_rd()  *	determine if a buffer is a byte oriented extended cpio archive entry.  *	convert and store the values in the ARCHD parameter.  * Return:  *	0 if a valid header, -1 otherwise.  */
end_comment

begin_function
name|int
name|cpio_rd
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|nsz
decl_stmt|;
name|HD_CPIO
modifier|*
name|hd
decl_stmt|;
comment|/* 	 * check that this is a valid header, if not return -1 	 */
if|if
condition|(
name|cpio_id
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|HD_CPIO
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|hd
operator|=
operator|(
name|HD_CPIO
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 	 * byte oriented cpio (posix) does not have padding! extract the octal 	 * ascii fields from the header 	 */
name|arcn
operator|->
name|pad
operator|=
literal|0L
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_dev
operator|=
operator|(
name|dev_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_dev
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_dev
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|=
operator|(
name|ino_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_ino
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_ino
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|=
operator|(
name|mode_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_mode
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_uid
operator|=
operator|(
name|uid_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_uid
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_gid
operator|=
operator|(
name|gid_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_gid
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|=
operator|(
name|nlink_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_nlink
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_nlink
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
operator|=
operator|(
name|dev_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_rdev
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_rdev
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NET2_STAT
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_mtime
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
else|#
directive|else
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
name|asc_uqd
argument_list|(
name|hd
operator|->
name|c_mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_mtime
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_atime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
expr_stmt|;
ifdef|#
directive|ifdef
name|NET2_STAT
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
operator|(
name|off_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
else|#
directive|else
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
operator|(
name|off_t
operator|)
name|asc_uqd
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|OCT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * check name size and if valid, read in the name of this entry (name 	 * follows header in the archive) 	 */
if|if
condition|(
operator|(
name|nsz
operator|=
operator|(
name|int
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_namesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_namesize
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|)
operator|<
literal|2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|arcn
operator|->
name|nlen
operator|=
name|nsz
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rd_nm
argument_list|(
name|arcn
argument_list|,
name|nsz
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|&
name|C_IFMT
operator|)
operator|!=
name|C_ISLNK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	 	 * no link name to read for this file 	 	 */
name|arcn
operator|->
name|ln_nlen
operator|=
literal|0
expr_stmt|;
name|arcn
operator|->
name|ln_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|com_rd
argument_list|(
name|arcn
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * check link name size and read in the link name. Link names are 	 * stored like file data. 	 */
if|if
condition|(
name|rd_ln_nm
argument_list|(
name|arcn
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * we have a valid header (with a link) 	 */
return|return
operator|(
name|com_rd
argument_list|(
name|arcn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cpio_endrd()  *      no cleanup needed here, just return size of the trailer (for append)  * Return:  *      size of trailer header in this format  */
end_comment

begin_function
name|off_t
name|cpio_endrd
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
call|(
name|off_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|HD_CPIO
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|TRAILER
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cpio_stwr()  *	start up the device mapping table  * Return:  *	0 if ok, -1 otherwise (what dev_start() returns)  */
end_comment

begin_function
name|int
name|cpio_stwr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|dev_start
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cpio_wr()  *	copy the data in the ARCHD to buffer in extended byte oriented cpio  *	format.  * Return  *      0 if file has data to be written after the header, 1 if file has NO  *	data to write after the header, -1 if archive write failed  */
end_comment

begin_function
name|int
name|cpio_wr
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
name|HD_CPIO
modifier|*
name|hd
decl_stmt|;
name|int
name|nsz
decl_stmt|;
name|HD_CPIO
name|hdblk
decl_stmt|;
comment|/* 	 * check and repair truncated device and inode fields in the header 	 */
if|if
condition|(
name|map_dev
argument_list|(
name|arcn
argument_list|,
operator|(
name|u_long
operator|)
name|CPIO_MASK
argument_list|,
operator|(
name|u_long
operator|)
name|CPIO_MASK
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|arcn
operator|->
name|pad
operator|=
literal|0L
expr_stmt|;
name|nsz
operator|=
name|arcn
operator|->
name|nlen
operator|+
literal|1
expr_stmt|;
name|hd
operator|=
operator|&
name|hdblk
expr_stmt|;
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_BLK
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_CHR
operator|)
condition|)
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|arcn
operator|->
name|type
condition|)
block|{
case|case
name|PAX_CTG
case|:
case|case
name|PAX_REG
case|:
case|case
name|PAX_HRG
case|:
comment|/* 		 * set data size for file data 		 */
ifdef|#
directive|ifdef
name|NET2_STAT
if|if
condition|(
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|,
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|OCT
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|uqd_asc
argument_list|(
operator|(
name|u_quad_t
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|,
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|OCT
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File is too large for cpio format %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|PAX_SLK
case|:
comment|/* 		 * set data size to hold link name 		 */
if|if
condition|(
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|ln_nlen
argument_list|,
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|OCT
argument_list|)
condition|)
goto|goto
name|out
goto|;
break|break;
default|default:
comment|/* 		 * all other file types have no file data 		 */
if|if
condition|(
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
literal|0
argument_list|,
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|OCT
argument_list|)
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
comment|/* 	 * copy the values to the header using octal ascii 	 */
if|if
condition|(
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|MAGIC
argument_list|,
name|hd
operator|->
name|c_magic
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_magic
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_dev
argument_list|,
name|hd
operator|->
name|c_dev
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_dev
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_ino
argument_list|,
name|hd
operator|->
name|c_ino
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_ino
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_mode
argument_list|,
name|hd
operator|->
name|c_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_mode
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_uid
argument_list|,
name|hd
operator|->
name|c_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_uid
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_gid
argument_list|,
name|hd
operator|->
name|c_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_gid
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
argument_list|,
name|hd
operator|->
name|c_nlink
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_nlink
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
argument_list|,
name|hd
operator|->
name|c_rdev
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_rdev
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
argument_list|,
name|hd
operator|->
name|c_mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_mtime
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|nsz
argument_list|,
name|hd
operator|->
name|c_namesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_namesize
argument_list|)
argument_list|,
name|OCT
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * write the file name to the archive 	 */
if|if
condition|(
operator|(
name|wr_rdbuf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdblk
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|HD_CPIO
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_rdbuf
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|nsz
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Unable to write cpio header for %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * if this file has data, we are done. The caller will write the file 	 * data, if we are link tell caller we are done, go to next file 	 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_CTG
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_REG
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_SLK
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * write the link name to the archive, tell the caller to go to the 	 * next file as we are done. 	 */
if|if
condition|(
name|wr_rdbuf
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
name|arcn
operator|->
name|ln_nlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Unable to write cpio link name for %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|out
label|:
comment|/* 	 * header field is out of range 	 */
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Cpio header field is too small to store file %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * Routines common to the system VR4 version of cpio (with/without file CRC)  */
comment|/*  * vcpio_id()  *      determine if a block given to us is a valid system VR4 cpio header  *	WITHOUT crc. WATCH it the magic cookies are in OCTAL, the header  *	uses HEX  * Return:  *      0 if a valid header, -1 otherwise  */
name|int
name|vcpio_id
parameter_list|(
name|char
modifier|*
name|blk
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|size
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|HD_VCPIO
argument_list|)
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|blk
argument_list|,
name|AVMAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|AVMAGIC
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * crc_id()  *      determine if a block given to us is a valid system VR4 cpio header  *	WITH crc. WATCH it the magic cookies are in OCTAL the header uses HEX  * Return:  *      0 if a valid header, -1 otherwise  */
name|int
name|crc_id
parameter_list|(
name|char
modifier|*
name|blk
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|size
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|HD_VCPIO
argument_list|)
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|blk
argument_list|,
name|AVCMAGIC
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|AVCMAGIC
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * crc_strd()  w	set file data CRC calculations. Fire up the hard link detection code  * Return:  *      0 if ok -1 otherwise (the return values of lnk_start())  */
name|int
name|crc_strd
parameter_list|(
name|void
parameter_list|)
block|{
name|docrc
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|lnk_start
argument_list|()
operator|)
return|;
block|}
comment|/*  * vcpio_rd()  *	determine if a buffer is a system VR4 archive entry. (with/without CRC)  *	convert and store the values in the ARCHD parameter.  * Return:  *	0 if a valid header, -1 otherwise.  */
name|int
name|vcpio_rd
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|HD_VCPIO
modifier|*
name|hd
decl_stmt|;
name|dev_t
name|devminor
decl_stmt|;
name|dev_t
name|devmajor
decl_stmt|;
name|int
name|nsz
decl_stmt|;
comment|/* 	 * during the id phase it was determined if we were using CRC, use the 	 * proper id routine. 	 */
if|if
condition|(
name|docrc
condition|)
block|{
if|if
condition|(
name|crc_id
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|HD_VCPIO
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|vcpio_id
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|HD_VCPIO
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|hd
operator|=
operator|(
name|HD_VCPIO
operator|*
operator|)
name|buf
expr_stmt|;
name|arcn
operator|->
name|pad
operator|=
literal|0L
expr_stmt|;
comment|/* 	 * extract the hex ascii fields from the header 	 */
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|=
operator|(
name|ino_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_ino
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_ino
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|=
operator|(
name|mode_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_mode
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_uid
operator|=
operator|(
name|uid_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_uid
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_gid
operator|=
operator|(
name|gid_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_gid
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NET2_STAT
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_mtime
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
else|#
directive|else
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
name|asc_uqd
argument_list|(
name|hd
operator|->
name|c_mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_mtime
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_atime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
expr_stmt|;
ifdef|#
directive|ifdef
name|NET2_STAT
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
operator|(
name|off_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
else|#
directive|else
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
operator|(
name|off_t
operator|)
name|asc_uqd
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|=
operator|(
name|nlink_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_nlink
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_nlink
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
name|devmajor
operator|=
operator|(
name|dev_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_maj
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_maj
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
name|devminor
operator|=
operator|(
name|dev_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_min
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_min
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_dev
operator|=
name|TODEV
argument_list|(
name|devmajor
argument_list|,
name|devminor
argument_list|)
expr_stmt|;
name|devmajor
operator|=
operator|(
name|dev_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_rmaj
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_maj
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
name|devminor
operator|=
operator|(
name|dev_t
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_rmin
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_min
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
operator|=
name|TODEV
argument_list|(
name|devmajor
argument_list|,
name|devminor
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|crc
operator|=
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_chksum
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_chksum
argument_list|)
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
comment|/* 	 * check the length of the file name, if ok read it in, return -1 if 	 * bogus 	 */
if|if
condition|(
operator|(
name|nsz
operator|=
operator|(
name|int
operator|)
name|asc_ul
argument_list|(
name|hd
operator|->
name|c_namesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_namesize
argument_list|)
argument_list|,
name|HEX
argument_list|)
operator|)
operator|<
literal|2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|arcn
operator|->
name|nlen
operator|=
name|nsz
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rd_nm
argument_list|(
name|arcn
argument_list|,
name|nsz
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * skip padding. header + filename is aligned to 4 byte boundries 	 */
if|if
condition|(
name|rd_skip
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|VCPIO_PAD
argument_list|(
sizeof|sizeof
argument_list|(
name|HD_VCPIO
argument_list|)
operator|+
name|nsz
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * if not a link (or a file with no data), calculate pad size (for 	 * padding which follows the file data), clear the link name and return 	 */
if|if
condition|(
operator|(
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|&
name|C_IFMT
operator|)
operator|!=
name|C_ISLNK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * we have a valid header (not a link) 		 */
name|arcn
operator|->
name|ln_nlen
operator|=
literal|0
expr_stmt|;
name|arcn
operator|->
name|ln_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|arcn
operator|->
name|pad
operator|=
name|VCPIO_PAD
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|com_rd
argument_list|(
name|arcn
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * read in the link name and skip over the padding 	 */
if|if
condition|(
operator|(
name|rd_ln_nm
argument_list|(
name|arcn
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|rd_skip
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|VCPIO_PAD
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * we have a valid header (with a link) 	 */
return|return
operator|(
name|com_rd
argument_list|(
name|arcn
argument_list|)
operator|)
return|;
block|}
comment|/*  * vcpio_endrd()  *      no cleanup needed here, just return size of the trailer (for append)  * Return:  *      size of trailer header in this format  */
name|off_t
name|vcpio_endrd
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
call|(
name|off_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|HD_VCPIO
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|TRAILER
argument_list|)
operator|+
operator|(
name|VCPIO_PAD
argument_list|(
sizeof|sizeof
argument_list|(
name|HD_VCPIO
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|TRAILER
argument_list|)
argument_list|)
operator|)
argument_list|)
operator|)
return|;
block|}
comment|/*  * crc_stwr()  *	start up the device mapping table, enable crc file calculation  * Return:  *	0 if ok, -1 otherwise (what dev_start() returns)  */
name|int
name|crc_stwr
parameter_list|(
name|void
parameter_list|)
block|{
name|docrc
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|dev_start
argument_list|()
operator|)
return|;
block|}
comment|/*  * vcpio_wr()  *	copy the data in the ARCHD to buffer in system VR4 cpio  *	(with/without crc) format.  * Return  *	0 if file has data to be written after the header, 1 if file has  *	NO data to write after the header, -1 if archive write failed  */
name|int
name|vcpio_wr
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
name|HD_VCPIO
modifier|*
name|hd
decl_stmt|;
name|unsigned
name|int
name|nsz
decl_stmt|;
name|HD_VCPIO
name|hdblk
decl_stmt|;
comment|/* 	 * check and repair truncated device and inode fields in the cpio 	 * header 	 */
if|if
condition|(
name|map_dev
argument_list|(
name|arcn
argument_list|,
operator|(
name|u_long
operator|)
name|VCPIO_MASK
argument_list|,
operator|(
name|u_long
operator|)
name|VCPIO_MASK
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nsz
operator|=
name|arcn
operator|->
name|nlen
operator|+
literal|1
expr_stmt|;
name|hd
operator|=
operator|&
name|hdblk
expr_stmt|;
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_BLK
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_CHR
operator|)
condition|)
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
operator|=
literal|0
expr_stmt|;
comment|/* 	 * add the proper magic value depending whether we were asked for 	 * file data crc's, and the crc if needed. 	 */
if|if
condition|(
name|docrc
condition|)
block|{
if|if
condition|(
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|VCMAGIC
argument_list|,
name|hd
operator|->
name|c_magic
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_magic
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|crc
argument_list|,
name|hd
operator|->
name|c_chksum
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_chksum
argument_list|)
argument_list|,
name|HEX
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
if|if
condition|(
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|VMAGIC
argument_list|,
name|hd
operator|->
name|c_magic
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_magic
argument_list|)
argument_list|,
name|OCT
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
literal|0L
argument_list|,
name|hd
operator|->
name|c_chksum
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_chksum
argument_list|)
argument_list|,
name|HEX
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|arcn
operator|->
name|type
condition|)
block|{
case|case
name|PAX_CTG
case|:
case|case
name|PAX_REG
case|:
case|case
name|PAX_HRG
case|:
comment|/* 		 * caller will copy file data to the archive. tell him how 		 * much to pad. 		 */
name|arcn
operator|->
name|pad
operator|=
name|VCPIO_PAD
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NET2_STAT
if|if
condition|(
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|,
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|HEX
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|uqd_asc
argument_list|(
operator|(
name|u_quad_t
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|,
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|HEX
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File is too large for sv4cpio format %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|PAX_SLK
case|:
comment|/* 		 * no file data for the caller to process, the file data has 		 * the size of the link 		 */
name|arcn
operator|->
name|pad
operator|=
literal|0L
expr_stmt|;
if|if
condition|(
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|ln_nlen
argument_list|,
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|HEX
argument_list|)
condition|)
goto|goto
name|out
goto|;
break|break;
default|default:
comment|/* 		 * no file data for the caller to process 		 */
name|arcn
operator|->
name|pad
operator|=
literal|0L
expr_stmt|;
if|if
condition|(
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
literal|0L
argument_list|,
name|hd
operator|->
name|c_filesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_filesize
argument_list|)
argument_list|,
name|HEX
argument_list|)
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
comment|/* 	 * set the other fields in the header 	 */
if|if
condition|(
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_ino
argument_list|,
name|hd
operator|->
name|c_ino
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_ino
argument_list|)
argument_list|,
name|HEX
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_mode
argument_list|,
name|hd
operator|->
name|c_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_mode
argument_list|)
argument_list|,
name|HEX
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_uid
argument_list|,
name|hd
operator|->
name|c_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_uid
argument_list|)
argument_list|,
name|HEX
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_gid
argument_list|,
name|hd
operator|->
name|c_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_gid
argument_list|)
argument_list|,
name|HEX
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
argument_list|,
name|hd
operator|->
name|c_mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_mtime
argument_list|)
argument_list|,
name|HEX
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
argument_list|,
name|hd
operator|->
name|c_nlink
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_nlink
argument_list|)
argument_list|,
name|HEX
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|MAJOR
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_dev
argument_list|)
argument_list|,
name|hd
operator|->
name|c_maj
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_maj
argument_list|)
argument_list|,
name|HEX
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|MINOR
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_dev
argument_list|)
argument_list|,
name|hd
operator|->
name|c_min
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_min
argument_list|)
argument_list|,
name|HEX
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|MAJOR
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|hd
operator|->
name|c_rmaj
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_maj
argument_list|)
argument_list|,
name|HEX
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|MINOR
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|hd
operator|->
name|c_rmin
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_min
argument_list|)
argument_list|,
name|HEX
argument_list|)
operator|||
name|ul_asc
argument_list|(
operator|(
name|u_long
operator|)
name|nsz
argument_list|,
name|hd
operator|->
name|c_namesize
argument_list|,
sizeof|sizeof
argument_list|(
name|hd
operator|->
name|c_namesize
argument_list|)
argument_list|,
name|HEX
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * write the header, the file name and padding as required. 	 */
if|if
condition|(
operator|(
name|wr_rdbuf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdblk
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|HD_VCPIO
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_rdbuf
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|nsz
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_skip
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|VCPIO_PAD
argument_list|(
sizeof|sizeof
argument_list|(
name|HD_VCPIO
argument_list|)
operator|+
name|nsz
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Could not write sv4cpio header for %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * if we have file data, tell the caller we are done, copy the file 	 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_CTG
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_REG
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * if we are not a link, tell the caller we are done, go to next file 	 */
if|if
condition|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_SLK
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * write the link name, tell the caller we are done. 	 */
if|if
condition|(
operator|(
name|wr_rdbuf
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
name|arcn
operator|->
name|ln_nlen
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_skip
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|VCPIO_PAD
argument_list|(
name|arcn
operator|->
name|ln_nlen
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Could not write sv4cpio link name for %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|out
label|:
comment|/* 	 * header field is out of range 	 */
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Sv4cpio header field is too small for file %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * Routines common to the old binary header cpio  */
comment|/*  * bcpio_id()  *      determine if a block given to us is an old binary cpio header  *	(with/without header byte swapping)  * Return:  *      0 if a valid header, -1 otherwise  */
name|int
name|bcpio_id
parameter_list|(
name|char
modifier|*
name|blk
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|HD_BCPIO
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * check both normal and byte swapped magic cookies 	 */
if|if
condition|(
operator|(
operator|(
name|u_short
operator|)
name|SHRT_EXT
argument_list|(
name|blk
argument_list|)
operator|)
operator|==
name|MAGIC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|u_short
operator|)
name|RSHRT_EXT
argument_list|(
name|blk
argument_list|)
operator|)
operator|==
name|MAGIC
condition|)
block|{
if|if
condition|(
operator|!
name|swp_head
condition|)
operator|++
name|swp_head
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  * bcpio_rd()  *	determine if a buffer is an old binary archive entry. (It may have byte  *	swapped header) convert and store the values in the ARCHD parameter.  *	This is a very old header format and should not really be used.  * Return:  *	0 if a valid header, -1 otherwise.  */
name|int
name|bcpio_rd
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|HD_BCPIO
modifier|*
name|hd
decl_stmt|;
name|int
name|nsz
decl_stmt|;
comment|/* 	 * check the header 	 */
if|if
condition|(
name|bcpio_id
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|HD_BCPIO
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|arcn
operator|->
name|pad
operator|=
literal|0L
expr_stmt|;
name|hd
operator|=
operator|(
name|HD_BCPIO
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|swp_head
condition|)
block|{
comment|/* 		 * header has swapped bytes on 16 bit boundaries 		 */
name|arcn
operator|->
name|sb
operator|.
name|st_dev
operator|=
call|(
name|dev_t
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_dev
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|=
call|(
name|ino_t
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_ino
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|=
call|(
name|mode_t
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_mode
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_uid
operator|=
call|(
name|uid_t
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_uid
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_gid
operator|=
call|(
name|gid_t
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_gid
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|=
call|(
name|nlink_t
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_nlink
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
operator|=
call|(
name|dev_t
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_rdev
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
call|(
name|time_t
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_mtime_1
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|time_t
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_mtime_2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
call|(
name|off_t
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_filesize_1
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|off_t
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_filesize_2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|nsz
operator|=
call|(
name|int
call|)
argument_list|(
name|RSHRT_EXT
argument_list|(
name|hd
operator|->
name|h_namesize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arcn
operator|->
name|sb
operator|.
name|st_dev
operator|=
call|(
name|dev_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_dev
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|=
call|(
name|ino_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_ino
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|=
call|(
name|mode_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_mode
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_uid
operator|=
call|(
name|uid_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_uid
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_gid
operator|=
call|(
name|gid_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_gid
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|=
call|(
name|nlink_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_nlink
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
operator|=
call|(
name|dev_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_rdev
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
call|(
name|time_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_mtime_1
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|time_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_mtime_2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
call|(
name|off_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_filesize_1
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|=
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|off_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_filesize_2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|nsz
operator|=
call|(
name|int
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_namesize
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arcn
operator|->
name|sb
operator|.
name|st_ctime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_atime
operator|=
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
expr_stmt|;
comment|/* 	 * check the file name size, if bogus give up. otherwise read the file 	 * name 	 */
if|if
condition|(
name|nsz
operator|<
literal|2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|arcn
operator|->
name|nlen
operator|=
name|nsz
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rd_nm
argument_list|(
name|arcn
argument_list|,
name|nsz
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * header + file name are aligned to 2 byte boundries, skip if needed 	 */
if|if
condition|(
name|rd_skip
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|BCPIO_PAD
argument_list|(
sizeof|sizeof
argument_list|(
name|HD_BCPIO
argument_list|)
operator|+
name|nsz
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * if not a link (or a file with no data), calculate pad size (for 	 * padding which follows the file data), clear the link name and return 	 */
if|if
condition|(
operator|(
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|&
name|C_IFMT
operator|)
operator|!=
name|C_ISLNK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * we have a valid header (not a link) 		 */
name|arcn
operator|->
name|ln_nlen
operator|=
literal|0
expr_stmt|;
name|arcn
operator|->
name|ln_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|arcn
operator|->
name|pad
operator|=
name|BCPIO_PAD
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|com_rd
argument_list|(
name|arcn
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rd_ln_nm
argument_list|(
name|arcn
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|rd_skip
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|BCPIO_PAD
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * we have a valid header (with a link) 	 */
return|return
operator|(
name|com_rd
argument_list|(
name|arcn
argument_list|)
operator|)
return|;
block|}
comment|/*  * bcpio_endrd()  *      no cleanup needed here, just return size of the trailer (for append)  * Return:  *      size of trailer header in this format  */
name|off_t
name|bcpio_endrd
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
call|(
name|off_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|HD_BCPIO
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|TRAILER
argument_list|)
operator|+
operator|(
name|BCPIO_PAD
argument_list|(
sizeof|sizeof
argument_list|(
name|HD_BCPIO
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|TRAILER
argument_list|)
argument_list|)
operator|)
argument_list|)
operator|)
return|;
block|}
comment|/*  * bcpio_wr()  *	copy the data in the ARCHD to buffer in old binary cpio format  *	There is a real chance of field overflow with this critter. So we  *	always check the conversion is ok. nobody in his their right mind  *	should write an achive in this format...  * Return  *      0 if file has data to be written after the header, 1 if file has NO  *	data to write after the header, -1 if archive write failed  */
name|int
name|bcpio_wr
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
name|HD_BCPIO
modifier|*
name|hd
decl_stmt|;
name|int
name|nsz
decl_stmt|;
name|HD_BCPIO
name|hdblk
decl_stmt|;
name|off_t
name|t_offt
decl_stmt|;
name|int
name|t_int
decl_stmt|;
name|time_t
name|t_timet
decl_stmt|;
comment|/* 	 * check and repair truncated device and inode fields in the cpio 	 * header 	 */
if|if
condition|(
name|map_dev
argument_list|(
name|arcn
argument_list|,
operator|(
name|u_long
operator|)
name|BCPIO_MASK
argument_list|,
operator|(
name|u_long
operator|)
name|BCPIO_MASK
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_BLK
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_CHR
operator|)
condition|)
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
operator|=
literal|0
expr_stmt|;
name|hd
operator|=
operator|&
name|hdblk
expr_stmt|;
switch|switch
condition|(
name|arcn
operator|->
name|type
condition|)
block|{
case|case
name|PAX_CTG
case|:
case|case
name|PAX_REG
case|:
case|case
name|PAX_HRG
case|:
comment|/* 		 * caller will copy file data to the archive. tell him how 		 * much to pad. 		 */
name|arcn
operator|->
name|pad
operator|=
name|BCPIO_PAD
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_filesize_1
index|[
literal|0
index|]
operator|=
name|CHR_WR_0
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_filesize_1
index|[
literal|1
index|]
operator|=
name|CHR_WR_1
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_filesize_2
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_filesize_2
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|t_offt
operator|=
call|(
name|off_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_filesize_1
argument_list|)
argument_list|)
expr_stmt|;
name|t_offt
operator|=
operator|(
name|t_offt
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|off_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_filesize_2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_size
operator|!=
name|t_offt
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File is too large for bcpio format %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|PAX_SLK
case|:
comment|/* 		 * no file data for the caller to process, the file data has 		 * the size of the link 		 */
name|arcn
operator|->
name|pad
operator|=
literal|0L
expr_stmt|;
name|hd
operator|->
name|h_filesize_1
index|[
literal|0
index|]
operator|=
name|CHR_WR_0
argument_list|(
name|arcn
operator|->
name|ln_nlen
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_filesize_1
index|[
literal|1
index|]
operator|=
name|CHR_WR_1
argument_list|(
name|arcn
operator|->
name|ln_nlen
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_filesize_2
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|arcn
operator|->
name|ln_nlen
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_filesize_2
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|arcn
operator|->
name|ln_nlen
argument_list|)
expr_stmt|;
name|t_int
operator|=
call|(
name|int
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_filesize_1
argument_list|)
argument_list|)
expr_stmt|;
name|t_int
operator|=
operator|(
name|t_int
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|int
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_filesize_2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|ln_nlen
operator|!=
name|t_int
condition|)
goto|goto
name|out
goto|;
break|break;
default|default:
comment|/* 		 * no file data for the caller to process 		 */
name|arcn
operator|->
name|pad
operator|=
literal|0L
expr_stmt|;
name|hd
operator|->
name|h_filesize_1
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
name|hd
operator|->
name|h_filesize_1
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
name|hd
operator|->
name|h_filesize_2
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
name|hd
operator|->
name|h_filesize_2
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 	 * build up the rest of the fields 	 */
name|hd
operator|->
name|h_magic
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|MAGIC
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_magic
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|MAGIC
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_dev
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_dev
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_dev
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_dev
operator|!=
call|(
name|dev_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_dev
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|hd
operator|->
name|h_ino
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_ino
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_ino
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_ino
operator|!=
call|(
name|ino_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_ino
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|hd
operator|->
name|h_mode
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_mode
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_mode
operator|!=
call|(
name|mode_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_mode
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|hd
operator|->
name|h_uid
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_uid
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_uid
operator|!=
call|(
name|uid_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_uid
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|hd
operator|->
name|h_gid
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_gid
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_gid
operator|!=
call|(
name|gid_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_gid
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|hd
operator|->
name|h_nlink
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_nlink
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_nlink
operator|!=
call|(
name|nlink_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_nlink
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|hd
operator|->
name|h_rdev
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_rdev
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_rdev
operator|!=
call|(
name|dev_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_rdev
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|hd
operator|->
name|h_mtime_1
index|[
literal|0
index|]
operator|=
name|CHR_WR_0
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_mtime_1
index|[
literal|1
index|]
operator|=
name|CHR_WR_1
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_mtime_2
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_mtime_2
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|t_timet
operator|=
call|(
name|time_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_mtime_1
argument_list|)
argument_list|)
expr_stmt|;
name|t_timet
operator|=
operator|(
name|t_timet
operator|<<
literal|16
operator|)
operator||
operator|(
call|(
name|time_t
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_mtime_2
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|arcn
operator|->
name|sb
operator|.
name|st_mtime
operator|!=
name|t_timet
condition|)
goto|goto
name|out
goto|;
name|nsz
operator|=
name|arcn
operator|->
name|nlen
operator|+
literal|1
expr_stmt|;
name|hd
operator|->
name|h_namesize
index|[
literal|0
index|]
operator|=
name|CHR_WR_2
argument_list|(
name|nsz
argument_list|)
expr_stmt|;
name|hd
operator|->
name|h_namesize
index|[
literal|1
index|]
operator|=
name|CHR_WR_3
argument_list|(
name|nsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsz
operator|!=
call|(
name|int
call|)
argument_list|(
name|SHRT_EXT
argument_list|(
name|hd
operator|->
name|h_namesize
argument_list|)
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * write the header, the file name and padding as required. 	 */
if|if
condition|(
operator|(
name|wr_rdbuf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdblk
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|HD_BCPIO
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_rdbuf
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|nsz
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_skip
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|BCPIO_PAD
argument_list|(
sizeof|sizeof
argument_list|(
name|HD_BCPIO
argument_list|)
operator|+
name|nsz
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Could not write bcpio header for %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * if we have file data, tell the caller we are done 	 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_CTG
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_REG
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * if we are not a link, tell the caller we are done, go to next file 	 */
if|if
condition|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_SLK
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * write the link name, tell the caller we are done. 	 */
if|if
condition|(
operator|(
name|wr_rdbuf
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
name|arcn
operator|->
name|ln_nlen
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_skip
argument_list|(
call|(
name|off_t
call|)
argument_list|(
name|BCPIO_PAD
argument_list|(
name|arcn
operator|->
name|ln_nlen
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Could not write bcpio link name for %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|out
label|:
comment|/* 	 * header field is out of range 	 */
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Bcpio header field is too small for file %s"
argument_list|,
name|arcn
operator|->
name|org_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

