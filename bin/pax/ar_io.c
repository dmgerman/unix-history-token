begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Keith Muller.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Keith Muller of the University of California, San Diego.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)ar_io.c	8.2 (Berkeley) 4/18/94";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pax.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * Routines which deal directly with the archive I/O device/file.  */
end_comment

begin_define
define|#
directive|define
name|DMOD
value|0666
end_define

begin_comment
comment|/* default mode of created archives */
end_comment

begin_define
define|#
directive|define
name|EXT_MODE
value|O_RDONLY
end_define

begin_comment
comment|/* open mode for list/extract */
end_comment

begin_define
define|#
directive|define
name|AR_MODE
value|(O_WRONLY | O_CREAT | O_TRUNC)
end_define

begin_comment
comment|/* mode for archive */
end_comment

begin_define
define|#
directive|define
name|APP_MODE
value|O_RDWR
end_define

begin_comment
comment|/* mode for append */
end_comment

begin_decl_stmt
specifier|static
name|char
name|none
index|[]
init|=
literal|"<NONE>"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pseudo name for no file */
end_comment

begin_decl_stmt
specifier|static
name|char
name|stdo
index|[]
init|=
literal|"<STDOUT>"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pseudo name for stdout */
end_comment

begin_decl_stmt
specifier|static
name|char
name|stdn
index|[]
init|=
literal|"<STDIN>"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pseudo name for stdin */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* archive file descriptor */
end_comment

begin_decl_stmt
specifier|static
name|int
name|artyp
init|=
name|ISREG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* archive type: file/FIFO/tape */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arvol
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* archive volume number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lstrval
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return value from last i/o */
end_comment

begin_decl_stmt
specifier|static
name|int
name|io_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i/o worked on volume after resync */
end_comment

begin_decl_stmt
specifier|static
name|int
name|did_io
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* did i/o ever occur on volume? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set via tty termination */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stat
name|arsb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stat of archive device at open */
end_comment

begin_decl_stmt
specifier|static
name|int
name|invld_rec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tape has out of spec record size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wr_trail
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trailer was rewritten in append */
end_comment

begin_decl_stmt
specifier|static
name|int
name|can_unlnk
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we unlink null archives?  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|arcname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* printable name of archive */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|gzip_program
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of gzip program */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|zpid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pid of child process */
end_comment

begin_function_decl
specifier|static
name|int
name|get_phys
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|sigset_t
name|s_mask
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ar_start_gzip
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ar_open()  *	Opens the next archive volume. Determines the type of the device and  *	sets up block sizes as required by the archive device and the format.  *	Note: we may be called with name == NULL on the first open only.  * Return:  *	-1 on failure, 0 otherwise  */
end_comment

begin_function
name|int
name|ar_open
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|mtget
name|mb
decl_stmt|;
if|if
condition|(
name|arfd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|arfd
argument_list|)
expr_stmt|;
name|arfd
operator|=
operator|-
literal|1
expr_stmt|;
name|can_unlnk
operator|=
name|did_io
operator|=
name|io_ok
operator|=
name|invld_rec
operator|=
literal|0
expr_stmt|;
name|artyp
operator|=
name|ISREG
expr_stmt|;
name|flcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * open based on overall operation mode 	 */
switch|switch
condition|(
name|act
condition|)
block|{
case|case
name|LIST
case|:
case|case
name|EXTRACT
case|:
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|arfd
operator|=
name|STDIN_FILENO
expr_stmt|;
name|arcname
operator|=
name|stdn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|arfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|EXT_MODE
argument_list|,
name|DMOD
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syswarn
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Failed open to read on %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|arfd
operator|!=
operator|-
literal|1
operator|&&
name|gzip_program
operator|!=
name|NULL
condition|)
name|ar_start_gzip
argument_list|(
name|arfd
argument_list|,
name|gzip_program
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARCHIVE
case|:
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|arfd
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|arcname
operator|=
name|stdo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|arfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|AR_MODE
argument_list|,
name|DMOD
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syswarn
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Failed open to write on %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|can_unlnk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arfd
operator|!=
operator|-
literal|1
operator|&&
name|gzip_program
operator|!=
name|NULL
condition|)
name|ar_start_gzip
argument_list|(
name|arfd
argument_list|,
name|gzip_program
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|APPND
case|:
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|arfd
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|arcname
operator|=
name|stdo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|arfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|APP_MODE
argument_list|,
name|DMOD
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syswarn
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Failed open to read/write on %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|COPY
case|:
comment|/* 		 * arfd not used in COPY mode 		 */
name|arcname
operator|=
name|none
expr_stmt|;
name|lstrval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|arfd
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|chdname
operator|!=
name|NULL
condition|)
if|if
condition|(
name|chdir
argument_list|(
name|chdname
argument_list|)
operator|!=
literal|0
condition|)
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed chdir to %s"
argument_list|,
name|chdname
argument_list|)
expr_stmt|;
comment|/* 	 * set up is based on device type 	 */
if|if
condition|(
name|fstat
argument_list|(
name|arfd
argument_list|,
operator|&
name|arsb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syswarn
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Failed stat on %s"
argument_list|,
name|arcname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|arfd
argument_list|)
expr_stmt|;
name|arfd
operator|=
operator|-
literal|1
expr_stmt|;
name|can_unlnk
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|arsb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"Cannot write an archive on top of a directory %s"
argument_list|,
name|arcname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|arfd
argument_list|)
expr_stmt|;
name|arfd
operator|=
operator|-
literal|1
expr_stmt|;
name|can_unlnk
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|S_ISCHR
argument_list|(
name|arsb
operator|.
name|st_mode
argument_list|)
condition|)
name|artyp
operator|=
name|ioctl
argument_list|(
name|arfd
argument_list|,
name|MTIOCGET
argument_list|,
operator|&
name|mb
argument_list|)
condition|?
name|ISCHR
else|:
name|ISTAPE
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|arsb
operator|.
name|st_mode
argument_list|)
condition|)
name|artyp
operator|=
name|ISBLK
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lseek
argument_list|(
name|arfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|ESPIPE
operator|)
condition|)
name|artyp
operator|=
name|ISPIPE
expr_stmt|;
else|else
name|artyp
operator|=
name|ISREG
expr_stmt|;
comment|/* 	 * make sure we beyond any doubt that we only can unlink regular files 	 * we created 	 */
if|if
condition|(
name|artyp
operator|!=
name|ISREG
condition|)
name|can_unlnk
operator|=
literal|0
expr_stmt|;
comment|/* 	 * if we are writing, we are done 	 */
if|if
condition|(
name|act
operator|==
name|ARCHIVE
condition|)
block|{
name|blksz
operator|=
name|rdblksz
operator|=
name|wrblksz
expr_stmt|;
name|lstrval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * set default blksz on read. APPNDs writes rdblksz on the last volume 	 * On all new archive volumes, we shift to wrblksz (if the user 	 * specified one, otherwize we will continue to use rdblksz). We 	 * must to set blocksize based on what kind of device the archive is 	 * stored. 	 */
switch|switch
condition|(
name|artyp
condition|)
block|{
case|case
name|ISTAPE
case|:
comment|/* 		 * Tape drives come in at least two flavors. Those that support 		 * variable sized records and those that have fixed sized 		 * records. They must be treated differently. For tape drives 		 * that support variable sized records, we must make large 		 * reads to make sure we get the entire record, otherwise we 		 * will just get the first part of the record (up to size we 		 * asked). Tapes with fixed sized records may or may not return 		 * multiple records in a single read. We really do not care 		 * what the physical record size is UNLESS we are going to 		 * append. (We will need the physical block size to rewrite 		 * the trailer). Only when we are appending do we go to the 		 * effort to figure out the true PHYSICAL record size. 		 */
name|blksz
operator|=
name|rdblksz
operator|=
name|MAXBLK
expr_stmt|;
break|break;
case|case
name|ISPIPE
case|:
case|case
name|ISBLK
case|:
case|case
name|ISCHR
case|:
comment|/* 		 * Blocksize is not a major issue with these devices (but must 		 * be kept a multiple of 512). If the user specified a write 		 * block size, we use that to read. Under append, we must 		 * always keep blksz == rdblksz. Otherwise we go ahead and use 		 * the device optimal blocksize as (and if) returned by stat 		 * and if it is within pax specs. 		 */
if|if
condition|(
operator|(
name|act
operator|==
name|APPND
operator|)
operator|&&
name|wrblksz
condition|)
block|{
name|blksz
operator|=
name|rdblksz
operator|=
name|wrblksz
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|arsb
operator|.
name|st_blksize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|arsb
operator|.
name|st_blksize
operator|<
name|MAXBLK
operator|)
operator|&&
operator|(
operator|(
name|arsb
operator|.
name|st_blksize
operator|%
name|BLKMULT
operator|)
operator|==
literal|0
operator|)
condition|)
name|rdblksz
operator|=
name|arsb
operator|.
name|st_blksize
expr_stmt|;
else|else
name|rdblksz
operator|=
name|DEVBLK
expr_stmt|;
comment|/* 		 * For performance go for large reads when we can without harm 		 */
if|if
condition|(
operator|(
name|act
operator|==
name|APPND
operator|)
operator|||
operator|(
name|artyp
operator|==
name|ISCHR
operator|)
condition|)
name|blksz
operator|=
name|rdblksz
expr_stmt|;
else|else
name|blksz
operator|=
name|MAXBLK
expr_stmt|;
break|break;
case|case
name|ISREG
case|:
comment|/* 		 * if the user specified wrblksz works, use it. Under appends 		 * we must always keep blksz == rdblksz 		 */
if|if
condition|(
operator|(
name|act
operator|==
name|APPND
operator|)
operator|&&
name|wrblksz
operator|&&
operator|(
operator|(
name|arsb
operator|.
name|st_size
operator|%
name|wrblksz
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|blksz
operator|=
name|rdblksz
operator|=
name|wrblksz
expr_stmt|;
break|break;
block|}
comment|/* 		 * See if we can find the blocking factor from the file size 		 */
for|for
control|(
name|rdblksz
operator|=
name|MAXBLK
init|;
name|rdblksz
operator|>
literal|0
condition|;
name|rdblksz
operator|-=
name|BLKMULT
control|)
if|if
condition|(
operator|(
name|arsb
operator|.
name|st_size
operator|%
name|rdblksz
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * When we cannot find a match, we may have a flawed archive. 		 */
if|if
condition|(
name|rdblksz
operator|<=
literal|0
condition|)
name|rdblksz
operator|=
name|FILEBLK
expr_stmt|;
comment|/* 		 * for performance go for large reads when we can 		 */
if|if
condition|(
name|act
operator|==
name|APPND
condition|)
name|blksz
operator|=
name|rdblksz
expr_stmt|;
else|else
name|blksz
operator|=
name|MAXBLK
expr_stmt|;
break|break;
default|default:
comment|/* 		 * should never happen, worse case, slow... 		 */
name|blksz
operator|=
name|rdblksz
operator|=
name|BLKMULT
expr_stmt|;
break|break;
block|}
name|lstrval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar_close()  *	closes archive device, increments volume number, and prints i/o summary  */
end_comment

begin_function
name|void
name|ar_close
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|arfd
operator|<
literal|0
condition|)
block|{
name|did_io
operator|=
name|io_ok
operator|=
name|flcnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * Close archive file. This may take a LONG while on tapes (we may be 	 * forced to wait for the rewind to complete) so tell the user what is 	 * going on (this avoids the user hitting control-c thinking pax is 	 * broken). 	 */
if|if
condition|(
name|vflag
operator|&&
operator|(
name|artyp
operator|==
name|ISTAPE
operator|)
condition|)
block|{
if|if
condition|(
name|vfpart
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|listf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|listf
argument_list|,
literal|"%s: Waiting for tape drive close to complete..."
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|listf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * if nothing was written to the archive (and we created it), we remove 	 * it 	 */
if|if
condition|(
name|can_unlnk
operator|&&
operator|(
name|fstat
argument_list|(
name|arfd
argument_list|,
operator|&
name|arsb
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|S_ISREG
argument_list|(
name|arsb
operator|.
name|st_mode
argument_list|)
operator|)
operator|&&
operator|(
name|arsb
operator|.
name|st_size
operator|==
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|arcname
argument_list|)
expr_stmt|;
name|can_unlnk
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * for a quick extract/list, pax frequently exits before the child 	 * process is done 	 */
if|if
condition|(
operator|(
name|act
operator|==
name|LIST
operator|||
name|act
operator|==
name|EXTRACT
operator|)
operator|&&
name|nflag
operator|&&
name|zpid
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
name|kill
argument_list|(
name|zpid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|waitpid
argument_list|(
name|zpid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|arfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|&&
operator|(
name|artyp
operator|==
name|ISTAPE
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"done.\n"
argument_list|,
name|listf
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|listf
argument_list|)
expr_stmt|;
block|}
name|arfd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|io_ok
operator|&&
operator|!
name|did_io
condition|)
block|{
name|flcnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|did_io
operator|=
name|io_ok
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The volume number is only increased when the last device has data 	 * and we have already determined the archive format. 	 */
if|if
condition|(
name|frmt
operator|!=
name|NULL
condition|)
operator|++
name|arvol
expr_stmt|;
if|if
condition|(
operator|!
name|vflag
condition|)
block|{
name|flcnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * Print out a summary of I/O for this archive volume. 	 */
if|if
condition|(
name|vfpart
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|listf
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If we have not determined the format yet, we just say how many bytes 	 * we have skipped over looking for a header to id. there is no way we 	 * could have written anything yet. 	 */
if|if
condition|(
name|frmt
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|NET2_STAT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|listf
argument_list|,
literal|"%s: unknown format, %lu bytes skipped.\n"
argument_list|,
name|argv0
argument_list|,
name|rdcnt
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|listf
argument_list|,
literal|"%s: unknown format, %ju bytes skipped.\n"
argument_list|,
name|argv0
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rdcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|listf
argument_list|)
expr_stmt|;
name|flcnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|NM_CPIO
argument_list|,
name|argv0
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|listf
argument_list|,
literal|"%llu blocks\n"
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
operator|(
name|rdcnt
condition|?
name|rdcnt
else|:
name|wrcnt
operator|)
operator|/
literal|5120
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|NM_TAR
argument_list|,
name|argv0
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|listf
argument_list|,
ifdef|#
directive|ifdef
name|NET2_STAT
literal|"%s: %s vol %d, %lu files, %lu bytes read, %lu bytes written.\n"
argument_list|,
name|argv0
argument_list|,
name|frmt
operator|->
name|name
argument_list|,
name|arvol
operator|-
literal|1
argument_list|,
name|flcnt
argument_list|,
name|rdcnt
argument_list|,
name|wrcnt
argument_list|)
expr_stmt|;
else|#
directive|else
literal|"%s: %s vol %d, %ju files, %ju bytes read, %ju bytes written.\n"
operator|,
name|argv0
operator|,
name|frmt
operator|->
name|name
operator|,
name|arvol
operator|-
literal|1
operator|,
operator|(
name|uintmax_t
operator|)
name|flcnt
operator|,
operator|(
name|uintmax_t
operator|)
name|rdcnt
operator|,
operator|(
name|uintmax_t
operator|)
name|wrcnt
block|)
function|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|listf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|flcnt
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * ar_drain()  *	drain any archive format independent padding from an archive read  *	from a socket or a pipe. This is to prevent the process on the  *	other side of the pipe from getting a SIGPIPE (pax will stop  *	reading an archive once a format dependent trailer is detected).  */
end_comment

begin_macro
unit|void
name|ar_drain
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|int
name|res
decl_stmt|;
name|char
name|drbuf
index|[
name|MAXBLK
index|]
decl_stmt|;
comment|/* 	 * we only drain from a pipe/socket. Other devices can be closed 	 * without reading up to end of file. We sure hope that pipe is closed 	 * on the other side so we will get an EOF. 	 */
if|if
condition|(
operator|(
name|artyp
operator|!=
name|ISPIPE
operator|)
operator|||
operator|(
name|lstrval
operator|<=
literal|0
operator|)
condition|)
return|return;
comment|/* 	 * keep reading until pipe is drained 	 */
while|while
condition|(
operator|(
name|res
operator|=
name|read
argument_list|(
name|arfd
argument_list|,
name|drbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|drbuf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
empty_stmt|;
name|lstrval
operator|=
name|res
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * ar_set_wr()  *	Set up device right before switching from read to write in an append.  *	device dependent code (if required) to do this should be added here.  *	For all archive devices we are already positioned at the place we want  *	to start writing when this routine is called.  * Return:  *	0 if all ready to write, -1 otherwise  */
end_comment

begin_function
name|int
name|ar_set_wr
parameter_list|(
name|void
parameter_list|)
block|{
name|off_t
name|cpos
decl_stmt|;
comment|/* 	 * we must make sure the trailer is rewritten on append, ar_next() 	 * will stop us if the archive containing the trailer was not written 	 */
name|wr_trail
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Add any device dependent code as required here 	 */
if|if
condition|(
name|artyp
operator|!=
name|ISREG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Ok we have an archive in a regular file. If we were rewriting a 	 * file, we must get rid of all the stuff after the current offset 	 * (it was not written by pax). 	 */
if|if
condition|(
operator|(
operator|(
name|cpos
operator|=
name|lseek
argument_list|(
name|arfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|ftruncate
argument_list|(
name|arfd
argument_list|,
name|cpos
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to truncate archive file"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar_app_ok()  *	check if the last volume in the archive allows appends. We cannot check  *	this until we are ready to write since there is no spec that says all  *	volumes in a single archive have to be of the same type...  * Return:  *	0 if we can append, -1 otherwise.  */
end_comment

begin_function
name|int
name|ar_app_ok
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|artyp
operator|==
name|ISPIPE
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Cannot append to an archive obtained from a pipe."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|invld_rec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Cannot append, device record size %d does not support %s spec"
argument_list|,
name|rdblksz
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar_read()  *	read up to a specified number of bytes from the archive into the  *	supplied buffer. When dealing with tapes we may not always be able to  *	read what we want.  * Return:  *	Number of bytes in buffer. 0 for end of file, -1 for a read error.  */
end_comment

begin_function
name|int
name|ar_read
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
comment|/* 	 * if last i/o was in error, no more reads until reset or new volume 	 */
if|if
condition|(
name|lstrval
operator|<=
literal|0
condition|)
return|return
operator|(
name|lstrval
operator|)
return|;
comment|/* 	 * how we read must be based on device type 	 */
switch|switch
condition|(
name|artyp
condition|)
block|{
case|case
name|ISTAPE
case|:
if|if
condition|(
operator|(
name|res
operator|=
name|read
argument_list|(
name|arfd
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* 			 * CAUTION: tape systems may not always return the same 			 * sized records so we leave blksz == MAXBLK. The 			 * physical record size that a tape drive supports is 			 * very hard to determine in a uniform and portable 			 * manner. 			 */
name|io_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|rdblksz
condition|)
block|{
comment|/* 				 * Record size changed. If this is happens on 				 * any record after the first, we probably have 				 * a tape drive which has a fixed record size 				 * we are getting multiple records in a single 				 * read). Watch out for record blocking that 				 * violates pax spec (must be a multiple of 				 * BLKMULT). 				 */
name|rdblksz
operator|=
name|res
expr_stmt|;
if|if
condition|(
name|rdblksz
operator|%
name|BLKMULT
condition|)
name|invld_rec
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
break|break;
case|case
name|ISREG
case|:
case|case
name|ISBLK
case|:
case|case
name|ISCHR
case|:
case|case
name|ISPIPE
case|:
default|default:
comment|/* 		 * Files are so easy to deal with. These other things cannot 		 * be trusted at all. So when we are dealing with character 		 * devices and pipes we just take what they have ready for us 		 * and return. Trying to do anything else with them runs the 		 * risk of failure. 		 */
if|if
condition|(
operator|(
name|res
operator|=
name|read
argument_list|(
name|arfd
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|io_ok
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
break|break;
block|}
comment|/* 	 * We are in trouble at this point, something is broken... 	 */
name|lstrval
operator|=
name|res
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed read on archive volume %d"
argument_list|,
name|arvol
argument_list|)
expr_stmt|;
else|else
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"End of archive volume %d reached"
argument_list|,
name|arvol
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar_write()  *	Write a specified number of bytes in supplied buffer to the archive  *	device so it appears as a single "block". Deals with errors and tries  *	to recover when faced with short writes.  * Return:  *	Number of bytes written. 0 indicates end of volume reached and with no  *	flaws (as best that can be detected). A -1 indicates an unrecoverable  *	error in the archive occured.  */
end_comment

begin_function
name|int
name|ar_write
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|bsz
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|off_t
name|cpos
decl_stmt|;
comment|/* 	 * do not allow pax to create a "bad" archive. Once a write fails on 	 * an archive volume prevent further writes to it. 	 */
if|if
condition|(
name|lstrval
operator|<=
literal|0
condition|)
return|return
operator|(
name|lstrval
operator|)
return|;
if|if
condition|(
operator|(
name|res
operator|=
name|write
argument_list|(
name|arfd
argument_list|,
name|buf
argument_list|,
name|bsz
argument_list|)
operator|)
operator|==
name|bsz
condition|)
block|{
name|wr_trail
operator|=
literal|1
expr_stmt|;
name|io_ok
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|bsz
operator|)
return|;
block|}
comment|/* 	 * write broke, see what we can do with it. We try to send any partial 	 * writes that may violate pax spec to the next archive volume. 	 */
if|if
condition|(
name|res
operator|<
literal|0
condition|)
name|lstrval
operator|=
name|res
expr_stmt|;
else|else
name|lstrval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|artyp
condition|)
block|{
case|case
name|ISREG
case|:
if|if
condition|(
operator|(
name|res
operator|>
literal|0
operator|)
operator|&&
operator|(
name|res
operator|%
name|BLKMULT
operator|)
condition|)
block|{
comment|/* 		 	 * try to fix up partial writes which are not BLKMULT 			 * in size by forcing the runt record to next archive 			 * volume 		 	 */
if|if
condition|(
operator|(
name|cpos
operator|=
name|lseek
argument_list|(
name|arfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
name|cpos
operator|-=
operator|(
name|off_t
operator|)
name|res
expr_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|arfd
argument_list|,
name|cpos
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|res
operator|=
name|lstrval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
break|break;
comment|/* 		 * if file is out of space, handle it like a return of 0 		 */
if|if
condition|(
operator|(
name|errno
operator|==
name|ENOSPC
operator|)
operator|||
operator|(
name|errno
operator|==
name|EFBIG
operator|)
operator|||
operator|(
name|errno
operator|==
name|EDQUOT
operator|)
condition|)
name|res
operator|=
name|lstrval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ISTAPE
case|:
case|case
name|ISCHR
case|:
case|case
name|ISBLK
case|:
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
block|{
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"Write failed, archive is write protected."
argument_list|)
expr_stmt|;
name|res
operator|=
name|lstrval
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * see if we reached the end of media, if so force a change to 		 * the next volume 		 */
if|if
condition|(
operator|(
name|errno
operator|==
name|ENOSPC
operator|)
operator|||
operator|(
name|errno
operator|==
name|EIO
operator|)
operator|||
operator|(
name|errno
operator|==
name|ENXIO
operator|)
condition|)
name|res
operator|=
name|lstrval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ISPIPE
case|:
default|default:
comment|/* 		 * we cannot fix errors to these devices 		 */
break|break;
block|}
comment|/* 	 * Better tell the user the bad news... 	 * if this is a block aligned archive format, we may have a bad archive 	 * if the format wants the header to start at a BLKMULT boundary. While 	 * we can deal with the mis-aligned data, it violates spec and other 	 * archive readers will likely fail. if the format is not block 	 * aligned, the user may be lucky (and the archive is ok). 	 */
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|res
operator|>
literal|0
condition|)
name|wr_trail
operator|=
literal|1
expr_stmt|;
name|io_ok
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If we were trying to rewrite the trailer and it didn't work, we 	 * must quit right away. 	 */
if|if
condition|(
operator|!
name|wr_trail
operator|&&
operator|(
name|res
operator|<=
literal|0
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Unable to append, trailer re-write failed. Quitting."
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
if|if
condition|(
name|res
operator|==
literal|0
condition|)
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"End of archive volume %d reached"
argument_list|,
name|arvol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|res
operator|<
literal|0
condition|)
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed write to archive volume: %d"
argument_list|,
name|arvol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|frmt
operator|->
name|blkalgn
operator|||
operator|(
operator|(
name|res
operator|%
name|frmt
operator|->
name|blkalgn
operator|)
operator|==
literal|0
operator|)
condition|)
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"WARNING: partial archive write. Archive MAY BE FLAWED"
argument_list|)
expr_stmt|;
else|else
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"WARNING: partial archive write. Archive IS FLAWED"
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar_rdsync()  *	Try to move past a bad spot on a flawed archive as needed to continue  *	I/O. Clears error flags to allow I/O to continue.  * Return:  *	0 when ok to try i/o again, -1 otherwise.  */
end_comment

begin_function
name|int
name|ar_rdsync
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|fsbz
decl_stmt|;
name|off_t
name|cpos
decl_stmt|;
name|off_t
name|mpos
decl_stmt|;
name|struct
name|mtop
name|mb
decl_stmt|;
comment|/* 	 * Fail resync attempts at user request (done) or this is going to be 	 * an update/append to an existing archive. If last i/o hit media end, 	 * we need to go to the next volume not try a resync. 	 */
if|if
condition|(
operator|(
name|done
operator|>
literal|0
operator|)
operator|||
operator|(
name|lstrval
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|act
operator|==
name|APPND
operator|)
operator|||
operator|(
name|act
operator|==
name|ARCHIVE
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Cannot allow updates to an archive with flaws."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|io_ok
condition|)
name|did_io
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|artyp
condition|)
block|{
case|case
name|ISTAPE
case|:
comment|/* 		 * if the last i/o was a successful data transfer, we assume 		 * the fault is just a bad record on the tape that we are now 		 * past. If we did not get any data since the last resync try 		 * to move the tape forward one PHYSICAL record past any 		 * damaged tape section. Some tape drives are stubborn and need 		 * to be pushed. 		 */
if|if
condition|(
name|io_ok
condition|)
block|{
name|io_ok
operator|=
literal|0
expr_stmt|;
name|lstrval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|mb
operator|.
name|mt_op
operator|=
name|MTFSR
expr_stmt|;
name|mb
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|arfd
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|mb
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|lstrval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ISREG
case|:
case|case
name|ISCHR
case|:
case|case
name|ISBLK
case|:
comment|/* 		 * try to step over the bad part of the device. 		 */
name|io_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|fsbz
operator|=
name|arsb
operator|.
name|st_blksize
operator|)
operator|<=
literal|0
operator|)
operator|||
operator|(
name|artyp
operator|!=
name|ISREG
operator|)
condition|)
name|fsbz
operator|=
name|BLKMULT
expr_stmt|;
if|if
condition|(
operator|(
name|cpos
operator|=
name|lseek
argument_list|(
name|arfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
name|mpos
operator|=
name|fsbz
operator|-
operator|(
name|cpos
operator|%
operator|(
name|off_t
operator|)
name|fsbz
operator|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|arfd
argument_list|,
name|mpos
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|lstrval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ISPIPE
case|:
default|default:
comment|/* 		 * cannot recover on these archive device types 		 */
name|io_ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lstrval
operator|<=
literal|0
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Unable to recover from an archive read failure."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"Attempting to recover from an archive read failure."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar_fow()  *	Move the I/O position within the archive foward the specified number of  *	bytes as supported by the device. If we cannot move the requested  *	number of bytes, return the actual number of bytes moved in skipped.  * Return:  *	0 if moved the requested distance, -1 on complete failure, 1 on  *	partial move (the amount moved is in skipped)  */
end_comment

begin_function
name|int
name|ar_fow
parameter_list|(
name|off_t
name|sksz
parameter_list|,
name|off_t
modifier|*
name|skipped
parameter_list|)
block|{
name|off_t
name|cpos
decl_stmt|;
name|off_t
name|mpos
decl_stmt|;
operator|*
name|skipped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sksz
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * we cannot move foward at EOF or error 	 */
if|if
condition|(
name|lstrval
operator|<=
literal|0
condition|)
return|return
operator|(
name|lstrval
operator|)
return|;
comment|/* 	 * Safer to read forward on devices where it is hard to find the end of 	 * the media without reading to it. With tapes we cannot be sure of the 	 * number of physical blocks to skip (we do not know physical block 	 * size at this point), so we must only read foward on tapes! 	 */
if|if
condition|(
name|artyp
operator|!=
name|ISREG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * figure out where we are in the archive 	 */
if|if
condition|(
operator|(
name|cpos
operator|=
name|lseek
argument_list|(
name|arfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* 	 	 * we can be asked to move farther than there are bytes in this 		 * volume, if so, just go to file end and let normal buf_fill() 		 * deal with the end of file (it will go to next volume by 		 * itself) 	 	 */
if|if
condition|(
operator|(
name|mpos
operator|=
name|cpos
operator|+
name|sksz
operator|)
operator|>
name|arsb
operator|.
name|st_size
condition|)
block|{
operator|*
name|skipped
operator|=
name|arsb
operator|.
name|st_size
operator|-
name|cpos
expr_stmt|;
name|mpos
operator|=
name|arsb
operator|.
name|st_size
expr_stmt|;
block|}
else|else
operator|*
name|skipped
operator|=
name|sksz
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|arfd
argument_list|,
name|mpos
argument_list|,
name|SEEK_SET
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Forward positioning operation on archive failed"
argument_list|)
expr_stmt|;
name|lstrval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar_rev()  *	move the i/o position within the archive backwards the specified byte  *	count as supported by the device. With tapes drives we RESET rdblksz to  *	the PHYSICAL blocksize.  *	NOTE: We should only be called to move backwards so we can rewrite the  *	last records (the trailer) of an archive (APPEND).  * Return:  *	0 if moved the requested distance, -1 on complete failure  */
end_comment

begin_function
name|int
name|ar_rev
parameter_list|(
name|off_t
name|sksz
parameter_list|)
block|{
name|off_t
name|cpos
decl_stmt|;
name|struct
name|mtop
name|mb
decl_stmt|;
name|int
name|phyblk
decl_stmt|;
comment|/* 	 * make sure we do not have try to reverse on a flawed archive 	 */
if|if
condition|(
name|lstrval
operator|<
literal|0
condition|)
return|return
operator|(
name|lstrval
operator|)
return|;
switch|switch
condition|(
name|artyp
condition|)
block|{
case|case
name|ISPIPE
case|:
if|if
condition|(
name|sksz
operator|<=
literal|0
condition|)
break|break;
comment|/* 		 * cannot go backwards on these critters 		 */
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Reverse positioning on pipes is not supported."
argument_list|)
expr_stmt|;
name|lstrval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|ISREG
case|:
case|case
name|ISBLK
case|:
case|case
name|ISCHR
case|:
default|default:
if|if
condition|(
name|sksz
operator|<=
literal|0
condition|)
break|break;
comment|/* 		 * For things other than files, backwards movement has a very 		 * high probability of failure as we really do not know the 		 * true attributes of the device we are talking to (the device 		 * may not even have the ability to lseek() in any direction). 		 * First we figure out where we are in the archive. 		 */
if|if
condition|(
operator|(
name|cpos
operator|=
name|lseek
argument_list|(
name|arfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to obtain current archive byte offset"
argument_list|)
expr_stmt|;
name|lstrval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * we may try to go backwards past the start when the archive 		 * is only a single record. If this hapens and we are on a 		 * multi volume archive, we need to go to the end of the 		 * previous volume and continue our movement backwards from 		 * there. 		 */
if|if
condition|(
operator|(
name|cpos
operator|-=
name|sksz
operator|)
operator|<
operator|(
name|off_t
operator|)
literal|0L
condition|)
block|{
if|if
condition|(
name|arvol
operator|>
literal|1
condition|)
block|{
comment|/* 				 * this should never happen 				 */
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Reverse position on previous volume."
argument_list|)
expr_stmt|;
name|lstrval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cpos
operator|=
operator|(
name|off_t
operator|)
literal|0L
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|arfd
argument_list|,
name|cpos
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to seek archive backwards"
argument_list|)
expr_stmt|;
name|lstrval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|ISTAPE
case|:
comment|/* 	 	 * Calculate and move the proper number of PHYSICAL tape 		 * blocks. If the sksz is not an even multiple of the physical 		 * tape size, we cannot do the move (this should never happen). 		 * (We also cannot handler trailers spread over two vols). 		 * get_phys() also makes sure we are in front of the filemark. 	 	 */
if|if
condition|(
operator|(
name|phyblk
operator|=
name|get_phys
argument_list|()
operator|)
operator|<=
literal|0
condition|)
block|{
name|lstrval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * make sure future tape reads only go by physical tape block 		 * size (set rdblksz to the real size). 		 */
name|rdblksz
operator|=
name|phyblk
expr_stmt|;
comment|/* 		 * if no movement is required, just return (we must be after 		 * get_phys() so the physical blocksize is properly set) 		 */
if|if
condition|(
name|sksz
operator|<=
literal|0
condition|)
break|break;
comment|/* 		 * ok we have to move. Make sure the tape drive can do it. 		 */
if|if
condition|(
name|sksz
operator|%
name|phyblk
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Tape drive unable to backspace requested amount"
argument_list|)
expr_stmt|;
name|lstrval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * move backwards the requested number of bytes 		 */
name|mb
operator|.
name|mt_op
operator|=
name|MTBSR
expr_stmt|;
name|mb
operator|.
name|mt_count
operator|=
name|sksz
operator|/
name|phyblk
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|arfd
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|mb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to backspace tape %d blocks."
argument_list|,
name|mb
operator|.
name|mt_count
argument_list|)
expr_stmt|;
name|lstrval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
block|}
name|lstrval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get_phys()  *	Determine the physical block size on a tape drive. We need the physical  *	block size so we know how many bytes we skip over when we move with  *	mtio commands. We also make sure we are BEFORE THE TAPE FILEMARK when  *	return.  *	This is one really SLOW routine...  * Return:  *	physical block size if ok (ok> 0), -1 otherwise  */
end_comment

begin_function
specifier|static
name|int
name|get_phys
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|padsz
init|=
literal|0
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|phyblk
decl_stmt|;
name|struct
name|mtop
name|mb
decl_stmt|;
name|char
name|scbuf
index|[
name|MAXBLK
index|]
decl_stmt|;
comment|/* 	 * move to the file mark, and then back up one record and read it. 	 * this should tell us the physical record size the tape is using. 	 */
if|if
condition|(
name|lstrval
operator|==
literal|1
condition|)
block|{
comment|/* 		 * we know we are at file mark when we get back a 0 from 		 * read() 		 */
while|while
condition|(
operator|(
name|res
operator|=
name|read
argument_list|(
name|arfd
argument_list|,
name|scbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|scbuf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|padsz
operator|+=
name|res
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to locate tape filemark."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * move backwards over the file mark so we are at the end of the 	 * last record. 	 */
name|mb
operator|.
name|mt_op
operator|=
name|MTBSF
expr_stmt|;
name|mb
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|arfd
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|mb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to backspace over tape filemark."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * move backwards so we are in front of the last record and read it to 	 * get physical tape blocksize. 	 */
name|mb
operator|.
name|mt_op
operator|=
name|MTBSR
expr_stmt|;
name|mb
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|arfd
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|mb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to backspace over last tape block."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|phyblk
operator|=
name|read
argument_list|(
name|arfd
argument_list|,
name|scbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|scbuf
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Cannot determine archive tape blocksize."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * read foward to the file mark, then back up in front of the filemark 	 * (this is a bit paranoid, but should be safe to do). 	 */
while|while
condition|(
operator|(
name|res
operator|=
name|read
argument_list|(
name|arfd
argument_list|,
name|scbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|scbuf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to locate tape filemark."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mb
operator|.
name|mt_op
operator|=
name|MTBSF
expr_stmt|;
name|mb
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|arfd
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|mb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to backspace over tape filemark."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * set lstrval so we know that the filemark has not been seen 	 */
name|lstrval
operator|=
literal|1
expr_stmt|;
comment|/* 	 * return if there was no padding 	 */
if|if
condition|(
name|padsz
operator|==
literal|0
condition|)
return|return
operator|(
name|phyblk
operator|)
return|;
comment|/* 	 * make sure we can move backwards over the padding. (this should 	 * never fail). 	 */
if|if
condition|(
name|padsz
operator|%
name|phyblk
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Tape drive unable to backspace requested amount"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * move backwards over the padding so the head is where it was when 	 * we were first called (if required). 	 */
name|mb
operator|.
name|mt_op
operator|=
name|MTBSR
expr_stmt|;
name|mb
operator|.
name|mt_count
operator|=
name|padsz
operator|/
name|phyblk
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|arfd
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|mb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syswarn
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Unable to backspace tape over %d pad blocks"
argument_list|,
name|mb
operator|.
name|mt_count
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|phyblk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar_next()  *	prompts the user for the next volume in this archive. For some devices  *	we may allow the media to be changed. Otherwise a new archive is  *	prompted for. By pax spec, if there is no controlling tty or an eof is  *	read on tty input, we must quit pax.  * Return:  *	0 when ready to continue, -1 when all done  */
end_comment

begin_function
name|int
name|ar_next
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
name|PAXPATHLEN
operator|+
literal|2
index|]
decl_stmt|;
specifier|static
name|int
name|freeit
init|=
literal|0
decl_stmt|;
name|sigset_t
name|o_mask
decl_stmt|;
comment|/* 	 * WE MUST CLOSE THE DEVICE. A lot of devices must see last close, (so 	 * things like writing EOF etc will be done) (Watch out ar_close() can 	 * also be called via a signal handler, so we must prevent a race. 	 */
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|s_mask
argument_list|,
operator|&
name|o_mask
argument_list|)
operator|<
literal|0
condition|)
name|syswarn
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Unable to set signal mask"
argument_list|)
expr_stmt|;
name|ar_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|o_mask
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|syswarn
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Unable to restore signal mask"
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
operator|||
operator|!
name|wr_trail
operator|||
name|strcmp
argument_list|(
name|NM_TAR
argument_list|,
name|argv0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tty_prnt
argument_list|(
literal|"\nATTENTION! %s archive volume change required.\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
comment|/* 	 * if i/o is on stdin or stdout, we cannot reopen it (we do not know 	 * the name), the user will be forced to type it in. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|arcname
argument_list|,
name|stdo
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|arcname
argument_list|,
name|stdn
argument_list|)
operator|&&
operator|(
name|artyp
operator|!=
name|ISREG
operator|)
operator|&&
operator|(
name|artyp
operator|!=
name|ISPIPE
operator|)
condition|)
block|{
if|if
condition|(
name|artyp
operator|==
name|ISTAPE
condition|)
block|{
name|tty_prnt
argument_list|(
literal|"%s ready for archive tape volume: %d\n"
argument_list|,
name|arcname
argument_list|,
name|arvol
argument_list|)
expr_stmt|;
name|tty_prnt
argument_list|(
literal|"Load the NEXT TAPE on the tape drive"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tty_prnt
argument_list|(
literal|"%s ready for archive volume: %d\n"
argument_list|,
name|arcname
argument_list|,
name|arvol
argument_list|)
expr_stmt|;
name|tty_prnt
argument_list|(
literal|"Load the NEXT STORAGE MEDIA (if required)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|act
operator|==
name|ARCHIVE
operator|)
operator|||
operator|(
name|act
operator|==
name|APPND
operator|)
condition|)
name|tty_prnt
argument_list|(
literal|" and make sure it is WRITE ENABLED.\n"
argument_list|)
expr_stmt|;
else|else
name|tty_prnt
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tty_prnt
argument_list|(
literal|"Type \"y\" to continue, \".\" to quit %s,"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
name|tty_prnt
argument_list|(
literal|" or \"s\" to switch to new device.\nIf you"
argument_list|)
expr_stmt|;
name|tty_prnt
argument_list|(
literal|" cannot change storage media, type \"s\"\n"
argument_list|)
expr_stmt|;
name|tty_prnt
argument_list|(
literal|"Is the device ready and online?> "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tty_read
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
name|lstrval
operator|=
operator|-
literal|1
expr_stmt|;
name|tty_prnt
argument_list|(
literal|"Quitting %s!\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|tty_prnt
argument_list|(
literal|"%s unknown command, try again\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
comment|/* 				 * we are to continue with the same device 				 */
if|if
condition|(
name|ar_open
argument_list|(
name|arcname
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tty_prnt
argument_list|(
literal|"Cannot re-open %s, try again\n"
argument_list|,
name|arcname
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
comment|/* 				 * user wants to open a different device 				 */
name|tty_prnt
argument_list|(
literal|"Switching to a different archive\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tty_prnt
argument_list|(
literal|"%s unknown command, try again\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
else|else
name|tty_prnt
argument_list|(
literal|"Ready for archive volume: %d\n"
argument_list|,
name|arvol
argument_list|)
expr_stmt|;
comment|/* 	 * have to go to a different archive 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|tty_prnt
argument_list|(
literal|"Input archive name or \".\" to quit %s.\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
name|tty_prnt
argument_list|(
literal|"Archive name> "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tty_read
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
name|lstrval
operator|=
operator|-
literal|1
expr_stmt|;
name|tty_prnt
argument_list|(
literal|"Quitting %s!\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
name|vfpart
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|tty_prnt
argument_list|(
literal|"Empty file name, try again\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|tty_prnt
argument_list|(
literal|"Illegal file name: .. try again\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|PAXPATHLEN
condition|)
block|{
name|tty_prnt
argument_list|(
literal|"File name too long, try again\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * try to open new archive 		 */
if|if
condition|(
name|ar_open
argument_list|(
name|buf
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|freeit
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|arcname
argument_list|)
expr_stmt|;
name|freeit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arcname
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
name|lstrval
operator|=
operator|-
literal|1
expr_stmt|;
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"Cannot save archive name."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|freeit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|tty_prnt
argument_list|(
literal|"Cannot open %s, try again\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ar_start_gzip()  * starts the gzip compression/decompression process as a child, using magic  * to keep the fd the same in the calling function (parent).  */
end_comment

begin_function
name|void
name|ar_start_gzip
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|gzip_prog
parameter_list|,
name|int
name|wr
parameter_list|)
block|{
name|int
name|fds
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|gzip_flags
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fds
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"could not pipe"
argument_list|)
expr_stmt|;
name|zpid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|zpid
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"could not fork"
argument_list|)
expr_stmt|;
comment|/* parent */
if|if
condition|(
name|zpid
condition|)
block|{
if|if
condition|(
name|wr
condition|)
name|dup2
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|else
name|dup2
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wr
condition|)
block|{
name|dup2
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|gzip_flags
operator|=
literal|"-c"
expr_stmt|;
block|}
else|else
block|{
name|dup2
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|gzip_flags
operator|=
literal|"-dc"
expr_stmt|;
block|}
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|execlp
argument_list|(
name|gzip_prog
argument_list|,
name|gzip_prog
argument_list|,
name|gzip_flags
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"could not exec"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

end_unit

