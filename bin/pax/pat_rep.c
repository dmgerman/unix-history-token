begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Keith Muller.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Keith Muller of the University of California, San Diego.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)pat_rep.c	8.2 (Berkeley) 4/18/94";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NET2_REGEX
end_ifdef

begin_include
include|#
directive|include
file|<regexp.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pax.h"
end_include

begin_include
include|#
directive|include
file|"pat_rep.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * routines to handle pattern matching, name modification (regular expression  * substitution and interactive renames), and destination name modification for  * copy (-rw). Both file name and link names are adjusted as required in these  * routines.  */
end_comment

begin_define
define|#
directive|define
name|MAXSUBEXP
value|10
end_define

begin_comment
comment|/* max subexpressions, DO NOT CHANGE */
end_comment

begin_decl_stmt
specifier|static
name|PATTERN
modifier|*
name|pathead
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file pattern match list head */
end_comment

begin_decl_stmt
specifier|static
name|PATTERN
modifier|*
name|pattail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file pattern match list tail */
end_comment

begin_decl_stmt
specifier|static
name|REPLACE
modifier|*
name|rephead
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* replacement string list head */
end_comment

begin_decl_stmt
specifier|static
name|REPLACE
modifier|*
name|reptail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* replacement string list tail */
end_comment

begin_function_decl
specifier|static
name|int
name|rep_name
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tty_rename
parameter_list|(
name|ARCHD
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fix_path
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fn_match
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|range_match
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NET2_REGEX
end_ifdef

begin_function_decl
specifier|static
name|int
name|resub
parameter_list|(
name|regexp
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|resub
parameter_list|(
name|regex_t
modifier|*
parameter_list|,
name|regmatch_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * rep_add()  *	parses the -s replacement string; compiles the regular expression  *	and stores the compiled value and it's replacement string together in  *	replacement string list. Input to this function is of the form:  *		/old/new/pg  *	The first char in the string specifies the delimiter used by this  *	replacement string. "Old" is a regular expression in "ed" format which  *	is compiled by regcomp() and is applied to filenames. "new" is the  *	substitution string; p and g are options flags for printing and global  *	replacement (over the single filename)  * Return:  *	0 if a proper replacement string and regular expression was added to  *	the list of replacement patterns; -1 otherwise.  */
end_comment

begin_function
name|int
name|rep_add
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|pt1
decl_stmt|;
name|char
modifier|*
name|pt2
decl_stmt|;
name|REPLACE
modifier|*
name|rep
decl_stmt|;
ifndef|#
directive|ifndef
name|NET2_REGEX
name|int
name|res
decl_stmt|;
name|char
name|rebuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * throw out the bad parameters 	 */
if|if
condition|(
operator|(
name|str
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|str
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Empty replacement string"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * first character in the string specifies what the delimiter is for 	 * this expression 	 */
if|if
condition|(
operator|(
name|pt1
operator|=
name|strchr
argument_list|(
name|str
operator|+
literal|1
argument_list|,
operator|*
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Invalid replacement string %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * allocate space for the node that handles this replacement pattern 	 * and split out the regular expression and try to compile it 	 */
if|if
condition|(
operator|(
name|rep
operator|=
operator|(
name|REPLACE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|REPLACE
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Unable to allocate memory for replacement string"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|pt1
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|NET2_REGEX
if|if
condition|(
operator|(
name|rep
operator|->
name|rcmp
operator|=
name|regcomp
argument_list|(
name|str
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|res
operator|=
name|regcomp
argument_list|(
operator|&
operator|(
name|rep
operator|->
name|rcmp
operator|)
argument_list|,
name|str
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|regerror
argument_list|(
name|res
argument_list|,
operator|&
operator|(
name|rep
operator|->
name|rcmp
operator|)
argument_list|,
name|rebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rebuf
argument_list|)
argument_list|)
expr_stmt|;
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"%s while compiling regular expression %s"
argument_list|,
name|rebuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rep
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * put the delimiter back in case we need an error message and 	 * locate the delimiter at the end of the replacement string 	 * we then point the node at the new substitution string 	 */
operator|*
name|pt1
operator|++
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
operator|(
name|pt2
operator|=
name|strchr
argument_list|(
name|pt1
argument_list|,
operator|*
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|NET2_REGEX
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rep
operator|->
name|rcmp
argument_list|)
expr_stmt|;
else|#
directive|else
name|regfree
argument_list|(
operator|&
operator|(
name|rep
operator|->
name|rcmp
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rep
argument_list|)
expr_stmt|;
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Invalid replacement string %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|pt2
operator|=
literal|'\0'
expr_stmt|;
name|rep
operator|->
name|nstr
operator|=
name|pt1
expr_stmt|;
name|pt1
operator|=
name|pt2
operator|++
expr_stmt|;
name|rep
operator|->
name|flgs
operator|=
literal|0
expr_stmt|;
comment|/* 	 * set the options if any 	 */
while|while
condition|(
operator|*
name|pt2
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
name|pt2
condition|)
block|{
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|rep
operator|->
name|flgs
operator||=
name|GLOB
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|rep
operator|->
name|flgs
operator||=
name|PRNT
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|NET2_REGEX
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rep
operator|->
name|rcmp
argument_list|)
expr_stmt|;
else|#
directive|else
name|regfree
argument_list|(
operator|&
operator|(
name|rep
operator|->
name|rcmp
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rep
argument_list|)
expr_stmt|;
operator|*
name|pt1
operator|=
operator|*
name|str
expr_stmt|;
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Invalid replacement string option %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|++
name|pt2
expr_stmt|;
block|}
comment|/* 	 * all done, link it in at the end 	 */
name|rep
operator|->
name|fow
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rephead
operator|==
name|NULL
condition|)
block|{
name|reptail
operator|=
name|rephead
operator|=
name|rep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reptail
operator|->
name|fow
operator|=
name|rep
expr_stmt|;
name|reptail
operator|=
name|rep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * pat_add()  *	add a pattern match to the pattern match list. Pattern matches are used  *	to select which archive members are extracted. (They appear as  *	arguments to pax in the list and read modes). If no patterns are  *	supplied to pax, all members in the archive will be selected (and the  *	pattern match list is empty).  * Return:  *	0 if the pattern was added to the list, -1 otherwise  */
name|int
name|pat_add
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
name|chdname
parameter_list|)
block|{
name|PATTERN
modifier|*
name|pt
decl_stmt|;
comment|/* 	 * throw out the junk 	 */
if|if
condition|(
operator|(
name|str
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|str
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Empty pattern string"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * allocate space for the pattern and store the pattern. the pattern is 	 * part of argv so do not bother to copy it, just point at it. Add the 	 * node to the end of the pattern list 	 */
if|if
condition|(
operator|(
name|pt
operator|=
operator|(
name|PATTERN
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PATTERN
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Unable to allocate memory for pattern string"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pt
operator|->
name|pstr
operator|=
name|str
expr_stmt|;
name|pt
operator|->
name|pend
operator|=
name|NULL
expr_stmt|;
name|pt
operator|->
name|plen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|pt
operator|->
name|fow
operator|=
name|NULL
expr_stmt|;
name|pt
operator|->
name|flgs
operator|=
literal|0
expr_stmt|;
name|pt
operator|->
name|chdname
operator|=
name|chdname
expr_stmt|;
if|if
condition|(
name|pathead
operator|==
name|NULL
condition|)
block|{
name|pattail
operator|=
name|pathead
operator|=
name|pt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pattail
operator|->
name|fow
operator|=
name|pt
expr_stmt|;
name|pattail
operator|=
name|pt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * pat_chk()  *	complain if any the user supplied pattern did not result in a match to  *	a selected archive member.  */
name|void
name|pat_chk
parameter_list|(
name|void
parameter_list|)
block|{
name|PATTERN
modifier|*
name|pt
decl_stmt|;
name|int
name|wban
init|=
literal|0
decl_stmt|;
comment|/* 	 * walk down the list checking the flags to make sure MTCH was set, 	 * if not complain 	 */
for|for
control|(
name|pt
operator|=
name|pathead
init|;
name|pt
operator|!=
name|NULL
condition|;
name|pt
operator|=
name|pt
operator|->
name|fow
control|)
block|{
if|if
condition|(
name|pt
operator|->
name|flgs
operator|&
name|MTCH
condition|)
continue|continue;
if|if
condition|(
operator|!
name|wban
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"WARNING! These patterns were not matched:"
argument_list|)
expr_stmt|;
operator|++
name|wban
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|pt
operator|->
name|pstr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * pat_sel()  *	the archive member which matches a pattern was selected. Mark the  *	pattern as having selected an archive member. arcn->pat points at the  *	pattern that was matched. arcn->pat is set in pat_match()  *  *	NOTE: When the -c option is used, we are called when there was no match  *	by pat_match() (that means we did match before the inverted sense of  *	the logic). Now this seems really strange at first, but with -c  we  *	need to keep track of those patterns that cause a archive member to NOT  *	be selected (it found an archive member with a specified pattern)  * Return:  *	0 if the pattern pointed at by arcn->pat was tagged as creating a  *	match, -1 otherwise.  */
name|int
name|pat_sel
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
name|PATTERN
modifier|*
name|pt
decl_stmt|;
name|PATTERN
modifier|*
modifier|*
name|ppt
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 	 * if no patterns just return 	 */
if|if
condition|(
operator|(
name|pathead
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|pt
operator|=
name|arcn
operator|->
name|pat
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * when we are NOT limited to a single match per pattern mark the 	 * pattern and return 	 */
if|if
condition|(
operator|!
name|nflag
condition|)
block|{
name|pt
operator|->
name|flgs
operator||=
name|MTCH
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * we reach this point only when we allow a single selected match per 	 * pattern, if the pattern matches a directory and we do not have -d 	 * (dflag) we are done with this pattern. We may also be handed a file 	 * in the subtree of a directory. in that case when we are operating 	 * with -d, this pattern was already selected and we are done 	 */
if|if
condition|(
name|pt
operator|->
name|flgs
operator|&
name|DIR_MTCH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|dflag
operator|&&
operator|(
operator|(
name|pt
operator|->
name|pend
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_DIR
operator|)
operator|)
condition|)
block|{
comment|/* 		 * ok we matched a directory and we are allowing 		 * subtree matches but because of the -n only its children will 		 * match. This is tagged as a DIR_MTCH type. 		 * WATCH IT, the code assumes that pt->pend points 		 * into arcn->name and arcn->name has not been modified. 		 * If not we will have a big mess. Yup this is another kludge 		 */
comment|/* 		 * if this was a prefix match, remove trailing part of path 		 * so we can copy it. Future matches will be exact prefix match 		 */
if|if
condition|(
name|pt
operator|->
name|pend
operator|!=
name|NULL
condition|)
operator|*
name|pt
operator|->
name|pend
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|->
name|pstr
operator|=
name|strdup
argument_list|(
name|arcn
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Pattern select out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|pend
operator|!=
name|NULL
condition|)
operator|*
name|pt
operator|->
name|pend
operator|=
literal|'/'
expr_stmt|;
name|pt
operator|->
name|pend
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * put the trailing / back in the source string 		 */
if|if
condition|(
name|pt
operator|->
name|pend
operator|!=
name|NULL
condition|)
block|{
operator|*
name|pt
operator|->
name|pend
operator|=
literal|'/'
expr_stmt|;
name|pt
operator|->
name|pend
operator|=
name|NULL
expr_stmt|;
block|}
name|pt
operator|->
name|plen
operator|=
name|strlen
argument_list|(
name|pt
operator|->
name|pstr
argument_list|)
expr_stmt|;
comment|/* 		 * strip off any trailing /, this should really never happen 		 */
name|len
operator|=
name|pt
operator|->
name|plen
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|pt
operator|->
name|pstr
operator|+
name|len
operator|)
operator|==
literal|'/'
condition|)
block|{
operator|*
operator|(
name|pt
operator|->
name|pstr
operator|+
name|len
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|pt
operator|->
name|plen
operator|=
name|len
expr_stmt|;
block|}
name|pt
operator|->
name|flgs
operator|=
name|DIR_MTCH
operator||
name|MTCH
expr_stmt|;
name|arcn
operator|->
name|pat
operator|=
name|pt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * we are then done with this pattern, so we delete it from the list 	 * because it can never be used for another match. 	 * Seems kind of strange to do for a -c, but the pax spec is really 	 * vague on the interaction of -c -n and -d. We assume that when -c 	 * and the pattern rejects a member (i.e. it matched it) it is done. 	 * In effect we place the order of the flags as having -c last. 	 */
name|pt
operator|=
name|pathead
expr_stmt|;
name|ppt
operator|=
operator|&
name|pathead
expr_stmt|;
while|while
condition|(
operator|(
name|pt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pt
operator|!=
name|arcn
operator|->
name|pat
operator|)
condition|)
block|{
name|ppt
operator|=
operator|&
operator|(
name|pt
operator|->
name|fow
operator|)
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
block|}
if|if
condition|(
name|pt
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * should never happen.... 		 */
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Pattern list inconsistant"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|ppt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|pat
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * pat_match()  *	see if this archive member matches any supplied pattern, if a match  *	is found, arcn->pat is set to point at the potential pattern. Later if  *	this archive member is "selected" we process and mark the pattern as  *	one which matched a selected archive member (see pat_sel())  * Return:  *	0 if this archive member should be processed, 1 if it should be  *	skipped and -1 if we are done with all patterns (and pax should quit  *	looking for more members)  */
name|int
name|pat_match
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
name|PATTERN
modifier|*
name|pt
decl_stmt|;
name|arcn
operator|->
name|pat
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * if there are no more patterns and we have -n (and not -c) we are 	 * done. otherwise with no patterns to match, matches all 	 */
if|if
condition|(
name|pathead
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nflag
operator|&&
operator|!
name|cflag
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * have to search down the list one at a time looking for a match. 	 */
name|pt
operator|=
name|pathead
expr_stmt|;
while|while
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * check for a file name match unless we have DIR_MTCH set in 		 * this pattern then we want a prefix match 		 */
if|if
condition|(
name|pt
operator|->
name|flgs
operator|&
name|DIR_MTCH
condition|)
block|{
comment|/* 			 * this pattern was matched before to a directory 			 * as we must have -n set for this (but not -d). We can 			 * only match CHILDREN of that directory so we must use 			 * an exact prefix match (no wildcards). 			 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|name
index|[
name|pt
operator|->
name|plen
index|]
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|pt
operator|->
name|pstr
argument_list|,
name|arcn
operator|->
name|name
argument_list|,
name|pt
operator|->
name|plen
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|fn_match
argument_list|(
name|pt
operator|->
name|pstr
argument_list|,
name|arcn
operator|->
name|name
argument_list|,
operator|&
name|pt
operator|->
name|pend
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|pt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
block|}
comment|/* 	 * return the result, remember that cflag (-c) inverts the sense of a 	 * match 	 */
if|if
condition|(
name|pt
operator|==
name|NULL
condition|)
return|return
operator|(
name|cflag
condition|?
literal|0
else|:
literal|1
operator|)
return|;
comment|/* 	 * we had a match, now when we invert the sense (-c) we reject this 	 * member. However we have to tag the pattern a being successful, (in a 	 * match, not in selecting a archive member) so we call pat_sel() here. 	 */
name|arcn
operator|->
name|pat
operator|=
name|pt
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pat_sel
argument_list|(
name|arcn
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|arcn
operator|->
name|pat
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * fn_match()  * Return:  *	0 if this archive member should be processed, 1 if it should be  *	skipped and -1 if we are done with all patterns (and pax should quit  *	looking for more members)  *	Note: *pend may be changed to show where the prefix ends.  */
specifier|static
name|int
name|fn_match
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
modifier|*
name|pend
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|char
name|test
decl_stmt|;
operator|*
name|pend
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|pattern
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* 			 * Ok we found an exact match 			 */
if|if
condition|(
operator|*
name|string
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * Check if it is a prefix match 			 */
if|if
condition|(
operator|(
name|dflag
operator|==
literal|1
operator|)
operator|||
operator|(
operator|*
name|string
operator|!=
literal|'/'
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 			 * It is a prefix match, remember where the trailing 			 * / is located 			 */
operator|*
name|pend
operator|=
name|string
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'?'
case|:
if|if
condition|(
operator|(
name|test
operator|=
operator|*
name|string
operator|++
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
literal|'*'
case|:
name|c
operator|=
operator|*
name|pattern
expr_stmt|;
comment|/* 			 * Collapse multiple *'s. 			 */
while|while
condition|(
name|c
operator|==
literal|'*'
condition|)
name|c
operator|=
operator|*
operator|++
name|pattern
expr_stmt|;
comment|/* 			 * Optimized hack for pattern with a * at the end 			 */
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * General case, use recursion. 			 */
while|while
condition|(
operator|(
name|test
operator|=
operator|*
name|string
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|fn_match
argument_list|(
name|pattern
argument_list|,
name|string
argument_list|,
name|pend
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|++
name|string
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|'['
case|:
comment|/* 			 * range match 			 */
if|if
condition|(
operator|(
operator|(
name|test
operator|=
operator|*
name|string
operator|++
operator|)
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|(
name|pattern
operator|=
name|range_match
argument_list|(
name|pattern
argument_list|,
name|test
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
literal|'\\'
case|:
default|default:
if|if
condition|(
name|c
operator|!=
operator|*
name|string
operator|++
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
block|}
comment|/* NOTREACHED */
block|}
specifier|static
name|char
modifier|*
name|range_match
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|test
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|char
name|c2
decl_stmt|;
name|int
name|negate
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|negate
operator|=
operator|(
operator|*
name|pattern
operator|==
literal|'!'
operator|)
operator|)
operator|!=
literal|0
condition|)
operator|++
name|pattern
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|pattern
operator|++
operator|)
operator|!=
literal|']'
condition|)
block|{
comment|/* 		 * Illegal pattern 		 */
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|pattern
operator|==
literal|'-'
operator|)
operator|&&
operator|(
operator|(
name|c2
operator|=
name|pattern
index|[
literal|1
index|]
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c2
operator|!=
literal|']'
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|<=
name|test
operator|)
operator|&&
operator|(
name|test
operator|<=
name|c2
operator|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
name|pattern
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|test
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ok
operator|==
name|negate
condition|?
name|NULL
else|:
name|pattern
operator|)
return|;
block|}
comment|/*  * mod_name()  *	modify a selected file name. first attempt to apply replacement string  *	expressions, then apply interactive file rename. We apply replacement  *	string expressions to both filenames and file links (if we didn't the  *	links would point to the wrong place, and we could never be able to  *	move an archive that has a file link in it). When we rename files  *	interactively, we store that mapping (old name to user input name) so  *	if we spot any file links to the old file name in the future, we will  *	know exactly how to fix the file link.  * Return:  *	0 continue to  process file, 1 skip this file, -1 pax is finished  */
name|int
name|mod_name
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
comment|/* 	 * Strip off leading '/' if appropriate. 	 * Currently, this option is only set for the tar format. 	 */
if|if
condition|(
name|rmleadslash
operator|&&
name|arcn
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|arcn
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|arcn
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|memmove
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
operator|&
name|arcn
operator|->
name|name
index|[
literal|1
index|]
argument_list|,
name|strlen
argument_list|(
name|arcn
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|nlen
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rmleadslash
operator|<
literal|2
condition|)
block|{
name|rmleadslash
operator|=
literal|2
expr_stmt|;
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"Removing leading / from absolute path names in the archive"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rmleadslash
operator|&&
name|arcn
operator|->
name|ln_name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HLK
operator|||
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
condition|)
block|{
if|if
condition|(
name|arcn
operator|->
name|ln_name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|arcn
operator|->
name|ln_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|memmove
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
operator|&
name|arcn
operator|->
name|ln_name
index|[
literal|1
index|]
argument_list|,
name|strlen
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|)
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|ln_nlen
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rmleadslash
operator|<
literal|2
condition|)
block|{
name|rmleadslash
operator|=
literal|2
expr_stmt|;
name|paxwarn
argument_list|(
literal|0
argument_list|,
literal|"Removing leading / from absolute path names in the archive"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * IMPORTANT: We have a problem. what do we do with symlinks? 	 * Modifying a hard link name makes sense, as we know the file it 	 * points at should have been seen already in the archive (and if it 	 * wasn't seen because of a read error or a bad archive, we lose 	 * anyway). But there are no such requirements for symlinks. On one 	 * hand the symlink that refers to a file in the archive will have to 	 * be modified to so it will still work at its new location in the 	 * file system. On the other hand a symlink that points elsewhere (and 	 * should continue to do so) should not be modified. There is clearly 	 * no perfect solution here. So we handle them like hardlinks. Clearly 	 * a replacement made by the interactive rename mapping is very likely 	 * to be correct since it applies to a single file and is an exact 	 * match. The regular expression replacements are a little harder to 	 * justify though. We claim that the symlink name is only likely 	 * to be replaced when it points within the file tree being moved and 	 * in that case it should be modified. what we really need to do is to 	 * call an oracle here. :) 	 */
if|if
condition|(
name|rephead
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * we have replacement strings, modify the name and the link 		 * name if any. 		 */
if|if
condition|(
operator|(
name|res
operator|=
name|rep_name
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
operator|&
operator|(
name|arcn
operator|->
name|nlen
operator|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|res
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_SLK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HLK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
operator|)
operator|&&
operator|(
operator|(
name|res
operator|=
name|rep_name
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
operator|&
operator|(
name|arcn
operator|->
name|ln_nlen
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|res
operator|)
return|;
block|}
if|if
condition|(
name|iflag
condition|)
block|{
comment|/* 		 * perform interactive file rename, then map the link if any 		 */
if|if
condition|(
operator|(
name|res
operator|=
name|tty_rename
argument_list|(
name|arcn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|res
operator|)
return|;
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_SLK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HLK
operator|)
operator|||
operator|(
name|arcn
operator|->
name|type
operator|==
name|PAX_HRG
operator|)
condition|)
name|sub_name
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
operator|&
operator|(
name|arcn
operator|->
name|ln_nlen
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
comment|/*  * tty_rename()  *	Prompt the user for a replacement file name. A "." keeps the old name,  *	a empty line skips the file, and an EOF on reading the tty, will cause  *	pax to stop processing and exit. Otherwise the file name input, replaces  *	the old one.  * Return:  *	0 process this file, 1 skip this file, -1 we need to exit pax  */
specifier|static
name|int
name|tty_rename
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|)
block|{
name|char
name|tmpname
index|[
name|PAXPATHLEN
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* 	 * prompt user for the replacement name for a file, keep trying until 	 * we get some reasonable input. Archives may have more than one file 	 * on them with the same name (from updates etc). We print verbose info 	 * on the file so the user knows what is up. 	 */
name|tty_prnt
argument_list|(
literal|"\nATTENTION: %s interactive file rename operation.\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ls_tty
argument_list|(
name|arcn
argument_list|)
expr_stmt|;
name|tty_prnt
argument_list|(
literal|"Input new name, or a \".\" to keep the old name, "
argument_list|)
expr_stmt|;
name|tty_prnt
argument_list|(
literal|"or a \"return\" to skip this file.\n"
argument_list|)
expr_stmt|;
name|tty_prnt
argument_list|(
literal|"Input> "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_read
argument_list|(
name|tmpname
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpname
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|tmpname
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tty_prnt
argument_list|(
literal|"Try again, illegal file name: ..\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|tmpname
argument_list|)
operator|>
name|PAXPATHLEN
condition|)
block|{
name|tty_prnt
argument_list|(
literal|"Try again, file name too long\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* 	 * empty file name, skips this file. a "." leaves it alone 	 */
if|if
condition|(
name|tmpname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|tty_prnt
argument_list|(
literal|"Skipping file.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|tmpname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|tmpname
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|tty_prnt
argument_list|(
literal|"Processing continues, name unchanged.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * ok the name changed. We may run into links that point at this 	 * file later. we have to remember where the user sent the file 	 * in order to repair any links. 	 */
name|tty_prnt
argument_list|(
literal|"Processing continues, name changed to: %s\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|res
operator|=
name|add_name
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|arcn
operator|->
name|nlen
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|nlen
operator|=
name|l_strncpy
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
name|tmpname
argument_list|,
sizeof|sizeof
argument_list|(
name|arcn
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arcn
operator|->
name|name
index|[
name|arcn
operator|->
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * set_dest()  *	fix up the file name and the link name (if any) so this file will land  *	in the destination directory (used during copy() -rw).  * Return:  *	0 if ok, -1 if failure (name too long)  */
name|int
name|set_dest
parameter_list|(
name|ARCHD
modifier|*
name|arcn
parameter_list|,
name|char
modifier|*
name|dest_dir
parameter_list|,
name|int
name|dir_len
parameter_list|)
block|{
if|if
condition|(
name|fix_path
argument_list|(
name|arcn
operator|->
name|name
argument_list|,
operator|&
operator|(
name|arcn
operator|->
name|nlen
operator|)
argument_list|,
name|dest_dir
argument_list|,
name|dir_len
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * It is really hard to deal with symlinks here, we cannot be sure 	 * if the name they point was moved (or will be moved). It is best to 	 * leave them alone. 	 */
if|if
condition|(
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_HLK
operator|)
operator|&&
operator|(
name|arcn
operator|->
name|type
operator|!=
name|PAX_HRG
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|fix_path
argument_list|(
name|arcn
operator|->
name|ln_name
argument_list|,
operator|&
operator|(
name|arcn
operator|->
name|ln_nlen
operator|)
argument_list|,
name|dest_dir
argument_list|,
name|dir_len
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * fix_path  *	concatenate dir_name and or_name and store the result in or_name (if  *	it fits). This is one ugly function.  * Return:  *	0 if ok, -1 if the final name is too long  */
specifier|static
name|int
name|fix_path
parameter_list|(
name|char
modifier|*
name|or_name
parameter_list|,
name|int
modifier|*
name|or_len
parameter_list|,
name|char
modifier|*
name|dir_name
parameter_list|,
name|int
name|dir_len
parameter_list|)
block|{
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 	 * we shift the or_name to the right enough to tack in the dir_name 	 * at the front. We make sure we have enough space for it all before 	 * we start. since dest always ends in a slash, we skip of or_name 	 * if it also starts with one. 	 */
name|start
operator|=
name|or_name
expr_stmt|;
name|src
operator|=
name|start
operator|+
operator|*
name|or_len
expr_stmt|;
name|dest
operator|=
name|src
operator|+
name|dir_len
expr_stmt|;
if|if
condition|(
operator|*
name|start
operator|==
literal|'/'
condition|)
block|{
operator|++
name|start
expr_stmt|;
operator|--
name|dest
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|dest
operator|-
name|or_name
operator|)
operator|>
name|PAXPATHLEN
condition|)
block|{
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"File name %s/%s, too long"
argument_list|,
name|dir_name
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|or_len
operator|=
name|len
expr_stmt|;
comment|/* 	 * enough space, shift 	 */
while|while
condition|(
name|src
operator|>=
name|start
condition|)
operator|*
name|dest
operator|--
operator|=
operator|*
name|src
operator|--
expr_stmt|;
name|src
operator|=
name|dir_name
operator|+
name|dir_len
operator|-
literal|1
expr_stmt|;
comment|/* 	 * splice in the destination directory name 	 */
while|while
condition|(
name|src
operator|>=
name|dir_name
condition|)
operator|*
name|dest
operator|--
operator|=
operator|*
name|src
operator|--
expr_stmt|;
operator|*
operator|(
name|or_name
operator|+
name|len
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * rep_name()  *	walk down the list of replacement strings applying each one in order.  *	when we find one with a successful substitution, we modify the name  *	as specified. if required, we print the results. if the resulting name  *	is empty, we will skip this archive member. We use the regexp(3)  *	routines (regexp() ought to win a prize as having the most cryptic  *	library function manual page).  *	--Parameters--  *	name is the file name we are going to apply the regular expressions to  *	(and may be modified)  *	nlen is the length of this name (and is modified to hold the length of  *	the final string).  *	prnt is a flag that says whether to print the final result.  * Return:  *	0 if substitution was successful, 1 if we are to skip the file (the name  *	ended up empty)  */
specifier|static
name|int
name|rep_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|nlen
parameter_list|,
name|int
name|prnt
parameter_list|)
block|{
name|REPLACE
modifier|*
name|pt
decl_stmt|;
name|char
modifier|*
name|inpt
decl_stmt|;
name|char
modifier|*
name|outpt
decl_stmt|;
name|char
modifier|*
name|endpt
decl_stmt|;
name|char
modifier|*
name|rpt
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|res
decl_stmt|;
ifndef|#
directive|ifndef
name|NET2_REGEX
name|regmatch_t
name|pm
index|[
name|MAXSUBEXP
index|]
decl_stmt|;
endif|#
directive|endif
name|char
name|nname
index|[
name|PAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* final result of all replacements */
name|char
name|buf1
index|[
name|PAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* where we work on the name */
comment|/* 	 * copy the name into buf1, where we will work on it. We need to keep 	 * the orig string around so we can print out the result of the final 	 * replacement. We build up the final result in nname. inpt points at 	 * the string we apply the regular expression to. prnt is used to 	 * suppress printing when we handle replacements on the link field 	 * (the user already saw that substitution go by) 	 */
name|pt
operator|=
name|rephead
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|inpt
operator|=
name|buf1
expr_stmt|;
name|outpt
operator|=
name|nname
expr_stmt|;
name|endpt
operator|=
name|outpt
operator|+
name|PAXPATHLEN
expr_stmt|;
comment|/* 	 * try each replacement string in order 	 */
while|while
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
do|do
block|{
comment|/* 			 * check for a successful substitution, if not go to 			 * the next pattern, or cleanup if we were global 			 */
ifdef|#
directive|ifdef
name|NET2_REGEX
if|if
condition|(
name|regexec
argument_list|(
name|pt
operator|->
name|rcmp
argument_list|,
name|inpt
argument_list|)
operator|==
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|regexec
argument_list|(
operator|&
operator|(
name|pt
operator|->
name|rcmp
operator|)
argument_list|,
name|inpt
argument_list|,
name|MAXSUBEXP
argument_list|,
name|pm
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
break|break;
comment|/* 			 * ok we found one. We have three parts, the prefix 			 * which did not match, the section that did and the 			 * tail (that also did not match). Copy the prefix to 			 * the final output buffer (watching to make sure we 			 * do not create a string too long). 			 */
name|found
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|NET2_REGEX
name|rpt
operator|=
name|pt
operator|->
name|rcmp
operator|->
name|startp
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|rpt
operator|=
name|inpt
operator|+
name|pm
index|[
literal|0
index|]
operator|.
name|rm_so
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|inpt
operator|<
name|rpt
operator|)
operator|&&
operator|(
name|outpt
operator|<
name|endpt
operator|)
condition|)
operator|*
name|outpt
operator|++
operator|=
operator|*
name|inpt
operator|++
expr_stmt|;
if|if
condition|(
name|outpt
operator|==
name|endpt
condition|)
break|break;
comment|/* 			 * for the second part (which matched the regular 			 * expression) apply the substitution using the 			 * replacement string and place it the prefix in the 			 * final output. If we have problems, skip it. 			 */
ifdef|#
directive|ifdef
name|NET2_REGEX
if|if
condition|(
operator|(
name|res
operator|=
name|resub
argument_list|(
name|pt
operator|->
name|rcmp
argument_list|,
name|pt
operator|->
name|nstr
argument_list|,
name|outpt
argument_list|,
name|endpt
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|res
operator|=
name|resub
argument_list|(
operator|&
operator|(
name|pt
operator|->
name|rcmp
operator|)
argument_list|,
name|pm
argument_list|,
name|pt
operator|->
name|nstr
argument_list|,
name|outpt
argument_list|,
name|endpt
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|prnt
condition|)
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Replacement name error %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|outpt
operator|+=
name|res
expr_stmt|;
comment|/* 			 * we set up to look again starting at the first 			 * character in the tail (of the input string right 			 * after the last character matched by the regular 			 * expression (inpt always points at the first char in 			 * the string to process). If we are not doing a global 			 * substitution, we will use inpt to copy the tail to 			 * the final result. Make sure we do not overrun the 			 * output buffer 			 */
ifdef|#
directive|ifdef
name|NET2_REGEX
name|inpt
operator|=
name|pt
operator|->
name|rcmp
operator|->
name|endp
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|inpt
operator|+=
name|pm
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|-
name|pm
index|[
literal|0
index|]
operator|.
name|rm_so
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|outpt
operator|==
name|endpt
operator|)
operator|||
operator|(
operator|*
name|inpt
operator|==
literal|'\0'
operator|)
condition|)
break|break;
comment|/* 			 * if the user wants global we keep trying to 			 * substitute until it fails, then we are done. 			 */
block|}
while|while
condition|(
name|pt
operator|->
name|flgs
operator|&
name|GLOB
condition|)
empty_stmt|;
if|if
condition|(
name|found
condition|)
break|break;
comment|/* 		 * a successful substitution did NOT occur, try the next one 		 */
name|pt
operator|=
name|pt
operator|->
name|fow
expr_stmt|;
block|}
do|if (found
block|)
block|{
comment|/* 		 * we had a substitution, copy the last tail piece (if there is 		 * room) to the final result 		 */
while|while
condition|(
operator|(
name|outpt
operator|<
name|endpt
operator|)
operator|&&
operator|(
operator|*
name|inpt
operator|!=
literal|'\0'
operator|)
condition|)
operator|*
name|outpt
operator|++
operator|=
operator|*
name|inpt
operator|++
expr_stmt|;
operator|*
name|outpt
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|outpt
operator|==
name|endpt
operator|)
operator|&&
operator|(
operator|*
name|inpt
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|prnt
condition|)
name|paxwarn
argument_list|(
literal|1
argument_list|,
literal|"Replacement name too long %s>> %s"
argument_list|,
name|name
argument_list|,
name|nname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * inform the user of the result if wanted 		 */
if|if
condition|(
name|prnt
operator|&&
operator|(
name|pt
operator|->
name|flgs
operator|&
name|PRNT
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|nname
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s>><empty string>\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s>> %s\n"
argument_list|,
name|name
argument_list|,
name|nname
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * if empty inform the caller this file is to be skipped 		 * otherwise copy the new name over the orig name and return 		 */
if|if
condition|(
operator|*
name|nname
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|nlen
operator|=
name|l_strncpy
argument_list|(
name|name
argument_list|,
name|nname
argument_list|,
name|PAXPATHLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name
index|[
name|PAXPATHLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|NET2_REGEX
comment|/*  * resub()  *	apply the replacement to the matched expression. expand out the old  * 	style ed(1) subexpression expansion.  * Return:  *	-1 if error, or the number of characters added to the destination.  */
specifier|static
name|int
name|resub
parameter_list|(
name|regexp
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|char
modifier|*
name|destend
parameter_list|)
block|{
name|char
modifier|*
name|spt
decl_stmt|;
name|char
modifier|*
name|dpt
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|no
decl_stmt|;
name|int
name|len
decl_stmt|;
name|spt
operator|=
name|src
expr_stmt|;
name|dpt
operator|=
name|dest
expr_stmt|;
while|while
condition|(
operator|(
name|dpt
operator|<
name|destend
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
operator|*
name|spt
operator|++
operator|)
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
name|no
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|*
name|spt
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|spt
operator|<=
literal|'9'
operator|)
condition|)
name|no
operator|=
operator|*
name|spt
operator|++
operator|-
literal|'0'
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|(
operator|*
name|spt
operator|==
literal|'\\'
operator|)
operator|||
operator|(
operator|*
name|spt
operator|==
literal|'&'
operator|)
operator|)
condition|)
name|c
operator|=
operator|*
name|spt
operator|++
expr_stmt|;
operator|*
name|dpt
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|prog
operator|->
name|startp
index|[
name|no
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|prog
operator|->
name|endp
index|[
name|no
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|len
operator|=
name|prog
operator|->
name|endp
index|[
name|no
index|]
operator|-
name|prog
operator|->
name|startp
index|[
name|no
index|]
operator|)
operator|<=
literal|0
operator|)
condition|)
continue|continue;
comment|/* 		 * copy the subexpression to the destination. 		 * fail if we run out of space or the match string is damaged 		 */
if|if
condition|(
name|len
operator|>
operator|(
name|destend
operator|-
name|dpt
operator|)
condition|)
name|len
operator|=
name|destend
operator|-
name|dpt
expr_stmt|;
if|if
condition|(
name|l_strncpy
argument_list|(
name|dpt
argument_list|,
name|prog
operator|->
name|startp
index|[
name|no
index|]
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dpt
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|(
name|dpt
operator|-
name|dest
operator|)
return|;
block|}
else|#
directive|else
comment|/*  * resub()  *	apply the replacement to the matched expression. expand out the old  * 	style ed(1) subexpression expansion.  * Return:  *	-1 if error, or the number of characters added to the destination.  */
specifier|static
name|int
name|resub
parameter_list|(
name|regex_t
modifier|*
name|rp
parameter_list|,
name|regmatch_t
modifier|*
name|pm
parameter_list|,
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|char
modifier|*
name|destend
parameter_list|)
block|{
name|char
modifier|*
name|spt
decl_stmt|;
name|char
modifier|*
name|dpt
decl_stmt|;
name|char
name|c
decl_stmt|;
name|regmatch_t
modifier|*
name|pmpt
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|subexcnt
decl_stmt|;
name|spt
operator|=
name|src
expr_stmt|;
name|dpt
operator|=
name|dest
expr_stmt|;
name|subexcnt
operator|=
name|rp
operator|->
name|re_nsub
expr_stmt|;
while|while
condition|(
operator|(
name|dpt
operator|<
name|destend
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
operator|*
name|spt
operator|++
operator|)
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* 		 * see if we just have an ordinary replacement character 		 * or we refer to a subexpression. 		 */
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
block|{
name|pmpt
operator|=
name|pm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|*
name|spt
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|spt
operator|<=
literal|'9'
operator|)
condition|)
block|{
comment|/* 			 * make sure there is a subexpression as specified 			 */
if|if
condition|(
operator|(
name|len
operator|=
operator|*
name|spt
operator|++
operator|-
literal|'0'
operator|)
operator|>
name|subexcnt
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pmpt
operator|=
name|pm
operator|+
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Ordinary character, just copy it 			 */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|(
operator|*
name|spt
operator|==
literal|'\\'
operator|)
operator|||
operator|(
operator|*
name|spt
operator|==
literal|'&'
operator|)
operator|)
condition|)
name|c
operator|=
operator|*
name|spt
operator|++
expr_stmt|;
operator|*
name|dpt
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * continue if the subexpression is bogus 		 */
if|if
condition|(
operator|(
name|pmpt
operator|->
name|rm_so
operator|<
literal|0
operator|)
operator|||
operator|(
name|pmpt
operator|->
name|rm_eo
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|=
name|pmpt
operator|->
name|rm_eo
operator|-
name|pmpt
operator|->
name|rm_so
operator|)
operator|<=
literal|0
operator|)
condition|)
continue|continue;
comment|/* 		 * copy the subexpression to the destination. 		 * fail if we run out of space or the match string is damaged 		 */
if|if
condition|(
name|len
operator|>
operator|(
name|destend
operator|-
name|dpt
operator|)
condition|)
name|len
operator|=
name|destend
operator|-
name|dpt
expr_stmt|;
if|if
condition|(
name|l_strncpy
argument_list|(
name|dpt
argument_list|,
name|src
operator|+
name|pmpt
operator|->
name|rm_so
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dpt
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|(
name|dpt
operator|-
name|dest
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

