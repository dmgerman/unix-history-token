begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: test.c,v 1.21 1999/04/05 09:48:38 kleink Exp $	*/
end_comment

begin_comment
comment|/*  * test(1); version 7-like  --  author Erik Baalbergen  * modified by Eric Gisin to be used as built-in.  * modified by Arnold Robbins to add SVR3 compatibility  * (-x -c -b -p -u -g -k) plus Korn's -L -nt -ot -ef and new -S (socket).  * modified by J.T. Conklin for NetBSD.  *  * This program is in the Public Domain.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SHELL
end_ifdef

begin_define
define|#
directive|define
name|main
value|testcmd
end_define

begin_include
include|#
directive|include
file|"bltin/bltin.h"
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|error
argument_list|(
specifier|const
name|char
operator|*
name|msg
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|error
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|msg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|verrx
argument_list|(
literal|2
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* test(1) accepts the following grammar: 	oexpr	::= aexpr | aexpr "-o" oexpr ; 	aexpr	::= nexpr | nexpr "-a" aexpr ; 	nexpr	::= primary | "!" primary 	primary	::= unary-operator operand 		| operand binary-operator operand 		| operand 		| "(" oexpr ")" 		; 	unary-operator ::= "-r"|"-w"|"-x"|"-f"|"-d"|"-c"|"-b"|"-p"| 		"-u"|"-g"|"-k"|"-s"|"-t"|"-z"|"-n"|"-o"|"-O"|"-G"|"-L"|"-S";  	binary-operator ::= "="|"!="|"-eq"|"-ne"|"-ge"|"-gt"|"-le"|"-lt"| 			"-nt"|"-ot"|"-ef"; 	operand ::=<any legal UNIX file name> */
end_comment

begin_enum
enum|enum
name|token
block|{
name|EOI
block|,
name|FILRD
block|,
name|FILWR
block|,
name|FILEX
block|,
name|FILEXIST
block|,
name|FILREG
block|,
name|FILDIR
block|,
name|FILCDEV
block|,
name|FILBDEV
block|,
name|FILFIFO
block|,
name|FILSOCK
block|,
name|FILSYM
block|,
name|FILGZ
block|,
name|FILTT
block|,
name|FILSUID
block|,
name|FILSGID
block|,
name|FILSTCK
block|,
name|FILNT
block|,
name|FILOT
block|,
name|FILEQ
block|,
name|FILUID
block|,
name|FILGID
block|,
name|STREZ
block|,
name|STRNZ
block|,
name|STREQ
block|,
name|STRNE
block|,
name|STRLT
block|,
name|STRGT
block|,
name|INTEQ
block|,
name|INTNE
block|,
name|INTGE
block|,
name|INTGT
block|,
name|INTLE
block|,
name|INTLT
block|,
name|UNOT
block|,
name|BAND
block|,
name|BOR
block|,
name|LPAREN
block|,
name|RPAREN
block|,
name|OPERAND
block|}
enum|;
end_enum

begin_enum
enum|enum
name|token_types
block|{
name|UNOP
block|,
name|BINOP
block|,
name|BUNOP
block|,
name|BBINOP
block|,
name|PAREN
block|}
enum|;
end_enum

begin_struct
struct|struct
name|t_op
block|{
specifier|const
name|char
modifier|*
name|op_text
decl_stmt|;
name|short
name|op_num
decl_stmt|,
name|op_type
decl_stmt|;
block|}
decl|const
name|ops
index|[]
init|=
block|{
block|{
literal|"-r"
block|,
name|FILRD
block|,
name|UNOP
block|}
block|,
block|{
literal|"-w"
block|,
name|FILWR
block|,
name|UNOP
block|}
block|,
block|{
literal|"-x"
block|,
name|FILEX
block|,
name|UNOP
block|}
block|,
block|{
literal|"-e"
block|,
name|FILEXIST
block|,
name|UNOP
block|}
block|,
block|{
literal|"-f"
block|,
name|FILREG
block|,
name|UNOP
block|}
block|,
block|{
literal|"-d"
block|,
name|FILDIR
block|,
name|UNOP
block|}
block|,
block|{
literal|"-c"
block|,
name|FILCDEV
block|,
name|UNOP
block|}
block|,
block|{
literal|"-b"
block|,
name|FILBDEV
block|,
name|UNOP
block|}
block|,
block|{
literal|"-p"
block|,
name|FILFIFO
block|,
name|UNOP
block|}
block|,
block|{
literal|"-u"
block|,
name|FILSUID
block|,
name|UNOP
block|}
block|,
block|{
literal|"-g"
block|,
name|FILSGID
block|,
name|UNOP
block|}
block|,
block|{
literal|"-k"
block|,
name|FILSTCK
block|,
name|UNOP
block|}
block|,
block|{
literal|"-s"
block|,
name|FILGZ
block|,
name|UNOP
block|}
block|,
block|{
literal|"-t"
block|,
name|FILTT
block|,
name|UNOP
block|}
block|,
block|{
literal|"-z"
block|,
name|STREZ
block|,
name|UNOP
block|}
block|,
block|{
literal|"-n"
block|,
name|STRNZ
block|,
name|UNOP
block|}
block|,
block|{
literal|"-h"
block|,
name|FILSYM
block|,
name|UNOP
block|}
block|,
comment|/* for backwards compat */
block|{
literal|"-O"
block|,
name|FILUID
block|,
name|UNOP
block|}
block|,
block|{
literal|"-G"
block|,
name|FILGID
block|,
name|UNOP
block|}
block|,
block|{
literal|"-L"
block|,
name|FILSYM
block|,
name|UNOP
block|}
block|,
block|{
literal|"-S"
block|,
name|FILSOCK
block|,
name|UNOP
block|}
block|,
block|{
literal|"="
block|,
name|STREQ
block|,
name|BINOP
block|}
block|,
block|{
literal|"!="
block|,
name|STRNE
block|,
name|BINOP
block|}
block|,
block|{
literal|"<"
block|,
name|STRLT
block|,
name|BINOP
block|}
block|,
block|{
literal|">"
block|,
name|STRGT
block|,
name|BINOP
block|}
block|,
block|{
literal|"-eq"
block|,
name|INTEQ
block|,
name|BINOP
block|}
block|,
block|{
literal|"-ne"
block|,
name|INTNE
block|,
name|BINOP
block|}
block|,
block|{
literal|"-ge"
block|,
name|INTGE
block|,
name|BINOP
block|}
block|,
block|{
literal|"-gt"
block|,
name|INTGT
block|,
name|BINOP
block|}
block|,
block|{
literal|"-le"
block|,
name|INTLE
block|,
name|BINOP
block|}
block|,
block|{
literal|"-lt"
block|,
name|INTLT
block|,
name|BINOP
block|}
block|,
block|{
literal|"-nt"
block|,
name|FILNT
block|,
name|BINOP
block|}
block|,
block|{
literal|"-ot"
block|,
name|FILOT
block|,
name|BINOP
block|}
block|,
block|{
literal|"-ef"
block|,
name|FILEQ
block|,
name|BINOP
block|}
block|,
block|{
literal|"!"
block|,
name|UNOT
block|,
name|BUNOP
block|}
block|,
block|{
literal|"-a"
block|,
name|BAND
block|,
name|BBINOP
block|}
block|,
block|{
literal|"-o"
block|,
name|BOR
block|,
name|BBINOP
block|}
block|,
block|{
literal|"("
block|,
name|LPAREN
block|,
name|PAREN
block|}
block|,
block|{
literal|")"
block|,
name|RPAREN
block|,
name|PAREN
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|t_op
specifier|const
modifier|*
name|t_wp_op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|t_wp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aexpr
name|__P
argument_list|(
operator|(
expr|enum
name|token
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|binop
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|equalf
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|filstat
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|token
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getn
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|quad_t
name|getq
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|intcmp
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isoperand
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|newerf
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nexpr
name|__P
argument_list|(
operator|(
expr|enum
name|token
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oexpr
name|__P
argument_list|(
operator|(
expr|enum
name|token
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|olderf
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|primary
name|__P
argument_list|(
operator|(
expr|enum
name|token
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|syntax
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|token
name|t_lex
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|res
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|nargv
decl_stmt|;
comment|/* 	 * XXX copy the whole contents of argv to a newly allocated 	 * space with two extra cells filled with NULL's - this source 	 * code totally depends on their presence. 	 */
if|if
condition|(
operator|(
name|nargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|argc
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Out of space"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|nargv
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|nargv
index|[
name|i
index|]
operator|=
name|nargv
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|argv
operator|=
name|nargv
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"["
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
operator|--
name|argc
index|]
argument_list|,
literal|"]"
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* XXX work around the absence of an eaccess(2) syscall */
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|t_wp
operator|=
operator|&
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|res
operator|=
operator|!
name|oexpr
argument_list|(
name|t_lex
argument_list|(
operator|*
name|t_wp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t_wp
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|t_wp
operator|!=
name|NULL
condition|)
name|syntax
argument_list|(
operator|*
name|t_wp
argument_list|,
literal|"unexpected operator"
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|syntax
parameter_list|(
name|op
parameter_list|,
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|op
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|&&
operator|*
name|op
condition|)
name|error
argument_list|(
literal|"%s: %s"
argument_list|,
name|op
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|oexpr
parameter_list|(
name|n
parameter_list|)
name|enum
name|token
name|n
decl_stmt|;
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|aexpr
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_lex
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|)
operator|==
name|BOR
condition|)
return|return
name|oexpr
argument_list|(
name|t_lex
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|)
argument_list|)
operator|||
name|res
return|;
name|t_wp
operator|--
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aexpr
parameter_list|(
name|n
parameter_list|)
name|enum
name|token
name|n
decl_stmt|;
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|nexpr
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_lex
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|)
operator|==
name|BAND
condition|)
return|return
name|aexpr
argument_list|(
name|t_lex
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|)
argument_list|)
operator|&&
name|res
return|;
name|t_wp
operator|--
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nexpr
parameter_list|(
name|n
parameter_list|)
name|enum
name|token
name|n
decl_stmt|;
comment|/* token */
block|{
if|if
condition|(
name|n
operator|==
name|UNOT
condition|)
return|return
operator|!
name|nexpr
argument_list|(
name|t_lex
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|)
argument_list|)
return|;
return|return
name|primary
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|primary
parameter_list|(
name|n
parameter_list|)
name|enum
name|token
name|n
decl_stmt|;
block|{
name|enum
name|token
name|nn
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|EOI
condition|)
return|return
literal|0
return|;
comment|/* missing expression */
if|if
condition|(
name|n
operator|==
name|LPAREN
condition|)
block|{
if|if
condition|(
operator|(
name|nn
operator|=
name|t_lex
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|)
operator|)
operator|==
name|RPAREN
condition|)
return|return
literal|0
return|;
comment|/* missing expression */
name|res
operator|=
name|oexpr
argument_list|(
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_lex
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|)
operator|!=
name|RPAREN
condition|)
name|syntax
argument_list|(
name|NULL
argument_list|,
literal|"closing paren expected"
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
if|if
condition|(
name|t_wp_op
operator|&&
name|t_wp_op
operator|->
name|op_type
operator|==
name|UNOP
condition|)
block|{
comment|/* unary expression */
if|if
condition|(
operator|*
operator|++
name|t_wp
operator|==
name|NULL
condition|)
name|syntax
argument_list|(
name|t_wp_op
operator|->
name|op_text
argument_list|,
literal|"argument expected"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|STREZ
case|:
return|return
name|strlen
argument_list|(
operator|*
name|t_wp
argument_list|)
operator|==
literal|0
return|;
case|case
name|STRNZ
case|:
return|return
name|strlen
argument_list|(
operator|*
name|t_wp
argument_list|)
operator|!=
literal|0
return|;
case|case
name|FILTT
case|:
return|return
name|isatty
argument_list|(
name|getn
argument_list|(
operator|*
name|t_wp
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|filstat
argument_list|(
operator|*
name|t_wp
argument_list|,
name|n
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|t_lex
argument_list|(
name|t_wp
index|[
literal|1
index|]
argument_list|)
operator|,
name|t_wp_op
operator|&&
name|t_wp_op
operator|->
name|op_type
operator|==
name|BINOP
condition|)
block|{
return|return
name|binop
argument_list|()
return|;
block|}
return|return
name|strlen
argument_list|(
operator|*
name|t_wp
argument_list|)
operator|>
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|binop
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|opnd1
decl_stmt|,
modifier|*
name|opnd2
decl_stmt|;
name|struct
name|t_op
specifier|const
modifier|*
name|op
decl_stmt|;
name|opnd1
operator|=
operator|*
name|t_wp
expr_stmt|;
operator|(
name|void
operator|)
name|t_lex
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|)
expr_stmt|;
name|op
operator|=
name|t_wp_op
expr_stmt|;
if|if
condition|(
operator|(
name|opnd2
operator|=
operator|*
operator|++
name|t_wp
operator|)
operator|==
name|NULL
condition|)
name|syntax
argument_list|(
name|op
operator|->
name|op_text
argument_list|,
literal|"argument expected"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|op_num
condition|)
block|{
case|case
name|STREQ
case|:
return|return
name|strcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|==
literal|0
return|;
case|case
name|STRNE
case|:
return|return
name|strcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|!=
literal|0
return|;
case|case
name|STRLT
case|:
return|return
name|strcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|<
literal|0
return|;
case|case
name|STRGT
case|:
return|return
name|strcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|>
literal|0
return|;
case|case
name|INTEQ
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|==
literal|0
return|;
case|case
name|INTNE
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|!=
literal|0
return|;
case|case
name|INTGE
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|>=
literal|0
return|;
case|case
name|INTGT
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|>
literal|0
return|;
case|case
name|INTLE
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|<=
literal|0
return|;
case|case
name|INTLT
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|<
literal|0
return|;
case|case
name|FILNT
case|:
return|return
name|newerf
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
return|;
case|case
name|FILOT
case|:
return|return
name|olderf
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
return|;
case|case
name|FILEQ
case|:
return|return
name|equalf
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|filstat
parameter_list|(
name|nm
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|nm
decl_stmt|;
name|enum
name|token
name|mode
decl_stmt|;
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|FILSYM
condition|?
name|lstat
argument_list|(
name|nm
argument_list|,
operator|&
name|s
argument_list|)
else|:
name|stat
argument_list|(
name|nm
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|FILRD
case|:
return|return
name|access
argument_list|(
name|nm
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
return|;
case|case
name|FILWR
case|:
return|return
name|access
argument_list|(
name|nm
argument_list|,
name|W_OK
argument_list|)
operator|==
literal|0
return|;
case|case
name|FILEX
case|:
comment|/* XXX work around access(2) false positives for superuser */
if|if
condition|(
name|access
argument_list|(
name|nm
argument_list|,
name|X_OK
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
operator|||
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|s
operator|.
name|st_mode
operator|&
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|)
operator|!=
literal|0
return|;
case|case
name|FILEXIST
case|:
return|return
name|access
argument_list|(
name|nm
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
return|;
case|case
name|FILREG
case|:
return|return
name|S_ISREG
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILDIR
case|:
return|return
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILCDEV
case|:
return|return
name|S_ISCHR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILBDEV
case|:
return|return
name|S_ISBLK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILFIFO
case|:
return|return
name|S_ISFIFO
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILSOCK
case|:
return|return
name|S_ISSOCK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILSYM
case|:
return|return
name|S_ISLNK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILSUID
case|:
return|return
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_ISUID
operator|)
operator|!=
literal|0
return|;
case|case
name|FILSGID
case|:
return|return
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_ISGID
operator|)
operator|!=
literal|0
return|;
case|case
name|FILSTCK
case|:
return|return
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_ISVTX
operator|)
operator|!=
literal|0
return|;
case|case
name|FILGZ
case|:
return|return
name|s
operator|.
name|st_size
operator|>
operator|(
name|off_t
operator|)
literal|0
return|;
case|case
name|FILUID
case|:
return|return
name|s
operator|.
name|st_uid
operator|==
name|geteuid
argument_list|()
return|;
case|case
name|FILGID
case|:
return|return
name|s
operator|.
name|st_gid
operator|==
name|getegid
argument_list|()
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|token
name|t_lex
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|t_op
specifier|const
modifier|*
name|op
init|=
name|ops
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|t_wp_op
operator|=
name|NULL
expr_stmt|;
return|return
name|EOI
return|;
block|}
while|while
condition|(
name|op
operator|->
name|op_text
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|op_text
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|op
operator|->
name|op_type
operator|==
name|UNOP
operator|&&
name|isoperand
argument_list|()
operator|)
operator|||
operator|(
name|op
operator|->
name|op_num
operator|==
name|LPAREN
operator|&&
operator|*
operator|(
name|t_wp
operator|+
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
break|break;
name|t_wp_op
operator|=
name|op
expr_stmt|;
return|return
name|op
operator|->
name|op_num
return|;
block|}
name|op
operator|++
expr_stmt|;
block|}
name|t_wp_op
operator|=
name|NULL
expr_stmt|;
return|return
name|OPERAND
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isoperand
parameter_list|()
block|{
name|struct
name|t_op
specifier|const
modifier|*
name|op
init|=
name|ops
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
operator|*
operator|(
name|t_wp
operator|+
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|t
operator|=
operator|*
operator|(
name|t_wp
operator|+
literal|2
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|op
operator|->
name|op_text
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|op_text
argument_list|)
operator|==
literal|0
condition|)
return|return
name|op
operator|->
name|op_type
operator|==
name|BINOP
operator|&&
operator|(
name|t
index|[
literal|0
index|]
operator|!=
literal|')'
operator|||
name|t
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
return|;
name|op
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* atoi with error detection */
end_comment

begin_function
specifier|static
name|int
name|getn
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|r
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|error
argument_list|(
operator|(
name|errno
operator|==
name|EINVAL
operator|)
condition|?
literal|"%s: bad number"
else|:
literal|"%s: out of range"
argument_list|,
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|error
argument_list|(
literal|"%s: bad number"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|r
return|;
block|}
end_function

begin_comment
comment|/* atoi with error detection and 64 bit range */
end_comment

begin_function
specifier|static
name|quad_t
name|getq
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|quad_t
name|r
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|strtoq
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|error
argument_list|(
operator|(
name|errno
operator|==
name|EINVAL
operator|)
condition|?
literal|"%s: bad number"
else|:
literal|"%s: out of range"
argument_list|,
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|error
argument_list|(
literal|"%s: bad number"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|quad_t
name|q1
decl_stmt|,
name|q2
decl_stmt|;
name|q1
operator|=
name|getq
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|q2
operator|=
name|getq
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|q1
operator|>
name|q2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|q1
operator|<
name|q2
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|newerf
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
specifier|const
name|char
modifier|*
name|f1
decl_stmt|,
decl|*
name|f2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|stat
name|b1
decl_stmt|,
name|b2
decl_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|f1
argument_list|,
operator|&
name|b1
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|f2
argument_list|,
operator|&
name|b2
argument_list|)
operator|==
literal|0
operator|&&
name|b1
operator|.
name|st_mtime
operator|>
name|b2
operator|.
name|st_mtime
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|olderf
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
specifier|const
name|char
modifier|*
name|f1
decl_stmt|,
decl|*
name|f2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|stat
name|b1
decl_stmt|,
name|b2
decl_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|f1
argument_list|,
operator|&
name|b1
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|f2
argument_list|,
operator|&
name|b2
argument_list|)
operator|==
literal|0
operator|&&
name|b1
operator|.
name|st_mtime
operator|<
name|b2
operator|.
name|st_mtime
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|equalf
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
specifier|const
name|char
modifier|*
name|f1
decl_stmt|,
decl|*
name|f2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|stat
name|b1
decl_stmt|,
name|b2
decl_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|f1
argument_list|,
operator|&
name|b1
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|f2
argument_list|,
operator|&
name|b2
argument_list|)
operator|==
literal|0
operator|&&
name|b1
operator|.
name|st_dev
operator|==
name|b2
operator|.
name|st_dev
operator|&&
name|b1
operator|.
name|st_ino
operator|==
name|b2
operator|.
name|st_ino
operator|)
return|;
block|}
end_block

end_unit

