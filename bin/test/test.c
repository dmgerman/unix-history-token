begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * GNU test program (ksb and mjb)  *  * Modified to run with the GNU shell Apr 25, 1988 by bfox.  *  *???	-G	file is owned by same gid; the effective gid is checked  * Chet Ramey, CWRU 3/23/89  *  * Fixed a BSD dependency (_doprnt()) in the port to AIX 2.2  * Chet Ramey, CWRU 5/3/89  */
end_comment

begin_comment
comment|/* Copyright (C) 1987,1989 Free Software Foundation, Inc.  This file is part of GNU Bash, the Bourne Again SHell.  Bash is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  Bash is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bash; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SONY
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|R_OK
end_ifndef

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_define
define|#
directive|define
name|F_OK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Id: gtest.c,v 1.10 88/07/02 13:34:45 afb Exp Locker: afb $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following few defines control the truth and false output of each stage.    TRUE and FALSE are what we use to compute the final output value.    SHELL_BOOLEAN is the form which returns truth or falseness in shell terms.    TRUTH_OR is how to do logical or with TRUE and FALSE.    TRUTH_AND is how to do logical and with TRUE and FALSE..    Default is TRUE = 1, FALSE = 0, TRUTH_OR = a | b, TRUTH_AND = a& b,     SHELL_BOOLEAN = (!value). */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|SHELL_BOOLEAN
parameter_list|(
name|value
parameter_list|)
value|(!(value))
end_define

begin_define
define|#
directive|define
name|TRUTH_OR
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) | (b))
end_define

begin_define
define|#
directive|define
name|TRUTH_AND
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)& (b))
end_define

begin_comment
comment|/* Define STANDALONE to get the /bin/test version.  Otherwise, we are    making this for the shell. */
end_comment

begin_comment
comment|/* #define STANDALONE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STANDALONE
end_ifdef

begin_define
define|#
directive|define
name|test_exit
parameter_list|(
name|val
parameter_list|)
value|exit (val)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
name|jmp_buf
name|test_exit_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|test_error_return
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|test_exit
parameter_list|(
name|val
parameter_list|)
value|test_error_return = val, longjmp (test_exit_buf, 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STANDALONE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_decl_stmt
name|int
name|sys_v
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|sys_v
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* position in list			*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of args from command line	*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the argument list			*/
end_comment

begin_function
specifier|static
name|void
name|test_syntax_error
parameter_list|(
name|format
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|test_exit
argument_list|(
name|SHELL_BOOLEAN
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|test_io_error
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errno
operator|=
name|old_errno
expr_stmt|;
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|test_exit
argument_list|(
name|SHELL_BOOLEAN
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * advance - increment our position in the argument list.  Check that  *	we're not past the end of the argument list.  This check is  *	supressed if the argument is FALSE.  made a macro for efficiency.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_define
define|#
directive|define
name|advance
parameter_list|(
name|f
parameter_list|)
value|(++pos, f&& (pos< argc ? 0 : beyond()))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|advance
argument_list|)
end_if

begin_function
specifier|static
name|int
name|advance
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
operator|++
name|pos
expr_stmt|;
if|if
condition|(
name|f
operator|&&
name|pos
operator|>=
name|argc
condition|)
name|beyond
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|unary_advance
parameter_list|()
value|(advance (1),++pos)
end_define

begin_comment
comment|/*  * beyond - call when we're beyond the end of the argument list (an  *	error condition)  */
end_comment

begin_function
specifier|static
name|int
name|beyond
parameter_list|()
block|{
name|test_syntax_error
argument_list|(
literal|"argument expected\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * int_expt_err - when an integer argument was expected, but something else  * 	was found.  */
end_comment

begin_function
specifier|static
name|void
name|int_expt_err
parameter_list|(
name|pch
parameter_list|)
name|char
modifier|*
name|pch
decl_stmt|;
block|{
name|test_syntax_error
argument_list|(
literal|"integer expression expected %s\n"
argument_list|,
name|pch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * isint - is the argument whose position in the argument vector is 'm' an  * 	integer? Convert it for me too, returning it's value in 'pl'.  */
end_comment

begin_function
specifier|static
name|int
name|isint
parameter_list|(
name|m
parameter_list|,
name|pl
parameter_list|)
name|int
name|m
decl_stmt|;
name|long
modifier|*
name|pl
decl_stmt|;
block|{
specifier|extern
name|long
name|atol
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|pch
decl_stmt|;
name|pch
operator|=
name|argv
index|[
name|m
index|]
expr_stmt|;
comment|/* Skip leading whitespace characters. */
while|while
condition|(
operator|*
name|pch
operator|==
literal|'\t'
operator|||
operator|*
name|pch
operator|==
literal|' '
condition|)
name|pch
operator|++
expr_stmt|;
comment|/* accept negative numbers but not '-' alone */
if|if
condition|(
literal|'-'
operator|==
operator|*
name|pch
condition|)
if|if
condition|(
literal|'\000'
operator|==
operator|*
operator|++
name|pch
condition|)
return|return
literal|0
return|;
while|while
condition|(
literal|'\000'
operator|!=
operator|*
name|pch
condition|)
block|{
switch|switch
condition|(
operator|*
name|pch
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
break|break;
default|default:
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|++
name|pch
expr_stmt|;
block|}
operator|*
name|pl
operator|=
name|atol
argument_list|(
name|argv
index|[
name|m
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * age_of - find the age of the given file.  Return YES or NO depending  *	on whether the file exists, and if it does, fill in the age with  *	the modify time.  */
end_comment

begin_function
specifier|static
name|int
name|age_of
parameter_list|(
name|posit
parameter_list|,
name|age
parameter_list|)
name|int
name|posit
decl_stmt|;
name|long
modifier|*
name|age
decl_stmt|;
block|{
name|struct
name|stat
name|stat_buf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|posit
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|*
name|age
operator|=
name|stat_buf
operator|.
name|st_mtime
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * term - parse a term and return 1 or 0 depending on whether the term  *	evaluates to true or false, respectively.  *  * term ::=  *	'-'('h'|'d'|'f'|'r'|'s'|'w'|'c'|'b'|'p'|'u'|'g'|'k') filename  *	'-'('L'|'x') filename  * 	'-t' [ int ]  *	'-'('z'|'n') string  *	string  *	string ('!='|'=') string  *<int> '-'(eq|ne|le|lt|ge|gt)<int>  *	file '-'(nt|ot|ef) file  *	'('<expr> ')'  * int ::=  *	'-l' string  *	positive and negative integers  */
end_comment

begin_function
specifier|static
name|int
name|term
parameter_list|()
block|{
name|int
name|expr
parameter_list|()
function_decl|;
specifier|auto
type|struct
name|stat
name|stat_buf
decl_stmt|,
name|stat_spare
decl_stmt|;
specifier|auto
name|long
name|int
name|l
decl_stmt|,
name|r
decl_stmt|;
specifier|auto
name|int
name|l_is_l
decl_stmt|,
name|r_is_l
decl_stmt|;
comment|/* are the left and right integer 			    * expressions of the form '-l string'? 			    */
specifier|auto
name|int
name|value
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
name|argc
condition|)
name|beyond
argument_list|()
expr_stmt|;
comment|/* Deal with leading "not". */
if|if
condition|(
name|pos
operator|<
name|argc
operator|&&
literal|'!'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
condition|)
block|{
name|advance
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* This has to be rewritten to handle the TRUTH and FALSE stuff. */
return|return
operator|(
operator|!
name|term
argument_list|()
operator|)
return|;
block|}
if|if
condition|(
literal|'('
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
condition|)
block|{
name|advance
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|expr
argument_list|()
expr_stmt|;
if|if
condition|(
literal|')'
operator|!=
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|||
literal|'\000'
operator|!=
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
condition|)
name|test_syntax_error
argument_list|(
literal|"argument expected, found %s\n"
argument_list|,
name|argv
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|value
operator|)
operator|)
return|;
block|}
comment|/* are there enough arguments left that this could be dyadic? */
if|if
condition|(
name|pos
operator|+
literal|3
operator|<=
name|argc
condition|)
block|{
specifier|register
name|int
name|op
decl_stmt|;
if|if
condition|(
literal|'-'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|&&
literal|'l'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|2
index|]
condition|)
block|{
name|l_is_l
operator|=
literal|1
expr_stmt|;
name|op
operator|=
name|pos
operator|+
literal|2
expr_stmt|;
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_is_l
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
literal|'-'
operator|==
name|argv
index|[
name|op
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|&&
literal|'l'
operator|==
name|argv
index|[
name|op
operator|+
literal|1
index|]
index|[
literal|1
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
operator|+
literal|1
index|]
index|[
literal|2
index|]
condition|)
block|{
name|r_is_l
operator|=
literal|1
expr_stmt|;
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|r_is_l
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|'-'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|0
index|]
condition|)
block|{
comment|/* check for eq, nt, and stuff */
switch|switch
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|1
index|]
condition|)
block|{
default|default:
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
literal|'t'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* lt */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|-
literal|1
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"before -lt"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"after -lt"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|<
name|r
operator|)
operator|)
return|;
block|}
if|if
condition|(
literal|'e'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* le */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|-
literal|1
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"before -le"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"after -le"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|<=
name|r
operator|)
operator|)
return|;
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
literal|'t'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* gt integer greater than */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|-
literal|1
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"before -gt"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"after -gt"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|>
name|r
operator|)
operator|)
return|;
block|}
if|if
condition|(
literal|'e'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* ge - integer greater than or equal to */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|-
literal|1
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"before -ge"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"after -ge"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|>=
name|r
operator|)
operator|)
return|;
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
literal|'t'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* nt - newer than */
name|pos
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|l_is_l
operator|||
name|r_is_l
condition|)
name|test_syntax_error
argument_list|(
literal|"-nt does not accept -l\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|age_of
argument_list|(
name|op
operator|-
literal|1
argument_list|,
operator|&
name|l
argument_list|)
operator|&&
name|age_of
argument_list|(
name|op
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|>
name|r
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
literal|'e'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* ne - integer not equal */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|-
literal|1
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"before -ne"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"after -ne"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|!=
name|r
operator|)
operator|)
return|;
block|}
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
literal|'q'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* eq - integer equal */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|-
literal|1
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"before -eq"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|op
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|int_expt_err
argument_list|(
literal|"after -eq"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|==
name|r
operator|)
operator|)
return|;
block|}
if|if
condition|(
literal|'f'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* ef - hard link? */
name|pos
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|l_is_l
operator|||
name|r_is_l
condition|)
name|test_syntax_error
argument_list|(
literal|"-ef does not accept -l\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|op
operator|+
literal|1
index|]
argument_list|,
operator|&
name|stat_spare
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|stat_buf
operator|.
name|st_dev
operator|==
name|stat_spare
operator|.
name|st_dev
operator|&&
name|stat_buf
operator|.
name|st_ino
operator|==
name|stat_spare
operator|.
name|st_ino
operator|)
operator|)
return|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
literal|'t'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* ot - older than */
name|pos
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|l_is_l
operator|||
name|r_is_l
condition|)
name|test_syntax_error
argument_list|(
literal|"-nt does not accept -l\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|age_of
argument_list|(
name|op
operator|-
literal|1
argument_list|,
operator|&
name|l
argument_list|)
operator|&&
name|age_of
argument_list|(
name|op
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|<
name|r
operator|)
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
break|break;
block|}
block|}
if|if
condition|(
literal|'='
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|0
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|1
index|]
condition|)
block|{
name|value
operator|=
operator|(
literal|0
operator|==
name|strcmp
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
name|argv
index|[
name|pos
operator|+
literal|2
index|]
argument_list|)
operator|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
block|}
if|if
condition|(
literal|'!'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|0
index|]
operator|&&
literal|'='
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|1
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
condition|)
block|{
name|value
operator|=
literal|0
operator|!=
name|strcmp
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
name|argv
index|[
name|pos
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
block|}
block|}
comment|/* Might be a switch type argument */
if|if
condition|(
literal|'-'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|2
index|]
comment|/*&& pos< argc-1 */
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
condition|)
block|{
default|default:
break|break;
comment|/* All of the following unary operators use unary_advance (), which 	     checks to make sure that there is an argument, and then advances 	     pos right past it.  This means that pos - 1 is the location of the 	     argument. */
case|case
literal|'r'
case|:
comment|/* file is readable? */
name|unary_advance
argument_list|()
expr_stmt|;
name|value
operator|=
operator|-
literal|1
operator|!=
name|access
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
case|case
literal|'w'
case|:
comment|/* File is writeable? */
name|unary_advance
argument_list|()
expr_stmt|;
name|value
operator|=
operator|-
literal|1
operator|!=
name|access
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
name|W_OK
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
case|case
literal|'x'
case|:
comment|/* File is executable? */
name|unary_advance
argument_list|()
expr_stmt|;
name|value
operator|=
operator|-
literal|1
operator|!=
name|access
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
name|X_OK
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
case|case
literal|'O'
case|:
comment|/* File is owned by you? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|geteuid
argument_list|()
operator|==
name|stat_buf
operator|.
name|st_uid
operator|)
operator|)
return|;
case|case
literal|'f'
case|:
comment|/* File is a file? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	   * Under SYSV, -f is true if the given file exists 	   * and is a regular file.  Other places, this checks 	   * to see if the given file is not a directory. 	   */
if|if
condition|(
name|sys_v
condition|)
return|return
operator|(
name|TRUE
operator|==
operator|(
operator|(
name|S_IFREG
operator|==
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|)
operator|||
operator|(
literal|0
operator|==
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|)
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_IFDIR
operator|!=
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|)
operator|)
return|;
case|case
literal|'d'
case|:
comment|/* File is a directory? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_IFDIR
operator|==
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|)
operator|)
return|;
case|case
literal|'s'
case|:
comment|/* File has something in it? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|stat_buf
operator|.
name|st_size
operator|>
operator|(
name|off_t
operator|)
literal|0
operator|)
operator|)
return|;
ifdef|#
directive|ifdef
name|S_IFSOCK
case|case
literal|'S'
case|:
comment|/* File is a socket? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_IFSOCK
operator|==
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|)
operator|)
return|;
endif|#
directive|endif
case|case
literal|'c'
case|:
comment|/* File is character special? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_IFCHR
operator|==
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|)
operator|)
return|;
case|case
literal|'b'
case|:
comment|/* File is block special? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_IFBLK
operator|==
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|)
operator|)
return|;
case|case
literal|'p'
case|:
comment|/* File is a named pipe? */
name|unary_advance
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|S_IFIFO
return|return
operator|(
name|FALSE
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_IFIFO
operator|==
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* S_IFIFO */
case|case
literal|'L'
case|:
comment|/* Same as -h  */
comment|/*FALLTHROUGH*/
case|case
literal|'h'
case|:
comment|/* File is a symbolic link? */
name|unary_advance
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|S_IFLNK
return|return
operator|(
name|FALSE
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|lstat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_IFLNK
operator|==
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* S_IFLNK */
case|case
literal|'u'
case|:
comment|/* File is setuid? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
literal|0
operator|!=
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_ISUID
operator|)
operator|)
operator|)
return|;
case|case
literal|'g'
case|:
comment|/* File is setgid? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
literal|0
operator|!=
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_ISGID
operator|)
operator|)
operator|)
return|;
case|case
literal|'k'
case|:
comment|/* File has sticky bit set? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
literal|0
operator|!=
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_ISVTX
operator|)
operator|)
operator|)
return|;
case|case
literal|'t'
case|:
comment|/* File (fd) is a terminal?  (fd) defaults to stdout. */
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|argc
operator|&&
name|isint
argument_list|(
name|pos
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|isatty
argument_list|(
operator|(
name|int
operator|)
name|r
argument_list|)
operator|)
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|==
operator|(
name|isatty
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
return|;
case|case
literal|'n'
case|:
comment|/* True if arg has some length. */
name|unary_advance
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
literal|0
operator|!=
name|strlen
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|)
return|;
break|break;
case|case
literal|'z'
case|:
comment|/* True if arg has no length. */
name|unary_advance
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
literal|0
operator|==
name|strlen
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|)
return|;
block|}
block|}
name|value
operator|=
literal|0
operator|!=
name|strlen
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/*  * and:  *	and '-a' term  *	term  */
end_comment

begin_function
specifier|static
name|int
name|and
parameter_list|()
block|{
specifier|auto
name|int
name|value
decl_stmt|;
name|value
operator|=
name|term
argument_list|()
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|argc
operator|&&
literal|'-'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|&&
literal|'a'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|2
index|]
condition|)
block|{
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|TRUTH_AND
argument_list|(
name|value
argument_list|,
name|term
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * or:  *	or '-o' and  *	and  */
end_comment

begin_function
specifier|static
name|int
name|or
parameter_list|()
block|{
specifier|auto
name|int
name|value
decl_stmt|;
name|value
operator|=
name|and
argument_list|()
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|argc
operator|&&
literal|'-'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|&&
literal|'o'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|2
index|]
condition|)
block|{
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|TRUTH_OR
argument_list|(
name|value
argument_list|,
name|and
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * expr:  *	or  */
end_comment

begin_function
name|int
name|expr
parameter_list|()
block|{
specifier|auto
name|int
name|value
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
name|argc
condition|)
name|beyond
argument_list|()
expr_stmt|;
name|value
operator|=
name|FALSE
expr_stmt|;
return|return
name|value
operator|^
name|or
argument_list|()
return|;
comment|/* Same with this. */
block|}
end_function

begin_comment
comment|/*  * [:  *	'[' expr ']'  * test:  *	test expr  */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|STANDALONE
name|main
parameter_list|(
name|margc
parameter_list|,
name|margv
parameter_list|)
else|#
directive|else
function|test_command
parameter_list|(
name|margc
parameter_list|,
name|margv
parameter_list|)
endif|#
directive|endif
comment|/* STANDALONE */
name|int
name|margc
decl_stmt|;
name|char
modifier|*
modifier|*
name|margv
decl_stmt|;
block|{
specifier|auto
name|int
name|value
decl_stmt|;
name|int
name|expr
parameter_list|()
function_decl|;
ifndef|#
directive|ifndef
name|STANDALONE
name|int
name|code
init|=
name|setjmp
argument_list|(
name|test_exit_buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
condition|)
return|return
operator|(
name|test_error_return
operator|)
return|;
endif|#
directive|endif
comment|/* STANDALONE */
name|argv
operator|=
name|margv
expr_stmt|;
if|if
condition|(
name|margv
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|margv
index|[
literal|0
index|]
argument_list|,
literal|"["
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|--
name|margc
expr_stmt|;
if|if
condition|(
name|margc
operator|<
literal|2
condition|)
name|test_exit
argument_list|(
name|SHELL_BOOLEAN
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|margv
index|[
name|margc
index|]
operator|&&
name|strcmp
argument_list|(
name|margv
index|[
name|margc
index|]
argument_list|,
literal|"]"
argument_list|)
operator|!=
literal|0
condition|)
name|test_syntax_error
argument_list|(
literal|"missing `]'\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|argc
operator|=
name|margc
expr_stmt|;
name|pos
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|argc
condition|)
name|test_exit
argument_list|(
name|SHELL_BOOLEAN
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|argc
condition|)
name|test_syntax_error
argument_list|(
literal|"too many arguments\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|test_exit
argument_list|(
name|SHELL_BOOLEAN
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

