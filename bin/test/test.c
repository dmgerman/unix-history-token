begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: test.c,v 1.21 1999/04/05 09:48:38 kleink Exp $	*/
end_comment

begin_comment
comment|/*-  * test(1); version 7-like  --  author Erik Baalbergen  * modified by Eric Gisin to be used as built-in.  * modified by Arnold Robbins to add SVR3 compatibility  * (-x -c -b -p -u -g -k) plus Korn's -L -nt -ot -ef and new -S (socket).  * modified by J.T. Conklin for NetBSD.  *  * This program is in the Public Domain.  */
end_comment

begin_comment
comment|/*  * Important: This file is used both as a standalone program /bin/test and  * as a builtin for /bin/sh (#define SHELL).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SHELL
end_ifdef

begin_define
define|#
directive|define
name|main
value|testcmd
end_define

begin_include
include|#
directive|include
file|"bltin/bltin.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|error
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|__dead2
name|__printf0like
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|verrx
argument_list|(
literal|2
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* test(1) accepts the following grammar: 	oexpr	::= aexpr | aexpr "-o" oexpr ; 	aexpr	::= nexpr | nexpr "-a" aexpr ; 	nexpr	::= primary | "!" primary 	primary	::= unary-operator operand 		| operand binary-operator operand 		| operand 		| "(" oexpr ")" 		; 	unary-operator ::= "-r"|"-w"|"-x"|"-f"|"-d"|"-c"|"-b"|"-p"| 		"-u"|"-g"|"-k"|"-s"|"-t"|"-z"|"-n"|"-o"|"-O"|"-G"|"-L"|"-S";  	binary-operator ::= "="|"!="|"-eq"|"-ne"|"-ge"|"-gt"|"-le"|"-lt"| 			"-nt"|"-ot"|"-ef"; 	operand ::=<any legal UNIX file name> */
end_comment

begin_enum
enum|enum
name|token
block|{
name|EOI
block|,
name|FILRD
block|,
name|FILWR
block|,
name|FILEX
block|,
name|FILEXIST
block|,
name|FILREG
block|,
name|FILDIR
block|,
name|FILCDEV
block|,
name|FILBDEV
block|,
name|FILFIFO
block|,
name|FILSOCK
block|,
name|FILSYM
block|,
name|FILGZ
block|,
name|FILTT
block|,
name|FILSUID
block|,
name|FILSGID
block|,
name|FILSTCK
block|,
name|FILNT
block|,
name|FILOT
block|,
name|FILEQ
block|,
name|FILUID
block|,
name|FILGID
block|,
name|STREZ
block|,
name|STRNZ
block|,
name|STREQ
block|,
name|STRNE
block|,
name|STRLT
block|,
name|STRGT
block|,
name|INTEQ
block|,
name|INTNE
block|,
name|INTGE
block|,
name|INTGT
block|,
name|INTLE
block|,
name|INTLT
block|,
name|UNOT
block|,
name|BAND
block|,
name|BOR
block|,
name|LPAREN
block|,
name|RPAREN
block|,
name|OPERAND
block|}
enum|;
end_enum

begin_enum
enum|enum
name|token_types
block|{
name|UNOP
block|,
name|BINOP
block|,
name|BUNOP
block|,
name|BBINOP
block|,
name|PAREN
block|}
enum|;
end_enum

begin_struct
struct|struct
name|t_op
block|{
specifier|const
name|char
modifier|*
name|op_text
decl_stmt|;
name|short
name|op_num
decl_stmt|,
name|op_type
decl_stmt|;
block|}
decl|const
name|ops
index|[]
init|=
block|{
block|{
literal|"-r"
block|,
name|FILRD
block|,
name|UNOP
block|}
block|,
block|{
literal|"-w"
block|,
name|FILWR
block|,
name|UNOP
block|}
block|,
block|{
literal|"-x"
block|,
name|FILEX
block|,
name|UNOP
block|}
block|,
block|{
literal|"-e"
block|,
name|FILEXIST
block|,
name|UNOP
block|}
block|,
block|{
literal|"-f"
block|,
name|FILREG
block|,
name|UNOP
block|}
block|,
block|{
literal|"-d"
block|,
name|FILDIR
block|,
name|UNOP
block|}
block|,
block|{
literal|"-c"
block|,
name|FILCDEV
block|,
name|UNOP
block|}
block|,
block|{
literal|"-b"
block|,
name|FILBDEV
block|,
name|UNOP
block|}
block|,
block|{
literal|"-p"
block|,
name|FILFIFO
block|,
name|UNOP
block|}
block|,
block|{
literal|"-u"
block|,
name|FILSUID
block|,
name|UNOP
block|}
block|,
block|{
literal|"-g"
block|,
name|FILSGID
block|,
name|UNOP
block|}
block|,
block|{
literal|"-k"
block|,
name|FILSTCK
block|,
name|UNOP
block|}
block|,
block|{
literal|"-s"
block|,
name|FILGZ
block|,
name|UNOP
block|}
block|,
block|{
literal|"-t"
block|,
name|FILTT
block|,
name|UNOP
block|}
block|,
block|{
literal|"-z"
block|,
name|STREZ
block|,
name|UNOP
block|}
block|,
block|{
literal|"-n"
block|,
name|STRNZ
block|,
name|UNOP
block|}
block|,
block|{
literal|"-h"
block|,
name|FILSYM
block|,
name|UNOP
block|}
block|,
comment|/* for backwards compat */
block|{
literal|"-O"
block|,
name|FILUID
block|,
name|UNOP
block|}
block|,
block|{
literal|"-G"
block|,
name|FILGID
block|,
name|UNOP
block|}
block|,
block|{
literal|"-L"
block|,
name|FILSYM
block|,
name|UNOP
block|}
block|,
block|{
literal|"-S"
block|,
name|FILSOCK
block|,
name|UNOP
block|}
block|,
block|{
literal|"="
block|,
name|STREQ
block|,
name|BINOP
block|}
block|,
block|{
literal|"!="
block|,
name|STRNE
block|,
name|BINOP
block|}
block|,
block|{
literal|"<"
block|,
name|STRLT
block|,
name|BINOP
block|}
block|,
block|{
literal|">"
block|,
name|STRGT
block|,
name|BINOP
block|}
block|,
block|{
literal|"-eq"
block|,
name|INTEQ
block|,
name|BINOP
block|}
block|,
block|{
literal|"-ne"
block|,
name|INTNE
block|,
name|BINOP
block|}
block|,
block|{
literal|"-ge"
block|,
name|INTGE
block|,
name|BINOP
block|}
block|,
block|{
literal|"-gt"
block|,
name|INTGT
block|,
name|BINOP
block|}
block|,
block|{
literal|"-le"
block|,
name|INTLE
block|,
name|BINOP
block|}
block|,
block|{
literal|"-lt"
block|,
name|INTLT
block|,
name|BINOP
block|}
block|,
block|{
literal|"-nt"
block|,
name|FILNT
block|,
name|BINOP
block|}
block|,
block|{
literal|"-ot"
block|,
name|FILOT
block|,
name|BINOP
block|}
block|,
block|{
literal|"-ef"
block|,
name|FILEQ
block|,
name|BINOP
block|}
block|,
block|{
literal|"!"
block|,
name|UNOT
block|,
name|BUNOP
block|}
block|,
block|{
literal|"-a"
block|,
name|BAND
block|,
name|BBINOP
block|}
block|,
block|{
literal|"-o"
block|,
name|BOR
block|,
name|BBINOP
block|}
block|,
block|{
literal|"("
block|,
name|LPAREN
block|,
name|PAREN
block|}
block|,
block|{
literal|")"
block|,
name|RPAREN
block|,
name|PAREN
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|t_op
specifier|const
modifier|*
name|t_wp_op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|t_wp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|parenlevel
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|aexpr
parameter_list|(
name|enum
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|binop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|equalf
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filstat
parameter_list|(
name|char
modifier|*
parameter_list|,
name|enum
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getn
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|intmax_t
name|getq
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intcmp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isunopoperand
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|islparenoperand
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isrparenoperand
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|newerf
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nexpr
parameter_list|(
name|enum
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oexpr
parameter_list|(
name|enum
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|olderf
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|primary
parameter_list|(
name|enum
name|token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|syntax
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|token
name|t_lex
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"["
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
operator|--
name|argc
index|]
argument_list|,
literal|"]"
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* no expression => false */
if|if
condition|(
operator|--
name|argc
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
ifndef|#
directive|ifndef
name|SHELL
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nargc
operator|=
name|argc
expr_stmt|;
name|t_wp
operator|=
operator|&
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|parenlevel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nargc
operator|==
literal|4
operator|&&
name|strcmp
argument_list|(
operator|*
name|t_wp
argument_list|,
literal|"!"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Things like ! "" -o x do not fit in the normal grammar. */
operator|--
name|nargc
expr_stmt|;
operator|++
name|t_wp
expr_stmt|;
name|res
operator|=
name|oexpr
argument_list|(
name|t_lex
argument_list|(
operator|*
name|t_wp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
operator|!
name|oexpr
argument_list|(
name|t_lex
argument_list|(
operator|*
name|t_wp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|nargc
operator|>
literal|0
condition|)
name|syntax
argument_list|(
operator|*
name|t_wp
argument_list|,
literal|"unexpected operator"
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|syntax
parameter_list|(
specifier|const
name|char
modifier|*
name|op
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|op
operator|&&
operator|*
name|op
condition|)
name|error
argument_list|(
literal|"%s: %s"
argument_list|,
name|op
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|oexpr
parameter_list|(
name|enum
name|token
name|n
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|aexpr
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_lex
argument_list|(
name|nargc
operator|>
literal|0
condition|?
operator|(
operator|--
name|nargc
operator|,
operator|*
operator|++
name|t_wp
operator|)
else|:
name|NULL
argument_list|)
operator|==
name|BOR
condition|)
return|return
name|oexpr
argument_list|(
name|t_lex
argument_list|(
name|nargc
operator|>
literal|0
condition|?
operator|(
operator|--
name|nargc
operator|,
operator|*
operator|++
name|t_wp
operator|)
else|:
name|NULL
argument_list|)
argument_list|)
operator|||
name|res
return|;
name|t_wp
operator|--
expr_stmt|;
name|nargc
operator|++
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aexpr
parameter_list|(
name|enum
name|token
name|n
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|nexpr
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_lex
argument_list|(
name|nargc
operator|>
literal|0
condition|?
operator|(
operator|--
name|nargc
operator|,
operator|*
operator|++
name|t_wp
operator|)
else|:
name|NULL
argument_list|)
operator|==
name|BAND
condition|)
return|return
name|aexpr
argument_list|(
name|t_lex
argument_list|(
name|nargc
operator|>
literal|0
condition|?
operator|(
operator|--
name|nargc
operator|,
operator|*
operator|++
name|t_wp
operator|)
else|:
name|NULL
argument_list|)
argument_list|)
operator|&&
name|res
return|;
name|t_wp
operator|--
expr_stmt|;
name|nargc
operator|++
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nexpr
parameter_list|(
name|enum
name|token
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
name|UNOT
condition|)
return|return
operator|!
name|nexpr
argument_list|(
name|t_lex
argument_list|(
name|nargc
operator|>
literal|0
condition|?
operator|(
operator|--
name|nargc
operator|,
operator|*
operator|++
name|t_wp
operator|)
else|:
name|NULL
argument_list|)
argument_list|)
return|;
return|return
name|primary
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|primary
parameter_list|(
name|enum
name|token
name|n
parameter_list|)
block|{
name|enum
name|token
name|nn
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|EOI
condition|)
return|return
literal|0
return|;
comment|/* missing expression */
if|if
condition|(
name|n
operator|==
name|LPAREN
condition|)
block|{
name|parenlevel
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|nn
operator|=
name|t_lex
argument_list|(
name|nargc
operator|>
literal|0
condition|?
operator|(
operator|--
name|nargc
operator|,
operator|*
operator|++
name|t_wp
operator|)
else|:
name|NULL
argument_list|)
operator|)
operator|==
name|RPAREN
condition|)
block|{
name|parenlevel
operator|--
expr_stmt|;
return|return
literal|0
return|;
comment|/* missing expression */
block|}
name|res
operator|=
name|oexpr
argument_list|(
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_lex
argument_list|(
name|nargc
operator|>
literal|0
condition|?
operator|(
operator|--
name|nargc
operator|,
operator|*
operator|++
name|t_wp
operator|)
else|:
name|NULL
argument_list|)
operator|!=
name|RPAREN
condition|)
name|syntax
argument_list|(
name|NULL
argument_list|,
literal|"closing paren expected"
argument_list|)
expr_stmt|;
name|parenlevel
operator|--
expr_stmt|;
return|return
name|res
return|;
block|}
if|if
condition|(
name|t_wp_op
operator|&&
name|t_wp_op
operator|->
name|op_type
operator|==
name|UNOP
condition|)
block|{
comment|/* unary expression */
if|if
condition|(
operator|--
name|nargc
operator|==
literal|0
condition|)
name|syntax
argument_list|(
name|t_wp_op
operator|->
name|op_text
argument_list|,
literal|"argument expected"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|STREZ
case|:
return|return
name|strlen
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|)
operator|==
literal|0
return|;
case|case
name|STRNZ
case|:
return|return
name|strlen
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|)
operator|!=
literal|0
return|;
case|case
name|FILTT
case|:
return|return
name|isatty
argument_list|(
name|getn
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|filstat
argument_list|(
operator|*
operator|++
name|t_wp
argument_list|,
name|n
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|t_lex
argument_list|(
name|nargc
operator|>
literal|0
condition|?
name|t_wp
index|[
literal|1
index|]
else|:
name|NULL
argument_list|)
operator|,
name|t_wp_op
operator|&&
name|t_wp_op
operator|->
name|op_type
operator|==
name|BINOP
condition|)
block|{
return|return
name|binop
argument_list|()
return|;
block|}
return|return
name|strlen
argument_list|(
operator|*
name|t_wp
argument_list|)
operator|>
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|binop
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|opnd1
decl_stmt|,
modifier|*
name|opnd2
decl_stmt|;
name|struct
name|t_op
specifier|const
modifier|*
name|op
decl_stmt|;
name|opnd1
operator|=
operator|*
name|t_wp
expr_stmt|;
operator|(
name|void
operator|)
name|t_lex
argument_list|(
name|nargc
operator|>
literal|0
condition|?
operator|(
operator|--
name|nargc
operator|,
operator|*
operator|++
name|t_wp
operator|)
else|:
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|t_wp_op
expr_stmt|;
if|if
condition|(
operator|(
name|opnd2
operator|=
name|nargc
operator|>
literal|0
condition|?
operator|(
operator|--
name|nargc
operator|,
operator|*
operator|++
name|t_wp
operator|)
else|:
name|NULL
operator|)
operator|==
name|NULL
condition|)
name|syntax
argument_list|(
name|op
operator|->
name|op_text
argument_list|,
literal|"argument expected"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|op_num
condition|)
block|{
case|case
name|STREQ
case|:
return|return
name|strcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|==
literal|0
return|;
case|case
name|STRNE
case|:
return|return
name|strcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|!=
literal|0
return|;
case|case
name|STRLT
case|:
return|return
name|strcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|<
literal|0
return|;
case|case
name|STRGT
case|:
return|return
name|strcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|>
literal|0
return|;
case|case
name|INTEQ
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|==
literal|0
return|;
case|case
name|INTNE
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|!=
literal|0
return|;
case|case
name|INTGE
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|>=
literal|0
return|;
case|case
name|INTGT
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|>
literal|0
return|;
case|case
name|INTLE
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|<=
literal|0
return|;
case|case
name|INTLT
case|:
return|return
name|intcmp
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
operator|<
literal|0
return|;
case|case
name|FILNT
case|:
return|return
name|newerf
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
return|;
case|case
name|FILOT
case|:
return|return
name|olderf
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
return|;
case|case
name|FILEQ
case|:
return|return
name|equalf
argument_list|(
name|opnd1
argument_list|,
name|opnd2
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|filstat
parameter_list|(
name|char
modifier|*
name|nm
parameter_list|,
name|enum
name|token
name|mode
parameter_list|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|FILSYM
condition|?
name|lstat
argument_list|(
name|nm
argument_list|,
operator|&
name|s
argument_list|)
else|:
name|stat
argument_list|(
name|nm
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|FILRD
case|:
return|return
operator|(
name|eaccess
argument_list|(
name|nm
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
return|;
case|case
name|FILWR
case|:
return|return
operator|(
name|eaccess
argument_list|(
name|nm
argument_list|,
name|W_OK
argument_list|)
operator|==
literal|0
operator|)
return|;
case|case
name|FILEX
case|:
comment|/* XXX work around eaccess(2) false positives for superuser */
if|if
condition|(
name|eaccess
argument_list|(
name|nm
argument_list|,
name|X_OK
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
operator|||
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|s
operator|.
name|st_mode
operator|&
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|)
operator|!=
literal|0
return|;
case|case
name|FILEXIST
case|:
return|return
operator|(
name|eaccess
argument_list|(
name|nm
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
operator|)
return|;
case|case
name|FILREG
case|:
return|return
name|S_ISREG
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILDIR
case|:
return|return
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILCDEV
case|:
return|return
name|S_ISCHR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILBDEV
case|:
return|return
name|S_ISBLK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILFIFO
case|:
return|return
name|S_ISFIFO
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILSOCK
case|:
return|return
name|S_ISSOCK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILSYM
case|:
return|return
name|S_ISLNK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
return|;
case|case
name|FILSUID
case|:
return|return
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_ISUID
operator|)
operator|!=
literal|0
return|;
case|case
name|FILSGID
case|:
return|return
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_ISGID
operator|)
operator|!=
literal|0
return|;
case|case
name|FILSTCK
case|:
return|return
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_ISVTX
operator|)
operator|!=
literal|0
return|;
case|case
name|FILGZ
case|:
return|return
name|s
operator|.
name|st_size
operator|>
operator|(
name|off_t
operator|)
literal|0
return|;
case|case
name|FILUID
case|:
return|return
name|s
operator|.
name|st_uid
operator|==
name|geteuid
argument_list|()
return|;
case|case
name|FILGID
case|:
return|return
name|s
operator|.
name|st_gid
operator|==
name|getegid
argument_list|()
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|token
name|t_lex
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|t_op
specifier|const
modifier|*
name|op
init|=
name|ops
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|t_wp_op
operator|=
name|NULL
expr_stmt|;
return|return
name|EOI
return|;
block|}
while|while
condition|(
name|op
operator|->
name|op_text
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|op_text
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|op
operator|->
name|op_type
operator|==
name|UNOP
operator|||
name|op
operator|->
name|op_type
operator|==
name|BUNOP
operator|)
operator|&&
name|isunopoperand
argument_list|()
operator|)
operator|||
operator|(
name|op
operator|->
name|op_num
operator|==
name|LPAREN
operator|&&
name|islparenoperand
argument_list|()
operator|)
operator|||
operator|(
name|op
operator|->
name|op_num
operator|==
name|RPAREN
operator|&&
name|isrparenoperand
argument_list|()
operator|)
condition|)
break|break;
name|t_wp_op
operator|=
name|op
expr_stmt|;
return|return
name|op
operator|->
name|op_num
return|;
block|}
name|op
operator|++
expr_stmt|;
block|}
name|t_wp_op
operator|=
name|NULL
expr_stmt|;
return|return
name|OPERAND
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isunopoperand
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|t_op
specifier|const
modifier|*
name|op
init|=
name|ops
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|nargc
operator|==
literal|1
condition|)
return|return
literal|1
return|;
name|s
operator|=
operator|*
operator|(
name|t_wp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nargc
operator|==
literal|2
condition|)
return|return
name|parenlevel
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
literal|")"
argument_list|)
operator|==
literal|0
return|;
name|t
operator|=
operator|*
operator|(
name|t_wp
operator|+
literal|2
operator|)
expr_stmt|;
while|while
condition|(
name|op
operator|->
name|op_text
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|op_text
argument_list|)
operator|==
literal|0
condition|)
return|return
name|op
operator|->
name|op_type
operator|==
name|BINOP
operator|&&
operator|(
name|parenlevel
operator|==
literal|0
operator|||
name|t
index|[
literal|0
index|]
operator|!=
literal|')'
operator|||
name|t
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
return|;
name|op
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|islparenoperand
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|t_op
specifier|const
modifier|*
name|op
init|=
name|ops
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|nargc
operator|==
literal|1
condition|)
return|return
literal|1
return|;
name|s
operator|=
operator|*
operator|(
name|t_wp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nargc
operator|==
literal|2
condition|)
return|return
name|parenlevel
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
literal|")"
argument_list|)
operator|==
literal|0
return|;
if|if
condition|(
name|nargc
operator|!=
literal|3
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|op
operator|->
name|op_text
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|op_text
argument_list|)
operator|==
literal|0
condition|)
return|return
name|op
operator|->
name|op_type
operator|==
name|BINOP
return|;
name|op
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isrparenoperand
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|nargc
operator|==
literal|1
condition|)
return|return
literal|0
return|;
name|s
operator|=
operator|*
operator|(
name|t_wp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nargc
operator|==
literal|2
condition|)
return|return
name|parenlevel
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
literal|")"
argument_list|)
operator|==
literal|0
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* atoi with error detection */
end_comment

begin_function
specifier|static
name|int
name|getn
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|r
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|p
condition|)
name|error
argument_list|(
literal|"%s: bad number"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|error
argument_list|(
operator|(
name|errno
operator|==
name|EINVAL
operator|)
condition|?
literal|"%s: bad number"
else|:
literal|"%s: out of range"
argument_list|,
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|error
argument_list|(
literal|"%s: bad number"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|r
return|;
block|}
end_function

begin_comment
comment|/* atoi with error detection and 64 bit range */
end_comment

begin_function
specifier|static
name|intmax_t
name|getq
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|intmax_t
name|r
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|strtoimax
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|p
condition|)
name|error
argument_list|(
literal|"%s: bad number"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|error
argument_list|(
operator|(
name|errno
operator|==
name|EINVAL
operator|)
condition|?
literal|"%s: bad number"
else|:
literal|"%s: out of range"
argument_list|,
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|error
argument_list|(
literal|"%s: bad number"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|intmax_t
name|q1
decl_stmt|,
name|q2
decl_stmt|;
name|q1
operator|=
name|getq
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|q2
operator|=
name|getq
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|q1
operator|>
name|q2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|q1
operator|<
name|q2
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|newerf
parameter_list|(
specifier|const
name|char
modifier|*
name|f1
parameter_list|,
specifier|const
name|char
modifier|*
name|f2
parameter_list|)
block|{
name|struct
name|stat
name|b1
decl_stmt|,
name|b2
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|f1
argument_list|,
operator|&
name|b1
argument_list|)
operator|!=
literal|0
operator|||
name|stat
argument_list|(
name|f2
argument_list|,
operator|&
name|b2
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|b1
operator|.
name|st_mtimespec
operator|.
name|tv_sec
operator|>
name|b2
operator|.
name|st_mtimespec
operator|.
name|tv_sec
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|b1
operator|.
name|st_mtimespec
operator|.
name|tv_sec
operator|<
name|b2
operator|.
name|st_mtimespec
operator|.
name|tv_sec
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|b1
operator|.
name|st_mtimespec
operator|.
name|tv_nsec
operator|>
name|b2
operator|.
name|st_mtimespec
operator|.
name|tv_nsec
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|olderf
parameter_list|(
specifier|const
name|char
modifier|*
name|f1
parameter_list|,
specifier|const
name|char
modifier|*
name|f2
parameter_list|)
block|{
return|return
operator|(
name|newerf
argument_list|(
name|f2
argument_list|,
name|f1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|equalf
parameter_list|(
specifier|const
name|char
modifier|*
name|f1
parameter_list|,
specifier|const
name|char
modifier|*
name|f2
parameter_list|)
block|{
name|struct
name|stat
name|b1
decl_stmt|,
name|b2
decl_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|f1
argument_list|,
operator|&
name|b1
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|f2
argument_list|,
operator|&
name|b2
argument_list|)
operator|==
literal|0
operator|&&
name|b1
operator|.
name|st_dev
operator|==
name|b2
operator|.
name|st_dev
operator|&&
name|b1
operator|.
name|st_ino
operator|==
name|b2
operator|.
name|st_ino
operator|)
return|;
block|}
end_function

end_unit

