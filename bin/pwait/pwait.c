begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2009, Jilles Tjoelker  * All rights reserved.  *  * Redistribution and use in source and binary forms, with  * or without modification, are permitted provided that the  * following conditions are met:  *  * 1. Redistributions of source code must retain the above  *    copyright notice, this list of conditions and the  *    following disclaimer.  * 2. Redistributions in binary form must reproduce the  *    above copyright notice, this list of conditions and  *    the following disclaimer in the documentation and/or  *    other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND  * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: pwait [-t timeout] [-v] pid ...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pwait - wait for processes to terminate  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|itimerval
name|itv
decl_stmt|;
name|int
name|kq
decl_stmt|;
name|struct
name|kevent
modifier|*
name|e
decl_stmt|;
name|int
name|tflag
decl_stmt|,
name|verbose
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|nleft
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|duplicate
decl_stmt|,
name|status
decl_stmt|;
name|long
name|pid
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|double
name|timeout
decl_stmt|;
name|tflag
operator|=
name|verbose
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|itv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|itv
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"t:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'t'
case|:
name|tflag
operator|=
literal|1
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
name|strtod
argument_list|(
name|optarg
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|optarg
operator|||
name|errno
operator|==
name|ERANGE
operator|||
name|timeout
operator|<
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"timeout value"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|end
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|'s'
case|:
break|break;
case|case
literal|'h'
case|:
name|timeout
operator|*=
literal|60
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'m'
case|:
name|timeout
operator|*=
literal|60
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"timeout unit"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|>
literal|100000000L
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"timeout value"
argument_list|)
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
name|time_t
operator|)
name|timeout
expr_stmt|;
name|timeout
operator|-=
operator|(
name|time_t
operator|)
name|timeout
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
call|(
name|suseconds_t
call|)
argument_list|(
name|timeout
operator|*
literal|1000000UL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
name|kq
operator|=
name|kqueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|kq
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"kqueue"
argument_list|)
expr_stmt|;
name|e
operator|=
name|malloc
argument_list|(
operator|(
name|argc
operator|+
name|tflag
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|nleft
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|argc
condition|;
name|n
operator|++
control|)
block|{
name|s
operator|=
name|argv
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"/proc/"
argument_list|,
literal|6
argument_list|)
condition|)
comment|/* Undocumented Solaris compat */
name|s
operator|+=
literal|6
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
operator|||
operator|*
name|end
operator|!=
literal|'\0'
operator|||
name|errno
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: bad process id"
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|duplicate
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nleft
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|e
index|[
name|i
index|]
operator|.
name|ident
operator|==
operator|(
name|uintptr_t
operator|)
name|pid
condition|)
name|duplicate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate
condition|)
block|{
name|EV_SET
argument_list|(
name|e
operator|+
name|nleft
argument_list|,
name|pid
argument_list|,
name|EVFILT_PROC
argument_list|,
name|EV_ADD
argument_list|,
name|NOTE_EXIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|kq
argument_list|,
name|e
operator|+
name|nleft
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"%ld"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|else
name|nleft
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tflag
condition|)
block|{
comment|/* 		 * Explicitly detect SIGALRM so that an exit status of 124 		 * can be returned rather than 142. 		 */
name|EV_SET
argument_list|(
name|e
operator|+
name|nleft
argument_list|,
name|SIGALRM
argument_list|,
name|EVFILT_SIGNAL
argument_list|,
name|EV_ADD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|kq
argument_list|,
name|e
operator|+
name|nleft
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"kevent"
argument_list|)
expr_stmt|;
comment|/* Ignore SIGALRM to not interrupt kevent(2). */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"setitimer"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nleft
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|kevent
argument_list|(
name|kq
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|e
argument_list|,
name|nleft
operator|+
name|tflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"kevent"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|e
index|[
name|i
index|]
operator|.
name|filter
operator|==
name|EVFILT_SIGNAL
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|124
operator|)
return|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|status
operator|=
name|e
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%ld: exited with status %d.\n"
argument_list|,
operator|(
name|long
operator|)
name|e
index|[
name|i
index|]
operator|.
name|ident
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%ld: killed by signal %d.\n"
argument_list|,
operator|(
name|long
operator|)
name|e
index|[
name|i
index|]
operator|.
name|ident
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%ld: terminated.\n"
argument_list|,
operator|(
name|long
operator|)
name|e
index|[
name|i
index|]
operator|.
name|ident
argument_list|)
expr_stmt|;
block|}
operator|--
name|nleft
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

