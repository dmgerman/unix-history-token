begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: csh.c,v 1.6.2.1 1997/08/24 21:41:29 jkh Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980, 1991, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)csh.c	8.2 (Berkeley) 10/12/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<vis.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"csh.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|extern
name|bool
name|MapsAreInited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bool
name|NLSMapsAreInited
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * C Shell  *  * Bill Joy, UC Berkeley, California, USA  * October 1978, May 1980  *  * Jim Kulp, IIASA, Laxenburg, Austria  * April 1980  *  * Christos Zoulas, Cornell University  * June, 1991  */
end_comment

begin_decl_stmt
name|Char
modifier|*
name|dumphist
index|[]
init|=
block|{
name|STRhistory
block|,
name|STRmh
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
modifier|*
name|loadhist
index|[]
init|=
block|{
name|STRsource
block|,
name|STRmh
block|,
name|STRtildothist
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nofile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|reenter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|nverbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|nexececho
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|quitit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|fast
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|batch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|mflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|prompt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|enterhist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|tellwhat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readf
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fpos_t
name|seekf
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|fpos_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|writef
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|closef
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|srccat
name|__P
argument_list|(
operator|(
name|Char
operator|*
operator|,
name|Char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|srcfile
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bool
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|phup
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|srcunit
name|__P
argument_list|(
operator|(
name|int
operator|,
name|bool
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mailchk
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Char
modifier|*
modifier|*
name|defaultpath
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|Char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|tcp
decl_stmt|;
name|int
name|f
decl_stmt|;
name|char
modifier|*
modifier|*
name|tempv
decl_stmt|;
name|struct
name|sigvec
name|osv
decl_stmt|;
name|cshin
operator|=
name|stdin
expr_stmt|;
name|cshout
operator|=
name|stdout
expr_stmt|;
name|csherr
operator|=
name|stderr
expr_stmt|;
name|settimes
argument_list|()
expr_stmt|;
comment|/* Immed. estab. timing base */
comment|/*      * Initialize non constant strings      */
ifdef|#
directive|ifdef
name|_PATH_BSHELL
name|STR_BSHELL
operator|=
name|SAVE
argument_list|(
name|_PATH_BSHELL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_PATH_CSHELL
name|STR_SHELLPATH
operator|=
name|SAVE
argument_list|(
name|_PATH_CSHELL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STR_environ
operator|=
name|blk2short
argument_list|(
name|environ
argument_list|)
expr_stmt|;
name|environ
operator|=
name|short2blk
argument_list|(
name|STR_environ
argument_list|)
expr_stmt|;
comment|/* So that we can free it */
name|STR_WORD_CHARS
operator|=
name|SAVE
argument_list|(
name|WORD_CHARS
argument_list|)
expr_stmt|;
name|HIST
operator|=
literal|'!'
expr_stmt|;
name|HISTSUB
operator|=
literal|'^'
expr_stmt|;
name|word_chars
operator|=
name|STR_WORD_CHARS
expr_stmt|;
name|tempv
operator|=
name|argv
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
name|str2short
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|STRaout
argument_list|)
condition|)
comment|/* A.out's are quittable */
name|quitit
operator|=
literal|1
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|egid
operator|=
name|getegid
argument_list|()
expr_stmt|;
comment|/*      * We are a login shell if: 1. we were invoked as -<something> and we had      * no arguments 2. or we were invoked only with the -l flag      */
name|loginsh
operator|=
operator|(
operator|*
operator|*
name|tempv
operator|==
literal|'-'
operator|&&
name|argc
operator|==
literal|1
operator|)
operator|||
operator|(
name|argc
operator|==
literal|2
operator|&&
name|tempv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|tempv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|tempv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
if|if
condition|(
name|loginsh
operator|&&
operator|*
operator|*
name|tempv
operator|!=
literal|'-'
condition|)
block|{
comment|/* 	 * Mangle the argv space 	 */
name|tempv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tempv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tempv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|tcp
operator|=
operator|*
name|tempv
init|;
operator|*
name|tcp
operator|++
condition|;
control|)
continue|continue;
for|for
control|(
name|tcp
operator|--
init|;
name|tcp
operator|>=
operator|*
name|tempv
condition|;
name|tcp
operator|--
control|)
name|tcp
index|[
literal|1
index|]
operator|=
name|tcp
index|[
literal|0
index|]
expr_stmt|;
operator|*
operator|++
name|tcp
operator|=
literal|'-'
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|loginsh
condition|)
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|chktim
argument_list|)
expr_stmt|;
name|AsciiOnly
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|NLS
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0200
init|;
name|k
operator|<=
literal|0377
operator|&&
operator|!
name|Isprint
argument_list|(
name|k
argument_list|)
condition|;
name|k
operator|++
control|)
continue|continue;
name|AsciiOnly
operator|=
name|k
operator|>
literal|0377
expr_stmt|;
block|}
else|#
directive|else
name|AsciiOnly
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
operator|==
name|NULL
operator|&&
name|getenv
argument_list|(
literal|"LC_ALL"
argument_list|)
operator|==
name|NULL
operator|&&
name|getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
operator|==
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* NLS */
comment|/*      * Move the descriptors to safe places. The variable didfds is 0 while we      * have only FSH* to work with. When didfds is true, we have 0,1,2 and      * prefer to use these.      */
name|initdesc
argument_list|()
expr_stmt|;
comment|/*      * XXX: This is to keep programs that use stdio happy.      *	    what we really want is freunopen() ....      *	    Closing cshin cshout and csherr (which are really stdin stdout      *	    and stderr at this point and then reopening them in the same order      *	    gives us again stdin == cshin stdout == cshout and stderr == csherr.      *	    If that was not the case builtins like printf that use stdio      *	    would break. But in any case we could fix that with memcpy and      *	    a bit of pointer manipulation...      *	    Fortunately this is not needed under the current implementation      *	    of stdio.      */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cshin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cshout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|csherr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cshin
operator|=
name|funopen
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|SHIN
argument_list|,
name|readf
argument_list|,
name|writef
argument_list|,
name|seekf
argument_list|,
name|closef
argument_list|)
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cshout
operator|=
name|funopen
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|SHOUT
argument_list|,
name|readf
argument_list|,
name|writef
argument_list|,
name|seekf
argument_list|,
name|closef
argument_list|)
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|csherr
operator|=
name|funopen
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|SHERR
argument_list|,
name|readf
argument_list|,
name|writef
argument_list|,
name|seekf
argument_list|,
name|closef
argument_list|)
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|cshin
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|cshout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|csherr
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Initialize the shell variables. ARGV and PROMPT are initialized later.      * STATUS is also munged in several places. CHILD is munged when      * forking/waiting      */
name|set
argument_list|(
name|STRstatus
argument_list|,
name|Strsave
argument_list|(
name|STR0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|tcp
argument_list|)
operator|<
name|MAXPATHLEN
condition|)
name|cp
operator|=
name|SAVE
argument_list|(
name|tcp
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|fast
operator|=
literal|1
expr_stmt|;
comment|/* No home -> can't read scripts */
else|else
name|set
argument_list|(
name|STRhome
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|dinit
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* dinit thinks that HOME == cwd in a login 				 * shell */
comment|/*      * Grab other useful things from the environment. Should we grab      * everything??      */
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|set
argument_list|(
name|STRuser
argument_list|,
name|SAVE
argument_list|(
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|set
argument_list|(
name|STRterm
argument_list|,
name|SAVE
argument_list|(
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|STRshell
argument_list|,
name|Strsave
argument_list|(
name|STR_SHELLPATH
argument_list|)
argument_list|)
expr_stmt|;
name|doldol
operator|=
name|putn
argument_list|(
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* For $$ */
name|shtemp
operator|=
name|Strspl
argument_list|(
name|STRtmpsh
argument_list|,
name|doldol
argument_list|)
expr_stmt|;
comment|/* For<< */
comment|/*      * Record the interrupt states from the parent process. If the parent is      * non-interruptible our hand must be forced or we (and our children) won't      * be either. Our children inherit termination from our parent. We catch it      * only if we are the login shell.      */
comment|/* parents interruptibility */
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGINT
argument_list|,
name|NULL
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
name|parintr
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|osv
operator|.
name|sv_handler
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGTERM
argument_list|,
name|NULL
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
name|parterm
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|osv
operator|.
name|sv_handler
expr_stmt|;
if|if
condition|(
name|loginsh
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|phup
argument_list|)
expr_stmt|;
comment|/* exit processing on HUP */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGXCPU
argument_list|,
name|phup
argument_list|)
expr_stmt|;
comment|/* ...and on XCPU */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|phup
argument_list|)
expr_stmt|;
comment|/* ...and on XFSZ */
block|}
comment|/*      * Process the arguments.      *      * Note that processing of -v/-x is actually delayed till after script      * processing.      *      * We set the first character of our name to be '-' if we are a shell      * running interruptible commands.  Many programs which examine ps'es      * use this to filter such shells out.      */
name|argc
operator|--
operator|,
name|tempv
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|(
name|tcp
operator|=
name|tempv
index|[
literal|0
index|]
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|*
operator|++
name|tcp
operator|!=
literal|'\0'
operator|&&
operator|!
name|batch
condition|)
block|{
do|do
switch|switch
condition|(
operator|*
name|tcp
operator|++
condition|)
block|{
case|case
literal|0
case|:
comment|/* -	Interruptible, no prompt */
name|prompt
operator|=
literal|0
expr_stmt|;
name|setintr
operator|=
literal|1
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* -b	Next arg is input file */
name|batch
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* -c	Command input from arg */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|tempv
operator|++
expr_stmt|;
name|arginp
operator|=
name|SAVE
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|prompt
operator|=
literal|0
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* -e	Exit on any error */
name|exiterr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* -f	Fast start */
name|fast
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* -i	Interactive, even if !intty */
name|intact
operator|=
literal|1
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* -m	read .cshrc (from su) */
name|mflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* -n	Don't execute */
name|noexec
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* -q	(Undoc'd) ... die on quit */
name|quitit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* -s	Read from std input */
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* -t	Read one line from input */
name|onelflg
operator|=
literal|2
expr_stmt|;
name|prompt
operator|=
literal|0
expr_stmt|;
name|nofile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* -v	Echo hist expanded input */
name|nverbose
operator|=
literal|1
expr_stmt|;
comment|/* ... later */
break|break;
case|case
literal|'x'
case|:
comment|/* -x	Echo just before execution */
name|nexececho
operator|=
literal|1
expr_stmt|;
comment|/* ... later */
break|break;
case|case
literal|'V'
case|:
comment|/* -V	Echo hist expanded input */
name|setNS
argument_list|(
name|STRverbose
argument_list|)
expr_stmt|;
comment|/* NOW! */
break|break;
case|case
literal|'X'
case|:
comment|/* -X	Echo just before execution */
name|setNS
argument_list|(
name|STRecho
argument_list|)
expr_stmt|;
comment|/* NOW! */
break|break;
block|}
do|while
condition|(
operator|*
name|tcp
condition|)
do|;
name|tempv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|quitit
condition|)
comment|/* With all due haste, for debugging */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/*      * Unless prevented by -, -c, -i, -s, or -t, if there are remaining      * arguments the first of them is the name of a shell file from which to      * read commands.      */
if|if
condition|(
name|nofile
operator|==
literal|0
operator|&&
name|argc
operator|>
literal|0
condition|)
block|{
name|nofile
operator|=
name|open
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|nofile
operator|<
literal|0
condition|)
block|{
name|child
operator|=
literal|1
expr_stmt|;
comment|/* So this doesn't return */
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|tempv
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ffile
operator|=
name|SAVE
argument_list|(
name|tempv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Replace FSHIN. Handle /dev/std{in,out,err} specially 	 * since once they are closed we cannot open them again. 	 * In that case we use our own saved descriptors 	 */
if|if
condition|(
operator|(
name|SHIN
operator|=
name|dmove
argument_list|(
name|nofile
argument_list|,
name|FSHIN
argument_list|)
operator|)
operator|<
literal|0
condition|)
switch|switch
condition|(
name|nofile
condition|)
block|{
case|case
literal|0
case|:
name|SHIN
operator|=
name|FSHIN
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|SHIN
operator|=
name|FSHOUT
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|SHIN
operator|=
name|FSHERR
expr_stmt|;
break|break;
default|default:
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|tempv
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|SHIN
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prompt
operator|=
literal|0
expr_stmt|;
comment|/* argc not used any more */
name|tempv
operator|++
expr_stmt|;
block|}
name|intty
operator|=
name|isatty
argument_list|(
name|SHIN
argument_list|)
expr_stmt|;
name|intty
operator||=
name|intact
expr_stmt|;
if|if
condition|(
name|intty
operator|||
operator|(
name|intact
operator|&&
name|isatty
argument_list|(
name|SHOUT
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|batch
operator|&&
operator|(
name|uid
operator|!=
name|euid
operator|||
name|gid
operator|!=
name|egid
operator|)
condition|)
block|{
name|errno
operator|=
name|EACCES
expr_stmt|;
name|child
operator|=
literal|1
expr_stmt|;
comment|/* So this doesn't return */
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
literal|"csh"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Re-initialize path if set in environment      * importpath uses intty and intact      */
if|if
condition|(
operator|(
name|tcp
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|set1
argument_list|(
name|STRpath
argument_list|,
name|defaultpath
argument_list|()
argument_list|,
operator|&
name|shvhed
argument_list|)
expr_stmt|;
else|else
name|importpath
argument_list|(
name|SAVE
argument_list|(
name|tcp
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Decide whether we should play with signals or not. If we are explicitly      * told (via -i, or -) or we are a login shell (arg0 starts with -) or the      * input and output are both the ttys("csh", or "csh</dev/ttyx>/dev/ttyx")      * Note that in only the login shell is it likely that parent may have set      * signals to be ignored      */
if|if
condition|(
name|loginsh
operator|||
name|intact
operator|||
operator|(
name|intty
operator|&&
name|isatty
argument_list|(
name|SHOUT
argument_list|)
operator|)
condition|)
name|setintr
operator|=
literal|1
expr_stmt|;
name|settell
argument_list|()
expr_stmt|;
comment|/*      * Save the remaining arguments in argv.      */
name|setq
argument_list|(
name|STRargv
argument_list|,
name|blk2short
argument_list|(
name|tempv
argument_list|)
argument_list|,
operator|&
name|shvhed
argument_list|)
expr_stmt|;
comment|/*      * Set up the prompt.      */
if|if
condition|(
name|prompt
condition|)
block|{
name|set
argument_list|(
name|STRprompt
argument_list|,
name|Strsave
argument_list|(
name|uid
operator|==
literal|0
condition|?
name|STRsymhash
else|:
name|STRsymcent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* that's a meta-questionmark */
name|set
argument_list|(
name|STRprompt2
argument_list|,
name|Strsave
argument_list|(
name|STRmquestion
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we are an interactive shell, then start fiddling with the signals;      * this is a tricky game.      */
name|shpgrp
operator|=
name|getpgrp
argument_list|()
expr_stmt|;
name|opgrp
operator|=
name|tpgrp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
block|{
operator|*
operator|*
name|argv
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
operator|!
name|quitit
condition|)
comment|/* Wary! */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|pintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|quitit
operator|==
literal|0
operator|&&
name|arginp
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* 	     * Wait till in foreground, in case someone stupidly runs csh& 	     * dont want to try to grab away the tty. 	     */
if|if
condition|(
name|isatty
argument_list|(
name|FSHERR
argument_list|)
condition|)
name|f
operator|=
name|FSHERR
expr_stmt|;
elseif|else
if|if
condition|(
name|isatty
argument_list|(
name|FSHOUT
argument_list|)
condition|)
name|f
operator|=
name|FSHOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|isatty
argument_list|(
name|OLDSTD
argument_list|)
condition|)
name|f
operator|=
name|OLDSTD
expr_stmt|;
else|else
name|f
operator|=
operator|-
literal|1
expr_stmt|;
name|retry
label|:
if|if
condition|(
operator|(
name|tpgrp
operator|=
name|tcgetpgrp
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tpgrp
operator|!=
name|shpgrp
condition|)
block|{
name|sig_t
name|old
init|=
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTTIN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|old
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|opgrp
operator|=
name|shpgrp
expr_stmt|;
name|shpgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|tpgrp
operator|=
name|shpgrp
expr_stmt|;
comment|/* 		 * Setpgid will fail if we are a session leader and 		 * mypid == mypgrp (POSIX 4.3.3) 		 */
if|if
condition|(
name|opgrp
operator|!=
name|shpgrp
condition|)
if|if
condition|(
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shpgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|notty
goto|;
comment|/* 		 * We do that after we set our process group, to make sure 		 * that the process group belongs to a process in the same 		 * session as the tty (our process and our group) (POSIX 7.2.4) 		 */
if|if
condition|(
name|tcsetpgrp
argument_list|(
name|f
argument_list|,
name|shpgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|notty
goto|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|dcopy
argument_list|(
name|f
argument_list|,
name|FSHTTY
argument_list|)
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tpgrp
operator|==
operator|-
literal|1
condition|)
block|{
name|notty
label|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csherr
argument_list|,
literal|"Warning: no access to tty (%s).\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csherr
argument_list|,
literal|"Thus no job control in this shell.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|setintr
operator|==
literal|0
operator|)
operator|&&
operator|(
name|parintr
operator|==
name|SIG_DFL
operator|)
condition|)
name|setintr
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|pchild
argument_list|)
expr_stmt|;
comment|/* while signals not ready */
comment|/*      * Set an exit here in case of an interrupt or error reading the shell      * start-up scripts.      */
name|reenter
operator|=
name|setexit
argument_list|()
expr_stmt|;
comment|/* PWP */
name|haderr
operator|=
literal|0
expr_stmt|;
comment|/* In case second time through */
if|if
condition|(
operator|!
name|fast
operator|&&
name|reenter
operator|==
literal|0
condition|)
block|{
comment|/* Will have value(STRhome) here because set fast if don't */
block|{
name|int
name|osetintr
init|=
name|setintr
decl_stmt|;
name|sig_t
name|oparintr
init|=
name|parintr
decl_stmt|;
name|sigset_t
name|omask
init|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
decl_stmt|;
name|setintr
operator|=
literal|0
expr_stmt|;
name|parintr
operator|=
name|SIG_IGN
expr_stmt|;
comment|/* Disable onintr */
ifdef|#
directive|ifdef
name|_PATH_DOTCSHRC
operator|(
name|void
operator|)
name|srcfile
argument_list|(
name|_PATH_DOTCSHRC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fast
operator|&&
operator|!
name|arginp
operator|&&
operator|!
name|onelflg
condition|)
name|dohash
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_PATH_DOTLOGIN
if|if
condition|(
name|loginsh
condition|)
operator|(
name|void
operator|)
name|srcfile
argument_list|(
name|_PATH_DOTLOGIN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|setintr
operator|=
name|osetintr
expr_stmt|;
name|parintr
operator|=
name|oparintr
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldotcshrc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fast
operator|&&
operator|!
name|arginp
operator|&&
operator|!
name|onelflg
operator|&&
operator|!
name|havhash
condition|)
name|dohash
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Source history before .login so that it is available in .login 	 */
if|if
condition|(
operator|(
name|cp
operator|=
name|value
argument_list|(
name|STRhistfile
argument_list|)
operator|)
operator|!=
name|STRNULL
condition|)
name|loadhist
index|[
literal|2
index|]
operator|=
name|cp
expr_stmt|;
name|dosource
argument_list|(
name|loadhist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|loginsh
condition|)
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldotlogin
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now are ready for the -v and -x flags      */
if|if
condition|(
name|nverbose
condition|)
name|setNS
argument_list|(
name|STRverbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexececho
condition|)
name|setNS
argument_list|(
name|STRecho
argument_list|)
expr_stmt|;
comment|/*      * All the rest of the world is inside this call. The argument to process      * indicates whether it should catch "error unwinds".  Thus if we are a      * interactive shell our call here will never return by being blown past on      * an error.      */
name|process
argument_list|(
name|setintr
argument_list|)
expr_stmt|;
comment|/*      * Mop-up.      */
if|if
condition|(
name|intty
condition|)
block|{
if|if
condition|(
name|loginsh
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"logout\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|SHIN
argument_list|)
expr_stmt|;
name|child
operator|=
literal|1
expr_stmt|;
name|goodbye
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"exit\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|rechist
argument_list|()
expr_stmt|;
name|exitstat
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|untty
parameter_list|()
block|{
if|if
condition|(
name|tpgrp
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|setpgid
argument_list|(
literal|0
argument_list|,
name|opgrp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetpgrp
argument_list|(
name|FSHTTY
argument_list|,
name|opgrp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|importpath
parameter_list|(
name|cp
parameter_list|)
name|Char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Char
modifier|*
name|dp
decl_stmt|;
name|Char
modifier|*
modifier|*
name|pv
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|cp
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
if|if
condition|(
operator|*
name|dp
operator|==
literal|':'
condition|)
name|i
operator|++
expr_stmt|;
comment|/*      * i+2 where i is the number of colons in the path. There are i+1      * directories in the path plus we need room for a zero terminator.      */
name|pv
operator|=
operator|(
name|Char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|Char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|=
name|cp
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|dp
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|dp
operator|)
operator|==
literal|':'
operator|||
name|c
operator|==
literal|0
condition|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
operator|&&
operator|(
name|euid
operator|==
literal|0
operator|||
name|uid
operator|==
literal|0
operator|)
operator|&&
operator|(
name|intact
operator|||
operator|(
name|intty
operator|&&
name|isatty
argument_list|(
name|SHOUT
argument_list|)
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csherr
argument_list|,
literal|"Warning: imported path contains relative components\n"
argument_list|)
expr_stmt|;
name|pv
index|[
name|i
operator|++
index|]
operator|=
name|Strsave
argument_list|(
operator|*
name|cp
condition|?
name|cp
else|:
name|STRdot
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|cp
operator|=
name|dp
operator|+
literal|1
expr_stmt|;
operator|*
name|dp
operator|=
literal|':'
expr_stmt|;
block|}
else|else
break|break;
block|}
name|dp
operator|++
expr_stmt|;
block|}
name|pv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|set1
argument_list|(
name|STRpath
argument_list|,
name|pv
argument_list|,
operator|&
name|shvhed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Source to the file which is the catenation of the argument names.  */
end_comment

begin_function
specifier|static
name|int
name|srccat
parameter_list|(
name|cp
parameter_list|,
name|dp
parameter_list|)
name|Char
modifier|*
name|cp
decl_stmt|,
decl|*
name|dp
decl_stmt|;
end_function

begin_block
block|{
name|Char
modifier|*
name|ep
init|=
name|Strspl
argument_list|(
name|cp
argument_list|,
name|dp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|short2str
argument_list|(
name|ep
argument_list|)
decl_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|ep
argument_list|)
expr_stmt|;
return|return
name|srcfile
argument_list|(
name|ptr
argument_list|,
name|mflag
condition|?
literal|0
else|:
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Source to a file putting the file descriptor in a safe place (> 2).  */
end_comment

begin_function
specifier|static
name|int
name|srcfile
parameter_list|(
name|f
parameter_list|,
name|onlyown
parameter_list|,
name|flag
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|bool
name|onlyown
decl_stmt|,
name|flag
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|;
if|if
condition|(
operator|(
name|unit
operator|=
name|open
argument_list|(
name|f
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|unit
operator|=
name|dmove
argument_list|(
name|unit
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|unit
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|srcunit
argument_list|(
name|unit
argument_list|,
name|onlyown
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Source to a unit.  If onlyown it must be our file or our group or  * we don't chance it.	This occurs on ".cshrc"s and the like.  */
end_comment

begin_decl_stmt
name|int
name|insource
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|srcunit
parameter_list|(
name|unit
parameter_list|,
name|onlyown
parameter_list|,
name|hflg
parameter_list|)
name|int
name|unit
decl_stmt|;
name|bool
name|onlyown
decl_stmt|,
name|hflg
decl_stmt|;
block|{
comment|/* We have to push down a lot of state here */
comment|/* All this could go into a structure */
name|int
name|oSHIN
init|=
operator|-
literal|1
decl_stmt|,
name|oldintty
init|=
name|intty
decl_stmt|,
name|oinsource
init|=
name|insource
decl_stmt|;
name|struct
name|whyle
modifier|*
name|oldwhyl
init|=
name|whyles
decl_stmt|;
name|Char
modifier|*
name|ogointr
init|=
name|gointr
decl_stmt|,
modifier|*
name|oarginp
init|=
name|arginp
decl_stmt|;
name|Char
modifier|*
name|oevalp
init|=
name|evalp
decl_stmt|,
modifier|*
modifier|*
name|oevalvec
init|=
name|evalvec
decl_stmt|;
name|int
name|oonelflg
init|=
name|onelflg
decl_stmt|;
name|bool
name|oenterhist
init|=
name|enterhist
decl_stmt|;
name|char
name|OHIST
init|=
name|HIST
decl_stmt|;
name|bool
name|otell
init|=
name|cantell
decl_stmt|;
name|struct
name|Bin
name|saveB
decl_stmt|;
specifier|volatile
name|sigset_t
name|omask
decl_stmt|;
name|jmp_buf
name|oldexit
decl_stmt|;
comment|/* The (few) real local variables */
name|int
name|my_reenter
decl_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|didfds
condition|)
name|donefds
argument_list|()
expr_stmt|;
if|if
condition|(
name|onlyown
condition|)
block|{
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|unit
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*      * There is a critical section here while we are pushing down the input      * stream since we have stuff in different structures. If we weren't      * careful an interrupt could corrupt SHIN's Bin structure and kill the      * shell.      *      * We could avoid the critical region by grouping all the stuff in a single      * structure and pointing at it to move it all at once.  This is less      * efficient globally on many variable references however.      */
name|insource
operator|=
literal|1
expr_stmt|;
name|getexit
argument_list|(
name|oldexit
argument_list|)
expr_stmt|;
name|omask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the new values of the state stuff saved above */
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|saveB
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|B
argument_list|,
sizeof|sizeof
argument_list|(
name|B
argument_list|)
argument_list|)
expr_stmt|;
name|fbuf
operator|=
name|NULL
expr_stmt|;
name|fseekp
operator|=
name|feobp
operator|=
name|fblocks
operator|=
literal|0
expr_stmt|;
name|oSHIN
operator|=
name|SHIN
operator|,
name|SHIN
operator|=
name|unit
operator|,
name|arginp
operator|=
literal|0
operator|,
name|onelflg
operator|=
literal|0
expr_stmt|;
name|intty
operator|=
name|isatty
argument_list|(
name|SHIN
argument_list|)
operator|,
name|whyles
operator|=
literal|0
operator|,
name|gointr
operator|=
literal|0
expr_stmt|;
name|evalvec
operator|=
literal|0
expr_stmt|;
name|evalp
operator|=
literal|0
expr_stmt|;
name|enterhist
operator|=
name|hflg
expr_stmt|;
if|if
condition|(
name|enterhist
condition|)
name|HIST
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Now if we are allowing commands to be interrupted, we let ourselves be      * interrupted.      */
if|if
condition|(
name|setintr
condition|)
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|settell
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|my_reenter
operator|=
name|setexit
argument_list|()
operator|)
operator|==
literal|0
condition|)
name|process
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 0 -> blow away on errors */
if|if
condition|(
name|setintr
condition|)
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
name|oSHIN
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* We made it to the new state... free up its storage */
comment|/* This code could get run twice but xfree doesn't care */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fblocks
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|fbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|fbuf
argument_list|)
expr_stmt|;
comment|/* Reset input arena */
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|B
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|saveB
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|B
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|SHIN
argument_list|)
operator|,
name|SHIN
operator|=
name|oSHIN
expr_stmt|;
name|arginp
operator|=
name|oarginp
operator|,
name|onelflg
operator|=
name|oonelflg
expr_stmt|;
name|evalp
operator|=
name|oevalp
operator|,
name|evalvec
operator|=
name|oevalvec
expr_stmt|;
name|intty
operator|=
name|oldintty
operator|,
name|whyles
operator|=
name|oldwhyl
operator|,
name|gointr
operator|=
name|ogointr
expr_stmt|;
if|if
condition|(
name|enterhist
condition|)
name|HIST
operator|=
name|OHIST
expr_stmt|;
name|enterhist
operator|=
name|oenterhist
expr_stmt|;
name|cantell
operator|=
name|otell
expr_stmt|;
block|}
name|resexit
argument_list|(
name|oldexit
argument_list|)
expr_stmt|;
comment|/*      * If process reset() (effectively an unwind) then we must also unwind.      */
if|if
condition|(
name|my_reenter
condition|)
name|stderror
argument_list|(
name|ERR_SILENT
argument_list|)
expr_stmt|;
name|insource
operator|=
name|oinsource
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rechist
parameter_list|()
block|{
name|Char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|hbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|hfile
decl_stmt|;
name|int
name|fp
decl_stmt|,
name|ftmp
decl_stmt|,
name|oldidfds
decl_stmt|;
name|struct
name|varent
modifier|*
name|shist
decl_stmt|;
if|if
condition|(
operator|!
name|fast
condition|)
block|{
comment|/* 	 * If $savehist is just set, we use the value of $history 	 * else we use the value in $savehist 	 */
if|if
condition|(
operator|(
name|shist
operator|=
name|adrof
argument_list|(
name|STRsavehist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|shist
operator|->
name|vec
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|hbuf
argument_list|,
name|shist
operator|->
name|vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|shist
operator|=
name|adrof
argument_list|(
name|STRhistory
argument_list|)
operator|)
operator|&&
name|shist
operator|->
name|vec
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|hbuf
argument_list|,
name|shist
operator|->
name|vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
else|else
return|return;
if|if
condition|(
operator|(
name|hfile
operator|=
name|value
argument_list|(
name|STRhistfile
argument_list|)
operator|)
operator|==
name|STRNULL
condition|)
block|{
name|hfile
operator|=
name|Strcpy
argument_list|(
name|buf
argument_list|,
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strcat
argument_list|(
name|buf
argument_list|,
name|STRsldthist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|creat
argument_list|(
name|short2str
argument_list|(
name|hfile
argument_list|)
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|oldidfds
operator|=
name|didfds
expr_stmt|;
name|didfds
operator|=
literal|0
expr_stmt|;
name|ftmp
operator|=
name|SHOUT
expr_stmt|;
name|SHOUT
operator|=
name|fp
expr_stmt|;
name|dumphist
index|[
literal|2
index|]
operator|=
name|hbuf
expr_stmt|;
name|dohist
argument_list|(
name|dumphist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SHOUT
operator|=
name|ftmp
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|didfds
operator|=
name|oldidfds
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|goodbye
parameter_list|()
block|{
name|rechist
argument_list|()
expr_stmt|;
if|if
condition|(
name|loginsh
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|setintr
operator|=
literal|0
expr_stmt|;
comment|/* No interrupts after "logout" */
if|if
condition|(
operator|!
operator|(
name|adrof
argument_list|(
name|STRlogout
argument_list|)
operator|)
condition|)
name|set
argument_list|(
name|STRlogout
argument_list|,
name|STRnormal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_PATH_DOTLOGOUT
operator|(
name|void
operator|)
name|srcfile
argument_list|(
name|_PATH_DOTLOGOUT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adrof
argument_list|(
name|STRhome
argument_list|)
condition|)
operator|(
name|void
operator|)
name|srccat
argument_list|(
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|STRsldtlogout
argument_list|)
expr_stmt|;
block|}
name|exitstat
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|exitstat
parameter_list|()
block|{
name|Char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|PROF
name|monitor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Note that if STATUS is corrupted (i.e. getn bombs) then error will exit      * directly because we poke child here. Otherwise we might continue      * unwarrantedly (sic).      */
name|child
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|value
argument_list|(
name|STRstatus
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|s
condition|?
name|getn
argument_list|(
name|s
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * in the event of a HUP we want to save the history  */
end_comment

begin_function
specifier|static
name|void
name|phup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|rechist
argument_list|()
expr_stmt|;
comment|/*      * We kill the last foreground process group. It then becomes      * responsible to propagate the SIGHUP to its progeny.      */
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
block|{
name|np
operator|=
name|pp
expr_stmt|;
comment|/* 	     * Find if this job is in the foreground. It could be that 	     * the process leader has exited and the foreground flag 	     * is cleared for it. 	     */
do|do
comment|/* 		 * If a process is in the foreground; we try to kill 		 * it's process group. If we succeed, then the 		 * whole job is gone. Otherwise we keep going... 		 * But avoid sending HUP to the shell again. 		 */
if|if
condition|(
operator|(
name|np
operator|->
name|p_flags
operator|&
name|PFOREGND
operator|)
operator|!=
literal|0
operator|&&
name|np
operator|->
name|p_jobid
operator|!=
name|shpgrp
operator|&&
name|killpg
argument_list|(
name|np
operator|->
name|p_jobid
argument_list|,
name|SIGHUP
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* In case the job was suspended... */
operator|(
name|void
operator|)
name|killpg
argument_list|(
name|np
operator|->
name|p_jobid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
break|break;
block|}
do|while
condition|(
operator|(
name|np
operator|=
name|np
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
block|}
block|}
name|_exit
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|Char
modifier|*
name|jobargv
index|[
literal|2
index|]
init|=
block|{
name|STRjobs
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Catch an interrupt, e.g. during lexical input.  * If we are an interactive shell, we reset the interrupt catch  * immediately.  In any case we drain the shell output,  * and finally go through the normal error mechanism, which  * gets a chance to make the shell go away.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|pintr
parameter_list|(
name|notused
parameter_list|)
name|int
name|notused
decl_stmt|;
block|{
name|pintr1
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pintr1
parameter_list|(
name|wantnl
parameter_list|)
name|bool
name|wantnl
decl_stmt|;
block|{
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|sigset_t
name|omask
decl_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
operator|(
name|sigset_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
block|{
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
operator|&
operator|~
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pjobs
condition|)
block|{
name|pjobs
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|dojobs
argument_list|(
name|jobargv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_INTR
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
operator|&
operator|~
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fpurge
argument_list|(
name|cshout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|endpwent
argument_list|()
expr_stmt|;
comment|/*      * If we have an active "onintr" then we search for the label. Note that if      * one does "onintr -" then we shan't be interruptible so we needn't worry      * about that here.      */
if|if
condition|(
name|gointr
condition|)
block|{
name|gotolab
argument_list|(
name|gointr
argument_list|)
expr_stmt|;
name|timflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|pargv
operator|)
operator|!=
name|NULL
condition|)
name|pargv
operator|=
literal|0
operator|,
name|blkfree
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|gargv
operator|)
operator|!=
name|NULL
condition|)
name|gargv
operator|=
literal|0
operator|,
name|blkfree
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intty
operator|&&
name|wantnl
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\r'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
block|}
name|stderror
argument_list|(
name|ERR_SILENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process is the main driving routine for the shell.  * It runs all command processing, except for those within { ... }  * in expressions (which is run by a routine evalav in sh.exp.c which  * is a stripped down process), and `...` evaluation which is run  * also by a subset of this code in sh.glob.c in the routine backeval.  *  * The code here is a little strange because part of it is interruptible  * and hence freeing of structures appears to occur when none is necessary  * if this is ignored.  *  * Note that if catch is not set then we will unwind on any error.  * If an end-of-file occurs, we return.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|command
modifier|*
name|savet
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|process
parameter_list|(
name|catch
parameter_list|)
name|bool
name|catch
decl_stmt|;
block|{
name|jmp_buf
name|osetexit
decl_stmt|;
name|struct
name|command
modifier|*
name|t
init|=
name|savet
decl_stmt|;
name|savet
operator|=
name|NULL
expr_stmt|;
name|getexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pendjob
argument_list|()
expr_stmt|;
name|paraml
operator|.
name|next
operator|=
name|paraml
operator|.
name|prev
operator|=
operator|&
name|paraml
expr_stmt|;
name|paraml
operator|.
name|word
operator|=
name|STRNULL
expr_stmt|;
operator|(
name|void
operator|)
name|setexit
argument_list|()
expr_stmt|;
name|justpr
operator|=
name|enterhist
expr_stmt|;
comment|/* execute if not entering history */
comment|/* 	 * Interruptible during interactive reads 	 */
if|if
condition|(
name|setintr
condition|)
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
operator|(
name|sigset_t
operator|)
literal|0
argument_list|)
operator|&
operator|~
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * For the sake of reset() 	 */
name|freelex
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
if|if
condition|(
name|savet
condition|)
name|freesyn
argument_list|(
name|savet
argument_list|)
operator|,
name|savet
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|haderr
condition|)
block|{
if|if
condition|(
operator|!
name|catch
condition|)
block|{
comment|/* unwind */
name|doneinp
operator|=
literal|0
expr_stmt|;
name|resexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
name|savet
operator|=
name|t
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
name|haderr
operator|=
literal|0
expr_stmt|;
comment|/* 	     * Every error is eventually caught here or the shell dies.  It is 	     * at this point that we clean up any left-over open files, by 	     * closing all but a fixed number of pre-defined files.  Thus 	     * routines don't have to worry about leaving files open due to 	     * deeper errors... they will get closed here. 	     */
name|closem
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|doneinp
condition|)
block|{
name|doneinp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chkstop
condition|)
name|chkstop
operator|--
expr_stmt|;
if|if
condition|(
name|neednote
condition|)
name|pnote
argument_list|()
expr_stmt|;
if|if
condition|(
name|intty
operator|&&
name|prompt
operator|&&
name|evalvec
operator|==
literal|0
condition|)
block|{
name|mailchk
argument_list|()
expr_stmt|;
comment|/* 	     * If we are at the end of the input buffer then we are going to 	     * read fresh stuff. Otherwise, we are rereading input and don't 	     * need or want to prompt. 	     */
if|if
condition|(
name|aret
operator|==
name|F_SEEK
operator|&&
name|fseekp
operator|==
name|feobp
condition|)
name|printprompt
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|cshout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seterr
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|seterr
argument_list|)
expr_stmt|;
name|seterr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Echo not only on VERBOSE, but also with history expansion. If there 	 * is a lexical error then we forego history echo. 	 */
if|if
condition|(
operator|(
name|lex
argument_list|(
operator|&
name|paraml
argument_list|)
operator|&&
operator|!
name|seterr
operator|&&
name|intty
operator|)
operator|||
name|adrof
argument_list|(
name|STRverbose
argument_list|)
condition|)
block|{
name|prlex
argument_list|(
name|csherr
argument_list|,
operator|&
name|paraml
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The parser may lose space if interrupted. 	 */
if|if
condition|(
name|setintr
condition|)
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Save input text on the history list if reading in old history, or it 	 * is from the terminal at the top level and not in a loop. 	 * 	 * PWP: entry of items in the history list while in a while loop is done 	 * elsewhere... 	 */
if|if
condition|(
name|enterhist
operator|||
operator|(
name|catch
operator|&&
name|intty
operator|&&
operator|!
name|whyles
operator|)
condition|)
name|savehist
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
comment|/* 	 * Print lexical error messages, except when sourcing history lists. 	 */
if|if
condition|(
operator|!
name|enterhist
operator|&&
name|seterr
condition|)
name|stderror
argument_list|(
name|ERR_OLD
argument_list|)
expr_stmt|;
comment|/* 	 * If had a history command :p modifier then this is as far as we 	 * should go 	 */
if|if
condition|(
name|justpr
condition|)
name|reset
argument_list|()
expr_stmt|;
name|alias
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
comment|/* 	 * Parse the words of the input into a parse tree. 	 */
name|savet
operator|=
name|syntax
argument_list|(
name|paraml
operator|.
name|next
argument_list|,
operator|&
name|paraml
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|seterr
condition|)
name|stderror
argument_list|(
name|ERR_OLD
argument_list|)
expr_stmt|;
name|execute
argument_list|(
name|savet
argument_list|,
operator|(
name|tpgrp
operator|>
literal|0
condition|?
name|tpgrp
else|:
operator|-
literal|1
operator|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Made it! 	 */
name|freelex
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
name|freesyn
argument_list|(
operator|(
expr|struct
name|command
operator|*
operator|)
name|savet
argument_list|)
operator|,
name|savet
operator|=
name|NULL
expr_stmt|;
block|}
name|resexit
argument_list|(
name|osetexit
argument_list|)
expr_stmt|;
name|savet
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
name|void
comment|/*ARGSUSED*/
name|dosource
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|Char
modifier|*
name|f
decl_stmt|;
name|bool
name|hflg
init|=
literal|0
decl_stmt|;
name|Char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|v
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|&&
name|eq
argument_list|(
operator|*
name|v
argument_list|,
name|STRmh
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|v
operator|==
name|NULL
condition|)
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_HFLAG
argument_list|)
expr_stmt|;
name|hflg
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|buf
argument_list|,
operator|*
name|v
argument_list|)
expr_stmt|;
name|f
operator|=
name|globone
argument_list|(
name|buf
argument_list|,
name|G_ERROR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|short2str
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|srcfile
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|0
argument_list|,
name|hflg
argument_list|)
operator|&&
operator|!
name|hflg
condition|)
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check for mail.  * If we are a login shell, then we don't want to tell  * about any mail file unless its been modified  * after the time we started.  * This prevents us from telling the user things he already  * knows, since the login program insists on saying  * "You have mail."  */
end_comment

begin_function
specifier|static
name|void
name|mailchk
parameter_list|()
block|{
name|struct
name|varent
modifier|*
name|v
decl_stmt|;
name|Char
modifier|*
modifier|*
name|vp
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|int
name|intvl
decl_stmt|,
name|cnt
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|bool
name|new
decl_stmt|;
name|v
operator|=
name|adrof
argument_list|(
name|STRmail
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|vp
operator|=
name|v
operator|->
name|vec
expr_stmt|;
name|cnt
operator|=
name|blklen
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|intvl
operator|=
operator|(
name|cnt
operator|&&
name|number
argument_list|(
operator|*
name|vp
argument_list|)
operator|)
condition|?
operator|(
operator|--
name|cnt
operator|,
name|getn
argument_list|(
operator|*
name|vp
operator|++
argument_list|)
operator|)
else|:
name|MAILINTVL
expr_stmt|;
if|if
condition|(
name|intvl
operator|<
literal|1
condition|)
name|intvl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|chktim
operator|+
name|intvl
operator|>
name|t
condition|)
return|return;
for|for
control|(
init|;
operator|*
name|vp
condition|;
name|vp
operator|++
control|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|short2str
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|new
operator|=
name|stb
operator|.
name|st_mtime
operator|>
name|time0
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|stb
operator|.
name|st_size
operator|==
literal|0
operator|||
name|stb
operator|.
name|st_atime
operator|>
name|stb
operator|.
name|st_mtime
operator|||
operator|(
name|stb
operator|.
name|st_atime
operator|<
name|chktim
operator|&&
name|stb
operator|.
name|st_mtime
operator|<
name|chktim
operator|)
operator|||
operator|(
name|loginsh
operator|&&
operator|!
name|new
operator|)
condition|)
continue|continue;
if|if
condition|(
name|cnt
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"You have %smail.\n"
argument_list|,
name|new
condition|?
literal|"new "
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"%s in %s.\n"
argument_list|,
name|new
condition|?
literal|"New mail"
else|:
literal|"Mail"
argument_list|,
name|vis_str
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|chktim
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Extract a home directory from the password file  * The argument points to a buffer where the name of the  * user whose home directory is sought is currently.  * We write the home directory of the user back there.  */
end_comment

begin_function
name|int
name|gethdir
parameter_list|(
name|home
parameter_list|)
name|Char
modifier|*
name|home
decl_stmt|;
block|{
name|Char
modifier|*
name|h
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
comment|/*      * Is it us?      */
if|if
condition|(
operator|*
name|home
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|=
name|value
argument_list|(
name|STRhome
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|home
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|short2str
argument_list|(
name|home
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|home
argument_list|,
name|str2short
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * When didfds is set, we do I/O from 0, 1, 2 otherwise from 15, 16, 17  * We also check if the shell has already changed the decriptor to point to  * 0, 1, 2 when didfds is set.  */
end_comment

begin_define
define|#
directive|define
name|DESC
parameter_list|(
name|a
parameter_list|)
value|(*((int *) (a)) - (didfds&& *((int *) a)>= FSHIN ? FSHIN : 0))
end_define

begin_function
specifier|static
name|int
name|readf
parameter_list|(
name|oreo
parameter_list|,
name|buf
parameter_list|,
name|siz
parameter_list|)
name|void
modifier|*
name|oreo
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|siz
decl_stmt|;
block|{
return|return
name|read
argument_list|(
name|DESC
argument_list|(
name|oreo
argument_list|)
argument_list|,
name|buf
argument_list|,
name|siz
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|writef
parameter_list|(
name|oreo
parameter_list|,
name|buf
parameter_list|,
name|siz
parameter_list|)
name|void
modifier|*
name|oreo
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|siz
decl_stmt|;
block|{
return|return
name|write
argument_list|(
name|DESC
argument_list|(
name|oreo
argument_list|)
argument_list|,
name|buf
argument_list|,
name|siz
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|fpos_t
name|seekf
parameter_list|(
name|oreo
parameter_list|,
name|off
parameter_list|,
name|whence
parameter_list|)
name|void
modifier|*
name|oreo
decl_stmt|;
name|fpos_t
name|off
decl_stmt|;
name|int
name|whence
decl_stmt|;
block|{
return|return
name|lseek
argument_list|(
name|DESC
argument_list|(
name|oreo
argument_list|)
argument_list|,
name|off
argument_list|,
name|whence
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|closef
parameter_list|(
name|oreo
parameter_list|)
name|void
modifier|*
name|oreo
decl_stmt|;
block|{
return|return
name|close
argument_list|(
name|DESC
argument_list|(
name|oreo
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print the visible version of a string.  */
end_comment

begin_function
name|int
name|vis_fputc
parameter_list|(
name|ch
parameter_list|,
name|fp
parameter_list|)
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
name|uenc
index|[
literal|5
index|]
decl_stmt|;
comment|/* 4 + NULL */
if|if
condition|(
name|ch
operator|&
name|QUOTE
condition|)
return|return
name|fputc
argument_list|(
name|ch
operator|&
name|TRIM
argument_list|,
name|fp
argument_list|)
return|;
comment|/*      * XXX: When we are in AsciiOnly we want all characters>= 0200 to      * be encoded, but currently there is no way in vis to do that.      */
operator|(
name|void
operator|)
name|vis
argument_list|(
name|uenc
argument_list|,
name|ch
operator|&
name|TRIM
argument_list|,
name|VIS_NOSLASH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fputs
argument_list|(
name|uenc
argument_list|,
name|fp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move the initial descriptors to their eventual  * resting places, closin all other units.  */
end_comment

begin_function
name|void
name|initdesc
parameter_list|()
block|{
name|didfds
operator|=
literal|0
expr_stmt|;
comment|/* 0, 1, 2 aren't set up */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|SHIN
operator|=
name|dcopy
argument_list|(
literal|0
argument_list|,
name|FSHIN
argument_list|)
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|SHOUT
operator|=
name|dcopy
argument_list|(
literal|1
argument_list|,
name|FSHOUT
argument_list|)
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|SHERR
operator|=
name|dcopy
argument_list|(
literal|2
argument_list|,
name|FSHERR
argument_list|)
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|OLDSTD
operator|=
name|dcopy
argument_list|(
name|SHIN
argument_list|,
name|FOLDSTD
argument_list|)
argument_list|,
name|FIOCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|closem
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|PROF
name|done
parameter_list|(
name|i
parameter_list|)
else|#
directive|else
function|xexit
parameter_list|(
name|i
parameter_list|)
endif|#
directive|endif
name|int
name|i
decl_stmt|;
block|{
name|untty
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Char
modifier|*
modifier|*
name|defaultpath
parameter_list|()
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|Char
modifier|*
modifier|*
name|blk
decl_stmt|,
modifier|*
modifier|*
name|blkp
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|blkp
operator|=
name|blk
operator|=
operator|(
name|Char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|Char
operator|*
argument_list|)
operator|*
literal|10
argument_list|)
expr_stmt|;
define|#
directive|define
name|DIRAPPEND
parameter_list|(
name|a
parameter_list|)
define|\
value|if (stat(ptr = a,&stb) == 0&& (stb.st_mode& S_IFMT) == S_IFDIR) \ 		*blkp++ = SAVE(ptr)
name|DIRAPPEND
argument_list|(
name|_PATH_BIN
argument_list|)
expr_stmt|;
name|DIRAPPEND
argument_list|(
name|_PATH_USRBIN
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|DIRAPPEND
if|if
condition|(
name|euid
operator|!=
literal|0
operator|&&
name|uid
operator|!=
literal|0
condition|)
operator|*
name|blkp
operator|++
operator|=
name|Strsave
argument_list|(
name|STRdot
argument_list|)
expr_stmt|;
operator|*
name|blkp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|blk
operator|)
return|;
block|}
end_function

begin_function
name|void
name|printprompt
parameter_list|()
block|{
name|Char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|whyles
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|value
argument_list|(
name|STRprompt
argument_list|)
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
name|HIST
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"%d"
argument_list|,
name|eventno
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
name|HIST
condition|)
name|cp
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|vis_fputc
argument_list|(
operator|*
name|cp
operator||
name|QUOTE
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* 	 * Prompt for forward reading loop body content. 	 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"? "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|cshout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

