begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)sem.c	8.1 (Berkeley) 5/31/93";
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: sem.c,v 1.6 1997/08/07 21:42:15 steve Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"csh.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|vffree
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Char
modifier|*
name|splicepipe
name|__P
argument_list|(
operator|(
expr|struct
name|command
operator|*
name|t
operator|,
name|Char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doio
name|__P
argument_list|(
operator|(
expr|struct
name|command
operator|*
name|t
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chkclob
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|execute
parameter_list|(
name|t
parameter_list|,
name|wanttty
parameter_list|,
name|pipein
parameter_list|,
name|pipeout
parameter_list|)
name|struct
name|command
modifier|*
name|t
decl_stmt|;
name|int
name|wanttty
decl_stmt|,
decl|*
name|pipein
decl_stmt|,
modifier|*
name|pipeout
decl_stmt|;
end_function

begin_block
block|{
name|bool
name|forked
init|=
literal|0
decl_stmt|;
name|struct
name|biltins
modifier|*
name|bifunc
decl_stmt|;
name|int
name|pid
init|=
literal|0
decl_stmt|;
name|int
name|pv
index|[
literal|2
index|]
decl_stmt|;
specifier|static
name|int
name|csigmask
decl_stmt|;
specifier|static
name|int
name|ocsigmask
decl_stmt|;
specifier|static
name|int
name|onosigchld
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|nosigchld
init|=
literal|0
decl_stmt|;
name|UNREGISTER
argument_list|(
name|forked
argument_list|)
expr_stmt|;
name|UNREGISTER
argument_list|(
name|bifunc
argument_list|)
expr_stmt|;
name|UNREGISTER
argument_list|(
name|wanttty
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_AMPERSAND
condition|)
name|wanttty
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|t_dtyp
condition|)
block|{
case|case
name|NODE_COMMAND
case|:
if|if
condition|(
operator|(
name|t
operator|->
name|t_dcom
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|QUOTE
condition|)
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|t
operator|->
name|t_dcom
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|t_dcom
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_REPEAT
operator|)
operator|==
literal|0
condition|)
name|Dfix
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* $ " ' \ */
if|if
condition|(
name|t
operator|->
name|t_dcom
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return;
comment|/* fall into... */
case|case
name|NODE_PAREN
case|:
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_PIPEOUT
condition|)
name|mypipe
argument_list|(
name|pipeout
argument_list|)
expr_stmt|;
comment|/* 	 * Must do<< early so parent will know where input pointer should be. 	 * If noexec then this is all we do. 	 */
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_READ
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|heredoc
argument_list|(
name|t
operator|->
name|t_dlef
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|set
argument_list|(
name|STRstatus
argument_list|,
name|Strsave
argument_list|(
name|STR0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This mess is the necessary kludge to handle the prefix builtins: 	 * nice, nohup, time.  These commands can also be used by themselves, 	 * and this is not handled here. This will also work when loops are 	 * parsed. 	 */
while|while
condition|(
name|t
operator|->
name|t_dtyp
operator|==
name|NODE_COMMAND
condition|)
if|if
condition|(
name|eq
argument_list|(
name|t
operator|->
name|t_dcom
index|[
literal|0
index|]
argument_list|,
name|STRnice
argument_list|)
condition|)
if|if
condition|(
name|t
operator|->
name|t_dcom
index|[
literal|1
index|]
condition|)
if|if
condition|(
name|strchr
argument_list|(
literal|"+-"
argument_list|,
name|t
operator|->
name|t_dcom
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
if|if
condition|(
name|t
operator|->
name|t_dcom
index|[
literal|2
index|]
condition|)
block|{
name|setname
argument_list|(
literal|"nice"
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_nice
operator|=
name|getn
argument_list|(
name|t
operator|->
name|t_dcom
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|lshift
argument_list|(
name|t
operator|->
name|t_dcom
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_dflg
operator||=
name|F_NICE
expr_stmt|;
block|}
else|else
break|break;
else|else
block|{
name|t
operator|->
name|t_nice
operator|=
literal|4
expr_stmt|;
name|lshift
argument_list|(
name|t
operator|->
name|t_dcom
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_dflg
operator||=
name|F_NICE
expr_stmt|;
block|}
else|else
break|break;
elseif|else
if|if
condition|(
name|eq
argument_list|(
name|t
operator|->
name|t_dcom
index|[
literal|0
index|]
argument_list|,
name|STRnohup
argument_list|)
condition|)
if|if
condition|(
name|t
operator|->
name|t_dcom
index|[
literal|1
index|]
condition|)
block|{
name|t
operator|->
name|t_dflg
operator||=
name|F_NOHUP
expr_stmt|;
name|lshift
argument_list|(
name|t
operator|->
name|t_dcom
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
elseif|else
if|if
condition|(
name|eq
argument_list|(
name|t
operator|->
name|t_dcom
index|[
literal|0
index|]
argument_list|,
name|STRtime
argument_list|)
condition|)
if|if
condition|(
name|t
operator|->
name|t_dcom
index|[
literal|1
index|]
condition|)
block|{
name|t
operator|->
name|t_dflg
operator||=
name|F_TIME
expr_stmt|;
name|lshift
argument_list|(
name|t
operator|->
name|t_dcom
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
else|else
break|break;
comment|/* is it a command */
if|if
condition|(
name|t
operator|->
name|t_dtyp
operator|==
name|NODE_COMMAND
condition|)
block|{
comment|/* 	     * Check if we have a builtin function and remember which one. 	     */
name|bifunc
operator|=
name|isbfunc
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
block|{
comment|/* 		 * Continue for builtins that are part of the scripting language 		 */
if|if
condition|(
name|bifunc
operator|->
name|bfunct
operator|!=
name|dobreak
operator|&&
name|bifunc
operator|->
name|bfunct
operator|!=
name|docontin
operator|&&
name|bifunc
operator|->
name|bfunct
operator|!=
name|doelse
operator|&&
name|bifunc
operator|->
name|bfunct
operator|!=
name|doend
operator|&&
name|bifunc
operator|->
name|bfunct
operator|!=
name|doforeach
operator|&&
name|bifunc
operator|->
name|bfunct
operator|!=
name|dogoto
operator|&&
name|bifunc
operator|->
name|bfunct
operator|!=
name|doif
operator|&&
name|bifunc
operator|->
name|bfunct
operator|!=
name|dorepeat
operator|&&
name|bifunc
operator|->
name|bfunct
operator|!=
name|doswbrk
operator|&&
name|bifunc
operator|->
name|bfunct
operator|!=
name|doswitch
operator|&&
name|bifunc
operator|->
name|bfunct
operator|!=
name|dowhile
operator|&&
name|bifunc
operator|->
name|bfunct
operator|!=
name|dozip
condition|)
break|break;
block|}
block|}
else|else
block|{
comment|/* not a command */
name|bifunc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
break|break;
block|}
comment|/* 	 * We fork only if we are timed, or are not the end of a parenthesized 	 * list and not a simple builtin function. Simple meaning one that is 	 * not pipedout, niced, nohupped, or&'d. It would be nice(?) to not 	 * fork in some of these cases. 	 */
comment|/* 	 * Prevent forking cd, pushd, popd, chdir cause this will cause the 	 * shell not to change dir! 	 */
if|if
condition|(
name|bifunc
operator|&&
operator|(
name|bifunc
operator|->
name|bfunct
operator|==
name|dochngd
operator|||
name|bifunc
operator|->
name|bfunct
operator|==
name|dopushd
operator|||
name|bifunc
operator|->
name|bfunct
operator|==
name|dopopd
operator|)
condition|)
name|t
operator|->
name|t_dflg
operator|&=
operator|~
operator|(
name|F_NICE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_TIME
operator|)
operator|||
operator|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_NOFORK
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|bifunc
operator|||
name|t
operator|->
name|t_dflg
operator|&
operator|(
name|F_PIPEOUT
operator||
name|F_AMPERSAND
operator||
name|F_NICE
operator||
name|F_NOHUP
operator|)
operator|)
operator|)
operator|)
operator|||
comment|/* 	 * We have to fork for eval too. 	 */
operator|(
name|bifunc
operator|&&
operator|(
name|t
operator|->
name|t_dflg
operator|&
operator|(
name|F_PIPEIN
operator||
name|F_PIPEOUT
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|bifunc
operator|->
name|bfunct
operator|==
name|doeval
operator|)
condition|)
if|if
condition|(
name|t
operator|->
name|t_dtyp
operator|==
name|NODE_PAREN
operator|||
name|t
operator|->
name|t_dflg
operator|&
operator|(
name|F_REPEAT
operator||
name|F_AMPERSAND
operator|)
operator|||
name|bifunc
condition|)
block|{
name|forked
operator|++
expr_stmt|;
comment|/* 		 * We need to block SIGCHLD here, so that if the process does 		 * not die before we can set the process group 		 */
if|if
condition|(
name|wanttty
operator|>=
literal|0
operator|&&
operator|!
name|nosigchld
condition|)
block|{
name|csigmask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
name|nosigchld
operator|=
literal|1
expr_stmt|;
block|}
name|pid
operator|=
name|pfork
argument_list|(
name|t
argument_list|,
name|wanttty
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
operator|&&
name|nosigchld
condition|)
block|{
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|csigmask
argument_list|)
expr_stmt|;
name|nosigchld
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|!=
literal|0
operator|&&
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_AMPERSAND
operator|)
condition|)
name|backpid
operator|=
name|pid
expr_stmt|;
block|}
else|else
block|{
name|int
name|ochild
decl_stmt|,
name|osetintr
decl_stmt|,
name|ohaderr
decl_stmt|,
name|odidfds
decl_stmt|;
name|int
name|oSHIN
decl_stmt|,
name|oSHOUT
decl_stmt|,
name|oSHERR
decl_stmt|,
name|oOLDSTD
decl_stmt|,
name|otpgrp
decl_stmt|;
name|int
name|omask
decl_stmt|;
comment|/* 		 * Prepare for the vfork by saving everything that the child 		 * corrupts before it exec's. Note that in some signal 		 * implementations which keep the signal info in user space 		 * (e.g. Sun's) it will also be necessary to save and restore 		 * the current sigvec's for the signals the child touches 		 * before it exec's. 		 */
if|if
condition|(
name|wanttty
operator|>=
literal|0
operator|&&
operator|!
name|nosigchld
operator|&&
operator|!
name|noexec
condition|)
block|{
name|csigmask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
name|nosigchld
operator|=
literal|1
expr_stmt|;
block|}
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
argument_list|)
expr_stmt|;
name|ochild
operator|=
name|child
expr_stmt|;
name|osetintr
operator|=
name|setintr
expr_stmt|;
name|ohaderr
operator|=
name|haderr
expr_stmt|;
name|odidfds
operator|=
name|didfds
expr_stmt|;
name|oSHIN
operator|=
name|SHIN
expr_stmt|;
name|oSHOUT
operator|=
name|SHOUT
expr_stmt|;
name|oSHERR
operator|=
name|SHERR
expr_stmt|;
name|oOLDSTD
operator|=
name|OLDSTD
expr_stmt|;
name|otpgrp
operator|=
name|tpgrp
expr_stmt|;
name|ocsigmask
operator|=
name|csigmask
expr_stmt|;
name|onosigchld
operator|=
name|nosigchld
expr_stmt|;
name|Vsav
operator|=
name|Vdp
operator|=
literal|0
expr_stmt|;
name|Vexpath
operator|=
literal|0
expr_stmt|;
name|Vt
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|stderror
argument_list|(
name|ERR_NOPROC
argument_list|)
expr_stmt|;
block|}
name|forked
operator|++
expr_stmt|;
if|if
condition|(
name|pid
condition|)
block|{
comment|/* parent */
name|child
operator|=
name|ochild
expr_stmt|;
name|setintr
operator|=
name|osetintr
expr_stmt|;
name|haderr
operator|=
name|ohaderr
expr_stmt|;
name|didfds
operator|=
name|odidfds
expr_stmt|;
name|SHIN
operator|=
name|oSHIN
expr_stmt|;
name|SHOUT
operator|=
name|oSHOUT
expr_stmt|;
name|SHERR
operator|=
name|oSHERR
expr_stmt|;
name|OLDSTD
operator|=
name|oOLDSTD
expr_stmt|;
name|tpgrp
operator|=
name|otpgrp
expr_stmt|;
name|csigmask
operator|=
name|ocsigmask
expr_stmt|;
name|nosigchld
operator|=
name|onosigchld
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|Vsav
argument_list|)
expr_stmt|;
name|Vsav
operator|=
literal|0
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|Vdp
argument_list|)
expr_stmt|;
name|Vdp
operator|=
literal|0
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|Vexpath
argument_list|)
expr_stmt|;
name|Vexpath
operator|=
literal|0
expr_stmt|;
name|blkfree
argument_list|(
operator|(
name|Char
operator|*
operator|*
operator|)
name|Vt
argument_list|)
expr_stmt|;
name|Vt
operator|=
literal|0
expr_stmt|;
comment|/* this is from pfork() */
name|palloc
argument_list|(
name|pid
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* child */
comment|/* this is from pfork() */
name|int
name|pgrp
decl_stmt|;
name|bool
name|ignint
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nosigchld
condition|)
block|{
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|csigmask
argument_list|)
expr_stmt|;
name|nosigchld
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|setintr
condition|)
name|ignint
operator|=
operator|(
name|tpgrp
operator|==
operator|-
literal|1
operator|&&
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_NOINTERRUPT
operator|)
operator|)
operator|||
operator|(
name|gointr
operator|&&
name|eq
argument_list|(
name|gointr
argument_list|,
name|STRminus
argument_list|)
operator|)
expr_stmt|;
name|pgrp
operator|=
name|pcurrjob
condition|?
name|pcurrjob
operator|->
name|p_jobid
else|:
name|getpid
argument_list|()
expr_stmt|;
name|child
operator|++
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
block|{
name|setintr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ignint
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|vffree
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wanttty
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|parterm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tpgrp
operator|==
operator|-
literal|1
operator|&&
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_NOINTERRUPT
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
name|pgetty
argument_list|(
name|wanttty
argument_list|,
name|pgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_NOHUP
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_NICE
condition|)
operator|(
name|void
operator|)
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|t_nice
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* 	     * It would be better if we could wait for the whole job when we 	     * knew the last process had been started.  Pwait, in fact, does 	     * wait for the whole job anyway, but this test doesn't really 	     * express our intentions. 	     */
if|if
condition|(
name|didfds
operator|==
literal|0
operator|&&
name|t
operator|->
name|t_dflg
operator|&
name|F_PIPEIN
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipein
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipein
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_PIPEOUT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nosigchld
condition|)
block|{
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|csigmask
argument_list|)
expr_stmt|;
name|nosigchld
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_AMPERSAND
operator|)
operator|==
literal|0
condition|)
name|pwait
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
name|doio
argument_list|(
name|t
argument_list|,
name|pipein
argument_list|,
name|pipeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_PIPEOUT
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipeout
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipeout
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Perform a builtin function. If we are not forked, arrange for 	 * possible stopping 	 */
if|if
condition|(
name|bifunc
condition|)
block|{
name|func
argument_list|(
name|t
argument_list|,
name|bifunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|forked
condition|)
name|exitstat
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|t_dtyp
operator|!=
name|NODE_PAREN
condition|)
block|{
name|doexec
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 	 * For () commands must put new 0,1,2 in FSH* and recurse 	 */
name|OLDSTD
operator|=
name|dcopy
argument_list|(
literal|0
argument_list|,
name|FOLDSTD
argument_list|)
expr_stmt|;
name|SHOUT
operator|=
name|dcopy
argument_list|(
literal|1
argument_list|,
name|FSHOUT
argument_list|)
expr_stmt|;
name|SHERR
operator|=
name|dcopy
argument_list|(
literal|2
argument_list|,
name|FSHERR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|SHIN
argument_list|)
expr_stmt|;
name|SHIN
operator|=
operator|-
literal|1
expr_stmt|;
name|didfds
operator|=
literal|0
expr_stmt|;
name|wanttty
operator|=
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|t_dspr
operator|->
name|t_dflg
operator||=
name|t
operator|->
name|t_dflg
operator|&
name|F_NOINTERRUPT
expr_stmt|;
name|execute
argument_list|(
name|t
operator|->
name|t_dspr
argument_list|,
name|wanttty
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exitstat
argument_list|()
expr_stmt|;
case|case
name|NODE_PIPE
case|:
name|t
operator|->
name|t_dcar
operator|->
name|t_dflg
operator||=
name|F_PIPEOUT
operator||
operator|(
name|t
operator|->
name|t_dflg
operator|&
operator|(
name|F_PIPEIN
operator||
name|F_AMPERSAND
operator||
name|F_STDERR
operator||
name|F_NOINTERRUPT
operator|)
operator|)
expr_stmt|;
name|execute
argument_list|(
name|t
operator|->
name|t_dcar
argument_list|,
name|wanttty
argument_list|,
name|pipein
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_dcdr
operator|->
name|t_dflg
operator||=
name|F_PIPEIN
operator||
operator|(
name|t
operator|->
name|t_dflg
operator|&
operator|(
name|F_PIPEOUT
operator||
name|F_AMPERSAND
operator||
name|F_NOFORK
operator||
name|F_NOINTERRUPT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|wanttty
operator|>
literal|0
condition|)
name|wanttty
operator|=
literal|0
expr_stmt|;
comment|/* got tty already */
name|execute
argument_list|(
name|t
operator|->
name|t_dcdr
argument_list|,
name|wanttty
argument_list|,
name|pv
argument_list|,
name|pipeout
argument_list|)
expr_stmt|;
break|break;
case|case
name|NODE_LIST
case|:
if|if
condition|(
name|t
operator|->
name|t_dcar
condition|)
block|{
name|t
operator|->
name|t_dcar
operator|->
name|t_dflg
operator||=
name|t
operator|->
name|t_dflg
operator|&
name|F_NOINTERRUPT
expr_stmt|;
name|execute
argument_list|(
name|t
operator|->
name|t_dcar
argument_list|,
name|wanttty
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	     * In strange case of A&B make a new job after A 	     */
if|if
condition|(
name|t
operator|->
name|t_dcar
operator|->
name|t_dflg
operator|&
name|F_AMPERSAND
operator|&&
name|t
operator|->
name|t_dcdr
operator|&&
operator|(
name|t
operator|->
name|t_dcdr
operator|->
name|t_dflg
operator|&
name|F_AMPERSAND
operator|)
operator|==
literal|0
condition|)
name|pendjob
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|t_dcdr
condition|)
block|{
name|t
operator|->
name|t_dcdr
operator|->
name|t_dflg
operator||=
name|t
operator|->
name|t_dflg
operator|&
operator|(
name|F_NOFORK
operator||
name|F_NOINTERRUPT
operator|)
expr_stmt|;
name|execute
argument_list|(
name|t
operator|->
name|t_dcdr
argument_list|,
name|wanttty
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NODE_OR
case|:
case|case
name|NODE_AND
case|:
if|if
condition|(
name|t
operator|->
name|t_dcar
condition|)
block|{
name|t
operator|->
name|t_dcar
operator|->
name|t_dflg
operator||=
name|t
operator|->
name|t_dflg
operator|&
name|F_NOINTERRUPT
expr_stmt|;
name|execute
argument_list|(
name|t
operator|->
name|t_dcar
argument_list|,
name|wanttty
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|getn
argument_list|(
name|value
argument_list|(
name|STRstatus
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|!=
operator|(
name|t
operator|->
name|t_dtyp
operator|==
name|NODE_AND
operator|)
condition|)
return|return;
block|}
if|if
condition|(
name|t
operator|->
name|t_dcdr
condition|)
block|{
name|t
operator|->
name|t_dcdr
operator|->
name|t_dflg
operator||=
name|t
operator|->
name|t_dflg
operator|&
operator|(
name|F_NOFORK
operator||
name|F_NOINTERRUPT
operator|)
expr_stmt|;
name|execute
argument_list|(
name|t
operator|->
name|t_dcdr
argument_list|,
name|wanttty
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*      * Fall through for all breaks from switch      *      * If there will be no more executions of this command, flush all file      * descriptors. Places that turn on the F_REPEAT bit are responsible for      * doing donefds after the last re-execution      */
if|if
condition|(
name|didfds
operator|&&
operator|!
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_REPEAT
operator|)
condition|)
name|donefds
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|vffree
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|gargv
operator|)
operator|!=
name|NULL
condition|)
block|{
name|gargv
operator|=
literal|0
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|v
operator|=
name|pargv
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pargv
operator|=
literal|0
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
name|_exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Expand and glob the words after an i/o redirection.  * If more than one word is generated, then update the command vector.  *  * This is done differently in all the shells:  * 1. in the bourne shell and ksh globbing is not performed  * 2. Bash/csh say ambiguous  * 3. zsh does i/o to/from all the files  * 4. itcsh concatenates the words.  *  * I don't know what is best to do. I think that Ambiguous is better  * than restructuring the command vector, because the user can get  * unexpected results. In any case, the command vector restructuring  * code is present and the user can choose it by setting noambiguous  */
end_comment

begin_function
specifier|static
name|Char
modifier|*
name|splicepipe
parameter_list|(
name|t
parameter_list|,
name|cp
parameter_list|)
name|struct
name|command
modifier|*
name|t
decl_stmt|;
name|Char
modifier|*
name|cp
decl_stmt|;
comment|/* word after< or> */
block|{
name|Char
modifier|*
name|blk
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|adrof
argument_list|(
name|STRnoambiguous
argument_list|)
condition|)
block|{
name|Char
modifier|*
modifier|*
name|pv
decl_stmt|;
name|blk
index|[
literal|0
index|]
operator|=
name|Dfix1
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* expand $ */
name|blk
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|gflag
operator|=
literal|0
operator|,
name|tglob
argument_list|(
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|gflag
condition|)
block|{
name|pv
operator|=
name|globall
argument_list|(
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
block|{
name|setname
argument_list|(
name|vis_str
argument_list|(
name|blk
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|blk
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_NOMATCH
argument_list|)
expr_stmt|;
block|}
name|gargv
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* we need to fix the command vector */
name|Char
modifier|*
modifier|*
name|av
init|=
name|blkspl
argument_list|(
name|t
operator|->
name|t_dcom
argument_list|,
operator|&
name|pv
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|t
operator|->
name|t_dcom
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_dcom
operator|=
name|av
expr_stmt|;
block|}
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|blk
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|blk
index|[
literal|0
index|]
operator|=
name|pv
index|[
literal|0
index|]
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|pv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|blk
index|[
literal|0
index|]
operator|=
name|globone
argument_list|(
name|blk
index|[
literal|1
index|]
operator|=
name|Dfix1
argument_list|(
name|cp
argument_list|)
argument_list|,
name|G_ERROR
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|blk
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|blk
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform io redirection.  * We may or maynot be forked here.  */
end_comment

begin_function
specifier|static
name|void
name|doio
parameter_list|(
name|t
parameter_list|,
name|pipein
parameter_list|,
name|pipeout
parameter_list|)
name|struct
name|command
modifier|*
name|t
decl_stmt|;
name|int
modifier|*
name|pipein
decl_stmt|,
decl|*
name|pipeout
decl_stmt|;
end_function

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|Char
modifier|*
name|cp
decl_stmt|;
name|int
name|flags
init|=
name|t
operator|->
name|t_dflg
decl_stmt|;
if|if
condition|(
name|didfds
operator|||
operator|(
name|flags
operator|&
name|F_REPEAT
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_READ
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* F_READ already done */
if|if
condition|(
name|t
operator|->
name|t_dlef
condition|)
block|{
name|char
name|tmp
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	     * so< /dev/std{in,out,err} work 	     */
operator|(
name|void
operator|)
name|dcopy
argument_list|(
name|SHIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dcopy
argument_list|(
name|SHOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dcopy
argument_list|(
name|SHERR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cp
operator|=
name|splicepipe
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|t_dlef
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|tmp
argument_list|,
name|short2str
argument_list|(
name|cp
argument_list|)
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|tmp
index|[
name|MAXPATHLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|tmp
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|tmp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmove
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_PIPEIN
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|pipein
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipein
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipein
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|F_NOINTERRUPT
operator|)
operator|&&
name|tpgrp
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
name|_PATH_DEVNULL
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|OLDSTD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|t_drit
condition|)
block|{
name|char
name|tmp
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|cp
operator|=
name|splicepipe
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|t_drit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|tmp
argument_list|,
name|short2str
argument_list|(
name|cp
argument_list|)
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|tmp
index|[
name|MAXPATHLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 * so> /dev/std{out,err} work 	 */
operator|(
name|void
operator|)
name|dcopy
argument_list|(
name|SHOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dcopy
argument_list|(
name|SHERR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_APPEND
operator|)
operator|&&
ifdef|#
directive|ifdef
name|O_APPEND
operator|(
name|fd
operator|=
name|open
argument_list|(
name|tmp
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|>=
literal|0
condition|)
empty_stmt|;
else|#
directive|else
operator|(
name|fd
operator|=
name|open
argument_list|(
name|tmp
argument_list|,
name|O_WRONLY
argument_list|)
operator|)
operator|>=
literal|0
block|)
operator|(
name|void
operator|)
name|lseek
argument_list|(
literal|1
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|L_XTND
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|F_OVERWRITE
operator|)
operator|&&
name|adrof
argument_list|(
name|STRnoclobber
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|F_APPEND
condition|)
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|tmp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|chkclob
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|tmp
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|stderror
argument_list|(
name|ERR_SYSTEM
argument_list|,
name|tmp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dmove
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_elseif
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_PIPEOUT
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|pipeout
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_elseif

begin_else
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|SHOUT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|1
argument_list|,
name|FIONCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
operator|(
name|void
operator|)
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|flags
operator|&
name|F_STDERR
condition|)
block|{
operator|(
name|void
operator|)
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|dup
argument_list|(
name|SHERR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|2
argument_list|,
name|FIONCLEX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|didfds
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_macro
unit|}  void
name|mypipe
argument_list|(
argument|pv
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|pv
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pv
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|oops
goto|;
name|pv
index|[
literal|0
index|]
operator|=
name|dmove
argument_list|(
name|pv
index|[
literal|0
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pv
index|[
literal|1
index|]
operator|=
name|dmove
argument_list|(
name|pv
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
name|pv
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
return|return;
name|oops
label|:
name|stderror
argument_list|(
name|ERR_PIPE
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|chkclob
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|S_ISCHR
argument_list|(
name|stb
operator|.
name|st_mode
argument_list|)
condition|)
return|return;
name|stderror
argument_list|(
name|ERR_EXISTS
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

