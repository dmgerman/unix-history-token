begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: proc.c,v 1.2.8.2 1998/01/31 17:06:15 joerg Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)proc.c	8.1 (Berkeley) 5/31/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"csh.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_define
define|#
directive|define
name|BIGINDEX
value|9
end_define

begin_comment
comment|/* largest desirable job index */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rusage
name|zru
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pflushall
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pflush
name|__P
argument_list|(
operator|(
expr|struct
name|process
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pclrcurr
name|__P
argument_list|(
operator|(
expr|struct
name|process
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|padd
name|__P
argument_list|(
operator|(
expr|struct
name|command
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pprint
name|__P
argument_list|(
operator|(
expr|struct
name|process
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ptprint
name|__P
argument_list|(
operator|(
expr|struct
name|process
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pads
name|__P
argument_list|(
operator|(
name|Char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pkill
name|__P
argument_list|(
operator|(
name|Char
operator|*
operator|*
name|v
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|process
modifier|*
name|pgetcurr
name|__P
argument_list|(
operator|(
expr|struct
name|process
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|okpcntl
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * pchild - called at interrupt level by the SIGCHLD signal  *	indicating that at least one child has terminated or stopped  *	thus at least one wait system call will definitely return a  *	childs status.  Top level routines (like pwait) must be sure  *	to mask interrupts when playing with the proclist data structures!  */
end_comment

begin_comment
comment|/* ARGUSED */
end_comment

begin_function
name|void
name|pchild
parameter_list|(
name|notused
parameter_list|)
name|int
name|notused
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|struct
name|process
modifier|*
name|fp
decl_stmt|;
name|int
name|pid
decl_stmt|;
specifier|extern
name|int
name|insource
decl_stmt|;
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|union
name|wait
name|w
decl_stmt|;
name|int
name|jobflags
decl_stmt|;
name|struct
name|rusage
name|ru
decl_stmt|;
name|loop
label|:
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* reset, just in case */
name|pid
operator|=
name|wait3
argument_list|(
operator|&
name|w
operator|.
name|w_status
argument_list|,
operator|(
name|setintr
operator|&&
operator|(
name|intty
operator|||
name|insource
operator|)
condition|?
name|WNOHANG
operator||
name|WUNTRACED
else|:
name|WNOHANG
operator|)
argument_list|,
operator|&
name|ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|pnoprocesses
operator|=
name|pid
operator|==
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pid
operator|==
name|pp
operator|->
name|p_pid
condition|)
goto|goto
name|found
goto|;
goto|goto
name|loop
goto|;
name|found
label|:
if|if
condition|(
name|pid
operator|==
name|atoi
argument_list|(
name|short2str
argument_list|(
name|value
argument_list|(
name|STRchild
argument_list|)
argument_list|)
argument_list|)
condition|)
name|unsetv
argument_list|(
name|STRchild
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_flags
operator|&=
operator|~
operator|(
name|PRUNNING
operator||
name|PSTOPPED
operator||
name|PREPORTED
operator|)
expr_stmt|;
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|pp
operator|->
name|p_flags
operator||=
name|PSTOPPED
expr_stmt|;
name|pp
operator|->
name|p_reason
operator|=
name|w
operator|.
name|w_stopsig
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
operator|(
name|PTIME
operator||
name|PPTIME
operator|)
operator|||
name|adrof
argument_list|(
name|STRtime
argument_list|)
condition|)
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|pp
operator|->
name|p_etime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_rusage
operator|=
name|ru
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|w
argument_list|)
condition|)
block|{
if|if
condition|(
name|w
operator|.
name|w_termsig
operator|==
name|SIGINT
condition|)
name|pp
operator|->
name|p_flags
operator||=
name|PINTERRUPTED
expr_stmt|;
else|else
name|pp
operator|->
name|p_flags
operator||=
name|PSIGNALED
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|w_coredump
condition|)
name|pp
operator|->
name|p_flags
operator||=
name|PDUMPED
expr_stmt|;
name|pp
operator|->
name|p_reason
operator|=
name|w
operator|.
name|w_termsig
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|p_reason
operator|=
name|w
operator|.
name|w_retcode
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_reason
operator|!=
literal|0
condition|)
name|pp
operator|->
name|p_flags
operator||=
name|PAEXITED
expr_stmt|;
else|else
name|pp
operator|->
name|p_flags
operator||=
name|PNEXITED
expr_stmt|;
block|}
block|}
name|jobflags
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|pp
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|p_flags
operator|&
operator|(
name|PPTIME
operator||
name|PRUNNING
operator||
name|PSTOPPED
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|child
operator|&&
name|adrof
argument_list|(
name|STRtime
argument_list|)
operator|&&
name|fp
operator|->
name|p_rusage
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|+
name|fp
operator|->
name|p_rusage
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|>=
name|atoi
argument_list|(
name|short2str
argument_list|(
name|value
argument_list|(
name|STRtime
argument_list|)
argument_list|)
argument_list|)
condition|)
name|fp
operator|->
name|p_flags
operator||=
name|PTIME
expr_stmt|;
name|jobflags
operator||=
name|fp
operator|->
name|p_flags
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|fp
operator|=
name|fp
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
name|pp
operator|->
name|p_flags
operator|&=
operator|~
name|PFOREGND
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|pp
operator|->
name|p_friends
operator|&&
operator|(
name|pp
operator|->
name|p_flags
operator|&
name|PPTIME
operator|)
condition|)
block|{
name|pp
operator|->
name|p_flags
operator|&=
operator|~
name|PPTIME
expr_stmt|;
name|pp
operator|->
name|p_flags
operator||=
name|PTIME
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|jobflags
operator|&
operator|(
name|PRUNNING
operator||
name|PREPORTED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|=
name|pp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fp
operator|->
name|p_flags
operator|&
name|PSTOPPED
condition|)
name|fp
operator|->
name|p_flags
operator||=
name|PREPORTED
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|fp
operator|=
name|fp
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
while|while
condition|(
name|fp
operator|->
name|p_pid
operator|!=
name|fp
operator|->
name|p_jobid
condition|)
name|fp
operator|=
name|fp
operator|->
name|p_friends
expr_stmt|;
if|if
condition|(
name|jobflags
operator|&
name|PSTOPPED
condition|)
block|{
if|if
condition|(
name|pcurrent
operator|&&
name|pcurrent
operator|!=
name|fp
condition|)
name|pprevious
operator|=
name|pcurrent
expr_stmt|;
name|pcurrent
operator|=
name|fp
expr_stmt|;
block|}
else|else
name|pclrcurr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobflags
operator|&
name|PFOREGND
condition|)
block|{
if|if
condition|(
name|jobflags
operator|&
operator|(
name|PSIGNALED
operator||
name|PSTOPPED
operator||
name|PPTIME
operator|)
operator|||
ifdef|#
directive|ifdef
name|IIASA
name|jobflags
operator|&
name|PAEXITED
operator|||
endif|#
directive|endif
operator|!
name|eq
argument_list|(
name|dcwd
operator|->
name|di_name
argument_list|,
name|fp
operator|->
name|p_cwd
operator|->
name|di_name
argument_list|)
condition|)
block|{
empty_stmt|;
comment|/* print in pjwait */
block|}
comment|/* PWP: print a newline after ^C */
elseif|else
if|if
condition|(
name|jobflags
operator|&
name|PINTERRUPTED
condition|)
block|{
operator|(
name|void
operator|)
name|vis_fputc
argument_list|(
literal|'\r'
operator||
name|QUOTE
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|jobflags
operator|&
name|PNOTIFY
operator|||
name|adrof
argument_list|(
name|STRnotify
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|vis_fputc
argument_list|(
literal|'\r'
operator||
name|QUOTE
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pprint
argument_list|(
name|pp
argument_list|,
name|NUMBER
operator||
name|NAME
operator||
name|REASON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|jobflags
operator|&
name|PSTOPPED
operator|)
operator|==
literal|0
condition|)
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|p_flags
operator||=
name|PNEEDNOTE
expr_stmt|;
name|neednote
operator|++
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|loop
goto|;
block|}
end_function

begin_function
name|void
name|pnote
parameter_list|()
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|omask
decl_stmt|;
name|neednote
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
name|PNEEDNOTE
condition|)
block|{
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_flags
operator|&=
operator|~
name|PNEEDNOTE
expr_stmt|;
name|flags
operator|=
name|pprint
argument_list|(
name|pp
argument_list|,
name|NUMBER
operator||
name|NAME
operator||
name|REASON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|PRUNNING
operator||
name|PSTOPPED
operator|)
operator|)
operator|==
literal|0
condition|)
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * pwait - wait for current job to terminate, maintaining integrity  *	of current and previous job indicators.  */
end_comment

begin_function
name|void
name|pwait
parameter_list|()
block|{
name|struct
name|process
modifier|*
name|fp
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|int
name|omask
decl_stmt|;
comment|/*      * Here's where dead procs get flushed.      */
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|(
name|fp
operator|=
operator|&
name|proclist
operator|)
operator|->
name|p_next
init|;
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|(
name|fp
operator|=
name|pp
operator|)
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_pid
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|p_next
operator|=
name|pp
operator|->
name|p_next
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|pp
operator|->
name|p_command
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_cwd
operator|&&
operator|--
name|pp
operator|->
name|p_cwd
operator|->
name|di_count
operator|==
literal|0
condition|)
if|if
condition|(
name|pp
operator|->
name|p_cwd
operator|->
name|di_next
operator|==
literal|0
condition|)
name|dfree
argument_list|(
name|pp
operator|->
name|p_cwd
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|ptr_t
operator|)
name|pp
argument_list|)
expr_stmt|;
name|pp
operator|=
name|fp
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|pjwait
argument_list|(
name|pcurrjob
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pjwait - wait for a job to finish or become stopped  *	It is assumed to be in the foreground state (PFOREGND)  */
end_comment

begin_function
name|void
name|pjwait
parameter_list|(
name|pp
parameter_list|)
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|fp
decl_stmt|;
name|int
name|jobflags
decl_stmt|,
name|reason
decl_stmt|;
name|int
name|omask
decl_stmt|;
while|while
condition|(
name|pp
operator|->
name|p_pid
operator|!=
name|pp
operator|->
name|p_jobid
condition|)
name|pp
operator|=
name|pp
operator|->
name|p_friends
expr_stmt|;
name|fp
operator|=
name|pp
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|p_flags
operator|&
operator|(
name|PFOREGND
operator||
name|PRUNNING
operator|)
operator|)
operator|==
name|PRUNNING
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csherr
argument_list|,
literal|"BUG: waiting for background job!\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|fp
operator|=
name|fp
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
comment|/*      * Now keep pausing as long as we are not interrupted (SIGINT), and the      * target process, or any of its friends, are running      */
name|fp
operator|=
name|pp
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
name|jobflags
operator|=
literal|0
expr_stmt|;
do|do
name|jobflags
operator||=
name|fp
operator|->
name|p_flags
expr_stmt|;
do|while
condition|(
operator|(
name|fp
operator|=
operator|(
name|fp
operator|->
name|p_friends
operator|)
operator|)
operator|!=
name|pp
condition|)
do|;
if|if
condition|(
operator|(
name|jobflags
operator|&
name|PRUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|JOBDEBUG
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csherr
argument_list|,
literal|"starting to sigpause for  SIGCHLD on %d\n"
argument_list|,
name|fp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JOBDEBUG */
operator|(
name|void
operator|)
name|sigpause
argument_list|(
name|omask
operator|&
operator|~
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpgrp
operator|>
literal|0
condition|)
comment|/* get tty back */
operator|(
name|void
operator|)
name|tcsetpgrp
argument_list|(
name|FSHTTY
argument_list|,
name|tpgrp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|jobflags
operator|&
operator|(
name|PSIGNALED
operator||
name|PSTOPPED
operator||
name|PTIME
operator|)
operator|)
operator|||
operator|!
name|eq
argument_list|(
name|dcwd
operator|->
name|di_name
argument_list|,
name|fp
operator|->
name|p_cwd
operator|->
name|di_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|jobflags
operator|&
name|PSTOPPED
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
if|if
condition|(
name|adrof
argument_list|(
name|STRlistjobs
argument_list|)
condition|)
block|{
name|Char
modifier|*
name|jobcommand
index|[
literal|3
index|]
decl_stmt|;
name|jobcommand
index|[
literal|0
index|]
operator|=
name|STRjobs
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
name|value
argument_list|(
name|STRlistjobs
argument_list|)
argument_list|,
name|STRlong
argument_list|)
condition|)
name|jobcommand
index|[
literal|1
index|]
operator|=
name|STRml
expr_stmt|;
else|else
name|jobcommand
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|jobcommand
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|dojobs
argument_list|(
name|jobcommand
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pprint
argument_list|(
name|pp
argument_list|,
name|SHELLDIR
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|pprint
argument_list|(
name|pp
argument_list|,
name|AREASON
operator||
name|SHELLDIR
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|pprint
argument_list|(
name|pp
argument_list|,
name|AREASON
operator||
name|SHELLDIR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|jobflags
operator|&
operator|(
name|PINTERRUPTED
operator||
name|PSTOPPED
operator|)
operator|)
operator|&&
name|setintr
operator|&&
operator|(
operator|!
name|gointr
operator|||
operator|!
name|eq
argument_list|(
name|gointr
argument_list|,
name|STRminus
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|jobflags
operator|&
name|PSTOPPED
operator|)
operator|==
literal|0
condition|)
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pintr1
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|reason
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|pp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fp
operator|->
name|p_reason
condition|)
name|reason
operator|=
name|fp
operator|->
name|p_flags
operator|&
operator|(
name|PSIGNALED
operator||
name|PINTERRUPTED
operator|)
condition|?
name|fp
operator|->
name|p_reason
operator||
name|META
else|:
name|fp
operator|->
name|p_reason
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|fp
operator|=
name|fp
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
if|if
condition|(
operator|(
name|reason
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|adrof
argument_list|(
name|STRprintexitvalue
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"Exit %d\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
name|set
argument_list|(
name|STRstatus
argument_list|,
name|putn
argument_list|(
name|reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|&&
name|exiterr
condition|)
name|exitstat
argument_list|()
expr_stmt|;
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dowait - wait for all processes to finish  */
end_comment

begin_function
name|void
comment|/*ARGSUSED*/
name|dowait
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|int
name|omask
decl_stmt|;
name|pjobs
operator|++
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
name|loop
label|:
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_pid
operator|&&
comment|/* pp->p_pid == pp->p_jobid&& */
name|pp
operator|->
name|p_flags
operator|&
name|PRUNNING
condition|)
block|{
operator|(
name|void
operator|)
name|sigpause
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|pjobs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pflushall - flush all jobs from list (e.g. at fork())  */
end_comment

begin_function
specifier|static
name|void
name|pflushall
parameter_list|()
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_pid
condition|)
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pflush - flag all process structures in the same job as the  *	the argument process for deletion.  The actual free of the  *	space is not done here since pflush is called at interrupt level.  */
end_comment

begin_function
specifier|static
name|void
name|pflush
parameter_list|(
name|pp
parameter_list|)
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|np
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_pid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csherr
argument_list|,
literal|"BUG: process flushed twice"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|pp
operator|->
name|p_pid
operator|!=
name|pp
operator|->
name|p_jobid
condition|)
name|pp
operator|=
name|pp
operator|->
name|p_friends
expr_stmt|;
name|pclrcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|pcurrjob
condition|)
name|pcurrjob
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
name|pp
operator|->
name|p_index
expr_stmt|;
name|np
operator|=
name|pp
expr_stmt|;
do|do
block|{
name|np
operator|->
name|p_index
operator|=
name|np
operator|->
name|p_pid
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|p_flags
operator|&=
operator|~
name|PNEEDNOTE
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|np
operator|=
name|np
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
if|if
condition|(
name|idx
operator|==
name|pmaxindex
condition|)
block|{
for|for
control|(
name|np
operator|=
name|proclist
operator|.
name|p_next
operator|,
name|idx
operator|=
literal|0
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|p_next
control|)
if|if
condition|(
name|np
operator|->
name|p_index
operator|>
name|idx
condition|)
name|idx
operator|=
name|np
operator|->
name|p_index
expr_stmt|;
name|pmaxindex
operator|=
name|idx
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * pclrcurr - make sure the given job is not the current or previous job;  *	pp MUST be the job leader  */
end_comment

begin_function
specifier|static
name|void
name|pclrcurr
parameter_list|(
name|pp
parameter_list|)
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
block|{
if|if
condition|(
name|pp
operator|==
name|pcurrent
condition|)
if|if
condition|(
name|pprevious
operator|!=
name|NULL
condition|)
block|{
name|pcurrent
operator|=
name|pprevious
expr_stmt|;
name|pprevious
operator|=
name|pgetcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcurrent
operator|=
name|pgetcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pprevious
operator|=
name|pgetcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pp
operator|==
name|pprevious
condition|)
name|pprevious
operator|=
name|pgetcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* +4 here is 1 for '\0', 1 ea for<<>&>> */
end_comment

begin_decl_stmt
specifier|static
name|Char
name|command
index|[
name|PMAXLEN
operator|+
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmdlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Char
modifier|*
name|cmdp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * palloc - allocate a process structure and fill it up.  *	an important assumption is made that the process is running.  */
end_comment

begin_function
name|void
name|palloc
parameter_list|(
name|pid
parameter_list|,
name|t
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp
operator|=
operator|(
expr|struct
name|process
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|process
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_pid
operator|=
name|pid
expr_stmt|;
name|pp
operator|->
name|p_flags
operator|=
name|t
operator|->
name|t_dflg
operator|&
name|F_AMPERSAND
condition|?
name|PRUNNING
else|:
name|PRUNNING
operator||
name|PFOREGND
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_TIME
condition|)
name|pp
operator|->
name|p_flags
operator||=
name|PPTIME
expr_stmt|;
name|cmdp
operator|=
name|command
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
name|padd
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|cmdp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_PIPEOUT
condition|)
block|{
name|pp
operator|->
name|p_flags
operator||=
name|PPOU
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_STDERR
condition|)
name|pp
operator|->
name|p_flags
operator||=
name|PERR
expr_stmt|;
block|}
name|pp
operator|->
name|p_command
operator|=
name|Strsave
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcurrjob
condition|)
block|{
name|struct
name|process
modifier|*
name|fp
decl_stmt|;
comment|/* careful here with interrupt level */
name|pp
operator|->
name|p_cwd
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|p_index
operator|=
name|pcurrjob
operator|->
name|p_index
expr_stmt|;
name|pp
operator|->
name|p_friends
operator|=
name|pcurrjob
expr_stmt|;
name|pp
operator|->
name|p_jobid
operator|=
name|pcurrjob
operator|->
name|p_pid
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|pcurrjob
init|;
name|fp
operator|->
name|p_friends
operator|!=
name|pcurrjob
condition|;
name|fp
operator|=
name|fp
operator|->
name|p_friends
control|)
continue|continue;
name|fp
operator|->
name|p_friends
operator|=
name|pp
expr_stmt|;
block|}
else|else
block|{
name|pcurrjob
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|p_jobid
operator|=
name|pid
expr_stmt|;
name|pp
operator|->
name|p_friends
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|p_cwd
operator|=
name|dcwd
expr_stmt|;
name|dcwd
operator|->
name|di_count
operator|++
expr_stmt|;
if|if
condition|(
name|pmaxindex
operator|<
name|BIGINDEX
condition|)
name|pp
operator|->
name|p_index
operator|=
operator|++
name|pmaxindex
expr_stmt|;
else|else
block|{
name|struct
name|process
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|np
operator|=
name|proclist
operator|.
name|p_next
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|p_next
control|)
if|if
condition|(
name|np
operator|->
name|p_index
operator|==
name|i
condition|)
goto|goto
name|tryagain
goto|;
name|pp
operator|->
name|p_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|pmaxindex
condition|)
name|pmaxindex
operator|=
name|i
expr_stmt|;
break|break;
name|tryagain
label|:
empty_stmt|;
block|}
block|}
if|if
condition|(
name|pcurrent
operator|==
name|NULL
condition|)
name|pcurrent
operator|=
name|pp
expr_stmt|;
elseif|else
if|if
condition|(
name|pprevious
operator|==
name|NULL
condition|)
name|pprevious
operator|=
name|pp
expr_stmt|;
block|}
name|pp
operator|->
name|p_next
operator|=
name|proclist
operator|.
name|p_next
expr_stmt|;
name|proclist
operator|.
name|p_next
operator|=
name|pp
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|pp
operator|->
name|p_btime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|padd
parameter_list|(
name|t
parameter_list|)
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|Char
modifier|*
modifier|*
name|argp
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|t
operator|->
name|t_dtyp
condition|)
block|{
case|case
name|NODE_PAREN
case|:
name|pads
argument_list|(
name|STRLparensp
argument_list|)
expr_stmt|;
name|padd
argument_list|(
name|t
operator|->
name|t_dspr
argument_list|)
expr_stmt|;
name|pads
argument_list|(
name|STRspRparen
argument_list|)
expr_stmt|;
break|break;
case|case
name|NODE_COMMAND
case|:
for|for
control|(
name|argp
operator|=
name|t
operator|->
name|t_dcom
init|;
operator|*
name|argp
condition|;
name|argp
operator|++
control|)
block|{
name|pads
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argp
index|[
literal|1
index|]
condition|)
name|pads
argument_list|(
name|STRspace
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NODE_OR
case|:
case|case
name|NODE_AND
case|:
case|case
name|NODE_PIPE
case|:
case|case
name|NODE_LIST
case|:
name|padd
argument_list|(
name|t
operator|->
name|t_dcar
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|t_dtyp
condition|)
block|{
case|case
name|NODE_OR
case|:
name|pads
argument_list|(
name|STRspor2sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NODE_AND
case|:
name|pads
argument_list|(
name|STRspand2sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NODE_PIPE
case|:
name|pads
argument_list|(
name|STRsporsp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NODE_LIST
case|:
name|pads
argument_list|(
name|STRsemisp
argument_list|)
expr_stmt|;
break|break;
block|}
name|padd
argument_list|(
name|t
operator|->
name|t_dcdr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_PIPEIN
operator|)
operator|==
literal|0
operator|&&
name|t
operator|->
name|t_dlef
condition|)
block|{
name|pads
argument_list|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_READ
operator|)
condition|?
name|STRspLarrow2sp
else|:
name|STRspLarrowsp
argument_list|)
expr_stmt|;
name|pads
argument_list|(
name|t
operator|->
name|t_dlef
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_PIPEOUT
operator|)
operator|==
literal|0
operator|&&
name|t
operator|->
name|t_drit
condition|)
block|{
name|pads
argument_list|(
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_APPEND
operator|)
condition|?
name|STRspRarrow2
else|:
name|STRspRarrow
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_STDERR
condition|)
name|pads
argument_list|(
name|STRand
argument_list|)
expr_stmt|;
name|pads
argument_list|(
name|STRspace
argument_list|)
expr_stmt|;
name|pads
argument_list|(
name|t
operator|->
name|t_drit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pads
parameter_list|(
name|cp
parameter_list|)
name|Char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/*      * Avoid the Quoted Space alias hack! Reported by:      * sam@john-bigboote.ICS.UCI.EDU (Sam Horrocks)      */
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
name|STRQNULL
index|[
literal|0
index|]
condition|)
name|cp
operator|++
expr_stmt|;
name|i
operator|=
name|Strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdlen
operator|>=
name|PMAXLEN
condition|)
return|return;
if|if
condition|(
name|cmdlen
operator|+
name|i
operator|>=
name|PMAXLEN
condition|)
block|{
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|cmdp
argument_list|,
name|STRsp3dots
argument_list|)
expr_stmt|;
name|cmdlen
operator|=
name|PMAXLEN
expr_stmt|;
name|cmdp
operator|+=
literal|4
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|Strcpy
argument_list|(
name|cmdp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cmdp
operator|+=
name|i
expr_stmt|;
name|cmdlen
operator|+=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * psavejob - temporarily save the current job on a one level stack  *	so another job can be created.  Used for { } in exp6  *	and `` in globbing.  */
end_comment

begin_function
name|void
name|psavejob
parameter_list|()
block|{
name|pholdjob
operator|=
name|pcurrjob
expr_stmt|;
name|pcurrjob
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * prestjob - opposite of psavejob.  This may be missed if we are interrupted  *	somewhere, but pendjob cleans up anyway.  */
end_comment

begin_function
name|void
name|prestjob
parameter_list|()
block|{
name|pcurrjob
operator|=
name|pholdjob
expr_stmt|;
name|pholdjob
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pendjob - indicate that a job (set of commands) has been completed  *	or is about to begin.  */
end_comment

begin_function
name|void
name|pendjob
parameter_list|()
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|pcurrjob
operator|&&
operator|(
name|pcurrjob
operator|->
name|p_flags
operator|&
operator|(
name|PFOREGND
operator||
name|PSTOPPED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pp
operator|=
name|pcurrjob
expr_stmt|;
while|while
condition|(
name|pp
operator|->
name|p_pid
operator|!=
name|pp
operator|->
name|p_jobid
condition|)
name|pp
operator|=
name|pp
operator|->
name|p_friends
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"[%d]"
argument_list|,
name|pp
operator|->
name|p_index
argument_list|)
expr_stmt|;
name|tp
operator|=
name|pp
expr_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|" %d"
argument_list|,
name|pp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|pp
operator|=
name|pp
operator|->
name|p_friends
expr_stmt|;
block|}
do|while
condition|(
name|pp
operator|!=
name|tp
condition|)
do|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
block|}
name|pholdjob
operator|=
name|pcurrjob
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pprint - print a job  */
end_comment

begin_function
specifier|static
name|int
name|pprint
parameter_list|(
name|pp
parameter_list|,
name|flag
parameter_list|)
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|bool
name|flag
decl_stmt|;
block|{
name|int
name|status
decl_stmt|,
name|reason
decl_stmt|;
name|struct
name|process
modifier|*
name|tp
decl_stmt|;
name|int
name|jobflags
decl_stmt|,
name|pstatus
decl_stmt|;
name|bool
name|hadnl
init|=
literal|1
decl_stmt|;
comment|/* did we just have a newline */
name|char
modifier|*
name|format
decl_stmt|;
operator|(
name|void
operator|)
name|fpurge
argument_list|(
name|cshout
argument_list|)
expr_stmt|;
while|while
condition|(
name|pp
operator|->
name|p_pid
operator|!=
name|pp
operator|->
name|p_jobid
condition|)
name|pp
operator|=
name|pp
operator|->
name|p_friends
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|pp
operator|->
name|p_friends
operator|&&
operator|(
name|pp
operator|->
name|p_flags
operator|&
name|PPTIME
operator|)
condition|)
block|{
name|pp
operator|->
name|p_flags
operator|&=
operator|~
name|PPTIME
expr_stmt|;
name|pp
operator|->
name|p_flags
operator||=
name|PTIME
expr_stmt|;
block|}
name|tp
operator|=
name|pp
expr_stmt|;
name|status
operator|=
name|reason
operator|=
operator|-
literal|1
expr_stmt|;
name|jobflags
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|jobflags
operator||=
name|pp
operator|->
name|p_flags
expr_stmt|;
name|pstatus
operator|=
name|pp
operator|->
name|p_flags
operator|&
name|PALLSTATES
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|pp
operator|&&
operator|!
name|hadnl
operator|&&
operator|!
operator|(
name|flag
operator|&
name|FANCY
operator|)
operator|&&
operator|(
operator|(
name|pstatus
operator|==
name|status
operator|&&
name|pp
operator|->
name|p_reason
operator|==
name|reason
operator|)
operator|||
operator|!
operator|(
name|flag
operator|&
name|REASON
operator|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tp
operator|!=
name|pp
operator|&&
operator|!
name|hadnl
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
name|NUMBER
condition|)
block|{
if|if
condition|(
name|pp
operator|==
name|tp
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"[%d]%s %c "
argument_list|,
name|pp
operator|->
name|p_index
argument_list|,
name|pp
operator|->
name|p_index
operator|<
literal|10
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|pp
operator|==
name|pcurrent
condition|?
literal|'+'
else|:
operator|(
name|pp
operator|==
name|pprevious
condition|?
literal|'-'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"       "
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
name|FANCY
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"%5d "
argument_list|,
name|pp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
operator|(
name|REASON
operator||
name|AREASON
operator|)
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|NAME
condition|)
name|format
operator|=
literal|"%-23s"
expr_stmt|;
else|else
name|format
operator|=
literal|"%s"
expr_stmt|;
if|if
condition|(
name|pstatus
operator|==
name|status
condition|)
if|if
condition|(
name|pp
operator|->
name|p_reason
operator|==
name|reason
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
name|format
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|0
expr_stmt|;
goto|goto
name|prcomd
goto|;
block|}
else|else
name|reason
operator|=
name|pp
operator|->
name|p_reason
expr_stmt|;
else|else
block|{
name|status
operator|=
name|pstatus
expr_stmt|;
name|reason
operator|=
name|pp
operator|->
name|p_reason
expr_stmt|;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|PRUNNING
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
name|format
argument_list|,
literal|"Running "
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PINTERRUPTED
case|:
case|case
name|PSTOPPED
case|:
case|case
name|PSIGNALED
case|:
comment|/*                      * tell what happened to the background job                      * From: Michael Schroeder                      *<mlschroe@immd4.informatik.uni-erlangen.de>                      */
if|if
condition|(
operator|(
name|flag
operator|&
name|REASON
operator|)
operator|||
operator|(
operator|(
name|flag
operator|&
name|AREASON
operator|)
operator|&&
name|reason
operator|!=
name|SIGINT
operator|&&
operator|(
name|reason
operator|!=
name|SIGPIPE
operator|||
operator|(
name|pp
operator|->
name|p_flags
operator|&
name|PPOU
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
name|format
argument_list|,
name|sys_siglist
index|[
operator|(
name|unsigned
name|char
operator|)
name|pp
operator|->
name|p_reason
index|]
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|PNEXITED
case|:
case|case
name|PAEXITED
case|:
if|if
condition|(
name|flag
operator|&
name|REASON
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_reason
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"Exit %-18d"
argument_list|,
name|pp
operator|->
name|p_reason
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
name|format
argument_list|,
literal|"Done"
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csherr
argument_list|,
literal|"BUG: status=%-9o"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|prcomd
label|:
if|if
condition|(
name|flag
operator|&
name|NAME
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"%s"
argument_list|,
name|vis_str
argument_list|(
name|pp
operator|->
name|p_command
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
name|PPOU
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|" |"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
name|PERR
condition|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'&'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
operator|(
name|REASON
operator||
name|AREASON
operator|)
operator|&&
name|pp
operator|->
name|p_flags
operator|&
name|PDUMPED
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|" (core dumped)"
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|==
name|pp
operator|->
name|p_friends
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|AMPERSAND
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
name|JOBDIR
operator|&&
operator|!
name|eq
argument_list|(
name|tp
operator|->
name|p_cwd
operator|->
name|di_name
argument_list|,
name|dcwd
operator|->
name|di_name
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|" (wd: "
argument_list|)
expr_stmt|;
name|dtildepr
argument_list|(
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|tp
operator|->
name|p_cwd
operator|->
name|di_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|')'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
name|PPTIME
operator|&&
operator|!
operator|(
name|status
operator|&
operator|(
name|PSTOPPED
operator||
name|PRUNNING
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|hadnl
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|prusage
argument_list|(
operator|&
name|zru
argument_list|,
operator|&
name|pp
operator|->
name|p_rusage
argument_list|,
operator|&
name|pp
operator|->
name|p_etime
argument_list|,
operator|&
name|pp
operator|->
name|p_btime
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|==
name|pp
operator|->
name|p_friends
condition|)
block|{
if|if
condition|(
operator|!
name|hadnl
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
name|SHELLDIR
operator|&&
operator|!
name|eq
argument_list|(
name|tp
operator|->
name|p_cwd
operator|->
name|di_name
argument_list|,
name|dcwd
operator|->
name|di_name
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"(wd now: "
argument_list|)
expr_stmt|;
name|dtildepr
argument_list|(
name|value
argument_list|(
name|STRhome
argument_list|)
argument_list|,
name|dcwd
operator|->
name|di_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|pp
operator|=
name|pp
operator|->
name|p_friends
operator|)
operator|!=
name|tp
condition|)
do|;
if|if
condition|(
name|jobflags
operator|&
name|PTIME
operator|&&
operator|(
name|jobflags
operator|&
operator|(
name|PSTOPPED
operator||
name|PRUNNING
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|jobflags
operator|&
name|NUMBER
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"       "
argument_list|)
expr_stmt|;
name|ptprint
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|hadnl
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|cshout
argument_list|)
expr_stmt|;
return|return
operator|(
name|jobflags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptprint
parameter_list|(
name|tp
parameter_list|)
name|struct
name|process
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|timeval
name|tetime
decl_stmt|,
name|diff
decl_stmt|;
specifier|static
name|struct
name|timeval
name|ztime
decl_stmt|;
name|struct
name|rusage
name|ru
decl_stmt|;
specifier|static
name|struct
name|rusage
name|zru
decl_stmt|;
name|struct
name|process
modifier|*
name|pp
init|=
name|tp
decl_stmt|;
name|ru
operator|=
name|zru
expr_stmt|;
name|tetime
operator|=
name|ztime
expr_stmt|;
do|do
block|{
name|ruadd
argument_list|(
operator|&
name|ru
argument_list|,
operator|&
name|pp
operator|->
name|p_rusage
argument_list|)
expr_stmt|;
name|tvsub
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|pp
operator|->
name|p_etime
argument_list|,
operator|&
name|pp
operator|->
name|p_btime
argument_list|)
expr_stmt|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|tetime
argument_list|,
operator|>
argument_list|)
condition|)
name|tetime
operator|=
name|diff
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|pp
operator|=
name|pp
operator|->
name|p_friends
operator|)
operator|!=
name|tp
condition|)
do|;
name|prusage
argument_list|(
operator|&
name|zru
argument_list|,
operator|&
name|ru
argument_list|,
operator|&
name|tetime
argument_list|,
operator|&
name|ztime
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dojobs - print all jobs  */
end_comment

begin_function
name|void
comment|/*ARGSUSED*/
name|dojobs
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|int
name|flag
init|=
name|NUMBER
operator||
name|NAME
operator||
name|REASON
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|chkstop
condition|)
name|chkstop
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|v
condition|)
block|{
if|if
condition|(
name|v
index|[
literal|1
index|]
operator|||
operator|!
name|eq
argument_list|(
operator|*
name|v
argument_list|,
name|STRml
argument_list|)
condition|)
name|stderror
argument_list|(
name|ERR_JOBS
argument_list|)
expr_stmt|;
name|flag
operator||=
name|FANCY
operator||
name|JOBDIR
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|pmaxindex
condition|;
name|i
operator|++
control|)
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_index
operator|==
name|i
operator|&&
name|pp
operator|->
name|p_pid
operator|==
name|pp
operator|->
name|p_jobid
condition|)
block|{
name|pp
operator|->
name|p_flags
operator|&=
operator|~
name|PNEEDNOTE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pprint
argument_list|(
name|pp
argument_list|,
name|flag
argument_list|)
operator|&
operator|(
name|PRUNNING
operator||
name|PSTOPPED
operator|)
operator|)
condition|)
name|pflush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * dofg - builtin - put the job into the foreground  */
end_comment

begin_function
name|void
comment|/*ARGSUSED*/
name|dofg
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|okpcntl
argument_list|()
expr_stmt|;
operator|++
name|v
expr_stmt|;
do|do
block|{
name|pp
operator|=
name|pfind
argument_list|(
operator|*
name|v
argument_list|)
expr_stmt|;
name|pstart
argument_list|(
name|pp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pjwait
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|v
operator|&&
operator|*
operator|++
name|v
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * %... - builtin - put the job into the foreground  */
end_comment

begin_function
name|void
comment|/*ARGSUSED*/
name|dofg1
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|okpcntl
argument_list|()
expr_stmt|;
name|pp
operator|=
name|pfind
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pstart
argument_list|(
name|pp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pjwait
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dobg - builtin - put the job into the background  */
end_comment

begin_function
name|void
comment|/*ARGSUSED*/
name|dobg
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|okpcntl
argument_list|()
expr_stmt|;
operator|++
name|v
expr_stmt|;
do|do
block|{
name|pp
operator|=
name|pfind
argument_list|(
operator|*
name|v
argument_list|)
expr_stmt|;
name|pstart
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|v
operator|&&
operator|*
operator|++
name|v
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * %...& - builtin - put the job into the background  */
end_comment

begin_function
name|void
comment|/*ARGSUSED*/
name|dobg1
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|pfind
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pstart
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dostop - builtin - stop the job  */
end_comment

begin_function
name|void
comment|/*ARGSUSED*/
name|dostop
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|pkill
argument_list|(
operator|++
name|v
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dokill - builtin - superset of kill (1)  */
end_comment

begin_function
name|void
comment|/*ARGSUSED*/
name|dokill
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|signum
init|=
name|SIGTERM
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|v
operator|++
expr_stmt|;
if|if
condition|(
name|v
index|[
literal|0
index|]
operator|&&
name|v
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
for|for
control|(
name|signum
operator|=
literal|1
init|;
name|signum
operator|<
name|NSIG
condition|;
name|signum
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cshout
argument_list|,
literal|"%s "
argument_list|,
name|sys_signame
index|[
name|signum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|signum
operator|==
name|NSIG
operator|/
literal|2
condition|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|cshout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Isdigit
argument_list|(
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|signum
operator|=
name|atoi
argument_list|(
name|short2str
argument_list|(
name|v
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|signum
operator|<
literal|0
operator|||
name|signum
operator|>
name|NSIG
condition|)
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_BADSIG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|short2str
argument_list|(
operator|&
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"sig"
argument_list|,
literal|3
argument_list|)
condition|)
name|name
operator|+=
literal|3
expr_stmt|;
for|for
control|(
name|signum
operator|=
literal|1
init|;
name|signum
operator|<
name|NSIG
condition|;
name|signum
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|sys_signame
index|[
name|signum
index|]
argument_list|,
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|signum
operator|==
name|NSIG
condition|)
block|{
name|setname
argument_list|(
name|vis_str
argument_list|(
operator|&
name|v
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_UNKSIG
argument_list|)
expr_stmt|;
block|}
block|}
name|v
operator|++
expr_stmt|;
block|}
name|pkill
argument_list|(
name|v
argument_list|,
name|signum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pkill
parameter_list|(
name|v
parameter_list|,
name|signum
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|int
name|signum
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|jobflags
init|=
literal|0
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|err1
init|=
literal|0
decl_stmt|;
name|int
name|omask
decl_stmt|;
name|Char
modifier|*
name|cp
decl_stmt|;
name|omask
operator|=
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
name|omask
operator||=
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|omask
argument_list|)
operator|&
operator|~
name|omask
expr_stmt|;
name|gflag
operator|=
literal|0
operator|,
name|tglob
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|gflag
condition|)
block|{
name|v
operator|=
name|globall
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_NOMATCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|gargv
operator|=
name|saveblk
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|trim
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|v
operator|&&
operator|(
name|cp
operator|=
operator|*
name|v
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
name|np
operator|=
name|pp
operator|=
name|pfind
argument_list|(
name|cp
argument_list|)
expr_stmt|;
do|do
name|jobflags
operator||=
name|np
operator|->
name|p_flags
expr_stmt|;
do|while
condition|(
operator|(
name|np
operator|=
name|np
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
switch|switch
condition|(
name|signum
condition|)
block|{
case|case
name|SIGSTOP
case|:
case|case
name|SIGTSTP
case|:
case|case
name|SIGTTIN
case|:
case|case
name|SIGTTOU
case|:
if|if
condition|(
operator|(
name|jobflags
operator|&
name|PRUNNING
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csherr
argument_list|,
literal|"%s: Already suspended\n"
argument_list|,
name|vis_str
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|err1
operator|++
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
break|break;
comment|/* 		 * suspend a process, kill -CONT %, then type jobs; the shell 		 * says it is suspended, but it is running; thanks jaap.. 		 */
case|case
name|SIGCONT
case|:
name|pstart
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
if|if
condition|(
name|killpg
argument_list|(
operator|(
name|pid_t
operator|)
name|pp
operator|->
name|p_jobid
argument_list|,
name|signum
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csherr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|vis_str
argument_list|(
name|cp
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|err1
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|signum
operator|==
name|SIGTERM
operator|||
name|signum
operator|==
name|SIGHUP
condition|)
operator|(
name|void
operator|)
name|killpg
argument_list|(
operator|(
name|pid_t
operator|)
name|pp
operator|->
name|p_jobid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|Isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_JOBARGS
argument_list|)
expr_stmt|;
else|else
block|{
name|pid
operator|=
name|atoi
argument_list|(
name|short2str
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kill
argument_list|(
operator|(
name|pid_t
operator|)
name|pid
argument_list|,
name|signum
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csherr
argument_list|,
literal|"%d: %s\n"
argument_list|,
name|pid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|err1
operator|++
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
if|if
condition|(
name|signum
operator|==
name|SIGTERM
operator|||
name|signum
operator|==
name|SIGHUP
condition|)
operator|(
name|void
operator|)
name|kill
argument_list|(
operator|(
name|pid_t
operator|)
name|pid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
name|cont
label|:
name|v
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gargv
condition|)
name|blkfree
argument_list|(
name|gargv
argument_list|)
operator|,
name|gargv
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
name|err1
condition|)
name|stderror
argument_list|(
name|ERR_SILENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pstart - start the job in foreground/background  */
end_comment

begin_function
name|void
name|pstart
parameter_list|(
name|pp
parameter_list|,
name|foregnd
parameter_list|)
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|int
name|foregnd
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|np
decl_stmt|;
name|int
name|omask
decl_stmt|;
name|long
name|jobflags
init|=
literal|0
decl_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|=
name|pp
expr_stmt|;
do|do
block|{
name|jobflags
operator||=
name|np
operator|->
name|p_flags
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|p_flags
operator|&
operator|(
name|PRUNNING
operator||
name|PSTOPPED
operator|)
condition|)
block|{
name|np
operator|->
name|p_flags
operator||=
name|PRUNNING
expr_stmt|;
name|np
operator|->
name|p_flags
operator|&=
operator|~
name|PSTOPPED
expr_stmt|;
if|if
condition|(
name|foregnd
condition|)
name|np
operator|->
name|p_flags
operator||=
name|PFOREGND
expr_stmt|;
else|else
name|np
operator|->
name|p_flags
operator|&=
operator|~
name|PFOREGND
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|np
operator|=
name|np
operator|->
name|p_friends
operator|)
operator|!=
name|pp
condition|)
do|;
if|if
condition|(
operator|!
name|foregnd
condition|)
name|pclrcurr
argument_list|(
name|pp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pprint
argument_list|(
name|pp
argument_list|,
name|foregnd
condition|?
name|NAME
operator||
name|JOBDIR
else|:
name|NUMBER
operator||
name|NAME
operator||
name|AMPERSAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|foregnd
condition|)
operator|(
name|void
operator|)
name|tcsetpgrp
argument_list|(
name|FSHTTY
argument_list|,
name|pp
operator|->
name|p_jobid
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobflags
operator|&
name|PSTOPPED
condition|)
operator|(
name|void
operator|)
name|killpg
argument_list|(
operator|(
name|pid_t
operator|)
name|pp
operator|->
name|p_jobid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|panystop
parameter_list|(
name|neednl
parameter_list|)
name|bool
name|neednl
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|chkstop
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_flags
operator|&
name|PSTOPPED
condition|)
name|stderror
argument_list|(
name|ERR_STOPPED
argument_list|,
name|neednl
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|process
modifier|*
name|pfind
parameter_list|(
name|cp
parameter_list|)
name|Char
modifier|*
name|cp
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
operator|||
name|cp
index|[
literal|1
index|]
operator|==
literal|0
operator|||
name|eq
argument_list|(
name|cp
argument_list|,
name|STRcent2
argument_list|)
operator|||
name|eq
argument_list|(
name|cp
argument_list|,
name|STRcentplus
argument_list|)
condition|)
block|{
if|if
condition|(
name|pcurrent
operator|==
name|NULL
condition|)
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_JOBCUR
argument_list|)
expr_stmt|;
return|return
operator|(
name|pcurrent
operator|)
return|;
block|}
if|if
condition|(
name|eq
argument_list|(
name|cp
argument_list|,
name|STRcentminus
argument_list|)
operator|||
name|eq
argument_list|(
name|cp
argument_list|,
name|STRcenthash
argument_list|)
condition|)
block|{
if|if
condition|(
name|pprevious
operator|==
name|NULL
condition|)
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_JOBPREV
argument_list|)
expr_stmt|;
return|return
operator|(
name|pprevious
operator|)
return|;
block|}
if|if
condition|(
name|Isdigit
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|idx
init|=
name|atoi
argument_list|(
name|short2str
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_index
operator|==
name|idx
operator|&&
name|pp
operator|->
name|p_pid
operator|==
name|pp
operator|->
name|p_jobid
condition|)
return|return
operator|(
name|pp
operator|)
return|;
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_NOSUCHJOB
argument_list|)
expr_stmt|;
block|}
name|np
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|proclist
operator|.
name|p_next
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|p_next
control|)
if|if
condition|(
name|pp
operator|->
name|p_pid
operator|==
name|pp
operator|->
name|p_jobid
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'?'
condition|)
block|{
name|Char
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|pp
operator|->
name|p_command
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|dp
operator|!=
name|cp
index|[
literal|2
index|]
condition|)
continue|continue;
if|if
condition|(
name|prefix
argument_list|(
name|cp
operator|+
literal|2
argument_list|,
name|dp
argument_list|)
condition|)
goto|goto
name|match
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|prefix
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|pp
operator|->
name|p_command
argument_list|)
condition|)
block|{
name|match
label|:
if|if
condition|(
name|np
condition|)
name|stderror
argument_list|(
name|ERR_NAME
operator||
name|ERR_AMBIG
argument_list|)
expr_stmt|;
name|np
operator|=
name|pp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|np
condition|)
return|return
operator|(
name|np
operator|)
return|;
name|stderror
argument_list|(
name|ERR_NAME
operator||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'?'
condition|?
name|ERR_JOBPAT
else|:
name|ERR_NOSUCHJOB
operator|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pgetcurr - find most recent job that is not pp, preferably stopped  */
end_comment

begin_function
specifier|static
name|struct
name|process
modifier|*
name|pgetcurr
parameter_list|(
name|pp
parameter_list|)
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|np
decl_stmt|;
name|struct
name|process
modifier|*
name|xp
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|np
operator|=
name|proclist
operator|.
name|p_next
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|p_next
control|)
if|if
condition|(
name|np
operator|!=
name|pcurrent
operator|&&
name|np
operator|!=
name|pp
operator|&&
name|np
operator|->
name|p_pid
operator|&&
name|np
operator|->
name|p_pid
operator|==
name|np
operator|->
name|p_jobid
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|p_flags
operator|&
name|PSTOPPED
condition|)
return|return
operator|(
name|np
operator|)
return|;
if|if
condition|(
name|xp
operator|==
name|NULL
condition|)
name|xp
operator|=
name|np
expr_stmt|;
block|}
return|return
operator|(
name|xp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * donotify - flag the job so as to report termination asynchronously  */
end_comment

begin_function
name|void
comment|/*ARGSUSED*/
name|donotify
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|Char
modifier|*
modifier|*
name|v
decl_stmt|;
name|struct
name|command
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|process
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|pfind
argument_list|(
operator|*
operator|++
name|v
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_flags
operator||=
name|PNOTIFY
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do the fork and whatever should be done in the child side that  * should not be done if we are not forking at all (like for simple builtin's)  * Also do everything that needs any signals fiddled with in the parent side  *  * Wanttty tells whether process and/or tty pgrps are to be manipulated:  *	-1:	leave tty alone; inherit pgrp from parent  *	 0:	already have tty; manipulate process pgrps only  *	 1:	want to claim tty; manipulate process and tty pgrps  * It is usually just the value of tpgrp.  */
end_comment

begin_function
name|int
name|pfork
parameter_list|(
name|t
parameter_list|,
name|wanttty
parameter_list|)
name|struct
name|command
modifier|*
name|t
decl_stmt|;
comment|/* command we are forking for */
name|int
name|wanttty
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|bool
name|ignint
init|=
literal|0
decl_stmt|;
name|int
name|pgrp
decl_stmt|;
name|int
name|omask
decl_stmt|;
comment|/*      * A child will be uninterruptible only under very special conditions.      * Remember that the semantics of '&' is implemented by disconnecting the      * process from the tty so signals do not need to ignored just for '&'.      * Thus signals are set to default action for children unless: we have had      * an "onintr -" (then specifically ignored) we are not playing with      * signals (inherit action)      */
if|if
condition|(
name|setintr
condition|)
name|ignint
operator|=
operator|(
name|tpgrp
operator|==
operator|-
literal|1
operator|&&
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_NOINTERRUPT
operator|)
operator|)
operator|||
operator|(
name|gointr
operator|&&
name|eq
argument_list|(
name|gointr
argument_list|,
name|STRminus
argument_list|)
operator|)
expr_stmt|;
comment|/*      * Check for maximum nesting of 16 processes to avoid Forking loops      */
if|if
condition|(
name|child
operator|==
literal|16
condition|)
name|stderror
argument_list|(
name|ERR_NESTING
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/*      * Hold SIGCHLD until we have the process installed in our table.      */
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
if|if
condition|(
name|setintr
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|FORKSLEEP
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|stderror
argument_list|(
name|ERR_NOPROC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|settimes
argument_list|()
expr_stmt|;
name|pgrp
operator|=
name|pcurrjob
condition|?
name|pcurrjob
operator|->
name|p_jobid
else|:
name|getpid
argument_list|()
expr_stmt|;
name|pflushall
argument_list|()
expr_stmt|;
name|pcurrjob
operator|=
name|NULL
expr_stmt|;
name|child
operator|++
expr_stmt|;
if|if
condition|(
name|setintr
condition|)
block|{
name|setintr
operator|=
literal|0
expr_stmt|;
comment|/* until I think otherwise */
comment|/* 	     * Children just get blown away on SIGINT, SIGQUIT unless "onintr 	     * -" seen. 	     */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ignint
condition|?
name|SIG_IGN
else|:
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|ignint
condition|?
name|SIG_IGN
else|:
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|wanttty
operator|>=
literal|0
condition|)
block|{
comment|/* make stoppable */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|parterm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tpgrp
operator|==
operator|-
literal|1
operator|&&
operator|(
name|t
operator|->
name|t_dflg
operator|&
name|F_NOINTERRUPT
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
name|pgetty
argument_list|(
name|wanttty
argument_list|,
name|pgrp
argument_list|)
expr_stmt|;
comment|/* 	 * Nohup and nice apply only to NODE_COMMAND's but it would be nice 	 * (?!?) if you could say "nohup (foo;bar)" Then the parser would have 	 * to know about nice/nohup/time 	 */
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_NOHUP
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_dflg
operator|&
name|F_NICE
condition|)
operator|(
name|void
operator|)
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|t_nice
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wanttty
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|setpgid
argument_list|(
name|pid
argument_list|,
name|pcurrjob
condition|?
name|pcurrjob
operator|->
name|p_jobid
else|:
name|pid
argument_list|)
expr_stmt|;
name|palloc
argument_list|(
name|pid
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|okpcntl
parameter_list|()
block|{
if|if
condition|(
name|tpgrp
operator|==
operator|-
literal|1
condition|)
name|stderror
argument_list|(
name|ERR_JOBCONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpgrp
operator|==
literal|0
condition|)
name|stderror
argument_list|(
name|ERR_JOBCTRLSUB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * if we don't have vfork(), things can still go in the wrong order  * resulting in the famous 'Stopped (tty output)'. But some systems  * don't permit the setpgid() call, (these are more recent secure  * systems such as ibm's aix). Then we'd rather print an error message  * than hang the shell!  * I am open to suggestions how to fix that.  */
end_comment

begin_function
name|void
name|pgetty
parameter_list|(
name|wanttty
parameter_list|,
name|pgrp
parameter_list|)
name|int
name|wanttty
decl_stmt|,
name|pgrp
decl_stmt|;
block|{
name|int
name|omask
init|=
literal|0
decl_stmt|;
comment|/*      * christos: I am blocking the tty signals till I've set things      * correctly....      */
if|if
condition|(
name|wanttty
operator|>
literal|0
condition|)
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGTSTP
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGTTIN
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGTTOU
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * From: Michael Schroeder<mlschroe@immd4.informatik.uni-erlangen.de>      * Don't check for tpgrp>= 0 so even non-interactive shells give      * background jobs process groups Same for the comparison in the other part      * of the #ifdef      */
if|if
condition|(
name|wanttty
operator|>=
literal|0
condition|)
if|if
condition|(
name|setpgid
argument_list|(
literal|0
argument_list|,
name|pgrp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|csherr
argument_list|,
literal|"csh: setpgid error.\n"
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wanttty
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|tcsetpgrp
argument_list|(
name|FSHTTY
argument_list|,
name|pgrp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tpgrp
operator|>
literal|0
condition|)
name|tpgrp
operator|=
literal|0
expr_stmt|;
comment|/* gave tty away */
block|}
end_function

end_unit

