begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c: This file contains the main control and user-interface routines    for the ed line editor. */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1993 Andrew Moore, Talke Studio.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: main.c,v 1.6.2.1 1997/08/24 21:50:21 jkh Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|copyright
init|=
literal|"@(#) Copyright (c) 1993 Andrew Moore, Talke Studio. \n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"@(#)main.c,v 1.1 1994/02/01 00:34:42 alm Exp"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * CREDITS  *  *	This program is based on the editor algorithm described in  *	Brian W. Kernighan and P. J. Plauger's book "Software Tools  *	in Pascal," Addison-Wesley, 1981.  *  *	The buffering algorithm is attributed to Rodney Ruddock of  *	the University of Guelph, Guelph, Ontario.  *  *	The cbc.c encryption code is adapted from  *	the bdes program by Matt Bishop of Dartmouth College,  *	Hanover, NH.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"ed.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
end_ifdef

begin_decl_stmt
name|sigjmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* static buffers */
end_comment

begin_decl_stmt
name|char
name|stdinbuf
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdin buffer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|shcmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shell command buffer */
end_comment

begin_decl_stmt
name|int
name|shcmdsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shell command buffer size */
end_comment

begin_decl_stmt
name|int
name|shcmdi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shell command buffer index */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ibuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ed command-line buffer */
end_comment

begin_decl_stmt
name|int
name|ibufsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ed command-line buffer size */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ibufp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to ed command-line buffer */
end_comment

begin_comment
comment|/* global flags */
end_comment

begin_decl_stmt
name|int
name|des
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, use crypt(3) for i/o */
end_comment

begin_decl_stmt
name|int
name|garrulous
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, print all error messages */
end_comment

begin_decl_stmt
name|int
name|isbinary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, buffer contains ASCII NULs */
end_comment

begin_decl_stmt
name|int
name|isglobal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, doing a global command */
end_comment

begin_decl_stmt
name|int
name|modified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, buffer modified since last write */
end_comment

begin_decl_stmt
name|int
name|mutex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, signals set "sigflags" */
end_comment

begin_decl_stmt
name|int
name|red
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, restrict shell/directory access */
end_comment

begin_decl_stmt
name|int
name|scripted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, suppress diagnostics */
end_comment

begin_decl_stmt
name|int
name|sigflags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, signals received while mutex set */
end_comment

begin_decl_stmt
name|int
name|sigactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, signal handlers are enabled */
end_comment

begin_decl_stmt
name|char
name|old_filename
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default filename */
end_comment

begin_decl_stmt
name|long
name|current_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current address in editor buffer */
end_comment

begin_decl_stmt
name|long
name|addr_last
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last address in editor buffer */
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* script line number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command-line prompt */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dps
init|=
literal|"*"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default command-line prompt */
end_comment

begin_decl_stmt
name|char
modifier|*
name|usage
init|=
literal|"usage: %s [-] [-sx] [-p string] [name]\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ed: line editor */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|long
name|status
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|__GNUC__
comment|/* Avoid longjmp clobbering */
operator|(
name|void
operator|)
operator|&
name|argc
expr_stmt|;
operator|(
name|void
operator|)
operator|&
name|argv
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|red
operator|=
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
operator|>
literal|2
operator|&&
name|argv
index|[
literal|0
index|]
index|[
name|n
operator|-
literal|3
index|]
operator|==
literal|'r'
expr_stmt|;
name|top
label|:
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"p:sx"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
comment|/* set prompt */
name|prompt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* run script */
name|scripted
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* use crypt */
ifdef|#
directive|ifdef
name|DES
name|des
operator|=
name|get_keyword
argument_list|()
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"crypt unavailable\n?\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usage
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|&&
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
name|scripted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|optind
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
comment|/* assert: reliable signals! */
ifdef|#
directive|ifdef
name|SIGWINCH
name|handle_winch
argument_list|(
name|SIGWINCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|handle_winch
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|signal_hup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|signal_int
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
if|if
condition|(
operator|(
name|status
operator|=
name|sigsetjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|status
operator|=
name|setjmp
argument_list|(
name|env
argument_list|)
operator|)
condition|)
endif|#
directive|endif
block|{
name|fputs
argument_list|(
literal|"\n?\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"interrupt"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init_buffers
argument_list|()
expr_stmt|;
name|sigactive
operator|=
literal|1
expr_stmt|;
comment|/* enable signal handlers */
if|if
condition|(
name|argc
operator|&&
operator|*
operator|*
name|argv
operator|&&
name|is_legal_filename
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
block|{
if|if
condition|(
name|read_file
argument_list|(
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|!=
literal|'!'
condition|)
name|strcpy
argument_list|(
name|old_filename
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
condition|)
block|{
name|fputs
argument_list|(
literal|"?\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid filename"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|status
operator|<
literal|0
operator|&&
name|garrulous
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|get_tty_line
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|ERR
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|modified
operator|&&
operator|!
name|scripted
condition|)
block|{
name|fputs
argument_list|(
literal|"?\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"warning: file modified"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|garrulous
condition|?
literal|"script, line %d: %s\n"
else|:
literal|""
argument_list|,
name|lineno
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|EMOD
expr_stmt|;
continue|continue;
block|}
else|else
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ibuf
index|[
name|n
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* discard line */
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected end-of-file"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|status
operator|=
name|ERR
expr_stmt|;
continue|continue;
block|}
name|isglobal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|extract_addr_range
argument_list|()
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|status
operator|=
name|exec_command
argument_list|()
operator|)
operator|>=
literal|0
condition|)
if|if
condition|(
operator|!
name|status
operator|||
operator|(
name|status
operator|=
name|display_lines
argument_list|(
name|current_addr
argument_list|,
name|current_addr
argument_list|,
name|status
argument_list|)
operator|)
operator|>=
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|EOF
case|:
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|EMOD
case|:
name|modified
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
literal|"?\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* give warning */
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"warning: file modified"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|garrulous
condition|?
literal|"script, line %d: %s\n"
else|:
literal|""
argument_list|,
name|lineno
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FATAL
case|:
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|garrulous
condition|?
literal|"script, line %d: %s\n"
else|:
literal|""
argument_list|,
name|lineno
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|garrulous
condition|?
literal|"%s\n"
else|:
literal|""
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
default|default:
name|fputs
argument_list|(
literal|"?\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|garrulous
condition|?
literal|"script, line %d: %s\n"
else|:
literal|""
argument_list|,
name|lineno
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_decl_stmt
name|long
name|first_addr
decl_stmt|,
name|second_addr
decl_stmt|,
name|addr_cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extract_addr_range: get line addresses from the command buffer until an    illegal address is seen; return status */
end_comment

begin_function
name|int
name|extract_addr_range
parameter_list|()
block|{
name|long
name|addr
decl_stmt|;
name|addr_cnt
operator|=
literal|0
expr_stmt|;
name|first_addr
operator|=
name|second_addr
operator|=
name|current_addr
expr_stmt|;
while|while
condition|(
operator|(
name|addr
operator|=
name|next_addr
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|addr_cnt
operator|++
expr_stmt|;
name|first_addr
operator|=
name|second_addr
expr_stmt|;
name|second_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
operator|*
name|ibufp
operator|!=
literal|','
operator|&&
operator|*
name|ibufp
operator|!=
literal|';'
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|ibufp
operator|++
operator|==
literal|';'
condition|)
name|current_addr
operator|=
name|addr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|addr_cnt
operator|=
name|min
argument_list|(
name|addr_cnt
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
literal|1
operator|||
name|second_addr
operator|!=
name|addr
condition|)
name|first_addr
operator|=
name|second_addr
expr_stmt|;
return|return
operator|(
name|addr
operator|==
name|ERR
operator|)
condition|?
name|ERR
else|:
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SKIP_BLANKS
parameter_list|()
value|while (isspace((unsigned char)*ibufp)&& *ibufp != '\n') ibufp++
end_define

begin_define
define|#
directive|define
name|MUST_BE_FIRST
parameter_list|()
define|\
value|if (!first) { sprintf(errmsg, "invalid address"); return ERR; }
end_define

begin_comment
comment|/*  next_addr: return the next line address in the command buffer */
end_comment

begin_function
name|long
name|next_addr
parameter_list|()
block|{
name|char
modifier|*
name|hd
decl_stmt|;
name|long
name|addr
init|=
name|current_addr
decl_stmt|;
name|long
name|n
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|c
decl_stmt|;
name|SKIP_BLANKS
argument_list|()
expr_stmt|;
for|for
control|(
name|hd
operator|=
name|ibufp
init|;
condition|;
name|first
operator|=
literal|0
control|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|ibufp
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
case|case
literal|'-'
case|:
case|case
literal|'^'
case|:
name|ibufp
operator|++
expr_stmt|;
name|SKIP_BLANKS
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ibufp
argument_list|)
condition|)
block|{
name|STRTOL
argument_list|(
name|n
argument_list|,
name|ibufp
argument_list|)
expr_stmt|;
name|addr
operator|+=
operator|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'^'
operator|)
condition|?
operator|-
name|n
else|:
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
condition|)
name|addr
operator|+=
operator|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'^'
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|MUST_BE_FIRST
argument_list|()
expr_stmt|;
name|STRTOL
argument_list|(
name|addr
argument_list|,
name|ibufp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
case|case
literal|'$'
case|:
name|MUST_BE_FIRST
argument_list|()
expr_stmt|;
name|ibufp
operator|++
expr_stmt|;
name|addr
operator|=
operator|(
name|c
operator|==
literal|'.'
operator|)
condition|?
name|current_addr
else|:
name|addr_last
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
case|case
literal|'?'
case|:
name|MUST_BE_FIRST
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|get_matching_node_addr
argument_list|(
name|get_compiled_pattern
argument_list|()
argument_list|,
name|c
operator|==
literal|'/'
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|c
operator|==
operator|*
name|ibufp
condition|)
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|MUST_BE_FIRST
argument_list|()
expr_stmt|;
name|ibufp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|get_marked_node_addr
argument_list|(
operator|*
name|ibufp
operator|++
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'%'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
if|if
condition|(
name|first
condition|)
block|{
name|ibufp
operator|++
expr_stmt|;
name|addr_cnt
operator|++
expr_stmt|;
name|second_addr
operator|=
operator|(
name|c
operator|==
literal|';'
operator|)
condition|?
name|current_addr
else|:
literal|1
expr_stmt|;
name|addr
operator|=
name|addr_last
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
default|default:
if|if
condition|(
name|ibufp
operator|==
name|hd
condition|)
return|return
name|EOF
return|;
elseif|else
if|if
condition|(
name|addr
operator|<
literal|0
operator|||
name|addr_last
operator|<
name|addr
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
else|else
return|return
name|addr
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BACKWARDS
end_ifdef

begin_comment
comment|/* GET_THIRD_ADDR: get a legal address from the command buffer */
end_comment

begin_define
define|#
directive|define
name|GET_THIRD_ADDR
parameter_list|(
name|addr
parameter_list|)
define|\
value|{ \ 	long ol1, ol2; \ \ 	ol1 = first_addr, ol2 = second_addr; \ 	if (extract_addr_range()< 0) \ 		return ERR; \ 	else if (addr_cnt == 0) { \ 		sprintf(errmsg, "destination expected"); \ 		return ERR; \ 	} else if (second_addr< 0 || addr_last< second_addr) { \ 		sprintf(errmsg, "invalid address"); \ 		return ERR; \ 	} \ 	addr = second_addr; \ 	first_addr = ol1, second_addr = ol2; \ }
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BACKWARDS */
end_comment

begin_comment
comment|/* GET_THIRD_ADDR: get a legal address from the command buffer */
end_comment

begin_define
define|#
directive|define
name|GET_THIRD_ADDR
parameter_list|(
name|addr
parameter_list|)
define|\
value|{ \ 	long ol1, ol2; \ \ 	ol1 = first_addr, ol2 = second_addr; \ 	if (extract_addr_range()< 0) \ 		return ERR; \ 	if (second_addr< 0 || addr_last< second_addr) { \ 		sprintf(errmsg, "invalid address"); \ 		return ERR; \ 	} \ 	addr = second_addr; \ 	first_addr = ol1, second_addr = ol2; \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GET_COMMAND_SUFFIX: verify the command suffix in the command buffer */
end_comment

begin_define
define|#
directive|define
name|GET_COMMAND_SUFFIX
parameter_list|()
value|{ \ 	int done = 0; \ 	do { \ 		switch(*ibufp) { \ 		case 'p': \ 			gflag |= GPR, ibufp++; \ 			break; \ 		case 'l': \ 			gflag |= GLS, ibufp++; \ 			break; \ 		case 'n': \ 			gflag |= GNP, ibufp++; \ 			break; \ 		default: \ 			done++; \ 		} \ 	} while (!done); \ 	if (*ibufp++ != '\n') { \ 		sprintf(errmsg, "invalid command suffix"); \ 		return ERR; \ 	} \ }
end_define

begin_comment
comment|/* sflags */
end_comment

begin_define
define|#
directive|define
name|SGG
value|001
end_define

begin_comment
comment|/* complement previous global substitute suffix */
end_comment

begin_define
define|#
directive|define
name|SGP
value|002
end_define

begin_comment
comment|/* complement previous print suffix */
end_comment

begin_define
define|#
directive|define
name|SGR
value|004
end_define

begin_comment
comment|/* use last regex instead of last pat */
end_comment

begin_define
define|#
directive|define
name|SGF
value|010
end_define

begin_comment
comment|/* repeat last substitution */
end_comment

begin_decl_stmt
name|int
name|patlock
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, pattern not freed by get_compiled_pattern() */
end_comment

begin_decl_stmt
name|long
name|rows
init|=
literal|22
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scroll length: ws_row - 2 */
end_comment

begin_comment
comment|/* exec_command: execute the next command in command buffer; return print    request, if any */
end_comment

begin_function
name|int
name|exec_command
parameter_list|()
block|{
specifier|extern
name|long
name|u_current_addr
decl_stmt|;
specifier|extern
name|long
name|u_addr_last
decl_stmt|;
specifier|static
name|pattern_t
modifier|*
name|pat
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|sgflag
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|sgnum
init|=
literal|0
decl_stmt|;
name|pattern_t
modifier|*
name|tpat
decl_stmt|;
name|char
modifier|*
name|fnp
decl_stmt|;
name|int
name|gflag
init|=
literal|0
decl_stmt|;
name|int
name|sflags
init|=
literal|0
decl_stmt|;
name|long
name|addr
init|=
literal|0
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|SKIP_BLANKS
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|ibufp
operator|++
condition|)
block|{
case|case
literal|'a'
case|:
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isglobal
condition|)
name|clear_undo_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|append_lines
argument_list|(
name|second_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|check_addr_range
argument_list|(
name|current_addr
argument_list|,
name|current_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isglobal
condition|)
name|clear_undo_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|delete_lines
argument_list|(
name|first_addr
argument_list|,
name|second_addr
argument_list|)
operator|<
literal|0
operator|||
name|append_lines
argument_list|(
name|current_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|check_addr_range
argument_list|(
name|current_addr
argument_list|,
name|current_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isglobal
condition|)
name|clear_undo_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|delete_lines
argument_list|(
name|first_addr
argument_list|,
name|second_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
operator|(
name|addr
operator|=
name|INC_MOD
argument_list|(
name|current_addr
argument_list|,
name|addr_last
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|current_addr
operator|=
name|addr
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|modified
operator|&&
operator|!
name|scripted
condition|)
return|return
name|EMOD
return|;
comment|/* fall through */
case|case
literal|'E'
case|:
if|if
condition|(
name|addr_cnt
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ibufp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected command suffix"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fnp
operator|=
name|get_filename
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
name|delete_lines
argument_list|(
literal|1
argument_list|,
name|addr_last
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|clear_undo_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|close_sbuf
argument_list|()
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|open_sbuf
argument_list|()
operator|<
literal|0
condition|)
return|return
name|FATAL
return|;
if|if
condition|(
operator|*
name|fnp
operator|&&
operator|*
name|fnp
operator|!=
literal|'!'
condition|)
name|strcpy
argument_list|(
name|old_filename
argument_list|,
name|fnp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BACKWARDS
if|if
condition|(
operator|*
name|fnp
operator|==
literal|'\0'
operator|&&
operator|*
name|old_filename
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no current filename"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|read_file
argument_list|(
operator|*
name|fnp
condition|?
name|fnp
else|:
name|old_filename
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|clear_undo_stack
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|0
expr_stmt|;
name|u_current_addr
operator|=
name|u_addr_last
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|addr_cnt
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ibufp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected command suffix"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fnp
operator|=
name|get_filename
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
operator|*
name|fnp
operator|==
literal|'!'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid redirection"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|fnp
condition|)
name|strcpy
argument_list|(
name|old_filename
argument_list|,
name|fnp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|strip_escapes
argument_list|(
name|old_filename
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'v'
case|:
case|case
literal|'G'
case|:
case|case
literal|'V'
case|:
if|if
condition|(
name|isglobal
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot nest global commands"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|check_addr_range
argument_list|(
literal|1
argument_list|,
name|addr_last
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|build_active_list
argument_list|(
name|c
operator|==
literal|'g'
operator|||
name|c
operator|==
literal|'G'
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
operator|(
name|n
operator|=
operator|(
name|c
operator|==
literal|'G'
operator|||
name|c
operator|==
literal|'V'
operator|)
operator|)
condition|)
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
name|isglobal
operator|++
expr_stmt|;
if|if
condition|(
name|exec_global
argument_list|(
name|n
argument_list|,
name|gflag
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|addr_cnt
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|errmsg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|addr_cnt
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|garrulous
operator|=
literal|1
operator|-
name|garrulous
operator|)
operator|&&
operator|*
name|errmsg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|second_addr
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isglobal
condition|)
name|clear_undo_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|append_lines
argument_list|(
name|second_addr
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|check_addr_range
argument_list|(
name|current_addr
argument_list|,
name|current_addr
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isglobal
condition|)
name|clear_undo_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|first_addr
operator|!=
name|second_addr
operator|&&
name|join_lines
argument_list|(
name|first_addr
argument_list|,
name|second_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'k'
case|:
name|c
operator|=
operator|*
name|ibufp
operator|++
expr_stmt|;
if|if
condition|(
name|second_addr
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
name|mark_line_node
argument_list|(
name|get_addressed_line_node
argument_list|(
name|second_addr
argument_list|)
argument_list|,
name|c
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|check_addr_range
argument_list|(
name|current_addr
argument_list|,
name|current_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
name|display_lines
argument_list|(
name|first_addr
argument_list|,
name|second_addr
argument_list|,
name|gflag
operator||
name|GLS
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|gflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|check_addr_range
argument_list|(
name|current_addr
argument_list|,
name|current_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GET_THIRD_ADDR
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_addr
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|second_addr
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid destination"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isglobal
condition|)
name|clear_undo_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|move_lines
argument_list|(
name|addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|check_addr_range
argument_list|(
name|current_addr
argument_list|,
name|current_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
name|display_lines
argument_list|(
name|first_addr
argument_list|,
name|second_addr
argument_list|,
name|gflag
operator||
name|GNP
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|gflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|check_addr_range
argument_list|(
name|current_addr
argument_list|,
name|current_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
name|display_lines
argument_list|(
name|first_addr
argument_list|,
name|second_addr
argument_list|,
name|gflag
operator||
name|GPR
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|gflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|addr_cnt
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
name|prompt
operator|=
name|prompt
condition|?
name|NULL
else|:
name|optarg
condition|?
name|optarg
else|:
name|dps
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
if|if
condition|(
name|addr_cnt
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
name|gflag
operator|=
operator|(
name|modified
operator|&&
operator|!
name|scripted
operator|&&
name|c
operator|==
literal|'q'
operator|)
condition|?
name|EMOD
else|:
name|EOF
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ibufp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected command suffix"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|addr_cnt
operator|==
literal|0
condition|)
name|second_addr
operator|=
name|addr_last
expr_stmt|;
if|if
condition|(
operator|(
name|fnp
operator|=
name|get_filename
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isglobal
condition|)
name|clear_undo_stack
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|old_filename
operator|==
literal|'\0'
operator|&&
operator|*
name|fnp
operator|!=
literal|'!'
condition|)
name|strcpy
argument_list|(
name|old_filename
argument_list|,
name|fnp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BACKWARDS
if|if
condition|(
operator|*
name|fnp
operator|==
literal|'\0'
operator|&&
operator|*
name|old_filename
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no current filename"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|addr
operator|=
name|read_file
argument_list|(
operator|*
name|fnp
condition|?
name|fnp
else|:
name|old_filename
argument_list|,
name|second_addr
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|addr
operator|&&
name|addr
operator|!=
name|addr_last
condition|)
name|modified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
do|do
block|{
switch|switch
condition|(
operator|*
name|ibufp
condition|)
block|{
case|case
literal|'\n'
case|:
name|sflags
operator||=
name|SGF
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|sflags
operator||=
name|SGG
expr_stmt|;
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|sflags
operator||=
name|SGP
expr_stmt|;
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|sflags
operator||=
name|SGR
expr_stmt|;
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|STRTOL
argument_list|(
name|sgnum
argument_list|,
name|ibufp
argument_list|)
expr_stmt|;
name|sflags
operator||=
name|SGF
expr_stmt|;
name|sgflag
operator|&=
operator|~
name|GSG
expr_stmt|;
comment|/* override GSG */
break|break;
default|default:
if|if
condition|(
name|sflags
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid command suffix"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
block|}
block|}
do|while
condition|(
name|sflags
operator|&&
operator|*
name|ibufp
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|sflags
operator|&&
operator|!
name|pat
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no previous substitution"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|sflags
operator|&
name|SGG
condition|)
name|sgnum
operator|=
literal|0
expr_stmt|;
comment|/* override numeric arg */
if|if
condition|(
operator|*
name|ibufp
operator|!=
literal|'\n'
operator|&&
operator|*
operator|(
name|ibufp
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid pattern delimiter"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|tpat
operator|=
name|pat
expr_stmt|;
name|SPL1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|sflags
operator|||
operator|(
name|sflags
operator|&
name|SGR
operator|)
operator|)
operator|&&
operator|(
name|tpat
operator|=
name|get_compiled_pattern
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|SPL0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|tpat
operator|!=
name|pat
condition|)
block|{
if|if
condition|(
name|pat
condition|)
block|{
name|regfree
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|tpat
expr_stmt|;
name|patlock
operator|=
literal|1
expr_stmt|;
comment|/* reserve pattern */
block|}
name|SPL0
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sflags
operator|&&
name|extract_subst_tail
argument_list|(
operator|&
name|sgflag
argument_list|,
operator|&
name|sgnum
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|isglobal
condition|)
name|sgflag
operator||=
name|GLB
expr_stmt|;
else|else
name|sgflag
operator|&=
operator|~
name|GLB
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SGG
condition|)
name|sgflag
operator|^=
name|GSG
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SGP
condition|)
name|sgflag
operator|^=
name|GPR
operator|,
name|sgflag
operator|&=
operator|~
operator|(
name|GLS
operator||
name|GNP
operator|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
operator|*
name|ibufp
condition|)
block|{
case|case
literal|'p'
case|:
name|sgflag
operator||=
name|GPR
operator|,
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|sgflag
operator||=
name|GLS
operator|,
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|sgflag
operator||=
name|GNP
operator|,
name|ibufp
operator|++
expr_stmt|;
break|break;
default|default:
name|n
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|n
condition|)
do|;
if|if
condition|(
name|check_addr_range
argument_list|(
name|current_addr
argument_list|,
name|current_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isglobal
condition|)
name|clear_undo_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|search_and_replace
argument_list|(
name|pat
argument_list|,
name|sgflag
argument_list|,
name|sgnum
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|check_addr_range
argument_list|(
name|current_addr
argument_list|,
name|current_addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GET_THIRD_ADDR
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isglobal
condition|)
name|clear_undo_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|copy_lines
argument_list|(
name|addr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|addr_cnt
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
name|pop_undo_stack
argument_list|()
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|ibufp
operator|)
operator|==
literal|'q'
operator|||
name|n
operator|==
literal|'Q'
condition|)
block|{
name|gflag
operator|=
name|EOF
expr_stmt|;
name|ibufp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ibufp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected command suffix"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fnp
operator|=
name|get_filename
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
if|if
condition|(
name|addr_cnt
operator|==
literal|0
operator|&&
operator|!
name|addr_last
condition|)
name|first_addr
operator|=
name|second_addr
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|check_addr_range
argument_list|(
literal|1
argument_list|,
name|addr_last
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|old_filename
operator|==
literal|'\0'
operator|&&
operator|*
name|fnp
operator|!=
literal|'!'
condition|)
name|strcpy
argument_list|(
name|old_filename
argument_list|,
name|fnp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BACKWARDS
if|if
condition|(
operator|*
name|fnp
operator|==
literal|'\0'
operator|&&
operator|*
name|old_filename
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no current filename"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|addr
operator|=
name|write_file
argument_list|(
operator|*
name|fnp
condition|?
name|fnp
else|:
name|old_filename
argument_list|,
operator|(
name|c
operator|==
literal|'W'
operator|)
condition|?
literal|"a"
else|:
literal|"w"
argument_list|,
name|first_addr
argument_list|,
name|second_addr
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|addr
operator|==
name|addr_last
condition|)
name|modified
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|modified
operator|&&
operator|!
name|scripted
operator|&&
name|n
operator|==
literal|'q'
condition|)
name|gflag
operator|=
name|EMOD
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|addr_cnt
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DES
name|des
operator|=
name|get_keyword
argument_list|()
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"crypt unavailable"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
endif|#
directive|endif
break|break;
case|case
literal|'z'
case|:
ifdef|#
directive|ifdef
name|BACKWARDS
if|if
condition|(
name|check_addr_range
argument_list|(
name|first_addr
operator|=
literal|1
argument_list|,
name|current_addr
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|check_addr_range
argument_list|(
name|first_addr
operator|=
literal|1
argument_list|,
name|current_addr
operator|+
operator|!
name|isglobal
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
literal|'0'
operator|<
operator|*
name|ibufp
operator|&&
operator|*
name|ibufp
operator|<=
literal|'9'
condition|)
name|STRTOL
argument_list|(
name|rows
argument_list|,
name|ibufp
argument_list|)
expr_stmt|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
name|display_lines
argument_list|(
name|second_addr
argument_list|,
name|min
argument_list|(
name|addr_last
argument_list|,
name|second_addr
operator|+
name|rows
argument_list|)
argument_list|,
name|gflag
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|gflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
name|addr_cnt
condition|?
name|second_addr
else|:
name|addr_last
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|addr_cnt
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sflags
operator|=
name|get_shell_command
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GET_COMMAND_SUFFIX
argument_list|()
expr_stmt|;
if|if
condition|(
name|sflags
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|shcmd
operator|+
literal|1
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|shcmd
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scripted
condition|)
name|printf
argument_list|(
literal|"!\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
ifdef|#
directive|ifdef
name|BACKWARDS
if|if
condition|(
name|check_addr_range
argument_list|(
name|first_addr
operator|=
literal|1
argument_list|,
name|current_addr
operator|+
literal|1
argument_list|)
operator|<
literal|0
else|#
directive|else
if|if
condition|(
name|check_addr_range
argument_list|(
name|first_addr
operator|=
literal|1
argument_list|,
name|current_addr
operator|+
operator|!
name|isglobal
argument_list|)
operator|<
literal|0
endif|#
directive|endif
operator|||
name|display_lines
argument_list|(
name|second_addr
argument_list|,
name|second_addr
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
default|default:
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unknown command"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
return|return
name|gflag
return|;
block|}
end_function

begin_comment
comment|/* check_addr_range: return status of address range check */
end_comment

begin_function
name|int
name|check_addr_range
parameter_list|(
name|n
parameter_list|,
name|m
parameter_list|)
name|long
name|n
decl_stmt|,
name|m
decl_stmt|;
block|{
if|if
condition|(
name|addr_cnt
operator|==
literal|0
condition|)
block|{
name|first_addr
operator|=
name|n
expr_stmt|;
name|second_addr
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|first_addr
operator|>
name|second_addr
operator|||
literal|1
operator|>
name|first_addr
operator|||
name|second_addr
operator|>
name|addr_last
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* get_matching_node_addr: return the address of the next line matching a    pattern in a given direction.  wrap around begin/end of editor buffer if    necessary */
end_comment

begin_function
name|long
name|get_matching_node_addr
parameter_list|(
name|pat
parameter_list|,
name|dir
parameter_list|)
name|pattern_t
modifier|*
name|pat
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|long
name|n
init|=
name|current_addr
decl_stmt|;
name|line_t
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
name|ERR
return|;
do|do
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dir
condition|?
name|INC_MOD
argument_list|(
name|n
argument_list|,
name|addr_last
argument_list|)
else|:
name|DEC_MOD
argument_list|(
name|n
argument_list|,
name|addr_last
argument_list|)
operator|)
condition|)
block|{
name|lp
operator|=
name|get_addressed_line_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|get_sbuf_line
argument_list|(
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
if|if
condition|(
name|isbinary
condition|)
name|NUL_TO_NEWLINE
argument_list|(
name|s
argument_list|,
name|lp
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regexec
argument_list|(
name|pat
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|n
return|;
block|}
block|}
do|while
condition|(
name|n
operator|!=
name|current_addr
condition|)
do|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no match"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
end_function

begin_comment
comment|/* get_filename: return pointer to copy of filename in the command buffer */
end_comment

begin_function
name|char
modifier|*
name|get_filename
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|filesz
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|ibufp
operator|!=
literal|'\n'
condition|)
block|{
name|SKIP_BLANKS
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|ibufp
operator|==
literal|'\n'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid filename"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ibufp
operator|=
name|get_extended_line
argument_list|(
operator|&
name|n
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
elseif|else
if|if
condition|(
operator|*
name|ibufp
operator|==
literal|'!'
condition|)
block|{
name|ibufp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|get_shell_command
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|n
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|shcmd
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|shcmd
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|-
literal|1
operator|>
name|MAXPATHLEN
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"filename too long"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
ifndef|#
directive|ifndef
name|BACKWARDS
elseif|else
if|if
condition|(
operator|*
name|old_filename
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no current filename"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
name|REALLOC
argument_list|(
name|file
argument_list|,
name|filesz
argument_list|,
name|MAXPATHLEN
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|*
name|ibufp
operator|!=
literal|'\n'
condition|;
control|)
name|file
index|[
name|n
operator|++
index|]
operator|=
operator|*
name|ibufp
operator|++
expr_stmt|;
name|file
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|is_legal_filename
argument_list|(
name|file
argument_list|)
condition|?
name|file
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* get_shell_command: read a shell command from stdin; return substitution    status */
end_comment

begin_function
name|int
name|get_shell_command
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* substitution char pointer */
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|red
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"shell access restricted"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|=
name|ibufp
operator|=
name|get_extended_line
argument_list|(
operator|&
name|j
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|REALLOC
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|j
operator|+
literal|1
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
literal|'!'
expr_stmt|;
comment|/* prefix command w/ bang */
while|while
condition|(
operator|*
name|ibufp
operator|!=
literal|'\n'
condition|)
switch|switch
condition|(
operator|*
name|ibufp
condition|)
block|{
default|default:
name|REALLOC
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ibufp
expr_stmt|;
if|if
condition|(
operator|*
name|ibufp
operator|++
operator|==
literal|'\\'
condition|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|s
operator|!=
name|ibufp
condition|)
block|{
name|REALLOC
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ibufp
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BACKWARDS
elseif|else
if|if
condition|(
name|shcmd
operator|==
name|NULL
operator|||
operator|*
operator|(
name|shcmd
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
name|shcmd
operator|==
name|NULL
condition|)
endif|#
directive|endif
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no previous command"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
else|else
block|{
name|REALLOC
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|i
operator|+
name|shcmdi
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|shcmd
operator|+
literal|1
init|;
name|s
operator|<
name|shcmd
operator|+
name|shcmdi
condition|;
control|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|ibufp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
operator|*
name|old_filename
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no current filename"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|j
operator|=
name|strlen
argument_list|(
name|s
operator|=
name|strip_escapes
argument_list|(
name|old_filename
argument_list|)
argument_list|)
expr_stmt|;
name|REALLOC
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|i
operator|+
name|j
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|ibufp
operator|++
expr_stmt|;
break|break;
block|}
name|REALLOC
argument_list|(
name|shcmd
argument_list|,
name|shcmdsz
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|shcmd
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|shcmd
index|[
name|shcmdi
operator|=
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|*
name|s
operator|==
literal|'!'
operator|||
operator|*
name|s
operator|==
literal|'%'
return|;
block|}
end_function

begin_comment
comment|/* append_lines: insert text from stdin to after line n; stop when either a    single period is read or EOF; return status */
end_comment

begin_function
name|int
name|append_lines
parameter_list|(
name|n
parameter_list|)
name|long
name|n
decl_stmt|;
block|{
name|int
name|l
decl_stmt|;
name|char
modifier|*
name|lp
init|=
name|ibuf
decl_stmt|;
name|char
modifier|*
name|eot
decl_stmt|;
name|undo_t
modifier|*
name|up
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|current_addr
operator|=
name|n
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|isglobal
condition|)
block|{
if|if
condition|(
operator|(
name|l
operator|=
name|get_tty_line
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|l
operator|==
literal|0
operator|||
name|ibuf
index|[
name|l
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
return|return
name|l
condition|?
name|EOF
else|:
literal|0
return|;
block|}
name|lp
operator|=
name|ibuf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|lp
operator|=
name|ibufp
operator|)
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
else|else
block|{
while|while
condition|(
operator|*
name|ibufp
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|l
operator|=
name|ibufp
operator|-
name|lp
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|==
literal|2
operator|&&
name|lp
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|lp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
return|return
literal|0
return|;
block|}
name|eot
operator|=
name|lp
operator|+
name|l
expr_stmt|;
name|SPL1
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|lp
operator|=
name|put_sbuf_line
argument_list|(
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SPL0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|up
condition|)
name|up
operator|->
name|t
operator|=
name|get_addressed_line_node
argument_list|(
name|current_addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|up
operator|=
name|push_undo_stack
argument_list|(
name|UADD
argument_list|,
name|current_addr
argument_list|,
name|current_addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SPL0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
block|}
do|while
condition|(
name|lp
operator|!=
name|eot
condition|)
do|;
name|modified
operator|=
literal|1
expr_stmt|;
name|SPL0
argument_list|()
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* join_lines: replace a range of lines with the joined text of those lines */
end_comment

begin_function
name|int
name|join_lines
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|long
name|from
decl_stmt|;
name|long
name|to
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|line_t
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|get_addressed_line_node
argument_list|(
name|INC_MOD
argument_list|(
name|to
argument_list|,
name|addr_last
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|get_addressed_line_node
argument_list|(
name|from
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|bp
operator|!=
name|ep
condition|;
name|bp
operator|=
name|bp
operator|->
name|q_forw
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|get_sbuf_line
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|REALLOC
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|size
operator|+
name|bp
operator|->
name|len
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|size
argument_list|,
name|s
argument_list|,
name|bp
operator|->
name|len
argument_list|)
expr_stmt|;
name|size
operator|+=
name|bp
operator|->
name|len
expr_stmt|;
block|}
name|REALLOC
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|size
operator|+
literal|2
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|size
argument_list|,
literal|"\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_lines
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|current_addr
operator|=
name|from
operator|-
literal|1
expr_stmt|;
name|SPL1
argument_list|()
expr_stmt|;
if|if
condition|(
name|put_sbuf_line
argument_list|(
name|buf
argument_list|)
operator|==
name|NULL
operator|||
name|push_undo_stack
argument_list|(
name|UADD
argument_list|,
name|current_addr
argument_list|,
name|current_addr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SPL0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|modified
operator|=
literal|1
expr_stmt|;
name|SPL0
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* move_lines: move a range of lines */
end_comment

begin_function
name|int
name|move_lines
parameter_list|(
name|addr
parameter_list|)
name|long
name|addr
decl_stmt|;
block|{
name|line_t
modifier|*
name|b1
decl_stmt|,
modifier|*
name|a1
decl_stmt|,
modifier|*
name|b2
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
name|long
name|n
init|=
name|INC_MOD
argument_list|(
name|second_addr
argument_list|,
name|addr_last
argument_list|)
decl_stmt|;
name|long
name|p
init|=
name|first_addr
operator|-
literal|1
decl_stmt|;
name|int
name|done
init|=
operator|(
name|addr
operator|==
name|first_addr
operator|-
literal|1
operator|||
name|addr
operator|==
name|second_addr
operator|)
decl_stmt|;
name|SPL1
argument_list|()
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|a2
operator|=
name|get_addressed_line_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|b2
operator|=
name|get_addressed_line_node
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|current_addr
operator|=
name|second_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|push_undo_stack
argument_list|(
name|UMOV
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
operator|==
name|NULL
operator|||
name|push_undo_stack
argument_list|(
name|UMOV
argument_list|,
name|addr
argument_list|,
name|INC_MOD
argument_list|(
name|addr
argument_list|,
name|addr_last
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SPL0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
else|else
block|{
name|a1
operator|=
name|get_addressed_line_node
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|first_addr
condition|)
block|{
name|b1
operator|=
name|get_addressed_line_node
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|b2
operator|=
name|get_addressed_line_node
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* this get_addressed_line_node last! */
block|}
else|else
block|{
name|b2
operator|=
name|get_addressed_line_node
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|b1
operator|=
name|get_addressed_line_node
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* this get_addressed_line_node last! */
block|}
name|a2
operator|=
name|b2
operator|->
name|q_forw
expr_stmt|;
name|REQUE
argument_list|(
name|b2
argument_list|,
name|b1
operator|->
name|q_forw
argument_list|)
expr_stmt|;
name|REQUE
argument_list|(
name|a1
operator|->
name|q_back
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|REQUE
argument_list|(
name|b1
argument_list|,
name|a1
argument_list|)
expr_stmt|;
name|current_addr
operator|=
name|addr
operator|+
operator|(
operator|(
name|addr
operator|<
name|first_addr
operator|)
condition|?
name|second_addr
operator|-
name|first_addr
operator|+
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|isglobal
condition|)
name|unset_active_nodes
argument_list|(
name|b2
operator|->
name|q_forw
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|1
expr_stmt|;
name|SPL0
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* copy_lines: copy a range of lines; return status */
end_comment

begin_function
name|int
name|copy_lines
parameter_list|(
name|addr
parameter_list|)
name|long
name|addr
decl_stmt|;
block|{
name|line_t
modifier|*
name|lp
decl_stmt|,
modifier|*
name|np
init|=
name|get_addressed_line_node
argument_list|(
name|first_addr
argument_list|)
decl_stmt|;
name|undo_t
modifier|*
name|up
init|=
name|NULL
decl_stmt|;
name|long
name|n
init|=
name|second_addr
operator|-
name|first_addr
operator|+
literal|1
decl_stmt|;
name|long
name|m
init|=
literal|0
decl_stmt|;
name|current_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|first_addr
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|second_addr
condition|)
block|{
name|n
operator|=
name|addr
operator|-
name|first_addr
operator|+
literal|1
expr_stmt|;
name|m
operator|=
name|second_addr
operator|-
name|addr
expr_stmt|;
block|}
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|=
name|m
operator|,
name|m
operator|=
literal|0
operator|,
name|np
operator|=
name|get_addressed_line_node
argument_list|(
name|current_addr
operator|+
literal|1
argument_list|)
control|)
for|for
control|(
init|;
name|n
operator|--
operator|>
literal|0
condition|;
name|np
operator|=
name|np
operator|->
name|q_forw
control|)
block|{
name|SPL1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|dup_line_node
argument_list|(
name|np
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SPL0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|add_line_node
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
condition|)
name|up
operator|->
name|t
operator|=
name|lp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|up
operator|=
name|push_undo_stack
argument_list|(
name|UADD
argument_list|,
name|current_addr
argument_list|,
name|current_addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SPL0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|modified
operator|=
literal|1
expr_stmt|;
name|SPL0
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* delete_lines: delete a range of lines */
end_comment

begin_function
name|int
name|delete_lines
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|long
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|line_t
modifier|*
name|n
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|SPL1
argument_list|()
expr_stmt|;
if|if
condition|(
name|push_undo_stack
argument_list|(
name|UDEL
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SPL0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|n
operator|=
name|get_addressed_line_node
argument_list|(
name|INC_MOD
argument_list|(
name|to
argument_list|,
name|addr_last
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|get_addressed_line_node
argument_list|(
name|from
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* this get_addressed_line_node last! */
if|if
condition|(
name|isglobal
condition|)
name|unset_active_nodes
argument_list|(
name|p
operator|->
name|q_forw
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|REQUE
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|addr_last
operator|-=
name|to
operator|-
name|from
operator|+
literal|1
expr_stmt|;
name|current_addr
operator|=
name|from
operator|-
literal|1
expr_stmt|;
name|modified
operator|=
literal|1
expr_stmt|;
name|SPL0
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* display_lines: print a range of lines to stdout */
end_comment

begin_function
name|int
name|display_lines
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|gflag
parameter_list|)
name|long
name|from
decl_stmt|;
name|long
name|to
decl_stmt|;
name|int
name|gflag
decl_stmt|;
block|{
name|line_t
modifier|*
name|bp
decl_stmt|;
name|line_t
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|from
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|ep
operator|=
name|get_addressed_line_node
argument_list|(
name|INC_MOD
argument_list|(
name|to
argument_list|,
name|addr_last
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|get_addressed_line_node
argument_list|(
name|from
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|bp
operator|!=
name|ep
condition|;
name|bp
operator|=
name|bp
operator|->
name|q_forw
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|get_sbuf_line
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
if|if
condition|(
name|put_tty_line
argument_list|(
name|s
argument_list|,
name|bp
operator|->
name|len
argument_list|,
name|current_addr
operator|=
name|from
operator|++
argument_list|,
name|gflag
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXMARK
value|26
end_define

begin_comment
comment|/* max number of marks */
end_comment

begin_decl_stmt
name|line_t
modifier|*
name|mark
index|[
name|MAXMARK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line markers */
end_comment

begin_decl_stmt
name|int
name|markno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line marker count */
end_comment

begin_comment
comment|/* mark_line_node: set a line node mark */
end_comment

begin_function
name|int
name|mark_line_node
parameter_list|(
name|lp
parameter_list|,
name|n
parameter_list|)
name|line_t
modifier|*
name|lp
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|islower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|n
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid mark character"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|mark
index|[
name|n
operator|-
literal|'a'
index|]
operator|==
name|NULL
condition|)
name|markno
operator|++
expr_stmt|;
name|mark
index|[
name|n
operator|-
literal|'a'
index|]
operator|=
name|lp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* get_marked_node_addr: return address of a marked line */
end_comment

begin_function
name|long
name|get_marked_node_addr
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|islower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|n
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid mark character"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
return|return
name|get_line_node_addr
argument_list|(
name|mark
index|[
name|n
operator|-
literal|'a'
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* unmark_line_node: clear line node mark */
end_comment

begin_function
name|void
name|unmark_line_node
parameter_list|(
name|lp
parameter_list|)
name|line_t
modifier|*
name|lp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|markno
operator|&&
name|i
operator|<
name|MAXMARK
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mark
index|[
name|i
index|]
operator|==
name|lp
condition|)
block|{
name|mark
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|markno
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* dup_line_node: return a pointer to a copy of a line node */
end_comment

begin_function
name|line_t
modifier|*
name|dup_line_node
parameter_list|(
name|lp
parameter_list|)
name|line_t
modifier|*
name|lp
decl_stmt|;
block|{
name|line_t
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
operator|(
name|line_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|line_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|np
operator|->
name|seek
operator|=
name|lp
operator|->
name|seek
expr_stmt|;
name|np
operator|->
name|len
operator|=
name|lp
operator|->
name|len
expr_stmt|;
return|return
name|np
return|;
block|}
end_function

begin_comment
comment|/* has_trailing_escape:  return the parity of escapes preceding a character    in a string */
end_comment

begin_function
name|int
name|has_trailing_escape
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
return|return
operator|(
name|s
operator|==
name|t
operator|||
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
operator|!=
literal|'\\'
operator|)
condition|?
literal|0
else|:
operator|!
name|has_trailing_escape
argument_list|(
name|s
argument_list|,
name|t
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* strip_escapes: return copy of escaped string of at most length MAXPATHLEN */
end_comment

begin_function
name|char
modifier|*
name|strip_escapes
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|filesz
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|REALLOC
argument_list|(
name|file
argument_list|,
name|filesz
argument_list|,
name|MAXPATHLEN
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* assert: no trailing escape */
while|while
condition|(
operator|(
name|file
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|*
name|s
operator|==
literal|'\\'
operator|)
condition|?
operator|*
operator|++
name|s
else|:
operator|*
name|s
operator|)
condition|)
name|s
operator|++
expr_stmt|;
return|return
name|file
return|;
block|}
end_function

begin_function
name|void
name|signal_hup
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|if
condition|(
name|mutex
condition|)
name|sigflags
operator||=
operator|(
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|handle_hup
argument_list|(
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|signal_int
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|if
condition|(
name|mutex
condition|)
name|sigflags
operator||=
operator|(
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|handle_int
argument_list|(
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|handle_hup
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|char
modifier|*
name|hup
init|=
name|NULL
decl_stmt|;
comment|/* hup filename */
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|sigactive
condition|)
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sigflags
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|addr_last
operator|&&
name|write_file
argument_list|(
literal|"ed.hup"
argument_list|,
literal|"w"
argument_list|,
literal|1
argument_list|,
name|addr_last
argument_list|)
operator|<
literal|0
operator|&&
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
operator|+
literal|8
operator|<=
name|MAXPATHLEN
operator|&&
comment|/* "ed.hup" + '/' */
operator|(
name|hup
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|+
literal|10
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|hup
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|hup
index|[
name|n
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|hup
index|[
name|n
index|]
operator|=
literal|'/'
operator|,
name|hup
index|[
name|n
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|hup
argument_list|,
literal|"ed.hup"
argument_list|)
expr_stmt|;
name|write_file
argument_list|(
name|hup
argument_list|,
literal|"w"
argument_list|,
literal|1
argument_list|,
name|addr_last
argument_list|)
expr_stmt|;
block|}
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|handle_int
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|sigactive
condition|)
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sigflags
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
name|siglongjmp
argument_list|(
name|env
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|longjmp
argument_list|(
name|env
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|int
name|cols
init|=
literal|72
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wrap column */
end_comment

begin_function
name|void
name|handle_winch
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|struct
name|winsize
name|ws
decl_stmt|;
comment|/* window size structure */
name|sigflags
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ws
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ws
operator|.
name|ws_row
operator|>
literal|2
condition|)
name|rows
operator|=
name|ws
operator|.
name|ws_row
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|ws
operator|.
name|ws_col
operator|>
literal|8
condition|)
name|cols
operator|=
name|ws
operator|.
name|ws_col
operator|-
literal|8
expr_stmt|;
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
end_function

begin_comment
comment|/* is_legal_filename: return a legal filename */
end_comment

begin_function
name|int
name|is_legal_filename
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|red
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'!'
operator|||
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|".."
argument_list|)
operator|||
name|strchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"shell access restricted"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

