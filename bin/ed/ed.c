begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ed.c: This file contains the main control and user-interface routines    for the ed line editor. */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1993 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley  * by Andrew Moore, Talke Studio.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Kernighan/Plauger, "Software Tools in Pascal," (c) 1981 by  * Addison-Wesley Publishing Company, Inc.  Reprinted with permission of  * the publisher.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright1
index|[]
init|=
literal|"@(#) Copyright (c) 1993 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|copyright2
index|[]
init|=
literal|"@(#) Kernighan/Plauger, Software Tools in Pascal, (c) 1981 by\n\  Addison-Wesley Publishing Company, Inc.  Reprinted with permission of\n\  the publisher.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ed.c	5.5 (Berkeley) 3/28/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * CREDITS  *	The buf.c algorithm is attributed to Rodney Ruddock of  *	the University of Guelph, Guelph, Ontario.  *  *	The cbc.c encryption code is adapted from  *	the bdes program by Matt Bishop of Dartmouth College,  *	Hanover, NH.  *  *	Addison-Wesley Publishing Company generously granted  *	permission to distribute this program over Internet.  *  */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"ed.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
end_ifdef

begin_decl_stmt
name|sigjmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* static buffers */
end_comment

begin_decl_stmt
name|char
modifier|*
name|shcmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shell command buffer */
end_comment

begin_decl_stmt
name|int
name|shcmdsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shell command buffer size */
end_comment

begin_decl_stmt
name|int
name|shcmdi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shell command buffer index */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cvbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global command buffer */
end_comment

begin_decl_stmt
name|int
name|cvbufsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global command buffer size */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lhbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lhs buffer */
end_comment

begin_decl_stmt
name|int
name|lhbufsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lhs buffer size */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rhbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rhs buffer */
end_comment

begin_decl_stmt
name|int
name|rhbufsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rhs buffer size */
end_comment

begin_decl_stmt
name|int
name|rhbufi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rhs buffer index */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* regsub buffer */
end_comment

begin_decl_stmt
name|int
name|rbufsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* regsub buffer size */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file i/o buffer */
end_comment

begin_decl_stmt
name|int
name|sbufsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file i/o buffer size */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ibuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ed command-line buffer */
end_comment

begin_decl_stmt
name|int
name|ibufsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ed command-line buffer size */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ibufp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to ed command-line buffer */
end_comment

begin_comment
comment|/* global flags */
end_comment

begin_decl_stmt
name|int
name|isbinary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, buffer contains ASCII NULs */
end_comment

begin_decl_stmt
name|int
name|modified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, buffer modified since last write */
end_comment

begin_decl_stmt
name|int
name|garrulous
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, print all error messages */
end_comment

begin_decl_stmt
name|int
name|scripted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, suppress diagnostics */
end_comment

begin_decl_stmt
name|int
name|des
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, use crypt(3) for i/o */
end_comment

begin_decl_stmt
name|int
name|mutex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, signals set "sigflags" */
end_comment

begin_decl_stmt
name|int
name|sigflags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, signals received while mutex set */
end_comment

begin_decl_stmt
name|int
name|sigactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, signal handlers are enabled */
end_comment

begin_decl_stmt
name|int
name|red
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, restrict shell/directory access */
end_comment

begin_decl_stmt
name|char
name|dfn
index|[
name|MAXFNAME
operator|+
literal|1
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default filename */
end_comment

begin_decl_stmt
name|long
name|curln
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current address */
end_comment

begin_decl_stmt
name|long
name|lastln
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last address */
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* script line number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command-line prompt */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dps
init|=
literal|"*"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default command-line prompt */
end_comment

begin_decl_stmt
name|char
modifier|*
name|usage
init|=
literal|"usage: %s [-] [-sx] [-p string] [name]\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|errmsg
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ed: line editor */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|long
name|status
init|=
literal|0
decl_stmt|;
name|red
operator|=
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
operator|>
literal|2
operator|&&
name|argv
index|[
literal|0
index|]
index|[
name|n
operator|-
literal|3
index|]
operator|==
literal|'r'
expr_stmt|;
name|top
label|:
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"p:sx"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
comment|/* set prompt */
name|prompt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* run script */
name|scripted
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* use crypt */
ifdef|#
directive|ifdef
name|DES
name|des
operator|=
name|getkey
argument_list|()
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"crypt unavailable\n?\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usage
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|&&
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
name|scripted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|optind
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
comment|/* assert: reliable signals! */
ifdef|#
directive|ifdef
name|SIGWINCH
name|dowinch
argument_list|(
name|SIGWINCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|dowinch
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|onhup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
if|if
condition|(
name|status
operator|=
name|sigsetjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|status
operator|=
name|setjmp
argument_list|(
name|env
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|fputs
argument_list|(
literal|"\n?\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"interrupt"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init_buf
argument_list|()
expr_stmt|;
name|sigactive
operator|=
literal|1
expr_stmt|;
comment|/* enable signal handlers */
if|if
condition|(
name|argc
operator|&&
operator|*
operator|*
name|argv
operator|&&
name|ckfn
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
block|{
if|if
condition|(
name|doread
argument_list|(
literal|0
argument_list|,
operator|*
name|argv
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|!=
literal|'!'
condition|)
name|strcpy
argument_list|(
name|dfn
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
condition|)
block|{
name|fputs
argument_list|(
literal|"?\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid filename"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|status
operator|<
literal|0
operator|&&
name|garrulous
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|getline
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|ERR
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|modified
operator|&&
operator|!
name|scripted
condition|)
block|{
name|fputs
argument_list|(
literal|"?\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"warning: file modified"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|garrulous
condition|?
literal|"script, line %d: %s\n"
else|:
literal|""
argument_list|,
name|lineno
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|EMOD
expr_stmt|;
continue|continue;
block|}
else|else
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ibuf
index|[
name|n
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* discard line */
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected end-of-file"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|status
operator|=
name|ERR
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|getlist
argument_list|()
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|status
operator|=
name|ckglob
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|>
literal|0
operator|&&
operator|(
name|status
operator|=
name|doglob
argument_list|(
name|status
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|curln
operator|=
name|status
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|=
name|n
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|status
operator|=
name|docmd
argument_list|(
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|status
operator|||
name|status
operator|&&
operator|(
name|status
operator|=
name|doprint
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|,
name|status
argument_list|)
operator|)
operator|>=
literal|0
condition|)
continue|continue;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|EOF
case|:
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|EMOD
case|:
name|modified
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
literal|"?\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* give warning */
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"warning: file modified"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|garrulous
condition|?
literal|"script, line %d: %s\n"
else|:
literal|""
argument_list|,
name|lineno
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FATAL
case|:
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|garrulous
condition|?
literal|"script, line %d: %s\n"
else|:
literal|""
argument_list|,
name|lineno
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|garrulous
condition|?
literal|"%s\n"
else|:
literal|""
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
default|default:
name|fputs
argument_list|(
literal|"?\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|garrulous
condition|?
literal|"script, line %d: %s\n"
else|:
literal|""
argument_list|,
name|lineno
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_decl_stmt
name|long
name|line1
decl_stmt|,
name|line2
decl_stmt|,
name|nlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* getlist: get line numbers from the command buffer until an illegal    address is seen.  return range status */
end_comment

begin_macro
name|getlist
argument_list|()
end_macro

begin_block
block|{
name|long
name|num
decl_stmt|;
name|nlines
operator|=
name|line2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|num
operator|=
name|getone
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|line1
operator|=
name|line2
expr_stmt|;
name|line2
operator|=
name|num
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ibufp
operator|!=
literal|','
operator|&&
operator|*
name|ibufp
operator|!=
literal|';'
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|ibufp
operator|++
operator|==
literal|';'
condition|)
name|curln
operator|=
name|num
expr_stmt|;
block|}
name|nlines
operator|=
name|min
argument_list|(
name|nlines
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|line2
operator|=
name|curln
expr_stmt|;
if|if
condition|(
name|nlines
operator|<=
literal|1
condition|)
name|line1
operator|=
name|line2
expr_stmt|;
return|return
operator|(
name|num
operator|==
name|ERR
operator|)
condition|?
name|ERR
else|:
name|nlines
return|;
block|}
end_block

begin_comment
comment|/*  getone: return the next line number in the command buffer */
end_comment

begin_function
name|long
name|getone
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|long
name|i
decl_stmt|,
name|num
decl_stmt|;
if|if
condition|(
operator|(
name|num
operator|=
name|getnum
argument_list|(
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|num
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|isspace
argument_list|(
operator|*
name|ibufp
argument_list|)
expr_stmt|;
name|skipblanks
argument_list|()
expr_stmt|;
name|c
operator|=
name|c
operator|&&
name|isdigit
argument_list|(
operator|*
name|ibufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|&&
operator|*
name|ibufp
operator|!=
literal|'+'
operator|&&
operator|*
name|ibufp
operator|!=
literal|'-'
operator|&&
operator|*
name|ibufp
operator|!=
literal|'^'
condition|)
break|break;
name|c
operator|=
name|c
condition|?
literal|'+'
else|:
operator|*
name|ibufp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|getnum
argument_list|(
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid address"
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|num
operator|+=
name|i
expr_stmt|;
else|else
name|num
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|>
name|lastln
operator|||
name|num
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* getnum:  return a relative line number from the command buffer */
end_comment

begin_function
name|long
name|getnum
parameter_list|(
name|first
parameter_list|)
name|int
name|first
decl_stmt|;
block|{
name|pattern_t
modifier|*
name|pat
decl_stmt|;
name|char
name|c
decl_stmt|;
name|skipblanks
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|ibufp
argument_list|)
condition|)
return|return
name|strtol
argument_list|(
name|ibufp
argument_list|,
operator|&
name|ibufp
argument_list|,
literal|10
argument_list|)
return|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|ibufp
condition|)
block|{
case|case
literal|'.'
case|:
name|ibufp
operator|++
expr_stmt|;
return|return
name|first
condition|?
name|curln
else|:
name|ERR
return|;
case|case
literal|'$'
case|:
name|ibufp
operator|++
expr_stmt|;
return|return
name|first
condition|?
name|lastln
else|:
name|ERR
return|;
case|case
literal|'/'
case|:
case|case
literal|'?'
case|:
if|if
condition|(
operator|(
name|pat
operator|=
name|optpat
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
operator|*
name|ibufp
operator|==
name|c
condition|)
name|ibufp
operator|++
expr_stmt|;
return|return
name|first
condition|?
name|patscan
argument_list|(
name|pat
argument_list|,
operator|(
name|c
operator|==
literal|'/'
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
else|:
name|ERR
return|;
case|case
literal|'^'
case|:
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
return|return
name|first
condition|?
name|curln
else|:
literal|1
return|;
case|case
literal|'\''
case|:
name|ibufp
operator|++
expr_stmt|;
return|return
name|first
condition|?
name|getmark
argument_list|(
operator|*
name|ibufp
operator|++
argument_list|)
else|:
name|ERR
return|;
case|case
literal|'%'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
if|if
condition|(
name|first
condition|)
block|{
name|ibufp
operator|++
expr_stmt|;
name|line2
operator|=
operator|(
name|c
operator|==
literal|';'
operator|)
condition|?
name|curln
else|:
literal|1
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
return|return
name|lastln
return|;
block|}
return|return
literal|1
return|;
default|default:
return|return
name|first
condition|?
name|EOF
else|:
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* gflags */
end_comment

begin_define
define|#
directive|define
name|GLB
value|001
end_define

begin_comment
comment|/* global command */
end_comment

begin_define
define|#
directive|define
name|GPR
value|002
end_define

begin_comment
comment|/* print after command */
end_comment

begin_define
define|#
directive|define
name|GLS
value|004
end_define

begin_comment
comment|/* list after command */
end_comment

begin_define
define|#
directive|define
name|GNP
value|010
end_define

begin_comment
comment|/* enumerate after command */
end_comment

begin_define
define|#
directive|define
name|GSG
value|020
end_define

begin_comment
comment|/* global substitute */
end_comment

begin_comment
comment|/* VRFYCMD: verify the command suffix in the command buffer */
end_comment

begin_define
define|#
directive|define
name|VRFYCMD
parameter_list|()
value|{ \ 	int done = 0; \ 	do { \ 		switch(*ibufp) { \ 		case 'p': \ 			gflag |= GPR, ibufp++; \ 			break; \ 		case 'l': \ 			gflag |= GLS, ibufp++; \ 			break; \ 		case 'n': \ 			gflag |= GNP, ibufp++; \ 			break; \ 		default: \ 			done++; \ 		} \ 	} while (!done); \ 	if (*ibufp++ != '\n') { \ 		sprintf(errmsg, "invalid command suffix"); \ 		return ERR; \ 	} \ }
end_define

begin_comment
comment|/* ckglob:  set lines matching a pattern in the command buffer; return    global status  */
end_comment

begin_macro
name|ckglob
argument_list|()
end_macro

begin_block
block|{
name|pattern_t
modifier|*
name|pat
decl_stmt|;
name|char
name|c
decl_stmt|,
name|delim
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|nomatch
decl_stmt|;
name|long
name|n
decl_stmt|;
name|line_t
modifier|*
name|lp
decl_stmt|;
name|int
name|gflag
init|=
literal|0
decl_stmt|;
comment|/* print suffix of interactive cmd */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|ibufp
operator|)
operator|==
literal|'V'
operator|||
name|c
operator|==
literal|'G'
condition|)
name|gflag
operator|=
name|GLB
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'g'
operator|&&
name|c
operator|!=
literal|'v'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ckrange
argument_list|(
literal|1
argument_list|,
name|lastln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
operator|(
name|delim
operator|=
operator|*
operator|++
name|ibufp
operator|)
operator|==
literal|' '
operator|||
name|delim
operator|==
literal|'\n'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid pattern delimiter"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pat
operator|=
name|optpat
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
operator|*
name|ibufp
operator|==
name|delim
condition|)
name|ibufp
operator|++
expr_stmt|;
if|if
condition|(
name|gflag
condition|)
name|VRFYCMD
argument_list|()
expr_stmt|;
comment|/* get print suffix */
for|for
control|(
name|lp
operator|=
name|getlp
argument_list|(
name|n
operator|=
literal|1
argument_list|)
init|;
name|n
operator|<=
name|lastln
condition|;
name|n
operator|++
operator|,
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|gettxt
argument_list|(
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|lp
operator|->
name|len
operator|&=
operator|~
name|ACTV
expr_stmt|;
comment|/* zero ACTV  bit */
if|if
condition|(
name|isbinary
condition|)
name|s
operator|=
name|nultonl
argument_list|(
name|s
argument_list|,
name|lp
operator|->
name|len
operator|&
operator|~
name|ACTV
argument_list|)
expr_stmt|;
if|if
condition|(
name|line1
operator|<=
name|n
operator|&&
name|n
operator|<=
name|line2
operator|&&
operator|(
operator|!
operator|(
name|nomatch
operator|=
name|regexec
argument_list|(
name|pat
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'g'
operator|||
name|c
operator|==
literal|'G'
operator|)
operator|||
name|nomatch
operator|&&
operator|(
name|c
operator|==
literal|'v'
operator|||
name|c
operator|==
literal|'V'
operator|)
operator|)
condition|)
name|lp
operator|->
name|len
operator||=
name|ACTV
expr_stmt|;
block|}
return|return
name|gflag
operator||
name|GSG
return|;
block|}
end_block

begin_comment
comment|/* doglob: apply command list in the command buffer to the active    lines in a range; return command status */
end_comment

begin_function
name|long
name|doglob
parameter_list|(
name|gflag
parameter_list|)
name|int
name|gflag
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|ocmd
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|ocmdsz
init|=
literal|0
decl_stmt|;
name|line_t
modifier|*
name|lp
init|=
name|NULL
decl_stmt|;
name|long
name|lc
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|interact
init|=
name|gflag
operator|&
operator|~
name|GSG
decl_stmt|;
comment|/* GLB& gflag ? */
name|char
modifier|*
name|cmd
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|BACKWARDS
if|if
condition|(
operator|!
name|interact
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ibufp
argument_list|,
literal|"\n"
argument_list|)
condition|)
name|cmd
operator|=
literal|"p\n"
expr_stmt|;
comment|/* null cmd-list == `p' */
elseif|else
if|if
condition|(
operator|(
name|cmd
operator|=
name|getcmdv
argument_list|(
operator|&
name|n
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|interact
operator|&&
operator|(
name|cmd
operator|=
name|getcmdv
argument_list|(
operator|&
name|n
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
endif|#
directive|endif
name|ureset
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|lp
operator|=
name|getlp
argument_list|(
name|lc
operator|=
literal|1
argument_list|)
init|;
name|lc
operator|<=
name|lastln
condition|;
name|lc
operator|++
operator|,
name|lp
operator|=
name|lp
operator|->
name|next
control|)
if|if
condition|(
name|lp
operator|->
name|len
operator|&
name|ACTV
condition|)
comment|/* active line */
break|break;
if|if
condition|(
name|lc
operator|>
name|lastln
condition|)
break|break;
name|lp
operator|->
name|len
operator|^=
name|ACTV
expr_stmt|;
comment|/* zero ACTV bit */
name|curln
operator|=
name|lc
expr_stmt|;
if|if
condition|(
name|interact
condition|)
block|{
comment|/* print curln and get a command in global syntax */
if|if
condition|(
name|doprint
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
while|while
condition|(
operator|(
name|n
operator|=
name|getline
argument_list|()
operator|)
operator|>
literal|0
operator|&&
name|ibuf
index|[
name|n
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected end-of-file"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|ibuf
argument_list|,
literal|"\n"
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|ibuf
argument_list|,
literal|"&\n"
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no previous command"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
else|else
name|cmd
operator|=
name|ocmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cmd
operator|=
name|getcmdv
argument_list|(
operator|&
name|n
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
else|else
block|{
name|CKBUF
argument_list|(
name|ocmd
argument_list|,
name|ocmdsz
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ocmd
argument_list|,
name|cmd
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|ocmd
expr_stmt|;
block|}
block|}
name|ibufp
operator|=
name|cmd
expr_stmt|;
for|for
control|(
init|;
operator|*
name|ibufp
condition|;
control|)
if|if
condition|(
operator|(
name|status
operator|=
name|getlist
argument_list|()
operator|)
operator|<
literal|0
operator|||
operator|(
name|status
operator|=
name|docmd
argument_list|(
literal|1
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|status
operator|>
literal|0
operator|&&
operator|(
name|status
operator|=
name|doprint
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|,
name|status
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
return|return
name|status
return|;
block|}
return|return
operator|(
operator|(
name|interact
operator|&
operator|~
name|GLB
operator|)
operator|&&
name|doprint
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|,
name|interact
argument_list|)
operator|<
literal|0
operator|)
condition|?
name|ERR
else|:
name|curln
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BACKWARDS
end_ifdef

begin_comment
comment|/* GETLINE3: get a legal address from the command buffer */
end_comment

begin_define
define|#
directive|define
name|GETLINE3
parameter_list|(
name|num
parameter_list|)
define|\
value|{ \ 	long ol1, ol2; \ \ 	ol1 = line1, ol2 = line2; \ 	if (getlist()< 0) \ 		return ERR; \ 	else if (nlines == 0) { \ 		sprintf(errmsg, "destination expected"); \ 		return ERR; \ 	} else if (line2< 0 || lastln< line2) { \ 		sprintf(errmsg, "invalid address"); \ 		return ERR; \ 	} \ 	num = line2; \ 	line1 = ol1, line2 = ol2; \ }
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BACKWARDS */
end_comment

begin_comment
comment|/* GETLINE3: get a legal address from the command buffer */
end_comment

begin_define
define|#
directive|define
name|GETLINE3
parameter_list|(
name|num
parameter_list|)
define|\
value|{ \ 	long ol1, ol2; \ \ 	ol1 = line1, ol2 = line2; \ 	if (getlist()< 0) \ 		return ERR; \ 	if (line2< 0 || lastln< line2) { \ 		sprintf(errmsg, "invalid address"); \ 		return ERR; \ 	} \ 	num = line2; \ 	line1 = ol1, line2 = ol2; \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sgflags */
end_comment

begin_define
define|#
directive|define
name|SGG
value|001
end_define

begin_comment
comment|/* complement previous global substitute suffix */
end_comment

begin_define
define|#
directive|define
name|SGP
value|002
end_define

begin_comment
comment|/* complement previous print suffix */
end_comment

begin_define
define|#
directive|define
name|SGR
value|004
end_define

begin_comment
comment|/* use last regex instead of last pat */
end_comment

begin_define
define|#
directive|define
name|SGF
value|010
end_define

begin_comment
comment|/* newline found */
end_comment

begin_decl_stmt
name|long
name|ucurln
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if>= 0, undo enabled */
end_comment

begin_decl_stmt
name|long
name|ulastln
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if>= 0, undo enabled */
end_comment

begin_decl_stmt
name|int
name|patlock
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, pattern not released by optpat() */
end_comment

begin_decl_stmt
name|long
name|rows
init|=
literal|22
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scroll length: ws_row - 2 */
end_comment

begin_comment
comment|/* docmd: execute the next command in command buffer; return print    request, if any */
end_comment

begin_macro
name|docmd
argument_list|(
argument|glob
argument_list|)
end_macro

begin_decl_stmt
name|int
name|glob
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|pattern_t
modifier|*
name|pat
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|sgflag
init|=
literal|0
decl_stmt|;
name|pattern_t
modifier|*
name|tpat
decl_stmt|;
name|char
modifier|*
name|fnp
decl_stmt|;
name|int
name|gflag
init|=
literal|0
decl_stmt|;
name|int
name|sflags
init|=
literal|0
decl_stmt|;
name|long
name|num
init|=
literal|0
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|skipblanks
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|ibufp
operator|++
condition|)
block|{
case|case
literal|'a'
case|:
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|glob
condition|)
name|ureset
argument_list|()
expr_stmt|;
if|if
condition|(
name|append
argument_list|(
name|line2
argument_list|,
name|glob
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|ckrange
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|glob
condition|)
name|ureset
argument_list|()
expr_stmt|;
if|if
condition|(
name|lndelete
argument_list|(
name|line1
argument_list|,
name|line2
argument_list|)
operator|<
literal|0
operator|||
name|append
argument_list|(
name|curln
argument_list|,
name|glob
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|ckrange
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|glob
condition|)
name|ureset
argument_list|()
expr_stmt|;
if|if
condition|(
name|lndelete
argument_list|(
name|line1
argument_list|,
name|line2
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|nextln
argument_list|(
name|curln
argument_list|,
name|lastln
argument_list|)
operator|!=
literal|0
condition|)
name|curln
operator|=
name|nextln
argument_list|(
name|curln
argument_list|,
name|lastln
argument_list|)
expr_stmt|;
name|modified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|modified
operator|&&
operator|!
name|scripted
condition|)
return|return
name|EMOD
return|;
comment|/* fall through */
case|case
literal|'E'
case|:
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|ibufp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected command suffix"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fnp
operator|=
name|getfn
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
name|lndelete
argument_list|(
literal|1
argument_list|,
name|lastln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|ureset
argument_list|()
expr_stmt|;
if|if
condition|(
name|sbclose
argument_list|()
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|sbopen
argument_list|()
operator|<
literal|0
condition|)
return|return
name|FATAL
return|;
if|if
condition|(
operator|*
name|fnp
operator|&&
operator|*
name|fnp
operator|!=
literal|'!'
condition|)
name|strcpy
argument_list|(
name|dfn
argument_list|,
name|fnp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BACKWARDS
if|if
condition|(
operator|*
name|fnp
operator|==
literal|'\0'
operator|&&
operator|*
name|dfn
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no current filename"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|doread
argument_list|(
literal|0
argument_list|,
operator|*
name|fnp
condition|?
name|fnp
else|:
name|dfn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|ureset
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|0
expr_stmt|;
name|ucurln
operator|=
name|ulastln
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|ibufp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected command suffix"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fnp
operator|=
name|getfn
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
operator|*
name|fnp
operator|==
literal|'!'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid redirection"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|fnp
condition|)
name|strcpy
argument_list|(
name|dfn
argument_list|,
name|fnp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|esctos
argument_list|(
name|dfn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot nest global commands"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
case|case
literal|'h'
case|:
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|errmsg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|garrulous
operator|=
literal|1
operator|-
name|garrulous
operator|)
operator|&&
operator|*
name|errmsg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|line2
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|glob
condition|)
name|ureset
argument_list|()
expr_stmt|;
if|if
condition|(
name|append
argument_list|(
name|prevln
argument_list|(
name|line2
argument_list|,
name|lastln
argument_list|)
argument_list|,
name|glob
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|ckrange
argument_list|(
name|curln
argument_list|,
name|curln
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|glob
condition|)
name|ureset
argument_list|()
expr_stmt|;
if|if
condition|(
name|line1
operator|!=
name|line2
operator|&&
name|join
argument_list|(
name|line1
argument_list|,
name|line2
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'k'
case|:
name|c
operator|=
operator|*
name|ibufp
operator|++
expr_stmt|;
if|if
condition|(
name|line2
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
name|putmark
argument_list|(
name|c
argument_list|,
name|getlp
argument_list|(
name|line2
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|ckrange
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
name|doprint
argument_list|(
name|line1
argument_list|,
name|line2
argument_list|,
name|gflag
operator||
name|GLS
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|gflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|ckrange
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GETLINE3
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|line1
operator|<=
name|num
operator|&&
name|num
operator|<
name|line2
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid destination"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|glob
condition|)
name|ureset
argument_list|()
expr_stmt|;
if|if
condition|(
name|move
argument_list|(
name|num
argument_list|,
name|glob
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
else|else
name|modified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|ckrange
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
name|doprint
argument_list|(
name|line1
argument_list|,
name|line2
argument_list|,
name|gflag
operator||
name|GNP
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|gflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|ckrange
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
name|doprint
argument_list|(
name|line1
argument_list|,
name|line2
argument_list|,
name|gflag
operator||
name|GPR
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|gflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|VRFYCMD
argument_list|()
expr_stmt|;
name|prompt
operator|=
name|prompt
condition|?
name|NULL
else|:
name|optarg
condition|?
name|optarg
else|:
name|dps
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|VRFYCMD
argument_list|()
expr_stmt|;
name|gflag
operator|=
operator|(
name|modified
operator|&&
operator|!
name|scripted
operator|&&
name|c
operator|==
literal|'q'
operator|)
condition|?
name|EMOD
else|:
name|EOF
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|ibufp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected command suffix"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|line2
operator|=
name|lastln
expr_stmt|;
if|if
condition|(
operator|(
name|fnp
operator|=
name|getfn
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|glob
condition|)
name|ureset
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|dfn
operator|==
literal|'\0'
operator|&&
operator|*
name|fnp
operator|!=
literal|'!'
condition|)
name|strcpy
argument_list|(
name|dfn
argument_list|,
name|fnp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BACKWARDS
if|if
condition|(
operator|*
name|fnp
operator|==
literal|'\0'
operator|&&
operator|*
name|dfn
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no current filename"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|num
operator|=
name|doread
argument_list|(
name|line2
argument_list|,
operator|*
name|fnp
condition|?
name|fnp
else|:
name|dfn
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|num
operator|&&
name|num
operator|!=
name|lastln
condition|)
name|modified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
do|do
block|{
switch|switch
condition|(
operator|*
name|ibufp
condition|)
block|{
case|case
literal|'\n'
case|:
name|sflags
operator||=
name|SGF
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|sflags
operator||=
name|SGG
expr_stmt|;
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|sflags
operator||=
name|SGP
expr_stmt|;
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|sflags
operator||=
name|SGR
expr_stmt|;
name|ibufp
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|sflags
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid command suffix"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
block|}
block|}
do|while
condition|(
name|sflags
operator|&&
operator|*
name|ibufp
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|sflags
operator|&&
operator|!
name|pat
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no previous substitution"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|sflags
operator|&
name|SGF
operator|)
condition|)
name|sgflag
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
operator|*
name|ibufp
operator|!=
literal|'\n'
operator|&&
operator|*
operator|(
name|ibufp
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid pattern delimiter"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|tpat
operator|=
name|pat
expr_stmt|;
name|spl1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|sflags
operator|||
operator|(
name|sflags
operator|&
name|SGR
operator|)
operator|)
operator|&&
operator|(
name|tpat
operator|=
name|optpat
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|tpat
operator|!=
name|pat
condition|)
block|{
if|if
condition|(
name|pat
condition|)
block|{
name|regfree
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|tpat
expr_stmt|;
name|patlock
operator|=
literal|1
expr_stmt|;
comment|/* reserve pattern */
block|}
elseif|else
if|if
condition|(
name|pat
operator|==
name|NULL
condition|)
block|{
comment|/* NOTREACHED */
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no previous substitution"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|spl0
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sflags
operator|&&
operator|(
name|sgflag
operator|=
name|getrhs
argument_list|(
name|glob
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|glob
condition|)
name|sgflag
operator||=
name|GLB
expr_stmt|;
else|else
name|sgflag
operator|&=
operator|~
name|GLB
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SGG
condition|)
name|sgflag
operator|^=
name|GSG
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SGP
condition|)
name|sgflag
operator|^=
name|GPR
operator|,
name|sgflag
operator|&=
operator|~
operator|(
name|GLS
operator||
name|GNP
operator|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
operator|*
name|ibufp
condition|)
block|{
case|case
literal|'p'
case|:
name|sgflag
operator||=
name|GPR
operator|,
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|sgflag
operator||=
name|GLS
operator|,
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|sgflag
operator||=
name|GNP
operator|,
name|ibufp
operator|++
expr_stmt|;
break|break;
default|default:
name|n
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|n
condition|)
do|;
if|if
condition|(
name|ckrange
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|glob
condition|)
name|ureset
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|subst
argument_list|(
name|pat
argument_list|,
name|sgflag
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|n
condition|)
name|modified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|ckrange
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|GETLINE3
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|glob
condition|)
name|ureset
argument_list|()
expr_stmt|;
if|if
condition|(
name|transfer
argument_list|(
name|num
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|modified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
name|undo
argument_list|(
name|glob
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot nest global commands"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|ibufp
operator|)
operator|==
literal|'q'
operator|||
name|n
operator|==
literal|'Q'
condition|)
block|{
name|gflag
operator|=
name|EOF
expr_stmt|;
name|ibufp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|ibufp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected command suffix"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fnp
operator|=
name|getfn
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
if|if
condition|(
name|nlines
operator|==
literal|0
operator|&&
operator|!
name|lastln
condition|)
name|line1
operator|=
name|line2
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ckrange
argument_list|(
literal|1
argument_list|,
name|lastln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|dfn
operator|==
literal|'\0'
operator|&&
operator|*
name|fnp
operator|!=
literal|'!'
condition|)
name|strcpy
argument_list|(
name|dfn
argument_list|,
name|fnp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BACKWARDS
if|if
condition|(
operator|*
name|fnp
operator|==
literal|'\0'
operator|&&
operator|*
name|dfn
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no current filename"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|num
operator|=
name|dowrite
argument_list|(
name|line1
argument_list|,
name|line2
argument_list|,
operator|*
name|fnp
condition|?
name|fnp
else|:
name|dfn
argument_list|,
operator|(
name|c
operator|==
literal|'W'
operator|)
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|num
operator|==
name|lastln
condition|)
name|modified
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|modified
operator|&&
operator|!
name|scripted
operator|&&
name|n
operator|==
literal|'q'
condition|)
name|gflag
operator|=
name|EMOD
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|VRFYCMD
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DES
name|des
operator|=
name|getkey
argument_list|()
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"crypt unavailable"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
endif|#
directive|endif
break|break;
case|case
literal|'z'
case|:
ifdef|#
directive|ifdef
name|BACKWARDS
if|if
condition|(
name|ckrange
argument_list|(
name|line1
operator|=
literal|1
argument_list|,
name|curln
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ckrange
argument_list|(
name|line1
operator|=
literal|1
argument_list|,
name|curln
operator|+
operator|!
name|glob
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
literal|'0'
operator|<
operator|*
name|ibufp
operator|&&
operator|*
name|ibufp
operator|<=
literal|'9'
condition|)
name|rows
operator|=
name|strtol
argument_list|(
name|ibufp
argument_list|,
operator|&
name|ibufp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
name|doprint
argument_list|(
name|line2
argument_list|,
name|min
argument_list|(
name|lastln
argument_list|,
name|line2
operator|+
name|rows
operator|-
literal|1
argument_list|)
argument_list|,
name|gflag
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|gflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|VRFYCMD
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|nlines
condition|?
name|line2
else|:
name|lastln
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
ifndef|#
directive|ifndef
name|VI_BANG
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|sflags
operator|=
name|getshcmd
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|VRFYCMD
argument_list|()
expr_stmt|;
if|if
condition|(
name|sflags
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|shcmd
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VI_BANG
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|system
argument_list|(
name|shcmd
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scripted
condition|)
name|printf
argument_list|(
literal|"!\n"
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|VI_BANG
block|}
if|if
condition|(
operator|!
name|lastln
operator|&&
operator|!
name|line1
operator|&&
operator|!
name|line2
condition|)
block|{
if|if
condition|(
operator|!
name|glob
condition|)
name|ureset
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ckrange
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
else|else
block|{
if|if
condition|(
operator|!
name|glob
condition|)
name|ureset
argument_list|()
expr_stmt|;
if|if
condition|(
name|lndelete
argument_list|(
name|line1
argument_list|,
name|line2
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|line2
operator|=
name|curln
expr_stmt|;
name|modified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|num
operator|=
name|doread
argument_list|(
name|line2
argument_list|,
name|shcmd
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|num
operator|&&
name|num
operator|!=
name|lastln
condition|)
name|modified
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'\n'
case|:
ifdef|#
directive|ifdef
name|BACKWARDS
if|if
condition|(
name|ckrange
argument_list|(
name|line1
operator|=
literal|1
argument_list|,
name|curln
operator|+
literal|1
argument_list|)
operator|<
literal|0
else|#
directive|else
if|if
condition|(
name|ckrange
argument_list|(
name|line1
operator|=
literal|1
argument_list|,
name|curln
operator|+
operator|!
name|glob
argument_list|)
operator|<
literal|0
endif|#
directive|endif
operator|||
name|doprint
argument_list|(
name|line2
argument_list|,
name|line2
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
break|break;
default|default:
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unknown command"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
return|return
name|gflag
return|;
block|}
end_block

begin_comment
comment|/* ckrange: return status of line number range check */
end_comment

begin_macro
name|ckrange
argument_list|(
argument|def1
argument_list|,
argument|def2
argument_list|)
end_macro

begin_decl_stmt
name|long
name|def1
decl_stmt|,
name|def2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
block|{
name|line1
operator|=
name|def1
expr_stmt|;
name|line2
operator|=
name|def2
expr_stmt|;
block|}
if|if
condition|(
name|line1
operator|>
name|line2
operator|||
literal|1
operator|>
name|line1
operator|||
name|line2
operator|>
name|lastln
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* patscan: return the number of the next line matching a pattern in a    given direction.  wrap around begin/end of line queue if necessary */
end_comment

begin_function
name|long
name|patscan
parameter_list|(
name|pat
parameter_list|,
name|dir
parameter_list|)
name|pattern_t
modifier|*
name|pat
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|long
name|n
init|=
name|curln
decl_stmt|;
name|line_t
modifier|*
name|lp
decl_stmt|;
do|do
block|{
if|if
condition|(
name|n
operator|=
name|dir
condition|?
name|nextln
argument_list|(
name|n
argument_list|,
name|lastln
argument_list|)
else|:
name|prevln
argument_list|(
name|n
argument_list|,
name|lastln
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|gettxt
argument_list|(
name|lp
operator|=
name|getlp
argument_list|(
name|n
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
if|if
condition|(
name|isbinary
condition|)
name|s
operator|=
name|nultonl
argument_list|(
name|s
argument_list|,
name|lp
operator|->
name|len
operator|&
operator|~
name|ACTV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regexec
argument_list|(
name|pat
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|n
return|;
block|}
block|}
do|while
condition|(
name|n
operator|!=
name|curln
condition|)
do|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no match"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
end_function

begin_comment
comment|/* getfn: return pointer to copy of filename in the command buffer */
end_comment

begin_function
name|char
modifier|*
name|getfn
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|filesz
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|ibufp
operator|!=
literal|'\n'
condition|)
block|{
name|skipblanks
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|ibufp
operator|==
literal|'\n'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid filename"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ibufp
operator|=
name|getcmdv
argument_list|(
operator|&
name|n
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|VI_BANG
elseif|else
if|if
condition|(
operator|*
name|ibufp
operator|==
literal|'!'
condition|)
block|{
name|ibufp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|getshcmd
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|n
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|shcmd
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|shcmd
return|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|n
operator|-
literal|1
operator|>
name|MAXFNAME
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"filename too long"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
ifndef|#
directive|ifndef
name|BACKWARDS
elseif|else
if|if
condition|(
operator|*
name|dfn
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no current filename"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
name|CKBUF
argument_list|(
name|file
argument_list|,
name|filesz
argument_list|,
name|MAXFNAME
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|*
name|ibufp
operator|!=
literal|'\n'
condition|;
control|)
name|file
index|[
name|n
operator|++
index|]
operator|=
operator|*
name|ibufp
operator|++
expr_stmt|;
name|file
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ckfn
argument_list|(
name|file
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* getrhs: extract substitution template from the command buffer */
end_comment

begin_macro
name|getrhs
argument_list|(
argument|glob
argument_list|)
end_macro

begin_decl_stmt
name|int
name|glob
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|delim
decl_stmt|;
if|if
condition|(
operator|(
name|delim
operator|=
operator|*
name|ibufp
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|rhbufi
operator|=
literal|0
expr_stmt|;
return|return
name|GPR
return|;
block|}
elseif|else
if|if
condition|(
name|makesub
argument_list|(
name|glob
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
operator|*
name|ibufp
operator|==
literal|'\n'
condition|)
return|return
name|GPR
return|;
elseif|else
if|if
condition|(
operator|*
name|ibufp
operator|==
name|delim
condition|)
name|ibufp
operator|++
expr_stmt|;
if|if
condition|(
literal|'1'
operator|<=
operator|*
name|ibufp
operator|&&
operator|*
name|ibufp
operator|<=
literal|'9'
condition|)
return|return
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|ibufp
argument_list|,
operator|&
name|ibufp
argument_list|,
literal|10
argument_list|)
operator|<<
literal|8
return|;
elseif|else
if|if
condition|(
operator|*
name|ibufp
operator|==
literal|'g'
condition|)
block|{
name|ibufp
operator|++
expr_stmt|;
return|return
name|GSG
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* makesub: return pointer to copy of substitution template in the command    buffer */
end_comment

begin_function
name|char
modifier|*
name|makesub
parameter_list|(
name|glob
parameter_list|)
name|int
name|glob
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
name|delim
init|=
operator|*
name|ibufp
operator|++
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|ibufp
operator|==
literal|'%'
operator|&&
operator|*
operator|(
name|ibufp
operator|+
literal|1
operator|)
operator|==
name|delim
condition|)
block|{
name|ibufp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|rhbuf
condition|)
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no previous substitution"
argument_list|)
expr_stmt|;
return|return
name|rhbuf
return|;
block|}
while|while
condition|(
operator|*
name|ibufp
operator|!=
name|delim
condition|)
block|{
name|CKBUF
argument_list|(
name|rhbuf
argument_list|,
name|rhbufsz
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|rhbuf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ibufp
operator|++
operator|)
operator|==
literal|'\n'
operator|&&
operator|*
name|ibufp
operator|==
literal|'\0'
condition|)
block|{
name|i
operator|--
operator|,
name|ibufp
operator|--
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rhbuf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ibufp
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|glob
condition|)
block|{
while|while
condition|(
operator|(
name|n
operator|=
name|getline
argument_list|()
operator|)
operator|==
literal|0
operator|||
name|n
operator|>
literal|0
operator|&&
name|ibuf
index|[
name|n
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
block|}
else|else
comment|/*NOTREACHED*/
empty_stmt|;
block|}
name|CKBUF
argument_list|(
name|rhbuf
argument_list|,
name|rhbufsz
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rhbuf
index|[
name|rhbufi
operator|=
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rhbuf
return|;
block|}
end_function

begin_comment
comment|/* getshcmd: read a shell command up a maximum size from stdin; return    substitution status */
end_comment

begin_function
name|int
name|getshcmd
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* substitution char pointer */
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|red
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"shell access restricted"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|=
name|ibufp
operator|=
name|getcmdv
argument_list|(
operator|&
name|j
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|CKBUF
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|j
operator|+
literal|1
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
literal|'!'
expr_stmt|;
comment|/* prefix command w/ bang */
while|while
condition|(
operator|*
name|ibufp
operator|!=
literal|'\n'
condition|)
switch|switch
condition|(
operator|*
name|ibufp
condition|)
block|{
default|default:
name|CKBUF
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ibufp
expr_stmt|;
if|if
condition|(
operator|*
name|ibufp
operator|++
operator|==
literal|'\\'
condition|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ibufp
operator|++
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|s
operator|!=
name|ibufp
condition|)
block|{
name|CKBUF
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ibufp
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BACKWARDS
elseif|else
if|if
condition|(
name|shcmd
operator|==
name|NULL
operator|||
operator|*
operator|(
name|shcmd
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
name|shcmd
operator|==
name|NULL
condition|)
endif|#
directive|endif
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no previous command"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
else|else
block|{
name|CKBUF
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|i
operator|+
name|shcmdi
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|shcmd
operator|+
literal|1
init|;
name|s
operator|<
name|shcmd
operator|+
name|shcmdi
condition|;
control|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|ibufp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
operator|*
name|dfn
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no current filename"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|j
operator|=
name|strlen
argument_list|(
name|s
operator|=
name|esctos
argument_list|(
name|dfn
argument_list|)
argument_list|)
expr_stmt|;
name|CKBUF
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|i
operator|+
name|j
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|ibufp
operator|++
expr_stmt|;
break|break;
block|}
name|CKBUF
argument_list|(
name|shcmd
argument_list|,
name|shcmdsz
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|shcmd
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|shcmd
index|[
name|shcmdi
operator|=
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|*
name|s
operator|==
literal|'!'
operator|||
operator|*
name|s
operator|==
literal|'%'
return|;
block|}
end_function

begin_comment
comment|/* append: insert text from stdin to after line n; stop when either a    single period is read or EOF; return status */
end_comment

begin_macro
name|append
argument_list|(
argument|n
argument_list|,
argument|glob
argument_list|)
end_macro

begin_decl_stmt
name|long
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|glob
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|l
decl_stmt|;
name|char
modifier|*
name|lp
init|=
name|ibuf
decl_stmt|;
name|char
modifier|*
name|eot
decl_stmt|;
name|undo_t
modifier|*
name|up
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|curln
operator|=
name|n
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|glob
condition|)
block|{
if|if
condition|(
operator|(
name|l
operator|=
name|getline
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|l
operator|==
literal|0
operator|||
name|ibuf
index|[
name|l
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
return|return
name|l
condition|?
name|EOF
else|:
literal|0
return|;
block|}
name|lp
operator|=
name|ibuf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|lp
operator|=
name|ibufp
operator|)
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
else|else
block|{
while|while
condition|(
operator|*
name|ibufp
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|l
operator|=
name|ibufp
operator|-
name|lp
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|==
literal|2
operator|&&
name|lp
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|lp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
return|return
literal|0
return|;
block|}
name|eot
operator|=
name|lp
operator|+
name|l
expr_stmt|;
name|spl1
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|lp
operator|=
name|puttxt
argument_list|(
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|up
condition|)
name|up
operator|->
name|t
operator|=
name|getlp
argument_list|(
name|curln
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|up
operator|=
name|upush
argument_list|(
name|UADD
argument_list|,
name|curln
argument_list|,
name|curln
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
block|}
do|while
condition|(
name|lp
operator|!=
name|eot
condition|)
do|;
name|spl0
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* subst: change all text matching a pattern in a range of lines according to    a substitution template; return status  */
end_comment

begin_macro
name|subst
argument_list|(
argument|pat
argument_list|,
argument|gflag
argument_list|)
end_macro

begin_decl_stmt
name|pattern_t
modifier|*
name|pat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|undo_t
modifier|*
name|up
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
name|char
modifier|*
name|eot
decl_stmt|;
name|long
name|lc
decl_stmt|;
name|int
name|nsubs
init|=
literal|0
decl_stmt|;
name|line_t
modifier|*
name|lp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|curln
operator|=
name|prevln
argument_list|(
name|line1
argument_list|,
name|lastln
argument_list|)
expr_stmt|;
for|for
control|(
name|lc
operator|=
literal|0
init|;
name|lc
operator|<=
name|line2
operator|-
name|line1
condition|;
name|lc
operator|++
control|)
block|{
name|lp
operator|=
name|getlp
argument_list|(
name|curln
operator|=
name|nextln
argument_list|(
name|curln
argument_list|,
name|lastln
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|regsub
argument_list|(
name|pat
argument_list|,
name|lp
argument_list|,
name|gflag
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
elseif|else
if|if
condition|(
name|len
condition|)
block|{
name|up
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lndelete
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|txt
operator|=
name|rbuf
expr_stmt|;
name|eot
operator|=
name|rbuf
operator|+
name|len
expr_stmt|;
name|spl1
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|txt
operator|=
name|puttxt
argument_list|(
name|txt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|up
condition|)
name|up
operator|->
name|t
operator|=
name|getlp
argument_list|(
name|curln
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|up
operator|=
name|upush
argument_list|(
name|UADD
argument_list|,
name|curln
argument_list|,
name|curln
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
block|}
do|while
condition|(
name|txt
operator|!=
name|eot
condition|)
do|;
name|spl0
argument_list|()
expr_stmt|;
name|nsubs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nsubs
operator|==
literal|0
operator|&&
operator|!
operator|(
name|gflag
operator|&
name|GLB
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"no match"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|gflag
operator|&
operator|(
name|GPR
operator||
name|GLS
operator||
name|GNP
operator|)
operator|)
operator|&&
name|doprint
argument_list|(
name|curln
argument_list|,
name|curln
argument_list|,
name|gflag
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* regsub: replace text matched by a pattern according to a substitution    template; return pointer to the modified text */
end_comment

begin_macro
name|regsub
argument_list|(
argument|pat
argument_list|,
argument|lp
argument_list|,
argument|gflag
argument_list|)
end_macro

begin_decl_stmt
name|pattern_t
modifier|*
name|pat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|line_t
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|kth
init|=
name|gflag
operator|>>
literal|8
decl_stmt|;
comment|/* substitute kth match only */
name|int
name|chngd
init|=
literal|0
decl_stmt|;
name|int
name|matchno
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|regmatch_t
name|rm
index|[
name|SE_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
name|char
modifier|*
name|eot
decl_stmt|;
if|if
condition|(
operator|(
name|txt
operator|=
name|gettxt
argument_list|(
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|len
operator|=
name|lp
operator|->
name|len
operator|&
operator|~
name|ACTV
expr_stmt|;
name|eot
operator|=
name|txt
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|isbinary
condition|)
name|txt
operator|=
name|nultonl
argument_list|(
name|txt
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regexec
argument_list|(
name|pat
argument_list|,
name|txt
argument_list|,
name|SE_MAX
argument_list|,
name|rm
argument_list|,
literal|0
argument_list|)
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|!
name|kth
operator|||
name|kth
operator|==
operator|++
name|matchno
condition|)
block|{
name|chngd
operator|++
expr_stmt|;
name|i
operator|=
name|rm
index|[
literal|0
index|]
operator|.
name|rm_so
expr_stmt|;
name|CKBUF
argument_list|(
name|rbuf
argument_list|,
name|rbufsz
argument_list|,
name|off
operator|+
name|i
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbinary
condition|)
name|txt
operator|=
name|nltonul
argument_list|(
name|txt
argument_list|,
name|rm
index|[
literal|0
index|]
operator|.
name|rm_eo
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rbuf
operator|+
name|off
argument_list|,
name|txt
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|=
name|catsub
argument_list|(
name|txt
argument_list|,
name|rm
argument_list|,
name|off
operator|+=
name|i
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
block|}
else|else
block|{
name|i
operator|=
name|rm
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
name|CKBUF
argument_list|(
name|rbuf
argument_list|,
name|rbufsz
argument_list|,
name|off
operator|+
name|i
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbinary
condition|)
name|txt
operator|=
name|nltonul
argument_list|(
name|txt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rbuf
operator|+
name|off
argument_list|,
name|txt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|off
operator|+=
name|i
expr_stmt|;
block|}
name|txt
operator|+=
name|rm
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|txt
operator|&&
operator|(
operator|!
name|chngd
operator|||
operator|(
name|gflag
operator|&
name|GSG
operator|)
operator|&&
name|rm
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|)
operator|&&
operator|!
name|regexec
argument_list|(
name|pat
argument_list|,
name|txt
argument_list|,
name|SE_MAX
argument_list|,
name|rm
argument_list|,
name|REG_NOTBOL
argument_list|)
condition|)
do|;
name|i
operator|=
name|eot
operator|-
name|txt
expr_stmt|;
name|CKBUF
argument_list|(
name|rbuf
argument_list|,
name|rbufsz
argument_list|,
name|off
operator|+
name|i
operator|+
literal|2
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|!
name|rm
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|&&
operator|(
name|gflag
operator|&
name|GSG
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"infinite substitution loop"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
if|if
condition|(
name|isbinary
condition|)
name|txt
operator|=
name|nltonul
argument_list|(
name|txt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rbuf
operator|+
name|off
argument_list|,
name|txt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rbuf
operator|+
name|off
operator|+
name|i
argument_list|,
literal|"\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|chngd
condition|?
name|off
operator|+
name|i
operator|+
literal|1
else|:
literal|0
return|;
block|}
end_block

begin_comment
comment|/* join: replace a range of lines with the joined text of those lines */
end_comment

begin_macro
name|join
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|long
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
name|line_t
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|getlp
argument_list|(
name|nextln
argument_list|(
name|to
argument_list|,
name|lastln
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|getlp
argument_list|(
name|from
argument_list|)
init|;
name|bp
operator|!=
name|ep
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
operator|,
name|size
operator|+=
name|len
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|gettxt
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|len
operator|=
name|bp
operator|->
name|len
operator|&
operator|~
name|ACTV
expr_stmt|;
name|CKBUF
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|size
operator|+
name|len
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|size
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|CKBUF
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|size
operator|+
literal|2
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|size
argument_list|,
literal|"\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lndelete
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERR
return|;
name|curln
operator|=
name|from
operator|-
literal|1
expr_stmt|;
name|spl1
argument_list|()
expr_stmt|;
if|if
condition|(
name|puttxt
argument_list|(
name|buf
argument_list|)
operator|==
name|NULL
operator|||
name|upush
argument_list|(
name|UADD
argument_list|,
name|curln
argument_list|,
name|curln
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|spl0
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* move: move a range of lines */
end_comment

begin_macro
name|move
argument_list|(
argument|num
argument_list|,
argument|glob
argument_list|)
end_macro

begin_decl_stmt
name|long
name|num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|glob
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|line_t
modifier|*
name|b1
decl_stmt|,
modifier|*
name|a1
decl_stmt|,
modifier|*
name|b2
decl_stmt|,
modifier|*
name|a2
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|long
name|n
init|=
name|nextln
argument_list|(
name|line2
argument_list|,
name|lastln
argument_list|)
decl_stmt|;
name|long
name|p
init|=
name|prevln
argument_list|(
name|line1
argument_list|,
name|lastln
argument_list|)
decl_stmt|;
name|int
name|done
init|=
operator|(
name|num
operator|==
name|line1
operator|-
literal|1
operator|||
name|num
operator|==
name|line2
operator|)
decl_stmt|;
name|spl1
argument_list|()
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|a2
operator|=
name|getlp
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|b2
operator|=
name|getlp
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|curln
operator|=
name|line2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|upush
argument_list|(
name|UMOV
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
operator|==
name|NULL
operator|||
name|upush
argument_list|(
name|UMOV
argument_list|,
name|num
argument_list|,
name|nextln
argument_list|(
name|num
argument_list|,
name|lastln
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
else|else
block|{
name|a1
operator|=
name|getlp
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|<
name|line1
condition|)
name|b1
operator|=
name|getlp
argument_list|(
name|p
argument_list|)
operator|,
name|b2
operator|=
name|getlp
argument_list|(
name|num
argument_list|)
expr_stmt|;
comment|/* this getlp last! */
else|else
name|b2
operator|=
name|getlp
argument_list|(
name|num
argument_list|)
operator|,
name|b1
operator|=
name|getlp
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* this getlp last! */
name|a2
operator|=
name|b2
operator|->
name|next
expr_stmt|;
name|requeue
argument_list|(
name|b2
argument_list|,
name|b1
operator|->
name|next
argument_list|)
expr_stmt|;
name|requeue
argument_list|(
name|a1
operator|->
name|prev
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|requeue
argument_list|(
name|b1
argument_list|,
name|a1
argument_list|)
expr_stmt|;
name|curln
operator|=
name|num
operator|+
operator|(
operator|(
name|num
operator|<
name|line1
operator|)
condition|?
name|line2
operator|-
name|line1
operator|+
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|glob
condition|)
for|for
control|(
name|lp
operator|=
name|b2
operator|->
name|next
init|;
name|lp
operator|!=
name|a2
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
name|lp
operator|->
name|len
operator|&=
operator|~
name|ACTV
expr_stmt|;
comment|/* zero ACTV  bit */
name|spl0
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* transfer: copy a range of lines; return status */
end_comment

begin_macro
name|transfer
argument_list|(
argument|num
argument_list|)
end_macro

begin_decl_stmt
name|long
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|line_t
modifier|*
name|lp
decl_stmt|;
name|long
name|nl
decl_stmt|,
name|nt
decl_stmt|,
name|lc
decl_stmt|;
name|long
name|mid
init|=
operator|(
name|num
operator|<
name|line2
operator|)
condition|?
name|num
else|:
name|line2
decl_stmt|;
name|undo_t
modifier|*
name|up
init|=
name|NULL
decl_stmt|;
name|curln
operator|=
name|num
expr_stmt|;
for|for
control|(
name|nt
operator|=
literal|0
operator|,
name|nl
operator|=
name|line1
init|;
name|nl
operator|<=
name|mid
condition|;
name|nl
operator|++
operator|,
name|nt
operator|++
control|)
block|{
name|spl1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|lpdup
argument_list|(
name|getlp
argument_list|(
name|nl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|lpqueue
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
condition|)
name|up
operator|->
name|t
operator|=
name|lp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|up
operator|=
name|upush
argument_list|(
name|UADD
argument_list|,
name|curln
argument_list|,
name|curln
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|spl0
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|nl
operator|+=
name|nt
operator|,
name|lc
operator|=
name|line2
operator|+
name|nt
init|;
name|nl
operator|<=
name|lc
condition|;
name|nl
operator|+=
literal|2
operator|,
name|lc
operator|++
control|)
block|{
name|spl1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|lpdup
argument_list|(
name|getlp
argument_list|(
name|nl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|lpqueue
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
condition|)
name|up
operator|->
name|t
operator|=
name|lp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|up
operator|=
name|upush
argument_list|(
name|UADD
argument_list|,
name|curln
argument_list|,
name|curln
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|spl0
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* lndelete: delete a range of lines */
end_comment

begin_macro
name|lndelete
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|long
name|from
decl_stmt|,
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|line_t
modifier|*
name|before
decl_stmt|,
modifier|*
name|after
decl_stmt|;
name|spl1
argument_list|()
expr_stmt|;
if|if
condition|(
name|upush
argument_list|(
name|UDEL
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|after
operator|=
name|getlp
argument_list|(
name|nextln
argument_list|(
name|to
argument_list|,
name|lastln
argument_list|)
argument_list|)
expr_stmt|;
name|before
operator|=
name|getlp
argument_list|(
name|prevln
argument_list|(
name|from
argument_list|,
name|lastln
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this getlp last! */
name|requeue
argument_list|(
name|before
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|lastln
operator|-=
name|to
operator|-
name|from
operator|+
literal|1
expr_stmt|;
name|curln
operator|=
name|prevln
argument_list|(
name|from
argument_list|,
name|lastln
argument_list|)
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* catsub: modify text according to a substitution template;    return offset to end of modified text */
end_comment

begin_macro
name|catsub
argument_list|(
argument|boln
argument_list|,
argument|rm
argument_list|,
argument|off
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|boln
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|regmatch_t
modifier|*
name|rm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|off
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|sub
init|=
name|rhbuf
decl_stmt|;
for|for
control|(
init|;
name|sub
operator|-
name|rhbuf
operator|<
name|rhbufi
condition|;
name|sub
operator|++
control|)
if|if
condition|(
operator|*
name|sub
operator|==
literal|'&'
condition|)
block|{
name|j
operator|=
name|rm
index|[
literal|0
index|]
operator|.
name|rm_so
expr_stmt|;
name|k
operator|=
name|rm
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
name|CKBUF
argument_list|(
name|rbuf
argument_list|,
name|rbufsz
argument_list|,
name|off
operator|+
name|k
operator|-
name|j
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|k
condition|)
name|rbuf
index|[
name|off
operator|++
index|]
operator|=
name|boln
index|[
name|j
operator|++
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sub
operator|==
literal|'\\'
operator|&&
literal|'1'
operator|<=
operator|*
operator|++
name|sub
operator|&&
operator|*
name|sub
operator|<=
literal|'9'
operator|&&
name|rm
index|[
operator|*
name|sub
operator|-
literal|'0'
index|]
operator|.
name|rm_so
operator|>=
literal|0
operator|&&
name|rm
index|[
operator|*
name|sub
operator|-
literal|'0'
index|]
operator|.
name|rm_eo
operator|>=
literal|0
condition|)
block|{
name|j
operator|=
name|rm
index|[
operator|*
name|sub
operator|-
literal|'0'
index|]
operator|.
name|rm_so
expr_stmt|;
name|k
operator|=
name|rm
index|[
operator|*
name|sub
operator|-
literal|'0'
index|]
operator|.
name|rm_eo
expr_stmt|;
name|CKBUF
argument_list|(
name|rbuf
argument_list|,
name|rbufsz
argument_list|,
name|off
operator|+
name|k
operator|-
name|j
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|k
condition|)
name|rbuf
index|[
name|off
operator|++
index|]
operator|=
name|boln
index|[
name|j
operator|++
index|]
expr_stmt|;
block|}
else|else
block|{
name|CKBUF
argument_list|(
name|rbuf
argument_list|,
name|rbufsz
argument_list|,
name|off
operator|+
literal|1
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|rbuf
index|[
name|off
operator|++
index|]
operator|=
operator|*
name|sub
expr_stmt|;
block|}
name|CKBUF
argument_list|(
name|rbuf
argument_list|,
name|rbufsz
argument_list|,
name|off
operator|+
literal|1
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
name|rbuf
index|[
name|off
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|off
return|;
block|}
end_block

begin_comment
comment|/* doprint: print a range of lines to stdout */
end_comment

begin_macro
name|doprint
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|gflag
argument_list|)
end_macro

begin_decl_stmt
name|long
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|line_t
modifier|*
name|bp
decl_stmt|;
name|line_t
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|from
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid address"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|ep
operator|=
name|getlp
argument_list|(
name|nextln
argument_list|(
name|to
argument_list|,
name|lastln
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|getlp
argument_list|(
name|from
argument_list|)
init|;
name|bp
operator|!=
name|ep
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|gettxt
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|putstr
argument_list|(
name|s
argument_list|,
name|bp
operator|->
name|len
operator|&
operator|~
name|ACTV
argument_list|,
name|curln
operator|=
name|from
operator|++
argument_list|,
name|gflag
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_decl_stmt
name|int
name|cols
init|=
literal|72
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wrap column: ws_col - 8 */
end_comment

begin_comment
comment|/* putstr: print text to stdout */
end_comment

begin_function
name|void
name|putstr
parameter_list|(
name|s
parameter_list|,
name|l
parameter_list|,
name|n
parameter_list|,
name|gflag
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
decl_stmt|;
name|long
name|n
decl_stmt|;
name|int
name|gflag
decl_stmt|;
block|{
name|int
name|col
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|gflag
operator|&
name|GNP
condition|)
block|{
name|printf
argument_list|(
literal|"%ld\t"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|col
operator|=
literal|8
expr_stmt|;
block|}
for|for
control|(
init|;
name|l
operator|--
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|gflag
operator|&
name|GLS
operator|)
operator|&&
operator|++
name|col
operator|>
name|cols
condition|)
block|{
name|fputs
argument_list|(
literal|"\\\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|col
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gflag
operator|&
name|GLS
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\b'
case|:
name|fputs
argument_list|(
literal|"\\b"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs
argument_list|(
literal|"\\f"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs
argument_list|(
literal|"\\r"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs
argument_list|(
literal|"\\t"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|fputs
argument_list|(
literal|"\\v"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|*
name|s
operator|<
literal|32
operator|||
literal|126
operator|<
operator|*
name|s
condition|)
block|{
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|&
literal|0300
operator|)
operator|>>
literal|6
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|&
literal|070
operator|)
operator|>>
literal|3
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|fputs
argument_list|(
literal|"\\\\"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|col
operator|--
expr_stmt|;
block|}
block|}
name|col
operator|++
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|BACKWARDS
if|if
condition|(
name|gflag
operator|&
name|GLS
condition|)
name|putchar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|newline_added
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if newline appended to input file */
end_comment

begin_comment
comment|/* doread: read a text file into the editor buffer; return line count */
end_comment

begin_function
name|long
name|doread
parameter_list|(
name|n
parameter_list|,
name|fn
parameter_list|)
name|long
name|n
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|line_t
modifier|*
name|lp
init|=
name|getlp
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|size
init|=
literal|0
decl_stmt|;
name|undo_t
modifier|*
name|up
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|isbinary
operator|=
name|newline_added
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
operator|(
operator|*
name|fn
operator|==
literal|'!'
operator|)
condition|?
name|popen
argument_list|(
name|fn
operator|+
literal|1
argument_list|,
literal|"r"
argument_list|)
else|:
name|fopen
argument_list|(
name|esctos
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot open input file"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|des
condition|)
name|desinit
argument_list|()
expr_stmt|;
for|for
control|(
name|curln
operator|=
name|n
init|;
operator|(
name|len
operator|=
name|sgetline
argument_list|(
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|;
name|size
operator|+=
name|len
control|)
block|{
name|spl1
argument_list|()
expr_stmt|;
if|if
condition|(
name|puttxt
argument_list|(
name|sbuf
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|lp
operator|=
name|lp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|up
condition|)
name|up
operator|->
name|t
operator|=
name|lp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|up
operator|=
name|upush
argument_list|(
name|UADD
argument_list|,
name|curln
argument_list|,
name|curln
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|spl0
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
operator|*
name|fn
operator|==
literal|'!'
operator|)
condition|?
name|pclose
argument_list|(
name|fp
argument_list|)
else|:
name|fclose
argument_list|(
name|fp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot close input file"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
if|if
condition|(
name|newline_added
operator|&&
operator|!
name|isbinary
condition|)
name|fputs
argument_list|(
literal|"newline appended\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|des
condition|)
name|size
operator|+=
literal|8
operator|-
name|size
operator|%
literal|8
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|!
name|scripted
condition|?
literal|"%lu\n"
else|:
literal|""
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|<
literal|0
operator|)
condition|?
name|ERR
else|:
name|curln
operator|-
name|n
return|;
block|}
end_function

begin_comment
comment|/* dowrite: write the text of a range of lines to a file; return line count */
end_comment

begin_function
name|long
name|dowrite
parameter_list|(
name|n
parameter_list|,
name|m
parameter_list|,
name|fn
parameter_list|,
name|mode
parameter_list|)
name|long
name|n
decl_stmt|;
name|long
name|m
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|line_t
modifier|*
name|lp
decl_stmt|;
name|unsigned
name|long
name|size
init|=
literal|0
decl_stmt|;
name|long
name|lc
init|=
name|n
condition|?
name|m
operator|-
name|n
operator|+
literal|1
else|:
literal|0
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|ct
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
operator|(
operator|(
operator|*
name|fn
operator|==
literal|'!'
operator|)
condition|?
name|popen
argument_list|(
name|fn
operator|+
literal|1
argument_list|,
literal|"w"
argument_list|)
else|:
name|fopen
argument_list|(
name|esctos
argument_list|(
name|fn
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot open output file"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|des
condition|)
name|desinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|&&
operator|!
name|des
condition|)
for|for
control|(
name|lp
operator|=
name|getlp
argument_list|(
name|n
argument_list|)
init|;
name|n
operator|<=
name|m
condition|;
name|n
operator|++
operator|,
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|gettxt
argument_list|(
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|len
operator|=
name|lp
operator|->
name|len
operator|&
operator|~
name|ACTV
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|lastln
operator|||
operator|!
name|isbinary
operator|||
operator|!
name|newline_added
condition|)
name|s
index|[
name|len
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
operator|(
name|ct
operator|=
name|fwrite
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|ct
operator|!=
name|len
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot write file"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|size
operator|+=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
condition|)
for|for
control|(
name|lp
operator|=
name|getlp
argument_list|(
name|n
argument_list|)
init|;
name|n
operator|<=
name|m
condition|;
name|n
operator|++
operator|,
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|gettxt
argument_list|(
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
name|len
operator|=
name|lp
operator|->
name|len
operator|&
operator|~
name|ACTV
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|desputc
argument_list|(
operator|*
name|s
operator|++
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
operator|&&
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot write file"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
name|lastln
operator|||
operator|!
name|isbinary
operator|||
operator|!
name|newline_added
condition|)
block|{
if|if
condition|(
name|desputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot write file"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|size
operator|++
expr_stmt|;
comment|/* for '\n' */
block|}
name|size
operator|+=
operator|(
name|lp
operator|->
name|len
operator|&
operator|~
name|ACTV
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|des
condition|)
block|{
name|desflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* flush buffer */
name|size
operator|+=
literal|8
operator|-
name|size
operator|%
literal|8
expr_stmt|;
comment|/* adjust DES size */
block|}
if|if
condition|(
operator|(
operator|(
operator|*
name|fn
operator|==
literal|'!'
operator|)
condition|?
name|pclose
argument_list|(
name|fp
argument_list|)
else|:
name|fclose
argument_list|(
name|fp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot close output file"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|!
name|scripted
condition|?
literal|"%lu\n"
else|:
literal|""
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|lc
return|;
block|}
end_function

begin_define
define|#
directive|define
name|USIZE
value|100
end_define

begin_comment
comment|/* undo stack size */
end_comment

begin_decl_stmt
name|undo_t
modifier|*
name|ustack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* undo stack */
end_comment

begin_decl_stmt
name|long
name|usize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack size variable */
end_comment

begin_decl_stmt
name|long
name|u_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* undo stack pointer */
end_comment

begin_comment
comment|/* upush: return pointer to intialized undo node */
end_comment

begin_function
name|undo_t
modifier|*
name|upush
parameter_list|(
name|type
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|type
decl_stmt|;
name|long
name|from
decl_stmt|;
name|long
name|to
decl_stmt|;
block|{
name|undo_t
modifier|*
name|t
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_REALLOC_NULL
argument_list|)
if|if
condition|(
name|ustack
operator|==
name|NULL
operator|&&
operator|(
name|ustack
operator|=
operator|(
name|undo_t
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|usize
operator|=
name|USIZE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|undo_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
name|t
operator|=
name|ustack
expr_stmt|;
if|if
condition|(
name|u_p
operator|<
name|usize
operator|||
operator|(
name|t
operator|=
operator|(
name|undo_t
operator|*
operator|)
name|realloc
argument_list|(
name|ustack
argument_list|,
operator|(
name|usize
operator|+=
name|USIZE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|undo_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ustack
operator|=
name|t
expr_stmt|;
name|ustack
index|[
name|u_p
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|ustack
index|[
name|u_p
index|]
operator|.
name|t
operator|=
name|getlp
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|ustack
index|[
name|u_p
index|]
operator|.
name|h
operator|=
name|getlp
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
name|ustack
operator|+
name|u_p
operator|++
return|;
block|}
comment|/* out of memory - release undo stack */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ureset
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ustack
argument_list|)
expr_stmt|;
name|ustack
operator|=
name|NULL
expr_stmt|;
name|usize
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* USWAP: swap undo nodes */
end_comment

begin_define
define|#
directive|define
name|USWAP
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{ \ 	undo_t utmp; \ 	utmp = x, x = y, y = utmp; \ }
end_define

begin_comment
comment|/* undo: undo last change to the editor buffer */
end_comment

begin_macro
name|undo
argument_list|(
argument|glob
argument_list|)
end_macro

begin_decl_stmt
name|int
name|glob
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|n
decl_stmt|;
name|long
name|ocurln
init|=
name|curln
decl_stmt|;
name|long
name|olastln
init|=
name|lastln
decl_stmt|;
name|line_t
modifier|*
name|lp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|ucurln
operator|==
operator|-
literal|1
operator|||
name|ulastln
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"nothing to undo"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|u_p
condition|)
name|modified
operator|=
literal|1
expr_stmt|;
name|getlp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* this getlp last! */
name|spl1
argument_list|()
expr_stmt|;
for|for
control|(
name|n
operator|=
name|u_p
init|;
name|n
operator|--
operator|>
literal|0
condition|;
control|)
block|{
switch|switch
condition|(
name|ustack
index|[
name|n
index|]
operator|.
name|type
condition|)
block|{
case|case
name|UADD
case|:
name|requeue
argument_list|(
name|ustack
index|[
name|n
index|]
operator|.
name|h
operator|->
name|prev
argument_list|,
name|ustack
index|[
name|n
index|]
operator|.
name|t
operator|->
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDEL
case|:
name|requeue
argument_list|(
name|ustack
index|[
name|n
index|]
operator|.
name|h
operator|->
name|prev
argument_list|,
name|ustack
index|[
name|n
index|]
operator|.
name|h
argument_list|)
expr_stmt|;
name|requeue
argument_list|(
name|ustack
index|[
name|n
index|]
operator|.
name|t
argument_list|,
name|ustack
index|[
name|n
index|]
operator|.
name|t
operator|->
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMOV
case|:
case|case
name|VMOV
case|:
name|requeue
argument_list|(
name|ustack
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|h
argument_list|,
name|ustack
index|[
name|n
index|]
operator|.
name|h
operator|->
name|next
argument_list|)
expr_stmt|;
name|requeue
argument_list|(
name|ustack
index|[
name|n
index|]
operator|.
name|t
operator|->
name|prev
argument_list|,
name|ustack
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|t
argument_list|)
expr_stmt|;
name|requeue
argument_list|(
name|ustack
index|[
name|n
index|]
operator|.
name|h
argument_list|,
name|ustack
index|[
name|n
index|]
operator|.
name|t
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
break|break;
default|default:
comment|/*NOTREACHED*/
empty_stmt|;
block|}
name|ustack
index|[
name|n
index|]
operator|.
name|type
operator|^=
literal|1
expr_stmt|;
block|}
comment|/* reverse undo order */
for|for
control|(
name|n
operator|=
name|u_p
init|;
name|n
operator|--
operator|>
operator|(
name|u_p
operator|+
literal|1
operator|)
operator|/
literal|2
condition|;
control|)
name|USWAP
argument_list|(
name|ustack
index|[
name|n
index|]
argument_list|,
name|ustack
index|[
name|u_p
operator|-
literal|1
operator|-
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|glob
condition|)
for|for
control|(
name|lp
operator|=
name|np
operator|=
name|getlp
argument_list|(
literal|0
argument_list|)
init|;
operator|(
name|lp
operator|=
name|lp
operator|->
name|next
operator|)
operator|!=
name|np
condition|;
control|)
name|lp
operator|->
name|len
operator|&=
operator|~
name|ACTV
expr_stmt|;
comment|/* zero ACTV bit */
name|curln
operator|=
name|ucurln
operator|,
name|ucurln
operator|=
name|ocurln
expr_stmt|;
name|lastln
operator|=
name|ulastln
operator|,
name|ulastln
operator|=
name|olastln
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* ureset: clear the undo stack */
end_comment

begin_function
name|void
name|ureset
parameter_list|()
block|{
name|line_t
modifier|*
name|lp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
while|while
condition|(
name|u_p
operator|--
condition|)
if|if
condition|(
name|ustack
index|[
name|u_p
index|]
operator|.
name|type
operator|==
name|UDEL
condition|)
block|{
name|ep
operator|=
name|ustack
index|[
name|u_p
index|]
operator|.
name|t
operator|->
name|next
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|ustack
index|[
name|u_p
index|]
operator|.
name|h
init|;
name|lp
operator|!=
name|ep
condition|;
name|lp
operator|=
name|tl
control|)
block|{
name|clrmark
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|tl
operator|=
name|lp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
block|}
name|u_p
operator|=
literal|0
expr_stmt|;
name|ucurln
operator|=
name|curln
expr_stmt|;
name|ulastln
operator|=
name|lastln
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXMARK
value|26
end_define

begin_comment
comment|/* max number of marks */
end_comment

begin_decl_stmt
name|line_t
modifier|*
name|mark
index|[
name|MAXMARK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line markers */
end_comment

begin_decl_stmt
name|int
name|markno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line marker count */
end_comment

begin_comment
comment|/* getmark: return address of a marked line */
end_comment

begin_function
name|long
name|getmark
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|islower
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid mark character"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
return|return
name|getaddr
argument_list|(
name|mark
index|[
name|n
operator|-
literal|'a'
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* putmark: set a line node mark */
end_comment

begin_function
name|int
name|putmark
parameter_list|(
name|n
parameter_list|,
name|lp
parameter_list|)
name|int
name|n
decl_stmt|;
name|line_t
modifier|*
name|lp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|islower
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"invalid mark character"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|mark
index|[
name|n
operator|-
literal|'a'
index|]
operator|==
name|NULL
condition|)
name|markno
operator|++
expr_stmt|;
name|mark
index|[
name|n
operator|-
literal|'a'
index|]
operator|=
name|lp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* clrmark: clear line node marks */
end_comment

begin_function
name|void
name|clrmark
parameter_list|(
name|lp
parameter_list|)
name|line_t
modifier|*
name|lp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|markno
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMARK
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mark
index|[
name|i
index|]
operator|==
name|lp
condition|)
block|{
name|mark
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|markno
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* sgetline: read a line of text up a maximum size from a file; return    line length */
end_comment

begin_macro
name|sgetline
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|des
condition|?
name|desgetc
argument_list|(
name|fp
argument_list|)
else|:
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|||
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|CKBUF
argument_list|(
name|sbuf
argument_list|,
name|sbufsz
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sbuf
index|[
name|i
operator|++
index|]
operator|=
name|c
operator|)
condition|)
name|isbinary
operator|=
literal|1
expr_stmt|;
block|}
name|CKBUF
argument_list|(
name|sbuf
argument_list|,
name|sbufsz
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|sbuf
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
name|i
condition|)
block|{
name|sbuf
index|[
name|i
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|newline_added
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot read input file"
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
name|sbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|isbinary
operator|&&
name|newline_added
operator|&&
name|i
operator|)
condition|?
operator|--
name|i
else|:
name|i
return|;
block|}
end_block

begin_comment
comment|/* getline: read a line of text up a maximum size from stdin; return    line length */
end_comment

begin_macro
name|getline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|oi
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Read one character at a time to avoid i/o contention with shell 	   escapes invoked by nonterminal input, e.g., 	   ed -<<EOF 	   !cat 	   hello, world 	   EOF */
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
condition|)
block|{
default|default:
name|oi
operator|=
literal|0
expr_stmt|;
name|CKBUF
argument_list|(
name|ibuf
argument_list|,
name|ibufsz
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|ERR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ibuf
index|[
name|i
operator|++
index|]
operator|=
name|c
operator|)
condition|)
name|isbinary
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
continue|continue;
name|lineno
operator|++
expr_stmt|;
comment|/* script line no. */
name|ibuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ibufp
operator|=
name|ibuf
expr_stmt|;
return|return
name|i
return|;
case|case
literal|0
case|:
if|if
condition|(
name|i
operator|!=
name|oi
condition|)
block|{
name|oi
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|i
condition|)
name|ibuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ibufp
operator|=
name|ibuf
expr_stmt|;
return|return
name|i
return|;
case|case
operator|-
literal|1
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"cannot read standard input"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|ibufp
operator|=
name|NULL
expr_stmt|;
return|return
name|ERR
return|;
block|}
block|}
end_block

begin_comment
comment|/* getcmdv: get a command vector */
end_comment

begin_function
name|char
modifier|*
name|getcmdv
parameter_list|(
name|sizep
parameter_list|,
name|nonl
parameter_list|)
name|int
modifier|*
name|sizep
decl_stmt|;
name|int
name|nonl
decl_stmt|;
block|{
name|int
name|l
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|t
init|=
name|ibufp
decl_stmt|;
while|while
condition|(
operator|*
name|t
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|l
operator|=
name|t
operator|-
name|ibufp
operator|)
operator|<
literal|2
operator|||
operator|!
name|oddesc
argument_list|(
name|ibufp
argument_list|,
name|ibufp
operator|+
name|l
operator|-
literal|1
argument_list|)
condition|)
block|{
operator|*
name|sizep
operator|=
name|l
expr_stmt|;
return|return
name|ibufp
return|;
block|}
operator|*
name|sizep
operator|=
operator|-
literal|1
expr_stmt|;
name|CKBUF
argument_list|(
name|cvbuf
argument_list|,
name|cvbufsz
argument_list|,
name|l
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cvbuf
argument_list|,
name|ibufp
argument_list|,
name|l
argument_list|)
expr_stmt|;
operator|*
operator|(
name|cvbuf
operator|+
operator|--
name|l
operator|-
literal|1
operator|)
operator|=
literal|'\n'
expr_stmt|;
comment|/* strip trailing esc */
if|if
condition|(
name|nonl
condition|)
name|l
operator|--
expr_stmt|;
comment|/* strip newline */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|getline
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|ibuf
index|[
name|n
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"unexpected end-of-file"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|CKBUF
argument_list|(
name|cvbuf
argument_list|,
name|cvbufsz
argument_list|,
name|l
operator|+
name|n
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cvbuf
operator|+
name|l
argument_list|,
name|ibuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|l
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|2
operator|||
operator|!
name|oddesc
argument_list|(
name|cvbuf
argument_list|,
name|cvbuf
operator|+
name|l
operator|-
literal|1
argument_list|)
condition|)
break|break;
operator|*
operator|(
name|cvbuf
operator|+
operator|--
name|l
operator|-
literal|1
operator|)
operator|=
literal|'\n'
expr_stmt|;
comment|/* strip trailing esc */
if|if
condition|(
name|nonl
condition|)
name|l
operator|--
expr_stmt|;
comment|/* strip newline */
block|}
name|CKBUF
argument_list|(
name|cvbuf
argument_list|,
name|cvbufsz
argument_list|,
name|l
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvbuf
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|sizep
operator|=
name|l
expr_stmt|;
return|return
name|cvbuf
return|;
block|}
end_function

begin_comment
comment|/* lpdup: return a pointer to a copy of a line node */
end_comment

begin_function
name|line_t
modifier|*
name|lpdup
parameter_list|(
name|lp
parameter_list|)
name|line_t
modifier|*
name|lp
decl_stmt|;
block|{
name|line_t
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
operator|(
name|line_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|line_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|np
operator|->
name|seek
operator|=
name|lp
operator|->
name|seek
expr_stmt|;
name|np
operator|->
name|len
operator|=
operator|(
name|lp
operator|->
name|len
operator|&
operator|~
name|ACTV
operator|)
expr_stmt|;
comment|/* zero ACTV bit */
return|return
name|np
return|;
block|}
end_function

begin_comment
comment|/* oddesc:  return the parity of escapes preceding a character in a    string */
end_comment

begin_macro
name|oddesc
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|s
operator|==
name|t
operator|||
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
operator|!=
literal|'\\'
operator|)
condition|?
literal|0
else|:
operator|!
name|oddesc
argument_list|(
name|s
argument_list|,
name|t
operator|-
literal|1
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* esctos: return copy of escaped string */
end_comment

begin_function
name|char
modifier|*
name|esctos
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|filesz
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|CKBUF
argument_list|(
name|file
argument_list|,
name|filesz
argument_list|,
name|MAXFNAME
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* assert: no trailing escape */
while|while
condition|(
name|file
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|*
name|s
operator|==
literal|'\\'
operator|)
condition|?
operator|*
operator|++
name|s
else|:
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
return|return
name|file
return|;
block|}
end_function

begin_function
name|void
name|onhup
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|if
condition|(
name|mutex
condition|)
name|sigflags
operator||=
operator|(
literal|1
operator|<<
name|signo
operator|)
expr_stmt|;
else|else
name|dohup
argument_list|(
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|onintr
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|if
condition|(
name|mutex
condition|)
name|sigflags
operator||=
operator|(
literal|1
operator|<<
name|signo
operator|)
expr_stmt|;
else|else
name|dointr
argument_list|(
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dohup
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|char
modifier|*
name|hup
init|=
name|NULL
decl_stmt|;
comment|/* hup filename */
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|sigactive
condition|)
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sigflags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|signo
operator|)
expr_stmt|;
if|if
condition|(
name|lastln
operator|&&
name|dowrite
argument_list|(
literal|1
argument_list|,
name|lastln
argument_list|,
literal|"ed.hup"
argument_list|,
literal|"w"
argument_list|)
operator|<
literal|0
operator|&&
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
operator|+
literal|8
operator|<=
name|MAXFNAME
comment|/* "ed.hup" + '/' */
operator|&&
operator|(
name|hup
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|+
literal|10
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|hup
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|hup
index|[
name|n
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|hup
index|[
name|n
index|]
operator|=
literal|'/'
operator|,
name|hup
index|[
name|n
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|hup
argument_list|,
literal|"ed.hup"
argument_list|)
expr_stmt|;
name|dowrite
argument_list|(
literal|1
argument_list|,
name|lastln
argument_list|,
name|hup
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
name|quit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dointr
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|sigactive
condition|)
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sigflags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|signo
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
name|siglongjmp
argument_list|(
name|env
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|longjmp
argument_list|(
name|env
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|struct
name|winsize
name|ws
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* window size structure */
end_comment

begin_function
name|void
name|dowinch
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|sigflags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|signo
operator|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ws
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ws
operator|.
name|ws_row
operator|>
literal|2
condition|)
name|rows
operator|=
name|ws
operator|.
name|ws_row
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|ws
operator|.
name|ws_col
operator|>
literal|8
condition|)
name|cols
operator|=
name|ws
operator|.
name|ws_col
operator|-
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ckfn: return a legal filename */
end_comment

begin_function
name|char
modifier|*
name|ckfn
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|red
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'!'
operator|||
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
literal|".."
argument_list|)
operator|||
name|strchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"shell access restricted"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|s
return|;
block|}
end_function

end_unit

