begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2008 Apple Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1.  Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  * 2.  Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  * 3.  Neither the name of Apple Inc. ("Apple") nor the names of  *     its contributors may be used to endorse or promote products derived  *     from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $P4: //depot/projects/trustedbsd/openbsm/bin/auditd/auditd_darwin.c#2 $  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<config/config.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit.h>
end_include

begin_include
include|#
directive|include
file|<bsm/audit_uevents.h>
end_include

begin_include
include|#
directive|include
file|<bsm/auditd_lib.h>
end_include

begin_include
include|#
directive|include
file|<bsm/libbsm.h>
end_include

begin_include
include|#
directive|include
file|<asl.h>
end_include

begin_include
include|#
directive|include
file|<launch.h>
end_include

begin_include
include|#
directive|include
file|<notify.h>
end_include

begin_include
include|#
directive|include
file|<mach/port.h>
end_include

begin_include
include|#
directive|include
file|<mach/mach_error.h>
end_include

begin_include
include|#
directive|include
file|<mach/mach_traps.h>
end_include

begin_include
include|#
directive|include
file|<mach/mach.h>
end_include

begin_include
include|#
directive|include
file|<mach/host_special_ports.h>
end_include

begin_include
include|#
directive|include
file|"auditd.h"
end_include

begin_include
include|#
directive|include
file|"auditd_controlServer.h"
end_include

begin_include
include|#
directive|include
file|"audit_triggersServer.h"
end_include

begin_comment
comment|/*  * Apple System Logger Handles.  */
end_comment

begin_decl_stmt
specifier|static
name|aslmsg
name|au_aslmsg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|aslclient
name|au_aslclient
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mach_port_t
name|control_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mach_port_t
name|signal_port
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mach_port_t
name|port_set
init|=
name|MACH_PORT_NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Current auditing state (cache).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|auditing_state
init|=
name|AUD_STATE_INIT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Maximum idle time before auditd terminates under launchd.  * If it is zero then auditd does not timeout while idle.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_idletime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__BSM_INTERNAL_NOTIFY_KEY
end_ifndef

begin_define
define|#
directive|define
name|__BSM_INTERNAL_NOTIFY_KEY
value|"com.apple.audit.change"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __BSM_INTERNAL_NOTIFY_KEY */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__AUDIT_LAUNCHD_LABEL
end_ifndef

begin_define
define|#
directive|define
name|__AUDIT_LAUNCHD_LABEL
value|"org.trustedbsd.auditd"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __AUDIT_LAUNCHD_LABEL */
end_comment

begin_define
define|#
directive|define
name|MAX_MSG_SIZE
value|4096
end_define

begin_comment
comment|/*  * Open and set up system logging.  */
end_comment

begin_function
name|void
name|auditd_openlog
parameter_list|(
name|int
name|debug
parameter_list|,
name|gid_t
name|gid
parameter_list|)
block|{
name|uint32_t
name|opt
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|opt
operator|=
name|ASL_OPT_STDERR
expr_stmt|;
name|au_aslclient
operator|=
name|asl_open
argument_list|(
literal|"auditd"
argument_list|,
literal|"org.trustedbsd.auditd"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|au_aslmsg
operator|=
name|asl_new
argument_list|(
name|ASL_TYPE_MSG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASL_KEY_READ_UID
comment|/* 	 * Make it only so the audit administrator and members of the audit 	 * review group (if used) have access to the auditd system log messages. 	 */
name|asl_set
argument_list|(
name|au_aslmsg
argument_list|,
name|ASL_KEY_READ_UID
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|cp
argument_list|,
literal|"%u"
argument_list|,
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|ASL_KEY_READ_GID
name|asl_set
argument_list|(
name|au_aslmsg
argument_list|,
name|ASL_KEY_READ_GID
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Set the client-side system log filtering. 	 */
if|if
condition|(
name|debug
condition|)
name|asl_set_filter
argument_list|(
name|au_aslclient
argument_list|,
name|ASL_FILTER_MASK_UPTO
argument_list|(
name|ASL_LEVEL_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|asl_set_filter
argument_list|(
name|au_aslclient
argument_list|,
name|ASL_FILTER_MASK_UPTO
argument_list|(
name|ASL_LEVEL_INFO
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log messages at different priority levels.   */
end_comment

begin_function
name|void
name|auditd_log_err
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|asl_vlog
argument_list|(
name|au_aslclient
argument_list|,
name|au_aslmsg
argument_list|,
name|ASL_LEVEL_ERR
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|auditd_log_notice
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|asl_vlog
argument_list|(
name|au_aslclient
argument_list|,
name|au_aslmsg
argument_list|,
name|ASL_LEVEL_NOTICE
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|auditd_log_info
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|asl_vlog
argument_list|(
name|au_aslclient
argument_list|,
name|au_aslmsg
argument_list|,
name|ASL_LEVEL_INFO
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|auditd_log_debug
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|asl_vlog
argument_list|(
name|au_aslclient
argument_list|,
name|au_aslmsg
argument_list|,
name|ASL_LEVEL_DEBUG
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the auditing state from the kernel and cache it.  */
end_comment

begin_function
specifier|static
name|void
name|init_audit_state
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|au_cond
decl_stmt|;
if|if
condition|(
name|auditon
argument_list|(
name|A_GETCOND
argument_list|,
operator|&
name|au_cond
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOSYS
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Audit status check failed (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|auditing_state
operator|=
name|AUD_STATE_DISABLED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|au_cond
operator|==
name|AUC_NOAUDIT
operator|||
name|au_cond
operator|==
name|AUC_DISABLED
condition|)
name|auditing_state
operator|=
name|AUD_STATE_DISABLED
expr_stmt|;
else|else
name|auditing_state
operator|=
name|AUD_STATE_ENABLED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the cached auditing state.  Let other tasks that may be caching it  * as well to update their state via notify(3).  */
end_comment

begin_function
name|void
name|auditd_set_state
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|int
name|old_auditing_state
init|=
name|auditing_state
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|AUD_STATE_INIT
condition|)
name|init_audit_state
argument_list|()
expr_stmt|;
else|else
name|auditing_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|auditing_state
operator|!=
name|old_auditing_state
condition|)
block|{
name|notify_post
argument_list|(
name|__BSM_INTERNAL_NOTIFY_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|auditing_state
operator|==
name|AUD_STATE_ENABLED
condition|)
name|auditd_log_notice
argument_list|(
literal|"Auditing enabled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|auditing_state
operator|==
name|AUD_STATE_DISABLED
condition|)
name|auditd_log_notice
argument_list|(
literal|"Auditing disabled"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get the cached auditing state.  */
end_comment

begin_function
name|int
name|auditd_get_state
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|auditing_state
operator|==
name|AUD_STATE_INIT
condition|)
block|{
name|init_audit_state
argument_list|()
expr_stmt|;
name|notify_post
argument_list|(
name|__BSM_INTERNAL_NOTIFY_KEY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|auditing_state
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the audit mach port in the launchd dictionary.  */
end_comment

begin_function
specifier|static
name|mach_port_t
name|lookup_machport
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|launch_data_t
name|msg
decl_stmt|,
name|msd
decl_stmt|,
name|ld
decl_stmt|,
name|cdict
decl_stmt|,
name|to
decl_stmt|;
name|mach_port_t
name|mp
init|=
name|MACH_PORT_NULL
decl_stmt|;
name|msg
operator|=
name|launch_data_new_string
argument_list|(
name|LAUNCH_KEY_CHECKIN
argument_list|)
expr_stmt|;
name|cdict
operator|=
name|launch_msg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdict
operator|==
name|NULL
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"launch_msg(\""
name|LAUNCH_KEY_CHECKIN
literal|"\") IPC failure: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
name|MACH_PORT_NULL
operator|)
return|;
block|}
if|if
condition|(
name|launch_data_get_type
argument_list|(
name|cdict
argument_list|)
operator|==
name|LAUNCH_DATA_ERRNO
condition|)
block|{
name|errno
operator|=
name|launch_data_get_errno
argument_list|(
name|cdict
argument_list|)
expr_stmt|;
name|auditd_log_err
argument_list|(
literal|"launch_data_get_type() can't get dict: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
name|MACH_PORT_NULL
operator|)
return|;
block|}
name|to
operator|=
name|launch_data_dict_lookup
argument_list|(
name|cdict
argument_list|,
name|LAUNCH_JOBKEY_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
condition|)
block|{
name|max_idletime
operator|=
name|launch_data_get_integer
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|auditd_log_debug
argument_list|(
literal|"launchd timeout set to %d"
argument_list|,
name|max_idletime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|auditd_log_debug
argument_list|(
literal|"launchd timeout not set, setting to 60"
argument_list|)
expr_stmt|;
name|max_idletime
operator|=
literal|60
expr_stmt|;
block|}
name|msd
operator|=
name|launch_data_dict_lookup
argument_list|(
name|cdict
argument_list|,
name|LAUNCH_JOBKEY_MACHSERVICES
argument_list|)
expr_stmt|;
if|if
condition|(
name|msd
operator|==
name|NULL
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"launch_data_dict_lookup() can't get mach services"
argument_list|)
expr_stmt|;
return|return
operator|(
name|MACH_PORT_NULL
operator|)
return|;
block|}
name|ld
operator|=
name|launch_data_dict_lookup
argument_list|(
name|msd
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|==
name|NULL
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"launch_data_dict_lookup can't find %s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
name|MACH_PORT_NULL
operator|)
return|;
block|}
name|mp
operator|=
name|launch_data_get_machport
argument_list|(
name|ld
argument_list|)
expr_stmt|;
return|return
operator|(
name|mp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mach_setup
parameter_list|(
name|int
name|launchd_flag
parameter_list|)
block|{
name|mach_msg_type_name_t
name|poly
decl_stmt|;
comment|/* 	 * Allocate a port set. 	 */
if|if
condition|(
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_PORT_SET
argument_list|,
operator|&
name|port_set
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Allocation of port set failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Allocate a signal reflection port. 	 */
if|if
condition|(
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|signal_port
argument_list|)
operator|!=
name|KERN_SUCCESS
operator|||
name|mach_port_move_member
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|signal_port
argument_list|,
name|port_set
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Allocation of signal port failed"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Allocate a trigger port. 	 */
if|if
condition|(
name|launchd_flag
condition|)
block|{
comment|/* 		 * If started under launchd, lookup port in launchd dictionary. 		 */
if|if
condition|(
operator|(
name|control_port
operator|=
name|lookup_machport
argument_list|(
name|__AUDIT_LAUNCHD_LABEL
argument_list|)
operator|)
operator|==
name|MACH_PORT_NULL
operator|||
name|mach_port_move_member
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|control_port
argument_list|,
name|port_set
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Cannot get Mach control port"
literal|" via launchd"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
name|auditd_log_debug
argument_list|(
literal|"Mach control port registered"
literal|" via launchd"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If not started under launchd, allocate port and register. 		 */
if|if
condition|(
name|mach_port_allocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|MACH_PORT_RIGHT_RECEIVE
argument_list|,
operator|&
name|control_port
argument_list|)
operator|!=
name|KERN_SUCCESS
operator|||
name|mach_port_move_member
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|control_port
argument_list|,
name|port_set
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
name|auditd_log_err
argument_list|(
literal|"Allocation of trigger port failed"
argument_list|)
expr_stmt|;
comment|/* 		 * Create a send right on our trigger port. 		 */
name|mach_port_extract_right
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
name|control_port
argument_list|,
name|MACH_MSG_TYPE_MAKE_SEND
argument_list|,
operator|&
name|control_port
argument_list|,
operator|&
name|poly
argument_list|)
expr_stmt|;
comment|/* 		 * Register the trigger port with the kernel. 		 */
if|if
condition|(
name|host_set_audit_control_port
argument_list|(
name|mach_host_self
argument_list|()
argument_list|,
name|control_port
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|auditd_log_err
argument_list|(
literal|"Cannot set Mach control port"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
name|auditd_log_debug
argument_list|(
literal|"Mach control port registered"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open the trigger messaging mechanism.  */
end_comment

begin_function
name|int
name|auditd_open_trigger
parameter_list|(
name|int
name|launchd_flag
parameter_list|)
block|{
return|return
operator|(
name|mach_setup
argument_list|(
name|launchd_flag
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the trigger messaging mechanism.  */
end_comment

begin_function
name|int
name|auditd_close_trigger
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Combined server handler.  Called by the mach message loop when there is  * a trigger or signal message.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|auditd_combined_server
parameter_list|(
name|mach_msg_header_t
modifier|*
name|InHeadP
parameter_list|,
name|mach_msg_header_t
modifier|*
name|OutHeadP
parameter_list|)
block|{
name|mach_port_t
name|local_port
init|=
name|InHeadP
operator|->
name|msgh_local_port
decl_stmt|;
comment|/* Reset the idle time alarm, if used. */
if|if
condition|(
name|max_idletime
condition|)
name|alarm
argument_list|(
name|max_idletime
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_port
operator|==
name|signal_port
condition|)
block|{
name|int
name|signo
init|=
name|InHeadP
operator|->
name|msgh_id
decl_stmt|;
switch|switch
condition|(
name|signo
condition|)
block|{
case|case
name|SIGTERM
case|:
case|case
name|SIGALRM
case|:
name|auditd_terminate
argument_list|()
expr_stmt|;
comment|/* Not reached. */
case|case
name|SIGCHLD
case|:
name|auditd_reap_children
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|SIGHUP
case|:
name|auditd_config_controls
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
default|default:
name|auditd_log_info
argument_list|(
literal|"Received signal %d"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|local_port
operator|==
name|control_port
condition|)
block|{
name|boolean_t
name|result
decl_stmt|;
name|result
operator|=
name|audit_triggers_server
argument_list|(
name|InHeadP
argument_list|,
name|OutHeadP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
name|auditd_control_server
argument_list|(
name|InHeadP
argument_list|,
name|OutHeadP
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|auditd_log_info
argument_list|(
literal|"Recevied msg on bad port 0x%x."
argument_list|,
name|local_port
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The main event loop.  Wait for trigger messages or signals and handle them.  * It should not return unless there is a problem.  */
end_comment

begin_function
name|void
name|auditd_wait_for_events
parameter_list|(
name|void
parameter_list|)
block|{
name|kern_return_t
name|result
decl_stmt|;
comment|/* 	 * Call the mach messaging server loop.  	 */
name|result
operator|=
name|mach_msg_server
argument_list|(
name|auditd_combined_server
argument_list|,
name|MAX_MSG_SIZE
argument_list|,
name|port_set
argument_list|,
name|MACH_MSG_OPTION_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implementation of the audit_triggers() MIG simpleroutine.  Simply a   * wrapper function.  This handles input from the kernel on the host  * special mach port.  */
end_comment

begin_function
name|kern_return_t
name|audit_triggers
parameter_list|(
name|mach_port_t
name|__unused
name|audit_port
parameter_list|,
name|int
name|trigger
parameter_list|)
block|{
name|auditd_handle_trigger
argument_list|(
name|trigger
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implementation of the auditd_control() MIG simpleroutine.  Simply a   * wrapper function.  This handles input from the audit(1) tool.  */
end_comment

begin_function
name|kern_return_t
name|auditd_control
parameter_list|(
name|mach_port_t
name|__unused
name|auditd_port
parameter_list|,
name|int
name|trigger
parameter_list|)
block|{
name|auditd_handle_trigger
argument_list|(
name|trigger
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When we get a signal, we are often not at a clean point.  So, little can  * be done in the signal handler itself.  Instead,  we send a message to the  * main servicing loop to do proper handling from a non-signal-handler  * context.  */
end_comment

begin_function
name|void
name|auditd_relay_signal
parameter_list|(
name|int
name|signal
parameter_list|)
block|{
name|mach_msg_empty_send_t
name|msg
decl_stmt|;
name|msg
operator|.
name|header
operator|.
name|msgh_id
operator|=
name|signal
expr_stmt|;
name|msg
operator|.
name|header
operator|.
name|msgh_remote_port
operator|=
name|signal_port
expr_stmt|;
name|msg
operator|.
name|header
operator|.
name|msgh_local_port
operator|=
name|MACH_PORT_NULL
expr_stmt|;
name|msg
operator|.
name|header
operator|.
name|msgh_bits
operator|=
name|MACH_MSGH_BITS
argument_list|(
name|MACH_MSG_TYPE_MAKE_SEND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mach_msg
argument_list|(
operator|&
operator|(
name|msg
operator|.
name|header
operator|)
argument_list|,
name|MACH_SEND_MSG
operator||
name|MACH_SEND_TIMEOUT
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|0
argument_list|,
name|MACH_PORT_NULL
argument_list|,
name|MACH_MSG_TIMEOUT_NONE
argument_list|,
name|MACH_PORT_NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

