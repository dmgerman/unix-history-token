begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Kenneth Almquist.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)var.c	8.3 (Berkeley) 5/4/95";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_comment
comment|/*  * Shell variables.  */
end_comment

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expand.h"
end_include

begin_include
include|#
directive|include
file|"nodes.h"
end_include

begin_comment
comment|/* for other headers */
end_comment

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_comment
comment|/* defines cmdenviron */
end_comment

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"mail.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_include
include|#
directive|include
file|"memalloc.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"mystring.h"
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_HISTORY
end_ifndef

begin_include
include|#
directive|include
file|"myhistedit.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VTABSIZE
value|39
end_define

begin_struct
struct|struct
name|varinit
block|{
name|struct
name|var
modifier|*
name|var
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|NO_HISTORY
end_ifndef

begin_decl_stmt
name|struct
name|var
name|vhistsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vterm
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|var
name|vifs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vmail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vmpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vps1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vps2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vps4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|var
name|voptind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vdisvfork
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|localvar
modifier|*
name|localvars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|forcelocal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|varinit
name|varinit
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|NO_HISTORY
block|{
operator|&
name|vhistsize
block|,
name|VUNSET
block|,
literal|"HISTSIZE="
block|,
name|sethistsize
block|}
block|,
endif|#
directive|endif
block|{
operator|&
name|vifs
block|,
literal|0
block|,
literal|"IFS= \t\n"
block|,
name|NULL
block|}
block|,
block|{
operator|&
name|vmail
block|,
name|VUNSET
block|,
literal|"MAIL="
block|,
name|NULL
block|}
block|,
block|{
operator|&
name|vmpath
block|,
name|VUNSET
block|,
literal|"MAILPATH="
block|,
name|NULL
block|}
block|,
block|{
operator|&
name|vpath
block|,
literal|0
block|,
literal|"PATH="
name|_PATH_DEFPATH
block|,
name|changepath
block|}
block|,
comment|/* 	 * vps1 depends on uid 	 */
block|{
operator|&
name|vps2
block|,
literal|0
block|,
literal|"PS2=> "
block|,
name|NULL
block|}
block|,
block|{
operator|&
name|vps4
block|,
literal|0
block|,
literal|"PS4=+ "
block|,
name|NULL
block|}
block|,
ifndef|#
directive|ifndef
name|NO_HISTORY
block|{
operator|&
name|vterm
block|,
name|VUNSET
block|,
literal|"TERM="
block|,
name|setterm
block|}
block|,
endif|#
directive|endif
block|{
operator|&
name|voptind
block|,
literal|0
block|,
literal|"OPTIND=1"
block|,
name|getoptsreset
block|}
block|,
block|{
operator|&
name|vdisvfork
block|,
name|VUNSET
block|,
literal|"SH_DISABLE_VFORK="
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|var
modifier|*
name|vartab
index|[
name|VTABSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|locale_names
index|[
literal|7
index|]
init|=
block|{
literal|"LC_COLLATE"
block|,
literal|"LC_CTYPE"
block|,
literal|"LC_MONETARY"
block|,
literal|"LC_NUMERIC"
block|,
literal|"LC_TIME"
block|,
literal|"LC_MESSAGES"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|locale_categories
index|[
literal|7
index|]
init|=
block|{
name|LC_COLLATE
block|,
name|LC_CTYPE
block|,
name|LC_MONETARY
block|,
name|LC_NUMERIC
block|,
name|LC_TIME
block|,
name|LC_MESSAGES
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|varequal
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|var
modifier|*
name|find_var
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|var
modifier|*
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|localevar
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setvareq_const
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine initializes the builtin variables and imports the environment.  * It is called when the shell is initialized.  */
end_comment

begin_function
name|void
name|initvar
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|ppid
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|struct
name|varinit
modifier|*
name|ip
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|varinit
init|;
operator|(
name|vp
operator|=
name|ip
operator|->
name|var
operator|)
operator|!=
name|NULL
condition|;
name|ip
operator|++
control|)
block|{
if|if
condition|(
name|find_var
argument_list|(
name|ip
operator|->
name|text
argument_list|,
operator|&
name|vpp
argument_list|,
operator|&
name|vp
operator|->
name|name_len
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
name|vp
operator|->
name|next
operator|=
operator|*
name|vpp
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|text
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|ip
operator|->
name|text
argument_list|)
expr_stmt|;
name|vp
operator|->
name|flags
operator|=
name|ip
operator|->
name|flags
operator||
name|VSTRFIXED
operator||
name|VTEXTFIXED
expr_stmt|;
name|vp
operator|->
name|func
operator|=
name|ip
operator|->
name|func
expr_stmt|;
block|}
comment|/* 	 * PS1 depends on uid 	 */
if|if
condition|(
name|find_var
argument_list|(
literal|"PS1"
argument_list|,
operator|&
name|vpp
argument_list|,
operator|&
name|vps1
operator|.
name|name_len
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|vps1
operator|.
name|next
operator|=
operator|*
name|vpp
expr_stmt|;
operator|*
name|vpp
operator|=
operator|&
name|vps1
expr_stmt|;
name|vps1
operator|.
name|text
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|geteuid
argument_list|()
condition|?
literal|"PS1=$ "
else|:
literal|"PS1=# "
argument_list|)
expr_stmt|;
name|vps1
operator|.
name|flags
operator|=
name|VSTRFIXED
operator||
name|VTEXTFIXED
expr_stmt|;
block|}
name|fmtstr
argument_list|(
name|ppid
argument_list|,
sizeof|sizeof
argument_list|(
name|ppid
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|getppid
argument_list|()
argument_list|)
expr_stmt|;
name|setvarsafe
argument_list|(
literal|"PPID"
argument_list|,
name|ppid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|envp
operator|=
name|environ
init|;
operator|*
name|envp
condition|;
name|envp
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
operator|*
name|envp
argument_list|,
literal|'='
argument_list|)
condition|)
block|{
name|setvareq
argument_list|(
operator|*
name|envp
argument_list|,
name|VEXPORT
operator||
name|VTEXTFIXED
argument_list|)
expr_stmt|;
block|}
block|}
name|setvareq_const
argument_list|(
literal|"OPTIND=1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setvareq_const
argument_list|(
literal|"IFS= \t\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Safe version of setvar, returns 1 on success 0 on failure.  */
end_comment

begin_function
name|int
name|setvarsafe
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|jmploc
name|jmploc
decl_stmt|;
name|struct
name|jmploc
modifier|*
specifier|const
name|savehandler
init|=
name|handler
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|inton
decl_stmt|;
name|inton
operator|=
name|is_int_on
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmploc
operator|.
name|loc
argument_list|)
condition|)
name|err
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|handler
operator|=
operator|&
name|jmploc
expr_stmt|;
name|setvar
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|handler
operator|=
name|savehandler
expr_stmt|;
name|SETINTON
argument_list|(
name|inton
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Set the value of a variable.  The flags argument is stored with the  * flags of the variable.  If val is NULL, the variable is unset.  */
end_comment

begin_function
name|void
name|setvar
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|size_t
name|vallen
decl_stmt|;
name|char
modifier|*
name|nameeq
decl_stmt|;
name|int
name|isbad
decl_stmt|;
name|isbad
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|is_name
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|isbad
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|is_in_name
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'='
condition|)
break|break;
name|isbad
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
name|namelen
operator|=
name|p
operator|-
name|name
expr_stmt|;
if|if
condition|(
name|isbad
condition|)
name|error
argument_list|(
literal|"%.*s: bad variable name"
argument_list|,
operator|(
name|int
operator|)
name|namelen
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|namelen
operator|+
literal|2
expr_stmt|;
comment|/* 2 is space for '=' and '\0' */
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
name|flags
operator||=
name|VUNSET
expr_stmt|;
name|vallen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|vallen
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|len
operator|+=
name|vallen
expr_stmt|;
block|}
name|INTOFF
expr_stmt|;
name|nameeq
operator|=
name|ckmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nameeq
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|nameeq
index|[
name|namelen
index|]
operator|=
literal|'='
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|memcpy
argument_list|(
name|nameeq
operator|+
name|namelen
operator|+
literal|1
argument_list|,
name|val
argument_list|,
name|vallen
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|nameeq
index|[
name|namelen
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|setvareq
argument_list|(
name|nameeq
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|localevar
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|ss
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'L'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|varequal
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"ANG"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"C_"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|varequal
argument_list|(
name|s
operator|+
literal|3
argument_list|,
literal|"ALL"
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|ss
operator|=
name|locale_names
init|;
operator|*
name|ss
condition|;
name|ss
operator|++
control|)
if|if
condition|(
name|varequal
argument_list|(
name|s
operator|+
literal|3
argument_list|,
operator|*
name|ss
operator|+
literal|3
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Sets/unsets an environment variable from a pointer that may actually be a  * pointer into environ where the string should not be manipulated.  */
end_comment

begin_function
specifier|static
name|void
name|change_env
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|char
modifier|*
name|eqp
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|;
name|INTOFF
expr_stmt|;
name|ss
operator|=
name|savestr
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eqp
operator|=
name|strchr
argument_list|(
name|ss
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|eqp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|eqp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|setenv
argument_list|(
name|ss
argument_list|,
name|eqp
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|unsetenv
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Same as setvar except that the variable and value are passed in  * the first argument as name=value.  Since the first argument will  * be actually stored in the table, it should not be a string that  * will go away.  */
end_comment

begin_function
name|void
name|setvareq
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|var
modifier|*
name|vp
decl_stmt|,
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|int
name|nlen
decl_stmt|;
if|if
condition|(
name|aflag
condition|)
name|flags
operator||=
name|VEXPORT
expr_stmt|;
if|if
condition|(
name|forcelocal
operator|&&
operator|!
operator|(
name|flags
operator|&
operator|(
name|VNOSET
operator||
name|VNOLOCAL
operator|)
operator|)
condition|)
name|mklocal
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vp
operator|=
name|find_var
argument_list|(
name|s
argument_list|,
operator|&
name|vpp
argument_list|,
operator|&
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|flags
operator|&
name|VREADONLY
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|VTEXTFIXED
operator||
name|VSTACK
operator|)
operator|)
operator|==
literal|0
condition|)
name|ckfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%.*s: is read only"
argument_list|,
name|vp
operator|->
name|name_len
argument_list|,
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|VNOSET
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|VTEXTFIXED
operator||
name|VSTACK
operator|)
operator|)
operator|==
literal|0
condition|)
name|ckfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|INTOFF
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|func
operator|&&
operator|(
name|flags
operator|&
name|VNOFUNC
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|vp
operator|->
name|func
call|)
argument_list|(
name|s
operator|+
name|vp
operator|->
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
operator|(
name|VTEXTFIXED
operator||
name|VSTACK
operator|)
operator|)
operator|==
literal|0
condition|)
name|ckfree
argument_list|(
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
name|vp
operator|->
name|flags
operator|&=
operator|~
operator|(
name|VTEXTFIXED
operator||
name|VSTACK
operator||
name|VUNSET
operator|)
expr_stmt|;
name|vp
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
name|vp
operator|->
name|text
operator|=
name|s
expr_stmt|;
comment|/* 		 * We could roll this to a function, to handle it as 		 * a regular variable function callback, but why bother? 		 * 		 * Note: this assumes iflag is not set to 1 initially. 		 * As part of initvar(), this is called before arguments 		 * are looked at. 		 */
if|if
condition|(
operator|(
name|vp
operator|==
operator|&
name|vmpath
operator|||
operator|(
name|vp
operator|==
operator|&
name|vmail
operator|&&
operator|!
name|mpathset
argument_list|()
operator|)
operator|)
operator|&&
name|iflag
operator|==
literal|1
condition|)
name|chkmail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|&&
name|localevar
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|change_env
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|updatecharset
argument_list|()
expr_stmt|;
block|}
name|INTON
expr_stmt|;
return|return;
block|}
comment|/* not found */
if|if
condition|(
name|flags
operator|&
name|VNOSET
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|VTEXTFIXED
operator||
name|VSTACK
operator|)
operator|)
operator|==
literal|0
condition|)
name|ckfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|INTOFF
expr_stmt|;
name|vp
operator|=
name|ckmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|vp
operator|->
name|text
operator|=
name|s
expr_stmt|;
name|vp
operator|->
name|name_len
operator|=
name|nlen
expr_stmt|;
name|vp
operator|->
name|next
operator|=
operator|*
name|vpp
expr_stmt|;
name|vp
operator|->
name|func
operator|=
name|NULL
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|&&
name|localevar
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|change_env
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|updatecharset
argument_list|()
expr_stmt|;
block|}
name|INTON
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setvareq_const
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|setvareq
argument_list|(
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|s
argument_list|)
argument_list|,
name|flags
operator||
name|VTEXTFIXED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a linked list of variable assignments.  */
end_comment

begin_function
name|void
name|listsetvar
parameter_list|(
name|struct
name|arglist
modifier|*
name|list
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|INTOFF
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|count
condition|;
name|i
operator|++
control|)
name|setvareq
argument_list|(
name|savestr
argument_list|(
name|list
operator|->
name|args
index|[
name|i
index|]
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the value of a variable.  Returns NULL if not set.  */
end_comment

begin_function
name|char
modifier|*
name|lookupvar
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|var
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|find_var
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
operator|||
name|v
operator|->
name|flags
operator|&
name|VUNSET
condition|)
return|return
name|NULL
return|;
return|return
name|v
operator|->
name|text
operator|+
name|v
operator|->
name|name_len
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Search the environment of a builtin command.  If the second argument  * is nonzero, return the value of a variable even if it hasn't been  * exported.  */
end_comment

begin_function
name|char
modifier|*
name|bltinlookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|doall
parameter_list|)
block|{
name|struct
name|var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmdenviron
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmdenviron
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|varequal
argument_list|(
name|cmdenviron
operator|->
name|args
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
condition|)
name|result
operator|=
name|strchr
argument_list|(
name|cmdenviron
operator|->
name|args
index|[
name|i
index|]
argument_list|,
literal|'='
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|v
operator|=
name|find_var
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
operator|||
name|v
operator|->
name|flags
operator|&
name|VUNSET
operator|||
operator|(
operator|!
name|doall
operator|&&
operator|(
name|v
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|v
operator|->
name|text
operator|+
name|v
operator|->
name|name_len
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Set up locale for a builtin (LANG/LC_* assignments).  */
end_comment

begin_function
name|void
name|bltinsetlocale
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|act
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|loc
decl_stmt|,
modifier|*
name|locdef
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cmdenviron
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmdenviron
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|localevar
argument_list|(
name|cmdenviron
operator|->
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|act
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|act
condition|)
return|return;
name|loc
operator|=
name|bltinlookup
argument_list|(
literal|"LC_ALL"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INTOFF
expr_stmt|;
if|if
condition|(
name|loc
operator|!=
name|NULL
condition|)
block|{
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
name|updatecharset
argument_list|()
expr_stmt|;
return|return;
block|}
name|locdef
operator|=
name|bltinlookup
argument_list|(
literal|"LANG"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|locale_names
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|loc
operator|=
name|bltinlookup
argument_list|(
name|locale_names
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|NULL
condition|)
name|loc
operator|=
name|locdef
expr_stmt|;
if|if
condition|(
name|loc
operator|!=
name|NULL
condition|)
name|setlocale
argument_list|(
name|locale_categories
index|[
name|i
index|]
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|INTON
expr_stmt|;
name|updatecharset
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Undo the effect of bltinlocaleset().  */
end_comment

begin_function
name|void
name|bltinunsetlocale
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|INTOFF
expr_stmt|;
if|if
condition|(
name|cmdenviron
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmdenviron
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|localevar
argument_list|(
name|cmdenviron
operator|->
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|updatecharset
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|INTON
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the localeisutf8 flag.  */
end_comment

begin_function
name|void
name|updatecharset
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|charset
decl_stmt|;
name|charset
operator|=
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
expr_stmt|;
name|localeisutf8
operator|=
operator|!
name|strcmp
argument_list|(
name|charset
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|initcharset
parameter_list|(
name|void
parameter_list|)
block|{
name|updatecharset
argument_list|()
expr_stmt|;
name|initial_localeisutf8
operator|=
name|localeisutf8
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a list of exported variables.  This routine is used to construct  * the third argument to execve when executing a program.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|environment
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nenv
decl_stmt|;
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
name|nenv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vpp
operator|=
name|vartab
init|;
name|vpp
operator|<
name|vartab
operator|+
name|VTABSIZE
condition|;
name|vpp
operator|++
control|)
block|{
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
if|if
condition|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
condition|)
name|nenv
operator|++
expr_stmt|;
block|}
name|ep
operator|=
name|env
operator|=
name|stalloc
argument_list|(
operator|(
name|nenv
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|env
argument_list|)
expr_stmt|;
for|for
control|(
name|vpp
operator|=
name|vartab
init|;
name|vpp
operator|<
name|vartab
operator|+
name|VTABSIZE
condition|;
name|vpp
operator|++
control|)
block|{
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
if|if
condition|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
condition|)
operator|*
name|ep
operator|++
operator|=
name|vp
operator|->
name|text
expr_stmt|;
block|}
operator|*
name|ep
operator|=
name|NULL
expr_stmt|;
return|return
name|env
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|var_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|sa
decl_stmt|,
modifier|*
decl_stmt|const
modifier|*
name|sb
decl_stmt|;
name|sa
operator|=
name|a
expr_stmt|;
name|sb
operator|=
name|b
expr_stmt|;
comment|/* 	 * This compares two var=value strings which creates a different 	 * order from what you would probably expect.  POSIX is somewhat 	 * ambiguous on what should be sorted exactly. 	 */
return|return
name|strcoll
argument_list|(
operator|*
name|sa
argument_list|,
operator|*
name|sb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Command to list all variables which are set.  This is invoked from the  * set command when it is called without any options or operands.  */
end_comment

begin_function
name|int
name|showvarscmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|vars
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/* 	 * POSIX requires us to sort the variables. 	 */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vpp
operator|=
name|vartab
init|;
name|vpp
operator|<
name|vartab
operator|+
name|VTABSIZE
condition|;
name|vpp
operator|++
control|)
block|{
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|vp
operator|->
name|flags
operator|&
name|VUNSET
operator|)
condition|)
name|n
operator|++
expr_stmt|;
block|}
block|}
name|INTOFF
expr_stmt|;
name|vars
operator|=
name|ckmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vars
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vpp
operator|=
name|vartab
init|;
name|vpp
operator|<
name|vartab
operator|+
name|VTABSIZE
condition|;
name|vpp
operator|++
control|)
block|{
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|vp
operator|->
name|flags
operator|&
name|VUNSET
operator|)
condition|)
name|vars
index|[
name|i
operator|++
index|]
operator|=
name|vp
operator|->
name|text
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|vars
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vars
argument_list|)
argument_list|,
name|var_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Skip improper variable names so the output remains usable as 		 * shell input. 		 */
if|if
condition|(
operator|!
name|isassignment
argument_list|(
name|vars
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|s
operator|=
name|strchr
argument_list|(
name|vars
index|[
name|i
index|]
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|outbin
argument_list|(
name|vars
index|[
name|i
index|]
argument_list|,
name|s
operator|-
name|vars
index|[
name|i
index|]
argument_list|,
name|out1
argument_list|)
expr_stmt|;
name|out1qstr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|out1c
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
name|vars
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The export and readonly commands.  */
end_comment

begin_function
name|int
name|exportcmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cmdname
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|values
decl_stmt|;
name|int
name|flag
init|=
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'r'
condition|?
name|VREADONLY
else|:
name|VEXPORT
decl_stmt|;
name|cmdname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|values
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|nextopt
argument_list|(
literal|"p"
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'p'
case|:
name|values
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|values
operator|&&
operator|*
name|argptr
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|"-p requires no arguments"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|argptr
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|ap
operator|=
name|argptr
init|;
operator|(
name|name
operator|=
operator|*
name|ap
operator|)
operator|!=
name|NULL
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|=
name|find_var
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|vp
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|&&
name|localevar
argument_list|(
name|vp
operator|->
name|text
argument_list|)
condition|)
block|{
name|change_env
argument_list|(
name|vp
operator|->
name|text
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|updatecharset
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
block|}
name|setvar
argument_list|(
name|name
argument_list|,
name|p
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|vpp
operator|=
name|vartab
init|;
name|vpp
operator|<
name|vartab
operator|+
name|VTABSIZE
condition|;
name|vpp
operator|++
control|)
block|{
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|vp
operator|->
name|flags
operator|&
name|flag
condition|)
block|{
if|if
condition|(
name|values
condition|)
block|{
comment|/* 						 * Skip improper variable names 						 * so the output remains usable 						 * as shell input. 						 */
if|if
condition|(
operator|!
name|isassignment
argument_list|(
name|vp
operator|->
name|text
argument_list|)
condition|)
continue|continue;
name|out1str
argument_list|(
name|cmdname
argument_list|)
expr_stmt|;
name|out1c
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|values
operator|&&
operator|!
operator|(
name|vp
operator|->
name|flags
operator|&
name|VUNSET
operator|)
condition|)
block|{
name|outbin
argument_list|(
name|vp
operator|->
name|text
argument_list|,
name|vp
operator|->
name|name_len
operator|+
literal|1
argument_list|,
name|out1
argument_list|)
expr_stmt|;
name|out1qstr
argument_list|(
name|vp
operator|->
name|text
operator|+
name|vp
operator|->
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|outbin
argument_list|(
name|vp
operator|->
name|text
argument_list|,
name|vp
operator|->
name|name_len
argument_list|,
name|out1
argument_list|)
expr_stmt|;
name|out1c
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The "local" command.  */
end_comment

begin_function
name|int
name|localcmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|nextopt
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_function
argument_list|()
condition|)
name|error
argument_list|(
literal|"Not in a function"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|name
operator|=
operator|*
name|argptr
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mklocal
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Make a variable a local variable.  When a variable is made local, it's  * value and flags are saved in a localvar structure.  The saved values  * will be restored when the shell function returns.  We handle the name  * "-" as a special case.  */
end_comment

begin_function
name|void
name|mklocal
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|localvar
modifier|*
name|lvp
decl_stmt|;
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|INTOFF
expr_stmt|;
name|lvp
operator|=
name|ckmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|localvar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|lvp
operator|->
name|text
operator|=
name|ckmalloc
argument_list|(
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lvp
operator|->
name|text
argument_list|,
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|=
name|find_var
argument_list|(
name|name
argument_list|,
operator|&
name|vpp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
condition|)
name|setvareq
argument_list|(
name|savestr
argument_list|(
name|name
argument_list|)
argument_list|,
name|VSTRFIXED
operator||
name|VNOLOCAL
argument_list|)
expr_stmt|;
else|else
name|setvar
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|VSTRFIXED
operator||
name|VNOLOCAL
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|*
name|vpp
expr_stmt|;
comment|/* the new variable */
name|lvp
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
name|lvp
operator|->
name|flags
operator|=
name|VUNSET
expr_stmt|;
block|}
else|else
block|{
name|lvp
operator|->
name|text
operator|=
name|vp
operator|->
name|text
expr_stmt|;
name|lvp
operator|->
name|flags
operator|=
name|vp
operator|->
name|flags
expr_stmt|;
name|vp
operator|->
name|flags
operator||=
name|VSTRFIXED
operator||
name|VTEXTFIXED
expr_stmt|;
if|if
condition|(
name|name
index|[
name|vp
operator|->
name|name_len
index|]
operator|==
literal|'='
condition|)
name|setvareq
argument_list|(
name|savestr
argument_list|(
name|name
argument_list|)
argument_list|,
name|VNOLOCAL
argument_list|)
expr_stmt|;
block|}
block|}
name|lvp
operator|->
name|vp
operator|=
name|vp
expr_stmt|;
name|lvp
operator|->
name|next
operator|=
name|localvars
expr_stmt|;
name|localvars
operator|=
name|lvp
expr_stmt|;
name|INTON
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called after a function returns.  */
end_comment

begin_function
name|void
name|poplocalvars
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|localvar
modifier|*
name|lvp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|int
name|islocalevar
decl_stmt|;
name|INTOFF
expr_stmt|;
while|while
condition|(
operator|(
name|lvp
operator|=
name|localvars
operator|)
operator|!=
name|NULL
condition|)
block|{
name|localvars
operator|=
name|lvp
operator|->
name|next
expr_stmt|;
name|vp
operator|=
name|lvp
operator|->
name|vp
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
comment|/* $- saved */
name|memcpy
argument_list|(
name|optval
argument_list|,
name|lvp
operator|->
name|text
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|lvp
operator|->
name|text
argument_list|)
expr_stmt|;
name|optschanged
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lvp
operator|->
name|flags
operator|&
operator|(
name|VUNSET
operator||
name|VSTRFIXED
operator|)
operator|)
operator|==
name|VUNSET
condition|)
block|{
name|vp
operator|->
name|flags
operator|&=
operator|~
name|VREADONLY
expr_stmt|;
operator|(
name|void
operator|)
name|unsetvar
argument_list|(
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|islocalevar
operator|=
operator|(
name|vp
operator|->
name|flags
operator||
name|lvp
operator|->
name|flags
operator|)
operator|&
name|VEXPORT
operator|&&
name|localevar
argument_list|(
name|lvp
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VTEXTFIXED
operator|)
operator|==
literal|0
condition|)
name|ckfree
argument_list|(
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
name|vp
operator|->
name|flags
operator|=
name|lvp
operator|->
name|flags
expr_stmt|;
name|vp
operator|->
name|text
operator|=
name|lvp
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|func
condition|)
call|(
modifier|*
name|vp
operator|->
name|func
call|)
argument_list|(
name|vp
operator|->
name|text
operator|+
name|vp
operator|->
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|islocalevar
condition|)
block|{
name|change_env
argument_list|(
name|vp
operator|->
name|text
argument_list|,
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
operator|&&
operator|(
name|vp
operator|->
name|flags
operator|&
name|VUNSET
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|updatecharset
argument_list|()
expr_stmt|;
block|}
block|}
name|ckfree
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
block|}
name|INTON
expr_stmt|;
block|}
end_function

begin_function
name|int
name|setvarcmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<=
literal|2
condition|)
return|return
name|unsetcmd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
name|setvar
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"too many arguments"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The unset builtin command.  */
end_comment

begin_function
name|int
name|unsetcmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|flg_func
init|=
literal|0
decl_stmt|;
name|int
name|flg_var
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|nextopt
argument_list|(
literal|"vf"
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'f'
condition|)
name|flg_func
operator|=
literal|1
expr_stmt|;
else|else
name|flg_var
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flg_func
operator|==
literal|0
operator|&&
name|flg_var
operator|==
literal|0
condition|)
name|flg_var
operator|=
literal|1
expr_stmt|;
name|INTOFF
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|argptr
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|flg_func
condition|)
name|ret
operator||=
name|unsetfunc
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|flg_var
condition|)
name|ret
operator||=
name|unsetvar
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
block|}
name|INTON
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Unset the specified variable.  * Called with interrupts off.  */
end_comment

begin_function
name|int
name|unsetvar
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|find_var
argument_list|(
name|s
argument_list|,
operator|&
name|vpp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|vp
operator|->
name|flags
operator|&
name|VREADONLY
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|vp
operator|->
name|text
index|[
name|vp
operator|->
name|name_len
operator|+
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|setvar
argument_list|(
name|s
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|&&
name|localevar
argument_list|(
name|vp
operator|->
name|text
argument_list|)
condition|)
block|{
name|change_env
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|updatecharset
argument_list|()
expr_stmt|;
block|}
name|vp
operator|->
name|flags
operator|&=
operator|~
name|VEXPORT
expr_stmt|;
name|vp
operator|->
name|flags
operator||=
name|VUNSET
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VSTRFIXED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VTEXTFIXED
operator|)
operator|==
literal|0
condition|)
name|ckfree
argument_list|(
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
operator|->
name|next
expr_stmt|;
name|ckfree
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the two strings specify the same variable.  The first  * variable name is terminated by '='; the second may be terminated by  * either '=' or '\0'.  */
end_comment

begin_function
specifier|static
name|int
name|varequal
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|q
parameter_list|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
operator|*
name|q
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'='
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
operator|&&
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Search for a variable.  * 'name' may be terminated by '=' or a NUL.  * vppp is set to the pointer to vp, or the list head if vp isn't found  * lenp is set to the number of characters in 'name'  */
end_comment

begin_function
specifier|static
name|struct
name|var
modifier|*
name|find_var
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|var
modifier|*
modifier|*
modifier|*
name|vppp
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|unsigned
name|int
name|hashval
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|,
modifier|*
modifier|*
name|vpp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|name
decl_stmt|;
name|hashval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
name|hashval
operator|=
literal|2
operator|*
name|hashval
operator|+
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|name
expr_stmt|;
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
name|vpp
operator|=
operator|&
name|vartab
index|[
name|hashval
operator|%
name|VTABSIZE
index|]
expr_stmt|;
if|if
condition|(
name|vppp
condition|)
operator|*
name|vppp
operator|=
name|vpp
expr_stmt|;
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vpp
operator|=
operator|&
name|vp
operator|->
name|next
operator|,
name|vp
operator|=
operator|*
name|vpp
control|)
block|{
if|if
condition|(
name|vp
operator|->
name|name_len
operator|!=
name|len
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|vp
operator|->
name|text
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|vppp
condition|)
operator|*
name|vppp
operator|=
name|vpp
expr_stmt|;
return|return
name|vp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

