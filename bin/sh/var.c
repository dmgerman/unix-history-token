begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Kenneth Almquist.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)var.c	8.3 (Berkeley) 5/4/95";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_comment
comment|/*  * Shell variables.  */
end_comment

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expand.h"
end_include

begin_include
include|#
directive|include
file|"nodes.h"
end_include

begin_comment
comment|/* for other headers */
end_comment

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_comment
comment|/* defines cmdenviron */
end_comment

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"mail.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_include
include|#
directive|include
file|"memalloc.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"mystring.h"
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_HISTORY
end_ifndef

begin_include
include|#
directive|include
file|"myhistedit.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VTABSIZE
value|39
end_define

begin_struct
struct|struct
name|varinit
block|{
name|struct
name|var
modifier|*
name|var
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|NO_HISTORY
end_ifndef

begin_decl_stmt
name|struct
name|var
name|vhistsize
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|var
name|vifs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vmail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vmpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vppid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vps1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vps2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vps4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|var
name|vvers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|var
name|voptind
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|STATIC
specifier|const
expr|struct
name|varinit
name|varinit
index|[]
operator|=
block|{
ifndef|#
directive|ifndef
name|NO_HISTORY
block|{
operator|&
name|vhistsize
block|,
name|VSTRFIXED
operator||
name|VTEXTFIXED
operator||
name|VUNSET
block|,
literal|"HISTSIZE="
block|,
name|sethistsize
block|}
block|,
endif|#
directive|endif
block|{
operator|&
name|vifs
block|,
name|VSTRFIXED
operator||
name|VTEXTFIXED
block|,
literal|"IFS= \t\n"
block|,
name|NULL
block|}
block|,
block|{
operator|&
name|vmail
block|,
name|VSTRFIXED
operator||
name|VTEXTFIXED
operator||
name|VUNSET
block|,
literal|"MAIL="
block|,
name|NULL
block|}
block|,
block|{
operator|&
name|vmpath
block|,
name|VSTRFIXED
operator||
name|VTEXTFIXED
operator||
name|VUNSET
block|,
literal|"MAILPATH="
block|,
name|NULL
block|}
block|,
block|{
operator|&
name|vpath
block|,
name|VSTRFIXED
operator||
name|VTEXTFIXED
block|,
literal|"PATH="
name|_PATH_DEFPATH
block|,
name|changepath
block|}
block|,
block|{
operator|&
name|vppid
block|,
name|VSTRFIXED
operator||
name|VTEXTFIXED
operator||
name|VUNSET
block|,
literal|"PPID="
block|,
name|NULL
block|}
block|,
comment|/* 	 * vps1 depends on uid 	 */
block|{
operator|&
name|vps2
block|,
name|VSTRFIXED
operator||
name|VTEXTFIXED
block|,
literal|"PS2=> "
block|,
name|NULL
block|}
block|,
block|{
operator|&
name|vps4
block|,
name|VSTRFIXED
operator||
name|VTEXTFIXED
block|,
literal|"PS4=+ "
block|,
name|NULL
block|}
block|,
block|{
operator|&
name|voptind
block|,
name|VSTRFIXED
operator||
name|VTEXTFIXED
block|,
literal|"OPTIND=1"
block|,
name|getoptsreset
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|STATIC
name|struct
name|var
modifier|*
name|vartab
index|[
name|VTABSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|STATIC
name|struct
name|var
modifier|*
modifier|*
name|hashvar
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|varequal
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|localevar
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initialize the variable symbol tables and import the environment.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|mkinit
end_ifdef

begin_expr_stmt
name|INCLUDE
literal|"var.h"
name|INIT
block|{
name|char
operator|*
operator|*
name|envp
block|;
specifier|extern
name|char
operator|*
operator|*
name|environ
block|;
name|initvar
argument_list|()
block|;
for|for
control|(
name|envp
operator|=
name|environ
init|;
operator|*
name|envp
condition|;
name|envp
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
operator|*
name|envp
argument_list|,
literal|'='
argument_list|)
condition|)
block|{
name|setvareq
argument_list|(
operator|*
name|envp
argument_list|,
name|VEXPORT
operator||
name|VTEXTFIXED
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_endif
unit|} }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This routine initializes the builtin variables.  It is called when the  * shell is initialized and again when a shell procedure is spawned.  */
end_comment

begin_function
name|void
name|initvar
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|ppid
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|struct
name|varinit
modifier|*
name|ip
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|varinit
init|;
operator|(
name|vp
operator|=
name|ip
operator|->
name|var
operator|)
operator|!=
name|NULL
condition|;
name|ip
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|==
literal|0
condition|)
block|{
name|vpp
operator|=
name|hashvar
argument_list|(
name|ip
operator|->
name|text
argument_list|)
expr_stmt|;
name|vp
operator|->
name|next
operator|=
operator|*
name|vpp
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|text
operator|=
name|ip
operator|->
name|text
expr_stmt|;
name|vp
operator|->
name|flags
operator|=
name|ip
operator|->
name|flags
expr_stmt|;
name|vp
operator|->
name|func
operator|=
name|ip
operator|->
name|func
expr_stmt|;
block|}
block|}
comment|/* 	 * PS1 depends on uid 	 */
if|if
condition|(
operator|(
name|vps1
operator|.
name|flags
operator|&
name|VEXPORT
operator|)
operator|==
literal|0
condition|)
block|{
name|vpp
operator|=
name|hashvar
argument_list|(
literal|"PS1="
argument_list|)
expr_stmt|;
name|vps1
operator|.
name|next
operator|=
operator|*
name|vpp
expr_stmt|;
operator|*
name|vpp
operator|=
operator|&
name|vps1
expr_stmt|;
name|vps1
operator|.
name|text
operator|=
name|geteuid
argument_list|()
condition|?
literal|"PS1=$ "
else|:
literal|"PS1=# "
expr_stmt|;
name|vps1
operator|.
name|flags
operator|=
name|VSTRFIXED
operator||
name|VTEXTFIXED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vppid
operator|.
name|flags
operator|&
name|VEXPORT
operator|)
operator|==
literal|0
condition|)
block|{
name|fmtstr
argument_list|(
name|ppid
argument_list|,
sizeof|sizeof
argument_list|(
name|ppid
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|getppid
argument_list|()
argument_list|)
expr_stmt|;
name|setvarsafe
argument_list|(
literal|"PPID"
argument_list|,
name|ppid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Safe version of setvar, returns 1 on success 0 on failure.  */
end_comment

begin_function
name|int
name|setvarsafe
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|jmploc
name|jmploc
decl_stmt|;
name|struct
name|jmploc
modifier|*
specifier|volatile
name|savehandler
init|=
name|handler
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|__GNUC__
comment|/* Avoid longjmp clobbering */
operator|(
name|void
operator|)
operator|&
name|err
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|setjmp
argument_list|(
name|jmploc
operator|.
name|loc
argument_list|)
condition|)
name|err
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|handler
operator|=
operator|&
name|jmploc
expr_stmt|;
name|setvar
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|handler
operator|=
name|savehandler
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Set the value of a variable.  The flags argument is stored with the  * flags of the variable.  If val is NULL, the variable is unset.  */
end_comment

begin_function
name|void
name|setvar
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|char
modifier|*
name|nameeq
decl_stmt|;
name|int
name|isbad
decl_stmt|;
name|isbad
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|is_name
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|isbad
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|is_in_name
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'='
condition|)
break|break;
name|isbad
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
name|namelen
operator|=
name|p
operator|-
name|name
expr_stmt|;
if|if
condition|(
name|isbad
condition|)
name|error
argument_list|(
literal|"%.*s: bad variable name"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|namelen
operator|+
literal|2
expr_stmt|;
comment|/* 2 is space for '=' and '\0' */
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
name|flags
operator||=
name|VUNSET
expr_stmt|;
block|}
else|else
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|nameeq
operator|=
name|ckmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|q
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|--
name|namelen
operator|>=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'='
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|scopy
argument_list|(
name|val
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|setvareq
argument_list|(
name|nameeq
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|localevar
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|lnames
index|[
literal|7
index|]
init|=
block|{
literal|"ALL"
block|,
literal|"COLLATE"
block|,
literal|"CTYPE"
block|,
literal|"MONETARY"
block|,
literal|"NUMERIC"
block|,
literal|"TIME"
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|ss
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'L'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|varequal
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"ANG"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"C_"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|ss
operator|=
name|lnames
init|;
operator|*
name|ss
condition|;
name|ss
operator|++
control|)
if|if
condition|(
name|varequal
argument_list|(
name|s
operator|+
literal|3
argument_list|,
operator|*
name|ss
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Same as setvar except that the variable and value are passed in  * the first argument as name=value.  Since the first argument will  * be actually stored in the table, it should not be a string that  * will go away.  */
end_comment

begin_function
name|void
name|setvareq
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|var
modifier|*
name|vp
decl_stmt|,
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|aflag
condition|)
name|flags
operator||=
name|VEXPORT
expr_stmt|;
name|vpp
operator|=
name|hashvar
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|varequal
argument_list|(
name|s
argument_list|,
name|vp
operator|->
name|text
argument_list|)
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|flags
operator|&
name|VREADONLY
condition|)
block|{
name|len
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'='
argument_list|)
operator|-
name|s
expr_stmt|;
name|error
argument_list|(
literal|"%.*s: is read only"
argument_list|,
name|len
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|INTOFF
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|func
operator|&&
operator|(
name|flags
operator|&
name|VNOFUNC
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|vp
operator|->
name|func
call|)
argument_list|(
name|strchr
argument_list|(
name|s
argument_list|,
literal|'='
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
operator|(
name|VTEXTFIXED
operator||
name|VSTACK
operator|)
operator|)
operator|==
literal|0
condition|)
name|ckfree
argument_list|(
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
name|vp
operator|->
name|flags
operator|&=
operator|~
operator|(
name|VTEXTFIXED
operator||
name|VSTACK
operator||
name|VUNSET
operator|)
expr_stmt|;
name|vp
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
name|vp
operator|->
name|text
operator|=
name|s
expr_stmt|;
comment|/* 			 * We could roll this to a function, to handle it as 			 * a regular variable function callback, but why bother? 			 */
if|if
condition|(
name|vp
operator|==
operator|&
name|vmpath
operator|||
operator|(
name|vp
operator|==
operator|&
name|vmail
operator|&&
operator|!
name|mpathset
argument_list|()
operator|)
condition|)
name|chkmail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|&&
name|localevar
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|putenv
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|INTON
expr_stmt|;
return|return;
block|}
block|}
comment|/* not found */
name|vp
operator|=
name|ckmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|vp
operator|->
name|text
operator|=
name|s
expr_stmt|;
name|vp
operator|->
name|next
operator|=
operator|*
name|vpp
expr_stmt|;
name|vp
operator|->
name|func
operator|=
name|NULL
expr_stmt|;
name|INTOFF
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|&&
name|localevar
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|putenv
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|INTON
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a linked list of variable assignments.  */
end_comment

begin_function
name|void
name|listsetvar
parameter_list|(
name|struct
name|strlist
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|strlist
modifier|*
name|lp
decl_stmt|;
name|INTOFF
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|list
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
name|setvareq
argument_list|(
name|savestr
argument_list|(
name|lp
operator|->
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|INTON
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the value of a variable.  Returns NULL if not set.  */
end_comment

begin_function
name|char
modifier|*
name|lookupvar
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|var
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
operator|*
name|hashvar
argument_list|(
name|name
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|varequal
argument_list|(
name|v
operator|->
name|text
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VUNSET
condition|)
return|return
name|NULL
return|;
return|return
name|strchr
argument_list|(
name|v
operator|->
name|text
argument_list|,
literal|'='
argument_list|)
operator|+
literal|1
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Search the environment of a builtin command.  If the second argument  * is nonzero, return the value of a variable even if it hasn't been  * exported.  */
end_comment

begin_function
name|char
modifier|*
name|bltinlookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|doall
parameter_list|)
block|{
name|struct
name|strlist
modifier|*
name|sp
decl_stmt|;
name|struct
name|var
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|cmdenviron
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|varequal
argument_list|(
name|sp
operator|->
name|text
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|strchr
argument_list|(
name|sp
operator|->
name|text
argument_list|,
literal|'='
argument_list|)
operator|+
literal|1
return|;
block|}
for|for
control|(
name|v
operator|=
operator|*
name|hashvar
argument_list|(
name|name
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|varequal
argument_list|(
name|v
operator|->
name|text
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VUNSET
operator|)
operator|||
operator|(
operator|!
name|doall
operator|&&
operator|(
name|v
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|strchr
argument_list|(
name|v
operator|->
name|text
argument_list|,
literal|'='
argument_list|)
operator|+
literal|1
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Generate a list of exported variables.  This routine is used to construct  * the third argument to execve when executing a program.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|environment
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nenv
decl_stmt|;
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
name|nenv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vpp
operator|=
name|vartab
init|;
name|vpp
operator|<
name|vartab
operator|+
name|VTABSIZE
condition|;
name|vpp
operator|++
control|)
block|{
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
if|if
condition|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
condition|)
name|nenv
operator|++
expr_stmt|;
block|}
name|ep
operator|=
name|env
operator|=
name|stalloc
argument_list|(
operator|(
name|nenv
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|env
argument_list|)
expr_stmt|;
for|for
control|(
name|vpp
operator|=
name|vartab
init|;
name|vpp
operator|<
name|vartab
operator|+
name|VTABSIZE
condition|;
name|vpp
operator|++
control|)
block|{
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
if|if
condition|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
condition|)
operator|*
name|ep
operator|++
operator|=
name|vp
operator|->
name|text
expr_stmt|;
block|}
operator|*
name|ep
operator|=
name|NULL
expr_stmt|;
return|return
name|env
return|;
block|}
end_function

begin_comment
comment|/*  * Called when a shell procedure is invoked to clear out nonexported  * variables.  It is also necessary to reallocate variables of with  * VSTACK set since these are currently allocated on the stack.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|mkinit
end_ifdef

begin_function_decl
name|MKINIT
name|void
name|shprocvar
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|SHELLPROC
end_macro

begin_block
block|{
name|shprocvar
argument_list|()
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|shprocvar
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|vpp
operator|=
name|vartab
init|;
name|vpp
operator|<
name|vartab
operator|+
name|VTABSIZE
condition|;
name|vpp
operator|++
control|)
block|{
for|for
control|(
name|prev
operator|=
name|vpp
init|;
operator|(
name|vp
operator|=
operator|*
name|prev
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|prev
operator|=
name|vp
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VTEXTFIXED
operator|)
operator|==
literal|0
condition|)
name|ckfree
argument_list|(
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VSTRFIXED
operator|)
operator|==
literal|0
condition|)
name|ckfree
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vp
operator|->
name|flags
operator|&
name|VSTACK
condition|)
block|{
name|vp
operator|->
name|text
operator|=
name|savestr
argument_list|(
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
name|vp
operator|->
name|flags
operator|&=
operator|~
name|VSTACK
expr_stmt|;
block|}
name|prev
operator|=
operator|&
name|vp
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
name|initvar
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|var_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|sa
decl_stmt|,
modifier|*
decl_stmt|const
modifier|*
name|sb
decl_stmt|;
name|sa
operator|=
name|a
expr_stmt|;
name|sb
operator|=
name|b
expr_stmt|;
comment|/* 	 * This compares two var=value strings which creates a different 	 * order from what you would probably expect.  POSIX is somewhat 	 * ambiguous on what should be sorted exactly. 	 */
return|return
name|strcoll
argument_list|(
operator|*
name|sa
argument_list|,
operator|*
name|sb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Command to list all variables which are set.  Currently this command  * is invoked from the set command when the set command is called without  * any variables.  */
end_comment

begin_function
name|int
name|showvarscmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|vars
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/* 	 * POSIX requires us to sort the variables. 	 */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vpp
operator|=
name|vartab
init|;
name|vpp
operator|<
name|vartab
operator|+
name|VTABSIZE
condition|;
name|vpp
operator|++
control|)
block|{
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|vp
operator|->
name|flags
operator|&
name|VUNSET
operator|)
condition|)
name|n
operator|++
expr_stmt|;
block|}
block|}
name|INTON
expr_stmt|;
name|vars
operator|=
name|ckmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vars
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vpp
operator|=
name|vartab
init|;
name|vpp
operator|<
name|vartab
operator|+
name|VTABSIZE
condition|;
name|vpp
operator|++
control|)
block|{
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|vp
operator|->
name|flags
operator|&
name|VUNSET
operator|)
condition|)
name|vars
index|[
name|i
operator|++
index|]
operator|=
name|vp
operator|->
name|text
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|vars
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vars
argument_list|)
argument_list|,
name|var_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|s
operator|=
name|vars
index|[
name|i
index|]
init|;
operator|*
name|s
operator|!=
literal|'='
condition|;
name|s
operator|++
control|)
name|out1c
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|out1c
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|out1qstr
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|out1c
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|ckfree
argument_list|(
name|vars
argument_list|)
expr_stmt|;
name|INTOFF
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The export and readonly commands.  */
end_comment

begin_function
name|int
name|exportcmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cmdname
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|values
decl_stmt|;
name|int
name|flag
init|=
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'r'
condition|?
name|VREADONLY
else|:
name|VEXPORT
decl_stmt|;
name|cmdname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|optreset
operator|=
name|optind
operator|=
literal|1
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
name|values
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"p"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'p'
case|:
name|values
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|error
argument_list|(
literal|"unknown option: -%c"
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|values
operator|&&
name|argc
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"-p requires no arguments"
argument_list|)
expr_stmt|;
name|listsetvar
argument_list|(
name|cmdenviron
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|name
operator|=
operator|*
name|argv
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|vpp
operator|=
name|hashvar
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|varequal
argument_list|(
name|vp
operator|->
name|text
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|vp
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|&&
name|localevar
argument_list|(
name|vp
operator|->
name|text
argument_list|)
condition|)
block|{
name|putenv
argument_list|(
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
block|}
block|}
name|setvar
argument_list|(
name|name
argument_list|,
name|p
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|vpp
operator|=
name|vartab
init|;
name|vpp
operator|<
name|vartab
operator|+
name|VTABSIZE
condition|;
name|vpp
operator|++
control|)
block|{
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|vp
operator|->
name|flags
operator|&
name|flag
condition|)
block|{
if|if
condition|(
name|values
condition|)
block|{
name|out1str
argument_list|(
name|cmdname
argument_list|)
expr_stmt|;
name|out1c
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|vp
operator|->
name|text
init|;
operator|*
name|p
operator|!=
literal|'='
condition|;
name|p
operator|++
control|)
name|out1c
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|&&
operator|!
operator|(
name|vp
operator|->
name|flags
operator|&
name|VUNSET
operator|)
condition|)
block|{
name|out1c
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|out1qstr
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|out1c
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The "local" command.  */
end_comment

begin_function
name|int
name|localcmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|in_function
argument_list|()
condition|)
name|error
argument_list|(
literal|"Not in a function"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|name
operator|=
operator|*
name|argptr
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mklocal
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Make a variable a local variable.  When a variable is made local, it's  * value and flags are saved in a localvar structure.  The saved values  * will be restored when the shell function returns.  We handle the name  * "-" as a special case.  */
end_comment

begin_function
name|void
name|mklocal
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|localvar
modifier|*
name|lvp
decl_stmt|;
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|INTOFF
expr_stmt|;
name|lvp
operator|=
name|ckmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|localvar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|lvp
operator|->
name|text
operator|=
name|ckmalloc
argument_list|(
sizeof|sizeof
name|optlist
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lvp
operator|->
name|text
argument_list|,
name|optlist
argument_list|,
sizeof|sizeof
name|optlist
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|vpp
operator|=
name|hashvar
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
operator|&&
operator|!
name|varequal
argument_list|(
name|vp
operator|->
name|text
argument_list|,
name|name
argument_list|)
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
condition|)
name|setvareq
argument_list|(
name|savestr
argument_list|(
name|name
argument_list|)
argument_list|,
name|VSTRFIXED
argument_list|)
expr_stmt|;
else|else
name|setvar
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|VSTRFIXED
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|*
name|vpp
expr_stmt|;
comment|/* the new variable */
name|lvp
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
name|lvp
operator|->
name|flags
operator|=
name|VUNSET
expr_stmt|;
block|}
else|else
block|{
name|lvp
operator|->
name|text
operator|=
name|vp
operator|->
name|text
expr_stmt|;
name|lvp
operator|->
name|flags
operator|=
name|vp
operator|->
name|flags
expr_stmt|;
name|vp
operator|->
name|flags
operator||=
name|VSTRFIXED
operator||
name|VTEXTFIXED
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
condition|)
name|setvareq
argument_list|(
name|savestr
argument_list|(
name|name
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|lvp
operator|->
name|vp
operator|=
name|vp
expr_stmt|;
name|lvp
operator|->
name|next
operator|=
name|localvars
expr_stmt|;
name|localvars
operator|=
name|lvp
expr_stmt|;
name|INTON
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called after a function returns.  */
end_comment

begin_function
name|void
name|poplocalvars
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|localvar
modifier|*
name|lvp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
while|while
condition|(
operator|(
name|lvp
operator|=
name|localvars
operator|)
operator|!=
name|NULL
condition|)
block|{
name|localvars
operator|=
name|lvp
operator|->
name|next
expr_stmt|;
name|vp
operator|=
name|lvp
operator|->
name|vp
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
comment|/* $- saved */
name|memcpy
argument_list|(
name|optlist
argument_list|,
name|lvp
operator|->
name|text
argument_list|,
sizeof|sizeof
name|optlist
argument_list|)
expr_stmt|;
name|ckfree
argument_list|(
name|lvp
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lvp
operator|->
name|flags
operator|&
operator|(
name|VUNSET
operator||
name|VSTRFIXED
operator|)
operator|)
operator|==
name|VUNSET
condition|)
block|{
operator|(
name|void
operator|)
name|unsetvar
argument_list|(
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VTEXTFIXED
operator|)
operator|==
literal|0
condition|)
name|ckfree
argument_list|(
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
name|vp
operator|->
name|flags
operator|=
name|lvp
operator|->
name|flags
expr_stmt|;
name|vp
operator|->
name|text
operator|=
name|lvp
operator|->
name|text
expr_stmt|;
block|}
name|ckfree
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|setvarcmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<=
literal|2
condition|)
return|return
name|unsetcmd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
name|setvar
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"List assignment not implemented"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The unset builtin command.  We unset the function before we unset the  * variable to allow a function to be unset when there is a readonly variable  * with the same name.  */
end_comment

begin_function
name|int
name|unsetcmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|flg_func
init|=
literal|0
decl_stmt|;
name|int
name|flg_var
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|nextopt
argument_list|(
literal|"vf"
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'f'
condition|)
name|flg_func
operator|=
literal|1
expr_stmt|;
else|else
name|flg_var
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flg_func
operator|==
literal|0
operator|&&
name|flg_var
operator|==
literal|0
condition|)
name|flg_var
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|argptr
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|flg_func
condition|)
name|ret
operator||=
name|unsetfunc
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|flg_var
condition|)
name|ret
operator||=
name|unsetvar
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Unset the specified variable.  */
end_comment

begin_function
name|int
name|unsetvar
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|var
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|var
modifier|*
name|vp
decl_stmt|;
name|vpp
operator|=
name|hashvar
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
operator|*
name|vpp
init|;
name|vp
condition|;
name|vpp
operator|=
operator|&
name|vp
operator|->
name|next
operator|,
name|vp
operator|=
operator|*
name|vpp
control|)
block|{
if|if
condition|(
name|varequal
argument_list|(
name|vp
operator|->
name|text
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|flags
operator|&
name|VREADONLY
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|INTOFF
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|strchr
argument_list|(
name|vp
operator|->
name|text
argument_list|,
literal|'='
argument_list|)
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
name|setvar
argument_list|(
name|s
argument_list|,
name|nullstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VEXPORT
operator|)
operator|&&
name|localevar
argument_list|(
name|vp
operator|->
name|text
argument_list|)
condition|)
block|{
name|unsetenv
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|flags
operator|&=
operator|~
name|VEXPORT
expr_stmt|;
name|vp
operator|->
name|flags
operator||=
name|VUNSET
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VSTRFIXED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|flags
operator|&
name|VTEXTFIXED
operator|)
operator|==
literal|0
condition|)
name|ckfree
argument_list|(
name|vp
operator|->
name|text
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
operator|->
name|next
expr_stmt|;
name|ckfree
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|INTON
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the appropriate entry in the hash table from the name.  */
end_comment

begin_function
name|STATIC
name|struct
name|var
modifier|*
modifier|*
name|hashvar
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|hashval
decl_stmt|;
name|hashval
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|)
operator|<<
literal|4
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
name|hashval
operator|+=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
expr_stmt|;
return|return
operator|&
name|vartab
index|[
name|hashval
operator|%
name|VTABSIZE
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the two strings specify the same varable.  The first  * variable name is terminated by '='; the second may be terminated by  * either '=' or '\0'.  */
end_comment

begin_function
name|STATIC
name|int
name|varequal
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|q
parameter_list|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
operator|*
name|q
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'='
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
operator|&&
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

