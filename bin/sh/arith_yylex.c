begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002  *	Herbert Xu.  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Kenneth Almquist.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"arith_yacc.h"
end_include

begin_include
include|#
directive|include
file|"expand.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"memalloc.h"
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_if
if|#
directive|if
name|ARITH_BOR
operator|+
literal|11
operator|!=
name|ARITH_BORASS
operator|||
name|ARITH_ASS
operator|+
literal|11
operator|!=
name|ARITH_EQ
end_if

begin_error
error|#
directive|error
error|Arithmetic tokens are out of order.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|arith_buf
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
init|=
name|arith_buf
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|value
operator|=
operator|*
name|buf
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
name|buf
operator|++
expr_stmt|;
continue|continue;
default|default:
return|return
name|ARITH_BAD
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|yylval
operator|.
name|val
operator|=
name|strtoarith_t
argument_list|(
name|buf
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arith_buf
operator|=
name|end
expr_stmt|;
return|return
name|ARITH_NUM
return|;
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|buf
operator|++
operator|,
name|is_in_name
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
empty_stmt|;
name|yylval
operator|.
name|name
operator|=
name|stalloc
argument_list|(
name|buf
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|yylval
operator|.
name|name
argument_list|,
name|p
argument_list|,
name|buf
operator|-
name|p
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|name
index|[
name|buf
operator|-
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|ARITH_VAR
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'='
case|:
name|value
operator|+=
name|ARITH_ASS
operator|-
literal|'='
expr_stmt|;
name|checkeq
label|:
name|buf
operator|++
expr_stmt|;
name|checkeqcur
label|:
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'='
condition|)
goto|goto
name|out
goto|;
name|value
operator|+=
literal|11
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
switch|switch
condition|(
operator|*
operator|++
name|buf
condition|)
block|{
case|case
literal|'='
case|:
name|value
operator|+=
name|ARITH_GE
operator|-
literal|'>'
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|value
operator|+=
name|ARITH_RSHIFT
operator|-
literal|'>'
expr_stmt|;
goto|goto
name|checkeq
goto|;
default|default:
name|value
operator|+=
name|ARITH_GT
operator|-
literal|'>'
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
literal|'<'
case|:
switch|switch
condition|(
operator|*
operator|++
name|buf
condition|)
block|{
case|case
literal|'='
case|:
name|value
operator|+=
name|ARITH_LE
operator|-
literal|'<'
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|value
operator|+=
name|ARITH_LSHIFT
operator|-
literal|'<'
expr_stmt|;
goto|goto
name|checkeq
goto|;
default|default:
name|value
operator|+=
name|ARITH_LT
operator|-
literal|'<'
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
operator|*
operator|++
name|buf
operator|!=
literal|'|'
condition|)
block|{
name|value
operator|+=
name|ARITH_BOR
operator|-
literal|'|'
expr_stmt|;
goto|goto
name|checkeqcur
goto|;
block|}
name|value
operator|+=
name|ARITH_OR
operator|-
literal|'|'
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
if|if
condition|(
operator|*
operator|++
name|buf
operator|!=
literal|'&'
condition|)
block|{
name|value
operator|+=
name|ARITH_BAND
operator|-
literal|'&'
expr_stmt|;
goto|goto
name|checkeqcur
goto|;
block|}
name|value
operator|+=
name|ARITH_AND
operator|-
literal|'&'
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
operator|*
operator|++
name|buf
operator|!=
literal|'='
condition|)
block|{
name|value
operator|+=
name|ARITH_NOT
operator|-
literal|'!'
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|value
operator|+=
name|ARITH_NE
operator|-
literal|'!'
expr_stmt|;
break|break;
case|case
literal|0
case|:
goto|goto
name|out
goto|;
case|case
literal|'('
case|:
name|value
operator|+=
name|ARITH_LPAREN
operator|-
literal|'('
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|value
operator|+=
name|ARITH_RPAREN
operator|-
literal|')'
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|value
operator|+=
name|ARITH_MUL
operator|-
literal|'*'
expr_stmt|;
goto|goto
name|checkeq
goto|;
case|case
literal|'/'
case|:
name|value
operator|+=
name|ARITH_DIV
operator|-
literal|'/'
expr_stmt|;
goto|goto
name|checkeq
goto|;
case|case
literal|'%'
case|:
name|value
operator|+=
name|ARITH_REM
operator|-
literal|'%'
expr_stmt|;
goto|goto
name|checkeq
goto|;
case|case
literal|'+'
case|:
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'+'
condition|)
return|return
name|ARITH_BAD
return|;
name|value
operator|+=
name|ARITH_ADD
operator|-
literal|'+'
expr_stmt|;
goto|goto
name|checkeq
goto|;
case|case
literal|'-'
case|:
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
return|return
name|ARITH_BAD
return|;
name|value
operator|+=
name|ARITH_SUB
operator|-
literal|'-'
expr_stmt|;
goto|goto
name|checkeq
goto|;
case|case
literal|'~'
case|:
name|value
operator|+=
name|ARITH_BNOT
operator|-
literal|'~'
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|value
operator|+=
name|ARITH_BXOR
operator|-
literal|'^'
expr_stmt|;
goto|goto
name|checkeq
goto|;
case|case
literal|'?'
case|:
name|value
operator|+=
name|ARITH_QMARK
operator|-
literal|'?'
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|value
operator|+=
name|ARITH_COLON
operator|-
literal|':'
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|buf
operator|++
expr_stmt|;
name|out
label|:
name|arith_buf
operator|=
name|buf
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

end_unit

