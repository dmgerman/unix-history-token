begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Kenneth Almquist.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)eval.c	8.9 (Berkeley) 6/8/95";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_comment
comment|/* For WIFSIGNALED(status) */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/*  * Evaluate a command.  */
end_comment

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"nodes.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_include
include|#
directive|include
file|"expand.h"
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_include
include|#
directive|include
file|"redir.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"trap.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_include
include|#
directive|include
file|"memalloc.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"show.h"
end_include

begin_include
include|#
directive|include
file|"mystring.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_HISTORY
end_ifndef

begin_include
include|#
directive|include
file|"myhistedit.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|evalskip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if we are skipping commands */
end_comment

begin_decl_stmt
specifier|static
name|int
name|skipcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of levels to skip */
end_comment

begin_decl_stmt
name|MKINIT
name|int
name|loopnest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current loop nesting level */
end_comment

begin_decl_stmt
name|int
name|funcnest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* depth of function calls */
end_comment

begin_decl_stmt
specifier|static
name|int
name|builtin_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* evalcommand flags for builtins */
end_comment

begin_decl_stmt
name|char
modifier|*
name|commandname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|strlist
modifier|*
name|cmdenviron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exitstatus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exit status of last command */
end_comment

begin_decl_stmt
name|int
name|oexitstatus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* saved exit status */
end_comment

begin_function_decl
specifier|static
name|void
name|evalloop
parameter_list|(
name|union
name|node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evalfor
parameter_list|(
name|union
name|node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|node
modifier|*
name|evalcase
parameter_list|(
name|union
name|node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evalsubshell
parameter_list|(
name|union
name|node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evalredir
parameter_list|(
name|union
name|node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expredir
parameter_list|(
name|union
name|node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evalpipe
parameter_list|(
name|union
name|node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_valid_fast_cmdsubst
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evalcommand
parameter_list|(
name|union
name|node
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|backcmd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prehash
parameter_list|(
name|union
name|node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Called to reset things after an exception.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|mkinit
end_ifdef

begin_expr_stmt
name|INCLUDE
literal|"eval.h"
name|RESET
block|{
name|evalskip
operator|=
literal|0
block|;
name|loopnest
operator|=
literal|0
block|;
name|funcnest
operator|=
literal|0
block|; }
endif|#
directive|endif
comment|/*  * The eval command.  */
name|int
name|evalcmd
argument_list|(
argument|int argc
argument_list|,
argument|char **argv
argument_list|)
block|{
name|char
operator|*
name|p
block|;
name|char
operator|*
name|concat
block|;
name|char
operator|*
operator|*
name|ap
block|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|p
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|STARTSTACKSTR
argument_list|(
name|concat
argument_list|)
expr_stmt|;
name|ap
operator|=
name|argv
operator|+
literal|2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|STPUTS
argument_list|(
name|p
argument_list|,
name|concat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ap
operator|++
operator|)
operator|==
name|NULL
condition|)
break|break;
name|STPUTC
argument_list|(
literal|' '
argument_list|,
name|concat
argument_list|)
expr_stmt|;
block|}
name|STPUTC
argument_list|(
literal|'\0'
argument_list|,
name|concat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p
operator|=
name|grabstackstr
argument_list|(
name|concat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}                 evalstring
operator|(
name|p
operator|,
name|builtin_flags
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} else
name|exitstatus
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|exitstatus
return|;
end_return

begin_comment
unit|}
comment|/*  * Execute a command or commands contained in a string.  */
end_comment

begin_macro
unit|void
name|evalstring
argument_list|(
argument|char *s
argument_list|,
argument|int flags
argument_list|)
end_macro

begin_block
block|{
name|union
name|node
modifier|*
name|n
decl_stmt|;
name|struct
name|stackmark
name|smark
decl_stmt|;
name|int
name|flags_exit
decl_stmt|;
name|int
name|any
decl_stmt|;
name|flags_exit
operator|=
name|flags
operator|&
name|EV_EXIT
expr_stmt|;
name|flags
operator|&=
operator|~
name|EV_EXIT
expr_stmt|;
name|any
operator|=
literal|0
expr_stmt|;
name|setstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|setinputstring
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|parsecmd
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
name|NEOF
condition|)
block|{
if|if
condition|(
name|n
operator|!=
name|NULL
operator|&&
operator|!
name|nflag
condition|)
block|{
if|if
condition|(
name|flags_exit
operator|&&
name|preadateof
argument_list|()
condition|)
name|evaltree
argument_list|(
name|n
argument_list|,
name|flags
operator||
name|EV_EXIT
argument_list|)
expr_stmt|;
else|else
name|evaltree
argument_list|(
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|any
operator|=
literal|1
expr_stmt|;
block|}
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
block|}
name|popfile
argument_list|()
expr_stmt|;
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|any
condition|)
name|exitstatus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags_exit
condition|)
name|exraise
argument_list|(
name|EXEXIT
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Evaluate a parse tree.  The value is left in the global variable  * exitstatus.  */
end_comment

begin_function
name|void
name|evaltree
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|do_etest
decl_stmt|;
name|union
name|node
modifier|*
name|next
decl_stmt|;
name|do_etest
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"evaltree(NULL) called\n"
operator|)
argument_list|)
expr_stmt|;
name|exitstatus
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
do|do
block|{
name|next
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_HISTORY
name|displayhist
operator|=
literal|1
expr_stmt|;
comment|/* show history substitutions done with fc */
endif|#
directive|endif
name|TRACE
argument_list|(
operator|(
literal|"evaltree(%p: %d) called\n"
operator|,
operator|(
name|void
operator|*
operator|)
name|n
operator|,
name|n
operator|->
name|type
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|NSEMI
case|:
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch1
argument_list|,
name|flags
operator|&
operator|~
name|EV_EXIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
condition|)
goto|goto
name|out
goto|;
name|next
operator|=
name|n
operator|->
name|nbinary
operator|.
name|ch2
expr_stmt|;
break|break;
case|case
name|NAND
case|:
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch1
argument_list|,
name|EV_TESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
operator|||
name|exitstatus
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|next
operator|=
name|n
operator|->
name|nbinary
operator|.
name|ch2
expr_stmt|;
break|break;
case|case
name|NOR
case|:
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch1
argument_list|,
name|EV_TESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
operator|||
name|exitstatus
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|next
operator|=
name|n
operator|->
name|nbinary
operator|.
name|ch2
expr_stmt|;
break|break;
case|case
name|NREDIR
case|:
name|evalredir
argument_list|(
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSUBSHELL
case|:
name|evalsubshell
argument_list|(
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|do_etest
operator|=
operator|!
operator|(
name|flags
operator|&
name|EV_TESTED
operator|)
expr_stmt|;
break|break;
case|case
name|NBACKGND
case|:
name|evalsubshell
argument_list|(
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIF
case|:
block|{
name|evaltree
argument_list|(
name|n
operator|->
name|nif
operator|.
name|test
argument_list|,
name|EV_TESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|exitstatus
operator|==
literal|0
condition|)
name|next
operator|=
name|n
operator|->
name|nif
operator|.
name|ifpart
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|->
name|nif
operator|.
name|elsepart
condition|)
name|next
operator|=
name|n
operator|->
name|nif
operator|.
name|elsepart
expr_stmt|;
else|else
name|exitstatus
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|NWHILE
case|:
case|case
name|NUNTIL
case|:
name|evalloop
argument_list|(
name|n
argument_list|,
name|flags
operator|&
operator|~
name|EV_EXIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFOR
case|:
name|evalfor
argument_list|(
name|n
argument_list|,
name|flags
operator|&
operator|~
name|EV_EXIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|NCASE
case|:
name|next
operator|=
name|evalcase
argument_list|(
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|NDEFUN
case|:
name|defun
argument_list|(
name|n
operator|->
name|narg
operator|.
name|text
argument_list|,
name|n
operator|->
name|narg
operator|.
name|next
argument_list|)
expr_stmt|;
name|exitstatus
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NNOT
case|:
name|evaltree
argument_list|(
name|n
operator|->
name|nnot
operator|.
name|com
argument_list|,
name|EV_TESTED
argument_list|)
expr_stmt|;
name|exitstatus
operator|=
operator|!
name|exitstatus
expr_stmt|;
break|break;
case|case
name|NPIPE
case|:
name|evalpipe
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|do_etest
operator|=
operator|!
operator|(
name|flags
operator|&
name|EV_TESTED
operator|)
expr_stmt|;
break|break;
case|case
name|NCMD
case|:
name|evalcommand
argument_list|(
name|n
argument_list|,
name|flags
argument_list|,
operator|(
expr|struct
name|backcmd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|do_etest
operator|=
operator|!
operator|(
name|flags
operator|&
name|EV_TESTED
operator|)
expr_stmt|;
break|break;
default|default:
name|out1fmt
argument_list|(
literal|"Node type = %d\n"
argument_list|,
name|n
operator|->
name|type
argument_list|)
expr_stmt|;
name|flushout
argument_list|(
operator|&
name|output
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|!=
name|NULL
condition|)
do|;
name|out
label|:
if|if
condition|(
name|pendingsigs
condition|)
name|dotrap
argument_list|()
expr_stmt|;
if|if
condition|(
name|eflag
operator|&&
name|exitstatus
operator|!=
literal|0
operator|&&
name|do_etest
condition|)
name|exitshell
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EV_EXIT
condition|)
name|exraise
argument_list|(
name|EXEXIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evalloop
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|loopnest
operator|++
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch1
argument_list|,
name|EV_TESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
condition|)
block|{
name|skipping
label|:
if|if
condition|(
name|evalskip
operator|==
name|SKIPCONT
operator|&&
operator|--
name|skipcount
operator|<=
literal|0
condition|)
block|{
name|evalskip
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|evalskip
operator|==
name|SKIPBREAK
operator|&&
operator|--
name|skipcount
operator|<=
literal|0
condition|)
name|evalskip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|evalskip
operator|==
name|SKIPFUNC
operator|||
name|evalskip
operator|==
name|SKIPFILE
condition|)
name|status
operator|=
name|exitstatus
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|NWHILE
condition|)
block|{
if|if
condition|(
name|exitstatus
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|exitstatus
operator|==
literal|0
condition|)
break|break;
block|}
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|status
operator|=
name|exitstatus
expr_stmt|;
if|if
condition|(
name|evalskip
condition|)
goto|goto
name|skipping
goto|;
block|}
name|loopnest
operator|--
expr_stmt|;
name|exitstatus
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evalfor
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|arglist
name|arglist
decl_stmt|;
name|union
name|node
modifier|*
name|argp
decl_stmt|;
name|struct
name|strlist
modifier|*
name|sp
decl_stmt|;
name|struct
name|stackmark
name|smark
decl_stmt|;
name|setstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|arglist
operator|.
name|lastp
operator|=
operator|&
name|arglist
operator|.
name|list
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|n
operator|->
name|nfor
operator|.
name|args
init|;
name|argp
condition|;
name|argp
operator|=
name|argp
operator|->
name|narg
operator|.
name|next
control|)
block|{
name|oexitstatus
operator|=
name|exitstatus
expr_stmt|;
name|expandarg
argument_list|(
name|argp
argument_list|,
operator|&
name|arglist
argument_list|,
name|EXP_FULL
operator||
name|EXP_TILDE
argument_list|)
expr_stmt|;
block|}
operator|*
name|arglist
operator|.
name|lastp
operator|=
name|NULL
expr_stmt|;
name|exitstatus
operator|=
literal|0
expr_stmt|;
name|loopnest
operator|++
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|arglist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|setvar
argument_list|(
name|n
operator|->
name|nfor
operator|.
name|var
argument_list|,
name|sp
operator|->
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evaltree
argument_list|(
name|n
operator|->
name|nfor
operator|.
name|body
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
condition|)
block|{
if|if
condition|(
name|evalskip
operator|==
name|SKIPCONT
operator|&&
operator|--
name|skipcount
operator|<=
literal|0
condition|)
block|{
name|evalskip
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|evalskip
operator|==
name|SKIPBREAK
operator|&&
operator|--
name|skipcount
operator|<=
literal|0
condition|)
name|evalskip
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|loopnest
operator|--
expr_stmt|;
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|union
name|node
modifier|*
name|evalcase
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|union
name|node
modifier|*
name|cp
decl_stmt|;
name|union
name|node
modifier|*
name|patp
decl_stmt|;
name|struct
name|arglist
name|arglist
decl_stmt|;
name|struct
name|stackmark
name|smark
decl_stmt|;
name|setstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|arglist
operator|.
name|lastp
operator|=
operator|&
name|arglist
operator|.
name|list
expr_stmt|;
name|oexitstatus
operator|=
name|exitstatus
expr_stmt|;
name|exitstatus
operator|=
literal|0
expr_stmt|;
name|expandarg
argument_list|(
name|n
operator|->
name|ncase
operator|.
name|expr
argument_list|,
operator|&
name|arglist
argument_list|,
name|EXP_TILDE
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|n
operator|->
name|ncase
operator|.
name|cases
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nclist
operator|.
name|next
control|)
block|{
for|for
control|(
name|patp
operator|=
name|cp
operator|->
name|nclist
operator|.
name|pattern
init|;
name|patp
condition|;
name|patp
operator|=
name|patp
operator|->
name|narg
operator|.
name|next
control|)
block|{
if|if
condition|(
name|casematch
argument_list|(
name|patp
argument_list|,
name|arglist
operator|.
name|list
operator|->
name|text
argument_list|)
condition|)
block|{
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|->
name|nclist
operator|.
name|next
operator|&&
name|cp
operator|->
name|type
operator|==
name|NCLISTFALLTHRU
condition|)
block|{
name|evaltree
argument_list|(
name|cp
operator|->
name|nclist
operator|.
name|body
argument_list|,
name|flags
operator|&
operator|~
name|EV_EXIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cp
operator|=
name|cp
operator|->
name|nclist
operator|.
name|next
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|->
name|nclist
operator|.
name|body
operator|)
return|;
block|}
block|}
block|}
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Kick off a subshell to evaluate a tree.  */
end_comment

begin_function
specifier|static
name|void
name|evalsubshell
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|job
modifier|*
name|jp
decl_stmt|;
name|int
name|backgnd
init|=
operator|(
name|n
operator|->
name|type
operator|==
name|NBACKGND
operator|)
decl_stmt|;
name|oexitstatus
operator|=
name|exitstatus
expr_stmt|;
name|expredir
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|redirect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|backgnd
operator|&&
name|flags
operator|&
name|EV_EXIT
operator|&&
operator|!
name|have_traps
argument_list|()
operator|)
operator|||
name|forkshell
argument_list|(
name|jp
operator|=
name|makejob
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
argument_list|,
name|n
argument_list|,
name|backgnd
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|backgnd
condition|)
name|flags
operator|&=
operator|~
name|EV_TESTED
expr_stmt|;
name|redirect
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|redirect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evaltree
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|n
argument_list|,
name|flags
operator||
name|EV_EXIT
argument_list|)
expr_stmt|;
comment|/* never returns */
block|}
elseif|else
if|if
condition|(
operator|!
name|backgnd
condition|)
block|{
name|INTOFF
expr_stmt|;
name|exitstatus
operator|=
name|waitforjob
argument_list|(
name|jp
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
block|}
else|else
name|exitstatus
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a redirected compound command.  */
end_comment

begin_function
specifier|static
name|void
name|evalredir
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|jmploc
name|jmploc
decl_stmt|;
name|struct
name|jmploc
modifier|*
name|savehandler
decl_stmt|;
specifier|volatile
name|int
name|in_redirect
init|=
literal|1
decl_stmt|;
name|oexitstatus
operator|=
name|exitstatus
expr_stmt|;
name|expredir
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|redirect
argument_list|)
expr_stmt|;
name|savehandler
operator|=
name|handler
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmploc
operator|.
name|loc
argument_list|)
condition|)
block|{
name|int
name|e
decl_stmt|;
name|handler
operator|=
name|savehandler
expr_stmt|;
name|e
operator|=
name|exception
expr_stmt|;
name|popredir
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|EXERROR
operator|||
name|e
operator|==
name|EXEXEC
condition|)
block|{
if|if
condition|(
name|in_redirect
condition|)
block|{
name|exitstatus
operator|=
literal|2
expr_stmt|;
return|return;
block|}
block|}
name|longjmp
argument_list|(
name|handler
operator|->
name|loc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INTOFF
expr_stmt|;
name|handler
operator|=
operator|&
name|jmploc
expr_stmt|;
name|redirect
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|redirect
argument_list|,
name|REDIR_PUSH
argument_list|)
expr_stmt|;
name|in_redirect
operator|=
literal|0
expr_stmt|;
name|INTON
expr_stmt|;
name|evaltree
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|INTOFF
expr_stmt|;
name|handler
operator|=
name|savehandler
expr_stmt|;
name|popredir
argument_list|()
expr_stmt|;
name|INTON
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute the names of the files in a redirection list.  */
end_comment

begin_function
specifier|static
name|void
name|expredir
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|)
block|{
name|union
name|node
modifier|*
name|redir
decl_stmt|;
for|for
control|(
name|redir
operator|=
name|n
init|;
name|redir
condition|;
name|redir
operator|=
name|redir
operator|->
name|nfile
operator|.
name|next
control|)
block|{
name|struct
name|arglist
name|fn
decl_stmt|;
name|fn
operator|.
name|lastp
operator|=
operator|&
name|fn
operator|.
name|list
expr_stmt|;
switch|switch
condition|(
name|redir
operator|->
name|type
condition|)
block|{
case|case
name|NFROM
case|:
case|case
name|NTO
case|:
case|case
name|NFROMTO
case|:
case|case
name|NAPPEND
case|:
case|case
name|NCLOBBER
case|:
name|expandarg
argument_list|(
name|redir
operator|->
name|nfile
operator|.
name|fname
argument_list|,
operator|&
name|fn
argument_list|,
name|EXP_TILDE
operator||
name|EXP_REDIR
argument_list|)
expr_stmt|;
name|redir
operator|->
name|nfile
operator|.
name|expfname
operator|=
name|fn
operator|.
name|list
operator|->
name|text
expr_stmt|;
break|break;
case|case
name|NFROMFD
case|:
case|case
name|NTOFD
case|:
if|if
condition|(
name|redir
operator|->
name|ndup
operator|.
name|vname
condition|)
block|{
name|expandarg
argument_list|(
name|redir
operator|->
name|ndup
operator|.
name|vname
argument_list|,
operator|&
name|fn
argument_list|,
name|EXP_TILDE
operator||
name|EXP_REDIR
argument_list|)
expr_stmt|;
name|fixredir
argument_list|(
name|redir
argument_list|,
name|fn
operator|.
name|list
operator|->
name|text
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Evaluate a pipeline.  All the processes in the pipeline are children  * of the process creating the pipeline.  (This differs from some versions  * of the shell, which make the last process in a pipeline the parent  * of all the rest.)  */
end_comment

begin_function
specifier|static
name|void
name|evalpipe
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|job
modifier|*
name|jp
decl_stmt|;
name|struct
name|nodelist
modifier|*
name|lp
decl_stmt|;
name|int
name|pipelen
decl_stmt|;
name|int
name|prevfd
decl_stmt|;
name|int
name|pip
index|[
literal|2
index|]
decl_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"evalpipe(%p) called\n"
operator|,
operator|(
name|void
operator|*
operator|)
name|n
operator|)
argument_list|)
expr_stmt|;
name|pipelen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|n
operator|->
name|npipe
operator|.
name|cmdlist
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
name|pipelen
operator|++
expr_stmt|;
name|INTOFF
expr_stmt|;
name|jp
operator|=
name|makejob
argument_list|(
name|n
argument_list|,
name|pipelen
argument_list|)
expr_stmt|;
name|prevfd
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|n
operator|->
name|npipe
operator|.
name|cmdlist
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
name|prehash
argument_list|(
name|lp
operator|->
name|n
argument_list|)
expr_stmt|;
name|pip
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pip
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|prevfd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Pipe call failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|forkshell
argument_list|(
name|jp
argument_list|,
name|lp
operator|->
name|n
argument_list|,
name|n
operator|->
name|npipe
operator|.
name|backgnd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INTON
expr_stmt|;
if|if
condition|(
name|prevfd
operator|>
literal|0
condition|)
block|{
name|dup2
argument_list|(
name|prevfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|prevfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pip
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prevfd
operator|>=
literal|0
operator|&&
name|pip
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
name|close
argument_list|(
name|pip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pip
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
block|{
name|dup2
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|evaltree
argument_list|(
name|lp
operator|->
name|n
argument_list|,
name|EV_EXIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prevfd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|prevfd
argument_list|)
expr_stmt|;
name|prevfd
operator|=
name|pip
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|pip
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|INTON
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|npipe
operator|.
name|backgnd
operator|==
literal|0
condition|)
block|{
name|INTOFF
expr_stmt|;
name|exitstatus
operator|=
name|waitforjob
argument_list|(
name|jp
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"evalpipe:  job done exit status %d\n"
operator|,
name|exitstatus
operator|)
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
block|}
else|else
name|exitstatus
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_valid_fast_cmdsubst
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|n
operator|->
name|type
operator|==
name|NCMD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Execute a command inside back quotes.  If it's a builtin command, we  * want to save its output in a block obtained from malloc.  Otherwise  * we fork off a subprocess and get the output of the command via a pipe.  * Should be called with interrupts off.  */
end_comment

begin_function
name|void
name|evalbackcmd
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|,
name|struct
name|backcmd
modifier|*
name|result
parameter_list|)
block|{
name|int
name|pip
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|job
modifier|*
name|jp
decl_stmt|;
name|struct
name|stackmark
name|smark
decl_stmt|;
comment|/* unnecessary */
name|struct
name|jmploc
name|jmploc
decl_stmt|;
name|struct
name|jmploc
modifier|*
name|savehandler
decl_stmt|;
name|struct
name|localvar
modifier|*
name|savelocalvars
decl_stmt|;
name|setstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|result
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|result
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|nleft
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|jp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|exitstatus
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|is_valid_fast_cmdsubst
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|exitstatus
operator|=
name|oexitstatus
expr_stmt|;
name|savelocalvars
operator|=
name|localvars
expr_stmt|;
name|localvars
operator|=
name|NULL
expr_stmt|;
name|forcelocal
operator|++
expr_stmt|;
name|savehandler
operator|=
name|handler
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmploc
operator|.
name|loc
argument_list|)
condition|)
block|{
if|if
condition|(
name|exception
operator|==
name|EXERROR
operator|||
name|exception
operator|==
name|EXEXEC
condition|)
name|exitstatus
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|exception
operator|!=
literal|0
condition|)
block|{
name|handler
operator|=
name|savehandler
expr_stmt|;
name|forcelocal
operator|--
expr_stmt|;
name|poplocalvars
argument_list|()
expr_stmt|;
name|localvars
operator|=
name|savelocalvars
expr_stmt|;
name|longjmp
argument_list|(
name|handler
operator|->
name|loc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|handler
operator|=
operator|&
name|jmploc
expr_stmt|;
name|evalcommand
argument_list|(
name|n
argument_list|,
name|EV_BACKCMD
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|handler
operator|=
name|savehandler
expr_stmt|;
name|forcelocal
operator|--
expr_stmt|;
name|poplocalvars
argument_list|()
expr_stmt|;
name|localvars
operator|=
name|savelocalvars
expr_stmt|;
block|}
else|else
block|{
name|exitstatus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pip
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Pipe call failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|jp
operator|=
name|makejob
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|forkshell
argument_list|(
name|jp
argument_list|,
name|n
argument_list|,
name|FORK_NOJOB
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FORCEINTON
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pip
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
block|{
name|dup2
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|evaltree
argument_list|(
name|n
argument_list|,
name|EV_EXIT
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|result
operator|->
name|fd
operator|=
name|pip
index|[
literal|0
index|]
expr_stmt|;
name|result
operator|->
name|jp
operator|=
name|jp
expr_stmt|;
block|}
name|out
label|:
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"evalbackcmd done: fd=%d buf=%p nleft=%d jp=%p\n"
operator|,
name|result
operator|->
name|fd
operator|,
name|result
operator|->
name|buf
operator|,
name|result
operator|->
name|nleft
operator|,
name|result
operator|->
name|jp
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if a builtin can safely be executed in the same process,  * even though it should be in a subshell (command substitution).  * Note that jobid, jobs, times and trap can show information not  * available in a child process; this is deliberate.  * The arguments should already have been expanded.  */
end_comment

begin_function
specifier|static
name|int
name|safe_builtin
parameter_list|(
name|int
name|idx
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|==
name|BLTINCMD
operator|||
name|idx
operator|==
name|COMMANDCMD
operator|||
name|idx
operator|==
name|ECHOCMD
operator|||
name|idx
operator|==
name|FALSECMD
operator|||
name|idx
operator|==
name|JOBIDCMD
operator|||
name|idx
operator|==
name|JOBSCMD
operator|||
name|idx
operator|==
name|KILLCMD
operator|||
name|idx
operator|==
name|PRINTFCMD
operator|||
name|idx
operator|==
name|PWDCMD
operator|||
name|idx
operator|==
name|TESTCMD
operator|||
name|idx
operator|==
name|TIMESCMD
operator|||
name|idx
operator|==
name|TRUECMD
operator|||
name|idx
operator|==
name|TYPECMD
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|idx
operator|==
name|EXPORTCMD
operator|||
name|idx
operator|==
name|TRAPCMD
operator|||
name|idx
operator|==
name|ULIMITCMD
operator|||
name|idx
operator|==
name|UMASKCMD
condition|)
return|return
operator|(
name|argc
operator|<=
literal|1
operator|||
operator|(
name|argc
operator|==
literal|2
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|)
return|;
if|if
condition|(
name|idx
operator|==
name|SETCMD
condition|)
return|return
operator|(
name|argc
operator|<=
literal|1
operator|||
operator|(
name|argc
operator|==
literal|2
operator|&&
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Execute a simple command.  * Note: This may or may not return if (flags& EV_EXIT).  */
end_comment

begin_function
specifier|static
name|void
name|evalcommand
parameter_list|(
name|union
name|node
modifier|*
name|cmd
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|backcmd
modifier|*
name|backcmd
parameter_list|)
block|{
name|struct
name|stackmark
name|smark
decl_stmt|;
name|union
name|node
modifier|*
name|argp
decl_stmt|;
name|struct
name|arglist
name|arglist
decl_stmt|;
name|struct
name|arglist
name|varlist
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|int
name|varflag
decl_stmt|;
name|struct
name|strlist
modifier|*
name|sp
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|pip
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|cmdentry
name|cmdentry
decl_stmt|;
name|struct
name|job
modifier|*
name|jp
decl_stmt|;
name|struct
name|jmploc
name|jmploc
decl_stmt|;
name|struct
name|jmploc
modifier|*
name|savehandler
decl_stmt|;
name|char
modifier|*
name|savecmdname
decl_stmt|;
name|struct
name|shparam
name|saveparam
decl_stmt|;
name|struct
name|localvar
modifier|*
name|savelocalvars
decl_stmt|;
name|struct
name|parsefile
modifier|*
name|savetopfile
decl_stmt|;
specifier|volatile
name|int
name|e
decl_stmt|;
name|char
modifier|*
name|lastarg
decl_stmt|;
name|int
name|realstatus
decl_stmt|;
name|int
name|do_clearcmdentry
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|pathval
argument_list|()
decl_stmt|;
comment|/* First expand the arguments. */
name|TRACE
argument_list|(
operator|(
literal|"evalcommand(%p, %d) called\n"
operator|,
operator|(
name|void
operator|*
operator|)
name|cmd
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|setstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|arglist
operator|.
name|lastp
operator|=
operator|&
name|arglist
operator|.
name|list
expr_stmt|;
name|varlist
operator|.
name|lastp
operator|=
operator|&
name|varlist
operator|.
name|list
expr_stmt|;
name|varflag
operator|=
literal|1
expr_stmt|;
name|jp
operator|=
name|NULL
expr_stmt|;
name|do_clearcmdentry
operator|=
literal|0
expr_stmt|;
name|oexitstatus
operator|=
name|exitstatus
expr_stmt|;
name|exitstatus
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|cmd
operator|->
name|ncmd
operator|.
name|args
init|;
name|argp
condition|;
name|argp
operator|=
name|argp
operator|->
name|narg
operator|.
name|next
control|)
block|{
if|if
condition|(
name|varflag
operator|&&
name|isassignment
argument_list|(
name|argp
operator|->
name|narg
operator|.
name|text
argument_list|)
condition|)
block|{
name|expandarg
argument_list|(
name|argp
argument_list|,
operator|&
name|varlist
argument_list|,
name|EXP_VARTILDE
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|expandarg
argument_list|(
name|argp
argument_list|,
operator|&
name|arglist
argument_list|,
name|EXP_FULL
operator||
name|EXP_TILDE
argument_list|)
expr_stmt|;
name|varflag
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|arglist
operator|.
name|lastp
operator|=
name|NULL
expr_stmt|;
operator|*
name|varlist
operator|.
name|lastp
operator|=
name|NULL
expr_stmt|;
name|expredir
argument_list|(
name|cmd
operator|->
name|ncmd
operator|.
name|redirect
argument_list|)
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|arglist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|argc
operator|++
expr_stmt|;
comment|/* Add one slot at the beginning for tryexec(). */
name|argv
operator|=
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|arglist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"evalcommand arg: %s\n"
operator|,
name|sp
operator|->
name|text
operator|)
argument_list|)
expr_stmt|;
operator|*
name|argv
operator|++
operator|=
name|sp
operator|->
name|text
expr_stmt|;
block|}
operator|*
name|argv
operator|=
name|NULL
expr_stmt|;
name|lastarg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|iflag
operator|&&
name|funcnest
operator|==
literal|0
operator|&&
name|argc
operator|>
literal|0
condition|)
name|lastarg
operator|=
name|argv
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|argv
operator|-=
name|argc
expr_stmt|;
comment|/* Print the command if xflag is set. */
if|if
condition|(
name|xflag
condition|)
block|{
name|char
name|sep
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ps4
decl_stmt|;
name|ps4
operator|=
name|expandstr
argument_list|(
name|ps4val
argument_list|()
argument_list|)
expr_stmt|;
name|out2str
argument_list|(
name|ps4
operator|!=
name|NULL
condition|?
name|ps4
else|:
name|ps4val
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|varlist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sep
operator|!=
literal|0
condition|)
name|out2c
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|sp
operator|->
name|text
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|outbin
argument_list|(
name|sp
operator|->
name|text
argument_list|,
name|p
operator|-
name|sp
operator|->
name|text
argument_list|,
name|out2
argument_list|)
expr_stmt|;
name|out2qstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|out2qstr
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|' '
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|arglist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sep
operator|!=
literal|0
condition|)
name|out2c
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* Disambiguate command looking like assignment. */
if|if
condition|(
name|sp
operator|==
name|arglist
operator|.
name|list
operator|&&
name|strchr
argument_list|(
name|sp
operator|->
name|text
argument_list|,
literal|'='
argument_list|)
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
name|sp
operator|->
name|text
argument_list|,
literal|'\''
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|out2c
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|out2str
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|out2c
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
else|else
name|out2qstr
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|' '
expr_stmt|;
block|}
name|out2c
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|flushout
argument_list|(
operator|&
name|errout
argument_list|)
expr_stmt|;
block|}
comment|/* Now locate the command. */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
comment|/* Variable assignment(s) without command */
name|cmdentry
operator|.
name|cmdtype
operator|=
name|CMDBUILTIN
expr_stmt|;
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|=
name|BLTINCMD
expr_stmt|;
name|cmdentry
operator|.
name|special
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|static
specifier|const
name|char
name|PATH
index|[]
init|=
literal|"PATH="
decl_stmt|;
name|int
name|cmd_flags
init|=
literal|0
decl_stmt|,
name|bltinonly
init|=
literal|0
decl_stmt|;
comment|/* 		 * Modify the command lookup path, if a PATH= assignment 		 * is present 		 */
for|for
control|(
name|sp
operator|=
name|varlist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|sp
operator|->
name|text
argument_list|,
name|PATH
argument_list|,
sizeof|sizeof
argument_list|(
name|PATH
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|path
operator|=
name|sp
operator|->
name|text
operator|+
sizeof|sizeof
argument_list|(
name|PATH
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 				 * On `PATH=... command`, we need to make 				 * sure that the command isn't using the 				 * non-updated hash table of the outer PATH 				 * setting and we need to make sure that 				 * the hash table isn't filled with items 				 * from the temporary setting. 				 * 				 * It would be better to forbit using and 				 * updating the table while this command 				 * runs, by the command finding mechanism 				 * is heavily integrated with hash handling, 				 * so we just delete the hash before and after 				 * the command runs. Partly deleting like 				 * changepatch() does doesn't seem worth the 				 * bookinging effort, since most such runs add 				 * directories in front of the new PATH. 				 */
name|clearcmdentry
argument_list|()
expr_stmt|;
name|do_clearcmdentry
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|bltinonly
condition|)
block|{
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|=
name|find_builtin
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|cmdentry
operator|.
name|special
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|<
literal|0
condition|)
block|{
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|=
name|BLTINCMD
expr_stmt|;
name|argv
operator|--
expr_stmt|;
name|argc
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
name|find_command
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|cmdentry
argument_list|,
name|cmd_flags
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* implement the bltin and command builtins here */
if|if
condition|(
name|cmdentry
operator|.
name|cmdtype
operator|!=
name|CMDBUILTIN
condition|)
break|break;
if|if
condition|(
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|BLTINCMD
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
break|break;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|bltinonly
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|COMMANDCMD
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-p"
argument_list|)
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
break|break;
if|if
condition|(
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
break|break;
name|argv
operator|+=
literal|3
expr_stmt|;
name|argc
operator|-=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|argv
operator|+=
literal|2
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
block|}
name|path
operator|=
name|_PATH_STDPATH
expr_stmt|;
name|clearcmdentry
argument_list|()
expr_stmt|;
name|do_clearcmdentry
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
break|break;
name|argv
operator|+=
literal|2
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
break|break;
else|else
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
name|cmd_flags
operator||=
name|DO_NOFUNC
expr_stmt|;
name|bltinonly
operator|=
literal|0
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* 		 * Special builtins lose their special properties when 		 * called via 'command'. 		 */
if|if
condition|(
name|cmd_flags
operator|&
name|DO_NOFUNC
condition|)
name|cmdentry
operator|.
name|special
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Fork off a child process if necessary. */
if|if
condition|(
operator|(
operator|(
name|cmdentry
operator|.
name|cmdtype
operator|==
name|CMDNORMAL
operator|||
name|cmdentry
operator|.
name|cmdtype
operator|==
name|CMDUNKNOWN
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
name|EV_EXIT
operator|)
operator|==
literal|0
operator|||
name|have_traps
argument_list|()
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|EV_BACKCMD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|cmdentry
operator|.
name|cmdtype
operator|!=
name|CMDBUILTIN
operator|||
operator|!
name|safe_builtin
argument_list|(
name|cmdentry
operator|.
name|u
operator|.
name|index
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|)
condition|)
block|{
name|jp
operator|=
name|makejob
argument_list|(
name|cmd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mode
operator|=
name|FORK_FG
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EV_BACKCMD
condition|)
block|{
name|mode
operator|=
name|FORK_NOJOB
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pip
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Pipe call failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|forkshell
argument_list|(
name|jp
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|parent
goto|;
comment|/* at end of routine */
if|if
condition|(
name|flags
operator|&
name|EV_BACKCMD
condition|)
block|{
name|FORCEINTON
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pip
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
block|{
name|dup2
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|flags
operator|&=
operator|~
name|EV_BACKCMD
expr_stmt|;
block|}
name|flags
operator||=
name|EV_EXIT
expr_stmt|;
block|}
comment|/* This is the child process if a fork occurred. */
comment|/* Execute the command. */
if|if
condition|(
name|cmdentry
operator|.
name|cmdtype
operator|==
name|CMDFUNCTION
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|trputs
argument_list|(
literal|"Shell function:  "
argument_list|)
expr_stmt|;
name|trargs
argument_list|(
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|saveparam
operator|=
name|shellparam
expr_stmt|;
name|shellparam
operator|.
name|malloc
operator|=
literal|0
expr_stmt|;
name|shellparam
operator|.
name|reset
operator|=
literal|1
expr_stmt|;
name|shellparam
operator|.
name|nparam
operator|=
name|argc
operator|-
literal|1
expr_stmt|;
name|shellparam
operator|.
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|shellparam
operator|.
name|optnext
operator|=
name|NULL
expr_stmt|;
name|INTOFF
expr_stmt|;
name|savelocalvars
operator|=
name|localvars
expr_stmt|;
name|localvars
operator|=
name|NULL
expr_stmt|;
name|reffunc
argument_list|(
name|cmdentry
operator|.
name|u
operator|.
name|func
argument_list|)
expr_stmt|;
name|savehandler
operator|=
name|handler
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmploc
operator|.
name|loc
argument_list|)
condition|)
block|{
name|freeparam
argument_list|(
operator|&
name|shellparam
argument_list|)
expr_stmt|;
name|shellparam
operator|=
name|saveparam
expr_stmt|;
name|popredir
argument_list|()
expr_stmt|;
name|unreffunc
argument_list|(
name|cmdentry
operator|.
name|u
operator|.
name|func
argument_list|)
expr_stmt|;
name|poplocalvars
argument_list|()
expr_stmt|;
name|localvars
operator|=
name|savelocalvars
expr_stmt|;
name|funcnest
operator|--
expr_stmt|;
name|handler
operator|=
name|savehandler
expr_stmt|;
name|longjmp
argument_list|(
name|handler
operator|->
name|loc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|handler
operator|=
operator|&
name|jmploc
expr_stmt|;
name|funcnest
operator|++
expr_stmt|;
name|redirect
argument_list|(
name|cmd
operator|->
name|ncmd
operator|.
name|redirect
argument_list|,
name|REDIR_PUSH
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|varlist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|mklocal
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|exitstatus
operator|=
name|oexitstatus
expr_stmt|;
name|evaltree
argument_list|(
name|getfuncnode
argument_list|(
name|cmdentry
operator|.
name|u
operator|.
name|func
argument_list|)
argument_list|,
name|flags
operator|&
operator|(
name|EV_TESTED
operator||
name|EV_EXIT
operator|)
argument_list|)
expr_stmt|;
name|INTOFF
expr_stmt|;
name|unreffunc
argument_list|(
name|cmdentry
operator|.
name|u
operator|.
name|func
argument_list|)
expr_stmt|;
name|poplocalvars
argument_list|()
expr_stmt|;
name|localvars
operator|=
name|savelocalvars
expr_stmt|;
name|freeparam
argument_list|(
operator|&
name|shellparam
argument_list|)
expr_stmt|;
name|shellparam
operator|=
name|saveparam
expr_stmt|;
name|handler
operator|=
name|savehandler
expr_stmt|;
name|funcnest
operator|--
expr_stmt|;
name|popredir
argument_list|()
expr_stmt|;
name|INTON
expr_stmt|;
if|if
condition|(
name|evalskip
operator|==
name|SKIPFUNC
condition|)
block|{
name|evalskip
operator|=
literal|0
expr_stmt|;
name|skipcount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|jp
condition|)
name|exitshell
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdentry
operator|.
name|cmdtype
operator|==
name|CMDBUILTIN
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|trputs
argument_list|(
literal|"builtin command:  "
argument_list|)
expr_stmt|;
name|trargs
argument_list|(
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mode
operator|=
operator|(
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|EXECCMD
operator|)
condition|?
literal|0
else|:
name|REDIR_PUSH
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|EV_BACKCMD
condition|)
block|{
name|memout
operator|.
name|nleft
operator|=
literal|0
expr_stmt|;
name|memout
operator|.
name|nextc
operator|=
name|memout
operator|.
name|buf
expr_stmt|;
name|memout
operator|.
name|bufsize
operator|=
literal|64
expr_stmt|;
name|mode
operator||=
name|REDIR_BACKQ
expr_stmt|;
name|cmdentry
operator|.
name|special
operator|=
literal|0
expr_stmt|;
block|}
name|savecmdname
operator|=
name|commandname
expr_stmt|;
name|savetopfile
operator|=
name|getcurrentfile
argument_list|()
expr_stmt|;
name|cmdenviron
operator|=
name|varlist
operator|.
name|list
expr_stmt|;
name|e
operator|=
operator|-
literal|1
expr_stmt|;
name|savehandler
operator|=
name|handler
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmploc
operator|.
name|loc
argument_list|)
condition|)
block|{
name|e
operator|=
name|exception
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|EXINT
condition|)
name|exitstatus
operator|=
name|SIGINT
operator|+
literal|128
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|!=
name|EXEXIT
condition|)
name|exitstatus
operator|=
literal|2
expr_stmt|;
goto|goto
name|cmddone
goto|;
block|}
name|handler
operator|=
operator|&
name|jmploc
expr_stmt|;
name|redirect
argument_list|(
name|cmd
operator|->
name|ncmd
operator|.
name|redirect
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* 		 * If there is no command word, redirection errors should 		 * not be fatal but assignment errors should. 		 */
if|if
condition|(
name|argc
operator|==
literal|0
operator|&&
operator|!
operator|(
name|flags
operator|&
name|EV_BACKCMD
operator|)
condition|)
name|cmdentry
operator|.
name|special
operator|=
literal|1
expr_stmt|;
name|listsetvar
argument_list|(
name|cmdenviron
argument_list|,
name|cmdentry
operator|.
name|special
condition|?
literal|0
else|:
name|VNOSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
name|bltinsetlocale
argument_list|()
expr_stmt|;
name|commandname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argptr
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|nextopt_optptr
operator|=
name|NULL
expr_stmt|;
comment|/* initialize nextopt */
name|builtin_flags
operator|=
name|flags
expr_stmt|;
name|exitstatus
operator|=
call|(
modifier|*
name|builtinfunc
index|[
name|cmdentry
operator|.
name|u
operator|.
name|index
index|]
call|)
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|flushall
argument_list|()
expr_stmt|;
name|cmddone
label|:
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
name|bltinunsetlocale
argument_list|()
expr_stmt|;
name|cmdenviron
operator|=
name|NULL
expr_stmt|;
name|out1
operator|=
operator|&
name|output
expr_stmt|;
name|out2
operator|=
operator|&
name|errout
expr_stmt|;
name|freestdout
argument_list|()
expr_stmt|;
name|handler
operator|=
name|savehandler
expr_stmt|;
name|commandname
operator|=
name|savecmdname
expr_stmt|;
if|if
condition|(
name|jp
condition|)
name|exitshell
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|EV_BACKCMD
condition|)
block|{
name|backcmd
operator|->
name|buf
operator|=
name|memout
operator|.
name|buf
expr_stmt|;
name|backcmd
operator|->
name|nleft
operator|=
name|memout
operator|.
name|nextc
operator|-
name|memout
operator|.
name|buf
expr_stmt|;
name|memout
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|!=
name|EXECCMD
condition|)
name|popredir
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|!=
name|EXERROR
operator|&&
name|e
operator|!=
name|EXEXEC
operator|)
operator|||
name|cmdentry
operator|.
name|special
condition|)
name|exraise
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|popfilesupto
argument_list|(
name|savetopfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
name|EV_BACKCMD
condition|)
name|FORCEINTON
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|trputs
argument_list|(
literal|"normal command:  "
argument_list|)
expr_stmt|;
name|trargs
argument_list|(
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|redirect
argument_list|(
name|cmd
operator|->
name|ncmd
operator|.
name|redirect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|varlist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|setvareq
argument_list|(
name|sp
operator|->
name|text
argument_list|,
name|VEXPORT
operator||
name|VSTACK
argument_list|)
expr_stmt|;
name|envp
operator|=
name|environment
argument_list|()
expr_stmt|;
name|shellexec
argument_list|(
name|argv
argument_list|,
name|envp
argument_list|,
name|path
argument_list|,
name|cmdentry
operator|.
name|u
operator|.
name|index
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
goto|goto
name|out
goto|;
name|parent
label|:
comment|/* parent process gets here (if we forked) */
if|if
condition|(
name|mode
operator|==
name|FORK_FG
condition|)
block|{
comment|/* argument to fork */
name|INTOFF
expr_stmt|;
name|exitstatus
operator|=
name|waitforjob
argument_list|(
name|jp
argument_list|,
operator|&
name|realstatus
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
if|if
condition|(
name|iflag
operator|&&
name|loopnest
operator|>
literal|0
operator|&&
name|WIFSIGNALED
argument_list|(
name|realstatus
argument_list|)
condition|)
block|{
name|evalskip
operator|=
name|SKIPBREAK
expr_stmt|;
name|skipcount
operator|=
name|loopnest
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|FORK_NOJOB
condition|)
block|{
name|backcmd
operator|->
name|fd
operator|=
name|pip
index|[
literal|0
index|]
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|backcmd
operator|->
name|jp
operator|=
name|jp
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|lastarg
condition|)
name|setvar
argument_list|(
literal|"_"
argument_list|,
name|lastarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_clearcmdentry
condition|)
name|clearcmdentry
argument_list|()
expr_stmt|;
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Search for a command.  This is called before we fork so that the  * location of the command will be available in the parent as well as  * the child.  The check for "goodname" is an overly conservative  * check that the name will not be subject to expansion.  */
end_comment

begin_function
specifier|static
name|void
name|prehash
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|cmdentry
name|entry
decl_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|type
operator|==
name|NCMD
operator|&&
name|n
operator|->
name|ncmd
operator|.
name|args
condition|)
if|if
condition|(
name|goodname
argument_list|(
name|n
operator|->
name|ncmd
operator|.
name|args
operator|->
name|narg
operator|.
name|text
argument_list|)
condition|)
name|find_command
argument_list|(
name|n
operator|->
name|ncmd
operator|.
name|args
operator|->
name|narg
operator|.
name|text
argument_list|,
operator|&
name|entry
argument_list|,
literal|0
argument_list|,
name|pathval
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Builtin commands.  Builtin commands whose functions are closely  * tied to evaluation are implemented here.  */
end_comment

begin_comment
comment|/*  * No command given, a bltin command with no arguments, or a bltin command  * with an invalid name.  */
end_comment

begin_function
name|int
name|bltincmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|out2fmt_flush
argument_list|(
literal|"%s: not found\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|127
return|;
block|}
comment|/* 	 * Preserve exitstatus of a previous possible redirection 	 * as POSIX mandates 	 */
return|return
name|exitstatus
return|;
block|}
end_function

begin_comment
comment|/*  * Handle break and continue commands.  Break, continue, and return are  * all handled by setting the evalskip flag.  The evaluation routines  * above all check this flag, and if it is set they start skipping  * commands rather than executing them.  The variable skipcount is  * the number of loops to break/continue, or the number of function  * levels to return.  (The latter is always 1.)  It should probably  * be an error to break out of more loops than exist, but it isn't  * in the standard shell so we don't make it one here.  */
end_comment

begin_function
name|int
name|breakcmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|n
init|=
name|argc
operator|>
literal|1
condition|?
name|number
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|loopnest
condition|)
name|n
operator|=
name|loopnest
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|evalskip
operator|=
operator|(
operator|*
operator|*
name|argv
operator|==
literal|'c'
operator|)
condition|?
name|SKIPCONT
else|:
name|SKIPBREAK
expr_stmt|;
name|skipcount
operator|=
name|n
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The `command' command.  */
end_comment

begin_function
name|int
name|commandcmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|cmd
init|=
operator|-
literal|1
decl_stmt|;
name|path
operator|=
name|bltinlookup
argument_list|(
literal|"PATH"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|optind
operator|=
name|optreset
operator|=
literal|1
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"pvV"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'p'
case|:
name|path
operator|=
name|_PATH_STDPATH
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|cmd
operator|=
name|TYPECMD_SMALLV
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|cmd
operator|=
name|TYPECMD_BIGV
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|error
argument_list|(
literal|"unknown option: -%c"
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"wrong number of arguments"
argument_list|)
expr_stmt|;
return|return
name|typecmd_impl
argument_list|(
literal|2
argument_list|,
name|argv
operator|-
literal|1
argument_list|,
name|cmd
argument_list|,
name|path
argument_list|)
return|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"commandcmd bad call"
argument_list|)
expr_stmt|;
comment|/* 	 * Do nothing successfully if no command was specified; 	 * ksh also does this. 	 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The return command.  */
end_comment

begin_function
name|int
name|returncmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
init|=
name|argc
operator|>
literal|1
condition|?
name|number
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
else|:
name|oexitstatus
decl_stmt|;
if|if
condition|(
name|funcnest
condition|)
block|{
name|evalskip
operator|=
name|SKIPFUNC
expr_stmt|;
name|skipcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* skip the rest of the file */
name|evalskip
operator|=
name|SKIPFILE
expr_stmt|;
name|skipcount
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|falsecmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|truecmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|execcmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
comment|/* 	 * Because we have historically not supported any options, 	 * only treat "--" specially. 	 */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|struct
name|strlist
modifier|*
name|sp
decl_stmt|;
name|iflag
operator|=
literal|0
expr_stmt|;
comment|/* exit on error */
name|mflag
operator|=
literal|0
expr_stmt|;
name|optschanged
argument_list|()
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|cmdenviron
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|setvareq
argument_list|(
name|sp
operator|->
name|text
argument_list|,
name|VEXPORT
operator||
name|VSTACK
argument_list|)
expr_stmt|;
name|shellexec
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|environment
argument_list|()
argument_list|,
name|pathval
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|timescmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
name|struct
name|rusage
name|ru
decl_stmt|;
name|long
name|shumins
decl_stmt|,
name|shsmins
decl_stmt|,
name|chumins
decl_stmt|,
name|chsmins
decl_stmt|;
name|double
name|shusecs
decl_stmt|,
name|shssecs
decl_stmt|,
name|chusecs
decl_stmt|,
name|chssecs
decl_stmt|;
if|if
condition|(
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|ru
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|shumins
operator|=
name|ru
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|/
literal|60
expr_stmt|;
name|shusecs
operator|=
name|ru
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|%
literal|60
operator|+
name|ru
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|/
literal|1000000.
expr_stmt|;
name|shsmins
operator|=
name|ru
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|/
literal|60
expr_stmt|;
name|shssecs
operator|=
name|ru
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|%
literal|60
operator|+
name|ru
operator|.
name|ru_stime
operator|.
name|tv_usec
operator|/
literal|1000000.
expr_stmt|;
if|if
condition|(
name|getrusage
argument_list|(
name|RUSAGE_CHILDREN
argument_list|,
operator|&
name|ru
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|chumins
operator|=
name|ru
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|/
literal|60
expr_stmt|;
name|chusecs
operator|=
name|ru
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|%
literal|60
operator|+
name|ru
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|/
literal|1000000.
expr_stmt|;
name|chsmins
operator|=
name|ru
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|/
literal|60
expr_stmt|;
name|chssecs
operator|=
name|ru
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|%
literal|60
operator|+
name|ru
operator|.
name|ru_stime
operator|.
name|tv_usec
operator|/
literal|1000000.
expr_stmt|;
name|out1fmt
argument_list|(
literal|"%ldm%.3fs %ldm%.3fs\n%ldm%.3fs %ldm%.3fs\n"
argument_list|,
name|shumins
argument_list|,
name|shusecs
argument_list|,
name|shsmins
argument_list|,
name|shssecs
argument_list|,
name|chumins
argument_list|,
name|chusecs
argument_list|,
name|chsmins
argument_list|,
name|chssecs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

