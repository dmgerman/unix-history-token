begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Kenneth Almquist.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)eval.c	8.9 (Berkeley) 6/8/95";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_comment
comment|/* For WIFSIGNALED(status) */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/*  * Evaluate a command.  */
end_comment

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"nodes.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_include
include|#
directive|include
file|"expand.h"
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_include
include|#
directive|include
file|"redir.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"trap.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_include
include|#
directive|include
file|"memalloc.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"show.h"
end_include

begin_include
include|#
directive|include
file|"mystring.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_HISTORY
end_ifndef

begin_include
include|#
directive|include
file|"myhistedit.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* flags in argument to evaltree */
end_comment

begin_define
define|#
directive|define
name|EV_EXIT
value|01
end_define

begin_comment
comment|/* exit after evaluating tree */
end_comment

begin_define
define|#
directive|define
name|EV_TESTED
value|02
end_define

begin_comment
comment|/* exit status is checked; ignore -e flag */
end_comment

begin_define
define|#
directive|define
name|EV_BACKCMD
value|04
end_define

begin_comment
comment|/* command executing within back quotes */
end_comment

begin_decl_stmt
name|MKINIT
name|int
name|evalskip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if we are skipping commands */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|skipcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of levels to skip */
end_comment

begin_decl_stmt
name|MKINIT
name|int
name|loopnest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current loop nesting level */
end_comment

begin_decl_stmt
name|int
name|funcnest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* depth of function calls */
end_comment

begin_decl_stmt
name|char
modifier|*
name|commandname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|strlist
modifier|*
name|cmdenviron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exitstatus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exit status of last command */
end_comment

begin_decl_stmt
name|int
name|oexitstatus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* saved exit status */
end_comment

begin_function_decl
name|STATIC
name|void
name|evalloop
parameter_list|(
name|union
name|node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|evalfor
parameter_list|(
name|union
name|node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|evalcase
parameter_list|(
name|union
name|node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|evalsubshell
parameter_list|(
name|union
name|node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|expredir
parameter_list|(
name|union
name|node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|evalpipe
parameter_list|(
name|union
name|node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|evalcommand
parameter_list|(
name|union
name|node
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|backcmd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|prehash
parameter_list|(
name|union
name|node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Called to reset things after an exception.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|mkinit
end_ifdef

begin_expr_stmt
name|INCLUDE
literal|"eval.h"
name|RESET
block|{
name|evalskip
operator|=
literal|0
block|;
name|loopnest
operator|=
literal|0
block|;
name|funcnest
operator|=
literal|0
block|; }
name|SHELLPROC
block|{
name|exitstatus
operator|=
literal|0
block|; }
endif|#
directive|endif
comment|/*  * The eval command.  */
name|int
name|evalcmd
argument_list|(
argument|int argc
argument_list|,
argument|char **argv
argument_list|)
block|{
name|char
operator|*
name|p
block|;
name|char
operator|*
name|concat
block|;
name|char
operator|*
operator|*
name|ap
block|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|p
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|STARTSTACKSTR
argument_list|(
name|concat
argument_list|)
expr_stmt|;
name|ap
operator|=
name|argv
operator|+
literal|2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|p
condition|)
name|STPUTC
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|concat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ap
operator|++
operator|)
operator|==
name|NULL
condition|)
break|break;
name|STPUTC
argument_list|(
literal|' '
argument_list|,
name|concat
argument_list|)
expr_stmt|;
block|}
name|STPUTC
argument_list|(
literal|'\0'
argument_list|,
name|concat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p
operator|=
name|grabstackstr
argument_list|(
name|concat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}                 evalstring
operator|(
name|p
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}         return
name|exitstatus
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * Execute a command or commands contained in a string.  */
end_comment

begin_macro
unit|void
name|evalstring
argument_list|(
argument|char *s
argument_list|)
end_macro

begin_block
block|{
name|union
name|node
modifier|*
name|n
decl_stmt|;
name|struct
name|stackmark
name|smark
decl_stmt|;
name|setstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|setinputstring
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|parsecmd
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
name|NEOF
condition|)
block|{
name|evaltree
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
block|}
name|popfile
argument_list|()
expr_stmt|;
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Evaluate a parse tree.  The value is left in the global variable  * exitstatus.  */
end_comment

begin_function
name|void
name|evaltree
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"evaltree(NULL) called\n"
operator|)
argument_list|)
expr_stmt|;
name|exitstatus
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifndef|#
directive|ifndef
name|NO_HISTORY
name|displayhist
operator|=
literal|1
expr_stmt|;
comment|/* show history substitutions done with fc */
endif|#
directive|endif
name|TRACE
argument_list|(
operator|(
literal|"evaltree(0x%lx: %d) called\n"
operator|,
operator|(
name|long
operator|)
name|n
operator|,
name|n
operator|->
name|type
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|NSEMI
case|:
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
condition|)
goto|goto
name|out
goto|;
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAND
case|:
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch1
argument_list|,
name|EV_TESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
operator|||
name|exitstatus
operator|!=
literal|0
condition|)
block|{
name|flags
operator||=
name|EV_TESTED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOR
case|:
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch1
argument_list|,
name|EV_TESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
operator|||
name|exitstatus
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|NREDIR
case|:
name|expredir
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|redirect
argument_list|)
expr_stmt|;
name|redirect
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|redirect
argument_list|,
name|REDIR_PUSH
argument_list|)
expr_stmt|;
name|evaltree
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|popredir
argument_list|()
expr_stmt|;
break|break;
case|case
name|NSUBSHELL
case|:
name|evalsubshell
argument_list|(
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|NBACKGND
case|:
name|evalsubshell
argument_list|(
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|NIF
case|:
block|{
name|evaltree
argument_list|(
name|n
operator|->
name|nif
operator|.
name|test
argument_list|,
name|EV_TESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|exitstatus
operator|==
literal|0
condition|)
name|evaltree
argument_list|(
name|n
operator|->
name|nif
operator|.
name|ifpart
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|->
name|nif
operator|.
name|elsepart
condition|)
name|evaltree
argument_list|(
name|n
operator|->
name|nif
operator|.
name|elsepart
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|exitstatus
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|NWHILE
case|:
case|case
name|NUNTIL
case|:
name|evalloop
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFOR
case|:
name|evalfor
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* 		 * The 'for' command does not set exitstatus, so the value 		 * now in exitstatus is from the last command executed in 		 * the 'for' loop.  That exit value had been tested (wrt 		 * 'sh -e' checking) while processing that command, and 		 * it should not be re-tested here. 		 */
name|flags
operator||=
name|EV_TESTED
expr_stmt|;
break|break;
case|case
name|NCASE
case|:
name|evalcase
argument_list|(
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * The 'case' command does not set exitstatus, so the value 		 * now in exitstatus is from the last command executed in 		 * the 'case' block.  That exit value had been tested (wrt 		 * 'sh -e' checking) while processing that command, and 		 * it should not be re-tested here. 		 */
name|flags
operator||=
name|EV_TESTED
expr_stmt|;
break|break;
case|case
name|NDEFUN
case|:
name|defun
argument_list|(
name|n
operator|->
name|narg
operator|.
name|text
argument_list|,
name|n
operator|->
name|narg
operator|.
name|next
argument_list|)
expr_stmt|;
name|exitstatus
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NNOT
case|:
name|evaltree
argument_list|(
name|n
operator|->
name|nnot
operator|.
name|com
argument_list|,
name|EV_TESTED
argument_list|)
expr_stmt|;
name|exitstatus
operator|=
operator|!
name|exitstatus
expr_stmt|;
break|break;
case|case
name|NPIPE
case|:
name|evalpipe
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|NCMD
case|:
name|evalcommand
argument_list|(
name|n
argument_list|,
name|flags
argument_list|,
operator|(
expr|struct
name|backcmd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|out1fmt
argument_list|(
literal|"Node type = %d\n"
argument_list|,
name|n
operator|->
name|type
argument_list|)
expr_stmt|;
name|flushout
argument_list|(
operator|&
name|output
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
if|if
condition|(
name|pendingsigs
condition|)
name|dotrap
argument_list|()
expr_stmt|;
comment|/* 	 * XXX - Like "!(n->type == NSEMI)", more types will probably 	 * need to be excluded from this test. It's probably better 	 * to set or unset EV_TESTED in the loop above than to bloat 	 * the conditional here. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|EV_EXIT
operator|)
operator|||
operator|(
name|eflag
operator|&&
name|exitstatus
operator|&&
operator|!
operator|(
name|flags
operator|&
name|EV_TESTED
operator|)
operator|&&
operator|!
operator|(
name|n
operator|->
name|type
operator|==
name|NSEMI
operator|)
operator|)
condition|)
name|exitshell
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|evalloop
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|loopnest
operator|++
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch1
argument_list|,
name|EV_TESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
condition|)
block|{
name|skipping
label|:
if|if
condition|(
name|evalskip
operator|==
name|SKIPCONT
operator|&&
operator|--
name|skipcount
operator|<=
literal|0
condition|)
block|{
name|evalskip
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|evalskip
operator|==
name|SKIPBREAK
operator|&&
operator|--
name|skipcount
operator|<=
literal|0
condition|)
name|evalskip
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|NWHILE
condition|)
block|{
if|if
condition|(
name|exitstatus
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|exitstatus
operator|==
literal|0
condition|)
break|break;
block|}
name|evaltree
argument_list|(
name|n
operator|->
name|nbinary
operator|.
name|ch2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|exitstatus
expr_stmt|;
if|if
condition|(
name|evalskip
condition|)
goto|goto
name|skipping
goto|;
block|}
name|loopnest
operator|--
expr_stmt|;
name|exitstatus
operator|=
name|status
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|evalfor
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|arglist
name|arglist
decl_stmt|;
name|union
name|node
modifier|*
name|argp
decl_stmt|;
name|struct
name|strlist
modifier|*
name|sp
decl_stmt|;
name|struct
name|stackmark
name|smark
decl_stmt|;
name|setstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|arglist
operator|.
name|lastp
operator|=
operator|&
name|arglist
operator|.
name|list
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|n
operator|->
name|nfor
operator|.
name|args
init|;
name|argp
condition|;
name|argp
operator|=
name|argp
operator|->
name|narg
operator|.
name|next
control|)
block|{
name|oexitstatus
operator|=
name|exitstatus
expr_stmt|;
name|expandarg
argument_list|(
name|argp
argument_list|,
operator|&
name|arglist
argument_list|,
name|EXP_FULL
operator||
name|EXP_TILDE
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
condition|)
goto|goto
name|out
goto|;
block|}
operator|*
name|arglist
operator|.
name|lastp
operator|=
name|NULL
expr_stmt|;
name|exitstatus
operator|=
literal|0
expr_stmt|;
name|loopnest
operator|++
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|arglist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|setvar
argument_list|(
name|n
operator|->
name|nfor
operator|.
name|var
argument_list|,
name|sp
operator|->
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evaltree
argument_list|(
name|n
operator|->
name|nfor
operator|.
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|evalskip
condition|)
block|{
if|if
condition|(
name|evalskip
operator|==
name|SKIPCONT
operator|&&
operator|--
name|skipcount
operator|<=
literal|0
condition|)
block|{
name|evalskip
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|evalskip
operator|==
name|SKIPBREAK
operator|&&
operator|--
name|skipcount
operator|<=
literal|0
condition|)
name|evalskip
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|loopnest
operator|--
expr_stmt|;
name|out
label|:
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|evalcase
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|union
name|node
modifier|*
name|cp
decl_stmt|;
name|union
name|node
modifier|*
name|patp
decl_stmt|;
name|struct
name|arglist
name|arglist
decl_stmt|;
name|struct
name|stackmark
name|smark
decl_stmt|;
name|setstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|arglist
operator|.
name|lastp
operator|=
operator|&
name|arglist
operator|.
name|list
expr_stmt|;
name|oexitstatus
operator|=
name|exitstatus
expr_stmt|;
name|expandarg
argument_list|(
name|n
operator|->
name|ncase
operator|.
name|expr
argument_list|,
operator|&
name|arglist
argument_list|,
name|EXP_TILDE
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|n
operator|->
name|ncase
operator|.
name|cases
init|;
name|cp
operator|&&
name|evalskip
operator|==
literal|0
condition|;
name|cp
operator|=
name|cp
operator|->
name|nclist
operator|.
name|next
control|)
block|{
for|for
control|(
name|patp
operator|=
name|cp
operator|->
name|nclist
operator|.
name|pattern
init|;
name|patp
condition|;
name|patp
operator|=
name|patp
operator|->
name|narg
operator|.
name|next
control|)
block|{
if|if
condition|(
name|casematch
argument_list|(
name|patp
argument_list|,
name|arglist
operator|.
name|list
operator|->
name|text
argument_list|)
condition|)
block|{
if|if
condition|(
name|evalskip
operator|==
literal|0
condition|)
block|{
name|evaltree
argument_list|(
name|cp
operator|->
name|nclist
operator|.
name|body
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
block|}
block|}
name|out
label|:
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Kick off a subshell to evaluate a tree.  */
end_comment

begin_function
name|STATIC
name|void
name|evalsubshell
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|job
modifier|*
name|jp
decl_stmt|;
name|int
name|backgnd
init|=
operator|(
name|n
operator|->
name|type
operator|==
name|NBACKGND
operator|)
decl_stmt|;
name|expredir
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|redirect
argument_list|)
expr_stmt|;
name|jp
operator|=
name|makejob
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|forkshell
argument_list|(
name|jp
argument_list|,
name|n
argument_list|,
name|backgnd
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|backgnd
condition|)
name|flags
operator|&=
operator|~
name|EV_TESTED
expr_stmt|;
name|redirect
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|redirect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evaltree
argument_list|(
name|n
operator|->
name|nredir
operator|.
name|n
argument_list|,
name|flags
operator||
name|EV_EXIT
argument_list|)
expr_stmt|;
comment|/* never returns */
block|}
if|if
condition|(
operator|!
name|backgnd
condition|)
block|{
name|INTOFF
expr_stmt|;
name|exitstatus
operator|=
name|waitforjob
argument_list|(
name|jp
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compute the names of the files in a redirection list.  */
end_comment

begin_function
name|STATIC
name|void
name|expredir
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|)
block|{
name|union
name|node
modifier|*
name|redir
decl_stmt|;
for|for
control|(
name|redir
operator|=
name|n
init|;
name|redir
condition|;
name|redir
operator|=
name|redir
operator|->
name|nfile
operator|.
name|next
control|)
block|{
name|struct
name|arglist
name|fn
decl_stmt|;
name|fn
operator|.
name|lastp
operator|=
operator|&
name|fn
operator|.
name|list
expr_stmt|;
name|oexitstatus
operator|=
name|exitstatus
expr_stmt|;
switch|switch
condition|(
name|redir
operator|->
name|type
condition|)
block|{
case|case
name|NFROM
case|:
case|case
name|NTO
case|:
case|case
name|NFROMTO
case|:
case|case
name|NAPPEND
case|:
name|expandarg
argument_list|(
name|redir
operator|->
name|nfile
operator|.
name|fname
argument_list|,
operator|&
name|fn
argument_list|,
name|EXP_TILDE
operator||
name|EXP_REDIR
argument_list|)
expr_stmt|;
name|redir
operator|->
name|nfile
operator|.
name|expfname
operator|=
name|fn
operator|.
name|list
operator|->
name|text
expr_stmt|;
break|break;
case|case
name|NFROMFD
case|:
case|case
name|NTOFD
case|:
if|if
condition|(
name|redir
operator|->
name|ndup
operator|.
name|vname
condition|)
block|{
name|expandarg
argument_list|(
name|redir
operator|->
name|ndup
operator|.
name|vname
argument_list|,
operator|&
name|fn
argument_list|,
name|EXP_FULL
operator||
name|EXP_TILDE
argument_list|)
expr_stmt|;
name|fixredir
argument_list|(
name|redir
argument_list|,
name|fn
operator|.
name|list
operator|->
name|text
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Evaluate a pipeline.  All the processes in the pipeline are children  * of the process creating the pipeline.  (This differs from some versions  * of the shell, which make the last process in a pipeline the parent  * of all the rest.)  */
end_comment

begin_function
name|STATIC
name|void
name|evalpipe
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|job
modifier|*
name|jp
decl_stmt|;
name|struct
name|nodelist
modifier|*
name|lp
decl_stmt|;
name|int
name|pipelen
decl_stmt|;
name|int
name|prevfd
decl_stmt|;
name|int
name|pip
index|[
literal|2
index|]
decl_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"evalpipe(0x%lx) called\n"
operator|,
operator|(
name|long
operator|)
name|n
operator|)
argument_list|)
expr_stmt|;
name|pipelen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|n
operator|->
name|npipe
operator|.
name|cmdlist
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
name|pipelen
operator|++
expr_stmt|;
name|INTOFF
expr_stmt|;
name|jp
operator|=
name|makejob
argument_list|(
name|n
argument_list|,
name|pipelen
argument_list|)
expr_stmt|;
name|prevfd
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|n
operator|->
name|npipe
operator|.
name|cmdlist
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
name|prehash
argument_list|(
name|lp
operator|->
name|n
argument_list|)
expr_stmt|;
name|pip
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pip
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|prevfd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Pipe call failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|forkshell
argument_list|(
name|jp
argument_list|,
name|lp
operator|->
name|n
argument_list|,
name|n
operator|->
name|npipe
operator|.
name|backgnd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INTON
expr_stmt|;
if|if
condition|(
name|prevfd
operator|>
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|copyfd
argument_list|(
name|prevfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|prevfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pip
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|prevfd
operator|>=
literal|0
operator|&&
name|pip
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
name|close
argument_list|(
name|pip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pip
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
block|{
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|copyfd
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|evaltree
argument_list|(
name|lp
operator|->
name|n
argument_list|,
name|EV_EXIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prevfd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|prevfd
argument_list|)
expr_stmt|;
name|prevfd
operator|=
name|pip
index|[
literal|0
index|]
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|INTON
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|npipe
operator|.
name|backgnd
operator|==
literal|0
condition|)
block|{
name|INTOFF
expr_stmt|;
name|exitstatus
operator|=
name|waitforjob
argument_list|(
name|jp
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"evalpipe:  job done exit status %d\n"
operator|,
name|exitstatus
operator|)
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Execute a command inside back quotes.  If it's a builtin command, we  * want to save its output in a block obtained from malloc.  Otherwise  * we fork off a subprocess and get the output of the command via a pipe.  * Should be called with interrupts off.  */
end_comment

begin_function
name|void
name|evalbackcmd
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|,
name|struct
name|backcmd
modifier|*
name|result
parameter_list|)
block|{
name|int
name|pip
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|job
modifier|*
name|jp
decl_stmt|;
name|struct
name|stackmark
name|smark
decl_stmt|;
comment|/* unnecessary */
name|setstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|result
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|result
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|nleft
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|jp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|exitstatus
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|NCMD
condition|)
block|{
name|exitstatus
operator|=
name|oexitstatus
expr_stmt|;
name|evalcommand
argument_list|(
name|n
argument_list|,
name|EV_BACKCMD
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exitstatus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pip
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Pipe call failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|jp
operator|=
name|makejob
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|forkshell
argument_list|(
name|jp
argument_list|,
name|n
argument_list|,
name|FORK_NOJOB
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FORCEINTON
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pip
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
block|{
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|copyfd
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|evaltree
argument_list|(
name|n
argument_list|,
name|EV_EXIT
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|result
operator|->
name|fd
operator|=
name|pip
index|[
literal|0
index|]
expr_stmt|;
name|result
operator|->
name|jp
operator|=
name|jp
expr_stmt|;
block|}
name|out
label|:
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"evalbackcmd done: fd=%d buf=0x%x nleft=%d jp=0x%x\n"
operator|,
name|result
operator|->
name|fd
operator|,
name|result
operator|->
name|buf
operator|,
name|result
operator|->
name|nleft
operator|,
name|result
operator|->
name|jp
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Execute a simple command.  */
end_comment

begin_function
name|STATIC
name|void
name|evalcommand
parameter_list|(
name|union
name|node
modifier|*
name|cmd
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|backcmd
modifier|*
name|backcmd
parameter_list|)
block|{
name|struct
name|stackmark
name|smark
decl_stmt|;
name|union
name|node
modifier|*
name|argp
decl_stmt|;
name|struct
name|arglist
name|arglist
decl_stmt|;
name|struct
name|arglist
name|varlist
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|int
name|varflag
decl_stmt|;
name|struct
name|strlist
modifier|*
name|sp
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|pip
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|cmdentry
name|cmdentry
decl_stmt|;
name|struct
name|job
modifier|*
name|jp
decl_stmt|;
name|struct
name|jmploc
name|jmploc
decl_stmt|;
name|struct
name|jmploc
modifier|*
specifier|volatile
name|savehandler
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|savecmdname
decl_stmt|;
specifier|volatile
name|struct
name|shparam
name|saveparam
decl_stmt|;
name|struct
name|localvar
modifier|*
specifier|volatile
name|savelocalvars
decl_stmt|;
specifier|volatile
name|int
name|e
decl_stmt|;
name|char
modifier|*
name|lastarg
decl_stmt|;
name|int
name|realstatus
decl_stmt|;
name|int
name|do_clearcmdentry
decl_stmt|;
if|#
directive|if
name|__GNUC__
comment|/* Avoid longjmp clobbering */
operator|(
name|void
operator|)
operator|&
name|argv
expr_stmt|;
operator|(
name|void
operator|)
operator|&
name|argc
expr_stmt|;
operator|(
name|void
operator|)
operator|&
name|lastarg
expr_stmt|;
operator|(
name|void
operator|)
operator|&
name|flags
expr_stmt|;
operator|(
name|void
operator|)
operator|&
name|do_clearcmdentry
expr_stmt|;
endif|#
directive|endif
comment|/* First expand the arguments. */
name|TRACE
argument_list|(
operator|(
literal|"evalcommand(0x%lx, %d) called\n"
operator|,
operator|(
name|long
operator|)
name|cmd
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|setstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
name|arglist
operator|.
name|lastp
operator|=
operator|&
name|arglist
operator|.
name|list
expr_stmt|;
name|varlist
operator|.
name|lastp
operator|=
operator|&
name|varlist
operator|.
name|list
expr_stmt|;
name|varflag
operator|=
literal|1
expr_stmt|;
name|do_clearcmdentry
operator|=
literal|0
expr_stmt|;
name|oexitstatus
operator|=
name|exitstatus
expr_stmt|;
name|exitstatus
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|cmd
operator|->
name|ncmd
operator|.
name|args
init|;
name|argp
condition|;
name|argp
operator|=
name|argp
operator|->
name|narg
operator|.
name|next
control|)
block|{
name|char
modifier|*
name|p
init|=
name|argp
operator|->
name|narg
operator|.
name|text
decl_stmt|;
if|if
condition|(
name|varflag
operator|&&
name|is_name
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|is_in_name
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
name|expandarg
argument_list|(
name|argp
argument_list|,
operator|&
name|varlist
argument_list|,
name|EXP_VARTILDE
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|expandarg
argument_list|(
name|argp
argument_list|,
operator|&
name|arglist
argument_list|,
name|EXP_FULL
operator||
name|EXP_TILDE
argument_list|)
expr_stmt|;
name|varflag
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|arglist
operator|.
name|lastp
operator|=
name|NULL
expr_stmt|;
operator|*
name|varlist
operator|.
name|lastp
operator|=
name|NULL
expr_stmt|;
name|expredir
argument_list|(
name|cmd
operator|->
name|ncmd
operator|.
name|redirect
argument_list|)
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|arglist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|argc
operator|++
expr_stmt|;
name|argv
operator|=
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|arglist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"evalcommand arg: %s\n"
operator|,
name|sp
operator|->
name|text
operator|)
argument_list|)
expr_stmt|;
operator|*
name|argv
operator|++
operator|=
name|sp
operator|->
name|text
expr_stmt|;
block|}
operator|*
name|argv
operator|=
name|NULL
expr_stmt|;
name|lastarg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|iflag
operator|&&
name|funcnest
operator|==
literal|0
operator|&&
name|argc
operator|>
literal|0
condition|)
name|lastarg
operator|=
name|argv
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|argv
operator|-=
name|argc
expr_stmt|;
comment|/* Print the command if xflag is set. */
if|if
condition|(
name|xflag
condition|)
block|{
name|outc
argument_list|(
literal|'+'
argument_list|,
operator|&
name|errout
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|varlist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|outc
argument_list|(
literal|' '
argument_list|,
operator|&
name|errout
argument_list|)
expr_stmt|;
name|out2str
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|arglist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|outc
argument_list|(
literal|' '
argument_list|,
operator|&
name|errout
argument_list|)
expr_stmt|;
name|out2str
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
name|outc
argument_list|(
literal|'\n'
argument_list|,
operator|&
name|errout
argument_list|)
expr_stmt|;
name|flushout
argument_list|(
operator|&
name|errout
argument_list|)
expr_stmt|;
block|}
comment|/* Now locate the command. */
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|cmdentry
operator|.
name|cmdtype
operator|=
name|CMDBUILTIN
expr_stmt|;
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|=
name|BLTINCMD
expr_stmt|;
block|}
else|else
block|{
specifier|static
specifier|const
name|char
name|PATH
index|[]
init|=
literal|"PATH="
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|pathval
argument_list|()
decl_stmt|;
comment|/* 		 * Modify the command lookup path, if a PATH= assignment 		 * is present 		 */
for|for
control|(
name|sp
operator|=
name|varlist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|sp
operator|->
name|text
argument_list|,
name|PATH
argument_list|,
sizeof|sizeof
argument_list|(
name|PATH
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|path
operator|=
name|sp
operator|->
name|text
operator|+
sizeof|sizeof
argument_list|(
name|PATH
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/*  				 * On `PATH=... command`, we need to make 				 * sure that the command isn't using the 				 * non-updated hash table of the outer PATH 				 * setting and we need to make sure that  				 * the hash table isn't filled with items 				 * from the temporary setting. 				 * 				 * It would be better to forbit using and  				 * updating the table while this command 				 * runs, by the command finding mechanism 				 * is heavily integrated with hash handling, 				 * so we just delete the hash before and after 				 * the command runs. Partly deleting like 				 * changepatch() does doesn't seem worth the 				 * bookinging effort, since most such runs add 				 * diretories in front of the new PATH. 				 */
name|clearcmdentry
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|do_clearcmdentry
operator|=
literal|1
expr_stmt|;
block|}
name|find_command
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|cmdentry
argument_list|,
literal|1
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdentry
operator|.
name|cmdtype
operator|==
name|CMDUNKNOWN
condition|)
block|{
comment|/* command not found */
name|exitstatus
operator|=
literal|127
expr_stmt|;
name|flushout
argument_list|(
operator|&
name|errout
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* implement the bltin builtin here */
if|if
condition|(
name|cmdentry
operator|.
name|cmdtype
operator|==
name|CMDBUILTIN
operator|&&
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|BLTINCMD
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|argc
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|=
name|find_builtin
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|outfmt
argument_list|(
operator|&
name|errout
argument_list|,
literal|"%s: not found\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exitstatus
operator|=
literal|127
expr_stmt|;
name|flushout
argument_list|(
operator|&
name|errout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|!=
name|BLTINCMD
condition|)
break|break;
block|}
block|}
block|}
comment|/* Fork off a child process if necessary. */
if|if
condition|(
name|cmd
operator|->
name|ncmd
operator|.
name|backgnd
operator|||
operator|(
name|cmdentry
operator|.
name|cmdtype
operator|==
name|CMDNORMAL
operator|&&
operator|(
operator|(
name|flags
operator|&
name|EV_EXIT
operator|)
operator|==
literal|0
operator|||
name|Tflag
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|EV_BACKCMD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|cmdentry
operator|.
name|cmdtype
operator|!=
name|CMDBUILTIN
operator|||
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|CDCMD
operator|||
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|DOTCMD
operator|||
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|EVALCMD
operator|)
operator|)
condition|)
block|{
name|jp
operator|=
name|makejob
argument_list|(
name|cmd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mode
operator|=
name|cmd
operator|->
name|ncmd
operator|.
name|backgnd
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EV_BACKCMD
condition|)
block|{
name|mode
operator|=
name|FORK_NOJOB
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pip
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Pipe call failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|forkshell
argument_list|(
name|jp
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|parent
goto|;
comment|/* at end of routine */
if|if
condition|(
name|flags
operator|&
name|EV_BACKCMD
condition|)
block|{
name|FORCEINTON
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pip
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
block|{
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|copyfd
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|flags
operator||=
name|EV_EXIT
expr_stmt|;
block|}
comment|/* This is the child process if a fork occurred. */
comment|/* Execute the command. */
if|if
condition|(
name|cmdentry
operator|.
name|cmdtype
operator|==
name|CMDFUNCTION
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|trputs
argument_list|(
literal|"Shell function:  "
argument_list|)
expr_stmt|;
name|trargs
argument_list|(
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|redirect
argument_list|(
name|cmd
operator|->
name|ncmd
operator|.
name|redirect
argument_list|,
name|REDIR_PUSH
argument_list|)
expr_stmt|;
name|saveparam
operator|=
name|shellparam
expr_stmt|;
name|shellparam
operator|.
name|malloc
operator|=
literal|0
expr_stmt|;
name|shellparam
operator|.
name|reset
operator|=
literal|1
expr_stmt|;
name|shellparam
operator|.
name|nparam
operator|=
name|argc
operator|-
literal|1
expr_stmt|;
name|shellparam
operator|.
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|shellparam
operator|.
name|optnext
operator|=
name|NULL
expr_stmt|;
name|INTOFF
expr_stmt|;
name|savelocalvars
operator|=
name|localvars
expr_stmt|;
name|localvars
operator|=
name|NULL
expr_stmt|;
name|INTON
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmploc
operator|.
name|loc
argument_list|)
condition|)
block|{
if|if
condition|(
name|exception
operator|==
name|EXSHELLPROC
condition|)
name|freeparam
argument_list|(
operator|(
expr|struct
name|shparam
operator|*
operator|)
operator|&
name|saveparam
argument_list|)
expr_stmt|;
else|else
block|{
name|freeparam
argument_list|(
operator|&
name|shellparam
argument_list|)
expr_stmt|;
name|shellparam
operator|=
name|saveparam
expr_stmt|;
block|}
name|poplocalvars
argument_list|()
expr_stmt|;
name|localvars
operator|=
name|savelocalvars
expr_stmt|;
name|handler
operator|=
name|savehandler
expr_stmt|;
name|longjmp
argument_list|(
name|handler
operator|->
name|loc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|savehandler
operator|=
name|handler
expr_stmt|;
name|handler
operator|=
operator|&
name|jmploc
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|varlist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|mklocal
argument_list|(
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
name|funcnest
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EV_TESTED
condition|)
name|evaltree
argument_list|(
name|cmdentry
operator|.
name|u
operator|.
name|func
argument_list|,
name|EV_TESTED
argument_list|)
expr_stmt|;
else|else
name|evaltree
argument_list|(
name|cmdentry
operator|.
name|u
operator|.
name|func
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funcnest
operator|--
expr_stmt|;
name|INTOFF
expr_stmt|;
name|poplocalvars
argument_list|()
expr_stmt|;
name|localvars
operator|=
name|savelocalvars
expr_stmt|;
name|freeparam
argument_list|(
operator|&
name|shellparam
argument_list|)
expr_stmt|;
name|shellparam
operator|=
name|saveparam
expr_stmt|;
name|handler
operator|=
name|savehandler
expr_stmt|;
name|popredir
argument_list|()
expr_stmt|;
name|INTON
expr_stmt|;
if|if
condition|(
name|evalskip
operator|==
name|SKIPFUNC
condition|)
block|{
name|evalskip
operator|=
literal|0
expr_stmt|;
name|skipcount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|EV_EXIT
condition|)
name|exitshell
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmdentry
operator|.
name|cmdtype
operator|==
name|CMDBUILTIN
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|trputs
argument_list|(
literal|"builtin command:  "
argument_list|)
expr_stmt|;
name|trargs
argument_list|(
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mode
operator|=
operator|(
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|EXECCMD
operator|)
condition|?
literal|0
else|:
name|REDIR_PUSH
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|EV_BACKCMD
condition|)
block|{
name|memout
operator|.
name|nleft
operator|=
literal|0
expr_stmt|;
name|memout
operator|.
name|nextc
operator|=
name|memout
operator|.
name|buf
expr_stmt|;
name|memout
operator|.
name|bufsize
operator|=
literal|64
expr_stmt|;
name|mode
operator||=
name|REDIR_BACKQ
expr_stmt|;
block|}
name|redirect
argument_list|(
name|cmd
operator|->
name|ncmd
operator|.
name|redirect
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|savecmdname
operator|=
name|commandname
expr_stmt|;
name|cmdenviron
operator|=
name|varlist
operator|.
name|list
expr_stmt|;
name|e
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmploc
operator|.
name|loc
argument_list|)
condition|)
block|{
name|e
operator|=
name|exception
expr_stmt|;
name|exitstatus
operator|=
operator|(
name|e
operator|==
name|EXINT
operator|)
condition|?
name|SIGINT
operator|+
literal|128
else|:
literal|2
expr_stmt|;
goto|goto
name|cmddone
goto|;
block|}
name|savehandler
operator|=
name|handler
expr_stmt|;
name|handler
operator|=
operator|&
name|jmploc
expr_stmt|;
name|commandname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argptr
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|optptr
operator|=
name|NULL
expr_stmt|;
comment|/* initialize nextopt */
name|exitstatus
operator|=
call|(
modifier|*
name|builtinfunc
index|[
name|cmdentry
operator|.
name|u
operator|.
name|index
index|]
call|)
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|flushall
argument_list|()
expr_stmt|;
name|cmddone
label|:
name|cmdenviron
operator|=
name|NULL
expr_stmt|;
name|out1
operator|=
operator|&
name|output
expr_stmt|;
name|out2
operator|=
operator|&
name|errout
expr_stmt|;
name|freestdout
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|EXSHELLPROC
condition|)
block|{
name|commandname
operator|=
name|savecmdname
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EV_EXIT
condition|)
block|{
name|exitshell
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
block|}
name|handler
operator|=
name|savehandler
expr_stmt|;
if|if
condition|(
name|e
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|!=
name|EXERROR
operator|&&
name|e
operator|!=
name|EXEXEC
operator|)
operator|||
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|BLTINCMD
operator|||
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|DOTCMD
operator|||
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|EVALCMD
ifndef|#
directive|ifndef
name|NO_HISTORY
operator|||
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|HISTCMD
endif|#
directive|endif
operator|||
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|==
name|EXECCMD
condition|)
name|exraise
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|FORCEINTON
expr_stmt|;
block|}
if|if
condition|(
name|cmdentry
operator|.
name|u
operator|.
name|index
operator|!=
name|EXECCMD
condition|)
name|popredir
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|EV_BACKCMD
condition|)
block|{
name|backcmd
operator|->
name|buf
operator|=
name|memout
operator|.
name|buf
expr_stmt|;
name|backcmd
operator|->
name|nleft
operator|=
name|memout
operator|.
name|nextc
operator|-
name|memout
operator|.
name|buf
expr_stmt|;
name|memout
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|trputs
argument_list|(
literal|"normal command:  "
argument_list|)
expr_stmt|;
name|trargs
argument_list|(
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clearredir
argument_list|()
expr_stmt|;
name|redirect
argument_list|(
name|cmd
operator|->
name|ncmd
operator|.
name|redirect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|varlist
operator|.
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|setvareq
argument_list|(
name|sp
operator|->
name|text
argument_list|,
name|VEXPORT
operator||
name|VSTACK
argument_list|)
expr_stmt|;
name|envp
operator|=
name|environment
argument_list|()
expr_stmt|;
name|shellexec
argument_list|(
name|argv
argument_list|,
name|envp
argument_list|,
name|pathval
argument_list|()
argument_list|,
name|cmdentry
operator|.
name|u
operator|.
name|index
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
goto|goto
name|out
goto|;
name|parent
label|:
comment|/* parent process gets here (if we forked) */
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
block|{
comment|/* argument to fork */
name|INTOFF
expr_stmt|;
name|exitstatus
operator|=
name|waitforjob
argument_list|(
name|jp
argument_list|,
operator|&
name|realstatus
argument_list|)
expr_stmt|;
name|INTON
expr_stmt|;
if|if
condition|(
name|iflag
operator|&&
name|loopnest
operator|>
literal|0
operator|&&
name|WIFSIGNALED
argument_list|(
name|realstatus
argument_list|)
condition|)
block|{
name|evalskip
operator|=
name|SKIPBREAK
expr_stmt|;
name|skipcount
operator|=
name|loopnest
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
literal|2
condition|)
block|{
name|backcmd
operator|->
name|fd
operator|=
name|pip
index|[
literal|0
index|]
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|backcmd
operator|->
name|jp
operator|=
name|jp
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|lastarg
condition|)
name|setvar
argument_list|(
literal|"_"
argument_list|,
name|lastarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_clearcmdentry
condition|)
name|clearcmdentry
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|popstackmark
argument_list|(
operator|&
name|smark
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Search for a command.  This is called before we fork so that the  * location of the command will be available in the parent as well as  * the child.  The check for "goodname" is an overly conservative  * check that the name will not be subject to expansion.  */
end_comment

begin_function
name|STATIC
name|void
name|prehash
parameter_list|(
name|union
name|node
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|cmdentry
name|entry
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|NCMD
operator|&&
name|n
operator|->
name|ncmd
operator|.
name|args
condition|)
if|if
condition|(
name|goodname
argument_list|(
name|n
operator|->
name|ncmd
operator|.
name|args
operator|->
name|narg
operator|.
name|text
argument_list|)
condition|)
name|find_command
argument_list|(
name|n
operator|->
name|ncmd
operator|.
name|args
operator|->
name|narg
operator|.
name|text
argument_list|,
operator|&
name|entry
argument_list|,
literal|0
argument_list|,
name|pathval
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Builtin commands.  Builtin commands whose functions are closely  * tied to evaluation are implemented here.  */
end_comment

begin_comment
comment|/*  * No command given, or a bltin command with no arguments.  Set the  * specified variables.  */
end_comment

begin_function
name|int
name|bltincmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
name|listsetvar
argument_list|(
name|cmdenviron
argument_list|)
expr_stmt|;
comment|/* 	 * Preserve exitstatus of a previous possible redirection 	 * as POSIX mandates 	 */
return|return
name|exitstatus
return|;
block|}
end_function

begin_comment
comment|/*  * Handle break and continue commands.  Break, continue, and return are  * all handled by setting the evalskip flag.  The evaluation routines  * above all check this flag, and if it is set they start skipping  * commands rather than executing them.  The variable skipcount is  * the number of loops to break/continue, or the number of function  * levels to return.  (The latter is always 1.)  It should probably  * be an error to break out of more loops than exist, but it isn't  * in the standard shell so we don't make it one here.  */
end_comment

begin_function
name|int
name|breakcmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|n
init|=
name|argc
operator|>
literal|1
condition|?
name|number
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|loopnest
condition|)
name|n
operator|=
name|loopnest
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|evalskip
operator|=
operator|(
operator|*
operator|*
name|argv
operator|==
literal|'c'
operator|)
condition|?
name|SKIPCONT
else|:
name|SKIPBREAK
expr_stmt|;
name|skipcount
operator|=
name|n
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The return command.  */
end_comment

begin_function
name|int
name|returncmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ret
init|=
name|argc
operator|>
literal|1
condition|?
name|number
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
else|:
name|oexitstatus
decl_stmt|;
if|if
condition|(
name|funcnest
condition|)
block|{
name|evalskip
operator|=
name|SKIPFUNC
expr_stmt|;
name|skipcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* skip the rest of the file */
name|evalskip
operator|=
name|SKIPFILE
expr_stmt|;
name|skipcount
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|falsecmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|truecmd
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|__unused
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|execcmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|struct
name|strlist
modifier|*
name|sp
decl_stmt|;
name|iflag
operator|=
literal|0
expr_stmt|;
comment|/* exit on error */
name|mflag
operator|=
literal|0
expr_stmt|;
name|optschanged
argument_list|()
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|cmdenviron
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|setvareq
argument_list|(
name|sp
operator|->
name|text
argument_list|,
name|VEXPORT
operator||
name|VSTACK
argument_list|)
expr_stmt|;
name|shellexec
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|environment
argument_list|()
argument_list|,
name|pathval
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

