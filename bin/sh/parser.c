begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Kenneth Almquist.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)parser.c	8.1 (Berkeley) 5/31/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|"nodes.h"
end_include

begin_include
include|#
directive|include
file|"expand.h"
end_include

begin_comment
comment|/* defines rmescapes() */
end_comment

begin_include
include|#
directive|include
file|"redir.h"
end_include

begin_comment
comment|/* defines copyfd() */
end_comment

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"memalloc.h"
end_include

begin_include
include|#
directive|include
file|"mystring.h"
end_include

begin_include
include|#
directive|include
file|"alias.h"
end_include

begin_include
include|#
directive|include
file|"myhistedit.h"
end_include

begin_comment
comment|/*  * Shell command parser.  */
end_comment

begin_define
define|#
directive|define
name|EOFMARKLEN
value|79
end_define

begin_comment
comment|/* values returned by readtoken */
end_comment

begin_include
include|#
directive|include
file|"token.def"
end_include

begin_struct
struct|struct
name|heredoc
block|{
name|struct
name|heredoc
modifier|*
name|next
decl_stmt|;
comment|/* next here document in list */
name|union
name|node
modifier|*
name|here
decl_stmt|;
comment|/* redirection node */
name|char
modifier|*
name|eofmark
decl_stmt|;
comment|/* string indicating end of input */
name|int
name|striptabs
decl_stmt|;
comment|/* if set, strip leading tabs */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|heredoc
modifier|*
name|heredoclist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of here documents to read */
end_comment

begin_decl_stmt
name|int
name|parsebackquote
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero if we are inside backquotes */
end_comment

begin_decl_stmt
name|int
name|doprompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, prompt the user */
end_comment

begin_decl_stmt
name|int
name|needprompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if interactive and at start of line */
end_comment

begin_decl_stmt
name|int
name|lasttoken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last token read */
end_comment

begin_decl_stmt
name|MKINIT
name|int
name|tokpushback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last token pushed back */
end_comment

begin_decl_stmt
name|char
modifier|*
name|wordtext
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* text of last word returned by readtoken */
end_comment

begin_decl_stmt
name|MKINIT
name|int
name|checkkwd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 == check for kwds, 2 == also eat newlines */
end_comment

begin_decl_stmt
name|struct
name|nodelist
modifier|*
name|backquotelist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|node
modifier|*
name|redirnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|heredoc
modifier|*
name|heredoc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quoteflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if (part of) last token was quoted */
end_comment

begin_decl_stmt
name|int
name|startlinno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line # where last token started */
end_comment

begin_define
define|#
directive|define
name|GDB_HACK
value|1
end_define

begin_comment
comment|/* avoid local declarations which gdb can't handle */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_HACK
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|argvars
index|[
literal|5
index|]
init|=
block|{
name|CTLVAR
block|,
name|VSNORMAL
operator||
name|VSQUOTE
block|,
literal|'@'
block|,
literal|'='
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|types
index|[]
init|=
literal|"}-+?="
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|STATIC
name|union
name|node
modifier|*
name|list
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|union
name|node
modifier|*
name|andor
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|union
name|node
modifier|*
name|pipeline
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|union
name|node
modifier|*
name|command
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|union
name|node
modifier|*
name|simplecmd
name|__P
argument_list|(
operator|(
expr|union
name|node
operator|*
operator|*
operator|,
expr|union
name|node
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parsefname
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|parseheredoc
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|readtoken
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|readtoken1
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|attyline
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|noexpand
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|synexpect
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|synerror
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|setprompt
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read and parse a command.  Returns NEOF on end of file.  (NULL is a  * valid parse tree indicating a blank line.)  */
end_comment

begin_function
name|union
name|node
modifier|*
name|parsecmd
parameter_list|(
name|interact
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|doprompt
operator|=
name|interact
expr_stmt|;
if|if
condition|(
name|doprompt
condition|)
name|setprompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|setprompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|needprompt
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|readtoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TEOF
condition|)
return|return
name|NEOF
return|;
if|if
condition|(
name|t
operator|==
name|TNL
condition|)
return|return
name|NULL
return|;
name|tokpushback
operator|++
expr_stmt|;
return|return
name|list
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|union
name|node
modifier|*
name|list
parameter_list|(
name|nlflag
parameter_list|)
block|{
name|union
name|node
modifier|*
name|n1
decl_stmt|,
modifier|*
name|n2
decl_stmt|,
modifier|*
name|n3
decl_stmt|;
name|checkkwd
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|nlflag
operator|==
literal|0
operator|&&
name|tokendlist
index|[
name|peektoken
argument_list|()
index|]
condition|)
return|return
name|NULL
return|;
name|n1
operator|=
name|andor
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|readtoken
argument_list|()
condition|)
block|{
case|case
name|TBACKGND
case|:
if|if
condition|(
name|n1
operator|->
name|type
operator|==
name|NCMD
operator|||
name|n1
operator|->
name|type
operator|==
name|NPIPE
condition|)
block|{
name|n1
operator|->
name|ncmd
operator|.
name|backgnd
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n1
operator|->
name|type
operator|==
name|NREDIR
condition|)
block|{
name|n1
operator|->
name|type
operator|=
name|NBACKGND
expr_stmt|;
block|}
else|else
block|{
name|n3
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nredir
argument_list|)
argument_list|)
expr_stmt|;
name|n3
operator|->
name|type
operator|=
name|NBACKGND
expr_stmt|;
name|n3
operator|->
name|nredir
operator|.
name|n
operator|=
name|n1
expr_stmt|;
name|n3
operator|->
name|nredir
operator|.
name|redirect
operator|=
name|NULL
expr_stmt|;
name|n1
operator|=
name|n3
expr_stmt|;
block|}
goto|goto
name|tsemi
goto|;
case|case
name|TNL
case|:
name|tokpushback
operator|++
expr_stmt|;
comment|/* fall through */
name|tsemi
label|:
case|case
name|TSEMI
case|:
if|if
condition|(
name|readtoken
argument_list|()
operator|==
name|TNL
condition|)
block|{
name|parseheredoc
argument_list|()
expr_stmt|;
if|if
condition|(
name|nlflag
condition|)
return|return
name|n1
return|;
block|}
else|else
block|{
name|tokpushback
operator|++
expr_stmt|;
block|}
name|checkkwd
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|tokendlist
index|[
name|peektoken
argument_list|()
index|]
condition|)
return|return
name|n1
return|;
name|n2
operator|=
name|andor
argument_list|()
expr_stmt|;
name|n3
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nbinary
argument_list|)
argument_list|)
expr_stmt|;
name|n3
operator|->
name|type
operator|=
name|NSEMI
expr_stmt|;
name|n3
operator|->
name|nbinary
operator|.
name|ch1
operator|=
name|n1
expr_stmt|;
name|n3
operator|->
name|nbinary
operator|.
name|ch2
operator|=
name|n2
expr_stmt|;
name|n1
operator|=
name|n3
expr_stmt|;
break|break;
case|case
name|TEOF
case|:
if|if
condition|(
name|heredoclist
condition|)
name|parseheredoc
argument_list|()
expr_stmt|;
else|else
name|pungetc
argument_list|()
expr_stmt|;
comment|/* push back EOF on input */
return|return
name|n1
return|;
default|default:
if|if
condition|(
name|nlflag
condition|)
name|synexpect
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tokpushback
operator|++
expr_stmt|;
return|return
name|n1
return|;
block|}
block|}
block|}
end_function

begin_function
name|STATIC
name|union
name|node
modifier|*
name|andor
parameter_list|()
block|{
name|union
name|node
modifier|*
name|n1
decl_stmt|,
modifier|*
name|n2
decl_stmt|,
modifier|*
name|n3
decl_stmt|;
name|int
name|t
decl_stmt|;
name|n1
operator|=
name|pipeline
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|readtoken
argument_list|()
operator|)
operator|==
name|TAND
condition|)
block|{
name|t
operator|=
name|NAND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|TOR
condition|)
block|{
name|t
operator|=
name|NOR
expr_stmt|;
block|}
else|else
block|{
name|tokpushback
operator|++
expr_stmt|;
return|return
name|n1
return|;
block|}
name|n2
operator|=
name|pipeline
argument_list|()
expr_stmt|;
name|n3
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nbinary
argument_list|)
argument_list|)
expr_stmt|;
name|n3
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|n3
operator|->
name|nbinary
operator|.
name|ch1
operator|=
name|n1
expr_stmt|;
name|n3
operator|->
name|nbinary
operator|.
name|ch2
operator|=
name|n2
expr_stmt|;
name|n1
operator|=
name|n3
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|union
name|node
modifier|*
name|pipeline
parameter_list|()
block|{
name|union
name|node
modifier|*
name|n1
decl_stmt|,
modifier|*
name|pipenode
decl_stmt|,
modifier|*
name|notnode
decl_stmt|;
name|struct
name|nodelist
modifier|*
name|lp
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|negate
init|=
literal|0
decl_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"pipeline: entered\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|readtoken
argument_list|()
operator|==
name|TNOT
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"pipeline: TNOT recognized\n"
operator|)
argument_list|)
expr_stmt|;
name|negate
operator|=
operator|!
name|negate
expr_stmt|;
block|}
name|tokpushback
operator|++
expr_stmt|;
name|n1
operator|=
name|command
argument_list|()
expr_stmt|;
if|if
condition|(
name|readtoken
argument_list|()
operator|==
name|TPIPE
condition|)
block|{
name|pipenode
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|npipe
argument_list|)
argument_list|)
expr_stmt|;
name|pipenode
operator|->
name|type
operator|=
name|NPIPE
expr_stmt|;
name|pipenode
operator|->
name|npipe
operator|.
name|backgnd
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
operator|(
expr|struct
name|nodelist
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nodelist
argument_list|)
argument_list|)
expr_stmt|;
name|pipenode
operator|->
name|npipe
operator|.
name|cmdlist
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|n
operator|=
name|n1
expr_stmt|;
do|do
block|{
name|prev
operator|=
name|lp
expr_stmt|;
name|lp
operator|=
operator|(
expr|struct
name|nodelist
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nodelist
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|n
operator|=
name|command
argument_list|()
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|lp
expr_stmt|;
block|}
do|while
condition|(
name|readtoken
argument_list|()
operator|==
name|TPIPE
condition|)
do|;
name|lp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n1
operator|=
name|pipenode
expr_stmt|;
block|}
name|tokpushback
operator|++
expr_stmt|;
if|if
condition|(
name|negate
condition|)
block|{
name|notnode
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nnot
argument_list|)
argument_list|)
expr_stmt|;
name|notnode
operator|->
name|type
operator|=
name|NNOT
expr_stmt|;
name|notnode
operator|->
name|nnot
operator|.
name|com
operator|=
name|n1
expr_stmt|;
name|n1
operator|=
name|notnode
expr_stmt|;
block|}
return|return
name|n1
return|;
block|}
end_function

begin_function
name|STATIC
name|union
name|node
modifier|*
name|command
parameter_list|()
block|{
name|union
name|node
modifier|*
name|n1
decl_stmt|,
modifier|*
name|n2
decl_stmt|;
name|union
name|node
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|app
decl_stmt|;
name|union
name|node
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|union
name|node
modifier|*
name|redir
decl_stmt|,
modifier|*
modifier|*
name|rpp
decl_stmt|;
name|int
name|t
decl_stmt|;
name|checkkwd
operator|=
literal|2
expr_stmt|;
name|redir
operator|=
literal|0
expr_stmt|;
name|rpp
operator|=
operator|&
name|redir
expr_stmt|;
comment|/* Check for redirection which may precede command */
while|while
condition|(
name|readtoken
argument_list|()
operator|==
name|TREDIR
condition|)
block|{
operator|*
name|rpp
operator|=
name|n2
operator|=
name|redirnode
expr_stmt|;
name|rpp
operator|=
operator|&
name|n2
operator|->
name|nfile
operator|.
name|next
expr_stmt|;
name|parsefname
argument_list|()
expr_stmt|;
block|}
name|tokpushback
operator|++
expr_stmt|;
switch|switch
condition|(
name|readtoken
argument_list|()
condition|)
block|{
case|case
name|TIF
case|:
name|n1
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nif
argument_list|)
argument_list|)
expr_stmt|;
name|n1
operator|->
name|type
operator|=
name|NIF
expr_stmt|;
name|n1
operator|->
name|nif
operator|.
name|test
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readtoken
argument_list|()
operator|!=
name|TTHEN
condition|)
name|synexpect
argument_list|(
name|TTHEN
argument_list|)
expr_stmt|;
name|n1
operator|->
name|nif
operator|.
name|ifpart
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|n2
operator|=
name|n1
expr_stmt|;
while|while
condition|(
name|readtoken
argument_list|()
operator|==
name|TELIF
condition|)
block|{
name|n2
operator|->
name|nif
operator|.
name|elsepart
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nif
argument_list|)
argument_list|)
expr_stmt|;
name|n2
operator|=
name|n2
operator|->
name|nif
operator|.
name|elsepart
expr_stmt|;
name|n2
operator|->
name|type
operator|=
name|NIF
expr_stmt|;
name|n2
operator|->
name|nif
operator|.
name|test
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readtoken
argument_list|()
operator|!=
name|TTHEN
condition|)
name|synexpect
argument_list|(
name|TTHEN
argument_list|)
expr_stmt|;
name|n2
operator|->
name|nif
operator|.
name|ifpart
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lasttoken
operator|==
name|TELSE
condition|)
name|n2
operator|->
name|nif
operator|.
name|elsepart
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|n2
operator|->
name|nif
operator|.
name|elsepart
operator|=
name|NULL
expr_stmt|;
name|tokpushback
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|readtoken
argument_list|()
operator|!=
name|TFI
condition|)
name|synexpect
argument_list|(
name|TFI
argument_list|)
expr_stmt|;
name|checkkwd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TWHILE
case|:
case|case
name|TUNTIL
case|:
block|{
name|int
name|got
decl_stmt|;
name|n1
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nbinary
argument_list|)
argument_list|)
expr_stmt|;
name|n1
operator|->
name|type
operator|=
operator|(
name|lasttoken
operator|==
name|TWHILE
operator|)
condition|?
name|NWHILE
else|:
name|NUNTIL
expr_stmt|;
name|n1
operator|->
name|nbinary
operator|.
name|ch1
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|got
operator|=
name|readtoken
argument_list|()
operator|)
operator|!=
name|TDO
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"expecting DO got %s %s\n"
operator|,
name|tokname
index|[
name|got
index|]
operator|,
name|got
operator|==
name|TWORD
condition|?
name|wordtext
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|synexpect
argument_list|(
name|TDO
argument_list|)
expr_stmt|;
block|}
name|n1
operator|->
name|nbinary
operator|.
name|ch2
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readtoken
argument_list|()
operator|!=
name|TDONE
condition|)
name|synexpect
argument_list|(
name|TDONE
argument_list|)
expr_stmt|;
name|checkkwd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|TFOR
case|:
if|if
condition|(
name|readtoken
argument_list|()
operator|!=
name|TWORD
operator|||
name|quoteflag
operator|||
operator|!
name|goodname
argument_list|(
name|wordtext
argument_list|)
condition|)
name|synerror
argument_list|(
literal|"Bad for loop variable"
argument_list|)
expr_stmt|;
name|n1
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfor
argument_list|)
argument_list|)
expr_stmt|;
name|n1
operator|->
name|type
operator|=
name|NFOR
expr_stmt|;
name|n1
operator|->
name|nfor
operator|.
name|var
operator|=
name|wordtext
expr_stmt|;
if|if
condition|(
name|readtoken
argument_list|()
operator|==
name|TWORD
operator|&&
operator|!
name|quoteflag
operator|&&
name|equal
argument_list|(
name|wordtext
argument_list|,
literal|"in"
argument_list|)
condition|)
block|{
name|app
operator|=
operator|&
name|ap
expr_stmt|;
while|while
condition|(
name|readtoken
argument_list|()
operator|==
name|TWORD
condition|)
block|{
name|n2
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|narg
argument_list|)
argument_list|)
expr_stmt|;
name|n2
operator|->
name|type
operator|=
name|NARG
expr_stmt|;
name|n2
operator|->
name|narg
operator|.
name|text
operator|=
name|wordtext
expr_stmt|;
name|n2
operator|->
name|narg
operator|.
name|backquote
operator|=
name|backquotelist
expr_stmt|;
operator|*
name|app
operator|=
name|n2
expr_stmt|;
name|app
operator|=
operator|&
name|n2
operator|->
name|narg
operator|.
name|next
expr_stmt|;
block|}
operator|*
name|app
operator|=
name|NULL
expr_stmt|;
name|n1
operator|->
name|nfor
operator|.
name|args
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|lasttoken
operator|!=
name|TNL
operator|&&
name|lasttoken
operator|!=
name|TSEMI
condition|)
name|synexpect
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|GDB_HACK
specifier|static
specifier|const
name|char
name|argvars
index|[
literal|5
index|]
init|=
block|{
name|CTLVAR
block|,
name|VSNORMAL
operator||
name|VSQUOTE
block|,
literal|'@'
block|,
literal|'='
block|,
literal|'\0'
block|}
decl_stmt|;
endif|#
directive|endif
name|n2
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|narg
argument_list|)
argument_list|)
expr_stmt|;
name|n2
operator|->
name|type
operator|=
name|NARG
expr_stmt|;
name|n2
operator|->
name|narg
operator|.
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|argvars
expr_stmt|;
name|n2
operator|->
name|narg
operator|.
name|backquote
operator|=
name|NULL
expr_stmt|;
name|n2
operator|->
name|narg
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|n1
operator|->
name|nfor
operator|.
name|args
operator|=
name|n2
expr_stmt|;
comment|/* 			 * Newline or semicolon here is optional (but note 			 * that the original Bourne shell only allowed NL). 			 */
if|if
condition|(
name|lasttoken
operator|!=
name|TNL
operator|&&
name|lasttoken
operator|!=
name|TSEMI
condition|)
name|tokpushback
operator|++
expr_stmt|;
block|}
name|checkkwd
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|readtoken
argument_list|()
operator|)
operator|==
name|TDO
condition|)
name|t
operator|=
name|TDONE
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|TBEGIN
condition|)
name|t
operator|=
name|TEND
expr_stmt|;
else|else
name|synexpect
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|n1
operator|->
name|nfor
operator|.
name|body
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readtoken
argument_list|()
operator|!=
name|t
condition|)
name|synexpect
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|checkkwd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TCASE
case|:
name|n1
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ncase
argument_list|)
argument_list|)
expr_stmt|;
name|n1
operator|->
name|type
operator|=
name|NCASE
expr_stmt|;
if|if
condition|(
name|readtoken
argument_list|()
operator|!=
name|TWORD
condition|)
name|synexpect
argument_list|(
name|TWORD
argument_list|)
expr_stmt|;
name|n1
operator|->
name|ncase
operator|.
name|expr
operator|=
name|n2
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|narg
argument_list|)
argument_list|)
expr_stmt|;
name|n2
operator|->
name|type
operator|=
name|NARG
expr_stmt|;
name|n2
operator|->
name|narg
operator|.
name|text
operator|=
name|wordtext
expr_stmt|;
name|n2
operator|->
name|narg
operator|.
name|backquote
operator|=
name|backquotelist
expr_stmt|;
name|n2
operator|->
name|narg
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|readtoken
argument_list|()
operator|==
name|TNL
condition|)
empty_stmt|;
if|if
condition|(
name|lasttoken
operator|!=
name|TWORD
operator|||
operator|!
name|equal
argument_list|(
name|wordtext
argument_list|,
literal|"in"
argument_list|)
condition|)
name|synerror
argument_list|(
literal|"expecting \"in\""
argument_list|)
expr_stmt|;
name|cpp
operator|=
operator|&
name|n1
operator|->
name|ncase
operator|.
name|cases
expr_stmt|;
name|checkkwd
operator|=
literal|2
operator|,
name|readtoken
argument_list|()
expr_stmt|;
do|do
block|{
operator|*
name|cpp
operator|=
name|cp
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nclist
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|NCLIST
expr_stmt|;
name|app
operator|=
operator|&
name|cp
operator|->
name|nclist
operator|.
name|pattern
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|app
operator|=
name|ap
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|narg
argument_list|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|type
operator|=
name|NARG
expr_stmt|;
name|ap
operator|->
name|narg
operator|.
name|text
operator|=
name|wordtext
expr_stmt|;
name|ap
operator|->
name|narg
operator|.
name|backquote
operator|=
name|backquotelist
expr_stmt|;
if|if
condition|(
name|checkkwd
operator|=
literal|2
operator|,
name|readtoken
argument_list|()
operator|!=
name|TPIPE
condition|)
break|break;
name|app
operator|=
operator|&
name|ap
operator|->
name|narg
operator|.
name|next
expr_stmt|;
name|readtoken
argument_list|()
expr_stmt|;
block|}
name|ap
operator|->
name|narg
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lasttoken
operator|!=
name|TRP
condition|)
name|synexpect
argument_list|(
name|TRP
argument_list|)
expr_stmt|;
name|cp
operator|->
name|nclist
operator|.
name|body
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|checkkwd
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|readtoken
argument_list|()
operator|)
operator|!=
name|TESAC
condition|)
block|{
if|if
condition|(
name|t
operator|!=
name|TENDCASE
condition|)
name|synexpect
argument_list|(
name|TENDCASE
argument_list|)
expr_stmt|;
else|else
name|checkkwd
operator|=
literal|2
operator|,
name|readtoken
argument_list|()
expr_stmt|;
block|}
name|cpp
operator|=
operator|&
name|cp
operator|->
name|nclist
operator|.
name|next
expr_stmt|;
block|}
do|while
condition|(
name|lasttoken
operator|!=
name|TESAC
condition|)
do|;
operator|*
name|cpp
operator|=
name|NULL
expr_stmt|;
name|checkkwd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TLP
case|:
name|n1
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nredir
argument_list|)
argument_list|)
expr_stmt|;
name|n1
operator|->
name|type
operator|=
name|NSUBSHELL
expr_stmt|;
name|n1
operator|->
name|nredir
operator|.
name|n
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|n1
operator|->
name|nredir
operator|.
name|redirect
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|readtoken
argument_list|()
operator|!=
name|TRP
condition|)
name|synexpect
argument_list|(
name|TRP
argument_list|)
expr_stmt|;
name|checkkwd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TBEGIN
case|:
name|n1
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readtoken
argument_list|()
operator|!=
name|TEND
condition|)
name|synexpect
argument_list|(
name|TEND
argument_list|)
expr_stmt|;
name|checkkwd
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Handle an empty command like other simple commands.  */
case|case
name|TNL
case|:
case|case
name|TWORD
case|:
name|tokpushback
operator|++
expr_stmt|;
return|return
name|simplecmd
argument_list|(
name|rpp
argument_list|,
name|redir
argument_list|)
return|;
default|default:
name|synexpect
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now check for redirection which may follow command */
while|while
condition|(
name|readtoken
argument_list|()
operator|==
name|TREDIR
condition|)
block|{
operator|*
name|rpp
operator|=
name|n2
operator|=
name|redirnode
expr_stmt|;
name|rpp
operator|=
operator|&
name|n2
operator|->
name|nfile
operator|.
name|next
expr_stmt|;
name|parsefname
argument_list|()
expr_stmt|;
block|}
name|tokpushback
operator|++
expr_stmt|;
operator|*
name|rpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|redir
condition|)
block|{
if|if
condition|(
name|n1
operator|->
name|type
operator|!=
name|NSUBSHELL
condition|)
block|{
name|n2
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nredir
argument_list|)
argument_list|)
expr_stmt|;
name|n2
operator|->
name|type
operator|=
name|NREDIR
expr_stmt|;
name|n2
operator|->
name|nredir
operator|.
name|n
operator|=
name|n1
expr_stmt|;
name|n1
operator|=
name|n2
expr_stmt|;
block|}
name|n1
operator|->
name|nredir
operator|.
name|redirect
operator|=
name|redir
expr_stmt|;
block|}
return|return
name|n1
return|;
block|}
end_function

begin_function
name|STATIC
name|union
name|node
modifier|*
name|simplecmd
parameter_list|(
name|rpp
parameter_list|,
name|redir
parameter_list|)
name|union
name|node
modifier|*
modifier|*
name|rpp
decl_stmt|,
decl|*
name|redir
decl_stmt|;
end_function

begin_block
block|{
name|union
name|node
modifier|*
name|args
decl_stmt|,
modifier|*
modifier|*
name|app
decl_stmt|;
name|union
name|node
modifier|*
modifier|*
name|orig_rpp
init|=
name|rpp
decl_stmt|;
name|union
name|node
modifier|*
name|n
decl_stmt|;
comment|/* If we don't have any redirections already, then we must reset */
comment|/* rpp to be the address of the local redir variable.  */
if|if
condition|(
name|redir
operator|==
literal|0
condition|)
name|rpp
operator|=
operator|&
name|redir
expr_stmt|;
name|args
operator|=
name|NULL
expr_stmt|;
name|app
operator|=
operator|&
name|args
expr_stmt|;
comment|/*  	 * We save the incoming value, because we need this for shell 	 * functions.  There can not be a redirect or an argument between 	 * the function name and the open parenthesis.   	 */
name|orig_rpp
operator|=
name|rpp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|readtoken
argument_list|()
operator|==
name|TWORD
condition|)
block|{
name|n
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|narg
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|NARG
expr_stmt|;
name|n
operator|->
name|narg
operator|.
name|text
operator|=
name|wordtext
expr_stmt|;
name|n
operator|->
name|narg
operator|.
name|backquote
operator|=
name|backquotelist
expr_stmt|;
operator|*
name|app
operator|=
name|n
expr_stmt|;
name|app
operator|=
operator|&
name|n
operator|->
name|narg
operator|.
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lasttoken
operator|==
name|TREDIR
condition|)
block|{
operator|*
name|rpp
operator|=
name|n
operator|=
name|redirnode
expr_stmt|;
name|rpp
operator|=
operator|&
name|n
operator|->
name|nfile
operator|.
name|next
expr_stmt|;
name|parsefname
argument_list|()
expr_stmt|;
comment|/* read name of redirection file */
block|}
elseif|else
if|if
condition|(
name|lasttoken
operator|==
name|TLP
operator|&&
name|app
operator|==
operator|&
name|args
operator|->
name|narg
operator|.
name|next
operator|&&
name|rpp
operator|==
name|orig_rpp
condition|)
block|{
comment|/* We have a function */
if|if
condition|(
name|readtoken
argument_list|()
operator|!=
name|TRP
condition|)
name|synexpect
argument_list|(
name|TRP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|!
name|goodname
argument_list|(
name|n
operator|->
name|narg
operator|.
name|text
argument_list|)
condition|)
name|synerror
argument_list|(
literal|"Bad function name"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|->
name|type
operator|=
name|NDEFUN
expr_stmt|;
name|n
operator|->
name|narg
operator|.
name|next
operator|=
name|command
argument_list|()
expr_stmt|;
return|return
name|n
return|;
block|}
else|else
block|{
name|tokpushback
operator|++
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|app
operator|=
name|NULL
expr_stmt|;
operator|*
name|rpp
operator|=
name|NULL
expr_stmt|;
name|n
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ncmd
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|NCMD
expr_stmt|;
name|n
operator|->
name|ncmd
operator|.
name|backgnd
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|ncmd
operator|.
name|args
operator|=
name|args
expr_stmt|;
name|n
operator|->
name|ncmd
operator|.
name|redirect
operator|=
name|redir
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_function
name|STATIC
name|void
name|parsefname
parameter_list|()
block|{
name|union
name|node
modifier|*
name|n
init|=
name|redirnode
decl_stmt|;
if|if
condition|(
name|readtoken
argument_list|()
operator|!=
name|TWORD
condition|)
name|synexpect
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|NHERE
condition|)
block|{
name|struct
name|heredoc
modifier|*
name|here
init|=
name|heredoc
decl_stmt|;
name|struct
name|heredoc
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|quoteflag
operator|==
literal|0
condition|)
name|n
operator|->
name|type
operator|=
name|NXHERE
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"Here document %d\n"
operator|,
name|n
operator|->
name|type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|here
operator|->
name|striptabs
condition|)
block|{
while|while
condition|(
operator|*
name|wordtext
operator|==
literal|'\t'
condition|)
name|wordtext
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|noexpand
argument_list|(
name|wordtext
argument_list|)
operator|||
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|wordtext
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|i
operator|>
name|EOFMARKLEN
condition|)
name|synerror
argument_list|(
literal|"Illegal eof marker for<< redirection"
argument_list|)
expr_stmt|;
name|rmescapes
argument_list|(
name|wordtext
argument_list|)
expr_stmt|;
name|here
operator|->
name|eofmark
operator|=
name|wordtext
expr_stmt|;
name|here
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|heredoclist
operator|==
name|NULL
condition|)
name|heredoclist
operator|=
name|here
expr_stmt|;
else|else
block|{
for|for
control|(
name|p
operator|=
name|heredoclist
init|;
name|p
operator|->
name|next
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
name|p
operator|->
name|next
operator|=
name|here
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|NTOFD
operator|||
name|n
operator|->
name|type
operator|==
name|NFROMFD
condition|)
block|{
if|if
condition|(
name|is_digit
argument_list|(
name|wordtext
index|[
literal|0
index|]
argument_list|)
condition|)
name|n
operator|->
name|ndup
operator|.
name|dupfd
operator|=
name|digit_val
argument_list|(
name|wordtext
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wordtext
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|n
operator|->
name|ndup
operator|.
name|dupfd
operator|=
operator|-
literal|1
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
if|if
condition|(
name|wordtext
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|bad
label|:
name|synerror
argument_list|(
literal|"Bad fd number"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|n
operator|->
name|nfile
operator|.
name|fname
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|narg
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|nfile
operator|.
name|fname
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|NARG
expr_stmt|;
name|n
operator|->
name|narg
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|narg
operator|.
name|text
operator|=
name|wordtext
expr_stmt|;
name|n
operator|->
name|narg
operator|.
name|backquote
operator|=
name|backquotelist
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Input any here documents.  */
end_comment

begin_function
name|STATIC
name|void
name|parseheredoc
parameter_list|()
block|{
name|struct
name|heredoc
modifier|*
name|here
decl_stmt|;
name|union
name|node
modifier|*
name|n
decl_stmt|;
while|while
condition|(
name|heredoclist
condition|)
block|{
name|here
operator|=
name|heredoclist
expr_stmt|;
name|heredoclist
operator|=
name|here
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|needprompt
condition|)
block|{
name|setprompt
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|needprompt
operator|=
literal|0
expr_stmt|;
block|}
name|readtoken1
argument_list|(
name|pgetc
argument_list|()
argument_list|,
name|here
operator|->
name|here
operator|->
name|type
operator|==
name|NHERE
condition|?
name|SQSYNTAX
else|:
name|DQSYNTAX
argument_list|,
name|here
operator|->
name|eofmark
argument_list|,
name|here
operator|->
name|striptabs
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|narg
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|narg
operator|.
name|type
operator|=
name|NARG
expr_stmt|;
name|n
operator|->
name|narg
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|narg
operator|.
name|text
operator|=
name|wordtext
expr_stmt|;
name|n
operator|->
name|narg
operator|.
name|backquote
operator|=
name|backquotelist
expr_stmt|;
name|here
operator|->
name|here
operator|->
name|nhere
operator|.
name|doc
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|int
name|peektoken
parameter_list|()
block|{
name|int
name|t
decl_stmt|;
name|t
operator|=
name|readtoken
argument_list|()
expr_stmt|;
name|tokpushback
operator|++
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function_decl
name|STATIC
name|int
name|xxreadtoken
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|STATIC
name|int
name|readtoken
parameter_list|()
block|{
name|int
name|t
decl_stmt|;
name|int
name|savecheckkwd
init|=
name|checkkwd
decl_stmt|;
name|struct
name|alias
modifier|*
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|alreadyseen
init|=
name|tokpushback
decl_stmt|;
endif|#
directive|endif
name|top
label|:
name|t
operator|=
name|xxreadtoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|checkkwd
condition|)
block|{
comment|/* 		 * eat newlines 		 */
if|if
condition|(
name|checkkwd
operator|==
literal|2
condition|)
block|{
name|checkkwd
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|t
operator|==
name|TNL
condition|)
block|{
name|parseheredoc
argument_list|()
expr_stmt|;
name|t
operator|=
name|xxreadtoken
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|checkkwd
operator|=
literal|0
expr_stmt|;
comment|/* 		 * check for keywords and aliases 		 */
if|if
condition|(
name|t
operator|==
name|TWORD
operator|&&
operator|!
name|quoteflag
condition|)
block|{
specifier|register
name|char
modifier|*
specifier|const
modifier|*
name|pp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|parsekwd
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
operator|*
name|wordtext
operator|&&
name|equal
argument_list|(
operator|*
name|pp
argument_list|,
name|wordtext
argument_list|)
condition|)
block|{
name|lasttoken
operator|=
name|t
operator|=
name|pp
operator|-
name|parsekwd
operator|+
name|KWDOFFSET
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"keyword %s recognized\n"
operator|,
name|tokname
index|[
name|t
index|]
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|ap
operator|=
name|lookupalias
argument_list|(
name|wordtext
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|pushstring
argument_list|(
name|ap
operator|->
name|val
argument_list|,
name|strlen
argument_list|(
name|ap
operator|->
name|val
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|checkkwd
operator|=
name|savecheckkwd
expr_stmt|;
goto|goto
name|top
goto|;
block|}
block|}
name|out
label|:
name|checkkwd
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|alreadyseen
condition|)
name|TRACE
argument_list|(
operator|(
literal|"token %s %s\n"
operator|,
name|tokname
index|[
name|t
index|]
operator|,
name|t
operator|==
name|TWORD
condition|?
name|wordtext
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
else|else
name|TRACE
argument_list|(
operator|(
literal|"reread token %s %s\n"
operator|,
name|tokname
index|[
name|t
index|]
operator|,
name|t
operator|==
name|TWORD
condition|?
name|wordtext
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the next input token.  * If the token is a word, we set backquotelist to the list of cmds in  *	backquotes.  We set quoteflag to true if any part of the word was  *	quoted.  * If the token is TREDIR, then we set redirnode to a structure containing  *	the redirection.  * In all cases, the variable startlinno is set to the number of the line  *	on which the token starts.  *  * [Change comment:  here documents and internal procedures]  * [Readtoken shouldn't have any arguments.  Perhaps we should make the  *  word parsing code into a separate routine.  In this case, readtoken  *  doesn't need to have any internal procedures, but parseword does.  *  We could also make parseoperator in essence the main routine, and  *  have parseword (readtoken1?) handle both words and redirection.]  */
end_comment

begin_define
define|#
directive|define
name|RETURN
parameter_list|(
name|token
parameter_list|)
value|return lasttoken = token
end_define

begin_function
name|STATIC
name|int
name|xxreadtoken
parameter_list|()
block|{
specifier|register
name|c
expr_stmt|;
if|if
condition|(
name|tokpushback
condition|)
block|{
name|tokpushback
operator|=
literal|0
expr_stmt|;
return|return
name|lasttoken
return|;
block|}
if|if
condition|(
name|needprompt
condition|)
block|{
name|setprompt
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|needprompt
operator|=
literal|0
expr_stmt|;
block|}
name|startlinno
operator|=
name|plinno
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* until token or start of word found */
name|c
operator|=
name|pgetc_macro
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
continue|continue;
comment|/* quick check for white space first */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
continue|continue;
case|case
literal|'#'
case|:
while|while
condition|(
operator|(
name|c
operator|=
name|pgetc
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|PEOF
condition|)
empty_stmt|;
name|pungetc
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
if|if
condition|(
name|pgetc
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
name|startlinno
operator|=
operator|++
name|plinno
expr_stmt|;
if|if
condition|(
name|doprompt
condition|)
name|setprompt
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
name|setprompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pungetc
argument_list|()
expr_stmt|;
goto|goto
name|breakloop
goto|;
case|case
literal|'\n'
case|:
name|plinno
operator|++
expr_stmt|;
name|needprompt
operator|=
name|doprompt
expr_stmt|;
name|RETURN
argument_list|(
name|TNL
argument_list|)
expr_stmt|;
case|case
name|PEOF
case|:
name|RETURN
argument_list|(
name|TEOF
argument_list|)
expr_stmt|;
case|case
literal|'&'
case|:
if|if
condition|(
name|pgetc
argument_list|()
operator|==
literal|'&'
condition|)
name|RETURN
argument_list|(
name|TAND
argument_list|)
expr_stmt|;
name|pungetc
argument_list|()
expr_stmt|;
name|RETURN
argument_list|(
name|TBACKGND
argument_list|)
expr_stmt|;
case|case
literal|'|'
case|:
if|if
condition|(
name|pgetc
argument_list|()
operator|==
literal|'|'
condition|)
name|RETURN
argument_list|(
name|TOR
argument_list|)
expr_stmt|;
name|pungetc
argument_list|()
expr_stmt|;
name|RETURN
argument_list|(
name|TPIPE
argument_list|)
expr_stmt|;
case|case
literal|';'
case|:
if|if
condition|(
name|pgetc
argument_list|()
operator|==
literal|';'
condition|)
name|RETURN
argument_list|(
name|TENDCASE
argument_list|)
expr_stmt|;
name|pungetc
argument_list|()
expr_stmt|;
name|RETURN
argument_list|(
name|TSEMI
argument_list|)
expr_stmt|;
case|case
literal|'('
case|:
name|RETURN
argument_list|(
name|TLP
argument_list|)
expr_stmt|;
case|case
literal|')'
case|:
name|RETURN
argument_list|(
name|TRP
argument_list|)
expr_stmt|;
default|default:
goto|goto
name|breakloop
goto|;
block|}
block|}
name|breakloop
label|:
return|return
name|readtoken1
argument_list|(
name|c
argument_list|,
name|BASESYNTAX
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
undef|#
directive|undef
name|RETURN
block|}
end_function

begin_comment
comment|/*  * If eofmark is NULL, read a word or a redirection symbol.  If eofmark  * is not NULL, read a here document.  In the latter case, eofmark is the  * word which marks the end of the document and striptabs is true if  * leading tabs should be stripped from the document.  The argument firstc  * is the first character of the input token or document.  *  * Because C does not have internal subroutines, I have simulated them  * using goto's to implement the subroutine linkage.  The following macros  * will run code that appears at the end of readtoken1.  */
end_comment

begin_define
define|#
directive|define
name|CHECKEND
parameter_list|()
value|{goto checkend; checkend_return:;}
end_define

begin_define
define|#
directive|define
name|PARSEREDIR
parameter_list|()
value|{goto parseredir; parseredir_return:;}
end_define

begin_define
define|#
directive|define
name|PARSESUB
parameter_list|()
value|{goto parsesub; parsesub_return:;}
end_define

begin_define
define|#
directive|define
name|PARSEBACKQOLD
parameter_list|()
value|{oldstyle = 1; goto parsebackq; parsebackq_oldreturn:;}
end_define

begin_define
define|#
directive|define
name|PARSEBACKQNEW
parameter_list|()
value|{oldstyle = 0; goto parsebackq; parsebackq_newreturn:;}
end_define

begin_define
define|#
directive|define
name|PARSEARITH
parameter_list|()
value|{goto parsearith; parsearith_return:;}
end_define

begin_function
name|STATIC
name|int
name|readtoken1
parameter_list|(
name|firstc
parameter_list|,
name|syntax
parameter_list|,
name|eofmark
parameter_list|,
name|striptabs
parameter_list|)
name|int
name|firstc
decl_stmt|;
name|char
specifier|const
modifier|*
name|syntax
decl_stmt|;
name|char
modifier|*
name|eofmark
decl_stmt|;
name|int
name|striptabs
decl_stmt|;
block|{
specifier|register
name|c
operator|=
name|firstc
expr_stmt|;
specifier|register
name|char
modifier|*
name|out
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|line
index|[
name|EOFMARKLEN
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|nodelist
modifier|*
name|bqlist
decl_stmt|;
name|int
name|quotef
decl_stmt|;
name|int
name|dblquote
decl_stmt|;
name|int
name|varnest
decl_stmt|;
comment|/* levels of variables expansion */
name|int
name|arinest
decl_stmt|;
comment|/* levels of arithmetic expansion */
name|int
name|parenlevel
decl_stmt|;
comment|/* levels of parens in arithmetic */
name|int
name|oldstyle
decl_stmt|;
name|char
specifier|const
modifier|*
name|prevsyntax
decl_stmt|;
comment|/* syntax before arithmetic */
name|startlinno
operator|=
name|plinno
expr_stmt|;
name|dblquote
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|syntax
operator|==
name|DQSYNTAX
condition|)
name|dblquote
operator|=
literal|1
expr_stmt|;
name|quotef
operator|=
literal|0
expr_stmt|;
name|bqlist
operator|=
name|NULL
expr_stmt|;
name|varnest
operator|=
literal|0
expr_stmt|;
name|arinest
operator|=
literal|0
expr_stmt|;
name|parenlevel
operator|=
literal|0
expr_stmt|;
name|STARTSTACKSTR
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|loop
label|:
block|{
comment|/* for each line, until end of word */
if|#
directive|if
name|ATTY
if|if
condition|(
name|c
operator|==
literal|'\034'
operator|&&
name|doprompt
operator|&&
name|attyset
argument_list|()
operator|&&
operator|!
name|equal
argument_list|(
name|termval
argument_list|()
argument_list|,
literal|"emacs"
argument_list|)
condition|)
block|{
name|attyline
argument_list|()
expr_stmt|;
if|if
condition|(
name|syntax
operator|==
name|BASESYNTAX
condition|)
return|return
name|readtoken
argument_list|()
return|;
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
endif|#
directive|endif
name|CHECKEND
argument_list|()
expr_stmt|;
comment|/* set c to PEOF if at end of here document */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* until end of line or end of word */
name|CHECKSTRSPACE
argument_list|(
literal|3
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* permit 3 calls to USTPUTC */
if|if
condition|(
name|parsebackquote
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
comment|/* XXX - compat with old /bin/sh */
if|if
condition|(
name|c
operator|!=
literal|'\\'
operator|&&
name|c
operator|!=
literal|'`'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
block|{
name|pungetc
argument_list|()
expr_stmt|;
name|c
operator|=
literal|'\\'
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|syntax
index|[
name|c
index|]
condition|)
block|{
case|case
name|CNL
case|:
comment|/* '\n' */
if|if
condition|(
name|syntax
operator|==
name|BASESYNTAX
condition|)
goto|goto
name|endword
goto|;
comment|/* exit outer loop */
name|USTPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|plinno
operator|++
expr_stmt|;
if|if
condition|(
name|doprompt
condition|)
name|setprompt
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
name|setprompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* continue outer loop */
case|case
name|CWORD
case|:
name|USTPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|CCTL
case|:
if|if
condition|(
name|eofmark
operator|==
name|NULL
operator|||
name|dblquote
condition|)
name|USTPUTC
argument_list|(
name|CTLESC
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|USTPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|CBACK
case|:
comment|/* backslash */
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|PEOF
condition|)
block|{
name|USTPUTC
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|pungetc
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|doprompt
condition|)
name|setprompt
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
name|setprompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dblquote
operator|&&
name|c
operator|!=
literal|'\\'
operator|&&
name|c
operator|!=
literal|'`'
operator|&&
name|c
operator|!=
literal|'$'
operator|&&
operator|(
name|c
operator|!=
literal|'"'
operator|||
name|eofmark
operator|!=
name|NULL
operator|)
condition|)
name|USTPUTC
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQSYNTAX
index|[
name|c
index|]
operator|==
name|CCTL
condition|)
name|USTPUTC
argument_list|(
name|CTLESC
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|USTPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|quotef
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|CSQUOTE
case|:
name|syntax
operator|=
name|SQSYNTAX
expr_stmt|;
break|break;
case|case
name|CDQUOTE
case|:
name|syntax
operator|=
name|DQSYNTAX
expr_stmt|;
name|dblquote
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CENDQUOTE
case|:
if|if
condition|(
name|eofmark
condition|)
block|{
name|USTPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|arinest
condition|)
name|syntax
operator|=
name|ARISYNTAX
expr_stmt|;
else|else
name|syntax
operator|=
name|BASESYNTAX
expr_stmt|;
name|quotef
operator|++
expr_stmt|;
name|dblquote
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|CVAR
case|:
comment|/* '$' */
name|PARSESUB
argument_list|()
expr_stmt|;
comment|/* parse substitution */
break|break;
case|case
name|CENDVAR
case|:
comment|/* '}' */
if|if
condition|(
name|varnest
operator|>
literal|0
condition|)
block|{
name|varnest
operator|--
expr_stmt|;
name|USTPUTC
argument_list|(
name|CTLENDVAR
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|USTPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLP
case|:
comment|/* '(' in arithmetic */
name|parenlevel
operator|++
expr_stmt|;
name|USTPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRP
case|:
comment|/* ')' in arithmetic */
if|if
condition|(
name|parenlevel
operator|>
literal|0
condition|)
block|{
name|USTPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|--
name|parenlevel
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pgetc
argument_list|()
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|--
name|arinest
operator|==
literal|0
condition|)
block|{
name|USTPUTC
argument_list|(
name|CTLENDARI
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|syntax
operator|=
name|prevsyntax
expr_stmt|;
block|}
else|else
name|USTPUTC
argument_list|(
literal|')'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  						 * unbalanced parens 						 *  (don't 2nd guess - no error) 						 */
name|pungetc
argument_list|()
expr_stmt|;
name|USTPUTC
argument_list|(
literal|')'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CBQUOTE
case|:
comment|/* '`' */
name|PARSEBACKQOLD
argument_list|()
expr_stmt|;
break|break;
case|case
name|CEOF
case|:
goto|goto
name|endword
goto|;
comment|/* exit outer loop */
default|default:
if|if
condition|(
name|varnest
operator|==
literal|0
condition|)
goto|goto
name|endword
goto|;
comment|/* exit outer loop */
name|USTPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|pgetc_macro
argument_list|()
expr_stmt|;
block|}
block|}
name|endword
label|:
if|if
condition|(
name|syntax
operator|==
name|ARISYNTAX
condition|)
name|synerror
argument_list|(
literal|"Missing '))'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|syntax
operator|!=
name|BASESYNTAX
operator|&&
operator|!
name|parsebackquote
operator|&&
name|eofmark
operator|==
name|NULL
condition|)
name|synerror
argument_list|(
literal|"Unterminated quoted string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|varnest
operator|!=
literal|0
condition|)
block|{
name|startlinno
operator|=
name|plinno
expr_stmt|;
name|synerror
argument_list|(
literal|"Missing '}'"
argument_list|)
expr_stmt|;
block|}
name|USTPUTC
argument_list|(
literal|'\0'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|len
operator|=
name|out
operator|-
name|stackblock
argument_list|()
expr_stmt|;
name|out
operator|=
name|stackblock
argument_list|()
expr_stmt|;
if|if
condition|(
name|eofmark
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|'>'
operator|||
name|c
operator|==
literal|'<'
operator|)
operator|&&
name|quotef
operator|==
literal|0
operator|&&
name|len
operator|<=
literal|2
operator|&&
operator|(
operator|*
name|out
operator|==
literal|'\0'
operator|||
name|is_digit
argument_list|(
operator|*
name|out
argument_list|)
operator|)
condition|)
block|{
name|PARSEREDIR
argument_list|()
expr_stmt|;
return|return
name|lasttoken
operator|=
name|TREDIR
return|;
block|}
else|else
block|{
name|pungetc
argument_list|()
expr_stmt|;
block|}
block|}
name|quoteflag
operator|=
name|quotef
expr_stmt|;
name|backquotelist
operator|=
name|bqlist
expr_stmt|;
name|grabstackblock
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|wordtext
operator|=
name|out
expr_stmt|;
return|return
name|lasttoken
operator|=
name|TWORD
return|;
comment|/* end of readtoken routine */
comment|/*  * Check to see whether we are at the end of the here document.  When this  * is called, c is set to the first character of the next input line.  If  * we are at the end of the here document, this routine sets the c to PEOF.  */
name|checkend
label|:
block|{
if|if
condition|(
name|eofmark
condition|)
block|{
if|if
condition|(
name|striptabs
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
operator|*
name|eofmark
condition|)
block|{
if|if
condition|(
name|pfgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|line
expr_stmt|;
for|for
control|(
name|q
operator|=
name|eofmark
operator|+
literal|1
init|;
operator|*
name|q
operator|&&
operator|*
name|p
operator|==
operator|*
name|q
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|&&
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
name|c
operator|=
name|PEOF
expr_stmt|;
name|plinno
operator|++
expr_stmt|;
name|needprompt
operator|=
name|doprompt
expr_stmt|;
block|}
else|else
block|{
name|pushstring
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
goto|goto
name|checkend_return
goto|;
block|}
comment|/*  * Parse a redirection operator.  The variable "out" points to a string  * specifying the fd to be redirected.  The variable "c" contains the  * first character of the redirection operator.  */
name|parseredir
label|:
block|{
name|char
name|fd
init|=
operator|*
name|out
decl_stmt|;
name|union
name|node
modifier|*
name|np
decl_stmt|;
name|np
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
name|np
operator|->
name|nfile
operator|.
name|fd
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
name|np
operator|->
name|type
operator|=
name|NAPPEND
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
name|np
operator|->
name|type
operator|=
name|NTOFD
expr_stmt|;
else|else
block|{
name|np
operator|->
name|type
operator|=
name|NTO
expr_stmt|;
name|pungetc
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* c == '<' */
name|np
operator|->
name|nfile
operator|.
name|fd
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfile
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|nhere
argument_list|)
condition|)
block|{
name|np
operator|=
operator|(
expr|union
name|node
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nhere
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|nfile
operator|.
name|fd
operator|=
literal|0
expr_stmt|;
block|}
name|np
operator|->
name|type
operator|=
name|NHERE
expr_stmt|;
name|heredoc
operator|=
operator|(
expr|struct
name|heredoc
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|heredoc
argument_list|)
argument_list|)
expr_stmt|;
name|heredoc
operator|->
name|here
operator|=
name|np
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|pgetc
argument_list|()
operator|)
operator|==
literal|'-'
condition|)
block|{
name|heredoc
operator|->
name|striptabs
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|heredoc
operator|->
name|striptabs
operator|=
literal|0
expr_stmt|;
name|pungetc
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
name|np
operator|->
name|type
operator|=
name|NFROMFD
expr_stmt|;
else|else
block|{
name|np
operator|->
name|type
operator|=
name|NFROM
expr_stmt|;
name|pungetc
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fd
operator|!=
literal|'\0'
condition|)
name|np
operator|->
name|nfile
operator|.
name|fd
operator|=
name|digit_val
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|redirnode
operator|=
name|np
expr_stmt|;
goto|goto
name|parseredir_return
goto|;
block|}
comment|/*  * Parse a substitution.  At this point, we have read the dollar sign  * and nothing else.  */
name|parsesub
label|:
block|{
name|int
name|subtype
decl_stmt|;
name|int
name|typeloc
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
ifndef|#
directive|ifndef
name|GDB_HACK
specifier|static
specifier|const
name|char
name|types
index|[]
init|=
literal|"}-+?="
decl_stmt|;
endif|#
directive|endif
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'('
operator|&&
name|c
operator|!=
literal|'{'
operator|&&
operator|!
name|is_name
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|is_special
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|USTPUTC
argument_list|(
literal|'$'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|pungetc
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
comment|/* $(command) or $((arith)) */
if|if
condition|(
name|pgetc
argument_list|()
operator|==
literal|'('
condition|)
block|{
name|PARSEARITH
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pungetc
argument_list|()
expr_stmt|;
name|PARSEBACKQNEW
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|USTPUTC
argument_list|(
name|CTLVAR
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|typeloc
operator|=
name|out
operator|-
name|stackblock
argument_list|()
expr_stmt|;
name|USTPUTC
argument_list|(
name|VSNORMAL
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|subtype
operator|=
name|VSNORMAL
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
name|subtype
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|is_name
argument_list|(
name|c
argument_list|)
condition|)
block|{
do|do
block|{
name|STPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|is_in_name
argument_list|(
name|c
argument_list|)
condition|)
do|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|is_special
argument_list|(
name|c
argument_list|)
condition|)
name|badsub
label|:
name|synerror
argument_list|(
literal|"Bad substitution"
argument_list|)
expr_stmt|;
name|USTPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
block|}
name|STPUTC
argument_list|(
literal|'='
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|flags
operator|=
name|VSNUL
expr_stmt|;
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|types
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|badsub
goto|;
name|subtype
operator|=
name|p
operator|-
name|types
operator|+
name|VSNORMAL
expr_stmt|;
block|}
else|else
block|{
name|pungetc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dblquote
operator|||
name|arinest
condition|)
name|flags
operator||=
name|VSQUOTE
expr_stmt|;
operator|*
operator|(
name|stackblock
argument_list|()
operator|+
name|typeloc
operator|)
operator|=
name|subtype
operator||
name|flags
expr_stmt|;
if|if
condition|(
name|subtype
operator|!=
name|VSNORMAL
condition|)
name|varnest
operator|++
expr_stmt|;
block|}
goto|goto
name|parsesub_return
goto|;
block|}
comment|/*  * Called to parse command substitutions.  Newstyle is set if the command  * is enclosed inside $(...); nlpp is a pointer to the head of the linked  * list of commands (passed by reference), and savelen is the number of  * characters on the top of the stack which must be preserved.  */
name|parsebackq
label|:
block|{
name|struct
name|nodelist
modifier|*
modifier|*
name|nlpp
decl_stmt|;
name|int
name|savepbq
decl_stmt|;
name|union
name|node
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|str
decl_stmt|;
name|struct
name|jmploc
name|jmploc
decl_stmt|;
name|struct
name|jmploc
modifier|*
specifier|volatile
name|savehandler
decl_stmt|;
name|int
name|savelen
decl_stmt|;
name|savepbq
operator|=
name|parsebackquote
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmploc
operator|.
name|loc
argument_list|)
condition|)
block|{
if|if
condition|(
name|str
condition|)
name|ckfree
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|parsebackquote
operator|=
literal|0
expr_stmt|;
name|handler
operator|=
name|savehandler
expr_stmt|;
name|longjmp
argument_list|(
name|handler
operator|->
name|loc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|INTOFF
expr_stmt|;
name|str
operator|=
name|NULL
expr_stmt|;
name|savelen
operator|=
name|out
operator|-
name|stackblock
argument_list|()
expr_stmt|;
if|if
condition|(
name|savelen
operator|>
literal|0
condition|)
block|{
name|str
operator|=
name|ckmalloc
argument_list|(
name|savelen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|stackblock
argument_list|()
argument_list|,
name|str
argument_list|,
name|savelen
argument_list|)
expr_stmt|;
block|}
name|savehandler
operator|=
name|handler
expr_stmt|;
name|handler
operator|=
operator|&
name|jmploc
expr_stmt|;
name|INTON
expr_stmt|;
if|if
condition|(
name|oldstyle
condition|)
block|{
comment|/* We must read until the closing backquote, giving special                    treatment to some slashes, and then push the string and                    reread it as input, interpreting it normally.  */
specifier|register
name|char
modifier|*
name|out
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|int
name|savelen
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|STARTSTACKSTR
argument_list|(
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|pgetc
argument_list|()
operator|)
operator|!=
literal|'`'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\\'
operator|&&
name|c
operator|!=
literal|'`'
operator|&&
name|c
operator|!=
literal|'$'
operator|&&
operator|(
operator|!
name|dblquote
operator|||
name|c
operator|!=
literal|'"'
operator|)
condition|)
name|STPUTC
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|STPUTC
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|STPUTC
argument_list|(
literal|'\0'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|savelen
operator|=
name|out
operator|-
name|stackblock
argument_list|()
expr_stmt|;
if|if
condition|(
name|savelen
operator|>
literal|0
condition|)
block|{
name|str
operator|=
name|ckmalloc
argument_list|(
name|savelen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|stackblock
argument_list|()
argument_list|,
name|str
argument_list|,
name|savelen
argument_list|)
expr_stmt|;
block|}
name|setinputstring
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|nlpp
operator|=
operator|&
name|bqlist
expr_stmt|;
while|while
condition|(
operator|*
name|nlpp
condition|)
name|nlpp
operator|=
operator|&
operator|(
operator|*
name|nlpp
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|nlpp
operator|=
operator|(
expr|struct
name|nodelist
operator|*
operator|)
name|stalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nodelist
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|nlpp
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|parsebackquote
operator|=
name|oldstyle
expr_stmt|;
name|n
operator|=
name|list
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oldstyle
operator|&&
operator|(
name|readtoken
argument_list|()
operator|!=
name|TRP
operator|)
condition|)
name|synexpect
argument_list|(
name|TRP
argument_list|)
expr_stmt|;
operator|(
operator|*
name|nlpp
operator|)
operator|->
name|n
operator|=
name|n
expr_stmt|;
comment|/* Start reading from old file again.  */
if|if
condition|(
name|oldstyle
condition|)
name|popfile
argument_list|()
expr_stmt|;
while|while
condition|(
name|stackblocksize
argument_list|()
operator|<=
name|savelen
condition|)
name|growstackblock
argument_list|()
expr_stmt|;
name|STARTSTACKSTR
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|bcopy
argument_list|(
name|str
argument_list|,
name|out
argument_list|,
name|savelen
argument_list|)
expr_stmt|;
name|STADJUST
argument_list|(
name|savelen
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|INTOFF
expr_stmt|;
name|ckfree
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|NULL
expr_stmt|;
name|INTON
expr_stmt|;
block|}
name|parsebackquote
operator|=
name|savepbq
expr_stmt|;
name|handler
operator|=
name|savehandler
expr_stmt|;
if|if
condition|(
name|arinest
operator|||
name|dblquote
condition|)
name|USTPUTC
argument_list|(
name|CTLBACKQ
operator||
name|CTLQUOTE
argument_list|,
name|out
argument_list|)
expr_stmt|;
else|else
name|USTPUTC
argument_list|(
name|CTLBACKQ
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstyle
condition|)
goto|goto
name|parsebackq_oldreturn
goto|;
else|else
goto|goto
name|parsebackq_newreturn
goto|;
block|}
comment|/*  * Parse an arithmetic expansion (indicate start of one and set state)  */
name|parsearith
label|:
block|{
if|if
condition|(
operator|++
name|arinest
operator|==
literal|1
condition|)
block|{
name|prevsyntax
operator|=
name|syntax
expr_stmt|;
name|syntax
operator|=
name|ARISYNTAX
expr_stmt|;
name|USTPUTC
argument_list|(
name|CTLARI
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * we collapse embedded arithmetic expansion to 		 * parenthesis, which should be equivalent 		 */
name|USTPUTC
argument_list|(
literal|'('
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
goto|goto
name|parsearith_return
goto|;
block|}
block|}
end_function

begin_comment
comment|/* end of readtoken */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|mkinit
end_ifdef

begin_macro
name|RESET
end_macro

begin_block
block|{
name|tokpushback
operator|=
literal|0
expr_stmt|;
name|checkkwd
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Returns true if the text contains nothing to expand (no dollar signs  * or backquotes).  */
end_comment

begin_function
name|STATIC
name|int
name|noexpand
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|p
operator|=
name|text
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|CTLESC
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|BASESYNTAX
index|[
name|c
index|]
operator|==
name|CCTL
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if the argument is a legal variable name (a letter or  * underscore followed by zero or more letters, underscores, and digits).  */
end_comment

begin_function
name|int
name|goodname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|is_name
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
operator|++
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|is_in_name
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Called when an unexpected token is read during the parse.  The argument  * is the token that is expected, or -1 if more than one type of token can  * occur at this point.  */
end_comment

begin_function
name|STATIC
name|void
name|synexpect
parameter_list|(
name|token
parameter_list|)
block|{
name|char
name|msg
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|token
operator|>=
literal|0
condition|)
block|{
name|fmtstr
argument_list|(
name|msg
argument_list|,
literal|64
argument_list|,
literal|"%s unexpected (expecting %s)"
argument_list|,
name|tokname
index|[
name|lasttoken
index|]
argument_list|,
name|tokname
index|[
name|token
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fmtstr
argument_list|(
name|msg
argument_list|,
literal|64
argument_list|,
literal|"%s unexpected"
argument_list|,
name|tokname
index|[
name|lasttoken
index|]
argument_list|)
expr_stmt|;
block|}
name|synerror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|synerror
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
if|if
condition|(
name|commandname
condition|)
name|outfmt
argument_list|(
operator|&
name|errout
argument_list|,
literal|"%s: %d: "
argument_list|,
name|commandname
argument_list|,
name|startlinno
argument_list|)
expr_stmt|;
name|outfmt
argument_list|(
operator|&
name|errout
argument_list|,
literal|"Syntax error: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|error
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|setprompt
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
name|whichprompt
operator|=
name|which
expr_stmt|;
if|if
condition|(
operator|!
name|el
condition|)
name|out2str
argument_list|(
name|getprompt
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * called by editline -- any expansions to the prompt  *    should be added here.  */
end_comment

begin_function
name|char
modifier|*
name|getprompt
parameter_list|(
name|unused
parameter_list|)
name|void
modifier|*
name|unused
decl_stmt|;
block|{
switch|switch
condition|(
name|whichprompt
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|""
return|;
case|case
literal|1
case|:
return|return
name|ps1val
argument_list|()
return|;
case|case
literal|2
case|:
return|return
name|ps2val
argument_list|()
return|;
default|default:
return|return
literal|"<internal prompt error>"
return|;
block|}
block|}
end_function

end_unit

