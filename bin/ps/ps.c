begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * ------+---------+---------+-------- + --------+---------+---------+---------*  * Copyright (c) 2004  - Garance Alistair Drosehn<gad@FreeBSD.org>.  * All rights reserved.  *  * Significant modifications made to bring `ps' options somewhat closer  * to the standard for `ps' as described in SingleUnixSpec-v3.  * ------+---------+---------+-------- + --------+---------+---------+---------*  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1990, 1993, 1994\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char sccsid[] = "@(#)ps.c	8.4 (Berkeley) 4/2/94";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"ps.h"
end_include

begin_define
define|#
directive|define
name|_PATH_PTS
value|"/dev/pts/"
end_define

begin_define
define|#
directive|define
name|W_SEP
value|" \t"
end_define

begin_comment
comment|/* "Whitespace" list separators */
end_comment

begin_define
define|#
directive|define
name|T_SEP
value|","
end_define

begin_comment
comment|/* "Terminate-element" list separators */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LAZY_PS
end_ifdef

begin_define
define|#
directive|define
name|DEF_UREAD
value|0
end_define

begin_define
define|#
directive|define
name|OPT_LAZY_f
value|"f"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEF_UREAD
value|1
end_define

begin_comment
comment|/* Always do the more-expensive read. */
end_comment

begin_define
define|#
directive|define
name|OPT_LAZY_f
end_define

begin_comment
comment|/* I.e., the `-f' option is not added. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * isdigit takes an `int', but expects values in the range of unsigned char.  * This wrapper ensures that values from a 'char' end up in the correct range.  */
end_comment

begin_define
define|#
directive|define
name|isdigitch
parameter_list|(
name|Anychar
parameter_list|)
value|isdigit((u_char)(Anychar))
end_define

begin_decl_stmt
name|int
name|cflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -c */
end_comment

begin_decl_stmt
name|int
name|eval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exit value */
end_comment

begin_decl_stmt
name|time_t
name|now
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current time(3) value */
end_comment

begin_decl_stmt
name|int
name|rawcpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -C */
end_comment

begin_decl_stmt
name|int
name|sumrusage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -S */
end_comment

begin_decl_stmt
name|int
name|termwidth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Width of the screen (0 == infinity). */
end_comment

begin_decl_stmt
name|int
name|totwidth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Calculated-width of requested variables. */
end_comment

begin_decl_stmt
name|int
name|showthreads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* will threads be shown? */
end_comment

begin_decl_stmt
name|struct
name|velisthead
name|varlist
init|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|varlist
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|forceuread
init|=
name|DEF_UREAD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do extra work to get u-area. */
end_comment

begin_decl_stmt
specifier|static
name|kvm_t
modifier|*
name|kd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KINFO
modifier|*
name|kinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|needcomm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -o "command" */
end_comment

begin_decl_stmt
specifier|static
name|int
name|needenv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -e */
end_comment

begin_decl_stmt
specifier|static
name|int
name|needuser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -o "user" */
end_comment

begin_decl_stmt
specifier|static
name|int
name|optfatal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fatal error parsing some list-option. */
end_comment

begin_enum
specifier|static
enum|enum
name|sort
block|{
name|DEFAULT
block|,
name|SORTMEM
block|,
name|SORTCPU
block|}
name|sortby
init|=
name|DEFAULT
enum|;
end_enum

begin_struct_decl
struct_decl|struct
name|listinfo
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|int
name|addelem_rtn
parameter_list|(
name|struct
name|listinfo
modifier|*
name|_inf
parameter_list|,
specifier|const
name|char
modifier|*
name|_elem
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|listinfo
block|{
name|int
name|count
decl_stmt|;
name|int
name|maxcount
decl_stmt|;
name|int
name|elemsize
decl_stmt|;
name|addelem_rtn
modifier|*
name|addelem
decl_stmt|;
specifier|const
name|char
modifier|*
name|lname
decl_stmt|;
union|union
block|{
name|gid_t
modifier|*
name|gids
decl_stmt|;
name|pid_t
modifier|*
name|pids
decl_stmt|;
name|dev_t
modifier|*
name|ttys
decl_stmt|;
name|uid_t
modifier|*
name|uids
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
block|}
name|l
union|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|check_procfs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addelem_gid
parameter_list|(
name|struct
name|listinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addelem_pid
parameter_list|(
name|struct
name|listinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addelem_tty
parameter_list|(
name|struct
name|listinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addelem_uid
parameter_list|(
name|struct
name|listinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_list
parameter_list|(
name|struct
name|listinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dynsizevars
parameter_list|(
name|KINFO
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|expand_list
parameter_list|(
name|struct
name|listinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|fmt
parameter_list|(
name|char
modifier|*
modifier|*
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|kvm_t
modifier|*
parameter_list|,
specifier|const
name|struct
name|kinfo_proc
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|KINFO
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_list
parameter_list|(
name|struct
name|listinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_list
parameter_list|(
name|struct
name|listinfo
modifier|*
parameter_list|,
name|addelem_rtn
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|kludge_oldps_options
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pscomp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|saveuser
parameter_list|(
name|KINFO
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scanvars
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sizevars
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|dfmt
index|[]
init|=
literal|"pid,tt,state,time,command"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|jfmt
index|[]
init|=
literal|"user,pid,ppid,pgid,sid,jobc,state,tt,time,command"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|lfmt
index|[]
init|=
literal|"uid,pid,ppid,cpu,pri,nice,vsz,rss,mwchan,state,"
literal|"tt,time,command"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|o1
index|[]
init|=
literal|"pid"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|o2
index|[]
init|=
literal|"tt,state,time,command"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ufmt
index|[]
init|=
literal|"user,pid,%cpu,%mem,vsz,rss,tt,state,start,time,command"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|vfmt
index|[]
init|=
literal|"pid,state,time,sl,re,pagein,vsz,rss,lim,tsiz,"
literal|"%cpu,%mem,command"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Zfmt
index|[]
init|=
literal|"label"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PS_ARGS
value|"AaCce" OPT_LAZY_f "G:gHhjLlM:mN:O:o:p:rSTt:U:uvwXxZ"
end_define

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|listinfo
name|gidlist
decl_stmt|,
name|pgrplist
decl_stmt|,
name|pidlist
decl_stmt|;
name|struct
name|listinfo
name|ruidlist
decl_stmt|,
name|sesslist
decl_stmt|,
name|ttylist
decl_stmt|,
name|uidlist
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|kp
decl_stmt|;
name|KINFO
modifier|*
name|next_KINFO
decl_stmt|;
name|struct
name|varent
modifier|*
name|vent
decl_stmt|;
name|struct
name|winsize
name|ws
decl_stmt|;
specifier|const
name|char
modifier|*
name|nlistf
decl_stmt|,
modifier|*
name|memf
decl_stmt|;
name|char
modifier|*
name|cols
decl_stmt|;
name|int
name|all
decl_stmt|,
name|ch
decl_stmt|,
name|elem
decl_stmt|,
name|flag
decl_stmt|,
name|_fmt
decl_stmt|,
name|i
decl_stmt|,
name|lineno
decl_stmt|;
name|int
name|nentries
decl_stmt|,
name|nkept
decl_stmt|,
name|nselectors
decl_stmt|;
name|int
name|prtheader
decl_stmt|,
name|wflag
decl_stmt|,
name|what
decl_stmt|,
name|xkeep
decl_stmt|,
name|xkeep_implied
decl_stmt|;
name|char
name|errbuf
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* Used by routines in print.c. */
if|if
condition|(
operator|(
name|cols
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|cols
operator|!=
literal|'\0'
condition|)
name|termwidth
operator|=
name|atoi
argument_list|(
name|cols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ws
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|ioctl
argument_list|(
name|STDERR_FILENO
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ws
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|ioctl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ws
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
name|ws
operator|.
name|ws_col
operator|==
literal|0
condition|)
name|termwidth
operator|=
literal|79
expr_stmt|;
else|else
name|termwidth
operator|=
name|ws
operator|.
name|ws_col
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Hide a number of option-processing kludges in a separate routine, 	 * to support some historical BSD behaviors, such as `ps axu'. 	 */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|argv
index|[
literal|1
index|]
operator|=
name|kludge_oldps_options
argument_list|(
name|PS_ARGS
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|all
operator|=
name|_fmt
operator|=
name|nselectors
operator|=
name|optfatal
operator|=
literal|0
expr_stmt|;
name|prtheader
operator|=
name|showthreads
operator|=
name|wflag
operator|=
name|xkeep_implied
operator|=
literal|0
expr_stmt|;
name|xkeep
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Neither -x nor -X. */
name|init_list
argument_list|(
operator|&
name|gidlist
argument_list|,
name|addelem_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
argument_list|,
literal|"group"
argument_list|)
expr_stmt|;
name|init_list
argument_list|(
operator|&
name|pgrplist
argument_list|,
name|addelem_pid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|,
literal|"process group"
argument_list|)
expr_stmt|;
name|init_list
argument_list|(
operator|&
name|pidlist
argument_list|,
name|addelem_pid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|,
literal|"process id"
argument_list|)
expr_stmt|;
name|init_list
argument_list|(
operator|&
name|ruidlist
argument_list|,
name|addelem_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|uid_t
argument_list|)
argument_list|,
literal|"ruser"
argument_list|)
expr_stmt|;
name|init_list
argument_list|(
operator|&
name|sesslist
argument_list|,
name|addelem_pid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|,
literal|"session id"
argument_list|)
expr_stmt|;
name|init_list
argument_list|(
operator|&
name|ttylist
argument_list|,
name|addelem_tty
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_t
argument_list|)
argument_list|,
literal|"tty"
argument_list|)
expr_stmt|;
name|init_list
argument_list|(
operator|&
name|uidlist
argument_list|,
name|addelem_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|uid_t
argument_list|)
argument_list|,
literal|"user"
argument_list|)
expr_stmt|;
name|memf
operator|=
name|nlistf
operator|=
name|_PATH_DEVNULL
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|PS_ARGS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* 			 * Exactly the same as `-ax'.   This has been 			 * added for compatability with SUSv3, but for 			 * now it will not be described in the man page. 			 */
name|nselectors
operator|++
expr_stmt|;
name|all
operator|=
name|xkeep
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|nselectors
operator|++
expr_stmt|;
name|all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|rawcpu
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* XXX set ufmt */
name|needenv
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LAZY_PS
case|case
literal|'f'
case|:
if|if
condition|(
name|getuid
argument_list|()
operator|==
literal|0
operator|||
name|getgid
argument_list|()
operator|==
literal|0
condition|)
name|forceuread
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'G'
case|:
name|add_list
argument_list|(
operator|&
name|gidlist
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|xkeep_implied
operator|=
literal|1
expr_stmt|;
name|nselectors
operator|++
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|#
directive|if
literal|0
comment|/*- 			 * XXX - This SUSv3 behavior is still under debate 			 *	since it conflicts with the (undocumented) 			 *	`-g' option.  So we skip it for now. 			 */
block|add_list(&pgrplist, optarg); 			xkeep_implied = 1; 			nselectors++; 			break;
else|#
directive|else
comment|/* The historical BSD-ish (from SunOS) behavior. */
break|break;
comment|/* no-op */
endif|#
directive|endif
case|case
literal|'H'
case|:
name|showthreads
operator|=
name|KERN_PROC_INC_THREAD
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|prtheader
operator|=
name|ws
operator|.
name|ws_row
operator|>
literal|5
condition|?
name|ws
operator|.
name|ws_row
else|:
literal|22
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|parsefmt
argument_list|(
name|jfmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_fmt
operator|=
literal|1
expr_stmt|;
name|jfmt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|showkey
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'l'
case|:
name|parsefmt
argument_list|(
name|lfmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_fmt
operator|=
literal|1
expr_stmt|;
name|lfmt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|memf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|sortby
operator|=
name|SORTMEM
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|nlistf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|parsefmt
argument_list|(
name|o1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|parsefmt
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|parsefmt
argument_list|(
name|o2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|o1
index|[
literal|0
index|]
operator|=
name|o2
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|_fmt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|parsefmt
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_fmt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|add_list
argument_list|(
operator|&
name|pidlist
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
comment|/* 			 * Note: `-p' does not *set* xkeep, but any values 			 * from pidlist are checked before xkeep is.  That 			 * way they are always matched, even if the user 			 * specifies `-X'. 			 */
name|nselectors
operator|++
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case 'R':
comment|/*- 			 * XXX - This un-standard option is still under 			 *	debate.  This is what SUSv3 defines as 			 *	the `-U' option, and while it would be 			 *	nice to have, it could cause even more 			 *	confusion to implement it as `-R'. 			 */
block|add_list(&ruidlist, optarg); 			xkeep_implied = 1; 			nselectors++; 			break;
endif|#
directive|endif
case|case
literal|'r'
case|:
name|sortby
operator|=
name|SORTCPU
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|sumrusage
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case 's':
comment|/*- 			 * XXX - This non-standard option is still under 			 *	debate.  This *is* supported on Solaris, 			 *	Linux, and IRIX, but conflicts with `-s' 			 *	on NetBSD and maybe some older BSD's. 			 */
block|add_list(&sesslist, optarg); 			xkeep_implied = 1; 			nselectors++; 			break;
endif|#
directive|endif
case|case
literal|'T'
case|:
if|if
condition|(
operator|(
name|optarg
operator|=
name|ttyname
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"stdin: not a terminal"
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'t'
case|:
name|add_list
argument_list|(
operator|&
name|ttylist
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|xkeep_implied
operator|=
literal|1
expr_stmt|;
name|nselectors
operator|++
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* This is what SUSv3 defines as the `-u' option. */
name|add_list
argument_list|(
operator|&
name|uidlist
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|xkeep_implied
operator|=
literal|1
expr_stmt|;
name|nselectors
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|parsefmt
argument_list|(
name|ufmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sortby
operator|=
name|SORTCPU
expr_stmt|;
name|_fmt
operator|=
literal|1
expr_stmt|;
name|ufmt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|parsefmt
argument_list|(
name|vfmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sortby
operator|=
name|SORTMEM
expr_stmt|;
name|_fmt
operator|=
literal|1
expr_stmt|;
name|vfmt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|wflag
condition|)
name|termwidth
operator|=
name|UNLIMITED
expr_stmt|;
elseif|else
if|if
condition|(
name|termwidth
operator|<
literal|131
condition|)
name|termwidth
operator|=
literal|131
expr_stmt|;
name|wflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* 			 * Note that `-X' and `-x' are not standard "selector" 			 * options. For most selector-options, we check *all* 			 * processes to see if any are matched by the given 			 * value(s).  After we have a set of all the matched 			 * processes, then `-X' and `-x' govern whether we 			 * modify that *matched* set for processes which do 			 * not have a controlling terminal.  `-X' causes 			 * those processes to be deleted from the matched 			 * set, while `-x' causes them to be kept. 			 */
name|xkeep
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xkeep
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|parsefmt
argument_list|(
name|Zfmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Zfmt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* 	 * If the user specified ps -e then they want a copy of the process 	 * environment kvm_getenvv(3) attempts to open /proc/<pid>/mem. 	 * Check to make sure that procfs is mounted on /proc, otherwise 	 * print a warning informing the user that output will be incomplete. 	 */
if|if
condition|(
name|needenv
operator|==
literal|1
operator|&&
name|check_procfs
argument_list|()
operator|==
literal|0
condition|)
name|warnx
argument_list|(
literal|"Process environment requires procfs(5)"
argument_list|)
expr_stmt|;
comment|/* 	 * If there arguments after processing all the options, attempt 	 * to treat them as a list of process ids. 	 */
while|while
condition|(
operator|*
name|argv
condition|)
block|{
if|if
condition|(
operator|!
name|isdigitch
argument_list|(
operator|*
operator|*
name|argv
argument_list|)
condition|)
break|break;
name|add_list
argument_list|(
operator|&
name|pidlist
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|argv
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: illegal argument: %s\n"
argument_list|,
name|getprogname
argument_list|()
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|optfatal
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Error messages already printed. */
if|if
condition|(
name|xkeep
operator|<
literal|0
condition|)
comment|/* Neither -X nor -x was specified. */
name|xkeep
operator|=
name|xkeep_implied
expr_stmt|;
name|kd
operator|=
name|kvm_openfiles
argument_list|(
name|nlistf
argument_list|,
name|memf
argument_list|,
name|NULL
argument_list|,
name|O_RDONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_fmt
condition|)
name|parsefmt
argument_list|(
name|dfmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nselectors
operator|==
literal|0
condition|)
block|{
name|uidlist
operator|.
name|l
operator|.
name|ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uid_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uidlist
operator|.
name|l
operator|.
name|ptr
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|nselectors
operator|=
literal|1
expr_stmt|;
name|uidlist
operator|.
name|count
operator|=
name|uidlist
operator|.
name|maxcount
operator|=
literal|1
expr_stmt|;
operator|*
name|uidlist
operator|.
name|l
operator|.
name|uids
operator|=
name|getuid
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * scan requested variables, noting what structures are needed, 	 * and adjusting header widths as appropriate. 	 */
name|scanvars
argument_list|()
expr_stmt|;
comment|/* 	 * Get process list.  If the user requested just one selector- 	 * option, then kvm_getprocs can be asked to return just those 	 * processes.  Otherwise, have it return all processes, and 	 * then this routine will search that full list and select the 	 * processes which match any of the user's selector-options. 	 */
name|what
operator|=
name|showthreads
operator|!=
literal|0
condition|?
name|KERN_PROC_ALL
else|:
name|KERN_PROC_PROC
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nselectors
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|gidlist
operator|.
name|count
operator|==
literal|1
condition|)
block|{
name|what
operator|=
name|KERN_PROC_RGID
operator||
name|showthreads
expr_stmt|;
name|flag
operator|=
operator|*
name|gidlist
operator|.
name|l
operator|.
name|gids
expr_stmt|;
name|nselectors
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pgrplist
operator|.
name|count
operator|==
literal|1
condition|)
block|{
name|what
operator|=
name|KERN_PROC_PGRP
operator||
name|showthreads
expr_stmt|;
name|flag
operator|=
operator|*
name|pgrplist
operator|.
name|l
operator|.
name|pids
expr_stmt|;
name|nselectors
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pidlist
operator|.
name|count
operator|==
literal|1
condition|)
block|{
name|what
operator|=
name|KERN_PROC_PID
operator||
name|showthreads
expr_stmt|;
name|flag
operator|=
operator|*
name|pidlist
operator|.
name|l
operator|.
name|pids
expr_stmt|;
name|nselectors
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ruidlist
operator|.
name|count
operator|==
literal|1
condition|)
block|{
name|what
operator|=
name|KERN_PROC_RUID
operator||
name|showthreads
expr_stmt|;
name|flag
operator|=
operator|*
name|ruidlist
operator|.
name|l
operator|.
name|uids
expr_stmt|;
name|nselectors
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sesslist
operator|.
name|count
operator|==
literal|1
condition|)
block|{
name|what
operator|=
name|KERN_PROC_SESSION
operator||
name|showthreads
expr_stmt|;
name|flag
operator|=
operator|*
name|sesslist
operator|.
name|l
operator|.
name|pids
expr_stmt|;
name|nselectors
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ttylist
operator|.
name|count
operator|==
literal|1
condition|)
block|{
name|what
operator|=
name|KERN_PROC_TTY
operator||
name|showthreads
expr_stmt|;
name|flag
operator|=
operator|*
name|ttylist
operator|.
name|l
operator|.
name|ttys
expr_stmt|;
name|nselectors
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uidlist
operator|.
name|count
operator|==
literal|1
condition|)
block|{
name|what
operator|=
name|KERN_PROC_UID
operator||
name|showthreads
expr_stmt|;
name|flag
operator|=
operator|*
name|uidlist
operator|.
name|l
operator|.
name|uids
expr_stmt|;
name|nselectors
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|all
condition|)
block|{
comment|/* No need for this routine to select processes. */
name|nselectors
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * select procs 	 */
name|nentries
operator|=
operator|-
literal|1
expr_stmt|;
name|kp
operator|=
name|kvm_getprocs
argument_list|(
name|kd
argument_list|,
name|what
argument_list|,
name|flag
argument_list|,
operator|&
name|nentries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kp
operator|==
name|NULL
operator|&&
name|nentries
operator|>
literal|0
operator|)
operator|||
operator|(
name|kp
operator|!=
name|NULL
operator|&&
name|nentries
operator|<
literal|0
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|kvm_geterr
argument_list|(
name|kd
argument_list|)
argument_list|)
expr_stmt|;
name|nkept
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nentries
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|kinfo
operator|=
name|malloc
argument_list|(
name|nentries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|kinfo
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nentries
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
operator|++
name|kp
control|)
block|{
comment|/* 			 * If the user specified multiple selection-criteria, 			 * then keep any process matched by the inclusive OR 			 * of all the selection-criteria given. 			 */
if|if
condition|(
name|pidlist
operator|.
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|elem
operator|=
literal|0
init|;
name|elem
operator|<
name|pidlist
operator|.
name|count
condition|;
name|elem
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|ki_pid
operator|==
name|pidlist
operator|.
name|l
operator|.
name|pids
index|[
name|elem
index|]
condition|)
goto|goto
name|keepit
goto|;
block|}
comment|/* 			 * Note that we had to process pidlist before 			 * filtering out processes which do not have 			 * a controlling terminal. 			 */
if|if
condition|(
name|xkeep
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|kp
operator|->
name|ki_tdev
operator|==
name|NODEV
operator|||
operator|(
name|kp
operator|->
name|ki_flag
operator|&
name|P_CONTROLT
operator|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|nselectors
operator|==
literal|0
condition|)
goto|goto
name|keepit
goto|;
if|if
condition|(
name|gidlist
operator|.
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|elem
operator|=
literal|0
init|;
name|elem
operator|<
name|gidlist
operator|.
name|count
condition|;
name|elem
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|ki_rgid
operator|==
name|gidlist
operator|.
name|l
operator|.
name|gids
index|[
name|elem
index|]
condition|)
goto|goto
name|keepit
goto|;
block|}
if|if
condition|(
name|pgrplist
operator|.
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|elem
operator|=
literal|0
init|;
name|elem
operator|<
name|pgrplist
operator|.
name|count
condition|;
name|elem
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|ki_pgid
operator|==
name|pgrplist
operator|.
name|l
operator|.
name|pids
index|[
name|elem
index|]
condition|)
goto|goto
name|keepit
goto|;
block|}
if|if
condition|(
name|ruidlist
operator|.
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|elem
operator|=
literal|0
init|;
name|elem
operator|<
name|ruidlist
operator|.
name|count
condition|;
name|elem
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|ki_ruid
operator|==
name|ruidlist
operator|.
name|l
operator|.
name|uids
index|[
name|elem
index|]
condition|)
goto|goto
name|keepit
goto|;
block|}
if|if
condition|(
name|sesslist
operator|.
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|elem
operator|=
literal|0
init|;
name|elem
operator|<
name|sesslist
operator|.
name|count
condition|;
name|elem
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|ki_sid
operator|==
name|sesslist
operator|.
name|l
operator|.
name|pids
index|[
name|elem
index|]
condition|)
goto|goto
name|keepit
goto|;
block|}
if|if
condition|(
name|ttylist
operator|.
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|elem
operator|=
literal|0
init|;
name|elem
operator|<
name|ttylist
operator|.
name|count
condition|;
name|elem
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|ki_tdev
operator|==
name|ttylist
operator|.
name|l
operator|.
name|ttys
index|[
name|elem
index|]
condition|)
goto|goto
name|keepit
goto|;
block|}
if|if
condition|(
name|uidlist
operator|.
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|elem
operator|=
literal|0
init|;
name|elem
operator|<
name|uidlist
operator|.
name|count
condition|;
name|elem
operator|++
control|)
if|if
condition|(
name|kp
operator|->
name|ki_uid
operator|==
name|uidlist
operator|.
name|l
operator|.
name|uids
index|[
name|elem
index|]
condition|)
goto|goto
name|keepit
goto|;
block|}
comment|/* 			 * This process did not match any of the user's 			 * selector-options, so skip the process. 			 */
continue|continue;
name|keepit
label|:
name|next_KINFO
operator|=
operator|&
name|kinfo
index|[
name|nkept
index|]
expr_stmt|;
name|next_KINFO
operator|->
name|ki_p
operator|=
name|kp
expr_stmt|;
name|next_KINFO
operator|->
name|ki_pcpu
operator|=
name|getpcpu
argument_list|(
name|next_KINFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortby
operator|==
name|SORTMEM
condition|)
name|next_KINFO
operator|->
name|ki_memsize
operator|=
name|kp
operator|->
name|ki_tsize
operator|+
name|kp
operator|->
name|ki_dsize
operator|+
name|kp
operator|->
name|ki_ssize
expr_stmt|;
if|if
condition|(
name|needuser
condition|)
name|saveuser
argument_list|(
name|next_KINFO
argument_list|)
expr_stmt|;
name|dynsizevars
argument_list|(
name|next_KINFO
argument_list|)
expr_stmt|;
name|nkept
operator|++
expr_stmt|;
block|}
block|}
name|sizevars
argument_list|()
expr_stmt|;
comment|/* 	 * print header 	 */
name|printheader
argument_list|()
expr_stmt|;
if|if
condition|(
name|nkept
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * sort proc list 	 */
name|qsort
argument_list|(
name|kinfo
argument_list|,
name|nkept
argument_list|,
sizeof|sizeof
argument_list|(
name|KINFO
argument_list|)
argument_list|,
name|pscomp
argument_list|)
expr_stmt|;
comment|/* 	 * For each process, call each variable output function. 	 */
for|for
control|(
name|i
operator|=
name|lineno
operator|=
literal|0
init|;
name|i
operator|<
name|nkept
condition|;
name|i
operator|++
control|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|vent
argument_list|,
argument|&varlist
argument_list|,
argument|next_ve
argument_list|)
block|{
call|(
name|vent
operator|->
name|var
operator|->
name|oproc
call|)
argument_list|(
operator|&
name|kinfo
index|[
name|i
index|]
argument_list|,
name|vent
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_NEXT
argument_list|(
name|vent
argument_list|,
name|next_ve
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|prtheader
operator|&&
name|lineno
operator|++
operator|==
name|prtheader
operator|-
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printheader
argument_list|()
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|free_list
argument_list|(
operator|&
name|gidlist
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|pidlist
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|pgrplist
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|ruidlist
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|sesslist
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|ttylist
argument_list|)
expr_stmt|;
name|free_list
argument_list|(
operator|&
name|uidlist
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|addelem_gid
parameter_list|(
name|struct
name|listinfo
modifier|*
name|inf
parameter_list|,
specifier|const
name|char
modifier|*
name|elem
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
specifier|const
name|char
modifier|*
name|nameorID
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|u_long
name|bigtemp
decl_stmt|;
if|if
condition|(
operator|*
name|elem
operator|==
literal|'\0'
operator|||
name|strlen
argument_list|(
name|elem
argument_list|)
operator|>=
name|MAXLOGNAME
condition|)
block|{
if|if
condition|(
operator|*
name|elem
operator|==
literal|'\0'
condition|)
name|warnx
argument_list|(
literal|"Invalid (zero-length) %s name"
argument_list|,
name|inf
operator|->
name|lname
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"%s name too long: %s"
argument_list|,
name|inf
operator|->
name|lname
argument_list|,
name|elem
argument_list|)
expr_stmt|;
name|optfatal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Do not add this value. */
block|}
comment|/* 	 * SUSv3 states that `ps -G grouplist' should match "real-group 	 * ID numbers", and does not mention group-names.  I do want to 	 * also support group-names, so this tries for a group-id first, 	 * and only tries for a name if that doesn't work.  This is the 	 * opposite order of what is done in addelem_uid(), but in 	 * practice the order would only matter for group-names which 	 * are all-numeric. 	 */
name|grp
operator|=
name|NULL
expr_stmt|;
name|nameorID
operator|=
literal|"named"
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|bigtemp
operator|=
name|strtoul
argument_list|(
name|elem
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
operator|&&
operator|*
name|endp
operator|==
literal|'\0'
operator|&&
name|bigtemp
operator|<=
name|GID_MAX
condition|)
block|{
name|nameorID
operator|=
literal|"name or ID matches"
expr_stmt|;
name|grp
operator|=
name|getgrgid
argument_list|(
operator|(
name|gid_t
operator|)
name|bigtemp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
name|grp
operator|=
name|getgrnam
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"No %s %s '%s'"
argument_list|,
name|inf
operator|->
name|lname
argument_list|,
name|nameorID
argument_list|,
name|elem
argument_list|)
expr_stmt|;
name|optfatal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|inf
operator|->
name|count
operator|>=
name|inf
operator|->
name|maxcount
condition|)
name|expand_list
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|inf
operator|->
name|l
operator|.
name|gids
index|[
operator|(
name|inf
operator|->
name|count
operator|)
operator|++
index|]
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BSD_PID_MAX
value|99999
end_define

begin_comment
comment|/* Copy of PID_MAX from sys/proc.h. */
end_comment

begin_function
specifier|static
name|int
name|addelem_pid
parameter_list|(
name|struct
name|listinfo
modifier|*
name|inf
parameter_list|,
specifier|const
name|char
modifier|*
name|elem
parameter_list|)
block|{
name|char
modifier|*
name|endp
decl_stmt|;
name|long
name|tempid
decl_stmt|;
if|if
condition|(
operator|*
name|elem
operator|==
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid (zero-length) process id"
argument_list|)
expr_stmt|;
name|optfatal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Do not add this value. */
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|tempid
operator|=
name|strtol
argument_list|(
name|elem
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
operator|||
name|tempid
operator|<
literal|0
operator|||
name|elem
operator|==
name|endp
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid %s: %s"
argument_list|,
name|inf
operator|->
name|lname
argument_list|,
name|elem
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ERANGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
name|tempid
operator|>
name|BSD_PID_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"%s too large: %s"
argument_list|,
name|inf
operator|->
name|lname
argument_list|,
name|elem
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ERANGE
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|optfatal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|inf
operator|->
name|count
operator|>=
name|inf
operator|->
name|maxcount
condition|)
name|expand_list
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|inf
operator|->
name|l
operator|.
name|pids
index|[
operator|(
name|inf
operator|->
name|count
operator|)
operator|++
index|]
operator|=
name|tempid
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|BSD_PID_MAX
end_undef

begin_comment
comment|/*-  * The user can specify a device via one of three formats:  *     1) fully qualified, e.g.:     /dev/ttyp0 /dev/console	/dev/pts/0  *     2) missing "/dev", e.g.:      ttyp0      console		pts/0  *     3) two-letters, e.g.:         p0         co		0  *        (matching letters that would be seen in the "TT" column)  */
end_comment

begin_function
specifier|static
name|int
name|addelem_tty
parameter_list|(
name|struct
name|listinfo
modifier|*
name|inf
parameter_list|,
specifier|const
name|char
modifier|*
name|elem
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ttypath
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|char
name|pathbuf
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|pathbuf2
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|pathbuf3
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|ttypath
operator|=
name|NULL
expr_stmt|;
name|pathbuf2
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pathbuf3
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
operator|*
name|elem
condition|)
block|{
case|case
literal|'/'
case|:
name|ttypath
operator|=
name|elem
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|elem
argument_list|,
literal|"co"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ttypath
operator|=
name|_PATH_CONSOLE
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|strlcpy
argument_list|(
name|pathbuf
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|pathbuf
argument_list|,
name|elem
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ttypath
operator|=
name|pathbuf
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pathbuf
argument_list|,
name|_PATH_TTY
argument_list|,
name|strlen
argument_list|(
name|_PATH_TTY
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|pathbuf
argument_list|,
name|_PATH_PTS
argument_list|,
name|strlen
argument_list|(
name|_PATH_PTS
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|pathbuf
argument_list|,
name|_PATH_CONSOLE
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Check to see if /dev/tty${elem} exists */
name|strlcpy
argument_list|(
name|pathbuf2
argument_list|,
name|_PATH_TTY
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf2
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|pathbuf2
argument_list|,
name|elem
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|pathbuf2
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISCHR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* No need to repeat stat()&& S_ISCHR() checks */
name|ttypath
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* Check to see if /dev/pts/${elem} exists */
name|strlcpy
argument_list|(
name|pathbuf3
argument_list|,
name|_PATH_PTS
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf3
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|pathbuf3
argument_list|,
name|elem
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|pathbuf3
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISCHR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* No need to repeat stat()&& S_ISCHR() checks */
name|ttypath
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|ttypath
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|ttypath
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|pathbuf3
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|warn
argument_list|(
literal|"%s, %s, and %s"
argument_list|,
name|pathbuf3
argument_list|,
name|pathbuf2
argument_list|,
name|ttypath
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|ttypath
argument_list|)
expr_stmt|;
name|optfatal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|S_ISCHR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|pathbuf3
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|warnx
argument_list|(
literal|"%s, %s, and %s: Not a terminal"
argument_list|,
name|pathbuf3
argument_list|,
name|pathbuf2
argument_list|,
name|ttypath
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"%s: Not a terminal"
argument_list|,
name|ttypath
argument_list|)
expr_stmt|;
name|optfatal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|inf
operator|->
name|count
operator|>=
name|inf
operator|->
name|maxcount
condition|)
name|expand_list
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|inf
operator|->
name|l
operator|.
name|ttys
index|[
operator|(
name|inf
operator|->
name|count
operator|)
operator|++
index|]
operator|=
name|sb
operator|.
name|st_rdev
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|addelem_uid
parameter_list|(
name|struct
name|listinfo
modifier|*
name|inf
parameter_list|,
specifier|const
name|char
modifier|*
name|elem
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|u_long
name|bigtemp
decl_stmt|;
if|if
condition|(
operator|*
name|elem
operator|==
literal|'\0'
operator|||
name|strlen
argument_list|(
name|elem
argument_list|)
operator|>=
name|MAXLOGNAME
condition|)
block|{
if|if
condition|(
operator|*
name|elem
operator|==
literal|'\0'
condition|)
name|warnx
argument_list|(
literal|"Invalid (zero-length) %s name"
argument_list|,
name|inf
operator|->
name|lname
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"%s name too long: %s"
argument_list|,
name|inf
operator|->
name|lname
argument_list|,
name|elem
argument_list|)
expr_stmt|;
name|optfatal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Do not add this value. */
block|}
name|pwd
operator|=
name|getpwnam
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|bigtemp
operator|=
name|strtoul
argument_list|(
name|elem
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|endp
operator|!=
literal|'\0'
operator|||
name|bigtemp
operator|>
name|UID_MAX
condition|)
name|warnx
argument_list|(
literal|"No %s named '%s'"
argument_list|,
name|inf
operator|->
name|lname
argument_list|,
name|elem
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The string is all digits, so it might be a userID. */
name|pwd
operator|=
name|getpwuid
argument_list|(
operator|(
name|uid_t
operator|)
name|bigtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
name|warnx
argument_list|(
literal|"No %s name or ID matches '%s'"
argument_list|,
name|inf
operator|->
name|lname
argument_list|,
name|elem
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * These used to be treated as minor warnings (and the 		 * option was simply ignored), but now they are fatal 		 * errors (and the command will be aborted). 		 */
name|optfatal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|inf
operator|->
name|count
operator|>=
name|inf
operator|->
name|maxcount
condition|)
name|expand_list
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|inf
operator|->
name|l
operator|.
name|uids
index|[
operator|(
name|inf
operator|->
name|count
operator|)
operator|++
index|]
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_list
parameter_list|(
name|struct
name|listinfo
modifier|*
name|inf
parameter_list|,
specifier|const
name|char
modifier|*
name|argp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|savep
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|int
name|toolong
decl_stmt|;
name|char
name|elemcopy
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|argp
operator|==
literal|0
condition|)
name|inf
operator|->
name|addelem
argument_list|(
name|inf
argument_list|,
name|elemcopy
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|argp
operator|!=
literal|'\0'
condition|)
block|{
while|while
condition|(
operator|*
name|argp
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
name|W_SEP
argument_list|,
operator|*
name|argp
argument_list|)
operator|!=
name|NULL
condition|)
name|argp
operator|++
expr_stmt|;
name|savep
operator|=
name|argp
expr_stmt|;
name|toolong
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|elemcopy
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|T_SEP
argument_list|,
operator|*
name|argp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|endp
operator|=
name|elemcopy
operator|+
sizeof|sizeof
argument_list|(
name|elemcopy
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|argp
operator|!=
literal|'\0'
operator|&&
name|cp
operator|<=
name|endp
operator|&&
name|strchr
argument_list|(
argument|W_SEP T_SEP
argument_list|,
argument|*argp
argument_list|)
operator|==
name|NULL
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|endp
condition|)
name|toolong
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|toolong
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * Add this single element to the given list. 			 */
name|inf
operator|->
name|addelem
argument_list|(
name|inf
argument_list|,
name|elemcopy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The string is too long to copy.  Find the end 			 * of the string to print out the warning message. 			 */
while|while
condition|(
operator|*
name|argp
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
argument|W_SEP T_SEP
argument_list|,
argument|*argp
argument_list|)
operator|==
name|NULL
condition|)
name|argp
operator|++
expr_stmt|;
name|warnx
argument_list|(
literal|"Value too long: %.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|argp
operator|-
name|savep
argument_list|)
argument_list|,
name|savep
argument_list|)
expr_stmt|;
name|optfatal
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Skip over any number of trailing whitespace characters, 		 * but only one (at most) trailing element-terminating 		 * character. 		 */
while|while
condition|(
operator|*
name|argp
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
name|W_SEP
argument_list|,
operator|*
name|argp
argument_list|)
operator|!=
name|NULL
condition|)
name|argp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|argp
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
name|T_SEP
argument_list|,
operator|*
name|argp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|argp
operator|++
expr_stmt|;
comment|/* Catch case where string ended with a comma. */
if|if
condition|(
operator|*
name|argp
operator|==
literal|'\0'
condition|)
name|inf
operator|->
name|addelem
argument_list|(
name|inf
argument_list|,
name|argp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|expand_list
parameter_list|(
name|struct
name|listinfo
modifier|*
name|inf
parameter_list|)
block|{
name|void
modifier|*
name|newlist
decl_stmt|;
name|int
name|newmax
decl_stmt|;
name|newmax
operator|=
operator|(
name|inf
operator|->
name|maxcount
operator|+
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
name|newlist
operator|=
name|realloc
argument_list|(
name|inf
operator|->
name|l
operator|.
name|ptr
argument_list|,
name|newmax
operator|*
name|inf
operator|->
name|elemsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlist
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|inf
operator|->
name|l
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"realloc to %d %ss failed"
argument_list|,
name|newmax
argument_list|,
name|inf
operator|->
name|lname
argument_list|)
expr_stmt|;
block|}
name|inf
operator|->
name|maxcount
operator|=
name|newmax
expr_stmt|;
name|inf
operator|->
name|l
operator|.
name|ptr
operator|=
name|newlist
expr_stmt|;
return|return
operator|(
name|newlist
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_list
parameter_list|(
name|struct
name|listinfo
modifier|*
name|inf
parameter_list|)
block|{
name|inf
operator|->
name|count
operator|=
name|inf
operator|->
name|elemsize
operator|=
name|inf
operator|->
name|maxcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|l
operator|.
name|ptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|inf
operator|->
name|l
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|inf
operator|->
name|addelem
operator|=
name|NULL
expr_stmt|;
name|inf
operator|->
name|lname
operator|=
name|NULL
expr_stmt|;
name|inf
operator|->
name|l
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_list
parameter_list|(
name|struct
name|listinfo
modifier|*
name|inf
parameter_list|,
name|addelem_rtn
name|artn
parameter_list|,
name|int
name|elemsize
parameter_list|,
specifier|const
name|char
modifier|*
name|lname
parameter_list|)
block|{
name|inf
operator|->
name|count
operator|=
name|inf
operator|->
name|maxcount
operator|=
literal|0
expr_stmt|;
name|inf
operator|->
name|elemsize
operator|=
name|elemsize
expr_stmt|;
name|inf
operator|->
name|addelem
operator|=
name|artn
expr_stmt|;
name|inf
operator|->
name|lname
operator|=
name|lname
expr_stmt|;
name|inf
operator|->
name|l
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|VARENT
modifier|*
name|find_varentry
parameter_list|(
name|VAR
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|varent
modifier|*
name|vent
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|vent
argument_list|,
argument|&varlist
argument_list|,
argument|next_ve
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|vent
operator|->
name|var
operator|->
name|name
argument_list|,
name|v
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|vent
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scanvars
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|varent
modifier|*
name|vent
decl_stmt|;
name|VAR
modifier|*
name|v
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|vent
argument_list|,
argument|&varlist
argument_list|,
argument|next_ve
argument_list|)
block|{
name|v
operator|=
name|vent
operator|->
name|var
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|flag
operator|&
name|DSIZ
condition|)
block|{
name|v
operator|->
name|dwidth
operator|=
name|v
operator|->
name|width
expr_stmt|;
name|v
operator|->
name|width
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|flag
operator|&
name|USER
condition|)
name|needuser
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|flag
operator|&
name|COMM
condition|)
name|needcomm
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dynsizevars
parameter_list|(
name|KINFO
modifier|*
name|ki
parameter_list|)
block|{
name|struct
name|varent
modifier|*
name|vent
decl_stmt|;
name|VAR
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|vent
argument_list|,
argument|&varlist
argument_list|,
argument|next_ve
argument_list|)
block|{
name|v
operator|=
name|vent
operator|->
name|var
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|flag
operator|&
name|DSIZ
operator|)
condition|)
continue|continue;
name|i
operator|=
call|(
name|v
operator|->
name|sproc
call|)
argument_list|(
name|ki
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|width
operator|<
name|i
condition|)
name|v
operator|->
name|width
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|width
operator|>
name|v
operator|->
name|dwidth
condition|)
name|v
operator|->
name|width
operator|=
name|v
operator|->
name|dwidth
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sizevars
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|varent
modifier|*
name|vent
decl_stmt|;
name|VAR
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|vent
argument_list|,
argument|&varlist
argument_list|,
argument|next_ve
argument_list|)
block|{
name|v
operator|=
name|vent
operator|->
name|var
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|vent
operator|->
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|width
operator|<
name|i
condition|)
name|v
operator|->
name|width
operator|=
name|i
expr_stmt|;
name|totwidth
operator|+=
name|v
operator|->
name|width
operator|+
literal|1
expr_stmt|;
comment|/* +1 for space */
block|}
name|totwidth
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fmt
parameter_list|(
name|char
modifier|*
modifier|*
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|kvm_t
modifier|*
parameter_list|,
specifier|const
name|struct
name|kinfo_proc
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|KINFO
modifier|*
name|ki
parameter_list|,
name|char
modifier|*
name|comm
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|fmt_argv
argument_list|(
call|(
modifier|*
name|fn
call|)
argument_list|(
name|kd
argument_list|,
name|ki
operator|->
name|ki_p
argument_list|,
name|termwidth
argument_list|)
argument_list|,
name|comm
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|UREADOK
parameter_list|(
name|ki
parameter_list|)
value|(forceuread || (ki->ki_p->ki_flag& P_INMEM))
end_define

begin_function
specifier|static
name|void
name|saveuser
parameter_list|(
name|KINFO
modifier|*
name|ki
parameter_list|)
block|{
if|if
condition|(
name|ki
operator|->
name|ki_p
operator|->
name|ki_flag
operator|&
name|P_INMEM
condition|)
block|{
comment|/* 		 * The u-area might be swapped out, and we can't get 		 * at it because we have a crashdump and no swap. 		 * If it's here fill in these fields, otherwise, just 		 * leave them 0. 		 */
name|ki
operator|->
name|ki_valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ki
operator|->
name|ki_valid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * save arguments if needed 	 */
if|if
condition|(
name|needcomm
condition|)
block|{
if|if
condition|(
name|ki
operator|->
name|ki_p
operator|->
name|ki_stat
operator|==
name|SZOMB
condition|)
name|ki
operator|->
name|ki_args
operator|=
name|strdup
argument_list|(
literal|"<defunct>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|UREADOK
argument_list|(
name|ki
argument_list|)
operator|||
operator|(
name|ki
operator|->
name|ki_p
operator|->
name|ki_args
operator|!=
name|NULL
operator|)
condition|)
name|ki
operator|->
name|ki_args
operator|=
name|strdup
argument_list|(
name|fmt
argument_list|(
name|kvm_getargv
argument_list|,
name|ki
argument_list|,
name|ki
operator|->
name|ki_p
operator|->
name|ki_comm
argument_list|,
name|MAXCOMLEN
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|asprintf
argument_list|(
operator|&
name|ki
operator|->
name|ki_args
argument_list|,
literal|"(%s)"
argument_list|,
name|ki
operator|->
name|ki_p
operator|->
name|ki_comm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|ki_args
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ki
operator|->
name|ki_args
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|needenv
condition|)
block|{
if|if
condition|(
name|UREADOK
argument_list|(
name|ki
argument_list|)
condition|)
name|ki
operator|->
name|ki_env
operator|=
name|strdup
argument_list|(
name|fmt
argument_list|(
name|kvm_getenvv
argument_list|,
name|ki
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ki
operator|->
name|ki_env
operator|=
name|strdup
argument_list|(
literal|"()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ki
operator|->
name|ki_env
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ki
operator|->
name|ki_env
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A macro used to improve the readability of pscomp(). */
end_comment

begin_define
define|#
directive|define
name|DIFF_RETURN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|field
parameter_list|)
value|do {	\ 	if ((a)->field != (b)->field)	\ 		return (((a)->field< (b)->field) ? -1 : 1); 	\ } while (0)
end_define

begin_function
specifier|static
name|int
name|pscomp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|KINFO
modifier|*
name|ka
decl_stmt|,
modifier|*
name|kb
decl_stmt|;
name|ka
operator|=
name|a
expr_stmt|;
name|kb
operator|=
name|b
expr_stmt|;
comment|/* SORTCPU and SORTMEM are sorted in descending order. */
if|if
condition|(
name|sortby
operator|==
name|SORTCPU
condition|)
name|DIFF_RETURN
argument_list|(
name|kb
argument_list|,
name|ka
argument_list|,
name|ki_pcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortby
operator|==
name|SORTMEM
condition|)
name|DIFF_RETURN
argument_list|(
name|kb
argument_list|,
name|ka
argument_list|,
name|ki_memsize
argument_list|)
expr_stmt|;
comment|/* 	 * TTY's are sorted in ascending order, except that all NODEV 	 * processes come before all processes with a device. 	 */
if|if
condition|(
name|ka
operator|->
name|ki_p
operator|->
name|ki_tdev
operator|!=
name|kb
operator|->
name|ki_p
operator|->
name|ki_tdev
condition|)
block|{
if|if
condition|(
name|ka
operator|->
name|ki_p
operator|->
name|ki_tdev
operator|==
name|NODEV
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|kb
operator|->
name|ki_p
operator|->
name|ki_tdev
operator|==
name|NODEV
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|DIFF_RETURN
argument_list|(
name|ka
argument_list|,
name|kb
argument_list|,
name|ki_p
operator|->
name|ki_tdev
argument_list|)
expr_stmt|;
block|}
comment|/* PID's and TID's (threads) are sorted in ascending order. */
name|DIFF_RETURN
argument_list|(
name|ka
argument_list|,
name|kb
argument_list|,
name|ki_p
operator|->
name|ki_pid
argument_list|)
expr_stmt|;
name|DIFF_RETURN
argument_list|(
name|ka
argument_list|,
name|kb
argument_list|,
name|ki_p
operator|->
name|ki_tid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|DIFF_RETURN
end_undef

begin_comment
comment|/*  * ICK (all for getopt), would rather hide the ugliness  * here than taint the main code.  *  *  ps foo -> ps -foo  *  ps 34 -> ps -p34  *  * The old convention that 't' with no trailing tty arg means the users  * tty, is only supported if argv[1] doesn't begin with a '-'.  This same  * feature is available with the option 'T', which takes no argument.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|kludge_oldps_options
parameter_list|(
specifier|const
name|char
modifier|*
name|optlist
parameter_list|,
name|char
modifier|*
name|origval
parameter_list|,
specifier|const
name|char
modifier|*
name|nextarg
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|argp
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|newopts
decl_stmt|,
modifier|*
name|ns
decl_stmt|,
modifier|*
name|optp
decl_stmt|,
modifier|*
name|pidp
decl_stmt|;
comment|/* 	 * See if the original value includes any option which takes an 	 * argument (and will thus use up the remainder of the string). 	 */
name|argp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|optlist
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|origval
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
name|optp
operator|=
name|strchr
argument_list|(
name|optlist
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|optp
operator|!=
name|NULL
operator|)
operator|&&
operator|*
operator|(
name|optp
operator|+
literal|1
operator|)
operator|==
literal|':'
condition|)
block|{
name|argp
operator|=
name|cp
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|argp
operator|!=
name|NULL
operator|&&
operator|*
name|origval
operator|==
literal|'-'
condition|)
return|return
operator|(
name|origval
operator|)
return|;
comment|/* 	 * if last letter is a 't' flag with no argument (in the context 	 * of the oldps options -- option string NOT starting with a '-' -- 	 * then convert to 'T' (meaning *this* terminal, i.e. ttyname(0)). 	 * 	 * However, if a flag accepting a string argument is found earlier 	 * in the option string (including a possible `t' flag), then the 	 * remainder of the string must be the argument to that flag; so 	 * do not modify that argument.  Note that a trailing `t' would 	 * cause argp to be set, if argp was not already set by some 	 * earlier option. 	 */
name|len
operator|=
name|strlen
argument_list|(
name|origval
argument_list|)
expr_stmt|;
name|cp
operator|=
name|origval
operator|+
name|len
operator|-
literal|1
expr_stmt|;
name|pidp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'t'
operator|&&
operator|*
name|origval
operator|!=
literal|'-'
operator|&&
name|cp
operator|==
name|argp
condition|)
block|{
if|if
condition|(
name|nextarg
operator|==
name|NULL
operator|||
operator|*
name|nextarg
operator|==
literal|'-'
operator|||
name|isdigitch
argument_list|(
operator|*
name|nextarg
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|'T'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The original value did not include any option which takes 		 * an argument (and that would include `p' and `t'), so check 		 * the value for trailing number, or comma-separated list of 		 * numbers, which we will treat as a pid request. 		 */
if|if
condition|(
name|isdigitch
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
while|while
condition|(
name|cp
operator|>=
name|origval
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|','
operator|||
name|isdigitch
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
operator|--
name|cp
expr_stmt|;
name|pidp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * If nothing needs to be added to the string, then return 	 * the "original" (although possibly modified) value. 	 */
if|if
condition|(
operator|*
name|origval
operator|==
literal|'-'
operator|&&
name|pidp
operator|==
name|NULL
condition|)
return|return
operator|(
name|origval
operator|)
return|;
comment|/* 	 * Create a copy of the string to add '-' and/or 'p' to the 	 * original value. 	 */
if|if
condition|(
operator|(
name|newopts
operator|=
name|ns
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|origval
operator|!=
literal|'-'
condition|)
operator|*
name|ns
operator|++
operator|=
literal|'-'
expr_stmt|;
comment|/* add option flag */
if|if
condition|(
name|pidp
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|ns
argument_list|,
name|origval
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Copy everything before the pid string, add the `p', 		 * and then copy the pid string. 		 */
name|len
operator|=
name|pidp
operator|-
name|origval
expr_stmt|;
name|memcpy
argument_list|(
name|ns
argument_list|,
name|origval
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ns
operator|+=
name|len
expr_stmt|;
operator|*
name|ns
operator|++
operator|=
literal|'p'
expr_stmt|;
name|strcpy
argument_list|(
name|ns
argument_list|,
name|pidp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|newopts
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_procfs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|statfs
name|mnt
decl_stmt|;
if|if
condition|(
name|statfs
argument_list|(
literal|"/proc"
argument_list|,
operator|&
name|mnt
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|mnt
operator|.
name|f_fstypename
argument_list|,
literal|"procfs"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|SINGLE_OPTS
value|"[-aCce" OPT_LAZY_f "HhjlmrSTuvwXxZ]"
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n%s\n%s\n"
argument_list|,
literal|"usage: ps "
name|SINGLE_OPTS
literal|" [-O fmt | -o fmt] [-G gid[,gid...]]"
argument_list|,
literal|"          [-M core] [-N system]"
argument_list|,
literal|"          [-p pid[,pid...]] [-t tty[,tty...]] [-U user[,user...]]"
argument_list|,
literal|"       ps [-L]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

