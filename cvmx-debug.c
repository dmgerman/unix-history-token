begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/*  * @file  *  * Interface to debug exception handler  * NOTE: CARE SHOULD BE TAKE WHEN USING STD C LIBRARY FUNCTIONS IN  * THIS FILE IF SOMEONE PUTS A BREAKPOINT ON THOSE FUNCTIONS  * DEBUGGING WILL FAIL.  *  *<hr>$Revision: 50060 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/octeon.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-debug.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-core.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-bootmem.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/octeon-boot-info.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-debug.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-core.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-coremask.h"
end_include

begin_include
include|#
directive|include
file|"octeon-boot-info.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_DEBUG_LOGGING
end_ifdef

begin_undef
undef|#
directive|undef
name|CVMX_DEBUG_LOGGING
end_undef

begin_define
define|#
directive|define
name|CVMX_DEBUG_LOGGING
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DEBUG_LOGGING
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_DEBUG_ATTACH
end_ifndef

begin_define
define|#
directive|define
name|CVMX_DEBUG_ATTACH
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_STATUS
value|(0xFFFFFFFFFF301000ull)
end_define

begin_define
define|#
directive|define
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_ADDRESS
parameter_list|(
name|num
parameter_list|)
value|(0xFFFFFFFFFF301100ull + 0x100 * (num))
end_define

begin_define
define|#
directive|define
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_ADDRESS_MASK
parameter_list|(
name|num
parameter_list|)
value|(0xFFFFFFFFFF301108ull + 0x100 * (num))
end_define

begin_define
define|#
directive|define
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_ASID
parameter_list|(
name|num
parameter_list|)
value|(0xFFFFFFFFFF301110ull + 0x100 * (num))
end_define

begin_define
define|#
directive|define
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_CONTROL
parameter_list|(
name|num
parameter_list|)
value|(0xFFFFFFFFFF301118ull + 0x100 * (num))
end_define

begin_define
define|#
directive|define
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_STATUS
value|(0xFFFFFFFFFF302000ull)
end_define

begin_define
define|#
directive|define
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_ADDRESS
parameter_list|(
name|num
parameter_list|)
value|(0xFFFFFFFFFF302100ull + 0x100 * (num))
end_define

begin_define
define|#
directive|define
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_ADDRESS_MASK
parameter_list|(
name|num
parameter_list|)
value|(0xFFFFFFFFFF302108ull + 0x100 * (num))
end_define

begin_define
define|#
directive|define
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_ASID
parameter_list|(
name|num
parameter_list|)
value|(0xFFFFFFFFFF302110ull + 0x100 * (num))
end_define

begin_define
define|#
directive|define
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_CONTROL
parameter_list|(
name|num
parameter_list|)
value|(0xFFFFFFFFFF302118ull + 0x100 * (num))
end_define

begin_define
define|#
directive|define
name|ERET_INSN
value|0x42000018U
end_define

begin_comment
comment|/* Hexcode for eret */
end_comment

begin_define
define|#
directive|define
name|ISR_DELAY_COUNTER
value|120000000
end_define

begin_comment
comment|/* Could be tuned down */
end_comment

begin_decl_stmt
specifier|extern
name|cvmx_debug_comm_t
name|cvmx_debug_uart_comm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|cvmx_debug_comm_t
name|cvmx_debug_remote_comm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cvmx_debug_comm_t
modifier|*
name|cvmx_debug_comms
index|[
name|COMM_SIZE
index|]
init|=
block|{
operator|&
name|cvmx_debug_uart_comm
block|,
operator|&
name|cvmx_debug_remote_comm
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cvmx_debug_globals_t
modifier|*
name|cvmx_debug_globals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * @file  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifndef

begin_decl_stmt
name|uint64_t
name|__cvmx_debug_save_regs_area
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|uint64_t
name|__cvmx_debug_mode_exception_ignore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|uint64_t
name|__cvmx_debug_mode_exception_occured
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cvmx_debug_stack
index|[
literal|8
operator|*
literal|1024
index|]
name|__attribute
argument_list|(
operator|(
name|aligned
argument_list|(
literal|16
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|__cvmx_debug_stack_top
init|=
operator|&
name|cvmx_debug_stack
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_TOOLCHAIN
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|cvmx_interrupt_in_isr
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|cvmx_interrupt_in_isr
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|uint64_t
name|__cvmx_debug_save_regs_area_all
index|[
name|CVMX_MAX_CORES
index|]
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|__cvmx_debug_save_regs_area
value|__cvmx_debug_save_regs_area_all[cvmx_get_core_num()]
end_define

begin_decl_stmt
specifier|volatile
name|uint64_t
name|__cvmx_debug_mode_exception_ignore_all
index|[
name|CVMX_MAX_CORES
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|__cvmx_debug_mode_exception_ignore
value|__cvmx_debug_mode_exception_ignore_all[cvmx_get_core_num()]
end_define

begin_decl_stmt
specifier|volatile
name|uint64_t
name|__cvmx_debug_mode_exception_occured_all
index|[
name|CVMX_MAX_CORES
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|__cvmx_debug_mode_exception_occured
value|__cvmx_debug_mode_exception_occured_all[cvmx_get_core_num()]
end_define

begin_decl_stmt
specifier|static
name|char
name|cvmx_debug_stack_all
index|[
name|CVMX_MAX_CORES
index|]
index|[
literal|8
operator|*
literal|1024
index|]
name|__attribute
argument_list|(
operator|(
name|aligned
argument_list|(
literal|16
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|__cvmx_debug_stack_top_all
index|[
name|CVMX_MAX_CORES
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cvmx_interrupt_in_isr
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|size_t
name|cvmx_debug_strlen
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|size_t
name|size
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
name|size
operator|++
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_strcpy
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
while|while
condition|(
operator|*
name|src
condition|)
block|{
operator|*
name|dest
operator|=
operator|*
name|src
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|dest
operator|++
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|cvmx_debug_memcpy_align
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noinline__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|cvmx_debug_memcpy_align
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|long
name|long
modifier|*
name|dest1
init|=
operator|(
name|long
name|long
operator|*
operator|)
name|dest
decl_stmt|;
specifier|const
name|long
name|long
modifier|*
name|src1
init|=
operator|(
specifier|const
name|long
name|long
operator|*
operator|)
name|src
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|40
condition|)
block|{
name|long
name|long
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|;
name|a0
operator|=
name|src1
index|[
literal|0
index|]
expr_stmt|;
name|a1
operator|=
name|src1
index|[
literal|1
index|]
expr_stmt|;
name|a2
operator|=
name|src1
index|[
literal|2
index|]
expr_stmt|;
name|a3
operator|=
name|src1
index|[
literal|3
index|]
expr_stmt|;
name|a4
operator|=
name|src1
index|[
literal|4
index|]
expr_stmt|;
name|dest1
index|[
literal|0
index|]
operator|=
name|a0
expr_stmt|;
name|dest1
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
name|dest1
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
name|dest1
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
name|dest1
index|[
literal|4
index|]
operator|=
name|a4
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
literal|8
control|)
block|{
operator|*
name|dest1
operator|=
operator|*
name|src1
expr_stmt|;
name|dest1
operator|++
expr_stmt|;
name|src1
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|cvmx_debug_core_mask
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_TOOLCHAIN
specifier|extern
name|int
name|__octeon_core_mask
decl_stmt|;
return|return
name|__octeon_core_mask
return|;
endif|#
directive|endif
return|return
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|core_mask
return|;
else|#
directive|else
return|return
name|octeon_get_boot_coremask
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|cvmx_debug_update_state
parameter_list|(
name|cvmx_debug_state_t
name|state
parameter_list|)
block|{
name|cvmx_debug_memcpy_align
argument_list|(
name|cvmx_debug_globals
operator|->
name|state
argument_list|,
operator|&
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_debug_state_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|cvmx_debug_state_t
name|cvmx_debug_get_state
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_debug_state_t
name|state
decl_stmt|;
name|cvmx_debug_memcpy_align
argument_list|(
operator|&
name|state
argument_list|,
name|cvmx_debug_globals
operator|->
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_debug_state_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|state
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|cvmx_debug_printf
parameter_list|(
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(format
parameter_list|(
name|__printf__
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|cvmx_debug_printf
parameter_list|(
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|CVMX_DEBUG_LOGGING
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|cvmx_dvprintf
argument_list|(
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_debug_in_focus
parameter_list|(
name|cvmx_debug_state_t
name|state
parameter_list|,
name|unsigned
name|core
parameter_list|)
block|{
return|return
name|state
operator|.
name|focus_core
operator|==
name|core
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_install_handler
parameter_list|(
name|unsigned
name|core
parameter_list|)
block|{
specifier|extern
name|void
name|__cvmx_debug_handler_stage2
argument_list|(
name|void
argument_list|)
decl_stmt|;
name|int32_t
modifier|*
name|trampoline
init|=
name|CASTPTR
argument_list|(
name|int32_t
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|BOOTLOADER_DEBUG_TRAMPOLINE_CORE
argument_list|)
argument_list|)
decl_stmt|;
name|trampoline
operator|+=
name|core
expr_stmt|;
operator|*
name|trampoline
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|long
argument_list|)
operator|&
name|__cvmx_debug_handler_stage2
expr_stmt|;
name|cvmx_debug_printf
argument_list|(
literal|"Debug handled installed on core %d at %p\n"
argument_list|,
name|core
argument_list|,
name|trampoline
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cvmx_debug_enabled
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|cvmx_debug_booted
argument_list|()
operator|||
name|CVMX_DEBUG_ATTACH
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_init_global_ptr
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|uint64_t
name|phys
init|=
name|cvmx_ptr_to_phys
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|cvmx_debug_globals_t
modifier|*
name|p
decl_stmt|;
comment|/* Since at this point, TLBs are not mapped 1 to 1, we should just use KSEG0 accesses. */
name|p
operator|=
name|CASTPTR
argument_list|(
name|cvmx_debug_globals_t
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|phys
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_debug_globals_t
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|version
operator|=
name|CVMX_DEBUG_GLOBALS_VERSION
expr_stmt|;
name|p
operator|->
name|tlb_entries
operator|=
name|cvmx_core_get_tlb_entries
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_init_globals
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|phys
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|cvmx_debug_globals
condition|)
return|return;
name|ptr
operator|=
name|cvmx_bootmem_alloc_named_range_once
argument_list|(
sizeof|sizeof
argument_list|(
name|cvmx_debug_globals_t
argument_list|)
argument_list|,
literal|0
argument_list|,
comment|/* KSEG0 max, 512MB=*/
literal|0
comment|/*1024*1024*512*/
argument_list|,
literal|8
argument_list|,
name|CVMX_DEBUG_GLOBALS_BLOCK_NAME
argument_list|,
name|cvmx_debug_init_global_ptr
argument_list|)
expr_stmt|;
name|phys
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* Since TLBs are not always mapped 1 to 1, we should just use access via KSEG0. */
name|cvmx_debug_globals
operator|=
name|CASTPTR
argument_list|(
name|cvmx_debug_globals_t
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|phys
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_debug_printf
argument_list|(
literal|"Debug named block at %p\n"
argument_list|,
name|cvmx_debug_globals
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_globals_check_version
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cvmx_debug_globals
operator|->
name|version
operator|!=
name|CVMX_DEBUG_GLOBALS_VERSION
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Wrong version on the globals struct spinining; expected %d, got:  %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|CVMX_DEBUG_GLOBALS_VERSION
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cvmx_debug_globals
operator|->
name|version
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
name|panic
argument_list|(
literal|"Wrong version.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
empty_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
specifier|inline
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|cvmx_debug_core_context
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|cvmx_debug_save_core_context
parameter_list|(
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
parameter_list|,
name|uint64_t
name|hi
parameter_list|,
name|uint64_t
name|lo
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|cvmx_debug_init
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_debug_state_t
name|state
decl_stmt|;
name|int
name|core
decl_stmt|;
specifier|const
name|cvmx_debug_comm_t
modifier|*
name|comm
decl_stmt|;
name|cvmx_spinlock_t
modifier|*
name|lock
decl_stmt|;
name|unsigned
name|int
name|coremask
init|=
name|cvmx_debug_core_mask
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cvmx_debug_enabled
argument_list|()
condition|)
return|return;
name|cvmx_debug_init_globals
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
comment|// Put a barrier until all cores have got to this point.
name|cvmx_coremask_barrier_sync
argument_list|(
name|coremask
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_debug_globals_check_version
argument_list|()
expr_stmt|;
name|comm
operator|=
name|cvmx_debug_comms
index|[
name|cvmx_debug_globals
operator|->
name|comm_type
index|]
expr_stmt|;
name|lock
operator|=
operator|&
name|cvmx_debug_globals
operator|->
name|lock
expr_stmt|;
name|core
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
comment|/*  Install the debugger handler on the cores. */
block|{
name|int
name|core1
init|=
literal|0
decl_stmt|;
for|for
control|(
name|core1
operator|=
literal|0
init|;
name|core1
operator|<
name|CVMX_MAX_CORES
condition|;
name|core1
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|1u
operator|<<
name|core1
operator|)
operator|&
name|coremask
condition|)
name|cvmx_debug_install_handler
argument_list|(
name|core1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|cvmx_debug_install_handler
argument_list|(
name|core
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|comm
operator|->
name|init
condition|)
name|comm
operator|->
name|init
argument_list|()
expr_stmt|;
block|{
name|cvmx_spinlock_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
name|state
operator|.
name|known_cores
operator||=
name|coremask
expr_stmt|;
name|state
operator|.
name|core_finished
operator|&=
operator|~
name|coremask
expr_stmt|;
else|#
directive|else
name|state
operator|.
name|known_cores
operator||=
operator|(
literal|1u
operator|<<
name|core
operator|)
expr_stmt|;
name|state
operator|.
name|core_finished
operator|&=
operator|~
operator|(
literal|1u
operator|<<
name|core
operator|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
comment|// Put a barrier until all cores have got to this point.
name|cvmx_coremask_barrier_sync
argument_list|(
name|coremask
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|coremask
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|cvmx_debug_printf
argument_list|(
literal|"cvmx_debug_init core: %d\n"
argument_list|,
name|core
argument_list|)
expr_stmt|;
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
name|state
operator|.
name|focus_core
operator|=
name|core
expr_stmt|;
name|state
operator|.
name|active_cores
operator|=
name|state
operator|.
name|known_cores
expr_stmt|;
name|state
operator|.
name|focus_switch
operator|=
literal|1
expr_stmt|;
name|state
operator|.
name|step_isr
operator|=
literal|1
expr_stmt|;
name|cvmx_debug_printf
argument_list|(
literal|"Known cores at init: 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|state
operator|.
name|known_cores
argument_list|)
expr_stmt|;
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|/* Initialize __cvmx_debug_stack_top_all. */
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_MAX_CORES
condition|;
name|i
operator|++
control|)
name|__cvmx_debug_stack_top_all
index|[
name|i
index|]
operator|=
operator|&
name|cvmx_debug_stack_all
index|[
name|i
index|]
index|[
literal|8
operator|*
literal|1024
index|]
expr_stmt|;
block|}
endif|#
directive|endif
name|cvmx_debug_globals
operator|->
name|init_complete
operator|=
literal|1
expr_stmt|;
name|CVMX_SYNCW
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|cvmx_debug_globals
operator|->
name|init_complete
condition|)
block|{
comment|/* Spin waiting for init to complete */
block|}
if|if
condition|(
name|cvmx_debug_booted
argument_list|()
condition|)
name|cvmx_debug_trigger_exception
argument_list|()
expr_stmt|;
comment|/*  Install the break handler after might tripper the debugger exception. */
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|coremask
argument_list|)
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|comm
operator|->
name|install_break_handler
condition|)
name|comm
operator|->
name|install_break_handler
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|cvmx_debug_hexchar
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Put the hex value of t into str. */
end_comment

begin_function
specifier|static
name|void
name|cvmx_debug_int8_to_strhex
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|str
index|[
literal|0
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
name|cvmx_debug_hexchar
index|[
name|t
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_int64_to_strhex
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|uint64_t
name|t
parameter_list|)
block|{
name|str
index|[
literal|0
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|60
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|56
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|2
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|52
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|3
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|48
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|4
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|44
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|5
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|40
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|6
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|36
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|7
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|32
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|8
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|28
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|9
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|24
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|10
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|20
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|11
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|16
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|12
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|12
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|13
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|14
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|4
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|15
index|]
operator|=
name|cvmx_debug_hexchar
index|[
operator|(
name|t
operator|>>
literal|0
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cvmx_debug_putpacket_noformat
parameter_list|(
name|char
modifier|*
name|packet
parameter_list|)
block|{
if|if
condition|(
name|cvmx_debug_comms
index|[
name|cvmx_debug_globals
operator|->
name|comm_type
index|]
operator|->
name|putpacket
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|cvmx_debug_printf
argument_list|(
literal|"Reply: %s\n"
argument_list|,
name|packet
argument_list|)
expr_stmt|;
return|return
name|cvmx_debug_comms
index|[
name|cvmx_debug_globals
operator|->
name|comm_type
index|]
operator|->
name|putpacket
argument_list|(
name|packet
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cvmx_debug_putcorepacket
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|core
parameter_list|)
block|{
name|char
modifier|*
name|tmp
init|=
literal|"!Core XX "
decl_stmt|;
name|int
name|tmpsize
init|=
name|cvmx_debug_strlen
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
name|int
name|bufsize
init|=
name|cvmx_debug_strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|char
modifier|*
name|packet
init|=
name|__builtin_alloca
argument_list|(
name|tmpsize
operator|+
name|bufsize
operator|+
literal|1
argument_list|)
decl_stmt|;
name|cvmx_debug_strcpy
argument_list|(
name|packet
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|cvmx_debug_strcpy
argument_list|(
operator|&
name|packet
index|[
name|tmpsize
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|core
operator|<
literal|10
condition|)
block|{
name|packet
index|[
literal|6
index|]
operator|=
literal|' '
expr_stmt|;
name|packet
index|[
literal|7
index|]
operator|=
name|core
operator|+
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|core
operator|<
literal|20
condition|)
block|{
name|packet
index|[
literal|6
index|]
operator|=
literal|'1'
expr_stmt|;
name|packet
index|[
literal|7
index|]
operator|=
name|core
operator|-
literal|10
operator|+
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|core
operator|<
literal|30
condition|)
block|{
name|packet
index|[
literal|6
index|]
operator|=
literal|'2'
expr_stmt|;
name|packet
index|[
literal|7
index|]
operator|=
name|core
operator|-
literal|20
operator|+
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|packet
index|[
literal|6
index|]
operator|=
literal|'3'
expr_stmt|;
name|packet
index|[
literal|7
index|]
operator|=
name|core
operator|-
literal|30
operator|+
literal|'0'
expr_stmt|;
block|}
return|return
name|cvmx_debug_putpacket_noformat
argument_list|(
name|packet
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Put a buf followed by an integer formated as a hex.  */
end_comment

begin_function
specifier|static
name|int
name|cvmx_debug_putpacket_hexint
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|size_t
name|size
init|=
name|cvmx_debug_strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|char
modifier|*
name|packet
init|=
name|__builtin_alloca
argument_list|(
name|size
operator|+
literal|16
operator|+
literal|1
argument_list|)
decl_stmt|;
name|cvmx_debug_strcpy
argument_list|(
name|packet
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cvmx_debug_int64_to_strhex
argument_list|(
operator|&
name|packet
index|[
name|size
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|cvmx_debug_putpacket_noformat
argument_list|(
name|packet
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cvmx_debug_active_core
parameter_list|(
name|cvmx_debug_state_t
name|state
parameter_list|,
name|unsigned
name|core
parameter_list|)
block|{
return|return
name|state
operator|.
name|active_cores
operator|&
operator|(
literal|1u
operator|<<
name|core
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|cvmx_debug_core_context
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|cvmx_debug_globals
operator|->
name|contextes
index|[
name|cvmx_get_core_num
argument_list|()
index|]
return|;
block|}
end_function

begin_function
specifier|static
specifier|volatile
name|uint64_t
modifier|*
name|cvmx_debug_regnum_to_context_ref
parameter_list|(
name|int
name|regnum
parameter_list|,
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
parameter_list|)
block|{
comment|/* Must be kept in sync with mips_octeon_reg_names in gdb/mips-tdep.c. */
if|if
condition|(
name|regnum
operator|<
literal|32
condition|)
return|return
operator|&
name|context
operator|->
name|regs
index|[
name|regnum
index|]
return|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
literal|32
case|:
return|return
operator|&
name|context
operator|->
name|cop0
operator|.
name|status
return|;
case|case
literal|33
case|:
return|return
operator|&
name|context
operator|->
name|lo
return|;
case|case
literal|34
case|:
return|return
operator|&
name|context
operator|->
name|hi
return|;
case|case
literal|35
case|:
return|return
operator|&
name|context
operator|->
name|cop0
operator|.
name|badvaddr
return|;
case|case
literal|36
case|:
return|return
operator|&
name|context
operator|->
name|cop0
operator|.
name|cause
return|;
case|case
literal|37
case|:
return|return
operator|&
name|context
operator|->
name|cop0
operator|.
name|depc
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cvmx_debug_probe_load
parameter_list|(
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|unsigned
name|char
modifier|*
name|result
parameter_list|)
block|{
specifier|volatile
name|unsigned
name|char
modifier|*
name|p
init|=
name|ptr
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|unsigned
name|char
name|tem
decl_stmt|;
block|{
name|__cvmx_debug_mode_exception_ignore
operator|=
literal|1
expr_stmt|;
name|__cvmx_debug_mode_exception_occured
operator|=
literal|0
expr_stmt|;
comment|/* We don't handle debug-mode exceptions in delay slots.  Avoid them.  */
asm|asm
specifier|volatile
asm|(".set push		\n\t"                       ".set noreorder	\n\t"                       "nop			\n\t"                       "lbu %0, %1		\n\t"                       "nop			\n\t"                       ".set pop" : "=r"(tem) : "m"(*p));
name|ok
operator|=
name|__cvmx_debug_mode_exception_occured
operator|==
literal|0
expr_stmt|;
name|__cvmx_debug_mode_exception_ignore
operator|=
literal|0
expr_stmt|;
name|__cvmx_debug_mode_exception_occured
operator|=
literal|0
expr_stmt|;
operator|*
name|result
operator|=
name|tem
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cvmx_debug_probe_store
parameter_list|(
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|volatile
name|unsigned
name|char
modifier|*
name|p
init|=
name|ptr
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|__cvmx_debug_mode_exception_ignore
operator|=
literal|1
expr_stmt|;
name|__cvmx_debug_mode_exception_occured
operator|=
literal|0
expr_stmt|;
comment|/* We don't handle debug-mode exceptions in delay slots.  Avoid them.  */
asm|asm
specifier|volatile
asm|(".set push		\n\t"                   ".set noreorder	\n\t"                   "nop			\n\t"                   "sb $0, %0		\n\t"                   "nop			\n\t"                   ".set pop" : "=m"(*p));
name|ok
operator|=
name|__cvmx_debug_mode_exception_occured
operator|==
literal|0
expr_stmt|;
name|__cvmx_debug_mode_exception_ignore
operator|=
literal|0
expr_stmt|;
name|__cvmx_debug_mode_exception_occured
operator|=
literal|0
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/**  * Routines to handle hex data  *  * @param ch  * @return  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cvmx_debug_hex
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'F'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * While we find nice hex chars, build an int.  * Return number of chars processed.  *  * @param ptr  * @param intValue  * @return  */
end_comment

begin_function
specifier|static
name|int
name|cvmx_debug_hexToLong
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|uint64_t
modifier|*
name|intValue
parameter_list|)
block|{
name|int
name|numChars
init|=
literal|0
decl_stmt|;
name|long
name|hexValue
decl_stmt|;
operator|*
name|intValue
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|ptr
condition|)
block|{
name|hexValue
operator|=
name|cvmx_debug_hex
argument_list|(
operator|*
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hexValue
operator|<
literal|0
condition|)
break|break;
operator|*
name|intValue
operator|=
operator|(
operator|*
name|intValue
operator|<<
literal|4
operator|)
operator||
name|hexValue
expr_stmt|;
name|numChars
operator|++
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|numChars
operator|)
return|;
block|}
end_function

begin_comment
comment|/**   * Initialize the performance counter control registers.   *   */
end_comment

begin_function
specifier|static
name|void
name|cvmx_debug_set_perf_control_reg
parameter_list|(
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
parameter_list|,
name|int
name|perf_event
parameter_list|,
name|int
name|perf_counter
parameter_list|)
block|{
name|cvmx_core_perf_control_t
name|control
decl_stmt|;
name|control
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|u
operator|=
literal|1
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|s
operator|=
literal|1
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|k
operator|=
literal|1
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|ex
operator|=
literal|1
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|w
operator|=
literal|1
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|m
operator|=
literal|1
operator|-
name|perf_counter
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|event
operator|=
name|perf_event
expr_stmt|;
name|context
operator|->
name|cop0
operator|.
name|perfctrl
index|[
name|perf_counter
index|]
operator|=
name|control
operator|.
name|u32
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|cvmx_debug_command_t
name|cvmx_debug_process_packet
parameter_list|(
specifier|const
name|char
modifier|*
name|packet
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|buf
init|=
name|packet
decl_stmt|;
name|cvmx_debug_command_t
name|result
init|=
name|COMMAND_NOP
decl_stmt|;
name|cvmx_debug_state_t
name|state
init|=
name|cvmx_debug_get_state
argument_list|()
decl_stmt|;
comment|/* A one letter command code represents what to do.  */
switch|switch
condition|(
operator|*
name|buf
operator|++
condition|)
block|{
case|case
literal|'?'
case|:
comment|/* What protocol do I speak? */
name|cvmx_debug_putpacket_noformat
argument_list|(
literal|"S0A"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\003'
case|:
comment|/* Control-C */
name|cvmx_debug_putpacket_noformat
argument_list|(
literal|"T9"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Change the focus core */
block|{
name|uint64_t
name|core
decl_stmt|;
if|if
condition|(
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|core
argument_list|)
condition|)
block|{
name|cvmx_debug_putpacket_noformat
argument_list|(
literal|"!Uknown core.  Focus not changed."
argument_list|)
expr_stmt|;
block|}
comment|/* Only cores in the exception handler may become the focus.                If a core not in the exception handler got focus the                debugger would hang since nobody would talk to it.  */
elseif|else
if|if
condition|(
name|state
operator|.
name|handler_cores
operator|&
operator|(
literal|1u
operator|<<
name|core
operator|)
condition|)
block|{
comment|/* Focus change reply must be sent before the focus                    changes. Otherwise the new focus core will eat our ACK                    from the debugger.  */
name|cvmx_debug_putpacket_hexint
argument_list|(
literal|"F"
argument_list|,
name|core
argument_list|)
expr_stmt|;
name|cvmx_debug_comms
index|[
name|cvmx_debug_globals
operator|->
name|comm_type
index|]
operator|->
name|change_core
argument_list|(
name|state
operator|.
name|focus_core
argument_list|,
name|core
argument_list|)
expr_stmt|;
name|state
operator|.
name|focus_core
operator|=
name|core
expr_stmt|;
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|cvmx_debug_putpacket_noformat
argument_list|(
literal|"!Core is not in the exception handler. Focus not changed."
argument_list|)
expr_stmt|;
comment|/* Nothing changed, so we send back the old value */
block|}
comment|/* fall through */
case|case
literal|'f'
case|:
comment|/* Get the focus core */
name|cvmx_debug_putpacket_hexint
argument_list|(
literal|"F"
argument_list|,
name|state
operator|.
name|focus_core
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* Set the flag for skip-over-isr in Single-Stepping mode */
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'1'
condition|)
name|state
operator|.
name|step_isr
operator|=
literal|1
expr_stmt|;
comment|/* Step in ISR */
else|else
name|state
operator|.
name|step_isr
operator|=
literal|0
expr_stmt|;
comment|/* Step over ISR */
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through. The reply to the set step-isr command is the            same as the get step-isr command */
case|case
literal|'j'
case|:
comment|/* Reply with step_isr status  */
name|cvmx_debug_putpacket_hexint
argument_list|(
literal|"J"
argument_list|,
operator|(
name|unsigned
operator|)
name|state
operator|.
name|step_isr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Set the active cores */
block|{
name|uint64_t
name|active_cores
decl_stmt|;
if|if
condition|(
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|active_cores
argument_list|)
condition|)
name|active_cores
operator|=
literal|0
expr_stmt|;
comment|/* Limit the active mask to the known to exist cores */
name|state
operator|.
name|active_cores
operator|=
name|active_cores
operator|&
name|state
operator|.
name|known_cores
expr_stmt|;
comment|/* Lazy user hack to have 0 be all cores */
if|if
condition|(
name|state
operator|.
name|active_cores
operator|==
literal|0
condition|)
name|state
operator|.
name|active_cores
operator|=
name|state
operator|.
name|known_cores
expr_stmt|;
comment|/* The focus core must be in the active_cores mask */
if|if
condition|(
operator|(
name|state
operator|.
name|active_cores
operator|&
operator|(
literal|1u
operator|<<
name|state
operator|.
name|focus_core
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|cvmx_debug_putpacket_noformat
argument_list|(
literal|"!Focus core was added to the masked."
argument_list|)
expr_stmt|;
name|state
operator|.
name|active_cores
operator||=
literal|1u
operator|<<
name|state
operator|.
name|focus_core
expr_stmt|;
block|}
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through. The reply to the set active cores command is the            same as the get active cores command */
case|case
literal|'i'
case|:
comment|/* Get the active cores */
name|cvmx_debug_putpacket_hexint
argument_list|(
literal|"I"
argument_list|,
name|state
operator|.
name|active_cores
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* Setting the step mode all or one */
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'1'
condition|)
name|state
operator|.
name|step_all
operator|=
literal|1
expr_stmt|;
comment|/* A step or continue will start all cores */
else|else
name|state
operator|.
name|step_all
operator|=
literal|0
expr_stmt|;
comment|/* A step or continue only affects the focus core */
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through. The reply to the set step-all command is the            same as the get step-all command */
case|case
literal|'a'
case|:
comment|/* Getting the current step mode */
name|cvmx_debug_putpacket_hexint
argument_list|(
literal|"A"
argument_list|,
name|state
operator|.
name|step_all
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* read a register from global place. */
block|{
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
init|=
name|cvmx_debug_core_context
argument_list|()
decl_stmt|;
name|uint64_t
name|regno
decl_stmt|;
specifier|volatile
name|uint64_t
modifier|*
name|reg
decl_stmt|;
comment|/* Get the register number to read */
if|if
condition|(
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Register number cannot be read.\n"
argument_list|)
expr_stmt|;
name|cvmx_debug_putpacket_hexint
argument_list|(
literal|""
argument_list|,
literal|0xDEADBEEF
argument_list|)
expr_stmt|;
break|break;
block|}
name|reg
operator|=
name|cvmx_debug_regnum_to_context_ref
argument_list|(
name|regno
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Register #%d is not valid\n"
argument_list|,
operator|(
name|int
operator|)
name|regno
argument_list|)
expr_stmt|;
name|cvmx_debug_putpacket_hexint
argument_list|(
literal|""
argument_list|,
literal|0xDEADBEEF
argument_list|)
expr_stmt|;
break|break;
block|}
name|cvmx_debug_putpacket_hexint
argument_list|(
literal|""
argument_list|,
operator|*
name|reg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'G'
case|:
comment|/* set the value of a register. */
block|{
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
init|=
name|cvmx_debug_core_context
argument_list|()
decl_stmt|;
name|uint64_t
name|regno
decl_stmt|;
specifier|volatile
name|uint64_t
modifier|*
name|reg
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
comment|/* Get the register number to write. It should be followed by                a comma */
if|if
condition|(
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|regno
argument_list|)
operator|||
operator|(
operator|*
name|buf
operator|++
operator|!=
literal|','
operator|)
operator|||
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"G packet corrupt: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
name|reg
operator|=
name|cvmx_debug_regnum_to_context_ref
argument_list|(
name|regno
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Register #%d is not valid\n"
argument_list|,
operator|(
name|int
operator|)
name|regno
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
operator|*
name|reg
operator|=
name|value
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
comment|/* Memory read. mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
block|{
name|uint64_t
name|addr
decl_stmt|,
name|i
decl_stmt|,
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|reply
decl_stmt|;
comment|/* Get the memory address, a comma, and the length */
if|if
condition|(
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|addr
argument_list|)
operator|||
operator|(
operator|*
name|buf
operator|++
operator|!=
literal|','
operator|)
operator|||
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"m packet corrupt: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
if|if
condition|(
name|length
operator|>=
literal|1024
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"m packet length out of range: %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
name|reply
operator|=
name|__builtin_alloca
argument_list|(
name|length
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|long
operator|)
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|/* Probe memory.  If not accessible fail.   */
name|unsigned
name|char
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|cvmx_debug_probe_load
argument_list|(
operator|&
name|ptr
index|[
name|i
index|]
argument_list|,
operator|&
name|t
argument_list|)
condition|)
goto|goto
name|error_packet
goto|;
name|cvmx_debug_int8_to_strhex
argument_list|(
operator|&
name|reply
index|[
name|i
operator|*
literal|2
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|cvmx_debug_putpacket_noformat
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
comment|/* Memory write. MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
block|{
name|uint64_t
name|addr
decl_stmt|,
name|i
decl_stmt|,
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|addr
argument_list|)
operator|||
operator|*
name|buf
operator|++
operator|!=
literal|','
operator|||
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|length
argument_list|)
operator|||
operator|*
name|buf
operator|++
operator|!=
literal|':'
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"M packet corrupt: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
name|ptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|long
operator|)
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|n
operator|=
name|cvmx_debug_hex
argument_list|(
name|buf
index|[
name|i
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|n1
operator|=
name|cvmx_debug_hex
argument_list|(
name|buf
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|n
operator|<<
literal|4
operator|)
operator||
name|n1
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|||
name|n1
operator|==
operator|-
literal|1
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"M packet corrupt: %s\n"
argument_list|,
operator|&
name|buf
index|[
name|i
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
comment|/* Probe memory.  If not accessible fail.   */
if|if
condition|(
operator|!
name|cvmx_debug_probe_store
argument_list|(
operator|&
name|ptr
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"M cannot write: %p\n"
argument_list|,
operator|&
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
name|ptr
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|cvmx_debug_putpacket_noformat
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* Set/get performance counter events. e[1234]XX..X: [01]                       is the performance counter to set X is the performance                       event.  [34] is to get the same thing.  */
block|{
name|uint64_t
name|perf_event
init|=
literal|0
decl_stmt|;
name|char
name|encoded_counter
init|=
operator|*
name|buf
operator|++
decl_stmt|;
name|uint64_t
name|counter
decl_stmt|;
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
init|=
name|cvmx_debug_core_context
argument_list|()
decl_stmt|;
comment|/* Ignore errors from the packet. */
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|perf_event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|encoded_counter
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* Set performance counter0 event. */
case|case
literal|'2'
case|:
comment|/* Set performance counter1 event. */
name|counter
operator|=
name|encoded_counter
operator|-
literal|'1'
expr_stmt|;
name|context
operator|->
name|cop0
operator|.
name|perfval
index|[
name|counter
index|]
operator|=
literal|0
expr_stmt|;
name|cvmx_debug_set_perf_control_reg
argument_list|(
name|context
argument_list|,
name|perf_event
argument_list|,
name|counter
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
comment|/* Get performance counter0 event. */
case|case
literal|'4'
case|:
comment|/* Get performance counter1 event. */
block|{
name|cvmx_core_perf_control_t
name|c
decl_stmt|;
name|char
name|outpacket
index|[
literal|16
operator|*
literal|2
operator|+
literal|2
index|]
decl_stmt|;
name|counter
operator|=
name|encoded_counter
operator|-
literal|'3'
expr_stmt|;
comment|/* Pass performance counter0 event and counter to                        the debugger.  */
name|c
operator|.
name|u32
operator|=
name|context
operator|->
name|cop0
operator|.
name|perfctrl
index|[
name|counter
index|]
expr_stmt|;
name|cvmx_debug_int64_to_strhex
argument_list|(
name|outpacket
argument_list|,
name|context
operator|->
name|cop0
operator|.
name|perfval
index|[
name|counter
index|]
argument_list|)
expr_stmt|;
name|outpacket
index|[
literal|16
index|]
operator|=
literal|','
expr_stmt|;
name|cvmx_debug_int64_to_strhex
argument_list|(
operator|&
name|outpacket
index|[
literal|17
index|]
argument_list|,
name|c
operator|.
name|s
operator|.
name|event
argument_list|)
expr_stmt|;
name|outpacket
index|[
literal|33
index|]
operator|=
literal|0
expr_stmt|;
name|cvmx_debug_putpacket_noformat
argument_list|(
name|outpacket
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
break|break;
if|#
directive|if
literal|0
block|case 't':
comment|/* Return the trace buffer read data register contents. */
block|{             uint64_t tra_data;             uint64_t tra_ctl;             char tmp[64];
comment|/* If trace buffer is disabled no trace data information is available. */
block|if ((tra_ctl& 0x1) == 0)             {                 cvmx_debug_putpacket_noformat("!Trace buffer not enabled\n");                 cvmx_debug_putpacket_noformat("t");             }             else             {                 cvmx_debug_putpacket_noformat("!Trace buffer is enabled\n");                 tra_data = cvmx_read_csr(OCTEON_TRA_READ_DATA);                 mem2hex (&tra_data, tmp, 8);                 strcpy (debug_output_buffer, "t");                 strcat (debug_output_buffer, tmp);                 cvmx_debug_putpacket_noformat(debug_output_buffer);             }         }         break;
endif|#
directive|endif
case|case
literal|'Z'
case|:
comment|/* Insert hardware breakpoint: Z[di]NN..N,AA.A, [di] data or                      instruction, NN..Nth at address AA..A */
block|{
enum|enum
name|type
block|{
name|WP_LOAD
init|=
literal|1
block|,
name|WP_STORE
init|=
literal|2
block|,
name|WP_ACCESS
init|=
literal|3
block|}
enum|;
name|uint64_t
name|num
decl_stmt|,
name|size
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|uint64_t
name|type
decl_stmt|;
name|char
name|bp_type
init|=
operator|*
name|buf
operator|++
decl_stmt|;
specifier|const
name|int
name|BE
init|=
literal|1
decl_stmt|,
name|TE
init|=
literal|4
decl_stmt|;
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
init|=
name|cvmx_debug_core_context
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|num
argument_list|)
operator|||
operator|*
name|buf
operator|++
operator|!=
literal|','
operator|||
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Z packet corrupt: %s\n"
argument_list|,
operator|&
name|packet
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
switch|switch
condition|(
name|bp_type
condition|)
block|{
case|case
literal|'i'
case|:
comment|// Instruction hardware breakpoint
if|if
condition|(
name|num
operator|>
literal|4
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Z packet corrupt: %s\n"
argument_list|,
operator|&
name|packet
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
name|context
operator|->
name|hw_ibp
operator|.
name|address
index|[
name|num
index|]
operator|=
name|addr
expr_stmt|;
name|context
operator|->
name|hw_ibp
operator|.
name|address_mask
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|hw_ibp
operator|.
name|asid
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|hw_ibp
operator|.
name|control
index|[
name|num
index|]
operator|=
name|BE
operator||
name|TE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|// Data hardware breakpoint
block|{
name|uint64_t
name|dbc
init|=
literal|0xff0
operator||
name|BE
operator||
name|TE
decl_stmt|;
name|uint64_t
name|dbm
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|4
operator|||
operator|*
name|buf
operator|++
operator|!=
literal|','
operator|||
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|size
argument_list|)
operator|||
operator|*
name|buf
operator|++
operator|!=
literal|','
operator|||
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|type
argument_list|)
operator|||
name|type
operator|>
name|WP_ACCESS
operator|||
name|type
operator|<
name|WP_LOAD
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Z packet corrupt: %s\n"
argument_list|,
operator|&
name|packet
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
comment|/* Set DBC[BE,TE,BLM]. */
name|context
operator|->
name|hw_dbp
operator|.
name|address
index|[
name|num
index|]
operator|=
name|addr
expr_stmt|;
name|context
operator|->
name|hw_dbp
operator|.
name|asid
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|dbc
operator||=
name|type
operator|==
name|WP_STORE
condition|?
literal|0x1000
else|:
name|type
operator|==
name|WP_LOAD
condition|?
literal|0x2000
else|:
literal|0
expr_stmt|;
comment|/* Mask the bits depending on the size for                     debugger to stop while accessing parts of the                     memory location.  */
name|dbm
operator|=
operator|(
name|size
operator|==
literal|8
operator|)
condition|?
literal|0x7
else|:
operator|(
operator|(
name|size
operator|==
literal|4
operator|)
condition|?
literal|3
else|:
operator|(
name|size
operator|==
literal|2
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|context
operator|->
name|hw_dbp
operator|.
name|address_mask
index|[
name|num
index|]
operator|=
name|dbm
expr_stmt|;
name|context
operator|->
name|hw_dbp
operator|.
name|control
index|[
name|num
index|]
operator|=
name|dbc
expr_stmt|;
break|break;
block|}
default|default:
name|cvmx_debug_printf
argument_list|(
literal|"Z packet corrupt: %s\n"
argument_list|,
operator|&
name|packet
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
block|}
break|break;
case|case
literal|'z'
case|:
comment|/* Remove hardware breakpoint: z[di]NN..N remove NN..Nth breakpoint.  */
block|{
name|uint64_t
name|num
decl_stmt|;
name|char
name|bp_type
init|=
operator|*
name|buf
operator|++
decl_stmt|;
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
init|=
name|cvmx_debug_core_context
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cvmx_debug_hexToLong
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|num
argument_list|)
operator|||
name|num
operator|>
literal|4
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"z packet corrupt: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
switch|switch
condition|(
name|bp_type
condition|)
block|{
case|case
literal|'i'
case|:
comment|// Instruction hardware breakpoint
name|context
operator|->
name|hw_ibp
operator|.
name|address
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|hw_ibp
operator|.
name|address_mask
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|hw_ibp
operator|.
name|asid
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|hw_ibp
operator|.
name|control
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|// Data hardware breakpoint
name|context
operator|->
name|hw_dbp
operator|.
name|address
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|hw_dbp
operator|.
name|address_mask
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|hw_dbp
operator|.
name|asid
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|hw_dbp
operator|.
name|control
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|cvmx_debug_printf
argument_list|(
literal|"z packet corrupt: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|error_packet
goto|;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* Single step. sAA..AA Step one instruction from AA..AA (optional) */
name|result
operator|=
name|COMMAND_STEP
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Continue. cAA..AA Continue at address AA..AA (optional) */
name|result
operator|=
name|COMMAND_CONTINUE
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
comment|/* Don't know. I think it is a communications sync */
comment|/* Ignoring this command */
break|break;
default|default:
name|cvmx_debug_printf
argument_list|(
literal|"Unknown debug command: %s\n"
argument_list|,
name|buf
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error_packet
label|:
name|cvmx_debug_putpacket_noformat
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|cvmx_debug_command_t
name|cvmx_debug_process_next_packet
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|packet
index|[
name|CVMX_DEBUG_MAX_REQUEST_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|cvmx_debug_comms
index|[
name|cvmx_debug_globals
operator|->
name|comm_type
index|]
operator|->
name|getpacket
argument_list|(
name|packet
argument_list|,
name|CVMX_DEBUG_MAX_REQUEST_SIZE
argument_list|)
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Request: %s\n"
argument_list|,
name|packet
argument_list|)
expr_stmt|;
return|return
name|cvmx_debug_process_packet
argument_list|(
name|packet
argument_list|)
return|;
block|}
return|return
name|COMMAND_NOP
return|;
block|}
end_function

begin_comment
comment|/* If a core isn't in the active core mask we need to start him up again. We    can only do this if the core didn't hit a breakpoint or single step. If the    core hit CVMX_CIU_DINT interrupt (generally happens when while executing    _exit() at the end of the program). Remove the core from known cores so    that when the cores in active core mask are done executing the program, the    focus will not be transfered to this core.  */
end_comment

begin_function
specifier|static
name|int
name|cvmx_debug_stop_core
parameter_list|(
name|cvmx_debug_state_t
name|state
parameter_list|,
name|unsigned
name|core
parameter_list|,
name|cvmx_debug_register_t
modifier|*
name|debug_reg
parameter_list|,
name|int
name|proxy
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cvmx_debug_active_core
argument_list|(
name|state
argument_list|,
name|core
argument_list|)
operator|&&
operator|!
name|debug_reg
operator|->
name|s
operator|.
name|dbp
operator|&&
operator|!
name|debug_reg
operator|->
name|s
operator|.
name|dss
operator|&&
operator|(
name|debug_reg
operator|->
name|s
operator|.
name|dint
operator|!=
literal|1
operator|)
condition|)
block|{
name|debug_reg
operator|->
name|s
operator|.
name|sst
operator|=
literal|0
expr_stmt|;
name|cvmx_debug_printf
argument_list|(
literal|"Core #%d not in active cores, continuing.\n"
argument_list|,
name|core
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|state
operator|.
name|core_finished
operator|&
operator|(
literal|1u
operator|<<
name|core
operator|)
operator|)
operator|&&
name|proxy
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* check to see if current exc is single-stepped and  that no other exc    was also simultaneously noticed. */
end_comment

begin_function
specifier|static
name|int
name|cvmx_debug_single_step_exc
parameter_list|(
name|cvmx_debug_register_t
modifier|*
name|debug_reg
parameter_list|)
block|{
if|if
condition|(
name|debug_reg
operator|->
name|s
operator|.
name|dss
operator|&&
operator|!
name|debug_reg
operator|->
name|s
operator|.
name|dib
operator|&&
operator|!
name|debug_reg
operator|->
name|s
operator|.
name|dbp
operator|&&
operator|!
name|debug_reg
operator|->
name|s
operator|.
name|ddbs
operator|&&
operator|!
name|debug_reg
operator|->
name|s
operator|.
name|ddbl
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_set_focus_core
parameter_list|(
name|cvmx_debug_state_t
modifier|*
name|state
parameter_list|,
name|int
name|core
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|ever_been_in_debug
condition|)
name|cvmx_debug_putcorepacket
argument_list|(
literal|"taking focus."
argument_list|,
name|core
argument_list|)
expr_stmt|;
name|cvmx_debug_comms
index|[
name|cvmx_debug_globals
operator|->
name|comm_type
index|]
operator|->
name|change_core
argument_list|(
name|state
operator|->
name|focus_core
argument_list|,
name|core
argument_list|)
expr_stmt|;
name|state
operator|->
name|focus_core
operator|=
name|core
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_may_elect_as_focus_core
parameter_list|(
name|cvmx_debug_state_t
modifier|*
name|state
parameter_list|,
name|int
name|core
parameter_list|,
name|cvmx_debug_register_t
modifier|*
name|debug_reg
parameter_list|)
block|{
comment|/* If another core has already elected itself as the focus core, we're late.  */
if|if
condition|(
name|state
operator|->
name|handler_cores
operator|&
operator|(
literal|1u
operator|<<
name|state
operator|->
name|focus_core
operator|)
condition|)
return|return;
comment|/* If we hit a breakpoint, elect ourselves.  */
if|if
condition|(
name|debug_reg
operator|->
name|s
operator|.
name|dib
operator|||
name|debug_reg
operator|->
name|s
operator|.
name|dbp
operator|||
name|debug_reg
operator|->
name|s
operator|.
name|ddbs
operator|||
name|debug_reg
operator|->
name|s
operator|.
name|ddbl
condition|)
name|cvmx_debug_set_focus_core
argument_list|(
name|state
argument_list|,
name|core
argument_list|)
expr_stmt|;
comment|/* It is possible the focus core has completed processing and exited the        program. When this happens the focus core will not be in        known_cores. If this is the case we need to elect a new focus. */
if|if
condition|(
operator|(
name|state
operator|->
name|known_cores
operator|&
operator|(
literal|1u
operator|<<
name|state
operator|->
name|focus_core
operator|)
operator|)
operator|==
literal|0
condition|)
name|cvmx_debug_set_focus_core
argument_list|(
name|state
argument_list|,
name|core
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_send_stop_reason
parameter_list|(
name|cvmx_debug_register_t
modifier|*
name|debug_reg
parameter_list|,
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
parameter_list|)
block|{
comment|/* Handle Debug Data Breakpoint Store/Load Exception. */
if|if
condition|(
name|debug_reg
operator|->
name|s
operator|.
name|ddbs
operator|||
name|debug_reg
operator|->
name|s
operator|.
name|ddbl
condition|)
name|cvmx_debug_putpacket_hexint
argument_list|(
literal|"T8:"
argument_list|,
operator|(
name|int
operator|)
name|context
operator|->
name|hw_dbp
operator|.
name|status
argument_list|)
expr_stmt|;
else|else
name|cvmx_debug_putpacket_noformat
argument_list|(
literal|"T9"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_clear_status
parameter_list|(
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
parameter_list|)
block|{
comment|/* SW needs to clear the BreakStatus bits after a watchpoint is hit or on        reset.  */
name|context
operator|->
name|hw_dbp
operator|.
name|status
operator|&=
operator|~
literal|0x3fff
expr_stmt|;
comment|/* Clear MCD0, which is write-1-to-clear.  */
name|context
operator|->
name|cop0
operator|.
name|multicoredebug
operator||=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_sync_up_cores
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* NOTE this reads directly from the state array for speed reasons        and we don't change the array. */
do|do
block|{
asm|asm("": : : "memory");
block|}
do|while
condition|(
name|cvmx_debug_globals
operator|->
name|state
index|[
name|offsetof
argument_list|(
name|cvmx_debug_state_t
argument_list|,
name|step_all
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
index|]
operator|&&
name|cvmx_debug_globals
operator|->
name|state
index|[
name|offsetof
argument_list|(
name|cvmx_debug_state_t
argument_list|,
name|handler_cores
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
index|]
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Delay the focus core a little if it is likely another core needs to steal    focus. Once we enter the main loop focus can't be stolen */
end_comment

begin_function
specifier|static
name|void
name|cvmx_debug_delay_focus_core
parameter_list|(
name|cvmx_debug_state_t
name|state
parameter_list|,
name|unsigned
name|core
parameter_list|,
name|cvmx_debug_register_t
modifier|*
name|debug_reg
parameter_list|)
block|{
specifier|volatile
name|int
name|i
decl_stmt|;
if|if
condition|(
name|debug_reg
operator|->
name|s
operator|.
name|dss
operator|||
name|debug_reg
operator|->
name|s
operator|.
name|dbp
operator|||
name|core
operator|!=
name|state
operator|.
name|focus_core
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2400
condition|;
name|i
operator|++
control|)
block|{
asm|asm
specifier|volatile
asm|(".set push		\n\t"                       ".set noreorder		\n\t"                       "nop			\n\t"                       "nop			\n\t"                       "nop			\n\t"                       "nop			\n\t"                       ".set pop");
comment|/* Spin giving the breakpoint core time to steal focus */
block|}
block|}
end_function

begin_comment
comment|/* If this core was single-stepping in a group,&& it was not the last focus-core,&& last focus-core happens to be inside an ISR, blocking focus-switch    then burn some cycles, to avoid unnecessary focus toggles. */
end_comment

begin_function
specifier|static
name|void
name|cvmx_debug_delay_isr_core
parameter_list|(
name|unsigned
name|core
parameter_list|,
name|uint32_t
name|depc
parameter_list|,
name|int
name|single_stepped_exc_only
parameter_list|,
name|cvmx_debug_state_t
name|state
parameter_list|)
block|{
specifier|volatile
name|uint64_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|single_stepped_exc_only
operator|||
name|state
operator|.
name|step_isr
operator|||
name|core
operator|==
name|state
operator|.
name|focus_core
operator|||
name|state
operator|.
name|focus_switch
condition|)
return|return;
name|cvmx_debug_printf
argument_list|(
literal|"Core #%u spinning for focus at 0x%x\n"
argument_list|,
name|core
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|depc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ISR_DELAY_COUNTER
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
comment|/* Spin giving the focus core time to service ISR */
comment|/* But cut short the loop, if we can.  Shrink down i, only once. */
if|if
condition|(
name|i
operator|>
literal|600000
operator|&&
name|state
operator|.
name|focus_switch
condition|)
name|i
operator|=
literal|500000
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cvmx_debug_perform_proxy
parameter_list|(
name|cvmx_debug_register_t
modifier|*
name|debug_reg
parameter_list|,
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
parameter_list|)
block|{
name|unsigned
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|cvmx_debug_state_t
name|state
init|=
name|cvmx_debug_get_state
argument_list|()
decl_stmt|;
name|cvmx_debug_command_t
name|command
init|=
name|COMMAND_NOP
decl_stmt|;
name|int
name|single_stepped_exc_only
init|=
name|cvmx_debug_single_step_exc
argument_list|(
name|debug_reg
argument_list|)
decl_stmt|;
comment|/* All cores should respect the focus core if it has to        stop focus switching while servicing an interrupt.        If the system is single-stepping, then the following        code path is valid. If the current core tripped on a        break-point or some other error while going through        an ISR, then we shouldn't be returning unconditionally.        In that case (non-single-step case) we must enter        the debugger exception stub fully. */
if|if
condition|(
operator|!
name|state
operator|.
name|step_isr
operator|&&
operator|(
name|cvmx_interrupt_in_isr
operator|||
operator|(
name|context
operator|->
name|cop0
operator|.
name|status
operator|&
literal|0x2ULL
operator|)
operator|)
operator|&&
name|single_stepped_exc_only
condition|)
block|{
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
comment|/* If this is the focus core, switch off focus switching            till ISR_DELAY_COUNTER. This will let focus core            keep the focus until the ISR is completed. */
if|if
condition|(
name|state
operator|.
name|focus_switch
operator|&&
name|core
operator|==
name|state
operator|.
name|focus_core
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Core #%u stopped focus stealing at 0x%llx\n"
argument_list|,
name|core
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|context
operator|->
name|cop0
operator|.
name|depc
argument_list|)
expr_stmt|;
name|state
operator|.
name|focus_switch
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Alow other cores to steal focus.            Focus core has completed ISR. */
if|if
condition|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|__SIZE_TYPE__
operator|)
name|context
operator|->
name|cop0
operator|.
name|depc
operator|)
operator|==
name|ERET_INSN
operator|&&
name|core
operator|==
name|state
operator|.
name|focus_core
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Core #%u resumed focus stealing at 0x%llx\n"
argument_list|,
name|core
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|context
operator|->
name|cop0
operator|.
name|depc
argument_list|)
expr_stmt|;
name|state
operator|.
name|focus_switch
operator|=
literal|1
expr_stmt|;
block|}
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cvmx_debug_printf
argument_list|(
literal|"Core #%u resumed skipping isr.\n"
argument_list|,
name|core
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Delay the focus core a little if it is likely another core needs to        steal focus. Once we enter the main loop focus can't be stolen */
name|cvmx_debug_delay_focus_core
argument_list|(
name|state
argument_list|,
name|core
argument_list|,
name|debug_reg
argument_list|)
expr_stmt|;
name|cvmx_debug_delay_isr_core
argument_list|(
name|core
argument_list|,
name|context
operator|->
name|cop0
operator|.
name|depc
argument_list|,
name|single_stepped_exc_only
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* The following section of code does two critical things. First, it        populates the handler_cores bitmask of all cores in the exception        handler. Only one core at a time can update this field. Second it        changes the focus core if needed. */
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Core #%d stopped\n"
argument_list|,
name|core
argument_list|)
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
name|state
operator|.
name|handler_cores
operator||=
operator|(
literal|1u
operator|<<
name|core
operator|)
expr_stmt|;
name|cvmx_debug_may_elect_as_focus_core
argument_list|(
operator|&
name|state
argument_list|,
name|core
argument_list|,
name|debug_reg
argument_list|)
expr_stmt|;
comment|/* Push all updates before exiting the critical section */
name|state
operator|.
name|focus_switch
operator|=
literal|1
expr_stmt|;
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__cvmx_debug_in_focus
argument_list|(
name|state
argument_list|,
name|core
argument_list|)
condition|)
name|cvmx_debug_send_stop_reason
argument_list|(
name|debug_reg
argument_list|,
name|context
argument_list|)
expr_stmt|;
do|do
block|{
name|unsigned
name|oldfocus
init|=
name|state
operator|.
name|focus_core
decl_stmt|;
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
comment|/* Note the focus core can change in this loop. */
if|if
condition|(
name|__cvmx_debug_in_focus
argument_list|(
name|state
argument_list|,
name|core
argument_list|)
condition|)
block|{
comment|/* If the focus has changed and the old focus has exited, then send a signal                that we should stop if step_all is off.  */
if|if
condition|(
name|oldfocus
operator|!=
name|state
operator|.
name|focus_core
operator|&&
operator|(
operator|(
literal|1u
operator|<<
name|oldfocus
operator|)
operator|&
name|state
operator|.
name|core_finished
operator|)
operator|&&
operator|!
name|state
operator|.
name|step_all
condition|)
name|cvmx_debug_send_stop_reason
argument_list|(
name|debug_reg
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|command
operator|=
name|cvmx_debug_process_next_packet
argument_list|()
expr_stmt|;
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
comment|/* When resuming let the other cores resume as well with                step-all.  */
if|if
condition|(
name|command
operator|!=
name|COMMAND_NOP
operator|&&
name|state
operator|.
name|step_all
condition|)
block|{
name|state
operator|.
name|command
operator|=
name|command
expr_stmt|;
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* When steping all cores, update the non focus core's command too. */
elseif|else
if|if
condition|(
name|state
operator|.
name|step_all
condition|)
name|command
operator|=
name|state
operator|.
name|command
expr_stmt|;
comment|/* If we did not get a command and the communication changed return,            we are changing the communications. */
if|if
condition|(
name|command
operator|==
name|COMMAND_NOP
operator|&&
name|cvmx_debug_globals
operator|->
name|comm_changed
condition|)
block|{
comment|/* FIXME, this should a sync not based on cvmx_coremask_barrier_sync.  */
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
comment|/* Sync up.  */
name|cvmx_coremask_barrier_sync
argument_list|(
name|state
operator|.
name|handler_cores
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
block|}
do|while
condition|(
name|command
operator|==
name|COMMAND_NOP
condition|)
do|;
name|debug_reg
operator|->
name|s
operator|.
name|sst
operator|=
name|command
operator|==
name|COMMAND_STEP
expr_stmt|;
name|cvmx_debug_printf
argument_list|(
literal|"Core #%d running\n"
argument_list|,
name|core
argument_list|)
expr_stmt|;
block|{
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
name|state
operator|.
name|handler_cores
operator|^=
operator|(
literal|1u
operator|<<
name|core
operator|)
expr_stmt|;
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|cvmx_debug_sync_up_cores
argument_list|()
expr_stmt|;
comment|/* Now that all cores are out, reset the command.  */
if|if
condition|(
name|__cvmx_debug_in_focus
argument_list|(
name|state
argument_list|,
name|core
argument_list|)
condition|)
block|{
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
name|state
operator|.
name|command
operator|=
name|COMMAND_NOP
expr_stmt|;
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_save_core_context
parameter_list|(
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
parameter_list|,
name|uint64_t
name|hi
parameter_list|,
name|uint64_t
name|lo
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|cvmx_debug_memcpy_align
argument_list|(
operator|(
name|char
operator|*
operator|)
name|context
operator|->
name|regs
argument_list|,
name|__cvmx_debug_save_regs_area
argument_list|,
sizeof|sizeof
argument_list|(
name|context
operator|->
name|regs
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|lo
operator|=
name|lo
expr_stmt|;
name|context
operator|->
name|hi
operator|=
name|hi
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|index
argument_list|,
name|COP0_INDEX
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|entrylo
index|[
literal|0
index|]
argument_list|,
name|COP0_ENTRYLO0
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|entrylo
index|[
literal|1
index|]
argument_list|,
name|COP0_ENTRYLO1
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|entryhi
argument_list|,
name|COP0_ENTRYHI
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|pagemask
argument_list|,
name|COP0_PAGEMASK
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|status
argument_list|,
name|COP0_STATUS
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|cause
argument_list|,
name|COP0_CAUSE
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|debug
argument_list|,
name|COP0_DEBUG
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|multicoredebug
argument_list|,
name|COP0_MULTICOREDEBUG
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|perfval
index|[
literal|0
index|]
argument_list|,
name|COP0_PERFVALUE0
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|perfval
index|[
literal|1
index|]
argument_list|,
name|COP0_PERFVALUE1
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|perfctrl
index|[
literal|0
index|]
argument_list|,
name|COP0_PERFCONTROL0
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|perfctrl
index|[
literal|1
index|]
argument_list|,
name|COP0_PERFCONTROL1
argument_list|)
expr_stmt|;
comment|/* Save DEPC and DESAVE since debug-mode exceptions (see        debug_probe_{load,store}) can clobber these.  */
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|depc
argument_list|,
name|COP0_DEPC
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|desave
argument_list|,
name|COP0_DESAVE
argument_list|)
expr_stmt|;
name|context
operator|->
name|hw_ibp
operator|.
name|status
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_STATUS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|context
operator|->
name|hw_ibp
operator|.
name|address
index|[
name|i
index|]
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|hw_ibp
operator|.
name|address_mask
index|[
name|i
index|]
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_ADDRESS_MASK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|hw_ibp
operator|.
name|asid
index|[
name|i
index|]
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_ASID
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|hw_ibp
operator|.
name|control
index|[
name|i
index|]
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_CONTROL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|->
name|hw_dbp
operator|.
name|status
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_STATUS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|context
operator|->
name|hw_dbp
operator|.
name|address
index|[
name|i
index|]
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|hw_dbp
operator|.
name|address_mask
index|[
name|i
index|]
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_ADDRESS_MASK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|hw_dbp
operator|.
name|asid
index|[
name|i
index|]
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_ASID
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|hw_dbp
operator|.
name|control
index|[
name|i
index|]
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_CONTROL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cvmx_debug_globals
operator|->
name|tlb_entries
condition|;
name|i
operator|++
control|)
block|{
name|CVMX_MT_COP0
argument_list|(
name|i
argument_list|,
name|COP0_INDEX
argument_list|)
expr_stmt|;
asm|asm
specifier|volatile
asm|("tlbr");
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|tlbs
index|[
name|i
index|]
operator|.
name|entrylo
index|[
literal|0
index|]
argument_list|,
name|COP0_ENTRYLO0
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|tlbs
index|[
name|i
index|]
operator|.
name|entrylo
index|[
literal|1
index|]
argument_list|,
name|COP0_ENTRYLO1
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|tlbs
index|[
name|i
index|]
operator|.
name|entryhi
argument_list|,
name|COP0_ENTRYHI
argument_list|)
expr_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|context
operator|->
name|tlbs
index|[
name|i
index|]
operator|.
name|pagemask
argument_list|,
name|COP0_PAGEMASK
argument_list|)
expr_stmt|;
block|}
name|CVMX_SYNCW
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_restore_core_context
parameter_list|(
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
parameter_list|)
block|{
name|uint64_t
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cvmx_debug_memcpy_align
argument_list|(
name|__cvmx_debug_save_regs_area
argument_list|,
operator|(
name|char
operator|*
operator|)
name|context
operator|->
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|context
operator|->
name|regs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't change the TLB so no need to restore it.  */
name|cvmx_write_csr
argument_list|(
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_STATUS
argument_list|,
name|context
operator|->
name|hw_dbp
operator|.
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|context
operator|->
name|hw_dbp
operator|.
name|address
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_ADDRESS_MASK
argument_list|(
name|i
argument_list|)
argument_list|,
name|context
operator|->
name|hw_dbp
operator|.
name|address_mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_ASID
argument_list|(
name|i
argument_list|)
argument_list|,
name|context
operator|->
name|hw_dbp
operator|.
name|asid
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DEBUG_HW_DATA_BREAKPOINT_CONTROL
argument_list|(
name|i
argument_list|)
argument_list|,
name|context
operator|->
name|hw_dbp
operator|.
name|control
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_STATUS
argument_list|,
name|context
operator|->
name|hw_ibp
operator|.
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_ADDRESS
argument_list|(
name|i
argument_list|)
argument_list|,
name|context
operator|->
name|hw_ibp
operator|.
name|address
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_ADDRESS_MASK
argument_list|(
name|i
argument_list|)
argument_list|,
name|context
operator|->
name|hw_ibp
operator|.
name|address_mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_ASID
argument_list|(
name|i
argument_list|)
argument_list|,
name|context
operator|->
name|hw_ibp
operator|.
name|asid
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DEBUG_HW_INSTRUCTION_BREAKPOINT_CONTROL
argument_list|(
name|i
argument_list|)
argument_list|,
name|context
operator|->
name|hw_ibp
operator|.
name|control
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|index
argument_list|,
name|COP0_INDEX
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|entrylo
index|[
literal|0
index|]
argument_list|,
name|COP0_ENTRYLO0
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|entrylo
index|[
literal|1
index|]
argument_list|,
name|COP0_ENTRYLO1
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|entryhi
argument_list|,
name|COP0_ENTRYHI
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|pagemask
argument_list|,
name|COP0_PAGEMASK
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|status
argument_list|,
name|COP0_STATUS
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|cause
argument_list|,
name|COP0_CAUSE
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|debug
argument_list|,
name|COP0_DEBUG
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|multicoredebug
argument_list|,
name|COP0_MULTICOREDEBUG
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|perfval
index|[
literal|0
index|]
argument_list|,
name|COP0_PERFVALUE0
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|perfval
index|[
literal|1
index|]
argument_list|,
name|COP0_PERFVALUE1
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|perfctrl
index|[
literal|0
index|]
argument_list|,
name|COP0_PERFCONTROL0
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|perfctrl
index|[
literal|1
index|]
argument_list|,
name|COP0_PERFCONTROL1
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|depc
argument_list|,
name|COP0_DEPC
argument_list|)
expr_stmt|;
name|CVMX_MT_COP0
argument_list|(
name|context
operator|->
name|cop0
operator|.
name|desave
argument_list|,
name|COP0_DESAVE
argument_list|)
expr_stmt|;
name|lo
operator|=
name|context
operator|->
name|lo
expr_stmt|;
name|hi
operator|=
name|context
operator|->
name|hi
expr_stmt|;
asm|asm("mtlo %0" :: "r"(lo));
asm|asm("mthi %0" :: "r"(hi));
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|cvmx_debug_print_cause
parameter_list|(
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CVMX_DEBUG_LOGGING
condition|)
return|return;
if|if
condition|(
name|context
operator|->
name|cop0
operator|.
name|multicoredebug
operator|&
literal|1
condition|)
name|cvmx_dprintf
argument_list|(
literal|"MCD0 was pulsed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cop0
operator|.
name|multicoredebug
operator|&
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"Exception %lld in Debug Mode\n"
argument_list|,
call|(
name|long
name|long
call|)
argument_list|(
operator|(
name|context
operator|->
name|cop0
operator|.
name|debug
operator|>>
literal|10
operator|)
operator|&
literal|0x1f
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cop0
operator|.
name|debug
operator|&
operator|(
literal|1
operator|<<
literal|19
operator|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"DDBSImpr\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cop0
operator|.
name|debug
operator|&
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"DDBLImpr\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cop0
operator|.
name|debug
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"DINT\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cop0
operator|.
name|debug
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"Debug Instruction Breakpoint (DIB) exception\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cop0
operator|.
name|debug
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"Debug Date Break Store (DDBS) exception\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cop0
operator|.
name|debug
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"Debug Date Break Load (DDBL) exception\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cop0
operator|.
name|debug
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"Debug Breakpoint (DBp) exception\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cop0
operator|.
name|debug
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"Debug Single Step (DSS) exception\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__cvmx_debug_handler_stage3
parameter_list|(
name|uint64_t
name|lo
parameter_list|,
name|uint64_t
name|hi
parameter_list|)
block|{
specifier|volatile
name|cvmx_debug_core_context_t
modifier|*
name|context
decl_stmt|;
name|int
name|comms_changed
init|=
literal|0
decl_stmt|;
name|cvmx_debug_printf
argument_list|(
literal|"Entering debug exception handler\n"
argument_list|)
expr_stmt|;
name|cvmx_debug_printf
argument_list|(
literal|"Debug named block at %p\n"
argument_list|,
name|cvmx_debug_globals
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_debug_mode_exception_occured
condition|)
block|{
name|uint64_t
name|depc
decl_stmt|;
name|CVMX_MF_COP0
argument_list|(
name|depc
argument_list|,
name|COP0_DEPC
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"Unexpected debug-mode exception occured at 0x%llx, 0x%llx spinning\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|depc
argument_list|,
call|(
name|long
name|long
call|)
argument_list|(
name|__cvmx_debug_mode_exception_occured
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
name|panic
argument_list|(
literal|"Unexpected debug-mode exception occured at 0x%llx, 0x%llx\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|depc
argument_list|,
call|(
name|long
name|long
call|)
argument_list|(
name|__cvmx_debug_mode_exception_occured
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
empty_stmt|;
block|}
name|context
operator|=
name|cvmx_debug_core_context
argument_list|()
expr_stmt|;
name|cvmx_debug_save_core_context
argument_list|(
name|context
argument_list|,
name|hi
argument_list|,
name|lo
argument_list|)
expr_stmt|;
block|{
name|cvmx_debug_state_t
name|state
decl_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
name|state
operator|.
name|ever_been_in_debug
operator|=
literal|1
expr_stmt|;
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|cvmx_debug_print_cause
argument_list|(
name|context
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|needs_proxy
decl_stmt|;
name|comms_changed
operator|=
literal|0
expr_stmt|;
comment|/* If the communication changes, change it. */
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_debug_globals
operator|->
name|comm_changed
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Communication changed: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_debug_globals
operator|->
name|comm_changed
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_debug_globals
operator|->
name|comm_changed
operator|>
name|COMM_SIZE
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Unknown communication spinning: %lld> %d.\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|cvmx_debug_globals
operator|->
name|comm_changed
argument_list|,
call|(
name|int
call|)
argument_list|(
name|COMM_SIZE
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
name|panic
argument_list|(
literal|"Unknown communication.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
empty_stmt|;
block|}
name|cvmx_debug_globals
operator|->
name|comm_type
operator|=
name|cvmx_debug_globals
operator|->
name|comm_changed
operator|-
literal|1
expr_stmt|;
name|cvmx_debug_globals
operator|->
name|comm_changed
operator|=
literal|0
expr_stmt|;
block|}
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
name|needs_proxy
operator|=
name|cvmx_debug_comms
index|[
name|cvmx_debug_globals
operator|->
name|comm_type
index|]
operator|->
name|needs_proxy
expr_stmt|;
block|{
name|cvmx_debug_register_t
name|debug_reg
decl_stmt|;
name|cvmx_debug_state_t
name|state
decl_stmt|;
name|unsigned
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
name|debug_reg
operator|.
name|u64
operator|=
name|context
operator|->
name|cop0
operator|.
name|debug
expr_stmt|;
comment|/* All cores stop on any exception.  See if we want nothing from this and                it should resume.  This needs to be done for non proxy based debugging                so that some non active-cores can control the other cores.  */
if|if
condition|(
operator|!
name|cvmx_debug_stop_core
argument_list|(
name|state
argument_list|,
name|core
argument_list|,
operator|&
name|debug_reg
argument_list|,
name|needs_proxy
argument_list|)
condition|)
block|{
name|context
operator|->
name|cop0
operator|.
name|debug
operator|=
name|debug_reg
operator|.
name|u64
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|needs_proxy
condition|)
block|{
name|cvmx_debug_register_t
name|debug_reg
decl_stmt|;
name|debug_reg
operator|.
name|u64
operator|=
name|context
operator|->
name|cop0
operator|.
name|debug
expr_stmt|;
name|cvmx_debug_printf
argument_list|(
literal|"Starting to proxy\n"
argument_list|)
expr_stmt|;
name|comms_changed
operator|=
name|cvmx_debug_perform_proxy
argument_list|(
operator|&
name|debug_reg
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|context
operator|->
name|cop0
operator|.
name|debug
operator|=
name|debug_reg
operator|.
name|u64
expr_stmt|;
block|}
else|else
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Starting to wait for remote host\n"
argument_list|)
expr_stmt|;
name|cvmx_debug_comms
index|[
name|cvmx_debug_globals
operator|->
name|comm_type
index|]
operator|->
name|wait_for_resume
argument_list|(
name|context
argument_list|,
name|cvmx_debug_get_state
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|comms_changed
condition|)
do|;
name|cvmx_debug_clear_status
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|cvmx_debug_restore_core_context
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|cvmx_debug_printf
argument_list|(
literal|"Exiting debug exception handler\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cvmx_debug_trigger_exception
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Set CVMX_CIU_DINT to enter debug exception handler.  */
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_DINT
argument_list|,
literal|1u
operator|<<
name|cvmx_get_core_num
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Perform an immediate read after every write to an RSL register to force      the write to complete. It doesn't matter what RSL read we do, so we      choose CVMX_MIO_BOOT_BIST_STAT because it is fast and harmless */
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_BOOT_BIST_STAT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Inform debugger about the end of the program. This is  * called from crt0 after all the C cleanup code finishes.  * Our current stack is the C one, not the debug exception  * stack. */
end_comment

begin_function
name|void
name|cvmx_debug_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|coreid
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|cvmx_debug_state_t
name|state
decl_stmt|;
if|if
condition|(
operator|!
name|cvmx_debug_globals
condition|)
return|return;
name|cvmx_debug_printf
argument_list|(
literal|"Debug _exit reached!, core %d, cvmx_debug_globals = %p\n"
argument_list|,
name|coreid
argument_list|,
name|cvmx_debug_globals
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
name|state
operator|=
name|cvmx_debug_get_state
argument_list|()
expr_stmt|;
name|state
operator|.
name|known_cores
operator|^=
operator|(
literal|1u
operator|<<
name|coreid
operator|)
expr_stmt|;
name|state
operator|.
name|core_finished
operator||=
operator|(
literal|1u
operator|<<
name|coreid
operator|)
expr_stmt|;
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|/* Tell the user the core has finished. */
if|if
condition|(
name|state
operator|.
name|ever_been_in_debug
condition|)
name|cvmx_debug_putcorepacket
argument_list|(
literal|"finished."
argument_list|,
name|coreid
argument_list|)
expr_stmt|;
comment|/* Notify the debugger if all cores have completed the program */
if|if
condition|(
operator|(
name|cvmx_debug_core_mask
argument_list|()
operator|&
name|state
operator|.
name|core_finished
operator|)
operator|==
name|cvmx_debug_core_mask
argument_list|()
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"All cores done!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|ever_been_in_debug
condition|)
name|cvmx_debug_putpacket_noformat
argument_list|(
literal|"D0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|.
name|focus_core
operator|==
name|coreid
operator|&&
name|state
operator|.
name|known_cores
operator|!=
literal|0
condition|)
block|{
comment|/* Loop through cores looking for someone to handle interrupts.            Since we already check that known_cores is non zero, this            should always find a core */
name|unsigned
name|newcore
decl_stmt|;
for|for
control|(
name|newcore
operator|=
literal|0
init|;
name|newcore
operator|<
name|CVMX_MAX_CORES
condition|;
name|newcore
operator|++
control|)
block|{
if|if
condition|(
name|state
operator|.
name|known_cores
operator|&
operator|(
literal|1u
operator|<<
name|newcore
operator|)
condition|)
block|{
name|cvmx_debug_printf
argument_list|(
literal|"Routing uart interrupts to Core #%u.\n"
argument_list|,
name|newcore
argument_list|)
expr_stmt|;
name|cvmx_debug_set_focus_core
argument_list|(
operator|&
name|state
argument_list|,
name|newcore
argument_list|)
expr_stmt|;
name|cvmx_debug_update_state
argument_list|(
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_debug_globals
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* If we ever been in the debug, report to it that we have exited the core. */
if|if
condition|(
name|state
operator|.
name|ever_been_in_debug
condition|)
name|cvmx_debug_trigger_exception
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

