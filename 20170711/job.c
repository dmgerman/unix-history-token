begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: job.c,v 1.190 2017/04/16 21:23:43 riastradh Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAKE_NATIVE
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD: job.c,v 1.190 2017/04/16 21:23:43 riastradh Exp $"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)job.c	8.2 (Berkeley) 3/19/94";
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: job.c,v 1.190 2017/04/16 21:23:43 riastradh Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * job.c --  *	handle the creation etc. of our child processes.  *  * Interface:  *	Job_Make  	    	Start the creation of the given target.  *  *	Job_CatchChildren   	Check for and handle the termination of any  *	    	  	    	children. This must be called reasonably  *	    	  	    	frequently to keep the whole make going at  *	    	  	    	a decent clip, since job table entries aren't  *	    	  	    	removed until their process is caught this way.  *  *	Job_CatchOutput	    	Print any output our children have produced.  *	    	  	    	Should also be called fairly frequently to  *	    	  	    	keep the user informed of what's going on.  *	    	  	    	If no output is waiting, it will block for  *	    	  	    	a time given by the SEL_* constants, below,  *	    	  	    	or until output is ready.  *  *	Job_Init  	    	Called to intialize this module. in addition,  *	    	  	    	any commands attached to the .BEGIN target  *	    	  	    	are executed before this function returns.  *	    	  	    	Hence, the makefile must have been parsed  *	    	  	    	before this function is called.  *  *	Job_End  	    	Cleanup any memory used.  *  *	Job_ParseShell	    	Given the line following a .SHELL target, parse  *	    	  	    	the line as a shell specification. Returns  *	    	  	    	FAILURE if the spec was incorrect.  *  *	Job_Finish	    	Perform any final processing which needs doing.  *	    	  	    	This includes the execution of any commands  *	    	  	    	which have been/were attached to the .END  *	    	  	    	target. It should only be called when the  *	    	  	    	job table is empty.  *  *	Job_AbortAll	    	Abort all currently running jobs. It doesn't  *	    	  	    	handle output or do anything for the jobs,  *	    	  	    	just kills them. It should only be called in  *	    	  	    	an emergency, as it were.  *  *	Job_CheckCommands   	Verify that the commands for a target are  *	    	  	    	ok. Provide them if necessary and possible.  *  *	Job_Touch 	    	Update a target without really updating it.  *  *	Job_Wait  	    	Wait for all currently-running jobs to finish.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_POLL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|USE_SELECT
end_ifndef

begin_comment
comment|/* no poll.h */
end_comment

begin_define
define|#
directive|define
name|USE_SELECT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_SELECT_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_SOCKET_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"trace.h"
end_include

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_comment
comment|/*  * error handling variables  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of errors reported */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aborting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* why is the make aborting? */
end_comment

begin_define
define|#
directive|define
name|ABORT_ERROR
value|1
end_define

begin_comment
comment|/* Because of an error */
end_comment

begin_define
define|#
directive|define
name|ABORT_INTERRUPT
value|2
end_define

begin_comment
comment|/* Because it was interrupted */
end_comment

begin_define
define|#
directive|define
name|ABORT_WAIT
value|3
end_define

begin_comment
comment|/* Waiting for jobs to finish */
end_comment

begin_define
define|#
directive|define
name|JOB_TOKENS
value|"+EI+"
end_define

begin_comment
comment|/* Token to requeue for each abort state */
end_comment

begin_comment
comment|/*  * this tracks the number of tokens currently "out" to build jobs.  */
end_comment

begin_decl_stmt
name|int
name|jobTokensRunning
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|not_parallel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if .NOT_PARALLEL */
end_comment

begin_comment
comment|/*  * XXX: Avoid SunOS bug... FILENO() is fp->_file, and file  * is a char! So when we go above 127 we turn negative!  */
end_comment

begin_define
define|#
directive|define
name|FILENO
parameter_list|(
name|a
parameter_list|)
value|((unsigned) fileno(a))
end_define

begin_comment
comment|/*  * post-make command processing. The node postCommands is really just the  * .END target but we keep it around to avoid having to search for it  * all the time.  */
end_comment

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|postCommands
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* node containing commands to execute when 				     * everything else is done */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numCommands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of commands actually printed 				     * for a target. Should this number be 				     * 0, no shell will be executed. */
end_comment

begin_comment
comment|/*  * Return values from JobStart.  */
end_comment

begin_define
define|#
directive|define
name|JOB_RUNNING
value|0
end_define

begin_comment
comment|/* Job is running */
end_comment

begin_define
define|#
directive|define
name|JOB_ERROR
value|1
end_define

begin_comment
comment|/* Error in starting the job */
end_comment

begin_define
define|#
directive|define
name|JOB_FINISHED
value|2
end_define

begin_comment
comment|/* The job is already finished */
end_comment

begin_comment
comment|/*  * Descriptions for various shells.  *  * The build environment may set DEFSHELL_INDEX to one of  * DEFSHELL_INDEX_SH, DEFSHELL_INDEX_KSH, or DEFSHELL_INDEX_CSH, to  * select one of the prefedined shells as the default shell.  *  * Alternatively, the build environment may set DEFSHELL_CUSTOM to the  * name or the full path of a sh-compatible shell, which will be used as  * the default shell.  *  * ".SHELL" lines in Makefiles can choose the default shell from the  # set defined here, or add additional shells.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEFSHELL_CUSTOM
end_ifdef

begin_define
define|#
directive|define
name|DEFSHELL_INDEX_CUSTOM
value|0
end_define

begin_define
define|#
directive|define
name|DEFSHELL_INDEX_SH
value|1
end_define

begin_define
define|#
directive|define
name|DEFSHELL_INDEX_KSH
value|2
end_define

begin_define
define|#
directive|define
name|DEFSHELL_INDEX_CSH
value|3
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !DEFSHELL_CUSTOM */
end_comment

begin_define
define|#
directive|define
name|DEFSHELL_INDEX_SH
value|0
end_define

begin_define
define|#
directive|define
name|DEFSHELL_INDEX_KSH
value|1
end_define

begin_define
define|#
directive|define
name|DEFSHELL_INDEX_CSH
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DEFSHELL_CUSTOM */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFSHELL_INDEX
end_ifndef

begin_define
define|#
directive|define
name|DEFSHELL_INDEX
value|0
end_define

begin_comment
comment|/* DEFSHELL_INDEX_CUSTOM or DEFSHELL_INDEX_SH */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DEFSHELL_INDEX */
end_comment

begin_decl_stmt
specifier|static
name|Shell
name|shells
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|DEFSHELL_CUSTOM
comment|/*      * An sh-compatible shell with a non-standard name.      *      * Keep this in sync with the "sh" description below, but avoid      * non-portable features that might not be supplied by all      * sh-compatible shells.      */
block|{
name|DEFSHELL_CUSTOM
block|,
name|FALSE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|0
block|,
name|FALSE
block|,
literal|"echo \"%s\"\n"
block|,
literal|"%s\n"
block|,
literal|"{ %s \n} || exit $?\n"
block|,
literal|"'\n'"
block|,
literal|'#'
block|,
literal|""
block|,
literal|""
block|, }
block|,
endif|#
directive|endif
comment|/* DEFSHELL_CUSTOM */
comment|/*      * SH description. Echo control is also possible and, under      * sun UNIX anyway, one can even control error checking.      */
block|{
literal|"sh"
block|,
name|FALSE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|0
block|,
name|FALSE
block|,
literal|"echo \"%s\"\n"
block|,
literal|"%s\n"
block|,
literal|"{ %s \n} || exit $?\n"
block|,
literal|"'\n'"
block|,
literal|'#'
block|,
if|#
directive|if
name|defined
argument_list|(
name|MAKE_NATIVE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
literal|"q"
block|,
else|#
directive|else
literal|""
block|,
endif|#
directive|endif
literal|""
block|, }
block|,
comment|/*      * KSH description.       */
block|{
literal|"ksh"
block|,
name|TRUE
block|,
literal|"set +v"
block|,
literal|"set -v"
block|,
literal|"set +v"
block|,
literal|6
block|,
name|FALSE
block|,
literal|"echo \"%s\"\n"
block|,
literal|"%s\n"
block|,
literal|"{ %s \n} || exit $?\n"
block|,
literal|"'\n'"
block|,
literal|'#'
block|,
literal|"v"
block|,
literal|""
block|, }
block|,
comment|/*      * CSH description. The csh can do echo control by playing      * with the setting of the 'echo' shell variable. Sadly,      * however, it is unable to do error control nicely.      */
block|{
literal|"csh"
block|,
name|TRUE
block|,
literal|"unset verbose"
block|,
literal|"set verbose"
block|,
literal|"unset verbose"
block|,
literal|10
block|,
name|FALSE
block|,
literal|"echo \"%s\"\n"
block|,
literal|"csh -c \"%s || exit 0\"\n"
block|,
literal|""
block|,
literal|"'\\\n'"
block|,
literal|'#'
block|,
literal|"v"
block|,
literal|"e"
block|, }
block|,
comment|/*      * UNKNOWN.      */
block|{
name|NULL
block|,
name|FALSE
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|FALSE
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Shell
modifier|*
name|commandShell
init|=
operator|&
name|shells
index|[
name|DEFSHELL_INDEX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this is the shell to 						   * which we pass all 						   * commands in the Makefile. 						   * It is set by the 						   * Job_ParseShell function */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|shellPath
init|=
name|NULL
decl_stmt|,
comment|/* full pathname of 						   * executable image */
modifier|*
name|shellName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last component of shell */
end_comment

begin_decl_stmt
name|char
modifier|*
name|shellErrFlag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|shellArgv
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Custom shell args */
end_comment

begin_decl_stmt
name|STATIC
name|Job
modifier|*
name|job_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The structures that describe them */
end_comment

begin_decl_stmt
name|STATIC
name|Job
modifier|*
name|job_table_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* job_table + maxJobs */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wantToken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we want a token */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lurking_children
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|make_suspended
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-zero if we've seen a SIGTSTP (etc) */
end_comment

begin_comment
comment|/*  * Set of descriptors of pipes connected to  * the output channels of children  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pollfd
modifier|*
name|fds
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Job
modifier|*
modifier|*
name|jobfds
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|watchfd
parameter_list|(
name|Job
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clearfd
parameter_list|(
name|Job
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readyfd
parameter_list|(
name|Job
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|STATIC
name|GNode
modifier|*
name|lastNode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The node for which output was most recently 				 * produced. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|targPrefix
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What we print at the start of TARG_FMT */
end_comment

begin_decl_stmt
specifier|static
name|Job
name|tokenWaitJob
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* token wait pseudo-job */
end_comment

begin_decl_stmt
specifier|static
name|Job
name|childExitJob
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* child exit pseudo-job */
end_comment

begin_define
define|#
directive|define
name|CHILD_EXIT
value|"."
end_define

begin_define
define|#
directive|define
name|DO_JOB_RESUME
value|"R"
end_define

begin_define
define|#
directive|define
name|TARG_FMT
value|"%s %s ---\n"
end_define

begin_comment
comment|/* Default format */
end_comment

begin_define
define|#
directive|define
name|MESSAGE
parameter_list|(
name|fp
parameter_list|,
name|gn
parameter_list|)
define|\
value|if (maxJobs != 1&& targPrefix&& *targPrefix) \ 	    (void)fprintf(fp, TARG_FMT, targPrefix, gn->name)
end_define

begin_decl_stmt
specifier|static
name|sigset_t
name|caught_signals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of signals we handle */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
end_if

begin_define
define|#
directive|define
name|KILLPG
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
value|kill(-(pid), (sig))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KILLPG
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
value|killpg((pid), (sig))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|JobChildSig
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobContinueSig
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Job
modifier|*
name|JobFindPid
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|JobPrintCommand
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|JobSaveCommand
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobClose
parameter_list|(
name|Job
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobExec
parameter_list|(
name|Job
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobMakeArgv
parameter_list|(
name|Job
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|JobStart
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|JobOutput
parameter_list|(
name|Job
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobDoOutput
parameter_list|(
name|Job
modifier|*
parameter_list|,
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Shell
modifier|*
name|JobMatchShell
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|JobInterrupt
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
name|MAKE_ATTR_DEAD
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|JobRestartJobs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobTokenAdd
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobSigLock
parameter_list|(
name|sigset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobSigUnlock
parameter_list|(
name|sigset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobSigReset
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MALLOC_OPTIONS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MALLOC_OPTIONS
value|"A"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
name|malloc_options
init|=
name|MALLOC_OPTIONS
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|job_table_dump
parameter_list|(
specifier|const
name|char
modifier|*
name|where
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"job table @ %s\n"
argument_list|,
name|where
argument_list|)
expr_stmt|;
for|for
control|(
name|job
operator|=
name|job_table
init|;
name|job
operator|<
name|job_table_end
condition|;
name|job
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"job %d, status %d, flags %d, pid %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|job
operator|-
name|job_table
argument_list|)
argument_list|,
name|job
operator|->
name|job_state
argument_list|,
name|job
operator|->
name|flags
argument_list|,
name|job
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete the target of a failed, interrupted, or otherwise  * unsuccessful job unless inhibited by .PRECIOUS.  */
end_comment

begin_function
specifier|static
name|void
name|JobDeleteTarget
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_JOIN
operator||
name|OP_PHONY
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|Targ_Precious
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|char
modifier|*
name|file
init|=
operator|(
name|gn
operator|->
name|path
operator|==
name|NULL
condition|?
name|gn
operator|->
name|name
else|:
name|gn
operator|->
name|path
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|noExecute
operator|&&
name|eunlink
argument_list|(
name|file
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|Error
argument_list|(
literal|"*** %s removed"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * JobSigLock/JobSigUnlock  *  * Signal lock routines to get exclusive access. Currently used to  * protect `jobs' and `stoppedJobs' list manipulations.  */
end_comment

begin_function
specifier|static
name|void
name|JobSigLock
parameter_list|(
name|sigset_t
modifier|*
name|omaskp
parameter_list|)
block|{
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|caught_signals
argument_list|,
name|omaskp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Punt
argument_list|(
literal|"JobSigLock: sigprocmask: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
name|omaskp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|JobSigUnlock
parameter_list|(
name|sigset_t
modifier|*
name|omaskp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
name|omaskp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|JobCreatePipe
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|int
name|minfd
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|,
name|flags
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|job
operator|->
name|jobPipe
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot create pipe: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* Avoid using low numbered fds */
name|fd
operator|=
name|fcntl
argument_list|(
name|job
operator|->
name|jobPipe
index|[
name|i
index|]
argument_list|,
name|F_DUPFD
argument_list|,
name|minfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|job
operator|->
name|jobPipe
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|job
operator|->
name|jobPipe
index|[
name|i
index|]
operator|=
name|fd
expr_stmt|;
block|}
block|}
comment|/* Set close-on-exec flag for both */
if|if
condition|(
name|fcntl
argument_list|(
name|job
operator|->
name|jobPipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot set close-on-exec: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|job
operator|->
name|jobPipe
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot set close-on-exec: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * We mark the input side of the pipe non-blocking; we poll(2) the      * pipe when we're waiting for a job token, but we might lose the      * race for the token when a new one becomes available, so the read       * from the pipe should not block.      */
name|flags
operator|=
name|fcntl
argument_list|(
name|job
operator|->
name|jobPipe
index|[
literal|0
index|]
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot get flags: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
name|O_NONBLOCK
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|job
operator|->
name|jobPipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot set flags: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobCondPassSig --  *	Pass a signal to a job  *  * Input:  *	signop		Signal to send it  *  * Side Effects:  *	None, except the job may bite it.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobCondPassSig
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"JobCondPassSig(%d) called.\n"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|job
operator|=
name|job_table
init|;
name|job
operator|<
name|job_table_end
condition|;
name|job
operator|++
control|)
block|{
if|if
condition|(
name|job
operator|->
name|job_state
operator|!=
name|JOB_ST_RUNNING
condition|)
continue|continue;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"JobCondPassSig passing signal %d to child %d.\n"
argument_list|,
name|signo
argument_list|,
name|job
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
name|KILLPG
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobChldSig --  *	SIGCHLD handler.  *  * Input:  *	signo		The signal number we've received  *  * Results:  *	None.  *  * Side Effects:  *	Sends a token on the child exit pipe to wake us up from  *	select()/poll().  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobChildSig
parameter_list|(
name|int
name|signo
name|MAKE_ATTR_UNUSED
parameter_list|)
block|{
while|while
condition|(
name|write
argument_list|(
name|childExitJob
operator|.
name|outPipe
argument_list|,
name|CHILD_EXIT
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobContinueSig --  *	Resume all stopped jobs.  *  * Input:  *	signo		The signal number we've received  *  * Results:  *	None.  *  * Side Effects:  *	Jobs start running again.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobContinueSig
parameter_list|(
name|int
name|signo
name|MAKE_ATTR_UNUSED
parameter_list|)
block|{
comment|/*      * Defer sending to SIGCONT to our stopped children until we return      * from the signal handler.      */
while|while
condition|(
name|write
argument_list|(
name|childExitJob
operator|.
name|outPipe
argument_list|,
name|DO_JOB_RESUME
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobPassSig --  *	Pass a signal on to all jobs, then resend to ourselves.  *  * Input:  *	signo		The signal number we've received  *  * Results:  *	None.  *  * Side Effects:  *	We die by the same signal.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|MAKE_ATTR_DEAD
specifier|static
name|void
name|JobPassSig_int
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* Run .INTERRUPT target then exit */
name|JobInterrupt
argument_list|(
name|TRUE
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|MAKE_ATTR_DEAD
specifier|static
name|void
name|JobPassSig_term
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* Dont run .INTERRUPT target then exit */
name|JobInterrupt
argument_list|(
name|FALSE
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|JobPassSig_suspend
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|sigset_t
name|nmask
decl_stmt|,
name|omask
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
comment|/* Suppress job started/continued messages */
name|make_suspended
operator|=
literal|1
expr_stmt|;
comment|/* Pass the signal onto every job */
name|JobCondPassSig
argument_list|(
name|signo
argument_list|)
expr_stmt|;
comment|/*      * Send ourselves the signal now we've given the message to everyone else.      * Note we block everything else possible while we're getting the signal.      * This ensures that all our jobs get continued when we wake up before      * we take any other signal.      */
name|sigfillset
argument_list|(
operator|&
name|nmask
argument_list|)
expr_stmt|;
name|sigdelset
argument_list|(
operator|&
name|nmask
argument_list|,
name|signo
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|nmask
argument_list|,
operator|&
name|omask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"JobPassSig passing signal %d to self.\n"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signo
argument_list|)
expr_stmt|;
comment|/*      * We've been continued.      *      * A whole host of signals continue to happen!      * SIGCHLD for any processes that actually suspended themselves.      * SIGCHLD for any processes that exited while we were alseep.      * The SIGCONT that actually caused us to wakeup.      *      * Since we defer passing the SIGCONT on to our children until      * the main processing loop, we can be sure that all the SIGCHLD      * events will have happened by then - and that the waitpid() will      * collect the child 'suspended' events.      * For correct sequencing we just need to ensure we process the      * waitpid() before passign on the SIGCONT.      *      * In any case nothing else is needed here.      */
comment|/* Restore handler and signal mask */
name|act
operator|.
name|sa_handler
operator|=
name|JobPassSig_suspend
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobFindPid  --  *	Compare the pid of the job with the given pid and return 0 if they  *	are equal. This function is called from Job_CatchChildren  *	to find the job descriptor of the finished job.  *  * Input:  *	job		job to examine  *	pid		process id desired  *  * Results:  *	Job with matching pid  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Job
modifier|*
name|JobFindPid
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|status
parameter_list|,
name|Boolean
name|isJobs
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
for|for
control|(
name|job
operator|=
name|job_table
init|;
name|job
operator|<
name|job_table_end
condition|;
name|job
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|job
operator|->
name|job_state
operator|==
name|status
operator|)
operator|&&
name|job
operator|->
name|pid
operator|==
name|pid
condition|)
return|return
name|job
return|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
operator|&&
name|isJobs
condition|)
name|job_table_dump
argument_list|(
literal|"no pid"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobPrintCommand  --  *	Put out another command for the given job. If the command starts  *	with an @ or a - we process it specially. In the former case,  *	so long as the -s and -n flags weren't given to make, we stick  *	a shell-specific echoOff command in the script. In the latter,  *	we ignore errors for the entire job, unless the shell has error  *	control.  *	If the command is just "..." we take all future commands for this  *	job to be commands to be executed once the entire graph has been  *	made and return non-zero to signal that the end of the commands  *	was reached. These commands are later attached to the postCommands  *	node and executed by Job_End when all things are done.  *	This function is called from JobStart via Lst_ForEach.  *  * Input:  *	cmdp		command string to print  *	jobp		job for which to print it  *  * Results:  *	Always 0, unless the command was "..."  *  * Side Effects:  *	If the command begins with a '-' and the shell has no error control,  *	the JOB_IGNERR flag is set in the job descriptor.  *	If the command is "..." and we're not ignoring such things,  *	tailCmds is set to the successor node of the cmd.  *	numCommands is incremented if the command is actually printed.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|JobPrintCommand
parameter_list|(
name|void
modifier|*
name|cmdp
parameter_list|,
name|void
modifier|*
name|jobp
parameter_list|)
block|{
name|Boolean
name|noSpecials
decl_stmt|;
comment|/* true if we shouldn't worry about 				     * inserting special commands into 				     * the input stream. */
name|Boolean
name|shutUp
init|=
name|FALSE
decl_stmt|;
comment|/* true if we put a no echo command 				     * into the command file */
name|Boolean
name|errOff
init|=
name|FALSE
decl_stmt|;
comment|/* true if we turned error checking 				     * off before printing the command 				     * and need to turn it back on */
specifier|const
name|char
modifier|*
name|cmdTemplate
decl_stmt|;
comment|/* Template to use when printing the 				     * command */
name|char
modifier|*
name|cmdStart
decl_stmt|;
comment|/* Start of expanded command */
name|char
modifier|*
name|escCmd
init|=
name|NULL
decl_stmt|;
comment|/* Command with quotes/backticks escaped */
name|char
modifier|*
name|cmd
init|=
operator|(
name|char
operator|*
operator|)
name|cmdp
decl_stmt|;
name|Job
modifier|*
name|job
init|=
operator|(
name|Job
operator|*
operator|)
name|jobp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|noSpecials
operator|=
name|NoExecute
argument_list|(
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"..."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|job
operator|->
name|node
operator|->
name|type
operator||=
name|OP_SAVE_CMDS
expr_stmt|;
if|if
condition|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNDOTS
operator|)
operator|==
literal|0
condition|)
block|{
name|job
operator|->
name|tailCmds
operator|=
name|Lst_Succ
argument_list|(
name|Lst_Member
argument_list|(
name|job
operator|->
name|node
operator|->
name|commands
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
define|#
directive|define
name|DBPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|arg
parameter_list|)
value|if (DEBUG(JOB)) {	\ 	(void)fprintf(debug_file, fmt, arg); 	\     }						\    (void)fprintf(job->cmdFILE, fmt, arg);	\    (void)fflush(job->cmdFILE);
name|numCommands
operator|+=
literal|1
expr_stmt|;
name|cmdStart
operator|=
name|cmd
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cmd
argument_list|,
name|job
operator|->
name|node
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
name|cmdTemplate
operator|=
literal|"%s\n"
expr_stmt|;
comment|/*      * Check for leading @' and -'s to control echoing and error checking.      */
while|while
condition|(
operator|*
name|cmd
operator|==
literal|'@'
operator|||
operator|*
name|cmd
operator|==
literal|'-'
operator|||
operator|(
operator|*
name|cmd
operator|==
literal|'+'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'@'
case|:
name|shutUp
operator|=
name|DEBUG
argument_list|(
name|LOUD
argument_list|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|errOff
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|noSpecials
condition|)
block|{
comment|/* 		 * We're not actually executing anything... 		 * but this one needs to be - use compat mode just for it. 		 */
name|CompatRunCommand
argument_list|(
name|cmdp
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmdStart
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
name|cmd
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cmd
argument_list|)
condition|)
name|cmd
operator|++
expr_stmt|;
comment|/*      * If the shell doesn't have error control the alternate echo'ing will      * be done (to avoid showing additional error checking code)       * and this will need the characters '$ ` \ "' escaped      */
if|if
condition|(
operator|!
name|commandShell
operator|->
name|hasErrCtl
condition|)
block|{
comment|/* Worst that could happen is every char needs escaping. */
name|escCmd
operator|=
name|bmake_malloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|*
literal|2
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|cmd
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cmd
index|[
name|i
index|]
operator|==
literal|'$'
operator|||
name|cmd
index|[
name|i
index|]
operator|==
literal|'`'
operator|||
name|cmd
index|[
name|i
index|]
operator|==
literal|'\\'
operator|||
name|cmd
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
name|escCmd
index|[
name|j
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|escCmd
index|[
name|j
index|]
operator|=
name|cmd
index|[
name|i
index|]
expr_stmt|;
block|}
name|escCmd
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|shutUp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|noSpecials
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|commandShell
operator|->
name|hasErrCtl
condition|)
name|shutUp
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errOff
condition|)
block|{
if|if
condition|(
operator|!
name|noSpecials
condition|)
block|{
if|if
condition|(
name|commandShell
operator|->
name|hasErrCtl
condition|)
block|{
comment|/* 		 * we don't want the error-control commands showing 		 * up either, so we turn off echoing while executing 		 * them. We could put another field in the shell 		 * structure to tell JobDoOutput to look for this 		 * string too, but why make it any more complex than 		 * it already is? 		 */
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|shutUp
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|ignErr
argument_list|)
expr_stmt|;
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|ignErr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|commandShell
operator|->
name|ignErr
operator|&&
operator|(
operator|*
name|commandShell
operator|->
name|ignErr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* 		 * The shell has no error control, so we need to be 		 * weird to get it to ignore any errors from the command. 		 * If echoing is turned on, we turn it off and use the 		 * errCheck template to echo the command. Leave echoing 		 * off so the user doesn't see the weirdness we go through 		 * to ignore errors. Set cmdTemplate to use the weirdness 		 * instead of the simple "%s\n" template. 		 */
name|job
operator|->
name|flags
operator||=
name|JOB_IGNERR
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|shutUp
condition|)
block|{
if|if
condition|(
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
block|}
name|DBPRINTF
argument_list|(
name|commandShell
operator|->
name|errCheck
argument_list|,
name|escCmd
argument_list|)
expr_stmt|;
name|shutUp
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|shutUp
condition|)
block|{
name|DBPRINTF
argument_list|(
name|commandShell
operator|->
name|errCheck
argument_list|,
name|escCmd
argument_list|)
expr_stmt|;
block|}
block|}
name|cmdTemplate
operator|=
name|commandShell
operator|->
name|ignErr
expr_stmt|;
comment|/* 		 * The error ignoration (hee hee) is already taken care 		 * of by the ignErr template, so pretend error checking 		 * is still on. 		 */
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*  	 * If errors are being checked and the shell doesn't have error control 	 * but does supply an errOut template, then setup commands to run 	 * through it. 	 */
if|if
condition|(
operator|!
name|commandShell
operator|->
name|hasErrCtl
operator|&&
name|commandShell
operator|->
name|errOut
operator|&&
operator|(
operator|*
name|commandShell
operator|->
name|errOut
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|shutUp
condition|)
block|{
if|if
condition|(
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
block|}
name|DBPRINTF
argument_list|(
name|commandShell
operator|->
name|errCheck
argument_list|,
name|escCmd
argument_list|)
expr_stmt|;
name|shutUp
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If it's a comment line or blank, treat as an ignored error */
if|if
condition|(
operator|(
name|escCmd
index|[
literal|0
index|]
operator|==
name|commandShell
operator|->
name|commentChar
operator|)
operator|||
operator|(
name|escCmd
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
name|cmdTemplate
operator|=
name|commandShell
operator|->
name|ignErr
expr_stmt|;
else|else
name|cmdTemplate
operator|=
name|commandShell
operator|->
name|errOut
expr_stmt|;
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|SHELL
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|shellName
argument_list|,
literal|"sh"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_TRACED
operator|)
operator|==
literal|0
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"set -%s\n"
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|job
operator|->
name|flags
operator||=
name|JOB_TRACED
expr_stmt|;
block|}
name|DBPRINTF
argument_list|(
name|cmdTemplate
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmdStart
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|escCmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|errOff
condition|)
block|{
comment|/* 	 * If echoing is already off, there's no point in issuing the 	 * echoOff command. Otherwise we issue it and pretend it was on 	 * for the whole command... 	 */
if|if
condition|(
operator|!
name|shutUp
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|shutUp
operator|=
name|TRUE
expr_stmt|;
block|}
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|errCheck
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shutUp
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOn
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobSaveCommand --  *	Save a command to be executed when everything else is done.  *	Callback function for JobFinish...  *  * Results:  *	Always returns 0  *  * Side Effects:  *	The command is tacked onto the end of postCommands's commands list.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|JobSaveCommand
parameter_list|(
name|void
modifier|*
name|cmd
parameter_list|,
name|void
modifier|*
name|gn
parameter_list|)
block|{
name|cmd
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cmd
argument_list|,
operator|(
name|GNode
operator|*
operator|)
name|gn
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|postCommands
operator|->
name|commands
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobClose --  *	Called to close both input and output pipes when a job is finished.  *  * Results:  *	Nada  *  * Side Effects:  *	The file descriptors associated with the job are closed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobClose
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|)
block|{
name|clearfd
argument_list|(
name|job
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|job
operator|->
name|outPipe
argument_list|)
expr_stmt|;
name|job
operator|->
name|outPipe
operator|=
operator|-
literal|1
expr_stmt|;
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|job
operator|->
name|inPipe
argument_list|)
expr_stmt|;
name|job
operator|->
name|inPipe
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobFinish  --  *	Do final processing for the given job including updating  *	parents and starting new jobs as available/necessary. Note  *	that we pay no attention to the JOB_IGNERR flag here.  *	This is because when we're called because of a noexecute flag  *	or something, jstat.w_status is 0 and when called from  *	Job_CatchChildren, the status is zeroed if it s/b ignored.  *  * Input:  *	job		job to finish  *	status		sub-why job went away  *  * Results:  *	None  *  * Side Effects:  *	Final commands for the job are placed on postCommands.  *  *	If we got an error and are aborting (aborting == ABORT_ERROR) and  *	the job list is now empty, we are done for the day.  *	If we recognized an error (errors !=0), we set the aborting flag  *	to ABORT_ERROR so no more jobs will be started.  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|JobFinish
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|WAIT_T
name|status
parameter_list|)
block|{
name|Boolean
name|done
decl_stmt|,
name|return_job_token
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Jobfinish: %d [%s], status %d\n"
argument_list|,
name|job
operator|->
name|pid
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
operator|)
operator|)
operator|)
operator|||
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* 	 * If it exited non-zero and either we're doing things our 	 * way or we're not ignoring errors, the job is finished. 	 * Similarly, if the shell died because of a signal 	 * the job is also finished. In these 	 * cases, finish out the job's output before printing the exit 	 * status... 	 */
name|JobClose
argument_list|(
name|job
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|NULL
operator|&&
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
name|job
operator|->
name|cmdFILE
operator|=
name|NULL
expr_stmt|;
block|}
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* 	 * Deal with ignored errors in -B mode. We need to print a message 	 * telling of the ignored error as well as setting status.w_status 	 * to 0 so the next command gets run. To do this, we set done to be 	 * TRUE if in -B mode and the job exited non-zero. 	 */
name|done
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
expr_stmt|;
comment|/* 	 * Old comment said: "Note we don't 	 * want to close down any of the streams until we know we're at the 	 * end." 	 * But we do. Otherwise when are we going to print the rest of the 	 * stuff? 	 */
name|JobClose
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * No need to close things down or anything. 	 */
name|done
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|done
condition|)
block|{
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Process %d [%s] exited.\n"
argument_list|,
name|job
operator|->
name|pid
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
condition|)
block|{
name|meta_job_error
argument_list|(
name|job
argument_list|,
name|job
operator|->
name|node
argument_list|,
name|job
operator|->
name|flags
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*** [%s] Error code %d%s\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|,
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|?
literal|" (ignored)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
condition|)
block|{
name|WAIT_STATUS
argument_list|(
name|status
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|deleteOnError
condition|)
block|{
name|JobDeleteTarget
argument_list|(
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|PrintOnError
argument_list|(
name|job
operator|->
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*** [%s] Completed successfully\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*** [%s] Signal %d\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleteOnError
condition|)
block|{
name|JobDeleteTarget
argument_list|(
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
condition|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|meta_job_finish
argument_list|(
name|job
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|status
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|x
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|return_job_token
operator|=
name|FALSE
expr_stmt|;
name|Trace_Log
argument_list|(
name|JOBEND
argument_list|,
name|job
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|WAIT_STATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|aborting
operator|==
name|ABORT_ERROR
operator|)
operator|||
operator|(
name|aborting
operator|==
name|ABORT_INTERRUPT
operator|)
condition|)
name|return_job_token
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|aborting
operator|!=
name|ABORT_ERROR
operator|)
operator|&&
operator|(
name|aborting
operator|!=
name|ABORT_INTERRUPT
operator|)
operator|&&
operator|(
name|WAIT_STATUS
argument_list|(
name|status
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	 * As long as we aren't aborting and the job didn't return a non-zero 	 * status that we shouldn't ignore, we call Make_Update to update 	 * the parents. In addition, any saved commands for the node are placed 	 * on the .END target. 	 */
if|if
condition|(
name|job
operator|->
name|tailCmds
operator|!=
name|NULL
condition|)
block|{
name|Lst_ForEachFrom
argument_list|(
name|job
operator|->
name|node
operator|->
name|commands
argument_list|,
name|job
operator|->
name|tailCmds
argument_list|,
name|JobSaveCommand
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|node
operator|->
name|made
operator|=
name|MADE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
condition|)
name|return_job_token
operator|=
name|TRUE
expr_stmt|;
name|Make_Update
argument_list|(
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|job
operator|->
name|job_state
operator|=
name|JOB_ST_FREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WAIT_STATUS
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|errors
operator|+=
literal|1
expr_stmt|;
name|job
operator|->
name|job_state
operator|=
name|JOB_ST_FREE
expr_stmt|;
block|}
comment|/*      * Set aborting if any error.      */
if|if
condition|(
name|errors
operator|&&
operator|!
name|keepgoing
operator|&&
operator|(
name|aborting
operator|!=
name|ABORT_INTERRUPT
operator|)
condition|)
block|{
comment|/* 	 * If we found any errors in this batch of children and the -k flag 	 * wasn't given, we set the aborting flag so no more jobs get 	 * started. 	 */
name|aborting
operator|=
name|ABORT_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|return_job_token
condition|)
name|Job_TokenReturn
argument_list|()
expr_stmt|;
if|if
condition|(
name|aborting
operator|==
name|ABORT_ERROR
operator|&&
name|jobTokensRunning
operator|==
literal|0
condition|)
block|{
comment|/* 	 * If we are aborting and the job table is now empty, we finish. 	 */
name|Finish
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Touch --  *	Touch the given target. Called by JobStart when the -t flag was  *	given  *  * Input:  *	gn		the node of the file to touch  *	silent		TRUE if should not print message  *  * Results:  *	None  *  * Side Effects:  *	The data modification of the file is changed. In addition, if the  *	file did not exist, it is created.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Touch
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Boolean
name|silent
parameter_list|)
block|{
name|int
name|streamID
decl_stmt|;
comment|/* ID of stream opened to do the touch */
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* Times for utime() call */
if|if
condition|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_JOIN
operator||
name|OP_USE
operator||
name|OP_USEBEFORE
operator||
name|OP_EXEC
operator||
name|OP_OPTIONAL
operator||
name|OP_SPECIAL
operator||
name|OP_PHONY
operator|)
condition|)
block|{
comment|/* 	 * .JOIN, .USE, .ZEROTIME and .OPTIONAL targets are "virtual" targets 	 * and, as such, shouldn't really be created. 	 */
return|return;
block|}
if|if
condition|(
operator|!
name|silent
operator|||
name|NoExecute
argument_list|(
name|gn
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"touch %s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NoExecute
argument_list|(
name|gn
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
name|Arch_Touch
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
condition|)
block|{
name|Arch_TouchLib
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|file
init|=
name|gn
operator|->
name|path
condition|?
name|gn
operator|->
name|path
else|:
name|gn
operator|->
name|name
decl_stmt|;
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
block|{
name|streamID
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|streamID
operator|>=
literal|0
condition|)
block|{
name|char
name|c
decl_stmt|;
comment|/* 		 * Read and write a byte to the file to change the 		 * modification time, then close the file. 		 */
if|if
condition|(
name|read
argument_list|(
name|streamID
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|streamID
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
while|while
condition|(
name|write
argument_list|(
name|streamID
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|streamID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"*** couldn't touch %s: %s"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_CheckCommands --  *	Make sure the given node has all the commands it needs.  *  * Input:  *	gn		The target whose commands need verifying  *	abortProc	Function to abort with message  *  * Results:  *	TRUE if the commands list is/was ok.  *  * Side Effects:  *	The node will have commands from the .DEFAULT rule added to it  *	if it needs them.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Job_CheckCommands
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|void
function_decl|(
modifier|*
name|abortProc
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
operator|&&
operator|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
operator|)
operator|==
literal|0
operator|||
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|children
argument_list|)
operator|)
condition|)
block|{
comment|/* 	 * No commands. Look for .DEFAULT rule from which we might infer 	 * commands 	 */
if|if
condition|(
operator|(
name|DEFAULT
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|DEFAULT
operator|->
name|commands
argument_list|)
operator|&&
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_SPECIAL
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* 	     * Make only looks for a .DEFAULT if the node was never the 	     * target of an operator, so that's what we do too. If 	     * a .DEFAULT was given, we substitute its commands for gn's 	     * commands and set the IMPSRC variable to be the target's name 	     * The DEFAULT node acts like a transformation rule, in that 	     * gn also inherits any attributes or sources attached to 	     * .DEFAULT itself. 	     */
name|Make_HandleUse
argument_list|(
name|DEFAULT
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Dir_MTime
argument_list|(
name|gn
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_SPECIAL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * The node wasn't the target of an operator we have no .DEFAULT 	     * rule to go on and the target doesn't already exist. There's 	     * nothing more we can do for this branch. If the -k flag wasn't 	     * given, we stop in our tracks, otherwise we just don't update 	     * this node's parents so they never get examined. 	     */
specifier|static
specifier|const
name|char
name|msg
index|[]
init|=
literal|": don't know how to make"
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|flags
operator|&
name|FROM_DEPEND
condition|)
block|{
if|if
condition|(
operator|!
name|Job_RunTarget
argument_list|(
literal|".STALE"
argument_list|,
name|gn
operator|->
name|fname
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: %s, %d: ignoring stale %s for %s\n"
argument_list|,
name|progname
argument_list|,
name|gn
operator|->
name|fname
argument_list|,
name|gn
operator|->
name|lineno
argument_list|,
name|makeDependfile
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_OPTIONAL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%s %s (ignored)\n"
argument_list|,
name|progname
argument_list|,
name|msg
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keepgoing
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%s %s (continuing)\n"
argument_list|,
name|progname
argument_list|,
name|msg
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
call|(
modifier|*
name|abortProc
call|)
argument_list|(
literal|"%s%s %s. Stop"
argument_list|,
name|progname
argument_list|,
name|msg
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobExec --  *	Execute the shell for the given job. Called from JobStart  *  * Input:  *	job		Job to execute  *  * Results:  *	None.  *  * Side Effects:  *	A shell is executed, outputs is altered and the Job structure added  *	to the job table.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobExec
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|cpid
decl_stmt|;
comment|/* ID of new child */
name|sigset_t
name|mask
decl_stmt|;
name|job
operator|->
name|flags
operator|&=
operator|~
name|JOB_TRACED
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Running %s %sly\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|,
literal|"local"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\tCommand: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s "
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Some jobs produce no output and it's disconcerting to have      * no feedback of their running (since they produce no output, the      * banner with their name in it never appears). This is an attempt to      * provide that feedback, even if nothing follows it.      */
if|if
condition|(
operator|(
name|lastNode
operator|!=
name|job
operator|->
name|node
operator|)
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
comment|/* No interruptions until this job is on the `jobs' list */
name|JobSigLock
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
comment|/* Pre-emptively mark job running, pid still zero though */
name|job
operator|->
name|job_state
operator|=
name|JOB_ST_RUNNING
expr_stmt|;
name|cpid
operator|=
name|vFork
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpid
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot vfork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpid
operator|==
literal|0
condition|)
block|{
comment|/* Child */
name|sigset_t
name|tmask
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
condition|)
block|{
name|meta_job_child
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Reset all signal handlers; this is necessary because we also 	 * need to unblock signals before we exec(2). 	 */
name|JobSigReset
argument_list|()
expr_stmt|;
comment|/* Now unblock signals */
name|sigemptyset
argument_list|(
operator|&
name|tmask
argument_list|)
expr_stmt|;
name|JobSigUnlock
argument_list|(
operator|&
name|tmask
argument_list|)
expr_stmt|;
comment|/* 	 * Must duplicate the input stream down to the child's input and 	 * reset it to the beginning (again). Since the stream was marked 	 * close-on-exec, we must clear that bit in the new input. 	 */
if|if
condition|(
name|dup2
argument_list|(
name|FILENO
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|execError
argument_list|(
literal|"dup2"
argument_list|,
literal|"job->cmdFILE"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|execError
argument_list|(
literal|"fcntl clear close-on-exec"
argument_list|,
literal|"stdin"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
literal|0
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|execError
argument_list|(
literal|"lseek to 0"
argument_list|,
literal|"stdin"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|job
operator|->
name|node
operator|->
name|type
operator|&
operator|(
name|OP_MAKE
operator||
name|OP_SUBMAKE
operator|)
condition|)
block|{
comment|/* 		 * Pass job token pipe to submakes. 		 */
if|if
condition|(
name|fcntl
argument_list|(
name|tokenWaitJob
operator|.
name|inPipe
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|execError
argument_list|(
literal|"clear close-on-exec"
argument_list|,
literal|"tokenWaitJob.inPipe"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|tokenWaitJob
operator|.
name|outPipe
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|execError
argument_list|(
literal|"clear close-on-exec"
argument_list|,
literal|"tokenWaitJob.outPipe"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set up the child's output to be routed through the pipe 	 * we've created for it. 	 */
if|if
condition|(
name|dup2
argument_list|(
name|job
operator|->
name|outPipe
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|execError
argument_list|(
literal|"dup2"
argument_list|,
literal|"job->outPipe"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The output channels are marked close on exec. This bit was 	 * duplicated by the dup2(on some systems), so we have to clear 	 * it before routing the shell's error output to the same place as 	 * its standard output. 	 */
if|if
condition|(
name|fcntl
argument_list|(
literal|1
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|execError
argument_list|(
literal|"clear close-on-exec"
argument_list|,
literal|"stdout"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|execError
argument_list|(
literal|"dup2"
argument_list|,
literal|"1, 2"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We want to switch the child into a different process family so 	 * we can kill it and all its descendants in one fell swoop, 	 * by killing its process family, but not commit suicide. 	 */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETPGID
argument_list|)
operator|(
name|void
operator|)
name|setpgid
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETSID
argument_list|)
comment|/* XXX: dsl - I'm sure this should be setpgrp()... */
operator|(
name|void
operator|)
name|setsid
argument_list|()
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|Var_ExportVars
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|execv
argument_list|(
name|shellPath
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|execError
argument_list|(
literal|"exec"
argument_list|,
name|shellPath
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Parent, continuing after the child exec */
name|job
operator|->
name|pid
operator|=
name|cpid
expr_stmt|;
name|Trace_Log
argument_list|(
name|JOBSTART
argument_list|,
name|job
argument_list|)
expr_stmt|;
comment|/*      * Set the current position in the buffer to the beginning      * and mark another stream to watch in the outputs mask      */
name|job
operator|->
name|curPos
operator|=
literal|0
expr_stmt|;
name|watchfd
argument_list|(
name|job
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|NULL
operator|&&
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
name|job
operator|->
name|cmdFILE
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * Now the job is actually running, add it to the table.      */
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"JobExec(%s): pid %d added to jobs table\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|,
name|job
operator|->
name|pid
argument_list|)
expr_stmt|;
name|job_table_dump
argument_list|(
literal|"job started"
argument_list|)
expr_stmt|;
block|}
name|JobSigUnlock
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobMakeArgv --  *	Create the argv needed to execute the shell for a given job.  *  *  * Results:  *  * Side Effects:  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobMakeArgv
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|argc
decl_stmt|;
specifier|static
name|char
name|args
index|[
literal|10
index|]
decl_stmt|;
comment|/* For merged arguments */
name|argv
index|[
literal|0
index|]
operator|=
name|UNCONST
argument_list|(
name|shellName
argument_list|)
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|commandShell
operator|->
name|exit
operator|&&
operator|(
operator|*
name|commandShell
operator|->
name|exit
operator|!=
literal|'-'
operator|)
operator|)
operator|||
operator|(
name|commandShell
operator|->
name|echo
operator|&&
operator|(
operator|*
name|commandShell
operator|->
name|echo
operator|!=
literal|'-'
operator|)
operator|)
condition|)
block|{
comment|/* 	 * At least one of the flags doesn't have a minus before it, so 	 * merge them together. Have to do this because the *(&(@*#*&#$# 	 * Bourne shell thinks its second argument is a file to source. 	 * Grrrr. Note the ten-character limitation on the combined arguments. 	 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|,
literal|"-%s%s"
argument_list|,
operator|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|?
literal|""
else|:
operator|(
name|commandShell
operator|->
name|exit
condition|?
name|commandShell
operator|->
name|exit
else|:
literal|""
operator|)
operator|)
argument_list|,
operator|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
condition|?
literal|""
else|:
operator|(
name|commandShell
operator|->
name|echo
condition|?
name|commandShell
operator|->
name|echo
else|:
literal|""
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|args
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
operator|&&
name|commandShell
operator|->
name|exit
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|UNCONST
argument_list|(
name|commandShell
operator|->
name|exit
argument_list|)
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
name|commandShell
operator|->
name|echo
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|UNCONST
argument_list|(
name|commandShell
operator|->
name|echo
argument_list|)
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobStart  --  *	Start a target-creation process going for the target described  *	by the graph node gn.  *  * Input:  *	gn		target to create  *	flags		flags for the job to override normal ones.  *			e.g. JOB_SPECIAL or JOB_IGNDOTS  *	previous	The previous Job structure for this node, if any.  *  * Results:  *	JOB_ERROR if there was an error in the commands, JOB_FINISHED  *	if there isn't actually anything left to do for the job and  *	JOB_RUNNING if the job has been started.  *  * Side Effects:  *	A new Job node is created and added to the list of running  *	jobs. PMake is forked and a child shell created.  *  * NB: I'm fairly sure that this code is never called with JOB_SPECIAL set  *     JOB_IGNDOTS is never set (dsl)  *     Also the return value is ignored by everyone.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|JobStart
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* new job descriptor */
name|char
modifier|*
name|argv
index|[
literal|10
index|]
decl_stmt|;
comment|/* Argument vector to shell */
name|Boolean
name|cmdsOK
decl_stmt|;
comment|/* true if the nodes commands were all right */
name|Boolean
name|noExec
decl_stmt|;
comment|/* Set true if we decide not to run the job */
name|int
name|tfd
decl_stmt|;
comment|/* File descriptor to the temp file */
for|for
control|(
name|job
operator|=
name|job_table
init|;
name|job
operator|<
name|job_table_end
condition|;
name|job
operator|++
control|)
block|{
if|if
condition|(
name|job
operator|->
name|job_state
operator|==
name|JOB_ST_FREE
condition|)
break|break;
block|}
if|if
condition|(
name|job
operator|>=
name|job_table_end
condition|)
name|Punt
argument_list|(
literal|"JobStart no job slots vacant"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|job
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|job
argument_list|)
expr_stmt|;
name|job
operator|->
name|job_state
operator|=
name|JOB_ST_SETUP
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_SPECIAL
condition|)
name|flags
operator||=
name|JOB_SPECIAL
expr_stmt|;
name|job
operator|->
name|node
operator|=
name|gn
expr_stmt|;
name|job
operator|->
name|tailCmds
operator|=
name|NULL
expr_stmt|;
comment|/*      * Set the initial value of the flags for this job based on the global      * ones and the node's attributes... Any flags supplied by the caller      * are also added to the field.      */
name|job
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Targ_Ignore
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|job
operator|->
name|flags
operator||=
name|JOB_IGNERR
expr_stmt|;
block|}
if|if
condition|(
name|Targ_Silent
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|job
operator|->
name|flags
operator||=
name|JOB_SILENT
expr_stmt|;
block|}
name|job
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
comment|/*      * Check the commands now so any attributes from .DEFAULT have a chance      * to migrate to the node      */
name|cmdsOK
operator|=
name|Job_CheckCommands
argument_list|(
name|gn
argument_list|,
name|Error
argument_list|)
expr_stmt|;
name|job
operator|->
name|inPollfd
operator|=
name|NULL
expr_stmt|;
comment|/*      * If the -n flag wasn't given, we open up OUR (not the child's)      * temporary file to stuff commands in it. The thing is rd/wr so we don't      * need to reopen it to feed it to the shell. If the -n flag *was* given,      * we just set the file to be stdout. Cute, huh?      */
if|if
condition|(
operator|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_MAKE
operator|)
operator|&&
operator|!
operator|(
name|noRecursiveExecute
operator|)
operator|)
operator|||
operator|(
operator|!
name|noExecute
operator|&&
operator|!
name|touchFlag
operator|)
condition|)
block|{
comment|/* 	 * tfile is the name of a file into which all shell commands are 	 * put. It is removed before the child shell is executed, unless 	 * DEBUG(SCRIPT) is set. 	 */
name|char
modifier|*
name|tfile
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|;
comment|/* 	 * We're serious here, but if the commands were bogus, we're 	 * also dead... 	 */
if|if
condition|(
operator|!
name|cmdsOK
condition|)
block|{
name|PrintOnError
argument_list|(
name|gn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* provide some clue */
name|DieHorribly
argument_list|()
expr_stmt|;
block|}
name|JobSigLock
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|tfd
operator|=
name|mkTempFile
argument_list|(
name|TMPPAT
argument_list|,
operator|&
name|tfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DEBUG
argument_list|(
name|SCRIPT
argument_list|)
condition|)
operator|(
name|void
operator|)
name|eunlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|JobSigUnlock
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|job
operator|->
name|cmdFILE
operator|=
name|fdopen
argument_list|(
name|tfd
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|==
name|NULL
condition|)
block|{
name|Punt
argument_list|(
literal|"Could not fdopen %s"
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|FILENO
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
comment|/* 	 * Send the commands to the command file, flush all its buffers then 	 * rewind and remove the thing. 	 */
name|noExec
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
condition|)
block|{
name|meta_job_start
argument_list|(
name|job
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|Targ_Silent
argument_list|(
name|gn
argument_list|)
condition|)
block|{
comment|/* might have changed */
name|job
operator|->
name|flags
operator||=
name|JOB_SILENT
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * We can do all the commands at once. hooray for sanity 	 */
name|numCommands
operator|=
literal|0
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|JobPrintCommand
argument_list|,
name|job
argument_list|)
expr_stmt|;
comment|/* 	 * If we didn't print out any commands to the shell script, 	 * there's not much point in executing the shell, is there? 	 */
if|if
condition|(
name|numCommands
operator|==
literal|0
condition|)
block|{
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
name|free
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NoExecute
argument_list|(
name|gn
argument_list|)
condition|)
block|{
comment|/* 	 * Not executing anything -- just print all the commands to stdout 	 * in one fell swoop. This will still set up job->tailCmds correctly. 	 */
if|if
condition|(
name|lastNode
operator|!=
name|gn
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|gn
expr_stmt|;
block|}
name|job
operator|->
name|cmdFILE
operator|=
name|stdout
expr_stmt|;
comment|/* 	 * Only print the commands if they're ok, but don't die if they're 	 * not -- just let the user know they're bad and keep going. It 	 * doesn't do any harm in this case and may do some good. 	 */
if|if
condition|(
name|cmdsOK
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|JobPrintCommand
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Don't execute the shell, thank you. 	 */
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Just touch the target and note that no shell should be executed. 	 * Set cmdFILE to stdout to make life easier. Check the commands, too, 	 * but don't die if they're no good -- it does no harm to keep working 	 * up the graph. 	 */
name|job
operator|->
name|cmdFILE
operator|=
name|stdout
expr_stmt|;
name|Job_Touch
argument_list|(
name|gn
argument_list|,
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
argument_list|)
expr_stmt|;
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Just in case it isn't already... */
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
comment|/*      * If we're not supposed to execute a shell, don't.      */
if|if
condition|(
name|noExec
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
condition|)
name|Job_TokenReturn
argument_list|()
expr_stmt|;
comment|/* 	 * Unlink and close the command file if we opened one 	 */
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
name|job
operator|->
name|cmdFILE
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * We only want to work our way up the graph if we aren't here because 	 * the commands for the job were no good. 	 */
if|if
condition|(
name|cmdsOK
operator|&&
name|aborting
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|tailCmds
operator|!=
name|NULL
condition|)
block|{
name|Lst_ForEachFrom
argument_list|(
name|job
operator|->
name|node
operator|->
name|commands
argument_list|,
name|job
operator|->
name|tailCmds
argument_list|,
name|JobSaveCommand
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|node
operator|->
name|made
operator|=
name|MADE
expr_stmt|;
name|Make_Update
argument_list|(
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|job_state
operator|=
name|JOB_ST_FREE
expr_stmt|;
return|return
name|cmdsOK
condition|?
name|JOB_FINISHED
else|:
name|JOB_ERROR
return|;
block|}
comment|/*      * Set up the control arguments to the shell. This is based on the flags      * set earlier for this job.      */
name|JobMakeArgv
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Create the pipe by which we'll get the shell's output.  */
name|JobCreatePipe
argument_list|(
name|job
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|JobExec
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|JOB_RUNNING
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|JobOutput
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
name|char
modifier|*
name|endp
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|ecp
decl_stmt|;
if|if
condition|(
name|commandShell
operator|->
name|noPrint
condition|)
block|{
name|ecp
operator|=
name|Str_FindSubstring
argument_list|(
name|cp
argument_list|,
name|commandShell
operator|->
name|noPrint
argument_list|)
expr_stmt|;
while|while
condition|(
name|ecp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
name|ecp
condition|)
block|{
operator|*
name|ecp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|beSilent
operator|&&
name|msg
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
comment|/* 		 * The only way there wouldn't be a newline after 		 * this line is if it were the last in the buffer. 		 * however, since the non-printable comes after it, 		 * there must be a newline, so we don't print one. 		 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|ecp
operator|+
name|commandShell
operator|->
name|noPLen
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|endp
condition|)
block|{
comment|/* 		 * Still more to print, look again after skipping 		 * the whitespace following the non-printable 		 * command.... 		 */
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|ecp
operator|=
name|Str_FindSubstring
argument_list|(
name|cp
argument_list|,
name|commandShell
operator|->
name|noPrint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|cp
return|;
block|}
block|}
block|}
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobDoOutput  --  *	This function is called at different times depending on  *	whether the user has specified that output is to be collected  *	via pipes or temporary files. In the former case, we are called  *	whenever there is something to read on the pipe. We collect more  *	output from the given job and store it in the job's outBuf. If  *	this makes up a line, we print it tagged by the job's identifier,  *	as necessary.  *	If output has been collected in a temporary file, we open the  *	file and read it line by line, transfering it to our own  *	output channel until the file is empty. At which point we  *	remove the temporary file.  *	In both cases, however, we keep our figurative eye out for the  *	'noPrint' line for the shell from which the output came. If  *	we recognize a line, we don't print it. If the command is not  *	alone on the line (the character after it is not \0 or \n), we  *	do print whatever follows it.  *  * Input:  *	job		the job whose output needs printing  *	finish		TRUE if this is the last time we'll be called  *			for this job  *  * Results:  *	None  *  * Side Effects:  *	curPos may be shifted as may the contents of outBuf.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|STATIC
name|void
name|JobDoOutput
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|Boolean
name|finish
parameter_list|)
block|{
name|Boolean
name|gotNL
init|=
name|FALSE
decl_stmt|;
comment|/* true if got a newline */
name|Boolean
name|fbuf
decl_stmt|;
comment|/* true if our buffer filled up */
name|int
name|nr
decl_stmt|;
comment|/* number of bytes read */
name|int
name|i
decl_stmt|;
comment|/* auxiliary index into outBuf */
name|int
name|max
decl_stmt|;
comment|/* limit for i (end of current data) */
name|int
name|nRead
decl_stmt|;
comment|/* (Temporary) number of bytes read */
comment|/*      * Read as many bytes as will fit in the buffer.      */
name|end_loop
label|:
name|gotNL
operator|=
name|FALSE
expr_stmt|;
name|fbuf
operator|=
name|FALSE
expr_stmt|;
name|nRead
operator|=
name|read
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|job
operator|->
name|outBuf
index|[
name|job
operator|->
name|curPos
index|]
argument_list|,
name|JOB_BUFSIZE
operator|-
name|job
operator|->
name|curPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRead
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
return|return;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"JobDoOutput(piperead)"
argument_list|)
expr_stmt|;
block|}
name|nr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nr
operator|=
name|nRead
expr_stmt|;
block|}
comment|/*      * If we hit the end-of-file (the job is dead), we must flush its      * remaining output, so pretend we read a newline if there's any      * output remaining in the buffer.      * Also clear the 'finish' flag so we stop looping.      */
if|if
condition|(
operator|(
name|nr
operator|==
literal|0
operator|)
operator|&&
operator|(
name|job
operator|->
name|curPos
operator|!=
literal|0
operator|)
condition|)
block|{
name|job
operator|->
name|outBuf
index|[
name|job
operator|->
name|curPos
index|]
operator|=
literal|'\n'
expr_stmt|;
name|nr
operator|=
literal|1
expr_stmt|;
name|finish
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nr
operator|==
literal|0
condition|)
block|{
name|finish
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*      * Look for the last newline in the bytes we just got. If there is      * one, break out of the loop with 'i' as its index and gotNL set      * TRUE.      */
name|max
operator|=
name|job
operator|->
name|curPos
operator|+
name|nr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|job
operator|->
name|curPos
operator|+
name|nr
operator|-
literal|1
init|;
name|i
operator|>=
name|job
operator|->
name|curPos
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|gotNL
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 	     * Why? 	     */
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|gotNL
condition|)
block|{
name|job
operator|->
name|curPos
operator|+=
name|nr
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|curPos
operator|==
name|JOB_BUFSIZE
condition|)
block|{
comment|/* 	     * If we've run out of buffer space, we have no choice 	     * but to print the stuff. sigh. 	     */
name|fbuf
operator|=
name|TRUE
expr_stmt|;
name|i
operator|=
name|job
operator|->
name|curPos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gotNL
operator|||
name|fbuf
condition|)
block|{
comment|/* 	 * Need to send the output to the screen. Null terminate it 	 * first, overwriting the newline character if there was one. 	 * So long as the line isn't one we should filter (according 	 * to the shell description), we print the line, preceded 	 * by a target banner if this target isn't the same as the 	 * one for which we last printed something. 	 * The rest of the data in the buffer are then shifted down 	 * to the start of the buffer and curPos is set accordingly. 	 */
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|job
operator|->
name|curPos
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|JobOutput
argument_list|(
name|job
argument_list|,
name|job
operator|->
name|outBuf
argument_list|,
operator|&
name|job
operator|->
name|outBuf
index|[
name|i
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	     * There's still more in that thar buffer. This time, though, 	     * we know there's no newline at the end, so we add one of 	     * our own free will. 	     */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|beSilent
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
condition|)
block|{
name|meta_job_output
argument_list|(
name|job
argument_list|,
name|cp
argument_list|,
name|gotNL
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%s"
argument_list|,
name|cp
argument_list|,
name|gotNL
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * max is the last offset still in the buffer. Move any remaining 	 * characters to the start of the buffer and update the end marker 	 * curPos. 	 */
if|if
condition|(
name|i
operator|<
name|max
condition|)
block|{
operator|(
name|void
operator|)
name|memmove
argument_list|(
name|job
operator|->
name|outBuf
argument_list|,
operator|&
name|job
operator|->
name|outBuf
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|max
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|curPos
operator|=
name|max
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|i
operator|==
name|max
argument_list|)
expr_stmt|;
name|job
operator|->
name|curPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|finish
condition|)
block|{
comment|/* 	 * If the finish flag is true, we must loop until we hit 	 * end-of-file on the pipe. This is guaranteed to happen 	 * eventually since the other end of the pipe is now closed 	 * (we closed it explicitly and the child has exited). When 	 * we do get an EOF, finish will be set FALSE and we'll fall 	 * through and out. 	 */
goto|goto
name|end_loop
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|JobRun
parameter_list|(
name|GNode
modifier|*
name|targ
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/*      * Unfortunately it is too complicated to run .BEGIN, .END,      * and .INTERRUPT job in the parallel job module. This has      * the nice side effect that it avoids a lot of other problems.      */
name|Lst
name|lst
init|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
decl_stmt|;
name|Lst_AtEnd
argument_list|(
name|lst
argument_list|,
name|targ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Make_Run
argument_list|(
name|lst
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|lst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|JobStart
argument_list|(
name|targ
argument_list|,
name|JOB_SPECIAL
argument_list|)
expr_stmt|;
while|while
condition|(
name|jobTokensRunning
condition|)
block|{
name|Job_CatchOutput
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|Compat_Make
argument_list|(
name|targ
argument_list|,
name|targ
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|made
operator|==
name|ERROR
condition|)
block|{
name|PrintOnError
argument_list|(
name|targ
argument_list|,
literal|"\n\nStop."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_CatchChildren --  *	Handle the exit of a child. Called from Make_Make.  *  * Input:  *	block		TRUE if should block on the wait  *  * Results:  *	none.  *  * Side Effects:  *	The job descriptor is removed from the list of children.  *  * Notes:  *	We do waits, blocking or not, according to the wisdom of our  *	caller, until there are no more children to report. For each  *	job, call JobFinish to finish things off.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_CatchChildren
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
comment|/* pid of dead child */
name|WAIT_T
name|status
decl_stmt|;
comment|/* Exit/termination status */
comment|/*      * Don't even bother if we know there's no one around.      */
if|if
condition|(
name|jobTokensRunning
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
operator|(
name|pid
operator|=
name|waitpid
argument_list|(
operator|(
name|pid_t
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
operator||
name|WUNTRACED
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Process %d exited/stopped status %x.\n"
argument_list|,
name|pid
argument_list|,
name|WAIT_STATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|JobReapChild
argument_list|(
name|pid
argument_list|,
name|status
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * It is possible that wait[pid]() was called from elsewhere,  * this lets us reap jobs regardless.  */
end_comment

begin_function
name|void
name|JobReapChild
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|WAIT_T
name|status
parameter_list|,
name|Boolean
name|isJobs
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* job descriptor for dead child */
comment|/*      * Don't even bother if we know there's no one around.      */
if|if
condition|(
name|jobTokensRunning
operator|==
literal|0
condition|)
return|return;
name|job
operator|=
name|JobFindPid
argument_list|(
name|pid
argument_list|,
name|JOB_ST_RUNNING
argument_list|,
name|isJobs
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|isJobs
condition|)
block|{
if|if
condition|(
operator|!
name|lurking_children
condition|)
name|Error
argument_list|(
literal|"Child (%d) status %x not in table?"
argument_list|,
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* not ours */
block|}
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Process %d (%s) stopped.\n"
argument_list|,
name|job
operator|->
name|pid
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|make_suspended
condition|)
block|{
switch|switch
condition|(
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
condition|)
block|{
case|case
name|SIGTSTP
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*** [%s] Suspended\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGSTOP
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*** [%s] Stopped\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*** [%s] Stopped -- signal %d\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|,
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|job_suspended
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
name|job
operator|->
name|job_state
operator|=
name|JOB_ST_FINISHED
expr_stmt|;
name|job
operator|->
name|exit_status
operator|=
name|WAIT_STATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|JobFinish
argument_list|(
name|job
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_CatchOutput --  *	Catch the output from our children, if we're using  *	pipes do so. Otherwise just block time until we get a  *	signal(most likely a SIGCHLD) since there's no point in  *	just spinning when there's nothing to do and the reaping  *	of a child can wait for a while.  *  * Results:  *	None  *  * Side Effects:  *	Output is read from pipes if we're piping.  * -----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_CatchOutput
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nready
decl_stmt|;
name|Job
modifier|*
name|job
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* The first fd in the list is the job token pipe */
do|do
block|{
name|nready
operator|=
name|poll
argument_list|(
name|fds
operator|+
literal|1
operator|-
name|wantToken
argument_list|,
name|nfds
operator|-
literal|1
operator|+
name|wantToken
argument_list|,
name|POLL_MSEC
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nready
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|nready
operator|<
literal|0
condition|)
name|Punt
argument_list|(
literal|"poll: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nready
operator|>
literal|0
operator|&&
name|readyfd
argument_list|(
operator|&
name|childExitJob
argument_list|)
condition|)
block|{
name|char
name|token
init|=
literal|0
decl_stmt|;
name|ssize_t
name|count
decl_stmt|;
name|count
operator|=
name|read
argument_list|(
name|childExitJob
operator|.
name|inPipe
argument_list|,
operator|&
name|token
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|count
condition|)
block|{
case|case
literal|0
case|:
name|Punt
argument_list|(
literal|"unexpected eof on token pipe"
argument_list|)
expr_stmt|;
case|case
operator|-
literal|1
case|:
name|Punt
argument_list|(
literal|"token pipe read: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
if|if
condition|(
name|token
operator|==
name|DO_JOB_RESUME
index|[
literal|0
index|]
condition|)
comment|/* Complete relay requested from our SIGCONT handler */
name|JobRestartJobs
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
operator|--
name|nready
expr_stmt|;
block|}
name|Job_CatchChildren
argument_list|()
expr_stmt|;
if|if
condition|(
name|nready
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|fds
index|[
name|i
index|]
operator|.
name|revents
condition|)
continue|continue;
name|job
operator|=
name|jobfds
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|job_state
operator|==
name|JOB_ST_RUNNING
condition|)
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|nready
operator|==
literal|0
condition|)
return|return;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Make --  *	Start the creation of a target. Basically a front-end for  *	JobStart used by the Make module.  *  * Results:  *	None.  *  * Side Effects:  *	Another job is started.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Make
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
operator|(
name|void
operator|)
name|JobStart
argument_list|(
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Shell_Init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|shellPath
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * We are using the default shell, which may be an absolute 	 * path if DEFSHELL_CUSTOM is defined. 	 */
name|shellName
operator|=
name|commandShell
operator|->
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|DEFSHELL_CUSTOM
if|if
condition|(
operator|*
name|shellName
operator|==
literal|'/'
condition|)
block|{
name|shellPath
operator|=
name|shellName
expr_stmt|;
name|shellName
operator|=
name|strrchr
argument_list|(
name|shellPath
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|shellName
operator|++
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|shellPath
operator|=
name|str_concat
argument_list|(
name|_PATH_DEFSHELLDIR
argument_list|,
name|shellName
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commandShell
operator|->
name|exit
operator|==
name|NULL
condition|)
block|{
name|commandShell
operator|->
name|exit
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|commandShell
operator|->
name|echo
operator|==
name|NULL
condition|)
block|{
name|commandShell
operator|->
name|echo
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|commandShell
operator|->
name|hasErrCtl
operator|&&
operator|*
name|commandShell
operator|->
name|exit
condition|)
block|{
if|if
condition|(
name|shellErrFlag
operator|&&
name|strcmp
argument_list|(
name|commandShell
operator|->
name|exit
argument_list|,
operator|&
name|shellErrFlag
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|shellErrFlag
argument_list|)
expr_stmt|;
name|shellErrFlag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|shellErrFlag
condition|)
block|{
name|int
name|n
init|=
name|strlen
argument_list|(
name|commandShell
operator|->
name|exit
argument_list|)
operator|+
literal|2
decl_stmt|;
name|shellErrFlag
operator|=
name|bmake_malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|shellErrFlag
condition|)
block|{
name|snprintf
argument_list|(
name|shellErrFlag
argument_list|,
name|n
argument_list|,
literal|"-%s"
argument_list|,
name|commandShell
operator|->
name|exit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|shellErrFlag
condition|)
block|{
name|free
argument_list|(
name|shellErrFlag
argument_list|)
expr_stmt|;
name|shellErrFlag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  * Returns the string literal that is used in the current command shell  * to produce a newline character.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|Shell_GetNewline
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|commandShell
operator|->
name|newline
return|;
block|}
end_function

begin_function
name|void
name|Job_SetPrefix
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|targPrefix
condition|)
block|{
name|free
argument_list|(
name|targPrefix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|Var_Exists
argument_list|(
name|MAKE_JOB_PREFIX
argument_list|,
name|VAR_GLOBAL
argument_list|)
condition|)
block|{
name|Var_Set
argument_list|(
name|MAKE_JOB_PREFIX
argument_list|,
literal|"---"
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|targPrefix
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
literal|"${"
name|MAKE_JOB_PREFIX
literal|"}"
argument_list|,
name|VAR_GLOBAL
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Init --  *	Initialize the process module  *  * Input:  *  * Results:  *	none  *  * Side Effects:  *	lists and counters are initialized  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Init
parameter_list|(
name|void
parameter_list|)
block|{
name|Job_SetPrefix
argument_list|()
expr_stmt|;
comment|/* Allocate space for all the job info */
name|job_table
operator|=
name|bmake_malloc
argument_list|(
name|maxJobs
operator|*
sizeof|sizeof
expr|*
name|job_table
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|job_table
argument_list|,
literal|0
argument_list|,
name|maxJobs
operator|*
sizeof|sizeof
expr|*
name|job_table
argument_list|)
expr_stmt|;
name|job_table_end
operator|=
name|job_table
operator|+
name|maxJobs
expr_stmt|;
name|wantToken
operator|=
literal|0
expr_stmt|;
name|aborting
operator|=
literal|0
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|lastNode
operator|=
name|NULL
expr_stmt|;
comment|/*      * There is a non-zero chance that we already have children.      * eg after 'make -f-<<EOF'      * Since their termination causes a 'Child (pid) not in table' message,      * Collect the status of any that are already dead, and suppress the      * error message if there are any undead ones.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|rval
decl_stmt|,
name|status
decl_stmt|;
name|rval
operator|=
name|waitpid
argument_list|(
operator|(
name|pid_t
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|>
literal|0
condition|)
continue|continue;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
name|lurking_children
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|Shell_Init
argument_list|()
expr_stmt|;
name|JobCreatePipe
argument_list|(
operator|&
name|childExitJob
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* We can only need to wait for tokens, children and output from each job */
name|fds
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fds
argument_list|)
operator|*
operator|(
literal|2
operator|+
name|maxJobs
operator|)
argument_list|)
expr_stmt|;
name|jobfds
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|jobfds
argument_list|)
operator|*
operator|(
literal|2
operator|+
name|maxJobs
operator|)
argument_list|)
expr_stmt|;
comment|/* These are permanent entries and take slots 0 and 1 */
name|watchfd
argument_list|(
operator|&
name|tokenWaitJob
argument_list|)
expr_stmt|;
name|watchfd
argument_list|(
operator|&
name|childExitJob
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|caught_signals
argument_list|)
expr_stmt|;
comment|/*      * Install a SIGCHLD handler.      */
operator|(
name|void
operator|)
name|bmake_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|JobChildSig
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|caught_signals
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
define|#
directive|define
name|ADDSIG
parameter_list|(
name|s
parameter_list|,
name|h
parameter_list|)
define|\
value|if (bmake_signal(s, SIG_IGN) != SIG_IGN) {	\ 	sigaddset(&caught_signals, s);		\ 	(void)bmake_signal(s, h);			\     }
comment|/*      * Catch the four signals that POSIX specifies if they aren't ignored.      * JobPassSig will take care of calling JobInterrupt if appropriate.      */
name|ADDSIG
argument_list|(
argument|SIGINT
argument_list|,
argument|JobPassSig_int
argument_list|)
name|ADDSIG
argument_list|(
argument|SIGHUP
argument_list|,
argument|JobPassSig_term
argument_list|)
name|ADDSIG
argument_list|(
argument|SIGTERM
argument_list|,
argument|JobPassSig_term
argument_list|)
name|ADDSIG
argument_list|(
argument|SIGQUIT
argument_list|,
argument|JobPassSig_term
argument_list|)
comment|/*      * There are additional signals that need to be caught and passed if      * either the export system wants to be told directly of signals or if      * we're giving each job its own process group (since then it won't get      * signals from the terminal driver as we own the terminal)      */
name|ADDSIG
argument_list|(
argument|SIGTSTP
argument_list|,
argument|JobPassSig_suspend
argument_list|)
name|ADDSIG
argument_list|(
argument|SIGTTOU
argument_list|,
argument|JobPassSig_suspend
argument_list|)
name|ADDSIG
argument_list|(
argument|SIGTTIN
argument_list|,
argument|JobPassSig_suspend
argument_list|)
name|ADDSIG
argument_list|(
argument|SIGWINCH
argument_list|,
argument|JobCondPassSig
argument_list|)
name|ADDSIG
argument_list|(
argument|SIGCONT
argument_list|,
argument|JobContinueSig
argument_list|)
undef|#
directive|undef
name|ADDSIG
operator|(
name|void
operator|)
name|Job_RunTarget
argument_list|(
literal|".BEGIN"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|postCommands
operator|=
name|Targ_FindNode
argument_list|(
literal|".END"
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|JobSigReset
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|DELSIG
parameter_list|(
name|s
parameter_list|)
define|\
value|if (sigismember(&caught_signals, s)) {		\ 	(void)bmake_signal(s, SIG_DFL);			\     }
name|DELSIG
argument_list|(
argument|SIGINT
argument_list|)
name|DELSIG
argument_list|(
argument|SIGHUP
argument_list|)
name|DELSIG
argument_list|(
argument|SIGQUIT
argument_list|)
name|DELSIG
argument_list|(
argument|SIGTERM
argument_list|)
name|DELSIG
argument_list|(
argument|SIGTSTP
argument_list|)
name|DELSIG
argument_list|(
argument|SIGTTOU
argument_list|)
name|DELSIG
argument_list|(
argument|SIGTTIN
argument_list|)
name|DELSIG
function_decl|(
name|SIGWINCH
function_decl|)
name|DELSIG
argument_list|(
argument|SIGCONT
argument_list|)
undef|#
directive|undef
name|DELSIG
parameter_list|(
name|void
parameter_list|)
function_decl|bmake_signal
parameter_list|(
name|SIGCHLD
parameter_list|,
name|SIG_DFL
parameter_list|)
function_decl|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobMatchShell --  *	Find a shell in 'shells' given its name.  *  * Results:  *	A pointer to the Shell structure.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Shell
modifier|*
name|JobMatchShell
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Shell
modifier|*
name|sh
decl_stmt|;
for|for
control|(
name|sh
operator|=
name|shells
init|;
name|sh
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sh
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|sh
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|sh
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_ParseShell --  *	Parse a shell specification and set up commandShell, shellPath  *	and shellName appropriately.  *  * Input:  *	line		The shell spec  *  * Results:  *	FAILURE if the specification was incorrect.  *  * Side Effects:  *	commandShell points to a Shell structure (either predefined or  *	created from the shell spec), shellPath is the full path of the  *	shell described by commandShell, while shellName is just the  *	final component of shellPath.  *  * Notes:  *	A shell specification consists of a .SHELL target, with dependency  *	operator, followed by a series of blank-separated words. Double  *	quotes can be used to use blanks in words. A backslash escapes  *	anything (most notably a double-quote and a space) and  *	provides the functionality it does in C. Each word consists of  *	keyword and value separated by an equal sign. There should be no  *	unnecessary spaces in the word. The keywords are as follows:  *	    name  	    Name of shell.  *	    path  	    Location of shell.  *	    quiet 	    Command to turn off echoing.  *	    echo  	    Command to turn echoing on  *	    filter	    Result of turning off echoing that shouldn't be  *	    	  	    printed.  *	    echoFlag	    Flag to turn echoing on at the start  *	    errFlag	    Flag to turn error checking on at the start  *	    hasErrCtl	    True if shell has error checking control  *	    newline	    String literal to represent a newline char  *	    check 	    Command to turn on error checking if hasErrCtl  *	    	  	    is TRUE or template of command to echo a command  *	    	  	    for which error checking is off if hasErrCtl is  *	    	  	    FALSE.  *	    ignore	    Command to turn off error checking if hasErrCtl  *	    	  	    is TRUE or template of command to execute a  *	    	  	    command so as to ignore any errors it returns if  *	    	  	    hasErrCtl is FALSE.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|ReturnStatus
name|Job_ParseShell
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|words
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|Shell
name|newShell
decl_stmt|;
name|Boolean
name|fullSpec
init|=
name|FALSE
decl_stmt|;
name|Shell
modifier|*
name|sh
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|UNCONST
argument_list|(
name|shellArgv
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|newShell
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newShell
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Parse the specification by keyword      */
name|words
operator|=
name|brk_string
argument_list|(
name|line
argument_list|,
operator|&
name|argc
argument_list|,
name|TRUE
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|==
name|NULL
condition|)
block|{
name|Error
argument_list|(
literal|"Unterminated quoted string [%s]"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|shellArgv
operator|=
name|path
expr_stmt|;
for|for
control|(
name|path
operator|=
name|NULL
operator|,
name|argv
operator|=
name|words
init|;
name|argc
operator|!=
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"path="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|path
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|5
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"name="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|name
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|5
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"quiet="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echoOff
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|6
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"echo="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echoOn
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|5
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"filter="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|noPrint
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|7
index|]
expr_stmt|;
name|newShell
operator|.
name|noPLen
operator|=
name|strlen
argument_list|(
name|newShell
operator|.
name|noPrint
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"echoFlag="
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echo
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|9
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"errFlag="
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|exit
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|8
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"hasErrCtl="
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|c
init|=
name|argv
index|[
literal|0
index|]
index|[
literal|10
index|]
decl_stmt|;
name|newShell
operator|.
name|hasErrCtl
operator|=
operator|!
operator|(
operator|(
name|c
operator|!=
literal|'Y'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'y'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'T'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'t'
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"newline="
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|newline
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|8
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"check="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|errCheck
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|6
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"ignore="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|ignErr
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|7
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"errout="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|errOut
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|7
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"comment="
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|commentChar
operator|=
name|argv
index|[
literal|0
index|]
index|[
literal|8
index|]
expr_stmt|;
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unknown keyword \"%s\""
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * If no path was given, the user wants one of the pre-defined shells, 	 * yes? So we find the one s/he wants with the help of JobMatchShell 	 * and set things up the right way. shellPath will be set up by 	 * Shell_Init. 	 */
if|if
condition|(
name|newShell
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Neither path nor name specified"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sh
operator|=
name|JobMatchShell
argument_list|(
name|newShell
operator|.
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"%s: No matching shell"
argument_list|,
name|newShell
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
name|commandShell
operator|=
name|sh
expr_stmt|;
name|shellName
operator|=
name|newShell
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|shellPath
condition|)
block|{
comment|/* Shell_Init has already been called!  Do it again. */
name|free
argument_list|(
name|UNCONST
argument_list|(
name|shellPath
argument_list|)
argument_list|)
expr_stmt|;
name|shellPath
operator|=
name|NULL
expr_stmt|;
name|Shell_Init
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 	 * The user provided a path. If s/he gave nothing else (fullSpec is 	 * FALSE), try and find a matching shell in the ones we know of. 	 * Else we just take the specification at its word and copy it 	 * to a new location. In either case, we need to record the 	 * path the user gave for the shell. 	 */
name|shellPath
operator|=
name|path
expr_stmt|;
name|path
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|path
operator|=
name|UNCONST
argument_list|(
name|shellPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|newShell
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
name|shellName
operator|=
name|newShell
operator|.
name|name
expr_stmt|;
block|}
else|else
block|{
name|shellName
operator|=
name|path
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fullSpec
condition|)
block|{
if|if
condition|(
operator|(
name|sh
operator|=
name|JobMatchShell
argument_list|(
name|shellName
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"%s: No matching shell"
argument_list|,
name|shellName
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
name|commandShell
operator|=
name|sh
expr_stmt|;
block|}
else|else
block|{
name|commandShell
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Shell
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|commandShell
operator|=
name|newShell
expr_stmt|;
block|}
comment|/* this will take care of shellErrFlag */
name|Shell_Init
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|commandShell
operator|->
name|echoOn
operator|&&
name|commandShell
operator|->
name|echoOff
condition|)
block|{
name|commandShell
operator|->
name|hasEchoCtl
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|commandShell
operator|->
name|hasErrCtl
condition|)
block|{
if|if
condition|(
name|commandShell
operator|->
name|errCheck
operator|==
name|NULL
condition|)
block|{
name|commandShell
operator|->
name|errCheck
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|commandShell
operator|->
name|ignErr
operator|==
name|NULL
condition|)
block|{
name|commandShell
operator|->
name|ignErr
operator|=
literal|"%s\n"
expr_stmt|;
block|}
block|}
comment|/*      * Do not free up the words themselves, since they might be in use by the      * shell specification.      */
name|free
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobInterrupt --  *	Handle the receipt of an interrupt.  *  * Input:  *	runINTERRUPT	Non-zero if commands for the .INTERRUPT target  *			should be executed  *	signo		signal received  *  * Results:  *	None  *  * Side Effects:  *	All children are killed. Another job will be started if the  *	.INTERRUPT target was given.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobInterrupt
parameter_list|(
name|int
name|runINTERRUPT
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* job descriptor in that element */
name|GNode
modifier|*
name|interrupt
decl_stmt|;
comment|/* the node describing the .INTERRUPT target */
name|sigset_t
name|mask
decl_stmt|;
name|GNode
modifier|*
name|gn
decl_stmt|;
name|aborting
operator|=
name|ABORT_INTERRUPT
expr_stmt|;
name|JobSigLock
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
name|job
operator|=
name|job_table
init|;
name|job
operator|<
name|job_table_end
condition|;
name|job
operator|++
control|)
block|{
if|if
condition|(
name|job
operator|->
name|job_state
operator|!=
name|JOB_ST_RUNNING
condition|)
continue|continue;
name|gn
operator|=
name|job
operator|->
name|node
expr_stmt|;
name|JobDeleteTarget
argument_list|(
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|pid
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"JobInterrupt passing signal %d to child %d.\n"
argument_list|,
name|signo
argument_list|,
name|job
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
name|KILLPG
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
block|}
name|JobSigUnlock
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|runINTERRUPT
operator|&&
operator|!
name|touchFlag
condition|)
block|{
name|interrupt
operator|=
name|Targ_FindNode
argument_list|(
literal|".INTERRUPT"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupt
operator|!=
name|NULL
condition|)
block|{
name|ignoreErrors
operator|=
name|FALSE
expr_stmt|;
name|JobRun
argument_list|(
name|interrupt
argument_list|)
expr_stmt|;
block|}
block|}
name|Trace_Log
argument_list|(
name|MAKEINTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *-----------------------------------------------------------------------  * Job_Finish --  *	Do final processing such as the running of the commands  *	attached to the .END target.  *  * Results:  *	Number of errors reported.  *  * Side Effects:  *	None.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Job_Finish
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|postCommands
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|postCommands
operator|->
name|commands
argument_list|)
operator|||
operator|!
name|Lst_IsEmpty
argument_list|(
name|postCommands
operator|->
name|children
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|errors
condition|)
block|{
name|Error
argument_list|(
literal|"Errors reported so .END ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|JobRun
argument_list|(
name|postCommands
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|errors
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_End --  *	Cleanup any memory used by the jobs module  *  * Results:  *	None.  *  * Side Effects:  *	Memory is freed  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_End
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CLEANUP
name|free
argument_list|(
name|shellArgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Wait --  *	Waits for all running jobs to finish and returns. Sets 'aborting'  *	to ABORT_WAIT to prevent other jobs from starting.  *  * Results:  *	None.  *  * Side Effects:  *	Currently running jobs finish.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Wait
parameter_list|(
name|void
parameter_list|)
block|{
name|aborting
operator|=
name|ABORT_WAIT
expr_stmt|;
while|while
condition|(
name|jobTokensRunning
operator|!=
literal|0
condition|)
block|{
name|Job_CatchOutput
argument_list|()
expr_stmt|;
block|}
name|aborting
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_AbortAll --  *	Abort all currently running jobs without handling output or anything.  *	This function is to be called only in the event of a major  *	error. Most definitely NOT to be called from JobInterrupt.  *  * Results:  *	None  *  * Side Effects:  *	All children are killed, not just the firstborn  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_AbortAll
parameter_list|(
name|void
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* the job descriptor in that element */
name|WAIT_T
name|foo
decl_stmt|;
name|aborting
operator|=
name|ABORT_ERROR
expr_stmt|;
if|if
condition|(
name|jobTokensRunning
condition|)
block|{
for|for
control|(
name|job
operator|=
name|job_table
init|;
name|job
operator|<
name|job_table_end
condition|;
name|job
operator|++
control|)
block|{
if|if
condition|(
name|job
operator|->
name|job_state
operator|!=
name|JOB_ST_RUNNING
condition|)
continue|continue;
comment|/* 	     * kill the child process with increasingly drastic signals to make 	     * darn sure it's dead. 	     */
name|KILLPG
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|KILLPG
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Catch as many children as want to report in at first, then give up      */
while|while
condition|(
name|waitpid
argument_list|(
operator|(
name|pid_t
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|foo
argument_list|,
name|WNOHANG
argument_list|)
operator|>
literal|0
condition|)
continue|continue;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobRestartJobs --  *	Tries to restart stopped jobs if there are slots available.  *	Called in process context in response to a SIGCONT.  *  * Results:  *	None.  *  * Side Effects:  *	Resumes jobs.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobRestartJobs
parameter_list|(
name|void
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
for|for
control|(
name|job
operator|=
name|job_table
init|;
name|job
operator|<
name|job_table_end
condition|;
name|job
operator|++
control|)
block|{
if|if
condition|(
name|job
operator|->
name|job_state
operator|==
name|JOB_ST_RUNNING
operator|&&
operator|(
name|make_suspended
operator|||
name|job
operator|->
name|job_suspended
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Restarting stopped job pid %d.\n"
argument_list|,
name|job
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|job
operator|->
name|job_suspended
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*** [%s] Continued\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|job_suspended
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|KILLPG
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGCONT
argument_list|)
operator|!=
literal|0
operator|&&
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Failed to send SIGCONT to %d\n"
argument_list|,
name|job
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|job
operator|->
name|job_state
operator|==
name|JOB_ST_FINISHED
condition|)
comment|/* Job exit deferred after calling waitpid() in a signal handler */
name|JobFinish
argument_list|(
name|job
argument_list|,
name|job
operator|->
name|exit_status
argument_list|)
expr_stmt|;
block|}
name|make_suspended
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|watchfd
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|)
block|{
if|if
condition|(
name|job
operator|->
name|inPollfd
operator|!=
name|NULL
condition|)
name|Punt
argument_list|(
literal|"Watching watched job"
argument_list|)
expr_stmt|;
name|fds
index|[
name|nfds
index|]
operator|.
name|fd
operator|=
name|job
operator|->
name|inPipe
expr_stmt|;
name|fds
index|[
name|nfds
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|jobfds
index|[
name|nfds
index|]
operator|=
name|job
expr_stmt|;
name|job
operator|->
name|inPollfd
operator|=
operator|&
name|fds
index|[
name|nfds
index|]
expr_stmt|;
name|nfds
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clearfd
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|job
operator|->
name|inPollfd
operator|==
name|NULL
condition|)
name|Punt
argument_list|(
literal|"Unwatching unwatched job"
argument_list|)
expr_stmt|;
name|i
operator|=
name|job
operator|->
name|inPollfd
operator|-
name|fds
expr_stmt|;
name|nfds
operator|--
expr_stmt|;
comment|/*      * Move last job in table into hole made by dead job.      */
if|if
condition|(
name|nfds
operator|!=
name|i
condition|)
block|{
name|fds
index|[
name|i
index|]
operator|=
name|fds
index|[
name|nfds
index|]
expr_stmt|;
name|jobfds
index|[
name|i
index|]
operator|=
name|jobfds
index|[
name|nfds
index|]
expr_stmt|;
name|jobfds
index|[
name|i
index|]
operator|->
name|inPollfd
operator|=
operator|&
name|fds
index|[
name|i
index|]
expr_stmt|;
block|}
name|job
operator|->
name|inPollfd
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|readyfd
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|)
block|{
if|if
condition|(
name|job
operator|->
name|inPollfd
operator|==
name|NULL
condition|)
name|Punt
argument_list|(
literal|"Polling unwatched job"
argument_list|)
expr_stmt|;
return|return
operator|(
name|job
operator|->
name|inPollfd
operator|->
name|revents
operator|&
name|POLLIN
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobTokenAdd --  *	Put a token into the job pipe so that some make process can start  *	another job.  *  * Side Effects:  *	Allows more build jobs to be spawned somewhere.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobTokenAdd
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|tok
init|=
name|JOB_TOKENS
index|[
name|aborting
index|]
decl_stmt|,
name|tok1
decl_stmt|;
comment|/* If we are depositing an error token flush everything else */
while|while
condition|(
name|tok
operator|!=
literal|'+'
operator|&&
name|read
argument_list|(
name|tokenWaitJob
operator|.
name|inPipe
argument_list|,
operator|&
name|tok1
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"(%d) aborting %d, deposit token %c\n"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|aborting
argument_list|,
name|JOB_TOKENS
index|[
name|aborting
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|write
argument_list|(
name|tokenWaitJob
operator|.
name|outPipe
argument_list|,
operator|&
name|tok
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_ServerStartTokenAdd --  *	Prep the job token pipe in the root make process.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_ServerStart
parameter_list|(
name|int
name|max_tokens
parameter_list|,
name|int
name|jp_0
parameter_list|,
name|int
name|jp_1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|jobarg
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|jp_0
operator|>=
literal|0
operator|&&
name|jp_1
operator|>=
literal|0
condition|)
block|{
comment|/* Pipe passed in from parent */
name|tokenWaitJob
operator|.
name|inPipe
operator|=
name|jp_0
expr_stmt|;
name|tokenWaitJob
operator|.
name|outPipe
operator|=
name|jp_1
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|jp_0
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|jp_1
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
return|return;
block|}
name|JobCreatePipe
argument_list|(
operator|&
name|tokenWaitJob
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|jobarg
argument_list|,
sizeof|sizeof
argument_list|(
name|jobarg
argument_list|)
argument_list|,
literal|"%d,%d"
argument_list|,
name|tokenWaitJob
operator|.
name|inPipe
argument_list|,
name|tokenWaitJob
operator|.
name|outPipe
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-J"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
name|jobarg
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
comment|/*      * Preload the job pipe with one token per job, save the one      * "extra" token for the primary job.      *       * XXX should clip maxJobs against PIPE_BUF -- if max_tokens is      * larger than the write buffer size of the pipe, we will      * deadlock here.      */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|max_tokens
condition|;
name|i
operator|++
control|)
name|JobTokenAdd
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_TokenReturn --  *	Return a withdrawn token to the pool.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_TokenReturn
parameter_list|(
name|void
parameter_list|)
block|{
name|jobTokensRunning
operator|--
expr_stmt|;
if|if
condition|(
name|jobTokensRunning
operator|<
literal|0
condition|)
name|Punt
argument_list|(
literal|"token botch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobTokensRunning
operator|||
name|JOB_TOKENS
index|[
name|aborting
index|]
operator|!=
literal|'+'
condition|)
name|JobTokenAdd
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_TokenWithdraw --  *	Attempt to withdraw a token from the pool.  *  * Results:  *	Returns TRUE if a token was withdrawn, and FALSE if the pool  *	is currently empty.  *  * Side Effects:  * 	If pool is empty, set wantToken so that we wake up  *	when a token is released.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Job_TokenWithdraw
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|tok
decl_stmt|,
name|tok1
decl_stmt|;
name|int
name|count
decl_stmt|;
name|wantToken
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Job_TokenWithdraw(%d): aborting %d, running %d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|aborting
argument_list|,
name|jobTokensRunning
argument_list|)
expr_stmt|;
if|if
condition|(
name|aborting
operator|||
operator|(
name|jobTokensRunning
operator|>=
name|maxJobs
operator|)
condition|)
return|return
name|FALSE
return|;
name|count
operator|=
name|read
argument_list|(
name|tokenWaitJob
operator|.
name|inPipe
argument_list|,
operator|&
name|tok
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|Fatal
argument_list|(
literal|"eof on job pipe!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
operator|&&
name|jobTokensRunning
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|Fatal
argument_list|(
literal|"job pipe read: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"(%d) blocked for token\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|wantToken
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|count
operator|==
literal|1
operator|&&
name|tok
operator|!=
literal|'+'
condition|)
block|{
comment|/* make being abvorted - remove any other job tokens */
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"(%d) aborted by token %c\n"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|tok
argument_list|)
expr_stmt|;
while|while
condition|(
name|read
argument_list|(
name|tokenWaitJob
operator|.
name|inPipe
argument_list|,
operator|&
name|tok1
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
continue|continue;
comment|/* And put the stopper back */
while|while
condition|(
name|write
argument_list|(
name|tokenWaitJob
operator|.
name|outPipe
argument_list|,
operator|&
name|tok
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
name|Fatal
argument_list|(
literal|"A failure has been detected in another branch of the parallel make"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|1
operator|&&
name|jobTokensRunning
operator|==
literal|0
condition|)
comment|/* We didn't want the token really */
while|while
condition|(
name|write
argument_list|(
name|tokenWaitJob
operator|.
name|outPipe
argument_list|,
operator|&
name|tok
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
name|jobTokensRunning
operator|++
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"(%d) withdrew token\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_RunTarget --  *	Run the named target if found. If a filename is specified, then  *	set that to the sources.  *  * Results:  *	None  *  * Side Effects:  * 	exits if the target fails.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Job_RunTarget
parameter_list|(
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
name|Targ_FindNode
argument_list|(
name|target
argument_list|,
name|TARG_NOCREATE
argument_list|)
decl_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fname
condition|)
name|Var_Set
argument_list|(
name|ALLSRC
argument_list|,
name|fname
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|JobRun
argument_list|(
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|ERROR
condition|)
block|{
name|PrintOnError
argument_list|(
name|gn
argument_list|,
literal|"\n\nStop."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_SELECT
end_ifdef

begin_function
name|int
name|emul_poll
parameter_list|(
name|struct
name|pollfd
modifier|*
name|fd
parameter_list|,
name|int
name|nfd
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|fd_set
name|rfds
decl_stmt|,
name|wfds
decl_stmt|;
name|int
name|i
decl_stmt|,
name|maxfd
decl_stmt|,
name|nselect
decl_stmt|,
name|npoll
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|long
name|usecs
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|rfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|wfds
argument_list|)
expr_stmt|;
name|maxfd
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfd
condition|;
name|i
operator|++
control|)
block|{
name|fd
index|[
name|i
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fd
index|[
name|i
index|]
operator|.
name|events
operator|&
name|POLLIN
condition|)
name|FD_SET
argument_list|(
name|fd
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|rfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
index|[
name|i
index|]
operator|.
name|events
operator|&
name|POLLOUT
condition|)
name|FD_SET
argument_list|(
name|fd
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|wfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
index|[
name|i
index|]
operator|.
name|fd
operator|>
name|maxfd
condition|)
name|maxfd
operator|=
name|fd
index|[
name|i
index|]
operator|.
name|fd
expr_stmt|;
block|}
if|if
condition|(
name|maxfd
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|Punt
argument_list|(
literal|"Ran out of fd_set slots; "
literal|"recompile with a larger FD_SETSIZE."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
block|{
name|tvp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|usecs
operator|=
name|timeout
operator|*
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|usecs
operator|/
literal|1000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|usecs
operator|%
literal|1000000
expr_stmt|;
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
block|}
name|nselect
operator|=
name|select
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
operator|&
name|rfds
argument_list|,
operator|&
name|wfds
argument_list|,
literal|0
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nselect
operator|<=
literal|0
condition|)
return|return
name|nselect
return|;
name|npoll
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|rfds
argument_list|)
condition|)
name|fd
index|[
name|i
index|]
operator|.
name|revents
operator||=
name|POLLIN
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|wfds
argument_list|)
condition|)
name|fd
index|[
name|i
index|]
operator|.
name|revents
operator||=
name|POLLOUT
expr_stmt|;
if|if
condition|(
name|fd
index|[
name|i
index|]
operator|.
name|revents
condition|)
name|npoll
operator|++
expr_stmt|;
block|}
return|return
name|npoll
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_SELECT */
end_comment

end_unit

