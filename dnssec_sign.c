begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ldns/config.h>
end_include

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_include
include|#
directive|include
file|<ldns/dnssec.h>
end_include

begin_include
include|#
directive|include
file|<ldns/dnssec_sign.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_comment
comment|/* this entire file is rather useless when you don't have  * crypto...  */
end_comment

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/evp.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/md5.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

begin_function
name|ldns_rr
modifier|*
name|ldns_create_empty_rrsig
parameter_list|(
name|ldns_rr_list
modifier|*
name|rrset
parameter_list|,
name|ldns_key
modifier|*
name|current_key
parameter_list|)
block|{
name|uint32_t
name|orig_ttl
decl_stmt|;
name|ldns_rr_class
name|orig_class
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|ldns_rr
modifier|*
name|current_sig
decl_stmt|;
name|uint8_t
name|label_count
decl_stmt|;
name|ldns_rdf
modifier|*
name|signame
decl_stmt|;
name|label_count
operator|=
name|ldns_dname_label_count
argument_list|(
name|ldns_rr_owner
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|rrset
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* RFC4035 2.2: not counting the leftmost label if it is a wildcard */
if|if
condition|(
name|ldns_dname_is_wildcard
argument_list|(
name|ldns_rr_owner
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|rrset
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|label_count
operator|--
expr_stmt|;
name|current_sig
operator|=
name|ldns_rr_new_frm_type
argument_list|(
name|LDNS_RR_TYPE_RRSIG
argument_list|)
expr_stmt|;
comment|/* set the type on the new signature */
name|orig_ttl
operator|=
name|ldns_rr_ttl
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|rrset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|orig_class
operator|=
name|ldns_rr_get_class
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|rrset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_rr_set_ttl
argument_list|(
name|current_sig
argument_list|,
name|orig_ttl
argument_list|)
expr_stmt|;
name|ldns_rr_set_class
argument_list|(
name|current_sig
argument_list|,
name|orig_class
argument_list|)
expr_stmt|;
name|ldns_rr_set_owner
argument_list|(
name|current_sig
argument_list|,
name|ldns_rdf_clone
argument_list|(
name|ldns_rr_owner
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|rrset
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in what we know of the signature */
comment|/* set the orig_ttl */
operator|(
name|void
operator|)
name|ldns_rr_rrsig_set_origttl
argument_list|(
name|current_sig
argument_list|,
name|ldns_native2rdf_int32
argument_list|(
name|LDNS_RDF_TYPE_INT32
argument_list|,
name|orig_ttl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the signers name */
name|signame
operator|=
name|ldns_rdf_clone
argument_list|(
name|ldns_key_pubkey_owner
argument_list|(
name|current_key
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_dname2canonical
argument_list|(
name|signame
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldns_rr_rrsig_set_signame
argument_list|(
name|current_sig
argument_list|,
name|signame
argument_list|)
expr_stmt|;
comment|/* label count - get it from the first rr in the rr_list */
operator|(
name|void
operator|)
name|ldns_rr_rrsig_set_labels
argument_list|(
name|current_sig
argument_list|,
name|ldns_native2rdf_int8
argument_list|(
name|LDNS_RDF_TYPE_INT8
argument_list|,
name|label_count
argument_list|)
argument_list|)
expr_stmt|;
comment|/* inception, expiration */
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_key_inception
argument_list|(
name|current_key
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ldns_rr_rrsig_set_inception
argument_list|(
name|current_sig
argument_list|,
name|ldns_native2rdf_int32
argument_list|(
name|LDNS_RDF_TYPE_TIME
argument_list|,
name|ldns_key_inception
argument_list|(
name|current_key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|ldns_rr_rrsig_set_inception
argument_list|(
name|current_sig
argument_list|,
name|ldns_native2rdf_int32
argument_list|(
name|LDNS_RDF_TYPE_TIME
argument_list|,
name|now
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ldns_key_expiration
argument_list|(
name|current_key
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ldns_rr_rrsig_set_expiration
argument_list|(
name|current_sig
argument_list|,
name|ldns_native2rdf_int32
argument_list|(
name|LDNS_RDF_TYPE_TIME
argument_list|,
name|ldns_key_expiration
argument_list|(
name|current_key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|ldns_rr_rrsig_set_expiration
argument_list|(
name|current_sig
argument_list|,
name|ldns_native2rdf_int32
argument_list|(
name|LDNS_RDF_TYPE_TIME
argument_list|,
name|now
operator|+
name|LDNS_DEFAULT_EXP_TIME
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ldns_rr_rrsig_set_keytag
argument_list|(
name|current_sig
argument_list|,
name|ldns_native2rdf_int16
argument_list|(
name|LDNS_RDF_TYPE_INT16
argument_list|,
name|ldns_key_keytag
argument_list|(
name|current_key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldns_rr_rrsig_set_algorithm
argument_list|(
name|current_sig
argument_list|,
name|ldns_native2rdf_int8
argument_list|(
name|LDNS_RDF_TYPE_ALG
argument_list|,
name|ldns_key_algorithm
argument_list|(
name|current_key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldns_rr_rrsig_set_typecovered
argument_list|(
name|current_sig
argument_list|,
name|ldns_native2rdf_int16
argument_list|(
name|LDNS_RDF_TYPE_TYPE
argument_list|,
name|ldns_rr_get_type
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|rrset
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|current_sig
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_function
name|ldns_rdf
modifier|*
name|ldns_sign_public_buffer
parameter_list|(
name|ldns_buffer
modifier|*
name|sign_buf
parameter_list|,
name|ldns_key
modifier|*
name|current_key
parameter_list|)
block|{
name|ldns_rdf
modifier|*
name|b64rdf
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|ldns_key_algorithm
argument_list|(
name|current_key
argument_list|)
condition|)
block|{
case|case
name|LDNS_SIGN_DSA
case|:
case|case
name|LDNS_SIGN_DSA_NSEC3
case|:
name|b64rdf
operator|=
name|ldns_sign_public_evp
argument_list|(
name|sign_buf
argument_list|,
name|ldns_key_evp_key
argument_list|(
name|current_key
argument_list|)
argument_list|,
name|EVP_dss1
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_SIGN_RSASHA1
case|:
case|case
name|LDNS_SIGN_RSASHA1_NSEC3
case|:
name|b64rdf
operator|=
name|ldns_sign_public_evp
argument_list|(
name|sign_buf
argument_list|,
name|ldns_key_evp_key
argument_list|(
name|current_key
argument_list|)
argument_list|,
name|EVP_sha1
argument_list|()
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_SIGN_RSASHA256
case|:
name|b64rdf
operator|=
name|ldns_sign_public_evp
argument_list|(
name|sign_buf
argument_list|,
name|ldns_key_evp_key
argument_list|(
name|current_key
argument_list|)
argument_list|,
name|EVP_sha256
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_SIGN_RSASHA512
case|:
name|b64rdf
operator|=
name|ldns_sign_public_evp
argument_list|(
name|sign_buf
argument_list|,
name|ldns_key_evp_key
argument_list|(
name|current_key
argument_list|)
argument_list|,
name|EVP_sha512
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* USE_SHA2 */
ifdef|#
directive|ifdef
name|USE_GOST
case|case
name|LDNS_SIGN_ECC_GOST
case|:
name|b64rdf
operator|=
name|ldns_sign_public_evp
argument_list|(
name|sign_buf
argument_list|,
name|ldns_key_evp_key
argument_list|(
name|current_key
argument_list|)
argument_list|,
name|EVP_get_digestbyname
argument_list|(
literal|"md_gost94"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* USE_GOST */
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SIGN_ECDSAP256SHA256
case|:
name|b64rdf
operator|=
name|ldns_sign_public_evp
argument_list|(
name|sign_buf
argument_list|,
name|ldns_key_evp_key
argument_list|(
name|current_key
argument_list|)
argument_list|,
name|EVP_sha256
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_SIGN_ECDSAP384SHA384
case|:
name|b64rdf
operator|=
name|ldns_sign_public_evp
argument_list|(
name|sign_buf
argument_list|,
name|ldns_key_evp_key
argument_list|(
name|current_key
argument_list|)
argument_list|,
name|EVP_sha384
argument_list|()
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|LDNS_SIGN_RSAMD5
case|:
name|b64rdf
operator|=
name|ldns_sign_public_evp
argument_list|(
name|sign_buf
argument_list|,
name|ldns_key_evp_key
argument_list|(
name|current_key
argument_list|)
argument_list|,
name|EVP_md5
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* do _you_ know this alg? */
name|printf
argument_list|(
literal|"unknown algorithm, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"is the one used available on this system?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|b64rdf
return|;
block|}
end_function

begin_comment
comment|/**  * use this function to sign with a public/private key alg  * return the created signatures  */
end_comment

begin_function
name|ldns_rr_list
modifier|*
name|ldns_sign_public
parameter_list|(
name|ldns_rr_list
modifier|*
name|rrset
parameter_list|,
name|ldns_key_list
modifier|*
name|keys
parameter_list|)
block|{
name|ldns_rr_list
modifier|*
name|signatures
decl_stmt|;
name|ldns_rr_list
modifier|*
name|rrset_clone
decl_stmt|;
name|ldns_rr
modifier|*
name|current_sig
decl_stmt|;
name|ldns_rdf
modifier|*
name|b64rdf
decl_stmt|;
name|ldns_key
modifier|*
name|current_key
decl_stmt|;
name|size_t
name|key_count
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|ldns_buffer
modifier|*
name|sign_buf
decl_stmt|;
name|ldns_rdf
modifier|*
name|new_owner
decl_stmt|;
if|if
condition|(
operator|!
name|rrset
operator|||
name|ldns_rr_list_rr_count
argument_list|(
name|rrset
argument_list|)
operator|<
literal|1
operator|||
operator|!
name|keys
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|new_owner
operator|=
name|NULL
expr_stmt|;
name|signatures
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
comment|/* prepare a signature and add all the know data 	 * prepare the rrset. Sign this together.  */
name|rrset_clone
operator|=
name|ldns_rr_list_clone
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rrset_clone
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* make it canonical */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|rrset_clone
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ldns_rr_set_ttl
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|rrset_clone
argument_list|,
name|i
argument_list|)
argument_list|,
name|ldns_rr_ttl
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|rrset
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_rr2canonical
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|rrset_clone
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* sort */
name|ldns_rr_list_sort
argument_list|(
name|rrset_clone
argument_list|)
expr_stmt|;
for|for
control|(
name|key_count
operator|=
literal|0
init|;
name|key_count
operator|<
name|ldns_key_list_key_count
argument_list|(
name|keys
argument_list|)
condition|;
name|key_count
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ldns_key_use
argument_list|(
name|ldns_key_list_key
argument_list|(
name|keys
argument_list|,
name|key_count
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|sign_buf
operator|=
name|ldns_buffer_new
argument_list|(
name|LDNS_MAX_PACKETLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sign_buf
condition|)
block|{
name|ldns_rr_list_free
argument_list|(
name|rrset_clone
argument_list|)
expr_stmt|;
name|ldns_rr_list_free
argument_list|(
name|signatures
argument_list|)
expr_stmt|;
name|ldns_rdf_free
argument_list|(
name|new_owner
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|b64rdf
operator|=
name|NULL
expr_stmt|;
name|current_key
operator|=
name|ldns_key_list_key
argument_list|(
name|keys
argument_list|,
name|key_count
argument_list|)
expr_stmt|;
comment|/* sign all RRs with keys that have ZSKbit, !SEPbit. 		   sign DNSKEY RRs with keys that have ZSKbit&SEPbit */
if|if
condition|(
name|ldns_key_flags
argument_list|(
name|current_key
argument_list|)
operator|&
name|LDNS_KEY_ZONE_KEY
condition|)
block|{
name|current_sig
operator|=
name|ldns_create_empty_rrsig
argument_list|(
name|rrset_clone
argument_list|,
name|current_key
argument_list|)
expr_stmt|;
comment|/* right now, we have: a key, a semi-sig and an rrset. For 			 * which we can create the sig and base64 encode that and 			 * add that to the signature */
if|if
condition|(
name|ldns_rrsig2buffer_wire
argument_list|(
name|sign_buf
argument_list|,
name|current_sig
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_buffer_free
argument_list|(
name|sign_buf
argument_list|)
expr_stmt|;
comment|/* ERROR */
name|ldns_rr_list_deep_free
argument_list|(
name|rrset_clone
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|current_sig
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|signatures
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* add the rrset in sign_buf */
if|if
condition|(
name|ldns_rr_list2buffer_wire
argument_list|(
name|sign_buf
argument_list|,
name|rrset_clone
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_buffer_free
argument_list|(
name|sign_buf
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|rrset_clone
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|current_sig
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|signatures
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|b64rdf
operator|=
name|ldns_sign_public_buffer
argument_list|(
name|sign_buf
argument_list|,
name|current_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b64rdf
condition|)
block|{
comment|/* signing went wrong */
name|ldns_rr_list_deep_free
argument_list|(
name|rrset_clone
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|current_sig
argument_list|)
expr_stmt|;
name|ldns_rr_list_deep_free
argument_list|(
name|signatures
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ldns_rr_rrsig_set_sig
argument_list|(
name|current_sig
argument_list|,
name|b64rdf
argument_list|)
expr_stmt|;
comment|/* push the signature to the signatures list */
name|ldns_rr_list_push_rr
argument_list|(
name|signatures
argument_list|,
name|current_sig
argument_list|)
expr_stmt|;
block|}
name|ldns_buffer_free
argument_list|(
name|sign_buf
argument_list|)
expr_stmt|;
comment|/* restart for the next key */
block|}
name|ldns_rr_list_deep_free
argument_list|(
name|rrset_clone
argument_list|)
expr_stmt|;
return|return
name|signatures
return|;
block|}
end_function

begin_comment
comment|/**  * Sign data with DSA  *  * \param[in] to_sign The ldns_buffer containing raw data that is  *                    to be signed  * \param[in] key The DSA key structure to sign with  * \return ldns_rdf for the RRSIG ldns_rr  */
end_comment

begin_function
name|ldns_rdf
modifier|*
name|ldns_sign_public_dsa
parameter_list|(
name|ldns_buffer
modifier|*
name|to_sign
parameter_list|,
name|DSA
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|sha1_hash
decl_stmt|;
name|ldns_rdf
modifier|*
name|sigdata_rdf
decl_stmt|;
name|ldns_buffer
modifier|*
name|b64sig
decl_stmt|;
name|DSA_SIG
modifier|*
name|sig
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|size_t
name|pad
decl_stmt|;
name|b64sig
operator|=
name|ldns_buffer_new
argument_list|(
name|LDNS_MAX_PACKETLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b64sig
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|sha1_hash
operator|=
name|SHA1
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|to_sign
argument_list|)
argument_list|,
name|ldns_buffer_position
argument_list|(
name|to_sign
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sha1_hash
condition|)
block|{
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sig
operator|=
name|DSA_do_sign
argument_list|(
name|sha1_hash
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sig
condition|)
block|{
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|data
operator|=
name|LDNS_XMALLOC
argument_list|(
name|uint8_t
argument_list|,
literal|1
operator|+
literal|2
operator|*
name|SHA_DIGEST_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sig
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|data
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|pad
operator|=
literal|20
operator|-
operator|(
name|size_t
operator|)
name|BN_num_bytes
argument_list|(
name|sig
operator|->
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|data
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|pad
argument_list|)
expr_stmt|;
block|}
name|BN_bn2bin
argument_list|(
name|sig
operator|->
name|r
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|data
operator|+
literal|1
operator|)
operator|+
name|pad
argument_list|)
expr_stmt|;
name|pad
operator|=
literal|20
operator|-
operator|(
name|size_t
operator|)
name|BN_num_bytes
argument_list|(
name|sig
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|data
operator|+
literal|1
operator|+
name|SHA_DIGEST_LENGTH
argument_list|,
literal|0
argument_list|,
name|pad
argument_list|)
expr_stmt|;
block|}
name|BN_bn2bin
argument_list|(
name|sig
operator|->
name|s
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|data
operator|+
literal|1
operator|+
name|SHA_DIGEST_LENGTH
operator|+
name|pad
operator|)
argument_list|)
expr_stmt|;
name|sigdata_rdf
operator|=
name|ldns_rdf_new_frm_data
argument_list|(
name|LDNS_RDF_TYPE_B64
argument_list|,
literal|1
operator|+
literal|2
operator|*
name|SHA_DIGEST_LENGTH
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
name|LDNS_FREE
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|sig
argument_list|)
expr_stmt|;
return|return
name|sigdata_rdf
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ECDSA
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|S_SPLINT_S
end_ifndef

begin_function
specifier|static
name|int
name|ldns_pkey_is_ecdsa
parameter_list|(
name|EVP_PKEY
modifier|*
name|pkey
parameter_list|)
block|{
name|EC_KEY
modifier|*
name|ec
decl_stmt|;
specifier|const
name|EC_GROUP
modifier|*
name|g
decl_stmt|;
if|if
condition|(
name|EVP_PKEY_type
argument_list|(
name|pkey
operator|->
name|type
argument_list|)
operator|!=
name|EVP_PKEY_EC
condition|)
return|return
literal|0
return|;
name|ec
operator|=
name|EVP_PKEY_get1_EC_KEY
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|g
operator|=
name|EC_KEY_get0_group
argument_list|(
name|ec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g
condition|)
block|{
name|EC_KEY_free
argument_list|(
name|ec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|EC_GROUP_get_curve_name
argument_list|(
name|g
argument_list|)
operator|==
name|NID_secp224r1
operator|||
name|EC_GROUP_get_curve_name
argument_list|(
name|g
argument_list|)
operator|==
name|NID_X9_62_prime256v1
operator|||
name|EC_GROUP_get_curve_name
argument_list|(
name|g
argument_list|)
operator|==
name|NID_secp384r1
condition|)
block|{
name|EC_KEY_free
argument_list|(
name|ec
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* downref the eckey, the original is still inside the pkey */
name|EC_KEY_free
argument_list|(
name|ec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* splint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_ECDSA */
end_comment

begin_function
name|ldns_rdf
modifier|*
name|ldns_sign_public_evp
parameter_list|(
name|ldns_buffer
modifier|*
name|to_sign
parameter_list|,
name|EVP_PKEY
modifier|*
name|key
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
name|digest_type
parameter_list|)
block|{
name|unsigned
name|int
name|siglen
decl_stmt|;
name|ldns_rdf
modifier|*
name|sigdata_rdf
decl_stmt|;
name|ldns_buffer
modifier|*
name|b64sig
decl_stmt|;
name|EVP_MD_CTX
name|ctx
decl_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|md_type
decl_stmt|;
name|int
name|r
decl_stmt|;
name|siglen
operator|=
literal|0
expr_stmt|;
name|b64sig
operator|=
name|ldns_buffer_new
argument_list|(
name|LDNS_MAX_PACKETLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b64sig
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* initializes a signing context */
name|md_type
operator|=
name|digest_type
expr_stmt|;
if|if
condition|(
operator|!
name|md_type
condition|)
block|{
comment|/* unknown message difest */
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|r
operator|=
name|EVP_SignInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|md_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|1
condition|)
block|{
name|r
operator|=
name|EVP_SignUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|to_sign
argument_list|)
argument_list|,
name|ldns_buffer_position
argument_list|(
name|to_sign
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|r
operator|==
literal|1
condition|)
block|{
name|r
operator|=
name|EVP_SignFinal
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|b64sig
argument_list|)
argument_list|,
operator|&
name|siglen
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|r
operator|!=
literal|1
condition|)
block|{
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* unfortunately, OpenSSL output is differenct from DNS DSA format */
ifndef|#
directive|ifndef
name|S_SPLINT_S
if|if
condition|(
name|EVP_PKEY_type
argument_list|(
name|key
operator|->
name|type
argument_list|)
operator|==
name|EVP_PKEY_DSA
condition|)
block|{
name|sigdata_rdf
operator|=
name|ldns_convert_dsa_rrsig_asn12rdf
argument_list|(
name|b64sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ECDSA
block|}
elseif|else
if|if
condition|(
name|EVP_PKEY_type
argument_list|(
name|key
operator|->
name|type
argument_list|)
operator|==
name|EVP_PKEY_EC
operator|&&
name|ldns_pkey_is_ecdsa
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|sigdata_rdf
operator|=
name|ldns_convert_ecdsa_rrsig_asn12rdf
argument_list|(
name|b64sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* ok output for other types is the same */
name|sigdata_rdf
operator|=
name|ldns_rdf_new_frm_data
argument_list|(
name|LDNS_RDF_TYPE_B64
argument_list|,
name|siglen
argument_list|,
name|ldns_buffer_begin
argument_list|(
name|b64sig
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* splint */
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
return|return
name|sigdata_rdf
return|;
block|}
end_function

begin_function
name|ldns_rdf
modifier|*
name|ldns_sign_public_rsasha1
parameter_list|(
name|ldns_buffer
modifier|*
name|to_sign
parameter_list|,
name|RSA
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|sha1_hash
decl_stmt|;
name|unsigned
name|int
name|siglen
decl_stmt|;
name|ldns_rdf
modifier|*
name|sigdata_rdf
decl_stmt|;
name|ldns_buffer
modifier|*
name|b64sig
decl_stmt|;
name|int
name|result
decl_stmt|;
name|siglen
operator|=
literal|0
expr_stmt|;
name|b64sig
operator|=
name|ldns_buffer_new
argument_list|(
name|LDNS_MAX_PACKETLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b64sig
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|sha1_hash
operator|=
name|SHA1
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|to_sign
argument_list|)
argument_list|,
name|ldns_buffer_position
argument_list|(
name|to_sign
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sha1_hash
condition|)
block|{
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|result
operator|=
name|RSA_sign
argument_list|(
name|NID_sha1
argument_list|,
name|sha1_hash
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|b64sig
argument_list|)
argument_list|,
operator|&
name|siglen
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|1
condition|)
block|{
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sigdata_rdf
operator|=
name|ldns_rdf_new_frm_data
argument_list|(
name|LDNS_RDF_TYPE_B64
argument_list|,
name|siglen
argument_list|,
name|ldns_buffer_begin
argument_list|(
name|b64sig
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
comment|/* can't free this buffer ?? */
return|return
name|sigdata_rdf
return|;
block|}
end_function

begin_function
name|ldns_rdf
modifier|*
name|ldns_sign_public_rsamd5
parameter_list|(
name|ldns_buffer
modifier|*
name|to_sign
parameter_list|,
name|RSA
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|md5_hash
decl_stmt|;
name|unsigned
name|int
name|siglen
decl_stmt|;
name|ldns_rdf
modifier|*
name|sigdata_rdf
decl_stmt|;
name|ldns_buffer
modifier|*
name|b64sig
decl_stmt|;
name|b64sig
operator|=
name|ldns_buffer_new
argument_list|(
name|LDNS_MAX_PACKETLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b64sig
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|md5_hash
operator|=
name|MD5
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|to_sign
argument_list|)
argument_list|,
name|ldns_buffer_position
argument_list|(
name|to_sign
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|md5_hash
condition|)
block|{
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|RSA_sign
argument_list|(
name|NID_md5
argument_list|,
name|md5_hash
argument_list|,
name|MD5_DIGEST_LENGTH
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ldns_buffer_begin
argument_list|(
name|b64sig
argument_list|)
argument_list|,
operator|&
name|siglen
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|sigdata_rdf
operator|=
name|ldns_rdf_new_frm_data
argument_list|(
name|LDNS_RDF_TYPE_B64
argument_list|,
name|siglen
argument_list|,
name|ldns_buffer_begin
argument_list|(
name|b64sig
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_buffer_free
argument_list|(
name|b64sig
argument_list|)
expr_stmt|;
return|return
name|sigdata_rdf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

begin_comment
comment|/**  * Pushes all rrs from the rrsets of type A and AAAA on gluelist.  */
end_comment

begin_function
specifier|static
name|ldns_status
name|ldns_dnssec_addresses_on_glue_list
parameter_list|(
name|ldns_dnssec_rrsets
modifier|*
name|cur_rrset
parameter_list|,
name|ldns_rr_list
modifier|*
name|glue_list
parameter_list|)
block|{
name|ldns_dnssec_rrs
modifier|*
name|cur_rrs
decl_stmt|;
while|while
condition|(
name|cur_rrset
condition|)
block|{
if|if
condition|(
name|cur_rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_A
operator|||
name|cur_rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
block|{
for|for
control|(
name|cur_rrs
operator|=
name|cur_rrset
operator|->
name|rrs
init|;
name|cur_rrs
condition|;
name|cur_rrs
operator|=
name|cur_rrs
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cur_rrs
operator|->
name|rr
condition|)
block|{
if|if
condition|(
operator|!
name|ldns_rr_list_push_rr
argument_list|(
name|glue_list
argument_list|,
name|cur_rrs
operator|->
name|rr
argument_list|)
condition|)
block|{
return|return
name|LDNS_STATUS_MEM_ERR
return|;
comment|/* ldns_rr_list_push_rr() 						 * returns false when unable 						 * to increase the capacity 						 * of the ldsn_rr_list 						 */
block|}
block|}
block|}
block|}
name|cur_rrset
operator|=
name|cur_rrset
operator|->
name|next
expr_stmt|;
block|}
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/**  * Marks the names in the zone that are occluded. Those names will be skipped  * when walking the tree with the ldns_dnssec_name_node_next_nonglue()  * function. But watch out! Names that are partially occluded (like glue with  * the same name as the delegation) will not be marked and should specifically   * be taken into account seperately.  *  * When glue_list is given (not NULL), in the process of marking the names, all  * glue resource records will be pushed to that list, even glue at delegation names.  *  * \param[in] zone the zone in which to mark the names  * \param[in] glue_list the list to which to push the glue rrs  * \return LDNS_STATUS_OK on success, an error code otherwise  */
end_comment

begin_function
name|ldns_status
name|ldns_dnssec_zone_mark_and_get_glue
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|glue_list
parameter_list|)
block|{
name|ldns_rbnode_t
modifier|*
name|node
decl_stmt|;
name|ldns_dnssec_name
modifier|*
name|name
decl_stmt|;
name|ldns_rdf
modifier|*
name|owner
decl_stmt|;
name|ldns_rdf
modifier|*
name|cut
init|=
name|NULL
decl_stmt|;
comment|/* keeps track of zone cuts */
comment|/* When the cut is caused by a delegation, below_delegation will be 1. 	 * When caused by a DNAME, below_delegation will be 0. 	 */
name|int
name|below_delegation
init|=
operator|-
literal|1
decl_stmt|;
comment|/* init suppresses comiler warning */
name|ldns_status
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|zone
operator|||
operator|!
name|zone
operator|->
name|names
condition|)
block|{
return|return
name|LDNS_STATUS_NULL
return|;
block|}
for|for
control|(
name|node
operator|=
name|ldns_rbtree_first
argument_list|(
name|zone
operator|->
name|names
argument_list|)
init|;
name|node
operator|!=
name|LDNS_RBTREE_NULL
condition|;
name|node
operator|=
name|ldns_rbtree_next
argument_list|(
name|node
argument_list|)
control|)
block|{
name|name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
name|owner
operator|=
name|ldns_dnssec_name_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cut
condition|)
block|{
comment|/* The previous node was a zone cut, or a subdomain 			 * below a zone cut. Is this node (still) a subdomain 			 * below the cut? Then the name is occluded. Unless 			 * the name contains a SOA, after which we are  			 * authoritative again. 			 * 			 * FIXME! If there are labels in between the SOA and 			 * the cut, going from the authoritative space (below 			 * the SOA) up into occluded space again, will not be 			 * detected with the contruct below! 			 */
if|if
condition|(
name|ldns_dname_is_subdomain
argument_list|(
name|owner
argument_list|,
name|cut
argument_list|)
operator|&&
operator|!
name|ldns_dnssec_rrsets_contains_type
argument_list|(
name|name
operator|->
name|rrsets
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
condition|)
block|{
if|if
condition|(
name|below_delegation
operator|&&
name|glue_list
condition|)
block|{
name|s
operator|=
name|ldns_dnssec_addresses_on_glue_list
argument_list|(
name|name
operator|->
name|rrsets
argument_list|,
name|glue_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
name|name
operator|->
name|is_glue
operator|=
name|true
expr_stmt|;
comment|/* Mark occluded name! */
continue|continue;
block|}
else|else
block|{
name|cut
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* The node is not below a zone cut. Is it a zone cut itself? 		 * Everything below a SOA is authoritative of course; Except 		 * when the name also contains a DNAME :). 		 */
if|if
condition|(
name|ldns_dnssec_rrsets_contains_type
argument_list|(
name|name
operator|->
name|rrsets
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
operator|&&
operator|!
name|ldns_dnssec_rrsets_contains_type
argument_list|(
name|name
operator|->
name|rrsets
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
condition|)
block|{
name|cut
operator|=
name|owner
expr_stmt|;
name|below_delegation
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|glue_list
condition|)
block|{
comment|/* record glue on the zone cut */
name|s
operator|=
name|ldns_dnssec_addresses_on_glue_list
argument_list|(
name|name
operator|->
name|rrsets
argument_list|,
name|glue_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ldns_dnssec_rrsets_contains_type
argument_list|(
name|name
operator|->
name|rrsets
argument_list|,
name|LDNS_RR_TYPE_DNAME
argument_list|)
condition|)
block|{
name|cut
operator|=
name|owner
expr_stmt|;
name|below_delegation
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/**  * Marks the names in the zone that are occluded. Those names will be skipped  * when walking the tree with the ldns_dnssec_name_node_next_nonglue()  * function. But watch out! Names that are partially occluded (like glue with  * the same name as the delegation) will not be marked and should specifically   * be taken into account seperately.  *  * \param[in] zone the zone in which to mark the names  * \return LDNS_STATUS_OK on success, an error code otherwise  */
end_comment

begin_function
name|ldns_status
name|ldns_dnssec_zone_mark_glue
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|)
block|{
return|return
name|ldns_dnssec_zone_mark_and_get_glue
argument_list|(
name|zone
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|ldns_rbnode_t
modifier|*
name|ldns_dnssec_name_node_next_nonglue
parameter_list|(
name|ldns_rbnode_t
modifier|*
name|node
parameter_list|)
block|{
name|ldns_rbnode_t
modifier|*
name|next_node
init|=
name|NULL
decl_stmt|;
name|ldns_dnssec_name
modifier|*
name|next_name
init|=
name|NULL
decl_stmt|;
name|bool
name|done
init|=
name|false
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|LDNS_RBTREE_NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|next_node
operator|=
name|node
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|next_node
operator|==
name|LDNS_RBTREE_NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
name|next_name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|next_node
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|next_name
operator|->
name|is_glue
condition|)
block|{
name|done
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|next_node
operator|=
name|ldns_rbtree_next
argument_list|(
name|next_node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|next_node
return|;
block|}
end_function

begin_function
name|ldns_status
name|ldns_dnssec_zone_create_nsecs
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|new_rrs
parameter_list|)
block|{
name|ldns_rbnode_t
modifier|*
name|first_node
decl_stmt|,
modifier|*
name|cur_node
decl_stmt|,
modifier|*
name|next_node
decl_stmt|;
name|ldns_dnssec_name
modifier|*
name|cur_name
decl_stmt|,
modifier|*
name|next_name
decl_stmt|;
name|ldns_rr
modifier|*
name|nsec_rr
decl_stmt|;
name|uint32_t
name|nsec_ttl
decl_stmt|;
name|ldns_dnssec_rrsets
modifier|*
name|soa
decl_stmt|;
comment|/* the TTL of NSEC rrs should be set to the minimum TTL of 	 * the zone SOA (RFC4035 Section 2.3) 	 */
name|soa
operator|=
name|ldns_dnssec_name_find_rrset
argument_list|(
name|zone
operator|->
name|soa
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
expr_stmt|;
comment|/* did the caller actually set it? if not, 	 * fall back to default ttl 	 */
if|if
condition|(
name|soa
operator|&&
name|soa
operator|->
name|rrs
operator|&&
name|soa
operator|->
name|rrs
operator|->
name|rr
operator|&&
operator|(
name|ldns_rr_rdf
argument_list|(
name|soa
operator|->
name|rrs
operator|->
name|rr
argument_list|,
literal|6
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|nsec_ttl
operator|=
name|ldns_rdf2native_int32
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|soa
operator|->
name|rrs
operator|->
name|rr
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nsec_ttl
operator|=
name|LDNS_DEFAULT_TTL
expr_stmt|;
block|}
name|first_node
operator|=
name|ldns_dnssec_name_node_next_nonglue
argument_list|(
name|ldns_rbtree_first
argument_list|(
name|zone
operator|->
name|names
argument_list|)
argument_list|)
expr_stmt|;
name|cur_node
operator|=
name|first_node
expr_stmt|;
if|if
condition|(
name|cur_node
condition|)
block|{
name|next_node
operator|=
name|ldns_dnssec_name_node_next_nonglue
argument_list|(
name|ldns_rbtree_next
argument_list|(
name|cur_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next_node
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|cur_node
operator|&&
name|next_node
condition|)
block|{
name|cur_name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|cur_node
operator|->
name|data
expr_stmt|;
name|next_name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|next_node
operator|->
name|data
expr_stmt|;
name|nsec_rr
operator|=
name|ldns_dnssec_create_nsec
argument_list|(
name|cur_name
argument_list|,
name|next_name
argument_list|,
name|LDNS_RR_TYPE_NSEC
argument_list|)
expr_stmt|;
name|ldns_rr_set_ttl
argument_list|(
name|nsec_rr
argument_list|,
name|nsec_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_dnssec_name_add_rr
argument_list|(
name|cur_name
argument_list|,
name|nsec_rr
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_rr_free
argument_list|(
name|nsec_rr
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_ERR
return|;
block|}
name|ldns_rr_list_push_rr
argument_list|(
name|new_rrs
argument_list|,
name|nsec_rr
argument_list|)
expr_stmt|;
name|cur_node
operator|=
name|next_node
expr_stmt|;
if|if
condition|(
name|cur_node
condition|)
block|{
name|next_node
operator|=
name|ldns_dnssec_name_node_next_nonglue
argument_list|(
name|ldns_rbtree_next
argument_list|(
name|cur_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_node
operator|&&
operator|!
name|next_node
condition|)
block|{
name|cur_name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|cur_node
operator|->
name|data
expr_stmt|;
name|next_name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|first_node
operator|->
name|data
expr_stmt|;
name|nsec_rr
operator|=
name|ldns_dnssec_create_nsec
argument_list|(
name|cur_name
argument_list|,
name|next_name
argument_list|,
name|LDNS_RR_TYPE_NSEC
argument_list|)
expr_stmt|;
name|ldns_rr_set_ttl
argument_list|(
name|nsec_rr
argument_list|,
name|nsec_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_dnssec_name_add_rr
argument_list|(
name|cur_name
argument_list|,
name|nsec_rr
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_rr_free
argument_list|(
name|nsec_rr
argument_list|)
expr_stmt|;
return|return
name|LDNS_STATUS_ERR
return|;
block|}
name|ldns_rr_list_push_rr
argument_list|(
name|new_rrs
argument_list|,
name|nsec_rr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"error\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|LDNS_STATUS_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_comment
comment|/* in dnssec_zone.c */
end_comment

begin_function_decl
specifier|extern
name|int
name|ldns_dname_compare_v
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|ldns_status
name|ldns_dnssec_zone_create_nsec3s_mkmap
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|new_rrs
parameter_list|,
name|uint8_t
name|algorithm
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|uint16_t
name|iterations
parameter_list|,
name|uint8_t
name|salt_length
parameter_list|,
name|uint8_t
modifier|*
name|salt
parameter_list|,
name|ldns_rbtree_t
modifier|*
modifier|*
name|map
parameter_list|)
block|{
name|ldns_rbnode_t
modifier|*
name|first_name_node
decl_stmt|;
name|ldns_rbnode_t
modifier|*
name|current_name_node
decl_stmt|;
name|ldns_dnssec_name
modifier|*
name|current_name
decl_stmt|;
name|ldns_status
name|result
init|=
name|LDNS_STATUS_OK
decl_stmt|;
name|ldns_rr
modifier|*
name|nsec_rr
decl_stmt|;
name|ldns_rr_list
modifier|*
name|nsec3_list
decl_stmt|;
name|uint32_t
name|nsec_ttl
decl_stmt|;
name|ldns_dnssec_rrsets
modifier|*
name|soa
decl_stmt|;
name|ldns_rbnode_t
modifier|*
name|hashmap_node
decl_stmt|;
if|if
condition|(
operator|!
name|zone
operator|||
operator|!
name|new_rrs
operator|||
operator|!
name|zone
operator|->
name|names
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
comment|/* the TTL of NSEC rrs should be set to the minimum TTL of 	 * the zone SOA (RFC4035 Section 2.3) 	 */
name|soa
operator|=
name|ldns_dnssec_name_find_rrset
argument_list|(
name|zone
operator|->
name|soa
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
expr_stmt|;
comment|/* did the caller actually set it? if not, 	 * fall back to default ttl 	 */
if|if
condition|(
name|soa
operator|&&
name|soa
operator|->
name|rrs
operator|&&
name|soa
operator|->
name|rrs
operator|->
name|rr
operator|&&
name|ldns_rr_rdf
argument_list|(
name|soa
operator|->
name|rrs
operator|->
name|rr
argument_list|,
literal|6
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|nsec_ttl
operator|=
name|ldns_rdf2native_int32
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|soa
operator|->
name|rrs
operator|->
name|rr
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nsec_ttl
operator|=
name|LDNS_DEFAULT_TTL
expr_stmt|;
block|}
if|if
condition|(
name|map
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|map
operator|=
name|ldns_rbtree_create
argument_list|(
name|ldns_dname_compare_v
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|map
operator|=
name|NULL
expr_stmt|;
block|}
empty_stmt|;
block|}
name|nsec3_list
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
name|first_name_node
operator|=
name|ldns_dnssec_name_node_next_nonglue
argument_list|(
name|ldns_rbtree_first
argument_list|(
name|zone
operator|->
name|names
argument_list|)
argument_list|)
expr_stmt|;
name|current_name_node
operator|=
name|first_name_node
expr_stmt|;
while|while
condition|(
name|current_name_node
operator|&&
name|current_name_node
operator|!=
name|LDNS_RBTREE_NULL
condition|)
block|{
name|current_name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|current_name_node
operator|->
name|data
expr_stmt|;
name|nsec_rr
operator|=
name|ldns_dnssec_create_nsec3
argument_list|(
name|current_name
argument_list|,
name|NULL
argument_list|,
name|zone
operator|->
name|soa
operator|->
name|name
argument_list|,
name|algorithm
argument_list|,
name|flags
argument_list|,
name|iterations
argument_list|,
name|salt_length
argument_list|,
name|salt
argument_list|)
expr_stmt|;
comment|/* by default, our nsec based generator adds rrsigs 		 * remove the bitmap for empty nonterminals */
if|if
condition|(
operator|!
name|current_name
operator|->
name|rrsets
condition|)
block|{
name|ldns_rdf_deep_free
argument_list|(
name|ldns_rr_pop_rdf
argument_list|(
name|nsec_rr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ldns_rr_set_ttl
argument_list|(
name|nsec_rr
argument_list|,
name|nsec_ttl
argument_list|)
expr_stmt|;
name|result
operator|=
name|ldns_dnssec_name_add_rr
argument_list|(
name|current_name
argument_list|,
name|nsec_rr
argument_list|)
expr_stmt|;
name|ldns_rr_list_push_rr
argument_list|(
name|new_rrs
argument_list|,
name|nsec_rr
argument_list|)
expr_stmt|;
name|ldns_rr_list_push_rr
argument_list|(
name|nsec3_list
argument_list|,
name|nsec_rr
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
condition|)
block|{
name|hashmap_node
operator|=
name|LDNS_MALLOC
argument_list|(
name|ldns_rbnode_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashmap_node
operator|&&
name|ldns_rr_owner
argument_list|(
name|nsec_rr
argument_list|)
condition|)
block|{
name|hashmap_node
operator|->
name|key
operator|=
name|ldns_dname_label
argument_list|(
name|ldns_rr_owner
argument_list|(
name|nsec_rr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashmap_node
operator|->
name|key
condition|)
block|{
name|hashmap_node
operator|->
name|data
operator|=
name|current_name
operator|->
name|name
expr_stmt|;
operator|(
name|void
operator|)
name|ldns_rbtree_insert
argument_list|(
operator|*
name|map
argument_list|,
name|hashmap_node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|current_name_node
operator|=
name|ldns_dnssec_name_node_next_nonglue
argument_list|(
name|ldns_rbtree_next
argument_list|(
name|current_name_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|ldns_rr_list_free
argument_list|(
name|nsec3_list
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|ldns_rr_list_sort_nsec3
argument_list|(
name|nsec3_list
argument_list|)
expr_stmt|;
name|result
operator|=
name|ldns_dnssec_chain_nsec3_list
argument_list|(
name|nsec3_list
argument_list|)
expr_stmt|;
name|ldns_rr_list_free
argument_list|(
name|nsec3_list
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|ldns_status
name|ldns_dnssec_zone_create_nsec3s
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|new_rrs
parameter_list|,
name|uint8_t
name|algorithm
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|uint16_t
name|iterations
parameter_list|,
name|uint8_t
name|salt_length
parameter_list|,
name|uint8_t
modifier|*
name|salt
parameter_list|)
block|{
return|return
name|ldns_dnssec_zone_create_nsec3s_mkmap
argument_list|(
name|zone
argument_list|,
name|new_rrs
argument_list|,
name|algorithm
argument_list|,
name|flags
argument_list|,
name|iterations
argument_list|,
name|salt_length
argument_list|,
name|salt
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

begin_decl_stmt
name|ldns_dnssec_rrs
modifier|*
name|ldns_dnssec_remove_signatures
argument_list|(
name|ldns_dnssec_rrs
operator|*
name|signatures
argument_list|,
name|ATTR_UNUSED
argument_list|(
name|ldns_key_list
operator|*
name|key_list
argument_list|)
argument_list|,
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
name|ldns_rr
operator|*
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|void
operator|*
name|arg
argument_list|)
block|{
name|ldns_dnssec_rrs
modifier|*
name|base_rrs
init|=
name|signatures
decl_stmt|;
name|ldns_dnssec_rrs
modifier|*
name|cur_rr
init|=
name|base_rrs
decl_stmt|;
name|ldns_dnssec_rrs
modifier|*
name|prev_rr
init|=
name|NULL
decl_stmt|;
name|ldns_dnssec_rrs
modifier|*
name|next_rr
decl_stmt|;
name|uint16_t
name|keytag
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|cur_rr
condition|)
block|{
switch|switch
condition|(
name|func
argument_list|(
name|NULL
argument_list|,
name|arg
argument_list|)
condition|)
block|{
case|case
name|LDNS_SIGNATURE_LEAVE_ADD_NEW
case|:
case|case
name|LDNS_SIGNATURE_REMOVE_ADD_NEW
case|:
break|break;
case|case
name|LDNS_SIGNATURE_LEAVE_NO_ADD
case|:
case|case
name|LDNS_SIGNATURE_REMOVE_NO_ADD
case|:
name|ldns_key_list_set_use
argument_list|(
name|key_list
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[XX] unknown return value from callback\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
operator|(
name|void
operator|)
name|func
argument_list|(
name|cur_rr
operator|->
name|rr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_rr
condition|)
block|{
name|next_rr
operator|=
name|cur_rr
operator|->
name|next
expr_stmt|;
switch|switch
condition|(
name|func
argument_list|(
name|cur_rr
operator|->
name|rr
argument_list|,
name|arg
argument_list|)
condition|)
block|{
case|case
name|LDNS_SIGNATURE_LEAVE_ADD_NEW
case|:
name|prev_rr
operator|=
name|cur_rr
expr_stmt|;
break|break;
case|case
name|LDNS_SIGNATURE_LEAVE_NO_ADD
case|:
name|keytag
operator|=
name|ldns_rdf2native_int16
argument_list|(
name|ldns_rr_rrsig_keytag
argument_list|(
name|cur_rr
operator|->
name|rr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_key_list_key_count
argument_list|(
name|key_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldns_key_keytag
argument_list|(
name|ldns_key_list_key
argument_list|(
name|key_list
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|keytag
condition|)
block|{
name|ldns_key_set_use
argument_list|(
name|ldns_key_list_key
argument_list|(
name|key_list
argument_list|,
name|i
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
name|prev_rr
operator|=
name|cur_rr
expr_stmt|;
break|break;
case|case
name|LDNS_SIGNATURE_REMOVE_NO_ADD
case|:
name|keytag
operator|=
name|ldns_rdf2native_int16
argument_list|(
name|ldns_rr_rrsig_keytag
argument_list|(
name|cur_rr
operator|->
name|rr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_key_list_key_count
argument_list|(
name|key_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldns_key_keytag
argument_list|(
name|ldns_key_list_key
argument_list|(
name|key_list
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|keytag
condition|)
block|{
name|ldns_key_set_use
argument_list|(
name|ldns_key_list_key
argument_list|(
name|key_list
argument_list|,
name|i
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prev_rr
condition|)
block|{
name|prev_rr
operator|->
name|next
operator|=
name|next_rr
expr_stmt|;
block|}
else|else
block|{
name|base_rrs
operator|=
name|next_rr
expr_stmt|;
block|}
name|LDNS_FREE
argument_list|(
name|cur_rr
argument_list|)
expr_stmt|;
break|break;
case|case
name|LDNS_SIGNATURE_REMOVE_ADD_NEW
case|:
if|if
condition|(
name|prev_rr
condition|)
block|{
name|prev_rr
operator|->
name|next
operator|=
name|next_rr
expr_stmt|;
block|}
else|else
block|{
name|base_rrs
operator|=
name|next_rr
expr_stmt|;
block|}
name|LDNS_FREE
argument_list|(
name|cur_rr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[XX] unknown return value from callback\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|cur_rr
operator|=
name|next_rr
expr_stmt|;
block|}
return|return
name|base_rrs
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_function
name|ldns_status
name|ldns_dnssec_zone_create_rrsigs
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|new_rrs
parameter_list|,
name|ldns_key_list
modifier|*
name|key_list
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ldns_rr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|ldns_dnssec_zone_create_rrsigs_flg
argument_list|(
name|zone
argument_list|,
name|new_rrs
argument_list|,
name|key_list
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** If there are KSKs use only them and mark ZSKs unused */
end_comment

begin_function
specifier|static
name|void
name|ldns_key_list_filter_for_dnskey
parameter_list|(
name|ldns_key_list
modifier|*
name|key_list
parameter_list|)
block|{
name|int
name|saw_ksk
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_key_list_key_count
argument_list|(
name|key_list
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|ldns_key_flags
argument_list|(
name|ldns_key_list_key
argument_list|(
name|key_list
argument_list|,
name|i
argument_list|)
argument_list|)
operator|&
name|LDNS_KEY_SEP_KEY
operator|)
condition|)
block|{
name|saw_ksk
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|saw_ksk
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_key_list_key_count
argument_list|(
name|key_list
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|ldns_key_flags
argument_list|(
name|ldns_key_list_key
argument_list|(
name|key_list
argument_list|,
name|i
argument_list|)
argument_list|)
operator|&
name|LDNS_KEY_SEP_KEY
operator|)
condition|)
name|ldns_key_set_use
argument_list|(
name|ldns_key_list_key
argument_list|(
name|key_list
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** If there are no ZSKs use KSK as ZSK */
end_comment

begin_function
specifier|static
name|void
name|ldns_key_list_filter_for_non_dnskey
parameter_list|(
name|ldns_key_list
modifier|*
name|key_list
parameter_list|)
block|{
name|int
name|saw_zsk
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_key_list_key_count
argument_list|(
name|key_list
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|ldns_key_flags
argument_list|(
name|ldns_key_list_key
argument_list|(
name|key_list
argument_list|,
name|i
argument_list|)
argument_list|)
operator|&
name|LDNS_KEY_SEP_KEY
operator|)
condition|)
block|{
name|saw_zsk
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|saw_zsk
condition|)
return|return;
comment|/* else filter all KSKs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_key_list_key_count
argument_list|(
name|key_list
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|ldns_key_flags
argument_list|(
name|ldns_key_list_key
argument_list|(
name|key_list
argument_list|,
name|i
argument_list|)
argument_list|)
operator|&
name|LDNS_KEY_SEP_KEY
operator|)
condition|)
name|ldns_key_set_use
argument_list|(
name|ldns_key_list_key
argument_list|(
name|key_list
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ldns_status
name|ldns_dnssec_zone_create_rrsigs_flg
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|new_rrs
parameter_list|,
name|ldns_key_list
modifier|*
name|key_list
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ldns_rr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ldns_status
name|result
init|=
name|LDNS_STATUS_OK
decl_stmt|;
name|ldns_rbnode_t
modifier|*
name|cur_node
decl_stmt|;
name|ldns_rr_list
modifier|*
name|rr_list
decl_stmt|;
name|ldns_dnssec_name
modifier|*
name|cur_name
decl_stmt|;
name|ldns_dnssec_rrsets
modifier|*
name|cur_rrset
decl_stmt|;
name|ldns_dnssec_rrs
modifier|*
name|cur_rr
decl_stmt|;
name|ldns_rr_list
modifier|*
name|siglist
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|on_delegation_point
init|=
literal|0
decl_stmt|;
comment|/* handle partially occluded names */
name|ldns_rr_list
modifier|*
name|pubkey_list
init|=
name|ldns_rr_list_new
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_key_list_key_count
argument_list|(
name|key_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ldns_rr_list_push_rr
argument_list|(
name|pubkey_list
argument_list|,
name|ldns_key2rr
argument_list|(
name|ldns_key_list_key
argument_list|(
name|key_list
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: callback to see is list should be signed */
comment|/* TODO: remove 'old' signatures from signature list */
name|cur_node
operator|=
name|ldns_rbtree_first
argument_list|(
name|zone
operator|->
name|names
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_node
operator|!=
name|LDNS_RBTREE_NULL
condition|)
block|{
name|cur_name
operator|=
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|cur_node
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|cur_name
operator|->
name|is_glue
condition|)
block|{
name|on_delegation_point
operator|=
name|ldns_dnssec_rrsets_contains_type
argument_list|(
name|cur_name
operator|->
name|rrsets
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
operator|&&
operator|!
name|ldns_dnssec_rrsets_contains_type
argument_list|(
name|cur_name
operator|->
name|rrsets
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
expr_stmt|;
name|cur_rrset
operator|=
name|cur_name
operator|->
name|rrsets
expr_stmt|;
while|while
condition|(
name|cur_rrset
condition|)
block|{
comment|/* reset keys to use */
name|ldns_key_list_set_use
argument_list|(
name|key_list
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* walk through old sigs, remove the old, 				   and mark which keys (not) to use) */
name|cur_rrset
operator|->
name|signatures
operator|=
name|ldns_dnssec_remove_signatures
argument_list|(
name|cur_rrset
operator|->
name|signatures
argument_list|,
name|key_list
argument_list|,
name|func
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LDNS_SIGN_DNSKEY_WITH_ZSK
operator|)
operator|&&
name|cur_rrset
operator|->
name|type
operator|==
name|LDNS_RR_TYPE_DNSKEY
condition|)
name|ldns_key_list_filter_for_dnskey
argument_list|(
name|key_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_rrset
operator|->
name|type
operator|!=
name|LDNS_RR_TYPE_DNSKEY
condition|)
name|ldns_key_list_filter_for_non_dnskey
argument_list|(
name|key_list
argument_list|)
expr_stmt|;
comment|/* TODO: just set count to zero? */
name|rr_list
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
name|cur_rr
operator|=
name|cur_rrset
operator|->
name|rrs
expr_stmt|;
while|while
condition|(
name|cur_rr
condition|)
block|{
name|ldns_rr_list_push_rr
argument_list|(
name|rr_list
argument_list|,
name|cur_rr
operator|->
name|rr
argument_list|)
expr_stmt|;
name|cur_rr
operator|=
name|cur_rr
operator|->
name|next
expr_stmt|;
block|}
comment|/* only sign non-delegation RRsets */
comment|/* (glue should have been marked earlier,  				 *  except on the delegation points itself) */
if|if
condition|(
operator|!
name|on_delegation_point
operator|||
name|ldns_rr_list_type
argument_list|(
name|rr_list
argument_list|)
operator|==
name|LDNS_RR_TYPE_DS
operator|||
name|ldns_rr_list_type
argument_list|(
name|rr_list
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
operator|||
name|ldns_rr_list_type
argument_list|(
name|rr_list
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|siglist
operator|=
name|ldns_sign_public
argument_list|(
name|rr_list
argument_list|,
name|key_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|siglist
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cur_rrset
operator|->
name|signatures
condition|)
block|{
name|result
operator|=
name|ldns_dnssec_rrs_add_rr
argument_list|(
name|cur_rrset
operator|->
name|signatures
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|siglist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cur_rrset
operator|->
name|signatures
operator|=
name|ldns_dnssec_rrs_new
argument_list|()
expr_stmt|;
name|cur_rrset
operator|->
name|signatures
operator|->
name|rr
operator|=
name|ldns_rr_list_rr
argument_list|(
name|siglist
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_rrs
condition|)
block|{
name|ldns_rr_list_push_rr
argument_list|(
name|new_rrs
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|siglist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ldns_rr_list_free
argument_list|(
name|siglist
argument_list|)
expr_stmt|;
block|}
name|ldns_rr_list_free
argument_list|(
name|rr_list
argument_list|)
expr_stmt|;
name|cur_rrset
operator|=
name|cur_rrset
operator|->
name|next
expr_stmt|;
block|}
comment|/* sign the nsec */
name|ldns_key_list_set_use
argument_list|(
name|key_list
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|cur_name
operator|->
name|nsec_signatures
operator|=
name|ldns_dnssec_remove_signatures
argument_list|(
name|cur_name
operator|->
name|nsec_signatures
argument_list|,
name|key_list
argument_list|,
name|func
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ldns_key_list_filter_for_non_dnskey
argument_list|(
name|key_list
argument_list|)
expr_stmt|;
name|rr_list
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
name|ldns_rr_list_push_rr
argument_list|(
name|rr_list
argument_list|,
name|cur_name
operator|->
name|nsec
argument_list|)
expr_stmt|;
name|siglist
operator|=
name|ldns_sign_public
argument_list|(
name|rr_list
argument_list|,
name|key_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|siglist
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cur_name
operator|->
name|nsec_signatures
condition|)
block|{
name|result
operator|=
name|ldns_dnssec_rrs_add_rr
argument_list|(
name|cur_name
operator|->
name|nsec_signatures
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|siglist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cur_name
operator|->
name|nsec_signatures
operator|=
name|ldns_dnssec_rrs_new
argument_list|()
expr_stmt|;
name|cur_name
operator|->
name|nsec_signatures
operator|->
name|rr
operator|=
name|ldns_rr_list_rr
argument_list|(
name|siglist
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_rrs
condition|)
block|{
name|ldns_rr_list_push_rr
argument_list|(
name|new_rrs
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|siglist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ldns_rr_list_free
argument_list|(
name|siglist
argument_list|)
expr_stmt|;
name|ldns_rr_list_free
argument_list|(
name|rr_list
argument_list|)
expr_stmt|;
block|}
name|cur_node
operator|=
name|ldns_rbtree_next
argument_list|(
name|cur_node
argument_list|)
expr_stmt|;
block|}
name|ldns_rr_list_deep_free
argument_list|(
name|pubkey_list
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|ldns_status
name|ldns_dnssec_zone_sign
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|new_rrs
parameter_list|,
name|ldns_key_list
modifier|*
name|key_list
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ldns_rr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|ldns_dnssec_zone_sign_flg
argument_list|(
name|zone
argument_list|,
name|new_rrs
argument_list|,
name|key_list
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|ldns_status
name|ldns_dnssec_zone_sign_flg
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|new_rrs
parameter_list|,
name|ldns_key_list
modifier|*
name|key_list
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ldns_rr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ldns_status
name|result
init|=
name|LDNS_STATUS_OK
decl_stmt|;
if|if
condition|(
operator|!
name|zone
operator|||
operator|!
name|new_rrs
operator|||
operator|!
name|key_list
condition|)
block|{
return|return
name|LDNS_STATUS_ERR
return|;
block|}
comment|/* zone is already sorted */
name|result
operator|=
name|ldns_dnssec_zone_mark_glue
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/* check whether we need to add nsecs */
if|if
condition|(
name|zone
operator|->
name|names
operator|&&
operator|!
operator|(
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|zone
operator|->
name|names
operator|->
name|root
operator|->
name|data
operator|)
operator|->
name|nsec
condition|)
block|{
name|result
operator|=
name|ldns_dnssec_zone_create_nsecs
argument_list|(
name|zone
argument_list|,
name|new_rrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|result
operator|=
name|ldns_dnssec_zone_create_rrsigs_flg
argument_list|(
name|zone
argument_list|,
name|new_rrs
argument_list|,
name|key_list
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|ldns_status
name|ldns_dnssec_zone_sign_nsec3
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|new_rrs
parameter_list|,
name|ldns_key_list
modifier|*
name|key_list
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ldns_rr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint8_t
name|algorithm
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|uint16_t
name|iterations
parameter_list|,
name|uint8_t
name|salt_length
parameter_list|,
name|uint8_t
modifier|*
name|salt
parameter_list|)
block|{
return|return
name|ldns_dnssec_zone_sign_nsec3_flg_mkmap
argument_list|(
name|zone
argument_list|,
name|new_rrs
argument_list|,
name|key_list
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|algorithm
argument_list|,
name|flags
argument_list|,
name|iterations
argument_list|,
name|salt_length
argument_list|,
name|salt
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|ldns_status
name|ldns_dnssec_zone_sign_nsec3_flg_mkmap
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|new_rrs
parameter_list|,
name|ldns_key_list
modifier|*
name|key_list
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ldns_rr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint8_t
name|algorithm
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|uint16_t
name|iterations
parameter_list|,
name|uint8_t
name|salt_length
parameter_list|,
name|uint8_t
modifier|*
name|salt
parameter_list|,
name|int
name|signflags
parameter_list|,
name|ldns_rbtree_t
modifier|*
modifier|*
name|map
parameter_list|)
block|{
name|ldns_rr
modifier|*
name|nsec3
decl_stmt|,
modifier|*
name|nsec3param
decl_stmt|;
name|ldns_status
name|result
init|=
name|LDNS_STATUS_OK
decl_stmt|;
comment|/* zone is already sorted */
name|result
operator|=
name|ldns_dnssec_zone_mark_glue
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
return|return
name|result
return|;
block|}
comment|/* TODO if there are already nsec3s presents and their 	 * parameters are the same as these, we don't have to recreate 	 */
if|if
condition|(
name|zone
operator|->
name|names
condition|)
block|{
comment|/* add empty nonterminals */
name|result
operator|=
name|ldns_dnssec_zone_add_empty_nonterminals
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|nsec3
operator|=
operator|(
operator|(
name|ldns_dnssec_name
operator|*
operator|)
name|zone
operator|->
name|names
operator|->
name|root
operator|->
name|data
operator|)
operator|->
name|nsec
expr_stmt|;
if|if
condition|(
name|nsec3
operator|&&
name|ldns_rr_get_type
argument_list|(
name|nsec3
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
comment|/* no need to recreate */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ldns_dnssec_zone_find_rrset
argument_list|(
name|zone
argument_list|,
name|zone
operator|->
name|soa
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_NSEC3PARAM
argument_list|)
condition|)
block|{
comment|/* create and add the nsec3param rr */
name|nsec3param
operator|=
name|ldns_rr_new_frm_type
argument_list|(
name|LDNS_RR_TYPE_NSEC3PARAM
argument_list|)
expr_stmt|;
name|ldns_rr_set_owner
argument_list|(
name|nsec3param
argument_list|,
name|ldns_rdf_clone
argument_list|(
name|zone
operator|->
name|soa
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_nsec3_add_param_rdfs
argument_list|(
name|nsec3param
argument_list|,
name|algorithm
argument_list|,
name|flags
argument_list|,
name|iterations
argument_list|,
name|salt_length
argument_list|,
name|salt
argument_list|)
expr_stmt|;
comment|/* always set bit 7 of the flags to zero, according to 				 * rfc5155 section 11. The bits are counted from right to left, 				 * so bit 7 in rfc5155 is bit 0 in ldns */
name|ldns_set_bit
argument_list|(
name|ldns_rdf_data
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|nsec3param
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|ldns_dnssec_zone_add_rr
argument_list|(
name|zone
argument_list|,
name|nsec3param
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
return|return
name|result
return|;
block|}
name|ldns_rr_list_push_rr
argument_list|(
name|new_rrs
argument_list|,
name|nsec3param
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|ldns_dnssec_zone_create_nsec3s_mkmap
argument_list|(
name|zone
argument_list|,
name|new_rrs
argument_list|,
name|algorithm
argument_list|,
name|flags
argument_list|,
name|iterations
argument_list|,
name|salt_length
argument_list|,
name|salt
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
name|result
operator|=
name|ldns_dnssec_zone_create_rrsigs_flg
argument_list|(
name|zone
argument_list|,
name|new_rrs
argument_list|,
name|key_list
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|signflags
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|ldns_status
name|ldns_dnssec_zone_sign_nsec3_flg
parameter_list|(
name|ldns_dnssec_zone
modifier|*
name|zone
parameter_list|,
name|ldns_rr_list
modifier|*
name|new_rrs
parameter_list|,
name|ldns_key_list
modifier|*
name|key_list
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|ldns_rr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint8_t
name|algorithm
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|uint16_t
name|iterations
parameter_list|,
name|uint8_t
name|salt_length
parameter_list|,
name|uint8_t
modifier|*
name|salt
parameter_list|,
name|int
name|signflags
parameter_list|)
block|{
return|return
name|ldns_dnssec_zone_sign_nsec3_flg_mkmap
argument_list|(
name|zone
argument_list|,
name|new_rrs
argument_list|,
name|key_list
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|algorithm
argument_list|,
name|flags
argument_list|,
name|iterations
argument_list|,
name|salt_length
argument_list|,
name|salt
argument_list|,
name|signflags
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|ldns_zone
modifier|*
name|ldns_zone_sign
parameter_list|(
specifier|const
name|ldns_zone
modifier|*
name|zone
parameter_list|,
name|ldns_key_list
modifier|*
name|key_list
parameter_list|)
block|{
name|ldns_dnssec_zone
modifier|*
name|dnssec_zone
decl_stmt|;
name|ldns_zone
modifier|*
name|signed_zone
decl_stmt|;
name|ldns_rr_list
modifier|*
name|new_rrs
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|signed_zone
operator|=
name|ldns_zone_new
argument_list|()
expr_stmt|;
name|dnssec_zone
operator|=
name|ldns_dnssec_zone_new
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ldns_dnssec_zone_add_rr
argument_list|(
name|dnssec_zone
argument_list|,
name|ldns_zone_soa
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_zone_set_soa
argument_list|(
name|signed_zone
argument_list|,
name|ldns_rr_clone
argument_list|(
name|ldns_zone_soa
argument_list|(
name|zone
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|zone
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|ldns_dnssec_zone_add_rr
argument_list|(
name|dnssec_zone
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|zone
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_zone_push_rr
argument_list|(
name|signed_zone
argument_list|,
name|ldns_rr_clone
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|zone
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new_rrs
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ldns_dnssec_zone_sign
argument_list|(
name|dnssec_zone
argument_list|,
name|new_rrs
argument_list|,
name|key_list
argument_list|,
name|ldns_dnssec_default_replace_signatures
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|new_rrs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ldns_rr_list_push_rr
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|signed_zone
argument_list|)
argument_list|,
name|ldns_rr_clone
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|new_rrs
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ldns_rr_list_deep_free
argument_list|(
name|new_rrs
argument_list|)
expr_stmt|;
name|ldns_dnssec_zone_free
argument_list|(
name|dnssec_zone
argument_list|)
expr_stmt|;
return|return
name|signed_zone
return|;
block|}
end_function

begin_function
name|ldns_zone
modifier|*
name|ldns_zone_sign_nsec3
parameter_list|(
name|ldns_zone
modifier|*
name|zone
parameter_list|,
name|ldns_key_list
modifier|*
name|key_list
parameter_list|,
name|uint8_t
name|algorithm
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|uint16_t
name|iterations
parameter_list|,
name|uint8_t
name|salt_length
parameter_list|,
name|uint8_t
modifier|*
name|salt
parameter_list|)
block|{
name|ldns_dnssec_zone
modifier|*
name|dnssec_zone
decl_stmt|;
name|ldns_zone
modifier|*
name|signed_zone
decl_stmt|;
name|ldns_rr_list
modifier|*
name|new_rrs
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|signed_zone
operator|=
name|ldns_zone_new
argument_list|()
expr_stmt|;
name|dnssec_zone
operator|=
name|ldns_dnssec_zone_new
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ldns_dnssec_zone_add_rr
argument_list|(
name|dnssec_zone
argument_list|,
name|ldns_zone_soa
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_zone_set_soa
argument_list|(
name|signed_zone
argument_list|,
name|ldns_rr_clone
argument_list|(
name|ldns_zone_soa
argument_list|(
name|zone
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|zone
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|ldns_dnssec_zone_add_rr
argument_list|(
name|dnssec_zone
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|zone
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_zone_push_rr
argument_list|(
name|signed_zone
argument_list|,
name|ldns_rr_clone
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|zone
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new_rrs
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ldns_dnssec_zone_sign_nsec3
argument_list|(
name|dnssec_zone
argument_list|,
name|new_rrs
argument_list|,
name|key_list
argument_list|,
name|ldns_dnssec_default_replace_signatures
argument_list|,
name|NULL
argument_list|,
name|algorithm
argument_list|,
name|flags
argument_list|,
name|iterations
argument_list|,
name|salt_length
argument_list|,
name|salt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|new_rrs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ldns_rr_list_push_rr
argument_list|(
name|ldns_zone_rrs
argument_list|(
name|signed_zone
argument_list|)
argument_list|,
name|ldns_rr_clone
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|new_rrs
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ldns_rr_list_deep_free
argument_list|(
name|new_rrs
argument_list|)
expr_stmt|;
name|ldns_dnssec_zone_free
argument_list|(
name|dnssec_zone
argument_list|)
expr_stmt|;
return|return
name|signed_zone
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL */
end_comment

end_unit

