begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 by Darren Reed.  *  * See the IPFILTER.LICENCE file for details on licencing.  */
end_comment

begin_comment
comment|/* #pragma ident   "@(#)solaris.c	1.12 6/5/96 (C) 1995 Darren Reed"*/
end_comment

begin_comment
comment|/*typedef unsigned int spustate_t;*/
end_comment

begin_struct_decl
struct_decl|struct
name|uio
struct_decl|;
end_struct_decl

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/moddefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/spinlock.h>
end_include

begin_comment
comment|/* HNT */
end_comment

begin_include
include|#
directive|include
file|<sys/io.h>
end_include

begin_include
include|#
directive|include
file|<sys/wsio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/af.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|"ip_compat.h"
end_include

begin_include
include|#
directive|include
file|"ip_fil.h"
end_include

begin_include
include|#
directive|include
file|"ip_nat.h"
end_include

begin_include
include|#
directive|include
file|"ipl.h"
end_include

begin_undef
undef|#
directive|undef
name|untimeout
end_undef

begin_undef
undef|#
directive|undef
name|IPFDEBUG
end_undef

begin_decl_stmt
specifier|extern
name|int
name|ipf_running
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ipf_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ipf_check
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ipnat_t
modifier|*
name|nat_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ipf_devfiles
index|[]
init|=
block|{
name|IPL_NAME
block|,
name|IPNAT_NAME
block|,
name|IPSTATE_NAME
block|,
name|IPAUTH_NAME
block|,
name|IPSYNC_NAME
block|,
name|IPLOOKUP_NAME
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|int
argument_list|(
argument|*ipf_ip_inp
argument_list|)
name|__P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|mblk_t
operator|*
operator|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_slowtimer
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|callout
modifier|*
name|ipf_timer_id
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|callout
modifier|*
name|synctimeoutid
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPFDEBUG
end_ifdef

begin_decl_stmt
name|void
name|printiri
name|__P
argument_list|(
operator|(
name|irinfo_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPFDEBUG */
end_comment

begin_function_decl
specifier|static
name|int
name|ipf_install
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Install Routine - Biswajit */
end_comment

begin_function_decl
specifier|static
name|int
name|ipf_load
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipf_unload
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipf_write
parameter_list|(
name|dev_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipf_attach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipf_detach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipf_qifsync
parameter_list|(
name|ip_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|qif_t
modifier|*
parameter_list|,
name|mblk_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Local functions for static linking - Biswajit  */
end_comment

begin_function_decl
specifier|static
name|void
name|ipf_linked_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|ipf_saved_init
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Used in ipf_install() - Biswajit */
end_comment

begin_comment
comment|/*  * While linking  statically,  PFIL needs to be installed  * before IPF is installed.  */
end_comment

begin_function_decl
name|int
name|pfil_install
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Driver Header  */
end_comment

begin_decl_stmt
specifier|static
name|drv_info_t
name|ipf_drv_info
init|=
block|{
name|IPL_VERSION
block|,
comment|/* type */
literal|"pseudo"
block|,
comment|/* class */
name|DRV_CHAR
operator||
name|DRV_PSEUDO
operator||
name|DRV_SAVE_CONF
operator||
name|DRV_MP_SAFE
block|,
comment|/* flags */
operator|-
literal|1
block|,
comment|/* b_major */
operator|-
literal|1
block|,
comment|/* c_major */
name|NULL
block|,
comment|/* cdio */
name|NULL
block|,
comment|/* gio_private */
name|NULL
block|,
comment|/* cdio_private */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|drv_ops_t
name|ipf_drv_ops
init|=
block|{
name|ipfopen
block|,
name|ipfclose
block|,
name|NULL
block|,
comment|/* strategy */
name|NULL
block|,
comment|/* dump */
name|NULL
block|,
comment|/* psize */
name|NULL
block|,
comment|/* mount */
name|ipfread
block|,
name|ipfwrite
block|,
comment|/* write */
name|ipfioctl
block|,
comment|/* ioctl */
ifdef|#
directive|ifdef
name|IPL_SELECT
name|ipfselect
block|,
comment|/* select */
else|#
directive|else
name|NULL
block|,
comment|/* select */
endif|#
directive|endif
name|NULL
block|,
comment|/* option1 */
name|NULL
block|,
comment|/* reserved1 */
name|NULL
block|,
comment|/* reserved2 */
name|NULL
block|,
comment|/* reserved3 */
name|NULL
block|,
comment|/* reserved4 */
literal|0
block|,
comment|/* flags */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|wsio_drv_data_t
name|ipf_wsio_data
init|=
block|{
literal|"pseudo_ipf"
block|,
comment|/* drv_path */
name|T_DEVICE
block|,
comment|/* drv_type */
name|DRV_CONVERGED
block|,
comment|/* drv_flags */
name|NULL
block|,
comment|/* drv_minor_build - field not used */
name|NULL
block|,
comment|/* drv_major_build - field not used */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|mod_operations
name|gio_mod_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|drv_info_t
name|ipf_drv_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|mod_conf_data
name|ipf_conf_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mod_type_data
name|ipf_drv_link
init|=
block|{
name|IPL_VERSION
block|,
operator|(
name|void
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modlink
name|ipf_mod_link
index|[]
init|=
block|{
block|{
operator|&
name|gio_mod_ops
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ipf_drv_link
block|}
block|,
block|{
name|NULL
block|,
operator|(
name|void
operator|*
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|modwrapper
name|ipf_wrapper
init|=
block|{
name|MODREV
block|,
name|ipf_load
block|,
name|ipf_unload
block|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ipf_conf_data
block|,
name|ipf_mod_link
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|wsio_drv_info_t
name|ipf_wsio_info
init|=
block|{
operator|&
name|ipf_drv_info
block|,
operator|&
name|ipf_drv_ops
block|,
operator|&
name|ipf_wsio_data
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ipf_load
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|ipfinst
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"IP Filter: ipf_load(%lx)\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Use drv_info passed to us instead of static version */
name|ipf_wsio_info
operator|.
name|drv_info
operator|=
operator|(
name|drv_info_t
operator|*
operator|)
name|arg
expr_stmt|;
name|ipfinst
operator|=
name|wsio_install_driver
argument_list|(
operator|&
name|ipf_wsio_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfinst
operator|==
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: wsio_install_driver(%lx) failed: %d\n"
argument_list|,
operator|&
name|ipf_wsio_info
argument_list|,
name|ipfinst
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
else|else
block|{
name|ipfinst
operator|=
name|ipf_attach
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"IP Filter: ipf_attach() = %d\n"
argument_list|,
name|ipfinst
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"IP Filter: ipf_load() = %d\n"
argument_list|,
name|ipfinst
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ipfinst
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipf_unload
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|ipfinst
decl_stmt|;
name|ipfinst
operator|=
name|wsio_uninstall_driver
argument_list|(
operator|&
name|ipf_wsio_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfinst
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: wsio_uninstall_driver(%lx) failed: %d\n"
argument_list|,
operator|&
name|ipf_wsio_info
argument_list|,
name|ipfinst
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
else|else
block|{
name|ipfinst
operator|=
name|ipf_detach
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"IP Filter: ipf_detach() = %d\n"
argument_list|,
name|ipfinst
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"IP Filter: ipf_unload() = %d\n"
argument_list|,
name|ipfinst
argument_list|)
expr_stmt|;
comment|/* HP Port: We don't want this to come to the cosole on boot up */
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: Unloaded\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * INSTALL  * Following routine is called when the dlkm module is  * being linked statically with the kernel  * - Biswajit  */
end_comment

begin_function
specifier|static
name|int
name|ipf_install
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|int
function_decl|(
modifier|*
name|dev_init
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|ipfinst
decl_stmt|;
comment|/* 	 * Make sure PFIL module is installed before 	 * installing IPF 	 */
if|if
condition|(
name|pfilinterface
operator|!=
name|PFIL_INTERFACE
condition|)
block|{
name|printf
argument_list|(
literal|"pfilinterface(%d) != %d\n"
argument_list|,
name|pfilinterface
argument_list|,
name|PFIL_INTERFACE
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * Link my init function into the chain 	 */
name|ipf_saved_init
operator|=
name|dev_init
expr_stmt|;
name|dev_init
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|&
name|ipf_linked_init
expr_stmt|;
comment|/* 	 * Register driver with WSIO 	 */
name|ipfinst
operator|=
name|wsio_install_driver
argument_list|(
operator|&
name|ipf_wsio_info
argument_list|)
expr_stmt|;
return|return
operator|(
name|ipfinst
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device Initialization Link  * Called only for statically linked drivers to link  *   init routine into list  * - Biswajit  */
end_comment

begin_function
specifier|static
name|void
name|ipf_linked_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Perform driver specific initialization 	 */
operator|(
name|void
operator|)
name|ipf_attach
argument_list|()
expr_stmt|;
comment|/* 	 * Call next init function in chain 	 */
call|(
name|void
call|)
argument_list|(
operator|*
name|ipf_saved_init
argument_list|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipf_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"IP Filter: ipf_write(%x,%lx)\n"
argument_list|,
name|dev
argument_list|,
name|uio
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipf_attach
parameter_list|()
block|{
name|char
modifier|*
name|defpass
decl_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|ipf_global
argument_list|,
literal|"ipf filter load/unload mutex"
argument_list|)
expr_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|ipf_mutex
argument_list|,
literal|"ipf filter rwlock"
argument_list|)
expr_stmt|;
name|RWLOCK_INIT
argument_list|(
operator|&
name|ipf_frcache
argument_list|,
literal|"ipf cache rwlock"
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
comment|/* 	 * Initialize mutex's 	 */
if|if
condition|(
name|ipfattach
argument_list|()
operator|==
operator|-
literal|1
condition|)
goto|goto
name|attachfailed
goto|;
comment|/* 	 * Lock people out while we set things up. 	 */
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_global
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfil_add_hook
argument_list|(
name|ipf_check
argument_list|,
name|PFIL_IN
operator||
name|PFIL_OUT
argument_list|,
operator|&
name|pfh_inet4
argument_list|)
condition|)
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: pfil_add_hook(pfh_inet4) failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfil_add_hook
argument_list|(
name|ipf_qifsync
argument_list|,
name|PFIL_IN
operator||
name|PFIL_OUT
argument_list|,
operator|&
name|pfh_sync
argument_list|)
condition|)
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: pfil_add_hook(pfh_sync) failed"
argument_list|)
expr_stmt|;
comment|/* 	 * Release lock 	 */
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_global
argument_list|)
expr_stmt|;
if|if
condition|(
name|FR_ISPASS
argument_list|(
name|ipf_pass
argument_list|)
condition|)
name|defpass
operator|=
literal|"pass"
expr_stmt|;
elseif|else
if|if
condition|(
name|FR_ISBLOCK
argument_list|(
name|ipf_pass
argument_list|)
condition|)
name|defpass
operator|=
literal|"block"
expr_stmt|;
else|else
name|defpass
operator|=
literal|"no-match -> block"
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
comment|/* HP Port: We don't want this to come to the cosole on boot up */
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"%s initialized.  Default = %s all, Logging = %s\n"
argument_list|,
name|ipfilter_version
argument_list|,
name|defpass
argument_list|,
ifdef|#
directive|ifdef
name|IPFILTER_LOG
literal|"enabled"
argument_list|)
expr_stmt|;
else|#
directive|else
literal|"disabled"
block|)
function|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|sync
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ipf_running
operator|==
literal|0
condition|)
name|ipf_running
operator|=
literal|1
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|ipf_timer_id
operator|==
name|NULL
condition|)
name|ipf_timer_id
operator|=
name|mp_timeout
argument_list|(
name|ipf_slowtimer
argument_list|,
name|NULL
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|ipf_running
operator|==
literal|1
condition|)
return|return
literal|0
return|;
end_if

begin_label
name|attachfailed
label|:
end_label

begin_expr_stmt
name|RW_DESTROY
argument_list|(
operator|&
name|ipf_global
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RW_DESTROY
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RW_DESTROY
argument_list|(
operator|&
name|ipf_frcache
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|-
literal|1
return|;
end_return

begin_function
unit|}   static
name|int
name|ipf_detach
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ipf_refcnt
condition|)
return|return
name|EBUSY
return|;
comment|/* 	 * Make sure we're the only one's modifying things.  With 	 * this lock others should just fall out of the loop. 	 */
name|MUTEX_ENTER
argument_list|(
operator|&
name|ipf_rw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipf_running
operator|<=
literal|0
condition|)
block|{
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipf_rw
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ipf_timer_id
condition|)
block|{
name|untimeout
argument_list|(
name|ipf_slowtimer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ipf_timer_id
operator|=
literal|0
expr_stmt|;
block|}
name|ipf_running
operator|=
operator|-
literal|1
expr_stmt|;
name|MUTEX_EXIT
argument_list|(
operator|&
name|ipf_rw
argument_list|)
expr_stmt|;
comment|/* 	 * Undo what we did in ipf_attach, freeing resources 	 * and removing things we installed.  The system 	 * framework guarantees we are not active with this devinfo 	 * node in any other entry points at this time. 	 */
name|sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|pfil_remove_hook
argument_list|(
name|ipf_check
argument_list|,
name|PFIL_IN
operator||
name|PFIL_OUT
argument_list|,
operator|&
name|pfh_inet4
argument_list|)
condition|)
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: pfil_remove_hook(pfh_inet4) failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfil_remove_hook
argument_list|(
name|ipf_qifsync
argument_list|,
name|PFIL_IN
operator||
name|PFIL_OUT
argument_list|,
operator|&
name|pfh_sync
argument_list|)
condition|)
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: pfil_remove_hook(pfh_sync) failed"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ipf_timer_id
operator|!=
name|NULL
condition|)
name|sched_yield
argument_list|()
expr_stmt|;
name|i
operator|=
name|ipfdetach
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|RW_DESTROY
argument_list|(
operator|&
name|ipf_global
argument_list|)
expr_stmt|;
name|RW_DESTROY
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
name|RW_DESTROY
argument_list|(
operator|&
name|ipf_frcache
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPFDEBUG
name|printf
argument_list|(
literal|"IP Filter: ipfdetach() = %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|i
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * OK, this is pretty scrappy code, but then it's essentially just here for  * debug purposes and that's it.  Packets should not normally come through  * here, and if they do, well, we would like to see as much information as  * possible about them and what they claim to hold.  */
end_comment

begin_endif
unit|void ipf_donotip(out, qif, q, m, mt, ip, off) 	int out; 	qif_t *qif; 	queue_t *q; 	mblk_t *m, *mt; 	ip_t *ip; 	size_t off; { 	u_char *s, outb[256], *t; 	int i, j;  	outb[0] = '\0'; 	outb[1] = '\0'; 	outb[2] = '\0'; 	outb[3] = '\0'; 	s = ip ? (u_char *)ip : outb; 	if (!ip&& (m == mt)&& m->b_cont&& (MTYPE(m) != M_DATA)) 		m = m->b_cont;  	printf(" !IP %s:%d %d %p %p %p %d %p/%d %p/%d %p %d %d %p\n", 		qif ? qif->qf_name : "?", out, qif->qf_hl, q, 		q ? q->q_ptr : NULL, q ? q->q_qinfo : NULL, 		mt->b_wptr - mt->b_rptr, m, MTYPE(m), mt, MTYPE(mt), m->b_rptr, 		m->b_wptr - m->b_rptr, off, ip); 	printf("%02x%02x%02x%02x\n", *s, *(s+1), *(s+2), *(s+3)); 	while (m != mt) { 		i = 0; 		j = 256; 		t = outb; 		s = mt->b_rptr; 		sprintf((char *)t, j, "%d:", MTYPE(mt)); 		t += strlen((char *)t); 		j -= strlen((char *)t); 		for (; (j> 0)&& (i< 100)&& (s< mt->b_wptr); i++) { 			sprintf((char *)t, j, "%02x%s", *s++, 				((i& 3) == 3) ? " " : ""); 			t += ((i& 3) == 3) ? 3 : 2; 			j -= ((i& 3) == 3) ? 3 : 2; 		} 		*t++ = '\n'; 		*t = '\0'; 		printf("%s", outb); 		mt = mt->b_cont; 	} 	i = 0; 	j = 256; 	t = outb; 	s = m->b_rptr; 	sprintf((char *)t, j, "%d:", MTYPE(m)); 	t += strlen((char *)t); 	j -= strlen((char *)t); 	for (; (j> 0)&& (i< 100)&& (s< m->b_wptr); i++) { 		sprintf((char *)t, j, "%02x%s", *s++, 			((i& 3) == 3) ? " " : ""); 		t += ((i& 3) == 3) ? 3 : 2; 		j -= ((i& 3) == 3) ? 3 : 2; 	} 	*t++ = '\n'; 	*t = '\0'; 	printf("%s", outb); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * look for bad consistancies between the list of interfaces the filter knows  * about and those which are currently configured.  */
end_comment

begin_function
specifier|static
name|int
name|ipf_qifsync
parameter_list|(
name|ip
parameter_list|,
name|hlen
parameter_list|,
name|il
parameter_list|,
name|out
parameter_list|,
name|qif
parameter_list|,
name|mp
parameter_list|)
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|void
modifier|*
name|il
decl_stmt|;
name|int
name|out
decl_stmt|;
name|qif_t
modifier|*
name|qif
decl_stmt|;
name|mblk_t
modifier|*
modifier|*
name|mp
decl_stmt|;
block|{
specifier|register
name|struct
name|frentry
modifier|*
name|f
decl_stmt|;
specifier|register
name|ipnat_t
modifier|*
name|np
decl_stmt|;
name|ipfsync
argument_list|(
operator|&
name|ipfmain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IPFDEBUG
end_ifdef

begin_function
name|void
name|printiri
parameter_list|(
name|iri
parameter_list|)
name|irinfo_t
modifier|*
name|iri
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"iri: ll_hdr_mp %p rfq %p stq %p\n"
argument_list|,
name|iri
operator|->
name|ir_ll_hdr_mp
argument_list|,
name|iri
operator|->
name|ir_rfq
argument_list|,
name|iri
operator|->
name|ir_stq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iri: ll_hdr_length %d ir_ill %p\n"
argument_list|,
name|iri
operator|->
name|ir_ll_hdr_length
argument_list|,
name|iri
operator|->
name|ir_ill
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ipfsync
parameter_list|()
block|{
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|qif_t
modifier|*
name|qif
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"lan%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|spinlock
argument_list|(
operator|&
name|pfil_rw
argument_list|)
expr_stmt|;
name|qif
operator|=
name|qif_iflookup
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|qif
operator|!=
name|NULL
condition|)
name|ipf_qifsync
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|qif
operator|->
name|qf_ill
argument_list|,
operator|-
literal|1
argument_list|,
name|qif
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|spinunlock
argument_list|(
operator|&
name|pfil_rw
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipf_slowtimer
parameter_list|()
block|{
if|if
condition|(
name|ipf_running
operator|<=
literal|0
condition|)
block|{
name|ipf_timer_id
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|READ_ENTER
argument_list|(
operator|&
name|ipf_global
argument_list|)
expr_stmt|;
name|ipf_frag_expire
argument_list|()
expr_stmt|;
name|ipf_state_expire
argument_list|()
expr_stmt|;
name|ipf_nat_expire
argument_list|()
expr_stmt|;
name|ipf_auth_expire
argument_list|()
expr_stmt|;
name|ipf_lookup_expire
argument_list|()
expr_stmt|;
name|ipf_rule_expire
argument_list|()
expr_stmt|;
name|ipf_ticks
operator|++
expr_stmt|;
name|ipf_timer_id
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ipf_running
operator|<=
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_global
argument_list|)
expr_stmt|;
return|return;
block|}
name|ipf_timer_id
operator|=
name|mp_timeout
argument_list|(
name|ipf_slowtimer
argument_list|,
name|NULL
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_global
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * routines below for saving IP headers to buffer  */
end_comment

begin_function
name|int
name|ipfopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|dummy
parameter_list|,
name|mode
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|intptr_t
name|dummy
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|minor_t
name|unit
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"ipfopen(%x,%x,%x,%x)\n"
argument_list|,
name|dev
argument_list|,
name|flag
argument_list|,
name|dummy
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|IPL_LOGMAX
operator|<
name|unit
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|unit
condition|)
block|{
case|case
name|IPL_LOGIPF
case|:
case|case
name|IPL_LOGNAT
case|:
case|case
name|IPL_LOGSTATE
case|:
case|case
name|IPL_LOGAUTH
case|:
case|case
name|IPL_LOGLOOKUP
case|:
case|case
name|IPL_LOGSYNC
case|:
ifdef|#
directive|ifdef
name|IPFILTER_SCAN
case|case
name|IPL_LOGSCAN
case|:
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default :
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|ipfclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|minor_t
name|unit
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"ipfclose(%x,%x,%x)\n"
argument_list|,
name|dev
argument_list|,
name|flag
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ipf_running
operator|<
literal|1
condition|)
return|return
name|EIO
return|;
name|unit
operator|=
operator|(
name|IPL_LOGMAX
operator|<
name|unit
operator|)
condition|?
name|ENXIO
else|:
literal|0
expr_stmt|;
return|return
name|unit
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IPFILTER_LOG
end_ifdef

begin_comment
comment|/*  * ipfread/ipflog  * both of these must operate with at least splnet() lest they be  * called during packet processing and cause an inconsistancy to appear in  * the filter lists.  */
end_comment

begin_function
name|int
name|ipfread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"ipfread(%x,%x)\n"
argument_list|,
name|dev
argument_list|,
name|uio
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ipf_running
operator|<
literal|1
condition|)
return|return
name|EIO
return|;
return|return
name|ipflog_read
argument_list|(
name|getminor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|uio
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPFILTER_LOG */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * ipfread/ipflog  * both of these must operate with at least splnet() lest they be  * called during packet processing and cause an inconsistancy to appear in  * the filter lists.  */
end_comment

begin_ifdef
unit|int ipfwrite(dev, uio, cp) 	dev_t dev; 	register struct uio *uio; 	cred_t *cp; {
ifdef|#
directive|ifdef
name|IPFDEBUG
end_ifdef

begin_endif
unit|cmn_err(CE_CONT, "ipfwrite(%x,%x,%x)\n", dev, uio, cp);
endif|#
directive|endif
end_endif

begin_endif
unit|if (ipf_running< 1) 		return EIO;  	if (getminor(dev) != IPL_LOGSYNC) 		return ENXIO; 	return ipfsync_write(uio); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPFILTER_SYNC */
end_comment

end_unit

