begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Source: /mit/kerberos/src/lib/des/RCS/misc.c,v $  * $Author: jtkohl $  *  * Copyright 1988 by the Massachusetts Institute of Technology.  *  * For copying and distribution information,  * please seethe file<mit-copyright.h>.  *  * This file contains most of the routines needed by the various  * make_foo programs, to account for bit- and byte-ordering on  * different machine types.  It also contains other routines useful in  * generating the intermediate source files.  */
end_comment

begin_include
include|#
directive|include
file|<mit-copyright.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"des_internal.h"
end_include

begin_comment
comment|/*  * The DES algorithm is defined in terms of MSBFIRST, so sometimes,  * e.g.  VAXes, we need to fix it up.  ANSI order means the DES  * MSBFIRST order.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* These don't seem to get used anywhere.... */
end_comment

begin_ifdef
unit|void swap_bits(array)     char *array; {
ifdef|#
directive|ifdef
name|MSBFIRST
end_ifdef

begin_comment
comment|/* just return */
end_comment

begin_else
unit|return;
else|#
directive|else
end_else

begin_comment
comment|/* LSBFIRST */
end_comment

begin_comment
unit|register old,new,i,j;
comment|/* for an eight byte block-- */
end_comment

begin_comment
comment|/* flips the bit order within each byte from 0 lsb to 0 msb */
end_comment

begin_comment
unit|for (i = 0; i<=7; i++) {         old = *array;         new = 0;         for (j = 0; j<=7; j++) {             new |= old& 01;
comment|/* copy a bit */
end_comment

begin_comment
unit|if (j< 7) {
comment|/* rotate in opposite directions */
end_comment

begin_endif
unit|old = old>> 1;                 new = new<< 1;             }         }         *array++ = new;     }
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSBFIRST */
end_comment

begin_ifdef
unit|}  unsigned long long_swap_bits(x)     unsigned long x; {
ifdef|#
directive|ifdef
name|MSBFIRST
end_ifdef

begin_else
unit|return x;
else|#
directive|else
end_else

begin_comment
unit|char *array = (char *)&x;     register old,new,i,j;
comment|/* flips the bit order within each byte from 0 lsb to 0 msb */
end_comment

begin_endif
unit|for (i = 0; i<= (sizeof(long)-1); i++) {         old = *array;         new = 0;         for (j = 0; j<=7; j++) {             if (old& 01)                 new = new | 01;             if (j< 7) {                 old = old>> 1;                 new = new<< 1;             }         }         *array++ = new;     }     return x;
endif|#
directive|endif
end_endif

begin_comment
comment|/* LSBFIRST */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
name|unsigned
name|long
name|swap_six_bits_to_ansi
parameter_list|(
name|old
parameter_list|)
name|unsigned
name|long
name|old
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|new
decl_stmt|,
name|j
decl_stmt|;
comment|/* flips the bit order within each byte from 0 lsb to 0 msb */
name|new
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|5
condition|;
name|j
operator|++
control|)
block|{
name|new
operator||=
name|old
operator|&
literal|01
expr_stmt|;
comment|/* copy a bit */
if|if
condition|(
name|j
operator|<
literal|5
condition|)
block|{
comment|/* rotate in opposite directions */
name|old
operator|=
name|old
operator|>>
literal|1
expr_stmt|;
name|new
operator|=
name|new
operator|<<
literal|1
expr_stmt|;
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|swap_four_bits_to_ansi
parameter_list|(
name|old
parameter_list|)
name|unsigned
name|long
name|old
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|new
decl_stmt|,
name|j
decl_stmt|;
comment|/* flips the bit order within each byte from 0 lsb to 0 msb */
name|new
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|new
operator||=
operator|(
name|old
operator|&
literal|01
operator|)
expr_stmt|;
comment|/* copy a bit */
if|if
condition|(
name|j
operator|<
literal|3
condition|)
block|{
name|old
operator|=
name|old
operator|>>
literal|1
expr_stmt|;
name|new
operator|=
name|new
operator|<<
literal|1
expr_stmt|;
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|swap_bit_pos_1
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|long
name|x
decl_stmt|;
block|{
comment|/*      * This corrects for the bit ordering of the algorithm, e.g.      * bit 0 ==> msb, bit 7 lsb.      *      * given the number of a bit position,>=1, flips the bit order      * each byte. e.g. bit 3 --> bit 6, bit 13 --> bit 12      */
specifier|register
name|y
operator|,
name|z
expr_stmt|;
comment|/* always do it, only used by des_make_key_perm.c so far */
name|y
operator|=
operator|(
name|x
operator|-
literal|1
operator|)
operator|/
literal|8
expr_stmt|;
name|z
operator|=
operator|(
name|x
operator|-
literal|1
operator|)
operator|%
literal|8
expr_stmt|;
name|x
operator|=
operator|(
literal|8
operator|-
name|z
operator|)
operator|+
operator|(
name|y
operator|*
literal|8
operator|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|swap_bit_pos_0
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|long
name|x
decl_stmt|;
block|{
comment|/*  zero based version */
comment|/*      * This corrects for the bit ordering of the algorithm, e.g.      * bit 0 ==> msb, bit 7 lsb.      */
ifdef|#
directive|ifdef
name|MSBFIRST
return|return
name|x
return|;
else|#
directive|else
comment|/* LSBFIRST */
specifier|register
name|y
operator|,
name|z
expr_stmt|;
comment|/*      * given the number of a bit position,>=0, flips the bit order      * each byte. e.g. bit 3 --> bit 6, bit 13 --> bit 12      */
name|y
operator|=
name|x
operator|/
literal|8
expr_stmt|;
name|z
operator|=
name|x
operator|%
literal|8
expr_stmt|;
name|x
operator|=
operator|(
literal|7
operator|-
name|z
operator|)
operator|+
operator|(
name|y
operator|*
literal|8
operator|)
expr_stmt|;
return|return
name|x
return|;
endif|#
directive|endif
comment|/* LSBFIRST */
block|}
end_function

begin_function
name|unsigned
name|long
name|swap_bit_pos_0_to_ansi
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|long
name|x
decl_stmt|;
block|{
comment|/* zero based version */
comment|/*      * This corrects for the bit ordering of the algorithm, e.g.      * bit 0 ==> msb, bit 7 lsb.      */
specifier|register
name|y
operator|,
name|z
expr_stmt|;
comment|/*      * given the number of a bit position,>=0, flips the bit order each      * byte. e.g. bit 3 --> bit 6, bit 13 --> bit 12      */
name|y
operator|=
name|x
operator|/
literal|8
expr_stmt|;
name|z
operator|=
name|x
operator|%
literal|8
expr_stmt|;
name|x
operator|=
operator|(
literal|7
operator|-
name|z
operator|)
operator|+
operator|(
name|y
operator|*
literal|8
operator|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|rev_swap_bit_pos_0
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|long
name|x
decl_stmt|;
block|{
comment|/* zero based version */
comment|/*      * This corrects for the bit ordering of the algorithm, e.g.      *  bit 0 ==> msb, bit 7 lsb.      *      * Role of LSB and MSB flipped from the swap_bit_pos_0()      */
ifdef|#
directive|ifdef
name|LSBFIRST
return|return
name|x
return|;
else|#
directive|else
comment|/* MSBFIRST */
specifier|register
name|y
operator|,
name|z
expr_stmt|;
comment|/*      * given the number of a bit position,>=0, flips the bit order each      * byte. e.g. bit 3 --> bit 6, bit 13 --> bit 12      */
name|y
operator|=
name|x
operator|/
literal|8
expr_stmt|;
name|z
operator|=
name|x
operator|%
literal|8
expr_stmt|;
name|x
operator|=
operator|(
literal|7
operator|-
name|z
operator|)
operator|+
operator|(
name|y
operator|*
literal|8
operator|)
expr_stmt|;
return|return
name|x
return|;
endif|#
directive|endif
comment|/* MSBFIRST */
block|}
end_function

begin_function
name|unsigned
name|long
name|swap_byte_bits
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|long
name|x
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MSBFIRST
return|return
name|x
return|;
else|#
directive|else
comment|/* LSBFIRST */
name|char
modifier|*
name|array
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|x
decl_stmt|;
specifier|register
name|unsigned
name|long
name|old
decl_stmt|,
name|new
decl_stmt|,
name|j
decl_stmt|;
comment|/* flips the bit order within each byte from 0 lsb to 0 msb */
name|old
operator|=
operator|*
name|array
expr_stmt|;
name|new
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|7
condition|;
name|j
operator|++
control|)
block|{
name|new
operator||=
operator|(
name|old
operator|&
literal|01
operator|)
expr_stmt|;
comment|/* copy a bit */
if|if
condition|(
name|j
operator|<
literal|7
condition|)
block|{
name|old
operator|=
name|old
operator|>>
literal|1
expr_stmt|;
name|new
operator|=
name|new
operator|<<
literal|1
expr_stmt|;
block|}
block|}
return|return
name|new
return|;
endif|#
directive|endif
comment|/* LSBFIRST */
block|}
end_function

begin_macro
name|swap_long_bytes_bit_number
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|long
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*      * given a bit number (0-31) from a vax, swap the byte part of the      * bit number to change the byte ordering to mSBFIRST type      */
ifdef|#
directive|ifdef
name|LSBFIRST
return|return
name|x
return|;
else|#
directive|else
comment|/* MSBFIRST */
name|unsigned
name|long
name|y
decl_stmt|,
name|z
decl_stmt|;
name|y
operator|=
name|x
operator|/
literal|8
expr_stmt|;
comment|/* initial byte component */
name|z
operator|=
name|x
operator|%
literal|8
expr_stmt|;
comment|/* bit within byte */
name|x
operator|=
operator|(
literal|3
operator|-
name|y
operator|)
operator|*
literal|8
operator|+
name|z
expr_stmt|;
return|return
name|x
return|;
endif|#
directive|endif
comment|/* MSBFIRST */
block|}
end_block

begin_function
name|void
name|test_set
parameter_list|(
name|stream
parameter_list|,
name|src
parameter_list|,
name|testbit
parameter_list|,
name|dest
parameter_list|,
name|setbit
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|int
name|testbit
decl_stmt|;
specifier|const
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|setbit
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DES_SHIFT_SHIFT
if|if
condition|(
name|testbit
operator|==
name|setbit
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"    %s |=  %s& (1<<%2d);\n"
argument_list|,
name|dest
argument_list|,
name|src
argument_list|,
name|testbit
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"    %s |= (%s& (1<<%2d)) %s %2d;\n"
argument_list|,
name|dest
argument_list|,
name|src
argument_list|,
name|testbit
argument_list|,
operator|(
name|testbit
operator|<
name|setbit
operator|)
condition|?
literal|"<<"
else|:
literal|">>"
argument_list|,
name|abs
argument_list|(
name|testbit
operator|-
name|setbit
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"    if (%s& (1<<%2d))  %s |= 1<<%2d;\n"
argument_list|,
name|src
argument_list|,
name|testbit
argument_list|,
name|dest
argument_list|,
name|setbit
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|extern
name|void
name|gen
name|PROTOTYPE
argument_list|(
operator|(
name|FILE
operator|*
name|stream
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|des_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
specifier|const
modifier|*
name|whoami
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|whoami
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|argc
operator|--
operator|,
operator|*
operator|++
name|argv
condition|)
block|{
name|arg
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-d"
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-debug"
argument_list|)
condition|)
name|des_debug
operator|++
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown control argument %s\n"
argument_list|,
name|whoami
argument_list|,
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|filename
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: multiple file names provided: %s, %s\n"
argument_list|,
name|whoami
argument_list|,
name|filename
argument_list|,
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
else|else
name|filename
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|filename
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no file name provided\n"
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|stream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|usage
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-debug] filename\n"
argument_list|,
name|whoami
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"/* This file is automatically generated.  Do not edit it. */\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* This routine will generate the contents of the file. */
name|gen
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|stream
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

