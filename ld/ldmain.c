begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Main program of GNU linker.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Written by Steve Chamberlain steve@cygnus.com     This file is part of GLD, the Gnu Linker.     GLD is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GLD is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GLD; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldwrite.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|<ldgram.h>
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"ldctor.h"
end_include

begin_comment
comment|/* Somewhere above, sys/stat.h got included.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SBRK
end_ifdef

begin_if
if|#
directive|if
operator|!
name|HAVE_DECL_SBRK
end_if

begin_function_decl
specifier|extern
name|void
modifier|*
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_SYSTEM_ROOT
end_ifndef

begin_define
define|#
directive|define
name|TARGET_SYSTEM_ROOT
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXPORTS */
end_comment

begin_decl_stmt
name|char
modifier|*
name|default_target
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|output_filename
init|=
literal|"a.out"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name this program was invoked by.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The prefix for system library directories.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ld_sysroot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The canonical representation of ld_sysroot.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ld_canon_sysroot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ld_canon_sysroot_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The file that we're creating.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|output_bfd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -G argument, for MIPS ECOFF target.  */
end_comment

begin_decl_stmt
name|int
name|g_switch_value
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print names of input files as processed.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|trace_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means same, but note open failures, too.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|trace_file_tries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means version number was printed, so exit successfully    instead of complaining if no input files are given.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|version_printed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means link in every member of an archive.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|whole_archive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means create DT_NEEDED entries only if a dynamic library    actually satisfies some reference in a regular object.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|as_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means never create DT_NEEDED entries for dynamic libraries    in DT_NEEDED tags.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|add_needed
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if we should demangle symbol names.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|demangling
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|args_type
name|command_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ld_config_type
name|config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sort_type
name|sort_section
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_sysroot
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_emulation
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_scripts_dir
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|add_archive_element
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|multiple_definition
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|multiple_common
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|enum
name|bfd_link_hash_type
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|enum
name|bfd_link_hash_type
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|add_to_set
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|bfd_link_hash_entry
modifier|*
parameter_list|,
name|bfd_reloc_code_real_type
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|constructor_callback
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|warning_callback
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warning_find_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|undefined_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|reloc_overflow
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|bfd_link_hash_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|reloc_dangerous
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|unattached_reloc
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|notice
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_callbacks
name|link_callbacks
init|=
block|{
name|add_archive_element
block|,
name|multiple_definition
block|,
name|multiple_common
block|,
name|add_to_set
block|,
name|constructor_callback
block|,
name|warning_callback
block|,
name|undefined_symbol
block|,
name|reloc_overflow
block|,
name|reloc_dangerous
block|,
name|unattached_reloc
block|,
name|notice
block|,
name|einfo
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
name|link_info
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remove_output
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|output_filename
condition|)
block|{
if|if
condition|(
name|output_bfd
condition|)
name|bfd_cache_close
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_output_file_on_failure
condition|)
name|unlink_if_ordinary
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|emulation
decl_stmt|;
name|long
name|start_time
init|=
name|get_run_time
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|START_PROGRESS
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expandargv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|bfd_set_error_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|xatexit
argument_list|(
name|remove_output
argument_list|)
expr_stmt|;
comment|/* Set up the sysroot directory.  */
name|ld_sysroot
operator|=
name|get_sysroot
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ld_sysroot
condition|)
block|{
if|if
condition|(
operator|*
name|TARGET_SYSTEM_ROOT
operator|==
literal|0
condition|)
block|{
name|einfo
argument_list|(
literal|"%P%F: this linker was not configured to use sysroots\n"
argument_list|)
expr_stmt|;
name|ld_sysroot
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|ld_canon_sysroot
operator|=
name|lrealpath
argument_list|(
name|ld_sysroot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ld_canon_sysroot
condition|)
name|ld_canon_sysroot_len
operator|=
name|strlen
argument_list|(
name|ld_canon_sysroot
argument_list|)
expr_stmt|;
else|else
name|ld_canon_sysroot_len
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Set the default BFD target based on the configured target.  Doing      this permits the linker to be configured for a particular target,      and linked against a shared BFD library which was configured for      a different target.  The macro TARGET is defined by Makefile.  */
if|if
condition|(
operator|!
name|bfd_set_default_target
argument_list|(
name|TARGET
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: can't set BFD default target to `%s': %E\n"
argument_list|)
argument_list|,
name|TARGET
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|YYDEBUG
block|{
specifier|extern
name|int
name|yydebug
decl_stmt|;
name|yydebug
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initialize the data about options.  */
name|trace_files
operator|=
name|trace_file_tries
operator|=
name|version_printed
operator|=
name|FALSE
expr_stmt|;
name|whole_archive
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|build_constructors
operator|=
name|TRUE
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|has_shared
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|split_by_reloc
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
name|config
operator|.
name|split_by_file
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
name|config
operator|.
name|hash_table_size
operator|=
literal|0
expr_stmt|;
name|command_line
operator|.
name|force_common_definition
operator|=
name|FALSE
expr_stmt|;
name|command_line
operator|.
name|inhibit_common_definition
operator|=
name|FALSE
expr_stmt|;
name|command_line
operator|.
name|interpreter
operator|=
name|NULL
expr_stmt|;
name|command_line
operator|.
name|rpath
operator|=
name|NULL
expr_stmt|;
name|command_line
operator|.
name|warn_mismatch
operator|=
name|TRUE
expr_stmt|;
name|command_line
operator|.
name|check_section_addresses
operator|=
name|TRUE
expr_stmt|;
name|command_line
operator|.
name|accept_unknown_input_arch
operator|=
name|FALSE
expr_stmt|;
name|command_line
operator|.
name|reduce_memory_overheads
operator|=
name|FALSE
expr_stmt|;
name|sort_section
operator|=
name|none
expr_stmt|;
comment|/* We initialize DEMANGLING based on the environment variable      COLLECT_NO_DEMANGLE.  The gcc collect2 program will demangle the      output of the linker, unless COLLECT_NO_DEMANGLE is set in the      environment.  Acting the same way here lets us provide the same      interface by default.  */
name|demangling
operator|=
name|getenv
argument_list|(
literal|"COLLECT_NO_DEMANGLE"
argument_list|)
operator|==
name|NULL
expr_stmt|;
name|link_info
operator|.
name|relocatable
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|emitrelocations
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|task_link
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|shared
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|pie
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|executable
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|symbolic
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|export_dynamic
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|static_link
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|traditional_format
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|optimize
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|=
name|RM_NOT_YET_SET
expr_stmt|;
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|=
name|RM_NOT_YET_SET
expr_stmt|;
name|link_info
operator|.
name|allow_multiple_definition
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|allow_undefined_version
operator|=
name|TRUE
expr_stmt|;
name|link_info
operator|.
name|create_default_symver
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|default_imported_symver
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|keep_memory
operator|=
name|TRUE
expr_stmt|;
name|link_info
operator|.
name|notice_all
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|nocopyreloc
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|new_dtags
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|combreloc
operator|=
name|TRUE
expr_stmt|;
name|link_info
operator|.
name|eh_frame_hdr
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|relro
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|strip_discarded
operator|=
name|TRUE
expr_stmt|;
name|link_info
operator|.
name|strip
operator|=
name|strip_none
expr_stmt|;
name|link_info
operator|.
name|discard
operator|=
name|discard_sec_merge
expr_stmt|;
name|link_info
operator|.
name|common_skip_ar_aymbols
operator|=
name|bfd_link_common_skip_none
expr_stmt|;
name|link_info
operator|.
name|callbacks
operator|=
operator|&
name|link_callbacks
expr_stmt|;
name|link_info
operator|.
name|hash
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|keep_hash
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|notice_hash
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|wrap_hash
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|input_bfds
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|create_object_symbols_section
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|gc_sym_list
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|base_file
operator|=
name|NULL
expr_stmt|;
comment|/* SVR4 linkers seem to set DT_INIT and DT_FINI based on magic _init      and _fini symbols.  We are compatible.  */
name|link_info
operator|.
name|init_function
operator|=
literal|"_init"
expr_stmt|;
name|link_info
operator|.
name|fini_function
operator|=
literal|"_fini"
expr_stmt|;
name|link_info
operator|.
name|pei386_auto_import
operator|=
operator|-
literal|1
expr_stmt|;
name|link_info
operator|.
name|pei386_runtime_pseudo_reloc
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|spare_dynamic_tags
operator|=
literal|5
expr_stmt|;
name|link_info
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|link_info
operator|.
name|flags_1
operator|=
literal|0
expr_stmt|;
name|link_info
operator|.
name|relax_pass
operator|=
literal|1
expr_stmt|;
name|link_info
operator|.
name|warn_shared_textrel
operator|=
name|FALSE
expr_stmt|;
name|link_info
operator|.
name|gc_sections
operator|=
name|FALSE
expr_stmt|;
name|ldfile_add_arch
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|config
operator|.
name|make_executable
operator|=
name|TRUE
expr_stmt|;
name|force_make_executable
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|TRUE
expr_stmt|;
name|config
operator|.
name|text_read_only
operator|=
name|TRUE
expr_stmt|;
name|emulation
operator|=
name|get_emulation
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|ldemul_choose_mode
argument_list|(
name|emulation
argument_list|)
expr_stmt|;
name|default_target
operator|=
name|ldemul_choose_target
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|lang_init
argument_list|()
expr_stmt|;
name|ldemul_before_parse
argument_list|()
expr_stmt|;
name|lang_has_input_file
operator|=
name|FALSE
expr_stmt|;
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|hash_table_size
operator|!=
literal|0
condition|)
name|bfd_hash_set_default_size
argument_list|(
name|config
operator|.
name|hash_table_size
argument_list|)
expr_stmt|;
name|ldemul_set_symbols
argument_list|()
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|relocatable
condition|)
block|{
if|if
condition|(
name|link_info
operator|.
name|gc_sections
condition|)
name|einfo
argument_list|(
literal|"%P%F: --gc-sections and -r may not be used together\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|command_line
operator|.
name|relax
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: --relax and -r may not be used together\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|shared
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: -r and -shared may not be used together\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|link_info
operator|.
name|shared
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|filter_shlib
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: -F may not be used without -shared\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|auxiliary_filters
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: -f may not be used without -shared\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|link_info
operator|.
name|shared
operator|||
name|link_info
operator|.
name|pie
condition|)
name|link_info
operator|.
name|executable
operator|=
name|TRUE
expr_stmt|;
comment|/* Treat ld -r -s as ld -r -S -x (i.e., strip all local symbols).  I      don't see how else this can be handled, since in this case we      must preserve all externally visible symbols.  */
if|if
condition|(
name|link_info
operator|.
name|relocatable
operator|&&
name|link_info
operator|.
name|strip
operator|==
name|strip_all
condition|)
block|{
name|link_info
operator|.
name|strip
operator|=
name|strip_debugger
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|discard
operator|==
name|discard_sec_merge
condition|)
name|link_info
operator|.
name|discard
operator|=
name|discard_all
expr_stmt|;
block|}
comment|/* This essentially adds another -L directory so this must be done after      the -L's in argv have been processed.  */
name|set_scripts_dir
argument_list|()
expr_stmt|;
comment|/* If we have not already opened and parsed a linker script      read the emulation's appropriate default script.  */
if|if
condition|(
name|saved_script_handle
operator|==
name|NULL
condition|)
block|{
name|int
name|isfile
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|ldemul_get_script
argument_list|(
operator|&
name|isfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|isfile
condition|)
name|ldfile_open_command_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|lex_string
operator|=
name|s
expr_stmt|;
name|lex_redirect
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|parser_input
operator|=
name|input_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|lex_string
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|trace_file_tries
condition|)
block|{
if|if
condition|(
name|saved_script_handle
condition|)
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"using external linker script:"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"using internal linker script:"
argument_list|)
argument_list|)
expr_stmt|;
name|info_msg
argument_list|(
literal|"\n==================================================\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_script_handle
condition|)
block|{
specifier|static
specifier|const
name|int
name|ld_bufsz
init|=
literal|8193
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|ld_bufsz
argument_list|)
decl_stmt|;
name|rewind
argument_list|(
name|saved_script_handle
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|ld_bufsz
operator|-
literal|1
argument_list|,
name|saved_script_handle
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|buf
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|info_msg
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|rewind
argument_list|(
name|saved_script_handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|isfile
decl_stmt|;
name|info_msg
argument_list|(
name|ldemul_get_script
argument_list|(
operator|&
name|isfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|info_msg
argument_list|(
literal|"\n==================================================\n"
argument_list|)
expr_stmt|;
block|}
name|lang_final
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|lang_has_input_file
condition|)
block|{
if|if
condition|(
name|version_printed
condition|)
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: no input files\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace_files
condition|)
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"%P: mode %s\n"
argument_list|)
argument_list|,
name|emulation
argument_list|)
expr_stmt|;
name|ldemul_after_parse
argument_list|()
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|map_filename
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|config
operator|.
name|map_filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|.
name|map_file
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|config
operator|.
name|map_file
operator|=
name|fopen
argument_list|(
name|config
operator|.
name|map_filename
argument_list|,
name|FOPEN_WT
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|map_file
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: cannot open map file %s: %E\n"
argument_list|)
argument_list|,
name|config
operator|.
name|map_filename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|lang_process
argument_list|()
expr_stmt|;
comment|/* Print error messages for any missing symbols, for any warning      symbols, and possibly multiple definitions.  */
if|if
condition|(
name|link_info
operator|.
name|relocatable
condition|)
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|EXEC_P
expr_stmt|;
else|else
name|output_bfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
name|ldwrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|map_file
operator|!=
name|NULL
condition|)
name|lang_map
argument_list|()
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|cref
condition|)
name|output_cref
argument_list|(
name|config
operator|.
name|map_file
operator|!=
name|NULL
condition|?
name|config
operator|.
name|map_file
else|:
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nocrossref_list
operator|!=
name|NULL
condition|)
name|check_nocrossrefs
argument_list|()
expr_stmt|;
name|lang_finish
argument_list|()
expr_stmt|;
comment|/* Even if we're producing relocatable output, some non-fatal errors should      be reported in the exit status.  (What non-fatal errors, if any, do we      want to ignore for relocatable output?)  */
if|if
condition|(
operator|!
name|config
operator|.
name|make_executable
operator|&&
operator|!
name|force_make_executable
condition|)
block|{
if|if
condition|(
name|trace_files
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: link errors found, deleting executable `%s'\n"
argument_list|)
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
comment|/* The file will be removed by remove_output.  */
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%B: final close failed: %E\n"
argument_list|)
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* If the --force-exe-suffix is enabled, and we're making an 	 executable file and it doesn't end in .exe, copy it to one 	 which does.  */
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocatable
operator|&&
name|command_line
operator|.
name|force_exe_suffix
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|output_filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
operator|||
operator|(
name|strcasecmp
argument_list|(
name|output_filename
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".exe"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|output_filename
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".dll"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|FILE
modifier|*
name|src
decl_stmt|;
name|FILE
modifier|*
name|dst
decl_stmt|;
specifier|const
name|int
name|bsize
init|=
literal|4096
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|bsize
argument_list|)
decl_stmt|;
name|int
name|l
decl_stmt|;
name|char
modifier|*
name|dst_name
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|5
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dst_name
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dst_name
argument_list|,
literal|".exe"
argument_list|)
expr_stmt|;
name|src
operator|=
name|fopen
argument_list|(
name|output_filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
name|dst
operator|=
name|fopen
argument_list|(
name|dst_name
argument_list|,
name|FOPEN_WB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|src
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: unable to open for source of copy `%s'\n"
argument_list|)
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: unable to open for destination of copy `%s'\n"
argument_list|)
argument_list|,
name|dst_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|l
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|bsize
argument_list|,
name|src
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|done
init|=
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|l
argument_list|,
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|done
operator|!=
name|l
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: Error writing file `%s'\n"
argument_list|)
argument_list|,
name|dst_name
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|dst
argument_list|)
operator|==
name|EOF
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: Error closing file `%s'\n"
argument_list|)
argument_list|,
name|dst_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dst_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|END_PROGRESS
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|stats
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|char
modifier|*
name|lim
init|=
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|long
name|run_time
init|=
name|get_run_time
argument_list|()
operator|-
name|start_time
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: total time in link: %ld.%06ld\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|run_time
operator|/
literal|1000000
argument_list|,
name|run_time
operator|%
literal|1000000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: data size %ld\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Prevent remove_output from doing anything, after a successful link.  */
name|output_filename
operator|=
name|NULL
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If the configured sysroot is relocatable, try relocating it based on    default prefix FROM.  Return the relocated directory if it exists,    otherwise return null.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_relative_sysroot
parameter_list|(
specifier|const
name|char
modifier|*
name|from
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TARGET_SYSTEM_ROOT_RELOCATABLE
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|path
operator|=
name|make_relative_prefix
argument_list|(
name|program_name
argument_list|,
name|from
argument_list|,
name|TARGET_SYSTEM_ROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|path
return|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the sysroot directory.  Return "" if no sysroot is being used.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_sysroot
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--sysroot="
argument_list|,
name|strlen
argument_list|(
literal|"--sysroot="
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|argv
index|[
name|i
index|]
operator|+
name|strlen
argument_list|(
literal|"--sysroot="
argument_list|)
return|;
name|path
operator|=
name|get_relative_sysroot
argument_list|(
name|BINDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
return|return
name|path
return|;
name|path
operator|=
name|get_relative_sysroot
argument_list|(
name|TOOLBINDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
return|return
name|path
return|;
return|return
name|TARGET_SYSTEM_ROOT
return|;
block|}
end_function

begin_comment
comment|/* We need to find any explicitly given emulation in order to initialize the    state that's needed by the lex&yacc argument parser (parse_args).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_emulation
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|emulation
decl_stmt|;
name|int
name|i
decl_stmt|;
name|emulation
operator|=
name|getenv
argument_list|(
name|EMULATION_ENVIRON
argument_list|)
expr_stmt|;
if|if
condition|(
name|emulation
operator|==
name|NULL
condition|)
name|emulation
operator|=
name|DEFAULT_EMULATION
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-m"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* -m EMUL */
if|if
condition|(
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|emulation
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: missing argument to -m\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips1"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips3"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips4"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips5"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips32"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips32r2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips64"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips64r2"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: The arguments -mips1, -mips2, -mips3, etc. are 		 passed to the linker by some MIPS compilers.  They 		 generally tell the linker to use a slightly different 		 library path.  Perhaps someday these should be 		 implemented as emulations; until then, we just ignore 		 the arguments and hope that nobody ever creates 		 emulations named ips1, ips2 or ips3.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-m486"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: The argument -m486 is passed to the linker on 		 some Linux systems.  Hope that nobody creates an 		 emulation named 486.  */
block|}
else|else
block|{
comment|/* -mEMUL */
name|emulation
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
return|return
name|emulation
return|;
block|}
end_function

begin_comment
comment|/* If directory DIR contains an "ldscripts" subdirectory,    add DIR to the library search path and return TRUE,    else return FALSE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|check_for_scripts_dir
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|size_t
name|dirlen
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|bfd_boolean
name|res
decl_stmt|;
name|dirlen
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
comment|/* sizeof counts the terminating NUL.  */
name|buf
operator|=
name|xmalloc
argument_list|(
name|dirlen
operator|+
sizeof|sizeof
argument_list|(
literal|"/ldscripts"
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/ldscripts"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|res
operator|=
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|ldfile_add_library_path
argument_list|(
name|dir
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Set the default directory for finding script files.    Libraries will be searched for here too, but that's ok.    We look for the "ldscripts" directory in:     SCRIPTDIR (passed from Makefile) 	     (adjusted according to the current location of the binary)    SCRIPTDIR (passed from Makefile)    the dir where this program is (for using it from the build tree)    the dir where this program is/../lib 	     (for installing the tool suite elsewhere).  */
end_comment

begin_function
specifier|static
name|void
name|set_scripts_dir
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
name|size_t
name|dirlen
decl_stmt|;
name|bfd_boolean
name|found
decl_stmt|;
name|dir
operator|=
name|make_relative_prefix
argument_list|(
name|program_name
argument_list|,
name|BINDIR
argument_list|,
name|SCRIPTDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
block|{
name|found
operator|=
name|check_for_scripts_dir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return;
block|}
name|dir
operator|=
name|make_relative_prefix
argument_list|(
name|program_name
argument_list|,
name|TOOLBINDIR
argument_list|,
name|SCRIPTDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
block|{
name|found
operator|=
name|check_for_scripts_dir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return;
block|}
if|if
condition|(
name|check_for_scripts_dir
argument_list|(
name|SCRIPTDIR
argument_list|)
condition|)
comment|/* We've been installed normally.  */
return|return;
comment|/* Look for "ldscripts" in the dir where our binary is.  */
name|end
operator|=
name|strrchr
argument_list|(
name|program_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
block|{
comment|/* We could have \foo\bar, or /foo\bar.  */
name|char
modifier|*
name|bslash
init|=
name|strrchr
argument_list|(
name|program_name
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
operator|||
operator|(
name|bslash
operator|!=
name|NULL
operator|&&
name|bslash
operator|>
name|end
operator|)
condition|)
name|end
operator|=
name|bslash
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
comment|/* Don't look for ldscripts in the current directory.  There is        too much potential for confusion.  */
return|return;
name|dirlen
operator|=
name|end
operator|-
name|program_name
expr_stmt|;
comment|/* Make a copy of program_name in dir.      Leave room for later "/../lib".  */
name|dir
operator|=
name|xmalloc
argument_list|(
name|dirlen
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dir
argument_list|,
name|program_name
argument_list|,
name|dirlen
argument_list|)
expr_stmt|;
name|dir
index|[
name|dirlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|check_for_scripts_dir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Look for "ldscripts" in<the dir where our binary is>/../lib.  */
name|strcpy
argument_list|(
name|dir
operator|+
name|dirlen
argument_list|,
literal|"/../lib"
argument_list|)
expr_stmt|;
name|check_for_scripts_dir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_ysym
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|link_info
operator|.
name|notice_hash
operator|==
name|NULL
condition|)
block|{
name|link_info
operator|.
name|notice_hash
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
name|link_info
operator|.
name|notice_hash
argument_list|,
name|bfd_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
argument_list|)
argument_list|,
literal|61
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_table_init failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|link_info
operator|.
name|notice_hash
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record a symbol to be wrapped, from the --wrap option.  */
end_comment

begin_function
name|void
name|add_wrap
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|link_info
operator|.
name|wrap_hash
operator|==
name|NULL
condition|)
block|{
name|link_info
operator|.
name|wrap_hash
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
name|link_info
operator|.
name|wrap_hash
argument_list|,
name|bfd_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
argument_list|)
argument_list|,
literal|61
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_table_init failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|link_info
operator|.
name|wrap_hash
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the -retain-symbols-file option.  */
end_comment

begin_function
name|void
name|add_keepsyms_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|link_info
operator|.
name|strip
operator|==
name|strip_some
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: error: duplicate retain-symbols-file\n"
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
literal|"%X%P: %s: %E\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|link_info
operator|.
name|keep_hash
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
name|link_info
operator|.
name|keep_hash
argument_list|,
name|bfd_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
argument_list|)
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_table_init failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
name|bufsize
operator|=
literal|100
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
while|while
condition|(
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|size_t
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|ISSPACE
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
name|buf
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|bufsize
condition|)
block|{
name|bufsize
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|link_info
operator|.
name|keep_hash
argument_list|,
name|buf
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_lookup for insertion failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|link_info
operator|.
name|strip
operator|!=
name|strip_none
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: `-retain-symbols-file' overrides `-s' and `-S'\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|link_info
operator|.
name|strip
operator|=
name|strip_some
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Callbacks from the BFD linker routines.  */
end_comment

begin_comment
comment|/* This is called when BFD has decided to include an archive member in    a link.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|add_archive_element
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|lang_input_statement_type
modifier|*
name|input
decl_stmt|;
name|input
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_input_statement_type
argument_list|)
argument_list|)
expr_stmt|;
name|input
operator|->
name|filename
operator|=
name|abfd
operator|->
name|filename
expr_stmt|;
name|input
operator|->
name|local_sym_name
operator|=
name|abfd
operator|->
name|filename
expr_stmt|;
name|input
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|input
operator|->
name|asymbols
operator|=
name|NULL
expr_stmt|;
name|input
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|input
operator|->
name|just_syms_flag
operator|=
name|FALSE
expr_stmt|;
name|input
operator|->
name|loaded
operator|=
name|FALSE
expr_stmt|;
name|input
operator|->
name|search_dirs_flag
operator|=
name|FALSE
expr_stmt|;
comment|/* FIXME: The following fields are not set: header.next,      header.type, closed, passive_position, symbol_count,      next_real_file, is_archive, target, real.  This bit of code is      from the old decode_library_subfile function.  I don't know      whether any of those fields matters.  */
name|ldlang_add_file
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|map_file
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|bfd_boolean
name|header_printed
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd
modifier|*
name|from
decl_stmt|;
name|int
name|len
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|from
operator|=
name|NULL
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|h
operator|->
name|type
condition|)
block|{
default|default:
name|from
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|from
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
name|from
operator|=
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|from
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|header_printed
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"Archive member included because of file (symbol)\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|header_printed
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|bfd_my_archive
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|minfo
argument_list|(
literal|"%s(%s)"
argument_list|,
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|+
literal|2
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|29
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
literal|30
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%B "
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"(%T)\n"
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"(%s)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace_files
operator|||
name|trace_file_tries
condition|)
name|info_msg
argument_list|(
literal|"%I\n"
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is called when BFD has discovered a symbol which is defined    multiple times.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|multiple_definition
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|,
name|bfd_vma
name|oval
parameter_list|,
name|bfd
modifier|*
name|nbfd
parameter_list|,
name|asection
modifier|*
name|nsec
parameter_list|,
name|bfd_vma
name|nval
parameter_list|)
block|{
comment|/* If either section has the output_section field set to      bfd_abs_section_ptr, it means that the section is being      discarded, and this is not really a multiple definition at all.      FIXME: It would be cleaner to somehow ignore symbols defined in      sections which are being discarded.  */
if|if
condition|(
operator|(
name|osec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|osec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|osec
operator|->
name|output_section
argument_list|)
operator|)
operator|||
operator|(
name|nsec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|nsec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|nsec
operator|->
name|output_section
argument_list|)
operator|)
condition|)
return|return
name|TRUE
return|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%C: multiple definition of `%T'\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|nsec
argument_list|,
name|nval
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%D: first defined here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|,
name|osec
argument_list|,
name|oval
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|relax
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: Disabling relaxation: it will not work with multiple definitions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|relax
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is called when there is a definition of a common symbol, or    when a common symbol is found for a symbol that is already defined,    or when two common symbols are found.  We only do something if    -warn-common was used.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|multiple_common
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|,
name|enum
name|bfd_link_hash_type
name|otype
parameter_list|,
name|bfd_vma
name|osize
parameter_list|,
name|bfd
modifier|*
name|nbfd
parameter_list|,
name|enum
name|bfd_link_hash_type
name|ntype
parameter_list|,
name|bfd_vma
name|nsize
parameter_list|)
block|{
if|if
condition|(
operator|!
name|config
operator|.
name|warn_common
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ntype
operator|==
name|bfd_link_hash_defined
operator|||
name|ntype
operator|==
name|bfd_link_hash_defweak
operator|||
name|ntype
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
name|ASSERT
argument_list|(
name|otype
operator|==
name|bfd_link_hash_common
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: definition of `%T' overriding common\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: common is here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|otype
operator|==
name|bfd_link_hash_defined
operator|||
name|otype
operator|==
name|bfd_link_hash_defweak
operator|||
name|otype
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
name|ASSERT
argument_list|(
name|ntype
operator|==
name|bfd_link_hash_common
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: common of `%T' overridden by definition\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: defined here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|otype
operator|==
name|bfd_link_hash_common
operator|&&
name|ntype
operator|==
name|bfd_link_hash_common
argument_list|)
expr_stmt|;
if|if
condition|(
name|osize
operator|>
name|nsize
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: common of `%T' overridden by larger common\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: larger common is here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nsize
operator|>
name|osize
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: common of `%T' overriding smaller common\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: smaller common is here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: multiple common of `%T'\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: previous common is here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is called when BFD has discovered a set element.  H is the    entry in the linker hash table for the set.  SECTION and VALUE    represent a value which should be added to the set.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|add_to_set
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_reloc_code_real_type
name|reloc
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
if|if
condition|(
name|config
operator|.
name|warn_constructors
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: global constructor %s used\n"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|.
name|build_constructors
condition|)
return|return
name|TRUE
return|;
name|ldctor_add_set_entry
argument_list|(
name|h
argument_list|,
name|reloc
argument_list|,
name|NULL
argument_list|,
name|section
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
comment|/* We don't call bfd_link_add_undef to add this to the list of 	 undefined symbols because we are going to define it 	 ourselves.  */
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is called when BFD has discovered a constructor.  This is only    called for some object file formats--those which do not handle    constructors in some more clever fashion.  This is similar to    adding an element to a set, but less general.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|constructor_callback
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|constructor
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|char
name|set_name
index|[
literal|1
operator|+
sizeof|sizeof
expr|"__CTOR_LIST__"]
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|warn_constructors
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: global constructor %s used\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|.
name|build_constructors
condition|)
return|return
name|TRUE
return|;
comment|/* Ensure that BFD_RELOC_CTOR exists now, so that we can give a      useful error message.  */
if|if
condition|(
name|bfd_reloc_type_lookup
argument_list|(
name|output_bfd
argument_list|,
name|BFD_RELOC_CTOR
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
name|info
operator|->
name|relocatable
operator|||
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_CTOR
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: BFD backend error: BFD_RELOC_CTOR unsupported\n"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|set_name
expr_stmt|;
if|if
condition|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor
condition|)
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"__CTOR_LIST__"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"__DTOR_LIST__"
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|set_name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
comment|/* We don't call bfd_link_add_undef to add this to the list of 	 undefined symbols because we are going to define it 	 ourselves.  */
block|}
name|ldctor_add_set_entry
argument_list|(
name|h
argument_list|,
name|BFD_RELOC_CTOR
argument_list|,
name|name
argument_list|,
name|section
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A structure used by warning_callback to pass information through    bfd_map_over_sections.  */
end_comment

begin_struct
struct|struct
name|warning_callback_info
block|{
name|bfd_boolean
name|found
decl_stmt|;
specifier|const
name|char
modifier|*
name|warning
decl_stmt|;
specifier|const
name|char
modifier|*
name|symbol
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|asymbols
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is called when there is a reference to a warning symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|warning_callback
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|warning
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
comment|/* This is a hack to support warn_multiple_gp.  FIXME: This should      have a cleaner interface, but what?  */
if|if
condition|(
operator|!
name|config
operator|.
name|warn_multiple_gp
operator|&&
name|strcmp
argument_list|(
name|warning
argument_list|,
literal|"using multiple gp values"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%C: %s%s\n"
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|_
argument_list|(
literal|"warning: "
argument_list|)
argument_list|,
name|warning
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%P: %s%s\n"
argument_list|,
name|_
argument_list|(
literal|"warning: "
argument_list|)
argument_list|,
name|warning
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|symbol
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%B: %s%s\n"
argument_list|,
name|abfd
argument_list|,
name|_
argument_list|(
literal|"warning: "
argument_list|)
argument_list|,
name|warning
argument_list|)
expr_stmt|;
else|else
block|{
name|lang_input_statement_type
modifier|*
name|entry
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|asymbols
decl_stmt|;
name|struct
name|warning_callback_info
name|info
decl_stmt|;
comment|/* Look through the relocs to see if we can find a plausible 	 address.  */
name|entry
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|abfd
operator|->
name|usrdata
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|asymbols
operator|!=
name|NULL
condition|)
name|asymbols
operator|=
name|entry
operator|->
name|asymbols
expr_stmt|;
else|else
block|{
name|long
name|symsize
decl_stmt|;
name|long
name|symbol_count
decl_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read symbols: %E\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|asymbols
operator|=
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|symbol_count
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|asymbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_count
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read symbols: %E\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|entry
operator|->
name|asymbols
operator|=
name|asymbols
expr_stmt|;
name|entry
operator|->
name|symbol_count
operator|=
name|symbol_count
expr_stmt|;
block|}
block|}
name|info
operator|.
name|found
operator|=
name|FALSE
expr_stmt|;
name|info
operator|.
name|warning
operator|=
name|warning
expr_stmt|;
name|info
operator|.
name|symbol
operator|=
name|symbol
expr_stmt|;
name|info
operator|.
name|asymbols
operator|=
name|asymbols
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|warning_find_reloc
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|.
name|found
condition|)
name|einfo
argument_list|(
literal|"%B: %s%s\n"
argument_list|,
name|abfd
argument_list|,
name|_
argument_list|(
literal|"warning: "
argument_list|)
argument_list|,
name|warning
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|asymbols
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is called by warning_callback for each section.  It checks the    relocs of the section to see if it can find a reference to the    symbol which triggered the warning.  If it can, it uses the reloc    to give an error message with a file and line number.  */
end_comment

begin_function
specifier|static
name|void
name|warning_find_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|iarg
parameter_list|)
block|{
name|struct
name|warning_callback_info
modifier|*
name|info
init|=
name|iarg
decl_stmt|;
name|long
name|relsize
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|found
condition|)
return|return;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read relocs: %E\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
return|return;
name|relpp
operator|=
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|relpp
argument_list|,
name|info
operator|->
name|asymbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read relocs: %E\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|p
operator|=
name|relpp
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|relcount
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|pend
operator|&&
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|arelent
modifier|*
name|q
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
operator|!=
name|NULL
operator|&&
operator|*
name|q
operator|->
name|sym_ptr_ptr
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|info
operator|->
name|symbol
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We found a reloc for the symbol we are looking for.  */
name|einfo
argument_list|(
literal|"%C: %s%s\n"
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|q
operator|->
name|address
argument_list|,
name|_
argument_list|(
literal|"warning: "
argument_list|)
argument_list|,
name|info
operator|->
name|warning
argument_list|)
expr_stmt|;
name|info
operator|->
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called when an undefined symbol is found.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|undefined_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|address
parameter_list|,
name|bfd_boolean
name|error
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|error_name
decl_stmt|;
specifier|static
name|unsigned
name|int
name|error_count
decl_stmt|;
define|#
directive|define
name|MAX_ERRORS_IN_A_ROW
value|5
if|if
condition|(
name|config
operator|.
name|warn_once
condition|)
block|{
specifier|static
name|struct
name|bfd_hash_table
modifier|*
name|hash
decl_stmt|;
comment|/* Only warn once about a particular undefined symbol.  */
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
block|{
name|hash
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
name|hash
argument_list|,
name|bfd_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_entry
argument_list|)
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: bfd_hash_table_init failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|hash
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: bfd_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We never print more than a reasonable number of errors in a row      for a single symbol.  */
if|if
condition|(
name|error_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|error_name
argument_list|)
operator|==
literal|0
condition|)
operator|++
name|error_count
expr_stmt|;
else|else
block|{
name|error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|error_name
argument_list|)
expr_stmt|;
name|error_name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|error_count
operator|<
name|MAX_ERRORS_IN_A_ROW
condition|)
block|{
if|if
condition|(
name|error
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%C: undefined reference to `%T'\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%C: warning: undefined reference to `%T'\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error_count
operator|==
name|MAX_ERRORS_IN_A_ROW
condition|)
block|{
if|if
condition|(
name|error
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%D: more undefined references to `%T' follow\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%D: warning: more undefined references to `%T' follow\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
name|einfo
argument_list|(
literal|"%X"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error_count
operator|<
name|MAX_ERRORS_IN_A_ROW
condition|)
block|{
if|if
condition|(
name|error
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%B: undefined reference to `%T'\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: undefined reference to `%T'\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error_count
operator|==
name|MAX_ERRORS_IN_A_ROW
condition|)
block|{
if|if
condition|(
name|error
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%B: more undefined references to `%T' follow\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: more undefined references to `%T' follow\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
name|einfo
argument_list|(
literal|"%X"
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Counter to limit the number of relocation overflow error messages    to print.  Errors are printed as it is decremented.  When it's    called and the counter is zero, a final message is printed    indicating more relocations were omitted.  When it gets to -1, no    such errors are printed.  If it's initially set to a value less    than -1, all such errors will be printed (--verbose does this).  */
end_comment

begin_decl_stmt
name|int
name|overflow_cutoff_limit
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is called when a reloc overflows.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|reloc_overflow
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_hash_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|reloc_name
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
if|if
condition|(
name|overflow_cutoff_limit
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
name|einfo
argument_list|(
literal|"%X%C:"
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflow_cutoff_limit
operator|>=
literal|0
operator|&&
name|overflow_cutoff_limit
operator|--
operator|==
literal|0
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|" additional relocation overflows omitted from the output\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|entry
condition|)
block|{
while|while
condition|(
name|entry
operator|->
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|entry
operator|->
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|entry
operator|=
name|entry
operator|->
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|type
condition|)
block|{
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
name|einfo
argument_list|(
name|_
argument_list|(
literal|" relocation truncated to fit: %s against undefined symbol `%T'"
argument_list|)
argument_list|,
name|reloc_name
argument_list|,
name|entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|einfo
argument_list|(
name|_
argument_list|(
literal|" relocation truncated to fit: %s against symbol `%T' defined in %A section in %B"
argument_list|)
argument_list|,
name|reloc_name
argument_list|,
name|entry
operator|->
name|root
operator|.
name|string
argument_list|,
name|entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
name|entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|bfd_abs_section_ptr
condition|?
name|output_bfd
else|:
name|entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|" relocation truncated to fit: %s against `%T'"
argument_list|)
argument_list|,
name|reloc_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|addend
operator|!=
literal|0
condition|)
name|einfo
argument_list|(
literal|"+%v"
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is called when a dangerous relocation is made.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|reloc_dangerous
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%C: dangerous relocation: %s\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|message
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is called when a reloc is being generated attached to a symbol    that is not being output.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|unattached_reloc
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%C: reloc refers to symbol `%T' which is not being output\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is called if link_info.notice_all is set, or when a symbol in    link_info.notice_hash is found.  Symbols are put in notice_hash    using the -y option.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|notice
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|cref
operator|||
name|nocrossref_list
operator|!=
name|NULL
condition|)
return|return
name|handle_asneeded_cref
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|notice_all
operator|||
operator|(
name|info
operator|->
name|notice_hash
operator|!=
name|NULL
operator|&&
name|bfd_hash_lookup
argument_list|(
name|info
operator|->
name|notice_hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%B: reference to %s\n"
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
literal|"%B: definition of %s\n"
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|command_line
operator|.
name|cref
operator|||
name|nocrossref_list
operator|!=
name|NULL
condition|)
name|add_cref
argument_list|(
name|name
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

