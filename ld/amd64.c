begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012,2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ld_arch.h"
end_include

begin_include
include|#
directive|include
file|"ld_dynamic.h"
end_include

begin_include
include|#
directive|include
file|"ld_input.h"
end_include

begin_include
include|#
directive|include
file|"ld_layout.h"
end_include

begin_include
include|#
directive|include
file|"ld_output.h"
end_include

begin_include
include|#
directive|include
file|"ld_reloc.h"
end_include

begin_include
include|#
directive|include
file|"ld_symbols.h"
end_include

begin_include
include|#
directive|include
file|"ld_utils.h"
end_include

begin_include
include|#
directive|include
file|"amd64.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: amd64.c 3419 2016-02-19 20:07:15Z emaste $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|_create_plt_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_got_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|type
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_copy_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_dynamic_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|type
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int64_t
name|addend
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_scan_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_got_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_gotplt_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_plt_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_finalize_got_and_plt
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_get_max_page_size
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_get_common_page_size
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_adjust_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_process_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_reserve_got_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_reserve_gotplt_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_reserve_plt_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_is_absolute_reloc
parameter_list|(
name|uint64_t
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_warn_pic
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_tls_gd_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_tls_ld_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_tls_ie_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|ld_tls_relax
name|_tls_check_relax
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_got_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_tls_verify_gd
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_tls_verify_ld
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_tls_relax_gd_to_ie
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_state
modifier|*
name|ls
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|uint64_t
name|p
parameter_list|,
name|uint64_t
name|g
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_tls_relax_gd_to_le
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_state
modifier|*
name|ls
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_tls_relax_ld_to_le
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_state
modifier|*
name|ls
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_tls_relax_ie_to_le
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|_tls_dtpoff
parameter_list|(
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|_tls_tpoff
parameter_list|(
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|uint64_t
name|_get_max_page_size
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ld
expr_stmt|;
return|return
operator|(
literal|0x200000
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_get_common_page_size
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ld
expr_stmt|;
return|return
operator|(
literal|0x1000
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_is_absolute_reloc
parameter_list|(
name|uint64_t
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|==
name|R_X86_64_64
operator|||
name|r
operator|==
name|R_X86_64_32
operator|||
name|r
operator|==
name|R_X86_64_32S
operator|||
name|r
operator|==
name|R_X86_64_16
operator|||
name|r
operator|==
name|R_X86_64_8
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_is_relative_reloc
parameter_list|(
name|uint64_t
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|==
name|R_X86_64_RELATIVE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_warn_pic
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
name|lsb
operator|=
name|lre
operator|->
name|lre_sym
expr_stmt|;
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|!=
name|STB_LOCAL
condition|)
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"relocation %s against `%s' can not be used"
literal|" by runtime linker; recompile with -fPIC"
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|EM_X86_64
argument_list|,
name|lre
operator|->
name|lre_type
argument_list|)
argument_list|,
name|lsb
operator|->
name|lsb_name
argument_list|)
expr_stmt|;
else|else
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"relocation %s can not be used by runtime linker;"
literal|" recompile with -fPIC"
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|EM_X86_64
argument_list|,
name|lre
operator|->
name|lre_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_got_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
comment|/* Check if the GOT section is already created. */
name|is
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
return|return
operator|(
name|is
operator|)
return|;
if|if
condition|(
name|create
condition|)
block|{
name|is
operator|=
name|ld_input_add_internal_section
argument_list|(
name|ld
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_entsize
operator|=
literal|8
expr_stmt|;
name|is
operator|->
name|is_align
operator|=
literal|8
expr_stmt|;
name|is
operator|->
name|is_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|is
operator|->
name|is_flags
operator|=
name|SHF_ALLOC
operator||
name|SHF_WRITE
expr_stmt|;
block|}
return|return
operator|(
name|is
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_gotplt_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
comment|/* Check if the GOT (for PLT) section is already created. */
name|is
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
return|return
operator|(
name|is
operator|)
return|;
if|if
condition|(
name|create
condition|)
block|{
name|is
operator|=
name|ld_input_add_internal_section
argument_list|(
name|ld
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_entsize
operator|=
literal|8
expr_stmt|;
name|is
operator|->
name|is_align
operator|=
literal|8
expr_stmt|;
name|is
operator|->
name|is_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|is
operator|->
name|is_flags
operator|=
name|SHF_ALLOC
operator||
name|SHF_WRITE
expr_stmt|;
comment|/* Reserve space for the initial entries. */
operator|(
name|void
operator|)
name|ld_input_reserve_ibuf
argument_list|(
name|is
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Create _GLOBAL_OFFSET_TABLE_ symbol. */
name|ld_symbols_add_internal
argument_list|(
name|ld
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|is
operator|->
name|is_index
argument_list|,
name|STB_LOCAL
argument_list|,
name|STT_OBJECT
argument_list|,
name|STV_HIDDEN
argument_list|,
name|is
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|is
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_plt_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
comment|/* Check if the PLT section is already created. */
name|is
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
return|return
operator|(
name|is
operator|)
return|;
if|if
condition|(
name|create
condition|)
block|{
name|is
operator|=
name|ld_input_add_internal_section
argument_list|(
name|ld
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_entsize
operator|=
literal|16
expr_stmt|;
name|is
operator|->
name|is_align
operator|=
literal|4
expr_stmt|;
name|is
operator|->
name|is_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|is
operator|->
name|is_flags
operator|=
name|SHF_ALLOC
operator||
name|SHF_EXECINSTR
expr_stmt|;
comment|/* Reserve space for the initial entry. */
operator|(
name|void
operator|)
name|ld_input_reserve_ibuf
argument_list|(
name|is
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|is
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_reserve_got_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|_find_and_create_got_section
argument_list|(
name|ld
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check if the entry already has a GOT entry. */
if|if
condition|(
name|lsb
operator|->
name|lsb_got
condition|)
return|return;
comment|/* Reserve GOT entries. */
name|lsb
operator|->
name|lsb_got_off
operator|=
name|ld_input_reserve_ibuf
argument_list|(
name|is
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_got
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_reserve_gotplt_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|_find_and_create_gotplt_section
argument_list|(
name|ld
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Reserve a GOT entry for PLT. */
operator|(
name|void
operator|)
name|ld_input_reserve_ibuf
argument_list|(
name|is
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Record a R_X86_64_JUMP_SLOT entry for this symbol. Note that 	 * we don't need to record the offset (relative to the GOT section) 	 * here, since the PLT relocations will be sorted later and we 	 * will generate GOT section according to the new order. 	 */
name|_create_plt_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_reserve_plt_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|_find_and_create_plt_section
argument_list|(
name|ld
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ld_input_reserve_ibuf
argument_list|(
name|is
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_plt
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_plt_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rela.plt"
argument_list|,
name|NULL
argument_list|,
name|R_X86_64_JUMP_SLOT
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_dynrel
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_got_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|type
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|tis
decl_stmt|;
name|tis
operator|=
name|_find_and_create_got_section
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tis
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rela.got"
argument_list|,
name|tis
argument_list|,
name|type
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|R_X86_64_RELATIVE
condition|)
name|lsb
operator|->
name|lsb_dynrel
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_copy_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|tis
decl_stmt|;
name|ld_dynamic_reserve_dynbss_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|tis
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tis
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rela.bss"
argument_list|,
name|tis
argument_list|,
name|R_X86_64_COPY
argument_list|,
name|lsb
argument_list|,
name|lsb
operator|->
name|lsb_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_dynrel
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_dynamic_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|type
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int64_t
name|addend
parameter_list|)
block|{
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|==
name|STB_LOCAL
condition|)
block|{
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
name|SHF_WRITE
condition|)
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rela.data.rel.local"
argument_list|,
name|is
argument_list|,
name|type
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
name|addend
argument_list|)
expr_stmt|;
else|else
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rela.data.rel.ro.local"
argument_list|,
name|is
argument_list|,
name|type
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
name|SHF_WRITE
condition|)
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rela.data.rel"
argument_list|,
name|is
argument_list|,
name|type
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
name|addend
argument_list|)
expr_stmt|;
else|else
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rela.data.rel.ro"
argument_list|,
name|is
argument_list|,
name|type
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|R_X86_64_RELATIVE
condition|)
name|lsb
operator|->
name|lsb_dynrel
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_finalize_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|tis
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
operator|(
name|void
operator|)
name|ld
expr_stmt|;
operator|(
name|void
operator|)
name|tis
expr_stmt|;
name|lsb
operator|=
name|ld_symbols_ref
argument_list|(
name|lre
operator|->
name|lre_sym
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lre
operator|->
name|lre_type
condition|)
block|{
case|case
name|R_X86_64_RELATIVE
case|:
comment|/* 		 * Update the addend stored in the original relocation to 		 * point to the new location, by adding the updated symbol 		 * value. 		 */
name|lre
operator|->
name|lre_addend
operator|+=
name|lsb
operator|->
name|lsb_value
expr_stmt|;
comment|/* R_X86_64_RELATIVE should not associate with a symbol. */
name|lre
operator|->
name|lre_sym
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|R_X86_64_DTPMOD64
case|:
comment|/* 		 * Relocation R_X86_64_DTPMOD64 generated for local dynamic 		 * TLS model should not assoicate with a symbol. 		 */
if|if
condition|(
name|lre
operator|->
name|lre_type
operator|==
name|R_X86_64_DTPMOD64
operator|&&
name|lsb
operator|->
name|lsb_tls_ld
condition|)
name|lre
operator|->
name|lre_sym
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_finalize_got_and_plt
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_input_section
modifier|*
name|got_is
decl_stmt|,
modifier|*
name|rela_got_is
decl_stmt|,
modifier|*
name|plt_is
decl_stmt|,
modifier|*
name|rela_plt_is
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|got_os
decl_stmt|,
modifier|*
name|plt_os
decl_stmt|,
modifier|*
name|rela_plt_os
decl_stmt|;
name|struct
name|ld_reloc_entry
modifier|*
name|lre
decl_stmt|;
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
name|char
name|dynamic_symbol
index|[]
init|=
literal|"_DYNAMIC"
decl_stmt|;
name|uint8_t
modifier|*
name|got
decl_stmt|,
modifier|*
name|plt
decl_stmt|;
name|uint64_t
name|u64
decl_stmt|;
name|int32_t
name|s32
decl_stmt|,
name|pltgot
decl_stmt|,
name|gotpcrel
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Intiailze all .got section entries to zero. 	 */
name|got_is
operator|=
name|_find_and_create_got_section
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_is
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|got_is
operator|->
name|is_ibuf
argument_list|,
literal|0
argument_list|,
name|got_is
operator|->
name|is_size
argument_list|)
expr_stmt|;
comment|/* 	 * Search for GOT relocations that requires filling in symbol 	 * value. 	 */
name|rela_got_is
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rela_got_is
operator|!=
name|NULL
operator|&&
name|rela_got_is
operator|->
name|is_reloc
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|lre
argument_list|,
argument|rela_got_is->is_reloc
argument_list|,
argument|lre_next
argument_list|)
block|{
if|if
condition|(
name|lre
operator|->
name|lre_type
operator|==
name|R_X86_64_RELATIVE
condition|)
block|{
name|lsb
operator|=
name|lre
operator|->
name|lre_sym
expr_stmt|;
name|got
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|got_is
operator|->
name|is_ibuf
operator|+
name|lsb
operator|->
name|lsb_got_off
expr_stmt|;
name|WRITE_64
argument_list|(
name|got
argument_list|,
name|lsb
operator|->
name|lsb_value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Find the .plt section. The buffers should have been allocated 	 * at this point. 	 */
name|plt_is
operator|=
name|_find_and_create_plt_section
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|plt_is
operator|==
name|NULL
condition|)
return|return;
name|plt_os
operator|=
name|plt_is
operator|->
name|is_output
expr_stmt|;
name|plt
operator|=
name|plt_is
operator|->
name|is_ibuf
expr_stmt|;
name|assert
argument_list|(
name|plt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Find the .got.plt and .rela.plt section. If the .plt section 	 * exists, the .got.plt and .rela.plt section should exist too. 	 */
name|got_is
operator|=
name|_find_and_create_gotplt_section
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|got_is
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|got_os
operator|=
name|got_is
operator|->
name|is_output
expr_stmt|;
name|lo
operator|->
name|lo_gotplt
operator|=
name|got_os
expr_stmt|;
name|got
operator|=
name|got_is
operator|->
name|is_ibuf
expr_stmt|;
name|assert
argument_list|(
name|got
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela_plt_is
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rela_plt_is
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela_plt_os
operator|=
name|rela_plt_is
operator|->
name|is_output
expr_stmt|;
name|lo
operator|->
name|lo_rel_plt
operator|=
name|rela_plt_os
expr_stmt|;
comment|/* Point sh_info field of the .rela.plt to .plt section. */
name|rela_plt_os
operator|->
name|os_info
operator|=
name|plt_os
expr_stmt|;
comment|/* Fill in the value of symbol _DYNAMIC in the first GOT entry. */
name|ld_symbols_get_value
argument_list|(
name|ld
argument_list|,
name|dynamic_symbol
argument_list|,
operator|&
name|u64
argument_list|)
expr_stmt|;
name|WRITE_64
argument_list|(
name|got
argument_list|,
name|u64
argument_list|)
expr_stmt|;
name|got
operator|+=
literal|8
expr_stmt|;
comment|/* Reserve the second and the third entry for the dynamic linker. */
name|memset
argument_list|(
name|got
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|got
operator|+=
literal|16
expr_stmt|;
comment|/* 	 * Write the initial PLT entry. 	 */
comment|/* Calculate the relative offset from PLT to GOT. */
name|pltgot
operator|=
name|got_os
operator|->
name|os_addr
operator|-
name|plt_os
operator|->
name|os_addr
expr_stmt|;
comment|/* 	 * Push the second GOT entry to the stack for the dynamic 	 * linker. (PUSH reg/memXX [RIP+disp32]) (6 bytes for push) 	 */
name|WRITE_8
argument_list|(
name|plt
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|WRITE_8
argument_list|(
name|plt
operator|+
literal|1
argument_list|,
literal|0x35
argument_list|)
expr_stmt|;
name|s32
operator|=
name|pltgot
operator|-
literal|6
operator|+
literal|8
expr_stmt|;
name|WRITE_32
argument_list|(
name|plt
operator|+
literal|2
argument_list|,
name|s32
argument_list|)
expr_stmt|;
name|plt
operator|+=
literal|6
expr_stmt|;
comment|/* 	 * Jump to the address in the third GOT entry (call into 	 * the dynamic linker). (JMP reg/memXX [RIP+disp32]) 	 * (6 bytes for jmp) 	 */
name|WRITE_8
argument_list|(
name|plt
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|WRITE_8
argument_list|(
name|plt
operator|+
literal|1
argument_list|,
literal|0x25
argument_list|)
expr_stmt|;
name|s32
operator|=
name|pltgot
operator|-
literal|12
operator|+
literal|16
expr_stmt|;
name|WRITE_32
argument_list|(
name|plt
operator|+
literal|2
argument_list|,
name|s32
argument_list|)
expr_stmt|;
name|plt
operator|+=
literal|6
expr_stmt|;
comment|/* Padding: 4-byte nop. (NOP [rAx+disp8]) */
name|WRITE_8
argument_list|(
name|plt
argument_list|,
literal|0x0f
argument_list|)
expr_stmt|;
name|WRITE_8
argument_list|(
name|plt
operator|+
literal|1
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|WRITE_8
argument_list|(
name|plt
operator|+
literal|2
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|WRITE_8
argument_list|(
name|plt
operator|+
literal|3
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|plt
operator|+=
literal|4
expr_stmt|;
comment|/* 	 * Walk through the sorted PLT relocations in the output section 	 * and fill in each GOT and PLT entries. 	 */
name|i
operator|=
literal|3
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lre
argument_list|,
argument|rela_plt_is->is_reloc
argument_list|,
argument|lre_next
argument_list|)
block|{
name|lsb
operator|=
name|ld_symbols_ref
argument_list|(
name|lre
operator|->
name|lre_sym
argument_list|)
expr_stmt|;
comment|/* 		 * Set symbol's PLT offset to the address of this PLT entry. 		 * The PLT offset is used in relocation processing later. 		 */
name|lsb
operator|->
name|lsb_plt_off
operator|=
name|plt_os
operator|->
name|os_addr
operator|+
operator|(
name|i
operator|-
literal|2
operator|)
operator|*
literal|16
expr_stmt|;
comment|/* 		 * Update the offset for the R_X86_64_JUMP_SLOT relocation 		 * entry, pointing to the corresponding GOT entry. 		 */
name|lre
operator|->
name|lre_offset
operator|=
name|got_os
operator|->
name|os_addr
operator|+
name|i
operator|*
literal|8
expr_stmt|;
comment|/* 		 * Calculate the IP-relative offset to the GOT entry for 		 * this function. (6 bytes for jmp) 		 */
name|gotpcrel
operator|=
name|pltgot
operator|+
name|i
operator|*
literal|8
operator|-
operator|(
name|i
operator|-
literal|2
operator|)
operator|*
literal|16
operator|-
literal|6
expr_stmt|;
comment|/* 		 * PLT: Jump to the address in the GOT entry for this 		 * function. (JMP reg/memXX [RIP+disp32]) 		 */
name|WRITE_8
argument_list|(
name|plt
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|WRITE_8
argument_list|(
name|plt
operator|+
literal|1
argument_list|,
literal|0x25
argument_list|)
expr_stmt|;
name|WRITE_32
argument_list|(
name|plt
operator|+
literal|2
argument_list|,
name|gotpcrel
argument_list|)
expr_stmt|;
name|plt
operator|+=
literal|6
expr_stmt|;
comment|/* 		 * PLT: Symbol is not resolved, push the relocation index to 		 * the stack. (PUSH imm32) 		 */
name|WRITE_8
argument_list|(
name|plt
argument_list|,
literal|0x68
argument_list|)
expr_stmt|;
name|WRITE_32
argument_list|(
name|plt
operator|+
literal|1
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|plt
operator|+=
literal|5
expr_stmt|;
comment|/* 		 * PLT: Jump to the first PLT entry, eventually call the 		 * dynamic linker. (JMP rel32off) 		 */
name|WRITE_8
argument_list|(
name|plt
argument_list|,
literal|0xe9
argument_list|)
expr_stmt|;
name|s32
operator|=
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|16
expr_stmt|;
name|WRITE_32
argument_list|(
name|plt
operator|+
literal|1
argument_list|,
name|s32
argument_list|)
expr_stmt|;
name|plt
operator|+=
literal|5
expr_stmt|;
comment|/* 		 * GOT: Write the GOT entry for this function, pointing to 		 * the push op. 		 */
name|u64
operator|=
name|plt_os
operator|->
name|os_addr
operator|+
operator|(
name|i
operator|-
literal|2
operator|)
operator|*
literal|16
operator|+
literal|6
expr_stmt|;
name|WRITE_64
argument_list|(
name|got
argument_list|,
name|u64
argument_list|)
expr_stmt|;
comment|/* Increase relocation entry index. */
name|j
operator|++
expr_stmt|;
comment|/* Move to next GOT entry. */
name|got
operator|+=
literal|8
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
name|got
operator|==
operator|(
name|uint8_t
operator|*
operator|)
name|got_is
operator|->
name|is_ibuf
operator|+
name|got_is
operator|->
name|is_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|plt
operator|==
operator|(
name|uint8_t
operator|*
operator|)
name|plt_is
operator|->
name|is_ibuf
operator|+
name|plt_is
operator|->
name|is_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_scan_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
name|enum
name|ld_tls_relax
name|tr
decl_stmt|;
name|lsb
operator|=
name|ld_symbols_ref
argument_list|(
name|lre
operator|->
name|lre_sym
argument_list|)
expr_stmt|;
comment|/* 	 * TODO: We do not yet support "Large Models" and relevant 	 * relocation types R_X86_64_GOT64, R_X86_64_GOTPCREL64, 	 * R_X86_64_GOTPC64, R_X86_64_GOTPLT64 and R_X86_64_PLTOFF64. 	 * Refer to AMD64 ELF ABI for details. 	 */
switch|switch
condition|(
name|lre
operator|->
name|lre_type
condition|)
block|{
case|case
name|R_X86_64_NONE
case|:
break|break;
case|case
name|R_X86_64_64
case|:
case|case
name|R_X86_64_32
case|:
case|case
name|R_X86_64_32S
case|:
case|case
name|R_X86_64_16
case|:
case|case
name|R_X86_64_8
case|:
comment|/* 		 * For a local symbol, if the linker output a PIE or DSO, 		 * we should generate a R_X86_64_RELATIVE reloc for 		 * R_X86_64_64. We don't know how to generate dynamic reloc 		 * for other reloc types since R_X86_64_RELATIVE is 64 bits. 		 * We can not use them directly either because FreeBSD rtld(1) 		 * (and probably glibc) doesn't accept absolute address 		 * reloction other than R_X86_64_64. 		 */
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|==
name|STB_LOCAL
condition|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_pie
operator|||
name|ld
operator|->
name|ld_dso
condition|)
block|{
if|if
condition|(
name|lre
operator|->
name|lre_type
operator|==
name|R_X86_64_64
condition|)
name|_create_dynamic_reloc
argument_list|(
name|ld
argument_list|,
name|is
argument_list|,
name|lsb
argument_list|,
name|R_X86_64_RELATIVE
argument_list|,
name|lre
operator|->
name|lre_offset
argument_list|,
name|lre
operator|->
name|lre_addend
argument_list|)
expr_stmt|;
else|else
name|_warn_pic
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * For a global symbol, we probably need to generate PLT entry 		 * and/or a dynamic relocation. 		 * 		 * Note here, normally the compiler will generate a PC-relative 		 * relocation for function calls. However, if the code retrieve 		 * the address of a function and call it indirectly, assembler 		 * will generate absolute relocation instead. That's why we 		 * should check if we need to create a PLT entry here. Also, if 		 * we're going to create the PLT entry, we should also set the 		 * symbol value to the address of PLT entry just in case the 		 * function address is used to compare with other function 		 * addresses. (If PLT address is used, function will have 		 * unified address in the main executable and DSOs) 		 */
if|if
condition|(
name|ld_reloc_require_plt
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|lsb
operator|->
name|lsb_plt
condition|)
block|{
name|_reserve_gotplt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|_reserve_plt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Note here even if we have generated PLT for this 			 * function before, we still need to set this flag. 			 * It's possible that we first see the relative 			 * relocation then this absolute relocation, in 			 * other words, the same function can be called in 			 * different ways. 			 */
name|lsb
operator|->
name|lsb_func_addr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ld_reloc_require_copy_reloc
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
operator|&&
operator|!
name|lsb
operator|->
name|lsb_copy_reloc
condition|)
name|_create_copy_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ld_reloc_require_dynamic_reloc
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
block|{
comment|/* We only support R_X86_64_64. (See above) */
if|if
condition|(
name|lre
operator|->
name|lre_type
operator|!=
name|R_X86_64_64
condition|)
block|{
name|_warn_pic
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Check if we can relax R_X86_64_64 to 			 * R_X86_64_RELATIVE instead. 			 */
if|if
condition|(
name|ld_reloc_relative_relax
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
name|_create_dynamic_reloc
argument_list|(
name|ld
argument_list|,
name|is
argument_list|,
name|lsb
argument_list|,
name|R_X86_64_RELATIVE
argument_list|,
name|lre
operator|->
name|lre_offset
argument_list|,
name|lre
operator|->
name|lre_addend
argument_list|)
expr_stmt|;
else|else
name|_create_dynamic_reloc
argument_list|(
name|ld
argument_list|,
name|is
argument_list|,
name|lsb
argument_list|,
name|R_X86_64_64
argument_list|,
name|lre
operator|->
name|lre_offset
argument_list|,
name|lre
operator|->
name|lre_addend
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_X86_64_PLT32
case|:
comment|/* 		 * In some cases we don't really need to generate a PLT 		 * entry, then a R_X86_64_PLT32 relocation can be relaxed 		 * to a R_X86_64_PC32 relocation. 		 */
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|==
name|STB_LOCAL
operator|||
operator|!
name|ld_reloc_require_plt
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
block|{
name|lre
operator|->
name|lre_type
operator|=
name|R_X86_64_PC32
expr_stmt|;
break|break;
block|}
comment|/* 		 * If linker outputs an normal executable and the symbol is 		 * defined but is not defined inside a DSO, we can generate 		 * a R_X86_64_PC32 relocation instead. 		 */
if|if
condition|(
name|ld
operator|->
name|ld_exec
operator|&&
name|lsb
operator|->
name|lsb_shndx
operator|!=
name|SHN_UNDEF
operator|&&
operator|(
name|lsb
operator|->
name|lsb_input
operator|==
name|NULL
operator|||
name|lsb
operator|->
name|lsb_input
operator|->
name|li_type
operator|!=
name|LIT_DSO
operator|)
condition|)
block|{
name|lre
operator|->
name|lre_type
operator|=
name|R_X86_64_PC32
expr_stmt|;
break|break;
block|}
comment|/* Create an PLT entry otherwise. */
if|if
condition|(
operator|!
name|lsb
operator|->
name|lsb_plt
condition|)
block|{
name|_reserve_gotplt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|_reserve_plt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_X86_64_PC64
case|:
case|case
name|R_X86_64_PC32
case|:
case|case
name|R_X86_64_PC16
case|:
case|case
name|R_X86_64_PC8
case|:
comment|/* 		 * When these relocations apply to a global symbol, we should 		 * check if we need to generate PLT entry and/or a dynamic 		 * relocation. 		 */
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|!=
name|STB_LOCAL
condition|)
block|{
if|if
condition|(
name|ld_reloc_require_plt
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
operator|&&
operator|!
name|lsb
operator|->
name|lsb_plt
condition|)
block|{
name|_reserve_gotplt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|_reserve_plt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ld_reloc_require_copy_reloc
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
operator|&&
operator|!
name|lsb
operator|->
name|lsb_copy_reloc
condition|)
name|_create_copy_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ld_reloc_require_dynamic_reloc
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
block|{
comment|/* 				 * We can not generate dynamic relocation for 				 * these PC-relative relocation since they 				 * are probably not supported by the runtime 				 * linkers. 				 * 				 * Note: FreeBSD rtld(1) does support 				 * R_X86_64_PC32. 				 */
name|_warn_pic
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_X86_64_GOTOFF64
case|:
case|case
name|R_X86_64_GOTPC32
case|:
comment|/* 		 * These relocation types use GOT address as a base address 		 * and instruct the linker to build a GOT. 		 */
operator|(
name|void
operator|)
name|_find_and_create_got_section
argument_list|(
name|ld
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_X86_64_GOT32
case|:
case|case
name|R_X86_64_GOTPCREL
case|:
comment|/* 		 * These relocation types instruct the linker to build a 		 * GOT and generate a GOT entry. 		 */
if|if
condition|(
operator|!
name|lsb
operator|->
name|lsb_got
condition|)
block|{
name|_reserve_got_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * TODO: For now we always create a R_X86_64_GLOB_DAT 			 * relocation for a GOT entry. There are cases that 			 * the symbol's address is known at link time and 			 * the GOT entry value can be filled in by the program 			 * linker instead. 			 */
if|if
condition|(
name|ld_reloc_require_glob_dat
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
name|_create_got_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
name|R_X86_64_GLOB_DAT
argument_list|,
name|lsb
operator|->
name|lsb_got_off
argument_list|)
expr_stmt|;
else|else
name|_create_got_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
name|R_X86_64_RELATIVE
argument_list|,
name|lsb
operator|->
name|lsb_got_off
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_X86_64_TLSGD
case|:
comment|/* Global Dynamic */
name|tr
operator|=
name|_tls_check_relax
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tr
condition|)
block|{
case|case
name|TLS_RELAX_NONE
case|:
name|_create_tls_gd_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_RELAX_INIT_EXEC
case|:
name|_create_tls_ie_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_RELAX_LOCAL_EXEC
case|:
break|break;
default|default:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"Internal: invalid TLS relaxation %d"
argument_list|,
name|tr
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|R_X86_64_TLSLD
case|:
comment|/* Local Dynamic */
name|tr
operator|=
name|_tls_check_relax
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|==
name|TLS_RELAX_NONE
condition|)
name|_create_tls_ld_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tr
operator|!=
name|TLS_RELAX_LOCAL_EXEC
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"Internal: invalid TLS relaxation %d"
argument_list|,
name|tr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_X86_64_DTPOFF32
case|:
comment|/* Handled by R_X86_64_TLSLD case. */
break|break;
case|case
name|R_X86_64_GOTTPOFF
case|:
comment|/* Initial Exec */
name|tr
operator|=
name|_tls_check_relax
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|==
name|TLS_RELAX_NONE
condition|)
name|_create_tls_ie_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tr
operator|!=
name|TLS_RELAX_LOCAL_EXEC
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"Internal: invalid TLS relaxation %d"
argument_list|,
name|tr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_X86_64_TPOFF32
case|:
comment|/* Local Exec */
comment|/* No further relaxation possible. */
break|break;
case|case
name|R_X86_64_GOTPC32_TLSDESC
case|:
case|case
name|R_X86_64_TLSDESC_CALL
case|:
comment|/* TODO. */
break|break;
default|default:
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"can not handle relocation %ju"
argument_list|,
name|lre
operator|->
name|lre_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_got_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|assert
argument_list|(
name|lsb
operator|->
name|lsb_got
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_got
operator|==
name|NULL
condition|)
block|{
name|ld
operator|->
name|ld_got
operator|=
name|_find_and_create_got_section
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ld
operator|->
name|ld_got
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|os
operator|=
name|ld
operator|->
name|ld_got
operator|->
name|is_output
expr_stmt|;
return|return
operator|(
name|os
operator|->
name|os_addr
operator|+
name|ld
operator|->
name|ld_got
operator|->
name|is_reloff
operator|+
name|lsb
operator|->
name|lsb_got_off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_process_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|uint64_t
name|u64
decl_stmt|,
name|s
decl_stmt|,
name|l
decl_stmt|,
name|p
decl_stmt|,
name|g
decl_stmt|;
name|int64_t
name|s64
decl_stmt|;
name|uint32_t
name|u32
decl_stmt|;
name|int32_t
name|s32
decl_stmt|;
name|enum
name|ld_tls_relax
name|tr
decl_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|l
operator|=
name|lsb
operator|->
name|lsb_plt_off
expr_stmt|;
name|p
operator|=
name|lre
operator|->
name|lre_offset
operator|+
name|is
operator|->
name|is_output
operator|->
name|os_addr
operator|+
name|is
operator|->
name|is_reloff
expr_stmt|;
name|s
operator|=
name|lsb
operator|->
name|lsb_value
expr_stmt|;
switch|switch
condition|(
name|lre
operator|->
name|lre_type
condition|)
block|{
case|case
name|R_X86_64_NONE
case|:
break|break;
case|case
name|R_X86_64_64
case|:
name|WRITE_64
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s
operator|+
name|lre
operator|->
name|lre_addend
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_X86_64_PC32
case|:
if|if
condition|(
name|lsb
operator|->
name|lsb_plt
condition|)
name|s32
operator|=
name|l
operator|+
name|lre
operator|->
name|lre_addend
operator|-
name|p
expr_stmt|;
else|else
name|s32
operator|=
name|s
operator|+
name|lre
operator|->
name|lre_addend
operator|-
name|p
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s32
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_X86_64_PLT32
case|:
if|if
condition|(
operator|!
name|ls
operator|->
name|ls_ignore_next_plt
condition|)
block|{
name|s32
operator|=
name|l
operator|+
name|lre
operator|->
name|lre_addend
operator|-
name|p
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s32
argument_list|)
expr_stmt|;
block|}
else|else
name|ls
operator|->
name|ls_ignore_next_plt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_X86_64_GOTPCREL
case|:
name|g
operator|=
name|_got_offset
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|s32
operator|=
name|g
operator|+
name|lre
operator|->
name|lre_addend
operator|-
name|p
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s32
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_X86_64_32
case|:
name|u64
operator|=
name|s
operator|+
name|lre
operator|->
name|lre_addend
expr_stmt|;
name|u32
operator|=
name|u64
operator|&
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|u64
operator|!=
name|u32
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"R_X86_64_32 relocation failed"
argument_list|)
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|u32
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_X86_64_32S
case|:
name|s64
operator|=
name|s
operator|+
name|lre
operator|->
name|lre_addend
expr_stmt|;
name|s32
operator|=
name|s64
operator|&
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|s64
operator|!=
name|s32
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"R_X86_64_32S relocation failed"
argument_list|)
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s32
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_X86_64_TLSGD
case|:
comment|/* Global Dynamic */
name|tr
operator|=
name|_tls_check_relax
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tr
condition|)
block|{
case|case
name|TLS_RELAX_NONE
case|:
name|g
operator|=
name|_got_offset
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|s32
operator|=
name|g
operator|+
name|lre
operator|->
name|lre_addend
operator|-
name|p
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_RELAX_INIT_EXEC
case|:
name|g
operator|=
name|_got_offset
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|_tls_relax_gd_to_ie
argument_list|(
name|ld
argument_list|,
name|ls
argument_list|,
name|lo
argument_list|,
name|lre
argument_list|,
name|p
argument_list|,
name|g
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_RELAX_LOCAL_EXEC
case|:
name|_tls_relax_gd_to_le
argument_list|(
name|ld
argument_list|,
name|ls
argument_list|,
name|lo
argument_list|,
name|lre
argument_list|,
name|lsb
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"Internal: invalid TLS relaxation %d"
argument_list|,
name|tr
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|R_X86_64_TLSLD
case|:
comment|/* Local Dynamic */
name|tr
operator|=
name|_tls_check_relax
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tr
condition|)
block|{
case|case
name|TLS_RELAX_NONE
case|:
name|g
operator|=
name|_got_offset
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|s32
operator|=
name|g
operator|+
name|lre
operator|->
name|lre_addend
operator|-
name|p
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_RELAX_LOCAL_EXEC
case|:
name|_tls_relax_ld_to_le
argument_list|(
name|ld
argument_list|,
name|ls
argument_list|,
name|lre
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"Internal: invalid TLS relaxation %d"
argument_list|,
name|tr
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|R_X86_64_DTPOFF32
case|:
comment|/* Local Dynamic (offset) */
name|tr
operator|=
name|_tls_check_relax
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tr
condition|)
block|{
case|case
name|TLS_RELAX_NONE
case|:
name|s32
operator|=
name|_tls_dtpoff
argument_list|(
name|lo
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_RELAX_LOCAL_EXEC
case|:
name|s32
operator|=
name|_tls_tpoff
argument_list|(
name|lo
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s32
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"Internal: invalid TLS relaxation %d"
argument_list|,
name|tr
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|R_X86_64_GOTTPOFF
case|:
comment|/* Initial Exec */
name|tr
operator|=
name|_tls_check_relax
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tr
condition|)
block|{
case|case
name|TLS_RELAX_NONE
case|:
name|g
operator|=
name|_got_offset
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|s32
operator|=
name|g
operator|+
name|lre
operator|->
name|lre_addend
operator|-
name|p
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s32
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_RELAX_LOCAL_EXEC
case|:
name|_tls_relax_ie_to_le
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|,
name|lre
argument_list|,
name|lsb
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"Internal: invalid TLS relaxation %d"
argument_list|,
name|tr
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|R_X86_64_TPOFF32
case|:
comment|/* Local Exec */
name|s32
operator|=
name|_tls_tpoff
argument_list|(
name|lo
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s32
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"Relocation %s not supported"
argument_list|,
name|elftc_reloc_type_str
argument_list|(
name|EM_X86_64
argument_list|,
name|lre
operator|->
name|lre_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_adjust_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|_is
decl_stmt|;
operator|(
name|void
operator|)
name|ld
expr_stmt|;
operator|(
name|void
operator|)
name|is
expr_stmt|;
operator|(
name|void
operator|)
name|buf
expr_stmt|;
comment|/* Only need to adjust relocation against section symbols. */
if|if
condition|(
name|lsb
operator|->
name|lsb_type
operator|!=
name|STT_SECTION
condition|)
return|return;
if|if
condition|(
operator|(
name|_is
operator|=
name|lsb
operator|->
name|lsb_is
operator|)
operator|==
name|NULL
operator|||
name|_is
operator|->
name|is_output
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Update the relocation addend to point to the new location 	 * in the output object. 	 */
name|lre
operator|->
name|lre_addend
operator|+=
name|_is
operator|->
name|is_reloff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|ld_tls_relax
name|_tls_check_relax
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
name|lsb
operator|=
name|ld_symbols_ref
argument_list|(
name|lre
operator|->
name|lre_sym
argument_list|)
expr_stmt|;
comment|/* 	 * If the linker is performing -static linking, we should always 	 * use the Local Exec model. 	 */
if|if
condition|(
operator|!
name|ld
operator|->
name|ld_dynamic_link
condition|)
return|return
operator|(
name|TLS_RELAX_LOCAL_EXEC
operator|)
return|;
comment|/* 	 * If the linker is creating a DSO, we can not perform any TLS 	 * relaxation. 	 */
if|if
condition|(
name|ld
operator|->
name|ld_dso
condition|)
return|return
operator|(
name|TLS_RELAX_NONE
operator|)
return|;
comment|/* 	 * The linker is creating an executable, if the symbol is 	 * defined in a regular object, we can use the Local Exec model. 	 */
if|if
condition|(
name|lsb
operator|->
name|lsb_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|ld_symbols_in_regular
argument_list|(
name|lsb
argument_list|)
condition|)
return|return
operator|(
name|TLS_RELAX_LOCAL_EXEC
operator|)
return|;
comment|/* 	 * If the TLS model is Global Dynamic, we can relax it to Initial 	 * Exec model since the linker is creating an executable. 	 */
if|if
condition|(
name|lre
operator|->
name|lre_type
operator|==
name|R_X86_64_TLSGD
condition|)
return|return
operator|(
name|TLS_RELAX_INIT_EXEC
operator|)
return|;
comment|/* For all the other cases, no relaxation can be done. */
return|return
operator|(
name|TLS_RELAX_NONE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|_tls_tpoff
parameter_list|(
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|int32_t
name|tls_off
decl_stmt|;
name|tls_off
operator|=
operator|-
name|roundup
argument_list|(
name|lo
operator|->
name|lo_tls_size
argument_list|,
name|lo
operator|->
name|lo_tls_align
argument_list|)
expr_stmt|;
return|return
operator|(
name|tls_off
operator|+
operator|(
name|lsb
operator|->
name|lsb_value
operator|-
name|lo
operator|->
name|lo_tls_addr
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|_tls_dtpoff
parameter_list|(
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
return|return
operator|(
name|lsb
operator|->
name|lsb_value
operator|-
name|lo
operator|->
name|lo_tls_addr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_tls_verify_gd
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|off
parameter_list|)
block|{
comment|/* 	 * Global Dynamic model: 	 * 	 * 0x00 .byte 0x66 	 * 0x01 leaq x@tlsgd(%rip), %rdi 	 * 0x08 .word 0x6666 	 * 0x0a rex64 	 * 0x0b call _tls_get_addr@plt 	 */
name|uint8_t
name|gd
index|[]
init|=
literal|"\x66\x48\x8d\x3d\x00\x00\x00\x00"
literal|"\x66\x66\x48\xe8\x00\x00\x00\x00"
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
operator|+
name|off
argument_list|,
name|gd
argument_list|,
sizeof|sizeof
argument_list|(
name|gd
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_tls_verify_ld
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|off
parameter_list|)
block|{
comment|/* 	 * Local Dynamic model: 	 * 	 * 0x00 leaq x@tlsld(%rip), %rdi 	 * 0x07 call _tls_get_addr@plt 	 */
name|uint8_t
name|ld
index|[]
init|=
literal|"\x48\x8d\x3d\x00\x00\x00\x00"
literal|"\xe8\x00\x00\x00\x00"
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
operator|+
name|off
argument_list|,
name|ld
argument_list|,
sizeof|sizeof
argument_list|(
name|ld
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_tls_relax_gd_to_ie
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_state
modifier|*
name|ls
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|uint64_t
name|p
parameter_list|,
name|uint64_t
name|g
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
comment|/* 	 * Initial Exec model: 	 * 	 * 0x00 movq %fs:0, %rax 	 * 0x09 addq x@gottpoff(%rip), %rax 	 */
name|uint8_t
name|ie
index|[]
init|=
literal|"\x64\x48\x8b\x04\x25\x00\x00\x00\x00"
literal|"\x48\x03\x05\x00\x00\x00\x00"
decl_stmt|;
name|int32_t
name|s32
decl_stmt|;
name|assert
argument_list|(
name|lre
operator|->
name|lre_type
operator|==
name|R_X86_64_TLSGD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_tls_verify_gd
argument_list|(
name|buf
argument_list|,
name|lre
operator|->
name|lre_offset
operator|-
literal|4
argument_list|)
condition|)
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"unrecognized TLS global dynamic model code"
argument_list|)
expr_stmt|;
comment|/* Rewrite Global Dynamic to Initial Exec model. */
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|buf
operator|+
name|lre
operator|->
name|lre_offset
operator|-
literal|4
argument_list|,
name|ie
argument_list|,
sizeof|sizeof
argument_list|(
name|ie
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * R_X86_64_TLSGD relocation is applied at gd[4]. After it's relaxed 	 * to Initial Exec model, the resulting R_X86_64_GOTTPOFF relocation 	 * should be applied at ie[12]. The addend should remain the same 	 * since instruction "leaq x@tlsgd(%rip), %rdi" and 	 * "addq x@gottpoff(%rip), %rax" has the same length. `p' is moved 	 * 8 bytes forward. 	 */
name|s32
operator|=
name|g
operator|+
name|lre
operator|->
name|lre_addend
operator|-
operator|(
name|p
operator|+
literal|8
operator|)
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
operator|+
literal|8
argument_list|,
name|s32
argument_list|)
expr_stmt|;
comment|/* Ignore the next R_X86_64_PLT32 relocation for _tls_get_addr. */
name|ls
operator|->
name|ls_ignore_next_plt
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_tls_relax_gd_to_le
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_state
modifier|*
name|ls
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
comment|/* 	 * Local Exec model: 	 * 	 * 0x00 movq %fs:0, %rax 	 * 0x09 leaq x@tpoff(%rax), %rax 	 */
name|uint8_t
name|le
index|[]
init|=
literal|"\x64\x48\x8b\x04\x25\x00\x00\x00\x00"
literal|"\x48\x8d\x80\x00\x00\x00\x00"
decl_stmt|;
name|int32_t
name|s32
decl_stmt|;
if|if
condition|(
operator|!
name|_tls_verify_gd
argument_list|(
name|buf
argument_list|,
name|lre
operator|->
name|lre_offset
operator|-
literal|4
argument_list|)
condition|)
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"unrecognized TLS global dynamic model code"
argument_list|)
expr_stmt|;
comment|/* Rewrite Global Dynamic to Local Exec model. */
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|buf
operator|+
name|lre
operator|->
name|lre_offset
operator|-
literal|4
argument_list|,
name|le
argument_list|,
sizeof|sizeof
argument_list|(
name|le
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * R_X86_64_TLSGD relocation is applied at gd[4]. After it's relaxed 	 * to Local Exec model, the resulting R_X86_64_TPOFF32 should be 	 * applied at le[12]. 	 */
name|s32
operator|=
name|_tls_tpoff
argument_list|(
name|lo
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
operator|+
literal|8
argument_list|,
name|s32
argument_list|)
expr_stmt|;
comment|/* Ignore the next R_X86_64_PLT32 relocation for _tls_get_addr. */
name|ls
operator|->
name|ls_ignore_next_plt
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_tls_relax_ld_to_le
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_state
modifier|*
name|ls
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
comment|/* 	 * Local Exec model: (with padding) 	 * 	 * 0x00 .word 0x6666 	 * 0x02 .byte 0x66 	 * 0x03 movq %fs:0, %rax 	 */
name|uint8_t
name|le_p
index|[]
init|=
literal|"\x66\x66\x66\x64\x48\x8b\x04\x25\x00\x00\x00\x00"
decl_stmt|;
name|assert
argument_list|(
name|lre
operator|->
name|lre_type
operator|==
name|R_X86_64_TLSLD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_tls_verify_ld
argument_list|(
name|buf
argument_list|,
name|lre
operator|->
name|lre_offset
operator|-
literal|3
argument_list|)
condition|)
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"unrecognized TLS local dynamic model code"
argument_list|)
expr_stmt|;
comment|/* Rewrite Local Dynamic to Local Exec model. */
name|memcpy
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
operator|-
literal|3
argument_list|,
name|le_p
argument_list|,
sizeof|sizeof
argument_list|(
name|le_p
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Ignore the next R_X86_64_PLT32 relocation for _tls_get_addr. */
name|ls
operator|->
name|ls_ignore_next_plt
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_tls_relax_ie_to_le
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|int32_t
name|s32
decl_stmt|;
name|uint8_t
name|reg
decl_stmt|;
operator|(
name|void
operator|)
name|ld
expr_stmt|;
name|assert
argument_list|(
name|lre
operator|->
name|lre_type
operator|==
name|R_X86_64_GOTTPOFF
argument_list|)
expr_stmt|;
comment|/* 	 * Rewrite Initial Exec to Local Exec model: rewrite 	 * "movq 0x0(%rip),%reg" to "movq 0x0,%reg". or, 	 * "addq 0x0(%rip),%rsp" to "addq 0x0,%rsp". or, 	 * "addq 0x0(%rip),%reg" to "leaq 0x0(%reg),%reg" 	 */
name|reg
operator|=
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|1
index|]
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|2
index|]
operator|==
literal|0x8b
condition|)
block|{
comment|/* movq 0x0(%rip),%reg -> movq 0x0,%reg. */
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|2
index|]
operator|=
literal|0xc7
expr_stmt|;
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|1
index|]
operator|=
literal|0xc0
operator||
name|reg
expr_stmt|;
comment|/* Set r/m to `reg' */
comment|/* 		 * Set REX.B (high bit for r/m) if REX.R (high bit for reg) 		 * is set. 		 */
if|if
condition|(
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|3
index|]
operator|==
literal|0x4c
condition|)
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|3
index|]
operator|=
literal|0x49
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|==
literal|4
condition|)
block|{
comment|/* addq 0x0(%rip),%rsp -> addq 0x0,%rsp */
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|2
index|]
operator|=
literal|0x81
expr_stmt|;
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|1
index|]
operator|=
literal|0xc0
operator||
name|reg
expr_stmt|;
comment|/* Set r/m to `reg' */
comment|/* 		 * Set REX.B (high bit for r/m) if REX.R (high bit for reg) 		 * is set. 		 */
if|if
condition|(
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|3
index|]
operator|==
literal|0x4c
condition|)
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|3
index|]
operator|=
literal|0x49
expr_stmt|;
block|}
else|else
block|{
comment|/* addq 0x0(%rip),%reg -> leaq 0x0(%reg),%reg */
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|2
index|]
operator|=
literal|0x8d
expr_stmt|;
comment|/* Both reg and r/m in ModRM should be set to `reg' */
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|1
index|]
operator|=
literal|0x80
operator||
name|reg
operator||
operator|(
name|reg
operator|<<
literal|3
operator|)
expr_stmt|;
comment|/* Set both REX.B and REX.R if REX.R is set */
if|if
condition|(
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|3
index|]
operator|==
literal|0x4c
condition|)
name|buf
index|[
name|lre
operator|->
name|lre_offset
operator|-
literal|3
index|]
operator|=
literal|0x4d
expr_stmt|;
block|}
comment|/* 	 * R_X86_64_GOTTPOFF relocation is applied at ie[12]. After it's 	 * relaxed to Local Exec model, the resulting R_X86_64_TPOFF32 	 * should be applied at le[12]. Thus the offset remains the same. 	 */
name|s32
operator|=
name|_tls_tpoff
argument_list|(
name|lo
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|s32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_tls_gd_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
comment|/* 	 * Reserve 2 GOT entries and generate R_X86_64_DTPMOD64 and 	 * R_X86_64_DTPOFF64 relocations. 	 */
if|if
condition|(
operator|!
name|lsb
operator|->
name|lsb_got
condition|)
block|{
name|_reserve_got_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|_create_got_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
name|R_X86_64_DTPMOD64
argument_list|,
name|lsb
operator|->
name|lsb_got_off
argument_list|)
expr_stmt|;
name|_create_got_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
name|R_X86_64_DTPOFF64
argument_list|,
name|lsb
operator|->
name|lsb_got_off
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_create_tls_ld_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
comment|/* Reserve 2 GOT entries and generate R_X86_64_DTPMOD64 reloation. */
if|if
condition|(
operator|!
name|lsb
operator|->
name|lsb_got
condition|)
block|{
name|_reserve_got_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|_create_got_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
name|R_X86_64_DTPMOD64
argument_list|,
name|lsb
operator|->
name|lsb_got_off
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_tls_ld
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_create_tls_ie_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
comment|/* Reserve 1 GOT entry and generate R_X86_64_TPOFF64 relocation. */
if|if
condition|(
operator|!
name|lsb
operator|->
name|lsb_got
condition|)
block|{
name|_reserve_got_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_create_got_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
name|R_X86_64_TPOFF64
argument_list|,
name|lsb
operator|->
name|lsb_got_off
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|amd64_register
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_arch
modifier|*
name|amd64
decl_stmt|,
modifier|*
name|amd64_alt
decl_stmt|;
if|if
condition|(
operator|(
name|amd64
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|amd64
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|amd64
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|amd64
operator|->
name|name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
literal|"amd64"
argument_list|)
expr_stmt|;
name|amd64
operator|->
name|script
operator|=
name|amd64_script
expr_stmt|;
name|amd64
operator|->
name|interp
operator|=
literal|"/libexec/ld-elf.so.1"
expr_stmt|;
name|amd64
operator|->
name|get_max_page_size
operator|=
name|_get_max_page_size
expr_stmt|;
name|amd64
operator|->
name|get_common_page_size
operator|=
name|_get_common_page_size
expr_stmt|;
name|amd64
operator|->
name|scan_reloc
operator|=
name|_scan_reloc
expr_stmt|;
name|amd64
operator|->
name|process_reloc
operator|=
name|_process_reloc
expr_stmt|;
name|amd64
operator|->
name|adjust_reloc
operator|=
name|_adjust_reloc
expr_stmt|;
name|amd64
operator|->
name|is_absolute_reloc
operator|=
name|_is_absolute_reloc
expr_stmt|;
name|amd64
operator|->
name|is_relative_reloc
operator|=
name|_is_relative_reloc
expr_stmt|;
name|amd64
operator|->
name|finalize_reloc
operator|=
name|_finalize_reloc
expr_stmt|;
name|amd64
operator|->
name|finalize_got_and_plt
operator|=
name|_finalize_got_and_plt
expr_stmt|;
name|amd64
operator|->
name|reloc_is_64bit
operator|=
literal|1
expr_stmt|;
name|amd64
operator|->
name|reloc_is_rela
operator|=
literal|1
expr_stmt|;
name|amd64
operator|->
name|reloc_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_Rela
argument_list|)
expr_stmt|;
name|HASH_ADD_STR
argument_list|(
name|ld
operator|->
name|ld_arch_list
argument_list|,
name|name
argument_list|,
name|amd64
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|amd64_alt
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|amd64_alt
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|amd64_alt
argument_list|,
name|amd64
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ld_arch
argument_list|)
argument_list|)
expr_stmt|;
name|amd64_alt
operator|->
name|alias
operator|=
name|amd64
expr_stmt|;
name|snprintf
argument_list|(
name|amd64_alt
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|amd64_alt
operator|->
name|name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
literal|"x86-64"
argument_list|)
expr_stmt|;
name|HASH_ADD_STR
argument_list|(
name|ld
operator|->
name|ld_arch_list
argument_list|,
name|name
argument_list|,
name|amd64_alt
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

