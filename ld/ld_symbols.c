begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ld_dynamic.h"
end_include

begin_include
include|#
directive|include
file|"ld_file.h"
end_include

begin_include
include|#
directive|include
file|"ld_input.h"
end_include

begin_include
include|#
directive|include
file|"ld_output.h"
end_include

begin_include
include|#
directive|include
file|"ld_symbols.h"
end_include

begin_include
include|#
directive|include
file|"ld_symver.h"
end_include

begin_include
include|#
directive|include
file|"ld_script.h"
end_include

begin_include
include|#
directive|include
file|"ld_strtab.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: ld_symbols.c 2965 2013-09-10 02:46:29Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|_INIT_SYMTAB_SIZE
value|128
end_define

begin_function_decl
specifier|static
name|void
name|_load_symbols
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_file
modifier|*
name|lf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_load_archive_symbols
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_file
modifier|*
name|lf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_load_elf_symbols
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_unload_symbols
parameter_list|(
name|struct
name|ld_input
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_add_elf_symbol
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf
modifier|*
name|e
parameter_list|,
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
name|size_t
name|strndx
parameter_list|,
name|int
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_add_to_dynsym_table
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_write_to_dynsym_table
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_add_to_symbol_table
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_free_symbol_table
parameter_list|(
name|struct
name|ld_symbol_table
modifier|*
name|symtab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ld_symbol_table
modifier|*
name|_alloc_symbol_table
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_archive_member_extracted
parameter_list|(
name|struct
name|ld_archive
modifier|*
name|la
parameter_list|,
name|off_t
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_archive_member
modifier|*
name|_extract_archive_member
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_file
modifier|*
name|lf
parameter_list|,
name|struct
name|ld_archive
modifier|*
name|la
parameter_list|,
name|off_t
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_print_extracted_member
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_archive_member
modifier|*
name|lam
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_resolve_and_add_symbol
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_symbol
modifier|*
name|_alloc_symbol
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_free_symbol
parameter_list|(
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_symbol
modifier|*
name|_find_symbol
parameter_list|(
name|struct
name|ld_symbol
modifier|*
name|tbl
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_update_symbol
parameter_list|(
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|_add_symbol
parameter_list|(
name|tbl
parameter_list|,
name|s
parameter_list|)
value|do {				\ 	HASH_ADD_KEYPTR(hh, (tbl), (s)->lsb_longname,		\ 	    strlen((s)->lsb_longname), (s));			\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|_remove_symbol
parameter_list|(
name|tbl
parameter_list|,
name|s
parameter_list|)
value|do {				\ 	HASH_DEL((tbl), (s));					\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|_resolve_symbol
parameter_list|(
name|_s
parameter_list|,
name|s
parameter_list|)
value|do {				\ 	assert((_s) != (s));					\ 	(s)->lsb_ref_dso |= (_s)->lsb_ref_dso;			\ 	(s)->lsb_ref_ndso |= (_s)->lsb_ref_ndso;		\ 	if ((s)->lsb_prev != NULL) {				\ 		(s)->lsb_prev->lsb_ref = (_s);			\ 		(_s)->lsb_prev = (s)->lsb_prev;			\ 	}							\ 	(s)->lsb_prev = (_s);					\ 	(_s)->lsb_ref = (s);					\ 	} while (0)
end_define

begin_function
name|void
name|ld_symbols_cleanup
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_input
modifier|*
name|li
decl_stmt|;
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|,
modifier|*
name|_lsb
decl_stmt|;
name|HASH_CLEAR
argument_list|(
name|hh
argument_list|,
name|ld
operator|->
name|ld_sym
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|li
argument_list|,
argument|&ld->ld_lilist
argument_list|,
argument|li_next
argument_list|)
block|{
name|_unload_symbols
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ld
operator|->
name|ld_ext_symbols
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|lsb
argument_list|,
argument|ld->ld_ext_symbols
argument_list|,
argument|lsb_next
argument_list|,
argument|_lsb
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
name|ld
operator|->
name|ld_ext_symbols
argument_list|,
name|lsb
argument_list|,
name|ld_symbol
argument_list|,
name|lsb_next
argument_list|)
expr_stmt|;
name|_free_symbol
argument_list|(
name|lsb
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ld
operator|->
name|ld_ext_symbols
argument_list|)
expr_stmt|;
name|ld
operator|->
name|ld_ext_symbols
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ld
operator|->
name|ld_var_symbols
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|lsb
argument_list|,
argument|ld->ld_var_symbols
argument_list|,
argument|lsb_next
argument_list|,
argument|_lsb
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
name|ld
operator|->
name|ld_var_symbols
argument_list|,
name|lsb
argument_list|,
name|ld_symbol
argument_list|,
name|lsb_next
argument_list|)
expr_stmt|;
name|_free_symbol
argument_list|(
name|lsb
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ld
operator|->
name|ld_var_symbols
argument_list|)
expr_stmt|;
name|ld
operator|->
name|ld_var_symbols
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ld
operator|->
name|ld_dyn_symbols
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ld
operator|->
name|ld_dyn_symbols
argument_list|)
expr_stmt|;
name|ld
operator|->
name|ld_dyn_symbols
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ld
operator|->
name|ld_symtab
operator|!=
name|NULL
condition|)
block|{
name|_free_symbol_table
argument_list|(
name|ld
operator|->
name|ld_symtab
argument_list|)
expr_stmt|;
name|ld
operator|->
name|ld_symtab
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ld
operator|->
name|ld_strtab
operator|!=
name|NULL
condition|)
block|{
name|ld_strtab_free
argument_list|(
name|ld
operator|->
name|ld_strtab
argument_list|)
expr_stmt|;
name|ld
operator|->
name|ld_strtab
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ld_symbols_add_extern
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
comment|/* Check if the extern symbol has been added before. */
if|if
condition|(
name|_find_symbol
argument_list|(
name|ld
operator|->
name|ld_sym
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
name|lsb
operator|=
name|_alloc_symbol
argument_list|(
name|ld
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|->
name|lsb_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|->
name|lsb_longname
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_ext_symbols
operator|==
name|NULL
condition|)
block|{
name|ld
operator|->
name|ld_ext_symbols
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ld
operator|->
name|ld_ext_symbols
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_ext_symbols
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|ld
operator|->
name|ld_ext_symbols
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
name|ld
operator|->
name|ld_ext_symbols
argument_list|,
name|lsb
argument_list|,
name|lsb_next
argument_list|)
expr_stmt|;
name|_add_symbol
argument_list|(
name|ld
operator|->
name|ld_sym
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_symbols_add_variable
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_variable
modifier|*
name|ldv
parameter_list|,
name|unsigned
name|provide
parameter_list|,
name|unsigned
name|hidden
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
name|lsb
operator|=
name|_alloc_symbol
argument_list|(
name|ld
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|->
name|lsb_name
operator|=
name|strdup
argument_list|(
name|ldv
operator|->
name|ldv_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|->
name|lsb_longname
operator|=
name|strdup
argument_list|(
name|ldv
operator|->
name|ldv_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_var
operator|=
name|ldv
expr_stmt|;
name|lsb
operator|->
name|lsb_bind
operator|=
name|STB_GLOBAL
expr_stmt|;
name|lsb
operator|->
name|lsb_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|lsb
operator|->
name|lsb_provide
operator|=
name|provide
expr_stmt|;
if|if
condition|(
name|hidden
condition|)
name|lsb
operator|->
name|lsb_other
operator|=
name|STV_HIDDEN
expr_stmt|;
name|lsb
operator|->
name|lsb_ref_ndso
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_var_symbols
operator|==
name|NULL
condition|)
block|{
name|ld
operator|->
name|ld_var_symbols
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ld
operator|->
name|ld_var_symbols
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_var_symbols
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|ld
operator|->
name|ld_var_symbols
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
name|ld
operator|->
name|ld_var_symbols
argument_list|,
name|lsb
argument_list|,
name|lsb_next
argument_list|)
expr_stmt|;
name|_resolve_and_add_symbol
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_symbols_add_internal
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|uint16_t
name|shndx
parameter_list|,
name|unsigned
name|char
name|bind
parameter_list|,
name|unsigned
name|char
name|type
parameter_list|,
name|unsigned
name|char
name|other
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_output_section
modifier|*
name|preset_os
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
name|lsb
operator|=
name|_alloc_symbol
argument_list|(
name|ld
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|->
name|lsb_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|->
name|lsb_longname
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_size
operator|=
name|size
expr_stmt|;
name|lsb
operator|->
name|lsb_value
operator|=
name|value
expr_stmt|;
name|lsb
operator|->
name|lsb_shndx
operator|=
name|shndx
expr_stmt|;
name|lsb
operator|->
name|lsb_bind
operator|=
name|bind
expr_stmt|;
name|lsb
operator|->
name|lsb_type
operator|=
name|type
expr_stmt|;
name|lsb
operator|->
name|lsb_other
operator|=
name|other
expr_stmt|;
name|lsb
operator|->
name|lsb_preset_os
operator|=
name|preset_os
expr_stmt|;
name|lsb
operator|->
name|lsb_ref_ndso
operator|=
literal|1
expr_stmt|;
name|lsb
operator|->
name|lsb_input
operator|=
operator|(
name|is
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|is
operator|->
name|is_input
expr_stmt|;
name|lsb
operator|->
name|lsb_is
operator|=
name|is
expr_stmt|;
name|_resolve_and_add_symbol
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ld_symbols_get_value
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|=
name|_find_symbol
argument_list|(
name|ld
operator|->
name|ld_sym
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|val
operator|=
name|lsb
operator|->
name|lsb_value
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ld_symbols_resolve
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_file
modifier|*
name|lf
decl_stmt|;
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|,
modifier|*
name|_lsb
decl_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ld
operator|->
name|ld_lflist
argument_list|)
condition|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_print_version
condition|)
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
else|else
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"no input files"
argument_list|)
expr_stmt|;
block|}
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
name|lf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ld
operator|->
name|ld_lflist
argument_list|)
expr_stmt|;
name|ls
operator|->
name|ls_group_level
operator|=
name|lf
operator|->
name|lf_group_level
expr_stmt|;
while|while
condition|(
name|lf
operator|!=
name|NULL
condition|)
block|{
comment|/* Process archive groups. */
if|if
condition|(
name|lf
operator|->
name|lf_group_level
operator|<
name|ls
operator|->
name|ls_group_level
operator|&&
name|ls
operator|->
name|ls_extracted
index|[
name|ls
operator|->
name|ls_group_level
index|]
condition|)
block|{
do|do
block|{
name|lf
operator|=
name|TAILQ_PREV
argument_list|(
name|lf
argument_list|,
name|ld_file_head
argument_list|,
name|lf_next
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|lf
operator|->
name|lf_group_level
operator|>=
name|ls
operator|->
name|ls_group_level
condition|)
do|;
name|lf
operator|=
name|TAILQ_NEXT
argument_list|(
name|lf
argument_list|,
name|lf_next
argument_list|)
expr_stmt|;
name|ls
operator|->
name|ls_extracted
index|[
name|ls
operator|->
name|ls_group_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ls
operator|->
name|ls_group_level
operator|=
name|lf
operator|->
name|lf_group_level
expr_stmt|;
comment|/* Load symbols. */
name|ld_file_load
argument_list|(
name|ld
argument_list|,
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|ls_arch_conflict
condition|)
block|{
name|ld_file_unload
argument_list|(
name|ld
argument_list|,
name|lf
argument_list|)
expr_stmt|;
return|return;
block|}
name|_load_symbols
argument_list|(
name|ld
argument_list|,
name|lf
argument_list|)
expr_stmt|;
name|ld_file_unload
argument_list|(
name|ld
argument_list|,
name|lf
argument_list|)
expr_stmt|;
name|lf
operator|=
name|TAILQ_NEXT
argument_list|(
name|lf
argument_list|,
name|lf_next
argument_list|)
expr_stmt|;
block|}
comment|/* Print information regarding space allocated for common symbols. */
if|if
condition|(
name|ld
operator|->
name|ld_print_linkmap
condition|)
block|{
name|printf
argument_list|(
literal|"\nCommon symbols:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-34s %-10s %s\n"
argument_list|,
literal|"name"
argument_list|,
literal|"size"
argument_list|,
literal|"file"
argument_list|)
expr_stmt|;
name|HASH_ITER
argument_list|(
argument|hh
argument_list|,
argument|ld->ld_sym
argument_list|,
argument|lsb
argument_list|,
argument|_lsb
argument_list|)
block|{
if|if
condition|(
name|lsb
operator|->
name|lsb_shndx
operator|!=
name|SHN_COMMON
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%-34s"
argument_list|,
name|lsb
operator|->
name|lsb_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|lsb
operator|->
name|lsb_name
argument_list|)
operator|>
literal|34
condition|)
name|printf
argument_list|(
literal|"\n%-34s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %#-10jx %s\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lsb
operator|->
name|lsb_size
argument_list|,
name|ld_input_get_fullname
argument_list|(
name|ld
argument_list|,
name|lsb
operator|->
name|lsb_input
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ld_symbols_update
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_input
modifier|*
name|li
decl_stmt|;
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|,
modifier|*
name|_lsb
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|li
argument_list|,
argument|&ld->ld_lilist
argument_list|,
argument|li_next
argument_list|)
block|{
if|if
condition|(
name|li
operator|->
name|li_local
operator|==
name|NULL
condition|)
continue|continue;
name|STAILQ_FOREACH
argument_list|(
argument|lsb
argument_list|,
argument|li->li_local
argument_list|,
argument|lsb_next
argument_list|)
name|_update_symbol
argument_list|(
name|lsb
argument_list|)
expr_stmt|;
block|}
name|HASH_ITER
argument_list|(
argument|hh
argument_list|,
argument|ld->ld_sym
argument_list|,
argument|lsb
argument_list|,
argument|_lsb
argument_list|)
block|{
comment|/* Skip symbols from DSOs. */
if|if
condition|(
name|ld_symbols_in_dso
argument_list|(
name|lsb
argument_list|)
condition|)
continue|continue;
name|_update_symbol
argument_list|(
name|lsb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ld_symbols_build_symtab
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|,
modifier|*
name|_os
decl_stmt|;
name|struct
name|ld_input
modifier|*
name|li
decl_stmt|;
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
name|_lsb
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|ld
operator|->
name|ld_symtab
operator|=
name|_alloc_symbol_table
argument_list|(
name|ld
argument_list|)
expr_stmt|;
name|ld
operator|->
name|ld_strtab
operator|=
name|ld_strtab_alloc
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Create an initial symbol at the beginning of symbol table. */
name|_lsb
operator|.
name|lsb_name
operator|=
name|NULL
expr_stmt|;
name|_lsb
operator|.
name|lsb_size
operator|=
literal|0
expr_stmt|;
name|_lsb
operator|.
name|lsb_value
operator|=
literal|0
expr_stmt|;
name|_lsb
operator|.
name|lsb_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|_lsb
operator|.
name|lsb_bind
operator|=
name|STB_LOCAL
expr_stmt|;
name|_lsb
operator|.
name|lsb_type
operator|=
name|STT_NOTYPE
expr_stmt|;
name|_lsb
operator|.
name|lsb_other
operator|=
literal|0
expr_stmt|;
name|_add_to_symbol_table
argument_list|(
name|ld
argument_list|,
operator|&
name|_lsb
argument_list|)
expr_stmt|;
comment|/* Create STT_SECTION symbols. */
name|STAILQ_FOREACH
argument_list|(
argument|os
argument_list|,
argument|&lo->lo_oslist
argument_list|,
argument|os_next
argument_list|)
block|{
if|if
condition|(
name|os
operator|->
name|os_empty
condition|)
continue|continue;
if|if
condition|(
name|os
operator|->
name|os_secsym
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|os
operator|->
name|os_rel
condition|)
continue|continue;
name|os
operator|->
name|os_secsym
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|os
operator|->
name|os_secsym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_secsym
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_secsym
operator|->
name|lsb_name
operator|=
name|NULL
expr_stmt|;
name|os
operator|->
name|os_secsym
operator|->
name|lsb_size
operator|=
literal|0
expr_stmt|;
name|os
operator|->
name|os_secsym
operator|->
name|lsb_value
operator|=
name|os
operator|->
name|os_addr
expr_stmt|;
name|os
operator|->
name|os_secsym
operator|->
name|lsb_shndx
operator|=
name|elf_ndxscn
argument_list|(
name|os
operator|->
name|os_scn
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_secsym
operator|->
name|lsb_bind
operator|=
name|STB_LOCAL
expr_stmt|;
name|os
operator|->
name|os_secsym
operator|->
name|lsb_type
operator|=
name|STT_SECTION
expr_stmt|;
name|os
operator|->
name|os_secsym
operator|->
name|lsb_other
operator|=
literal|0
expr_stmt|;
name|_add_to_symbol_table
argument_list|(
name|ld
argument_list|,
name|os
operator|->
name|os_secsym
argument_list|)
expr_stmt|;
comment|/* Create STT_SECTION symbols for relocation sections. */
if|if
condition|(
name|os
operator|->
name|os_r
operator|!=
name|NULL
operator|&&
operator|!
name|ld
operator|->
name|ld_reloc
condition|)
block|{
name|_os
operator|=
name|os
operator|->
name|os_r
expr_stmt|;
name|_os
operator|->
name|os_secsym
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|_os
operator|->
name|os_secsym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_os
operator|->
name|os_secsym
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|_os
operator|->
name|os_secsym
operator|->
name|lsb_name
operator|=
name|NULL
expr_stmt|;
name|_os
operator|->
name|os_secsym
operator|->
name|lsb_size
operator|=
literal|0
expr_stmt|;
name|_os
operator|->
name|os_secsym
operator|->
name|lsb_value
operator|=
name|_os
operator|->
name|os_addr
expr_stmt|;
name|_os
operator|->
name|os_secsym
operator|->
name|lsb_shndx
operator|=
name|elf_ndxscn
argument_list|(
name|_os
operator|->
name|os_scn
argument_list|)
expr_stmt|;
name|_os
operator|->
name|os_secsym
operator|->
name|lsb_bind
operator|=
name|STB_LOCAL
expr_stmt|;
name|_os
operator|->
name|os_secsym
operator|->
name|lsb_type
operator|=
name|STT_SECTION
expr_stmt|;
name|_os
operator|->
name|os_secsym
operator|->
name|lsb_other
operator|=
literal|0
expr_stmt|;
name|_add_to_symbol_table
argument_list|(
name|ld
argument_list|,
name|_os
operator|->
name|os_secsym
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy local symbols from each input object. */
name|STAILQ_FOREACH
argument_list|(
argument|li
argument_list|,
argument|&ld->ld_lilist
argument_list|,
argument|li_next
argument_list|)
block|{
if|if
condition|(
name|li
operator|->
name|li_local
operator|==
name|NULL
condition|)
continue|continue;
name|STAILQ_FOREACH
argument_list|(
argument|lsb
argument_list|,
argument|li->li_local
argument_list|,
argument|lsb_next
argument_list|)
block|{
if|if
condition|(
name|lsb
operator|->
name|lsb_type
operator|!=
name|STT_SECTION
operator|&&
name|lsb
operator|->
name|lsb_index
operator|!=
literal|0
condition|)
name|_add_to_symbol_table
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
comment|/* 			 * Set the symbol index of the STT_SECTION symbols 			 * to the index of the section symbol for the 			 * corresponding output section. The updated 			 * symbol index will be used by the relocation 			 * serialization function If the linker generates 			 * relocatable object or option -emit-relocs is 			 * specified. 			 */
if|if
condition|(
name|lsb
operator|->
name|lsb_type
operator|==
name|STT_SECTION
condition|)
block|{
name|is
operator|=
name|lsb
operator|->
name|lsb_is
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_output
operator|!=
name|NULL
condition|)
block|{
name|os
operator|=
name|is
operator|->
name|is_output
expr_stmt|;
name|assert
argument_list|(
name|os
operator|->
name|os_secsym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_out_index
operator|=
name|os
operator|->
name|os_secsym
operator|->
name|lsb_out_index
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Copy resolved global symbols from hash table. */
name|HASH_ITER
argument_list|(
argument|hh
argument_list|,
argument|ld->ld_sym
argument_list|,
argument|lsb
argument_list|,
argument|tmp
argument_list|)
block|{
comment|/* Skip undefined/unreferenced symbols from DSO. */
if|if
condition|(
name|ld_symbols_in_dso
argument_list|(
name|lsb
argument_list|)
operator|&&
operator|(
name|lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_UNDEF
operator|||
operator|!
name|lsb
operator|->
name|lsb_ref_ndso
operator|)
condition|)
continue|continue;
comment|/* 		 * Skip linker script defined symbols when creating 		 * relocatable output object. 		 */
if|if
condition|(
name|lsb
operator|->
name|lsb_input
operator|==
name|NULL
operator|&&
name|ld
operator|->
name|ld_reloc
condition|)
continue|continue;
comment|/* Skip "provide" symbols that are not referenced. */
if|if
condition|(
name|lsb
operator|->
name|lsb_provide
operator|&&
name|lsb
operator|->
name|lsb_prev
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|lsb
operator|->
name|lsb_import
condition|)
block|{
if|if
condition|(
name|lsb
operator|->
name|lsb_type
operator|==
name|STT_FUNC
operator|&&
name|lsb
operator|->
name|lsb_func_addr
condition|)
name|lsb
operator|->
name|lsb_value
operator|=
name|lsb
operator|->
name|lsb_plt_off
expr_stmt|;
else|else
name|lsb
operator|->
name|lsb_value
operator|=
literal|0
expr_stmt|;
name|lsb
operator|->
name|lsb_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
name|_add_to_symbol_table
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ld_symbols_scan
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|ld
operator|->
name|ld_dynsym
operator|=
name|_alloc_symbol_table
argument_list|(
name|ld
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_dynstr
operator|==
name|NULL
condition|)
name|ld
operator|->
name|ld_dynstr
operator|=
name|ld_strtab_alloc
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reserve space for the initial symbol. */
name|ld
operator|->
name|ld_dynsym
operator|->
name|sy_size
operator|++
expr_stmt|;
name|HASH_ITER
argument_list|(
argument|hh
argument_list|,
argument|ld->ld_sym
argument_list|,
argument|lsb
argument_list|,
argument|tmp
argument_list|)
block|{
comment|/* 		 * Warn undefined symbols if the linker is creating an 		 * executable. 		 */
if|if
condition|(
operator|(
name|ld
operator|->
name|ld_exec
operator|||
name|ld
operator|->
name|ld_pie
operator|)
operator|&&
name|lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_UNDEF
operator|&&
name|lsb
operator|->
name|lsb_bind
operator|!=
name|STB_WEAK
condition|)
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"undefined symbol: %s"
argument_list|,
name|lsb
operator|->
name|lsb_name
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate space for common symbols and add them to the 		 * special input section COMMON for section layout later. 		 */
if|if
condition|(
name|lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_COMMON
condition|)
name|ld_input_alloc_common_symbol
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
comment|/* 		 * The code below handles the dynamic symbol table. If 		 * we are doing a -static linking, we can skip. 		 */
if|if
condition|(
operator|!
name|ld
operator|->
name|ld_dynamic_link
condition|)
continue|continue;
comment|/* 		 * Following symbols should not be added to the dynamic 		 * symbol table: 		 * 		 * 1. Do not add undefined symbols in DSOs. 		 */
if|if
condition|(
name|ld_symbols_in_dso
argument_list|(
name|lsb
argument_list|)
operator|&&
name|lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
comment|/* 		 * Add following symbols to the dynamic symbol table: 		 * 		 * 1. A symbol that is defined in a regular object and 		 *    referenced by a DSO. 		 * 		 * 2. A symbol that is defined in a DSO and referenced 		 *    by a regular object. 		 * 		 * 3. A symbol that is referenced by a dynamic relocation. 		 * 		 * 4. The linker creates a DSO and the symbol is defined 		 *    in a regular object and is visible externally. 		 * 		 */
if|if
condition|(
name|lsb
operator|->
name|lsb_ref_dso
operator|&&
name|ld_symbols_in_regular
argument_list|(
name|lsb
argument_list|)
condition|)
name|_add_to_dynsym_table
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lsb
operator|->
name|lsb_ref_ndso
operator|&&
name|ld_symbols_in_dso
argument_list|(
name|lsb
argument_list|)
condition|)
block|{
name|lsb
operator|->
name|lsb_import
operator|=
literal|1
expr_stmt|;
name|lsb
operator|->
name|lsb_input
operator|->
name|li_dso_refcnt
operator|++
expr_stmt|;
name|ld_symver_add_verdef_refcnt
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|_add_to_dynsym_table
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lsb
operator|->
name|lsb_dynrel
condition|)
name|_add_to_dynsym_table
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ld
operator|->
name|ld_dso
operator|&&
name|ld_symbols_in_regular
argument_list|(
name|lsb
argument_list|)
operator|&&
name|lsb
operator|->
name|lsb_other
operator|==
name|STV_DEFAULT
operator|&&
name|ld_symver_search_version_script
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
operator|!=
literal|0
condition|)
name|_add_to_dynsym_table
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ld_symbols_finalize_dynsym
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|,
name|_lsb
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create an initial symbol at the beginning of symbol table. */
name|_lsb
operator|.
name|lsb_name
operator|=
name|NULL
expr_stmt|;
name|_lsb
operator|.
name|lsb_nameindex
operator|=
literal|0
expr_stmt|;
name|_lsb
operator|.
name|lsb_size
operator|=
literal|0
expr_stmt|;
name|_lsb
operator|.
name|lsb_value
operator|=
literal|0
expr_stmt|;
name|_lsb
operator|.
name|lsb_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|_lsb
operator|.
name|lsb_bind
operator|=
name|STB_LOCAL
expr_stmt|;
name|_lsb
operator|.
name|lsb_type
operator|=
name|STT_NOTYPE
expr_stmt|;
name|_lsb
operator|.
name|lsb_other
operator|=
literal|0
expr_stmt|;
name|_write_to_dynsym_table
argument_list|(
name|ld
argument_list|,
operator|&
name|_lsb
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ld
operator|->
name|ld_dyn_symbols
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lsb
argument_list|,
argument|ld->ld_dyn_symbols
argument_list|,
argument|lsb_dyn
argument_list|)
block|{
if|if
condition|(
name|lsb
operator|->
name|lsb_import
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|_lsb
argument_list|,
name|lsb
argument_list|,
sizeof|sizeof
argument_list|(
name|_lsb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsb
operator|->
name|lsb_type
operator|==
name|STT_FUNC
operator|&&
name|lsb
operator|->
name|lsb_func_addr
condition|)
name|_lsb
operator|.
name|lsb_value
operator|=
name|lsb
operator|->
name|lsb_plt_off
expr_stmt|;
else|else
name|_lsb
operator|.
name|lsb_value
operator|=
literal|0
expr_stmt|;
name|_lsb
operator|.
name|lsb_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|_write_to_dynsym_table
argument_list|(
name|ld
argument_list|,
operator|&
name|_lsb
argument_list|)
expr_stmt|;
block|}
else|else
name|_write_to_dynsym_table
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
name|lo
operator|->
name|lo_dynsym
operator|->
name|os_info_val
operator|=
name|ld
operator|->
name|ld_dynsym
operator|->
name|sy_first_nonlocal
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the resolved symbol.  */
end_comment

begin_function
name|struct
name|ld_symbol
modifier|*
name|ld_symbols_ref
parameter_list|(
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
while|while
condition|(
name|lsb
operator|->
name|lsb_ref
operator|!=
name|NULL
condition|)
name|lsb
operator|=
name|lsb
operator|->
name|lsb_ref
expr_stmt|;
return|return
operator|(
name|lsb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a symbol can be overriden (by symbols in main executable).  */
end_comment

begin_function
name|int
name|ld_symbols_overridden
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
comment|/* Symbols can be overridden only when we are creating a DSO. */
if|if
condition|(
operator|!
name|ld
operator|->
name|ld_dso
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Only visible symbols can be overriden. */
if|if
condition|(
name|lsb
operator|->
name|lsb_other
operator|!=
name|STV_DEFAULT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Symbols converted to local by version script can not be 	 * overridden. 	 */
if|if
condition|(
name|ld_symver_search_version_script
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* TODO: other cases. */
comment|/* Otherwise symbol can be overridden. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a symbol is defined in regular object.  */
end_comment

begin_function
name|int
name|ld_symbols_in_regular
parameter_list|(
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
return|return
operator|(
name|lsb
operator|->
name|lsb_input
operator|==
name|NULL
operator|||
name|lsb
operator|->
name|lsb_input
operator|->
name|li_type
operator|!=
name|LIT_DSO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a symbol is defined in a DSO.  */
end_comment

begin_function
name|int
name|ld_symbols_in_dso
parameter_list|(
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
return|return
operator|(
name|lsb
operator|->
name|lsb_input
operator|!=
name|NULL
operator|&&
name|lsb
operator|->
name|lsb_input
operator|->
name|li_type
operator|==
name|LIT_DSO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_symbol
modifier|*
name|_alloc_symbol
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_symbol
modifier|*
name|_find_symbol
parameter_list|(
name|struct
name|ld_symbol
modifier|*
name|tbl
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|s
decl_stmt|;
name|HASH_FIND_STR
argument_list|(
name|tbl
argument_list|,
name|name
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|_prefer_new
parameter_list|()
value|do {			\ 	_resolve_symbol(_lsb, lsb);		\ 	_remove_symbol(ld->ld_sym, _lsb);	\ 	_add_symbol(ld->ld_sym, lsb);		\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|_prefer_old
parameter_list|()
value|_resolve_symbol(lsb, _lsb)
end_define

begin_undef
undef|#
directive|undef
name|max
end_undef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_function
specifier|static
name|void
name|_resolve_and_add_symbol
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|_lsb
decl_stmt|;
name|struct
name|ld_symbol_defver
modifier|*
name|dv
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|sn
decl_stmt|;
comment|/* "long" name is a symbol name plus a symbol version string. */
name|name
operator|=
name|lsb
operator|->
name|lsb_longname
expr_stmt|;
comment|/* "sn" stores the bare symbol name. */
name|sn
operator|=
name|lsb
operator|->
name|lsb_name
expr_stmt|;
comment|/* 	 * Search in the symbol table for the symbol with the same name and 	 * same version. 	 */
if|if
condition|(
operator|(
name|_lsb
operator|=
name|_find_symbol
argument_list|(
name|ld
operator|->
name|ld_sym
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
goto|goto
name|found
goto|;
comment|/* 	 * If there is a default version recorded for the symbol name: 	 * 	 * 1. If the symbol to resolve doesn't have a version, search the 	 *    symbol with the same name and with a default version. 	 * 	 * 2. If the symbol to resolve has the default version, search the 	 *    symbol with the same name but without a version. 	 */
name|HASH_FIND_STR
argument_list|(
name|ld
operator|->
name|ld_defver
argument_list|,
name|sn
argument_list|,
name|dv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|sn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|_lsb
operator|=
name|_find_symbol
argument_list|(
name|ld
operator|->
name|ld_sym
argument_list|,
name|dv
operator|->
name|dv_longname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
goto|goto
name|found
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|dv
operator|->
name|dv_longname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|_lsb
operator|=
name|_find_symbol
argument_list|(
name|ld
operator|->
name|ld_sym
argument_list|,
name|sn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
goto|goto
name|found
goto|;
block|}
block|}
comment|/* 	 * This is *probably* a new symbol, add it to the symbol table 	 * and proceed. 	 * 	 * Note that if one symbol has a version but another one doesn't, 	 * and they are both undefined, there is still a chance that they are 	 * the same symbol. We will solve that when we see the definition. 	 */
name|_add_symbol
argument_list|(
name|ld
operator|->
name|ld_sym
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
return|return;
name|found
label|:
comment|/* 	 * We found the same symbol in the symbol table. Now we should 	 * decide which symbol to resolve and which symbol to keep. 	 */
comment|/* 	 * Verify both symbol has the same TLS (thread local storage) 	 * characteristics. 	 */
if|if
condition|(
operator|(
name|lsb
operator|->
name|lsb_type
operator|==
name|STT_TLS
operator|||
name|_lsb
operator|->
name|lsb_type
operator|==
name|STT_TLS
operator|)
operator|&&
name|lsb
operator|->
name|lsb_type
operator|!=
name|_lsb
operator|->
name|lsb_type
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"TLS symbol %s is non-TLS in another reference"
argument_list|)
expr_stmt|;
comment|/* 	 * If the symbol to resolve is undefined, we always resolve this 	 * symbol to the symbol that is already in the table, no matter it is 	 * defined or not. 	 */
if|if
condition|(
name|lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_UNDEF
condition|)
block|{
name|_prefer_old
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the symbol to resolve is a common symbol and is defined in 	 * a regular object: 	 * 	 * 1. If the symbol in the table is undefined, we prefer the 	 *    common symbol. 	 * 	 * 2. If both symbols are common symbols, we prefer the symbol 	 *    already in the table. However if the symbol in the table 	 *    is found in a DSO, we prefer the common symbol in regular 	 *    object. The size of the symbol we decided to keep is set to 	 *    the larger one of the two. 	 * 	 * 3. If the symbol in the table is defined, we prefer the 	 *    defined symbol. However if the defined symbol is found 	 *    in a DSO, we prefer the common symbol in regular object. 	 * 	 */
if|if
condition|(
name|lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_COMMON
operator|&&
name|ld_symbols_in_regular
argument_list|(
name|lsb
argument_list|)
condition|)
block|{
if|if
condition|(
name|_lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_UNDEF
condition|)
name|_prefer_new
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|_lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_COMMON
condition|)
block|{
if|if
condition|(
name|ld_symbols_in_dso
argument_list|(
name|_lsb
argument_list|)
condition|)
block|{
name|_prefer_new
argument_list|()
expr_stmt|;
name|lsb
operator|->
name|lsb_size
operator|=
name|max
argument_list|(
name|lsb
operator|->
name|lsb_size
argument_list|,
name|_lsb
operator|->
name|lsb_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_prefer_old
argument_list|()
expr_stmt|;
name|_lsb
operator|->
name|lsb_size
operator|=
name|max
argument_list|(
name|lsb
operator|->
name|lsb_size
argument_list|,
name|_lsb
operator|->
name|lsb_size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ld_symbols_in_dso
argument_list|(
name|_lsb
argument_list|)
condition|)
name|_prefer_new
argument_list|()
expr_stmt|;
else|else
name|_prefer_old
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * If the symbol to resolve is a common symbol and is defined in 	 * a DSO: 	 * 	 * 1. If the symbol in the table is undefined, we prefer the common 	 *    symbol. 	 * 	 * 2. If the symbol in the table is also a common symbol, we prefer 	 *    the one in the table. The size of the symbol we decided to 	 *    keep is set to the larger one of the two. 	 * 	 * 3. If the symbol in the table is defined, we prefer the defined 	 *    symbol. 	 */
if|if
condition|(
name|lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_COMMON
operator|&&
name|ld_symbols_in_dso
argument_list|(
name|lsb
argument_list|)
condition|)
block|{
if|if
condition|(
name|_lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_UNDEF
condition|)
name|_prefer_new
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|_lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_COMMON
condition|)
block|{
name|_prefer_old
argument_list|()
expr_stmt|;
name|_lsb
operator|->
name|lsb_size
operator|=
name|max
argument_list|(
name|lsb
operator|->
name|lsb_size
argument_list|,
name|_lsb
operator|->
name|lsb_size
argument_list|)
expr_stmt|;
block|}
else|else
name|_prefer_old
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * Now we know the symbol to resolve is a defined symbol. If it is 	 * defined in a regular object: 	 * 	 * 1. If the symbol in the table is undefined, we prefer the defined 	 *    symbol. (no doubt!) 	 * 	 * 2. If the symbol in the table is a common symbol, we perfer the 	 *    defined symbol. 	 * 	 * 3. If the symbol in the table is also a defined symbol, we need to 	 * consider: 	 * 	 * a) If the symbol in the table is also defined in a regular object, 	 *    and both symbols are strong, we have a multi-definition error. 	 *    If only one of them is strong, we pick that one. If both of them 	 *    are weak, we pick the one that is already in the table. (fisrt 	 *    seen). Another case is that if one of them is a "provide" symbol, 	 *    we prefer the one that is not "provide". 	 * 	 * b) If the symbol in the table is defined in a DSO, we pick the one 	 *    defined in the regular object. (no matter weak or strong!) 	 */
if|if
condition|(
name|ld_symbols_in_regular
argument_list|(
name|lsb
argument_list|)
condition|)
block|{
if|if
condition|(
name|_lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_UNDEF
operator|||
name|_lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_COMMON
condition|)
name|_prefer_new
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ld_symbols_in_regular
argument_list|(
name|_lsb
argument_list|)
condition|)
block|{
if|if
condition|(
name|_lsb
operator|->
name|lsb_provide
operator|&&
operator|!
name|lsb
operator|->
name|lsb_provide
condition|)
name|_prefer_new
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|==
name|_lsb
operator|->
name|lsb_bind
condition|)
block|{
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|==
name|STB_WEAK
condition|)
name|_prefer_old
argument_list|()
expr_stmt|;
else|else
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"multiple "
literal|"definition of symbol %s"
argument_list|,
name|lsb
operator|->
name|lsb_longname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|==
name|STB_WEAK
condition|)
name|_prefer_old
argument_list|()
expr_stmt|;
else|else
name|_prefer_new
argument_list|()
expr_stmt|;
block|}
else|else
name|_prefer_new
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Last case, the symbol to resolve is a defined symbol in a DSO. 	 * 	 * 1. If the symbol in the table is undefined, we prefer the defined 	 *    symbol. (no doubt!) 	 * 	 * 2. If the symbol in the table is a common symbol: if it is in a 	 *    regular object and the defined DSO symbol is a function, we 	 *    prefer the common symbol. For all the other cases, we prefer 	 *    the defined symbol in the DSO. 	 * 	 * 3. If the symbol in the table is a defined symbol. We always pick 	 *    the symbol already in the table. (no matter it's in regular 	 *    object or DSO, strong or weak) 	 */
if|if
condition|(
name|_lsb
operator|->
name|lsb_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|_lsb
operator|->
name|lsb_shndx
operator|!=
name|SHN_COMMON
condition|)
name|_prefer_old
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|_lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_COMMON
operator|&&
name|ld_symbols_in_regular
argument_list|(
name|_lsb
argument_list|)
operator|&&
name|lsb
operator|->
name|lsb_type
operator|==
name|STT_FUNC
condition|)
name|_prefer_old
argument_list|()
expr_stmt|;
else|else
block|{
name|_prefer_new
argument_list|()
expr_stmt|;
comment|/* 		 * Now we added a defined symbol from DSO. Here we should 		 * check if the DSO symbol has a default symbol version. 		 * If so, we search the symbol table for the symbol with the 		 * same name but without a symbol version. If there is one, 		 * we resolve the found symbol to this newly added DSO symbol 		 * and remove the found symbol from the table. 		 */
name|HASH_FIND_STR
argument_list|(
name|ld
operator|->
name|ld_defver
argument_list|,
name|sn
argument_list|,
name|dv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|_lsb
operator|=
name|_find_symbol
argument_list|(
name|ld
operator|->
name|ld_sym
argument_list|,
name|sn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|_resolve_symbol
argument_list|(
name|_lsb
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|_remove_symbol
argument_list|(
name|ld
operator|->
name|ld_sym
argument_list|,
name|_lsb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_add_elf_symbol
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf
modifier|*
name|e
parameter_list|,
name|GElf_Sym
modifier|*
name|sym
parameter_list|,
name|size_t
name|strndx
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
name|struct
name|ld_symbol_defver
modifier|*
name|dv
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len
decl_stmt|,
name|ndx
decl_stmt|;
name|unsigned
name|char
name|st_bind
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|elf_strptr
argument_list|(
name|e
argument_list|,
name|strndx
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * First check if the section this symbol refers to is belong 	 * to a section group that has been removed. 	 */
name|st_bind
operator|=
name|GELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_COMMON
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_ABS
operator|&&
name|sym
operator|->
name|st_shndx
operator|<
name|li
operator|->
name|li_shnum
operator|-
literal|1
operator|&&
name|li
operator|->
name|li_is
index|[
name|sym
operator|->
name|st_shndx
index|]
operator|.
name|is_discard
condition|)
block|{
name|st_bind
operator|=
name|GELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_bind
operator|==
name|STB_GLOBAL
operator|||
name|st_bind
operator|==
name|STB_WEAK
condition|)
block|{
comment|/* 			 * For symbol with STB_GLOBAL or STB_WEAK binding, 			 * we convert it to an undefined symbol. 			 */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Local symbols are discarded, if the section they 			 * refer to are removed. 			 */
return|return;
block|}
block|}
name|lsb
operator|=
name|_alloc_symbol
argument_list|(
name|ld
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|->
name|lsb_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|lsb
operator|->
name|lsb_size
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
name|lsb
operator|->
name|lsb_bind
operator|=
name|GELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_type
operator|=
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_other
operator|=
name|sym
operator|->
name|st_other
expr_stmt|;
name|lsb
operator|->
name|lsb_shndx
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|lsb
operator|->
name|lsb_index
operator|=
name|i
expr_stmt|;
name|lsb
operator|->
name|lsb_input
operator|=
name|li
expr_stmt|;
name|lsb
operator|->
name|lsb_ver
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lsb
operator|->
name|lsb_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|lsb
operator|->
name|lsb_shndx
operator|!=
name|SHN_ABS
condition|)
block|{
if|if
condition|(
name|lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_COMMON
condition|)
name|lsb
operator|->
name|lsb_is
operator|=
operator|&
name|li
operator|->
name|li_is
index|[
name|li
operator|->
name|li_shnum
operator|-
literal|1
index|]
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|lsb
operator|->
name|lsb_shndx
operator|<
name|li
operator|->
name|li_shnum
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_is
operator|=
operator|&
name|li
operator|->
name|li_is
index|[
name|lsb
operator|->
name|lsb_shndx
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|li
operator|->
name|li_type
operator|==
name|LIT_DSO
condition|)
name|lsb
operator|->
name|lsb_ref_dso
operator|=
literal|1
expr_stmt|;
else|else
name|lsb
operator|->
name|lsb_ref_ndso
operator|=
literal|1
expr_stmt|;
comment|/* Find out symbol version info. */
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|li_file
operator|->
name|lf_type
operator|==
name|LFT_DSO
operator|&&
name|li
operator|->
name|li_vername
operator|!=
name|NULL
operator|&&
name|li
operator|->
name|li_versym
operator|!=
name|NULL
operator|&&
operator|(
name|size_t
operator|)
name|i
operator|<
name|li
operator|->
name|li_versym_sz
condition|)
block|{
name|j
operator|=
name|li
operator|->
name|li_versym
index|[
name|i
index|]
expr_stmt|;
name|ndx
operator|=
name|j
operator|&
operator|~
literal|0x8000
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|ndx
operator|<
name|li
operator|->
name|li_vername_sz
condition|)
block|{
name|lsb
operator|->
name|lsb_ver
operator|=
name|li
operator|->
name|li_vername
index|[
name|ndx
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|printf("symbol: %s ver: %s\n", lsb->lsb_name, 			    lsb->lsb_ver);
endif|#
directive|endif
if|if
condition|(
name|j
operator|>=
literal|2
operator|&&
operator|(
name|j
operator|&
literal|0x8000
operator|)
operator|==
literal|0
operator|&&
name|lsb
operator|->
name|lsb_shndx
operator|!=
name|SHN_UNDEF
condition|)
name|lsb
operator|->
name|lsb_default
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Build "long" symbol name which is used for hash key. */
if|if
condition|(
name|lsb
operator|->
name|lsb_ver
operator|==
name|NULL
operator|||
name|j
operator|<
literal|2
condition|)
block|{
name|lsb
operator|->
name|lsb_longname
operator|=
name|strdup
argument_list|(
name|lsb
operator|->
name|lsb_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsb
operator|->
name|lsb_longname
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|lsb
operator|->
name|lsb_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|lsb
operator|->
name|lsb_ver
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|lsb
operator|->
name|lsb_longname
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|lsb
operator|->
name|lsb_longname
argument_list|,
name|len
argument_list|,
literal|"%s@%s"
argument_list|,
name|lsb
operator|->
name|lsb_name
argument_list|,
name|lsb
operator|->
name|lsb_ver
argument_list|)
expr_stmt|;
block|}
comment|/* Keep track of default versions. */
if|if
condition|(
name|lsb
operator|->
name|lsb_default
condition|)
block|{
if|if
condition|(
operator|(
name|dv
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dv
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|dv
operator|->
name|dv_name
operator|=
name|lsb
operator|->
name|lsb_name
expr_stmt|;
name|dv
operator|->
name|dv_longname
operator|=
name|lsb
operator|->
name|lsb_longname
expr_stmt|;
name|dv
operator|->
name|dv_ver
operator|=
name|lsb
operator|->
name|lsb_ver
expr_stmt|;
name|HASH_ADD_KEYPTR
argument_list|(
name|hh
argument_list|,
name|ld
operator|->
name|ld_defver
argument_list|,
name|dv
operator|->
name|dv_name
argument_list|,
name|strlen
argument_list|(
name|dv
operator|->
name|dv_name
argument_list|)
argument_list|,
name|dv
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert symbol to input object internal symbol list and 	 * perform symbol resolving. 	 */
name|ld_input_add_symbol
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|!=
name|STB_LOCAL
condition|)
name|_resolve_and_add_symbol
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|_archive_member_extracted
parameter_list|(
name|struct
name|ld_archive
modifier|*
name|la
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|struct
name|ld_archive_member
modifier|*
name|_lam
decl_stmt|;
name|HASH_FIND
argument_list|(
name|hh
argument_list|,
name|la
operator|->
name|la_m
argument_list|,
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|,
name|_lam
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lam
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_archive_member
modifier|*
name|_extract_archive_member
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_file
modifier|*
name|lf
parameter_list|,
name|struct
name|ld_archive
modifier|*
name|la
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
name|Elf
modifier|*
name|e
decl_stmt|;
name|Elf_Arhdr
modifier|*
name|arhdr
decl_stmt|;
name|struct
name|ld_archive_member
modifier|*
name|lam
decl_stmt|;
name|struct
name|ld_input
modifier|*
name|li
decl_stmt|;
if|if
condition|(
name|elf_rand
argument_list|(
name|lf
operator|->
name|lf_elf
argument_list|,
name|off
argument_list|)
operator|==
literal|0
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: elf_rand failed: %s"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|elf_begin
argument_list|(
operator|-
literal|1
argument_list|,
name|ELF_C_READ
argument_list|,
name|lf
operator|->
name|lf_elf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: elf_begin failed: %s"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arhdr
operator|=
name|elf_getarhdr
argument_list|(
name|e
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: elf_getarhdr failed: %s"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep record of extracted members. */
if|if
condition|(
operator|(
name|lam
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lam
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|lam
operator|->
name|lam_ar_name
operator|=
name|strdup
argument_list|(
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lam
operator|->
name|lam_ar_name
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|lam
operator|->
name|lam_name
operator|=
name|strdup
argument_list|(
name|arhdr
operator|->
name|ar_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lam
operator|->
name|lam_name
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|lam
operator|->
name|lam_off
operator|=
name|off
expr_stmt|;
name|HASH_ADD
argument_list|(
name|hh
argument_list|,
name|la
operator|->
name|la_m
argument_list|,
name|lam_off
argument_list|,
sizeof|sizeof
argument_list|(
name|lam
operator|->
name|lam_off
argument_list|)
argument_list|,
name|lam
argument_list|)
expr_stmt|;
comment|/* Allocate input object for this member. */
name|li
operator|=
name|ld_input_alloc
argument_list|(
name|ld
argument_list|,
name|lf
argument_list|,
name|lam
operator|->
name|lam_name
argument_list|)
expr_stmt|;
name|li
operator|->
name|li_lam
operator|=
name|lam
expr_stmt|;
name|lam
operator|->
name|lam_input
operator|=
name|li
expr_stmt|;
comment|/* Load the symbols of this member. */
name|_load_elf_symbols
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|lam
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_print_extracted_member
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_archive_member
modifier|*
name|lam
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|char
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
if|if
condition|(
operator|!
name|ls
operator|->
name|ls_archive_mb_header
condition|)
block|{
name|printf
argument_list|(
literal|"Extracted archive members:\n\n"
argument_list|)
expr_stmt|;
name|ls
operator|->
name|ls_archive_mb_header
operator|=
literal|1
expr_stmt|;
block|}
name|c1
operator|=
name|ld_input_get_fullname
argument_list|(
name|ld
argument_list|,
name|lam
operator|->
name|lam_input
argument_list|)
expr_stmt|;
name|c2
operator|=
name|ld_input_get_fullname
argument_list|(
name|ld
argument_list|,
name|lsb
operator|->
name|lsb_input
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-30s"
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|c1
argument_list|)
operator|>=
literal|30
condition|)
block|{
name|printf
argument_list|(
literal|"\n%-30s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s (%s)\n"
argument_list|,
name|c2
argument_list|,
name|lsb
operator|->
name|lsb_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_load_archive_symbols
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_file
modifier|*
name|lf
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_archive
modifier|*
name|la
decl_stmt|;
name|struct
name|ld_archive_member
modifier|*
name|lam
decl_stmt|;
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
name|Elf_Arsym
modifier|*
name|as
decl_stmt|;
name|size_t
name|c
decl_stmt|;
name|int
name|extracted
decl_stmt|,
name|i
decl_stmt|;
name|assert
argument_list|(
name|lf
operator|!=
name|NULL
operator|&&
name|lf
operator|->
name|lf_type
operator|==
name|LFT_ARCHIVE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lf
operator|->
name|lf_ar
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
name|la
operator|=
name|lf
operator|->
name|lf_ar
expr_stmt|;
if|if
condition|(
operator|(
name|as
operator|=
name|elf_getarsym
argument_list|(
name|lf
operator|->
name|lf_elf
argument_list|,
operator|&
name|c
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: elf_getarsym failed: %s"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|extracted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|as
index|[
name|i
index|]
operator|.
name|as_name
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|_archive_member_extracted
argument_list|(
name|la
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|as_off
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|lsb
operator|=
name|_find_symbol
argument_list|(
name|ld
operator|->
name|ld_sym
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|as_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|lam
operator|=
name|_extract_archive_member
argument_list|(
name|ld
argument_list|,
name|lf
argument_list|,
name|la
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|as_off
argument_list|)
expr_stmt|;
name|extracted
operator|=
literal|1
expr_stmt|;
name|ls
operator|->
name|ls_extracted
index|[
name|ls
operator|->
name|ls_group_level
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_print_linkmap
condition|)
name|_print_extracted_member
argument_list|(
name|ld
argument_list|,
name|lam
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|extracted
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|_load_elf_symbols
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn_sym
decl_stmt|,
modifier|*
name|scn_dynamic
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn_versym
decl_stmt|,
modifier|*
name|scn_verneed
decl_stmt|,
modifier|*
name|scn_verdef
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|GElf_Shdr
name|shdr
decl_stmt|;
name|size_t
name|dyn_strndx
decl_stmt|,
name|strndx
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|;
comment|/* Load section list from input object. */
name|ld_input_init_sections
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|strndx
operator|=
name|dyn_strndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|scn_sym
operator|=
name|scn_versym
operator|=
name|scn_verneed
operator|=
name|scn_verdef
operator|=
name|scn_dynamic
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint64_t
operator|)
name|i
operator|<
name|li
operator|->
name|li_shnum
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|is
operator|=
operator|&
name|li
operator|->
name|li_is
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|li_type
operator|==
name|LIT_DSO
condition|)
block|{
if|if
condition|(
name|is
operator|->
name|is_type
operator|==
name|SHT_DYNSYM
condition|)
block|{
name|scn_sym
operator|=
name|elf_getscn
argument_list|(
name|e
argument_list|,
name|is
operator|->
name|is_index
argument_list|)
expr_stmt|;
name|strndx
operator|=
name|is
operator|->
name|is_link
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is
operator|->
name|is_type
operator|==
name|SHT_SUNW_versym
condition|)
name|scn_versym
operator|=
name|elf_getscn
argument_list|(
name|e
argument_list|,
name|is
operator|->
name|is_index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is
operator|->
name|is_type
operator|==
name|SHT_SUNW_verneed
condition|)
name|scn_verneed
operator|=
name|elf_getscn
argument_list|(
name|e
argument_list|,
name|is
operator|->
name|is_index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is
operator|->
name|is_type
operator|==
name|SHT_SUNW_verdef
condition|)
name|scn_verdef
operator|=
name|elf_getscn
argument_list|(
name|e
argument_list|,
name|is
operator|->
name|is_index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is
operator|->
name|is_type
operator|==
name|SHT_DYNAMIC
condition|)
block|{
name|scn_dynamic
operator|=
name|elf_getscn
argument_list|(
name|e
argument_list|,
name|is
operator|->
name|is_index
argument_list|)
expr_stmt|;
name|dyn_strndx
operator|=
name|is
operator|->
name|is_link
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|is
operator|->
name|is_type
operator|==
name|SHT_SYMTAB
condition|)
block|{
name|scn_sym
operator|=
name|elf_getscn
argument_list|(
name|e
argument_list|,
name|is
operator|->
name|is_index
argument_list|)
expr_stmt|;
name|strndx
operator|=
name|is
operator|->
name|is_link
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|scn_sym
operator|==
name|NULL
operator|||
name|strndx
operator|==
name|SHN_UNDEF
condition|)
return|return;
name|ld_symver_load_symbol_version_info
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
name|e
argument_list|,
name|scn_versym
argument_list|,
name|scn_verneed
argument_list|,
name|scn_verdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|scn_dynamic
operator|!=
name|NULL
condition|)
name|ld_dynamic_load_dso_dynamic
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
name|e
argument_list|,
name|scn_dynamic
argument_list|,
name|dyn_strndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn_sym
argument_list|,
operator|&
name|shdr
argument_list|)
operator|!=
operator|&
name|shdr
condition|)
block|{
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"%s: gelf_getshdr failed: %s"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|scn_sym
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"%s: elf_getdata failed: %s"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Empty symbol table section? */
return|return;
block|}
name|li
operator|->
name|li_symnum
operator|=
name|d
operator|->
name|d_size
operator|/
name|shdr
operator|.
name|sh_entsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint64_t
operator|)
name|i
operator|<
name|li
operator|->
name|li_symnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getsym
argument_list|(
name|d
argument_list|,
name|i
argument_list|,
operator|&
name|sym
argument_list|)
operator|!=
operator|&
name|sym
condition|)
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"%s: gelf_getsym failed: %s"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|_add_elf_symbol
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
name|e
argument_list|,
operator|&
name|sym
argument_list|,
name|strndx
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_load_symbols
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_file
modifier|*
name|lf
parameter_list|)
block|{
if|if
condition|(
name|lf
operator|->
name|lf_type
operator|==
name|LFT_ARCHIVE
condition|)
name|_load_archive_symbols
argument_list|(
name|ld
argument_list|,
name|lf
argument_list|)
expr_stmt|;
else|else
block|{
name|lf
operator|->
name|lf_input
operator|=
name|ld_input_alloc
argument_list|(
name|ld
argument_list|,
name|lf
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
name|_load_elf_symbols
argument_list|(
name|ld
argument_list|,
name|lf
operator|->
name|lf_input
argument_list|,
name|lf
operator|->
name|lf_elf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_unload_symbols
parameter_list|(
name|struct
name|ld_input
modifier|*
name|li
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|li
operator|->
name|li_symindex
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|uint64_t
operator|)
name|i
operator|<
name|li
operator|->
name|li_symnum
condition|;
name|i
operator|++
control|)
name|_free_symbol
argument_list|(
name|li
operator|->
name|li_symindex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_free_symbol
parameter_list|(
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
if|if
condition|(
name|lsb
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|lsb
operator|->
name|lsb_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lsb
operator|->
name|lsb_longname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lsb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_update_symbol
parameter_list|(
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
if|if
condition|(
name|lsb
operator|->
name|lsb_preset_os
operator|!=
name|NULL
condition|)
block|{
name|lsb
operator|->
name|lsb_value
operator|=
name|lsb
operator|->
name|lsb_preset_os
operator|->
name|os_addr
expr_stmt|;
name|lsb
operator|->
name|lsb_shndx
operator|=
name|elf_ndxscn
argument_list|(
name|lsb
operator|->
name|lsb_preset_os
operator|->
name|os_scn
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lsb
operator|->
name|lsb_shndx
operator|==
name|SHN_ABS
condition|)
return|return;
if|if
condition|(
name|lsb
operator|->
name|lsb_input
operator|!=
name|NULL
condition|)
block|{
name|is
operator|=
name|lsb
operator|->
name|lsb_is
expr_stmt|;
if|if
condition|(
name|is
operator|==
name|NULL
operator|||
operator|(
name|os
operator|=
name|is
operator|->
name|is_output
operator|)
operator|==
name|NULL
condition|)
return|return;
name|lsb
operator|->
name|lsb_value
operator|+=
name|os
operator|->
name|os_addr
operator|+
name|is
operator|->
name|is_reloff
expr_stmt|;
name|lsb
operator|->
name|lsb_shndx
operator|=
name|elf_ndxscn
argument_list|(
name|os
operator|->
name|os_scn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|ld_symbol_table
modifier|*
name|_alloc_symbol_table
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_symbol_table
modifier|*
name|symtab
decl_stmt|;
if|if
condition|(
operator|(
name|symtab
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ld
operator|->
name|ld_symtab
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
return|return
operator|(
name|symtab
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_add_to_dynsym_table
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|assert
argument_list|(
name|ld
operator|->
name|ld_dynsym
operator|!=
name|NULL
operator|&&
name|ld
operator|->
name|ld_dynstr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_dyn_symbols
operator|==
name|NULL
condition|)
block|{
name|ld
operator|->
name|ld_dyn_symbols
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ld
operator|->
name|ld_dyn_symbols
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_dyn_symbols
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|ld
operator|->
name|ld_dyn_symbols
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
name|ld
operator|->
name|ld_dyn_symbols
argument_list|,
name|lsb
argument_list|,
name|lsb_dyn
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_nameindex
operator|=
name|ld_strtab_insert_no_suffix
argument_list|(
name|ld
argument_list|,
name|ld
operator|->
name|ld_dynstr
argument_list|,
name|lsb
operator|->
name|lsb_name
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_dyn_index
operator|=
name|ld
operator|->
name|ld_dynsym
operator|->
name|sy_size
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_write_to_dynsym_table
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_symbol_table
modifier|*
name|symtab
decl_stmt|;
name|Elf32_Sym
modifier|*
name|s32
decl_stmt|;
name|Elf64_Sym
modifier|*
name|s64
decl_stmt|;
name|size_t
name|es
decl_stmt|;
name|assert
argument_list|(
name|lsb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ld
operator|->
name|ld_dynsym
operator|!=
name|NULL
operator|&&
name|ld
operator|->
name|ld_dynstr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|ld
operator|->
name|ld_dynsym
expr_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|es
operator|=
operator|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
expr_stmt|;
comment|/* Allocate buffer for the dynsym table. */
if|if
condition|(
name|symtab
operator|->
name|sy_buf
operator|==
name|NULL
condition|)
block|{
name|symtab
operator|->
name|sy_buf
operator|=
name|malloc
argument_list|(
name|symtab
operator|->
name|sy_size
operator|*
name|es
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|sy_write_pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|)
block|{
name|s32
operator|=
name|symtab
operator|->
name|sy_buf
expr_stmt|;
name|s32
operator|+=
name|symtab
operator|->
name|sy_write_pos
expr_stmt|;
name|s32
operator|->
name|st_name
operator|=
name|lsb
operator|->
name|lsb_nameindex
expr_stmt|;
name|s32
operator|->
name|st_info
operator|=
name|ELF32_ST_INFO
argument_list|(
name|lsb
operator|->
name|lsb_bind
argument_list|,
name|lsb
operator|->
name|lsb_type
argument_list|)
expr_stmt|;
name|s32
operator|->
name|st_other
operator|=
name|lsb
operator|->
name|lsb_other
expr_stmt|;
name|s32
operator|->
name|st_shndx
operator|=
name|lsb
operator|->
name|lsb_shndx
expr_stmt|;
name|s32
operator|->
name|st_value
operator|=
name|lsb
operator|->
name|lsb_value
expr_stmt|;
name|s32
operator|->
name|st_size
operator|=
name|lsb
operator|->
name|lsb_size
expr_stmt|;
block|}
else|else
block|{
name|s64
operator|=
name|symtab
operator|->
name|sy_buf
expr_stmt|;
name|s64
operator|+=
name|symtab
operator|->
name|sy_write_pos
expr_stmt|;
name|s64
operator|->
name|st_name
operator|=
name|lsb
operator|->
name|lsb_nameindex
expr_stmt|;
name|s64
operator|->
name|st_info
operator|=
name|ELF64_ST_INFO
argument_list|(
name|lsb
operator|->
name|lsb_bind
argument_list|,
name|lsb
operator|->
name|lsb_type
argument_list|)
expr_stmt|;
name|s64
operator|->
name|st_other
operator|=
name|lsb
operator|->
name|lsb_other
expr_stmt|;
name|s64
operator|->
name|st_shndx
operator|=
name|lsb
operator|->
name|lsb_shndx
expr_stmt|;
name|s64
operator|->
name|st_value
operator|=
name|lsb
operator|->
name|lsb_value
expr_stmt|;
name|s64
operator|->
name|st_size
operator|=
name|lsb
operator|->
name|lsb_size
expr_stmt|;
block|}
comment|/* Remember the index for the first non-local symbol. */
if|if
condition|(
name|symtab
operator|->
name|sy_first_nonlocal
operator|==
literal|0
operator|&&
name|lsb
operator|->
name|lsb_bind
operator|!=
name|STB_LOCAL
condition|)
name|symtab
operator|->
name|sy_first_nonlocal
operator|=
name|symtab
operator|->
name|sy_write_pos
expr_stmt|;
name|symtab
operator|->
name|sy_write_pos
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_add_to_symbol_table
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_symbol_table
modifier|*
name|symtab
decl_stmt|;
name|struct
name|ld_strtab
modifier|*
name|strtab
decl_stmt|;
name|Elf32_Sym
modifier|*
name|s32
decl_stmt|;
name|Elf64_Sym
modifier|*
name|s64
decl_stmt|;
name|size_t
name|es
decl_stmt|;
name|assert
argument_list|(
name|lsb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ld
operator|->
name|ld_symtab
operator|!=
name|NULL
operator|&&
name|ld
operator|->
name|ld_strtab
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|ld
operator|->
name|ld_symtab
expr_stmt|;
name|strtab
operator|=
name|ld
operator|->
name|ld_strtab
expr_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|es
operator|=
operator|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
expr_stmt|;
comment|/* Allocate/Reallocate buffer for the symbol table. */
if|if
condition|(
name|symtab
operator|->
name|sy_buf
operator|==
name|NULL
condition|)
block|{
name|symtab
operator|->
name|sy_size
operator|=
literal|0
expr_stmt|;
name|symtab
operator|->
name|sy_cap
operator|=
name|_INIT_SYMTAB_SIZE
expr_stmt|;
name|symtab
operator|->
name|sy_buf
operator|=
name|malloc
argument_list|(
name|symtab
operator|->
name|sy_cap
operator|*
name|es
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|->
name|sy_buf
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symtab
operator|->
name|sy_size
operator|>=
name|symtab
operator|->
name|sy_cap
condition|)
block|{
name|symtab
operator|->
name|sy_cap
operator|*=
literal|2
expr_stmt|;
name|symtab
operator|->
name|sy_buf
operator|=
name|realloc
argument_list|(
name|symtab
operator|->
name|sy_buf
argument_list|,
name|symtab
operator|->
name|sy_cap
operator|*
name|es
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|->
name|sy_buf
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"relloc"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert the symbol into the symbol table and the symbol name to 	 * the assoicated name string table. 	 */
name|lsb
operator|->
name|lsb_nameindex
operator|=
name|ld_strtab_insert_no_suffix
argument_list|(
name|ld
argument_list|,
name|strtab
argument_list|,
name|lsb
operator|->
name|lsb_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|)
block|{
name|s32
operator|=
name|symtab
operator|->
name|sy_buf
expr_stmt|;
name|s32
operator|+=
name|symtab
operator|->
name|sy_size
expr_stmt|;
name|s32
operator|->
name|st_name
operator|=
name|lsb
operator|->
name|lsb_nameindex
expr_stmt|;
name|s32
operator|->
name|st_info
operator|=
name|ELF32_ST_INFO
argument_list|(
name|lsb
operator|->
name|lsb_bind
argument_list|,
name|lsb
operator|->
name|lsb_type
argument_list|)
expr_stmt|;
name|s32
operator|->
name|st_other
operator|=
name|lsb
operator|->
name|lsb_other
expr_stmt|;
name|s32
operator|->
name|st_shndx
operator|=
name|lsb
operator|->
name|lsb_shndx
expr_stmt|;
name|s32
operator|->
name|st_value
operator|=
name|lsb
operator|->
name|lsb_value
expr_stmt|;
name|s32
operator|->
name|st_size
operator|=
name|lsb
operator|->
name|lsb_size
expr_stmt|;
block|}
else|else
block|{
name|s64
operator|=
name|symtab
operator|->
name|sy_buf
expr_stmt|;
name|s64
operator|+=
name|symtab
operator|->
name|sy_size
expr_stmt|;
name|s64
operator|->
name|st_name
operator|=
name|lsb
operator|->
name|lsb_nameindex
expr_stmt|;
name|s64
operator|->
name|st_info
operator|=
name|ELF64_ST_INFO
argument_list|(
name|lsb
operator|->
name|lsb_bind
argument_list|,
name|lsb
operator|->
name|lsb_type
argument_list|)
expr_stmt|;
name|s64
operator|->
name|st_other
operator|=
name|lsb
operator|->
name|lsb_other
expr_stmt|;
name|s64
operator|->
name|st_shndx
operator|=
name|lsb
operator|->
name|lsb_shndx
expr_stmt|;
name|s64
operator|->
name|st_value
operator|=
name|lsb
operator|->
name|lsb_value
expr_stmt|;
name|s64
operator|->
name|st_size
operator|=
name|lsb
operator|->
name|lsb_size
expr_stmt|;
block|}
comment|/* Remember the index for the first non-local symbol. */
if|if
condition|(
name|symtab
operator|->
name|sy_first_nonlocal
operator|==
literal|0
operator|&&
name|lsb
operator|->
name|lsb_bind
operator|!=
name|STB_LOCAL
condition|)
name|symtab
operator|->
name|sy_first_nonlocal
operator|=
name|symtab
operator|->
name|sy_size
expr_stmt|;
name|lsb
operator|->
name|lsb_out_index
operator|=
name|symtab
operator|->
name|sy_size
expr_stmt|;
name|symtab
operator|->
name|sy_size
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_free_symbol_table
parameter_list|(
name|struct
name|ld_symbol_table
modifier|*
name|symtab
parameter_list|)
block|{
if|if
condition|(
name|symtab
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|symtab
operator|->
name|sy_buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

