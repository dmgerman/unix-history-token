begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ld_arch.h"
end_include

begin_include
include|#
directive|include
file|"ld_ehframe.h"
end_include

begin_include
include|#
directive|include
file|"ld_input.h"
end_include

begin_include
include|#
directive|include
file|"ld_output.h"
end_include

begin_include
include|#
directive|include
file|"ld_reloc.h"
end_include

begin_include
include|#
directive|include
file|"ld_utils.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: ld_ehframe.c 2964 2013-09-10 02:46:06Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ld_ehframe_cie
block|{
name|uint64_t
name|cie_off
decl_stmt|;
comment|/* offset in section */
name|uint64_t
name|cie_off_orig
decl_stmt|;
comment|/* orignial offset (before optimze) */
name|uint64_t
name|cie_size
decl_stmt|;
comment|/* CIE size (include length field) */
name|uint8_t
modifier|*
name|cie_content
decl_stmt|;
comment|/* CIE content */
name|uint8_t
name|cie_fde_encode
decl_stmt|;
comment|/* FDE PC start/range encode. */
name|struct
name|ld_ehframe_cie
modifier|*
name|cie_dup
decl_stmt|;
comment|/* duplicate entry */
name|STAILQ_ENTRY
argument_list|(
argument|ld_ehframe_cie
argument_list|)
name|cie_next
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|ld_ehframe_cie_head
argument_list|,
name|ld_ehframe_cie
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ld_ehframe_fde
block|{
name|struct
name|ld_ehframe_cie
modifier|*
name|fde_cie
decl_stmt|;
comment|/* associated CIE */
name|uint64_t
name|fde_off
decl_stmt|;
comment|/* offset in section */
name|uint64_t
name|fde_off_pcbegin
decl_stmt|;
comment|/* section offset of "PC Begin" field */
name|int32_t
name|fde_pcrel
decl_stmt|;
comment|/* relative offset to "PC Begin" */
name|int32_t
name|fde_datarel
decl_stmt|;
comment|/* relative offset to FDE entry */
name|STAILQ_ENTRY
argument_list|(
argument|ld_ehframe_fde
argument_list|)
name|fde_next
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|ld_ehframe_fde_head
argument_list|,
name|ld_ehframe_fde
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int64_t
name|_decode_sleb128
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_decode_uleb128
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_process_ehframe_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_read_encoded
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|uint8_t
name|encode
parameter_list|,
name|uint64_t
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_cmp_fde
parameter_list|(
name|struct
name|ld_ehframe_fde
modifier|*
name|a
parameter_list|,
name|struct
name|ld_ehframe_fde
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ld_ehframe_adjust
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|uint64_t
name|length
decl_stmt|,
name|length_size
decl_stmt|,
name|remain
decl_stmt|,
name|adjust
decl_stmt|;
name|uint32_t
name|cie_id
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If the .eh_frame section is unchanged, we don't need to 	 * do much. 	 */
name|assert
argument_list|(
name|is
operator|->
name|is_ehframe
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_shrink
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_ehframe
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* 	 * Otherwise the section is shrinked becase some FDE's are 	 * discarded. We copy the section content to a buffer while 	 * skipping those discarded FDE's. 	 */
if|if
condition|(
operator|(
name|is
operator|->
name|is_ibuf
operator|=
name|malloc
argument_list|(
name|is
operator|->
name|is_size
operator|-
name|is
operator|->
name|is_shrink
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|d
operator|=
name|is
operator|->
name|is_ibuf
expr_stmt|;
name|end
operator|=
name|d
operator|+
name|is
operator|->
name|is_size
operator|-
name|is
operator|->
name|is_shrink
expr_stmt|;
name|p
operator|=
name|is
operator|->
name|is_ehframe
expr_stmt|;
name|adjust
operator|=
literal|0
expr_stmt|;
name|remain
operator|=
name|is
operator|->
name|is_size
expr_stmt|;
while|while
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
name|s
operator|=
name|p
expr_stmt|;
comment|/* Read CIE/FDE length field. */
name|READ_32
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0xffffffff
condition|)
block|{
name|READ_64
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|length_size
operator|=
literal|8
expr_stmt|;
block|}
else|else
name|length_size
operator|=
literal|4
expr_stmt|;
comment|/* Check for terminator */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
comment|/* Read CIE ID/Pointer field. */
name|READ_32
argument_list|(
name|p
argument_list|,
name|cie_id
argument_list|)
expr_stmt|;
comment|/* Clear adjustment if CIE is found. */
if|if
condition|(
name|cie_id
operator|==
literal|0
condition|)
name|adjust
operator|=
literal|0
expr_stmt|;
comment|/* Check for our special mark. */
if|if
condition|(
name|cie_id
operator|!=
literal|0xFFFFFFFF
condition|)
block|{
if|if
condition|(
name|cie_id
operator|!=
literal|0
condition|)
block|{
comment|/* Adjust FDE pointer. */
name|assert
argument_list|(
name|cie_id
operator|>
name|adjust
argument_list|)
expr_stmt|;
name|cie_id
operator|-=
name|adjust
expr_stmt|;
name|WRITE_32
argument_list|(
name|p
argument_list|,
name|cie_id
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|length
operator|+
name|length_size
argument_list|)
expr_stmt|;
name|d
operator|+=
name|length
operator|+
name|length_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Discard FDE and increate adjustment. */
name|adjust
operator|+=
name|length
operator|+
name|length_size
expr_stmt|;
block|}
comment|/* Next entry. */
name|p
operator|+=
name|length
expr_stmt|;
name|remain
operator|-=
name|length
operator|+
name|length_size
expr_stmt|;
block|}
name|is
operator|->
name|is_size
operator|-=
name|is
operator|->
name|is_shrink
expr_stmt|;
name|is
operator|->
name|is_shrink
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|d
operator|==
name|end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|is
operator|->
name|is_ehframe
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_ehframe
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_ehframe_scan
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|struct
name|ld_output_element
modifier|*
name|oe
decl_stmt|;
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|struct
name|ld_input_section_head
modifier|*
name|islist
decl_stmt|;
name|uint64_t
name|ehframe_off
decl_stmt|;
name|char
name|ehframe_name
index|[]
init|=
literal|".eh_frame"
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Search for .eh_frame output section. Nothing needs to be done 	 * if .eh_frame section not exist or is empty. 	 */
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|ehframe_name
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|==
name|NULL
operator|||
name|os
operator|->
name|os_empty
condition|)
return|return;
if|if
condition|(
operator|(
name|ld
operator|->
name|ld_cie
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ld
operator|->
name|ld_cie
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|ld
operator|->
name|ld_cie
argument_list|)
expr_stmt|;
comment|/* 	 * Remove duplicate CIE from each input .eh_frame section. 	 */
name|ehframe_off
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|oe
argument_list|,
argument|&os->os_e
argument_list|,
argument|oe_next
argument_list|)
block|{
comment|/* 		 * XXX We currently do not support .eh_frame section which 		 * contains elements other than OET_INPUT_SECTION_LIST. 		 */
if|if
condition|(
name|oe
operator|->
name|oe_type
operator|!=
name|OET_INPUT_SECTION_LIST
condition|)
continue|continue;
name|islist
operator|=
name|oe
operator|->
name|oe_islist
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|islist
argument_list|,
argument|is_next
argument_list|)
block|{
comment|/* 			 * Process each input .eh_frame section and search 			 * for duplicate CIE's. The input section relative 			 * offset in the output section is resync'ed since 			 * the input section might be shrinked. 			 */
name|is
operator|->
name|is_reloff
operator|=
name|ehframe_off
expr_stmt|;
name|_process_ehframe_section
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|ehframe_off
operator|+=
name|is
operator|->
name|is_size
expr_stmt|;
block|}
block|}
comment|/* Calculate the size of .eh_frame_hdr section. */
if|if
condition|(
name|ld
operator|->
name|ld_ehframe_hdr
condition|)
block|{
name|is
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".eh_frame_hdr"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_fde_num
operator|>
literal|0
condition|)
name|is
operator|->
name|is_size
operator|+=
literal|4
operator|+
name|lo
operator|->
name|lo_fde_num
operator|*
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ld_ehframe_create_hdr
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|ld_input_add_internal_section
argument_list|(
name|ld
argument_list|,
literal|".eh_frame_hdr"
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|is
operator|->
name|is_size
operator|=
literal|8
expr_stmt|;
comment|/* initial size */
name|is
operator|->
name|is_align
operator|=
literal|4
expr_stmt|;
name|is
operator|->
name|is_entsize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_ehframe_finalize_hdr
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|,
modifier|*
name|hdr_is
decl_stmt|;
name|struct
name|ld_input_section_head
modifier|*
name|islist
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|,
modifier|*
name|hdr_os
decl_stmt|;
name|struct
name|ld_output_element
modifier|*
name|oe
decl_stmt|;
name|struct
name|ld_ehframe_fde
modifier|*
name|fde
decl_stmt|,
modifier|*
name|_fde
decl_stmt|;
name|char
name|ehframe_name
index|[]
init|=
literal|".eh_frame"
decl_stmt|;
name|uint64_t
name|pcbegin
decl_stmt|;
name|int32_t
name|pcrel
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hdr_is
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".eh_frame_hdr"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|hdr_is
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hdr_os
operator|=
name|hdr_is
operator|->
name|is_output
expr_stmt|;
name|lo
operator|->
name|lo_ehframe_hdr
operator|=
name|hdr_os
expr_stmt|;
if|if
condition|(
name|hdr_is
operator|->
name|is_discard
operator|||
name|hdr_os
operator|==
name|NULL
condition|)
return|return;
name|p
operator|=
name|hdr_is
operator|->
name|is_ibuf
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|hdr_is
operator|->
name|is_size
expr_stmt|;
comment|/* Find .eh_frame output section. */
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|ehframe_name
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|os
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* .eh_frame_hdr version */
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* 	 * eh_frame_ptr_enc: encoding format for eh_frame_ptr field. 	 * Usually a signed 4-byte PC relateive offset is used here. 	 */
operator|*
name|p
operator|++
operator|=
name|DW_EH_PE_pcrel
operator||
name|DW_EH_PE_sdata4
expr_stmt|;
comment|/* 	 * fde_count_enc: encoding format for fde_count field. Unsigned 	 * 4 byte encoding should be used here. Note that If the binary 	 * search table is not present, DW_EH_PE_omit should be used 	 * instead. 	 */
operator|*
name|p
operator|++
operator|=
name|lo
operator|->
name|lo_fde_num
operator|==
literal|0
condition|?
name|DW_EH_PE_omit
else|:
name|DW_EH_PE_udata4
expr_stmt|;
comment|/* 	 * table_enc: encoding format for the binary search table entry. 	 * Signed 4 byte table relative offset is used here. Note that 	 * if the binary search table is not present, DW_EH_PE_omit should 	 * be used instaed. 	 */
operator|*
name|p
operator|++
operator|=
name|lo
operator|->
name|lo_fde_num
operator|==
literal|0
condition|?
name|DW_EH_PE_omit
else|:
operator|(
name|DW_EH_PE_datarel
operator||
name|DW_EH_PE_sdata4
operator|)
expr_stmt|;
comment|/* Write 4 byte PC relative offset to the .eh_frame section. */
name|pcrel
operator|=
name|os
operator|->
name|os_addr
operator|-
name|hdr_os
operator|->
name|os_addr
operator|-
literal|4
expr_stmt|;
name|WRITE_32
argument_list|(
name|p
argument_list|,
name|pcrel
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* Write the total number of FDE's. */
name|WRITE_32
argument_list|(
name|p
argument_list|,
name|lo
operator|->
name|lo_fde_num
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* Allocate global FDE list. */
if|if
condition|(
name|ld
operator|->
name|ld_fde
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ld
operator|->
name|ld_fde
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|ld
operator|->
name|ld_fde
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|ld
operator|->
name|ld_fde
argument_list|)
expr_stmt|;
block|}
comment|/* Link together the FDE's from each input object. */
name|STAILQ_FOREACH
argument_list|(
argument|oe
argument_list|,
argument|&os->os_e
argument_list|,
argument|oe_next
argument_list|)
block|{
if|if
condition|(
name|oe
operator|->
name|oe_type
operator|!=
name|OET_INPUT_SECTION_LIST
condition|)
continue|continue;
name|islist
operator|=
name|oe
operator|->
name|oe_islist
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|islist
argument_list|,
argument|is_next
argument_list|)
block|{
if|if
condition|(
name|is
operator|->
name|is_fde
operator|==
name|NULL
operator|||
name|STAILQ_EMPTY
argument_list|(
name|is
operator|->
name|is_fde
argument_list|)
condition|)
continue|continue;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|fde
argument_list|,
argument|is->is_fde
argument_list|,
argument|fde_next
argument_list|,
argument|_fde
argument_list|)
block|{
operator|(
name|void
operator|)
name|_read_encoded
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|,
operator|&
name|pcbegin
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|is
operator|->
name|is_ibuf
operator|+
name|fde
operator|->
name|fde_off_pcbegin
argument_list|,
name|fde
operator|->
name|fde_cie
operator|->
name|cie_fde_encode
argument_list|,
name|os
operator|->
name|os_addr
argument_list|)
expr_stmt|;
name|fde
operator|->
name|fde_pcrel
operator|=
name|pcbegin
operator|-
name|hdr_os
operator|->
name|os_addr
expr_stmt|;
name|fde
operator|->
name|fde_datarel
operator|=
name|os
operator|->
name|os_addr
operator|+
name|is
operator|->
name|is_reloff
operator|+
name|fde
operator|->
name|fde_off
operator|-
name|hdr_os
operator|->
name|os_addr
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
name|is
operator|->
name|is_fde
argument_list|,
name|fde
argument_list|,
name|ld_ehframe_fde
argument_list|,
name|fde_next
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|ld
operator|->
name|ld_fde
argument_list|,
name|fde
argument_list|,
name|fde_next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Sort the binary search table in an increasing order by pcrel. */
name|STAILQ_SORT
argument_list|(
name|ld
operator|->
name|ld_fde
argument_list|,
name|ld_ehframe_fde
argument_list|,
name|fde_next
argument_list|,
name|_cmp_fde
argument_list|)
expr_stmt|;
comment|/* Write binary search table. */
name|STAILQ_FOREACH
argument_list|(
argument|fde
argument_list|,
argument|ld->ld_fde
argument_list|,
argument|fde_next
argument_list|)
block|{
name|WRITE_32
argument_list|(
name|p
argument_list|,
name|fde
operator|->
name|fde_pcrel
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|WRITE_32
argument_list|(
name|p
argument_list|,
name|fde
operator|->
name|fde_datarel
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|assert
argument_list|(
name|p
operator|==
name|end
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|_cmp_fde
parameter_list|(
name|struct
name|ld_ehframe_fde
modifier|*
name|a
parameter_list|,
name|struct
name|ld_ehframe_fde
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|fde_pcrel
operator|<
name|b
operator|->
name|fde_pcrel
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|fde_pcrel
operator|==
name|b
operator|->
name|fde_pcrel
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_parse_cie_augment
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_ehframe_cie
modifier|*
name|cie
parameter_list|,
name|uint8_t
modifier|*
name|aug_p
parameter_list|,
name|uint8_t
modifier|*
name|augdata_p
parameter_list|,
name|uint64_t
name|auglen
parameter_list|)
block|{
name|uint64_t
name|dummy
decl_stmt|;
name|uint8_t
name|encode
decl_stmt|,
modifier|*
name|augdata_end
decl_stmt|;
name|int
name|len
decl_stmt|;
name|assert
argument_list|(
name|aug_p
operator|!=
name|NULL
operator|&&
operator|*
name|aug_p
operator|==
literal|'z'
argument_list|)
expr_stmt|;
name|augdata_end
operator|=
name|augdata_p
operator|+
name|auglen
expr_stmt|;
comment|/* 	 * Here we're only interested in the presence of augment 'R' 	 * and associated CIE augment data, which describes the 	 * encoding scheme of FDE PC begin and range. 	 */
name|aug_p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|aug_p
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
name|aug_p
condition|)
block|{
case|case
literal|'L'
case|:
comment|/* Skip one augment in augment data. */
name|augdata_p
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Skip two augments in augment data. */
name|encode
operator|=
operator|*
name|augdata_p
operator|++
expr_stmt|;
name|len
operator|=
name|_read_encoded
argument_list|(
name|ld
argument_list|,
name|ld
operator|->
name|ld_output
argument_list|,
operator|&
name|dummy
argument_list|,
name|augdata_p
argument_list|,
name|encode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|augdata_p
operator|+=
name|len
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|cie
operator|->
name|cie_fde_encode
operator|=
operator|*
name|augdata_p
operator|++
expr_stmt|;
break|break;
default|default:
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"unsupported eh_frame augmentation `%c'"
argument_list|,
operator|*
name|aug_p
argument_list|)
expr_stmt|;
return|return;
block|}
name|aug_p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|augdata_p
operator|>
name|augdata_end
condition|)
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"invalid eh_frame augmentation"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_process_ehframe_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|)
block|{
name|struct
name|ld_input
modifier|*
name|li
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|struct
name|ld_ehframe_cie
modifier|*
name|cie
decl_stmt|,
modifier|*
name|_cie
decl_stmt|;
name|struct
name|ld_ehframe_cie_head
name|cie_h
decl_stmt|;
name|struct
name|ld_ehframe_fde
modifier|*
name|fde
decl_stmt|;
name|struct
name|ld_reloc_entry
modifier|*
name|lre
decl_stmt|,
modifier|*
name|_lre
decl_stmt|;
name|uint64_t
name|length
decl_stmt|,
name|es
decl_stmt|,
name|off
decl_stmt|,
name|off_orig
decl_stmt|,
name|remain
decl_stmt|,
name|shrink
decl_stmt|,
name|auglen
decl_stmt|;
name|uint32_t
name|cie_id
decl_stmt|,
name|cie_pointer
decl_stmt|,
name|length_size
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|et
decl_stmt|,
name|cie_version
decl_stmt|,
modifier|*
name|augment
decl_stmt|;
name|li
operator|=
name|is
operator|->
name|is_input
expr_stmt|;
name|os
operator|=
name|is
operator|->
name|is_output
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|cie_h
argument_list|)
expr_stmt|;
comment|/* 	 * .eh_frame section content should already be preloaded 	 * in is->is_ibuf. 	 */
name|assert
argument_list|(
name|is
operator|->
name|is_ibuf
operator|!=
name|NULL
operator|&&
name|is
operator|->
name|is_size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|shrink
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|is
operator|->
name|is_ibuf
expr_stmt|;
name|off
operator|=
name|off_orig
operator|=
literal|0
expr_stmt|;
name|remain
operator|=
name|is
operator|->
name|is_size
expr_stmt|;
while|while
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
name|et
operator|=
name|p
expr_stmt|;
name|off
operator|=
name|et
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|is
operator|->
name|is_ibuf
expr_stmt|;
comment|/* Read CIE/FDE length field. */
name|READ_32
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|es
operator|=
name|length
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0xffffffff
condition|)
block|{
name|READ_64
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|es
operator|+=
literal|8
expr_stmt|;
name|length_size
operator|=
literal|8
expr_stmt|;
block|}
else|else
name|length_size
operator|=
literal|4
expr_stmt|;
comment|/* Check for terminator */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
break|break;
comment|/* Read CIE ID/Pointer field. */
name|READ_32
argument_list|(
name|p
argument_list|,
name|cie_id
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|cie_id
operator|==
literal|0
condition|)
block|{
comment|/* This is a Common Information Entry (CIE). */
if|if
condition|(
operator|(
name|cie
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cie
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|cie
operator|->
name|cie_off
operator|=
name|off
expr_stmt|;
name|cie
operator|->
name|cie_off_orig
operator|=
name|off_orig
expr_stmt|;
name|cie
operator|->
name|cie_size
operator|=
name|es
expr_stmt|;
name|cie
operator|->
name|cie_content
operator|=
name|et
expr_stmt|;
name|cie
operator|->
name|cie_dup
operator|=
name|NULL
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cie_h
argument_list|,
name|cie
argument_list|,
name|cie_next
argument_list|)
expr_stmt|;
comment|/* 			 * This is a Common Information Entry (CIE). Search 			 * in the CIE list see if we can found a duplicate 			 * entry. 			 */
name|STAILQ_FOREACH
argument_list|(
argument|_cie
argument_list|,
argument|ld->ld_cie
argument_list|,
argument|cie_next
argument_list|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|et
argument_list|,
name|_cie
operator|->
name|cie_content
argument_list|,
name|es
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cie
operator|->
name|cie_dup
operator|=
name|_cie
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|_cie
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * We found a duplicate entry. It should be 				 * removed and the subsequent FDE's should 				 * point to the previously stored CIE. 				 */
name|memmove
argument_list|(
name|et
argument_list|,
name|et
operator|+
name|es
argument_list|,
name|remain
operator|-
name|es
argument_list|)
expr_stmt|;
name|shrink
operator|+=
name|es
expr_stmt|;
name|p
operator|=
name|et
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * This is a new CIE entry which should be 				 * kept. Read its augmentation which is 				 * used to parse assoicated FDE's later. 				 */
name|cie_version
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|cie_version
operator|!=
literal|1
condition|)
block|{
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"unsupported CIE version"
argument_list|)
expr_stmt|;
goto|goto
name|ignore_cie
goto|;
block|}
name|augment
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'z'
condition|)
block|{
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"unsupported CIE "
literal|"augmentation"
argument_list|)
expr_stmt|;
goto|goto
name|ignore_cie
goto|;
block|}
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
comment|/* Skip EH Data field. */
if|if
condition|(
name|strstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|augment
argument_list|,
literal|"eh"
argument_list|)
operator|!=
name|NULL
condition|)
name|p
operator|+=
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|?
literal|4
else|:
literal|8
expr_stmt|;
comment|/* Skip CAF and DAF. */
operator|(
name|void
operator|)
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_decode_sleb128
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* Skip RA. */
name|p
operator|++
expr_stmt|;
comment|/* Parse augmentation data. */
name|auglen
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|_parse_cie_augment
argument_list|(
name|ld
argument_list|,
name|cie
argument_list|,
name|augment
argument_list|,
name|p
argument_list|,
name|auglen
argument_list|)
expr_stmt|;
name|ignore_cie
label|:
name|p
operator|=
name|et
operator|+
name|es
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * This is a Frame Description Entry (FDE). First 			 * Search for the associated CIE. 			 */
name|STAILQ_FOREACH
argument_list|(
argument|cie
argument_list|,
argument|&cie_h
argument_list|,
argument|cie_next
argument_list|)
block|{
if|if
condition|(
name|cie
operator|->
name|cie_off_orig
operator|==
name|off_orig
operator|+
name|length_size
operator|-
name|cie_id
condition|)
break|break;
block|}
comment|/* 			 * If we can not found the associated CIE, this FDE 			 * is invalid and we ignore it. 			 */
if|if
condition|(
name|cie
operator|==
name|NULL
condition|)
block|{
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"%s(%s): malformed FDE"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|is
operator|->
name|is_name
argument_list|)
expr_stmt|;
name|p
operator|=
name|et
operator|+
name|es
expr_stmt|;
goto|goto
name|next_entry
goto|;
block|}
comment|/* Allocate new FDE entry. */
if|if
condition|(
operator|(
name|fde
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fde
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|fde
operator|->
name|fde_off
operator|=
name|off
expr_stmt|;
name|fde
operator|->
name|fde_off_pcbegin
operator|=
name|off
operator|+
name|length_size
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_fde
operator|==
name|NULL
condition|)
block|{
name|is
operator|->
name|is_fde
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|is
operator|->
name|is_fde
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_fde
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|is
operator|->
name|is_fde
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
name|is
operator|->
name|is_fde
argument_list|,
name|fde
argument_list|,
name|fde_next
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_fde_num
operator|++
expr_stmt|;
comment|/* Calculate the new CIE pointer value. */
if|if
condition|(
name|cie
operator|->
name|cie_dup
operator|!=
name|NULL
condition|)
block|{
name|cie_pointer
operator|=
name|off
operator|+
name|length_size
operator|+
name|is
operator|->
name|is_reloff
operator|-
name|cie
operator|->
name|cie_dup
operator|->
name|cie_off
expr_stmt|;
name|fde
operator|->
name|fde_cie
operator|=
name|cie
operator|->
name|cie_dup
expr_stmt|;
block|}
else|else
block|{
name|cie_pointer
operator|=
name|off
operator|+
name|length_size
operator|-
name|cie
operator|->
name|cie_off
expr_stmt|;
name|fde
operator|->
name|fde_cie
operator|=
name|cie
expr_stmt|;
block|}
comment|/* Rewrite CIE pointer value. */
if|if
condition|(
name|cie_id
operator|!=
name|cie_pointer
condition|)
block|{
name|p
operator|-=
literal|4
expr_stmt|;
name|WRITE_32
argument_list|(
name|p
argument_list|,
name|cie_pointer
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|et
operator|+
name|es
expr_stmt|;
block|}
name|next_entry
label|:
name|off_orig
operator|+=
name|es
expr_stmt|;
name|remain
operator|-=
name|es
expr_stmt|;
block|}
comment|/* 	 * Update the relocation entry offsets since we shrinked the 	 * section content. 	 */
if|if
condition|(
name|shrink
operator|>
literal|0
operator|&&
name|is
operator|->
name|is_ris
operator|!=
name|NULL
operator|&&
name|is
operator|->
name|is_ris
operator|->
name|is_reloc
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|lre
argument_list|,
argument|is->is_ris->is_reloc
argument_list|,
argument|lre_next
argument_list|,
argument|_lre
argument_list|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|cie
argument_list|,
argument|&cie_h
argument_list|,
argument|cie_next
argument_list|)
block|{
if|if
condition|(
name|cie
operator|->
name|cie_off_orig
operator|>
name|lre
operator|->
name|lre_offset
condition|)
break|break;
if|if
condition|(
name|cie
operator|->
name|cie_dup
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 				 * Remove relocations for the duplicated CIE 				 * entries. 				 */
if|if
condition|(
name|lre
operator|->
name|lre_offset
operator|<
name|cie
operator|->
name|cie_off_orig
operator|+
name|cie
operator|->
name|cie_size
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
name|is
operator|->
name|is_ris
operator|->
name|is_reloc
argument_list|,
name|lre
argument_list|,
name|ld_reloc_entry
argument_list|,
name|lre_next
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_ris
operator|->
name|is_num_reloc
operator|--
expr_stmt|;
name|is
operator|->
name|is_ris
operator|->
name|is_size
operator|-=
name|ld
operator|->
name|ld_arch
operator|->
name|reloc_entsize
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_r
operator|!=
name|NULL
condition|)
name|os
operator|->
name|os_r
operator|->
name|os_size
operator|-=
name|ld
operator|->
name|ld_arch
operator|->
name|reloc_entsize
expr_stmt|;
break|break;
block|}
comment|/* Adjust relocation offset for FDE entries. */
name|lre
operator|->
name|lre_offset
operator|-=
name|cie
operator|->
name|cie_size
expr_stmt|;
block|}
block|}
block|}
comment|/* Insert newly found non-duplicate CIE's to the global CIE list. */
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|cie
argument_list|,
argument|&cie_h
argument_list|,
argument|cie_next
argument_list|,
argument|_cie
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|cie_h
argument_list|,
name|cie
argument_list|,
name|ld_ehframe_cie
argument_list|,
name|cie_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|cie
operator|->
name|cie_dup
operator|==
name|NULL
condition|)
block|{
name|cie
operator|->
name|cie_off
operator|+=
name|is
operator|->
name|is_reloff
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|ld
operator|->
name|ld_cie
argument_list|,
name|cie
argument_list|,
name|cie_next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update the size of input .eh_frame section */
name|is
operator|->
name|is_size
operator|-=
name|shrink
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|_read_encoded
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|uint8_t
name|encode
parameter_list|,
name|uint64_t
name|pc
parameter_list|)
block|{
name|int16_t
name|s16
decl_stmt|;
name|int32_t
name|s32
decl_stmt|;
name|uint8_t
name|application
decl_stmt|,
modifier|*
name|begin
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|encode
operator|==
name|DW_EH_PE_omit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|application
operator|=
name|encode
operator|&
literal|0xf0
expr_stmt|;
name|encode
operator|&=
literal|0x0f
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|begin
operator|=
name|data
expr_stmt|;
switch|switch
condition|(
name|encode
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
if|if
condition|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|)
name|READ_32
argument_list|(
name|data
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
else|else
name|READ_64
argument_list|(
name|data
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_uleb128
case|:
operator|*
name|val
operator|=
name|_decode_uleb128
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|len
operator|=
name|data
operator|-
name|begin
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_udata2
case|:
name|READ_16
argument_list|(
name|data
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_udata4
case|:
name|READ_32
argument_list|(
name|data
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_udata8
case|:
name|READ_64
argument_list|(
name|data
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
name|len
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sleb128
case|:
operator|*
name|val
operator|=
name|_decode_sleb128
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|len
operator|=
name|data
operator|-
name|begin
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata2
case|:
name|READ_16
argument_list|(
name|data
argument_list|,
name|s16
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|s16
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata4
case|:
name|READ_32
argument_list|(
name|data
argument_list|,
name|s32
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|s32
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata8
case|:
name|READ_64
argument_list|(
name|data
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
name|len
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"unsupported eh_frame encoding"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|application
operator|==
name|DW_EH_PE_pcrel
condition|)
block|{
comment|/* 		 * Value is relative to .eh_frame section virtual addr. 		 */
switch|switch
condition|(
name|encode
condition|)
block|{
case|case
name|DW_EH_PE_uleb128
case|:
case|case
name|DW_EH_PE_udata2
case|:
case|case
name|DW_EH_PE_udata4
case|:
case|case
name|DW_EH_PE_udata8
case|:
operator|*
name|val
operator|+=
name|pc
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sleb128
case|:
case|case
name|DW_EH_PE_sdata2
case|:
case|case
name|DW_EH_PE_sdata4
case|:
case|case
name|DW_EH_PE_sdata8
case|:
operator|*
name|val
operator|=
name|pc
operator|+
operator|(
name|int64_t
operator|)
operator|*
name|val
expr_stmt|;
break|break;
default|default:
comment|/* DW_EH_PE_absptr is absolute value. */
break|break;
block|}
block|}
comment|/* XXX Applications other than DW_EH_PE_pcrel are not handled. */
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_decode_sleb128
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|dp
parameter_list|)
block|{
name|int64_t
name|ret
init|=
literal|0
decl_stmt|;
name|uint8_t
name|b
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|src
init|=
operator|*
name|dp
decl_stmt|;
do|do
block|{
name|b
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|b
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|shift
operator|<
literal|32
operator|&&
operator|(
name|b
operator|&
literal|0x40
operator|)
operator|!=
literal|0
condition|)
name|ret
operator||=
operator|(
operator|-
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
operator|*
name|dp
operator|=
name|src
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_decode_uleb128
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|dp
parameter_list|)
block|{
name|uint64_t
name|ret
init|=
literal|0
decl_stmt|;
name|uint8_t
name|b
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|src
init|=
operator|*
name|dp
decl_stmt|;
do|do
block|{
name|b
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|ret
operator||=
operator|(
operator|(
name|b
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
do|;
operator|*
name|dp
operator|=
name|src
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

