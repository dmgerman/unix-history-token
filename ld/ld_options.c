begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ld_file.h"
end_include

begin_include
include|#
directive|include
file|"ld_path.h"
end_include

begin_include
include|#
directive|include
file|"ld_script.h"
end_include

begin_include
include|#
directive|include
file|"ld_symbols.h"
end_include

begin_include
include|#
directive|include
file|"ld_options.h"
end_include

begin_include
include|#
directive|include
file|"ld_output.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: ld_options.c 2926 2013-03-17 22:53:54Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Support routines for parsing command line options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ld_short_opts
init|=
literal|"b:c:de:Ef:Fgh:iI:l:L:m:MnNo:O::qrR:sStT:xXyY:u:vV()"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ld_option
name|ld_opts
index|[]
init|=
block|{
block|{
literal|"aarchive"
block|,
name|KEY_STATIC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"adefault"
block|,
name|KEY_DYNAMIC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"ashared"
block|,
name|KEY_DYNAMIC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"accept-unknown-input-arch"
block|,
name|KEY_ACCEPT_UNKNOWN
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"allow-multiple-definition"
block|,
name|KEY_Z_MULDEFS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"allow-shlib-undefined"
block|,
name|KEY_ALLOW_SHLIB_UNDEF
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"assert"
block|,
name|KEY_ASSERT
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"as-needed"
block|,
name|KEY_AS_NEEDED
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"auxiliary"
block|,
literal|'f'
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"build-id"
block|,
name|KEY_BUILD_ID
block|,
name|ANY_DASH
block|,
name|OPT_ARG
block|}
block|,
block|{
literal|"call_shared"
block|,
name|KEY_DYNAMIC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"check-sections"
block|,
name|KEY_CHECK_SECTIONS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"cref"
block|,
name|KEY_CREF
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"defsym"
block|,
name|KEY_DEFSYM
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"demangle"
block|,
name|KEY_DEMANGLE
block|,
name|ANY_DASH
block|,
name|OPT_ARG
block|}
block|,
block|{
literal|"dc"
block|,
literal|'d'
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"dp"
block|,
literal|'d'
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"disable-new-dtags"
block|,
name|KEY_DISABLE_NEW_DTAGS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"discard-all"
block|,
literal|'x'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"discard-locals"
block|,
literal|'X'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"dn"
block|,
name|KEY_STATIC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"dy"
block|,
name|KEY_DYNAMIC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"dynamic-linker"
block|,
literal|'I'
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"end-group"
block|,
literal|')'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"entry"
block|,
literal|'e'
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"error-unresolved-symbols"
block|,
name|KEY_ERR_UNRESOLVE_SYM
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"export-dynamic"
block|,
literal|'E'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"eh-frame-hdr"
block|,
name|KEY_EH_FRAME_HDR
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"emit-relocs"
block|,
literal|'q'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"emulation"
block|,
literal|'m'
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"enable-new-dtags"
block|,
name|KEY_ENABLE_NEW_DTAGS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"fatal-warnings"
block|,
name|KEY_FATAL_WARNINGS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"filter"
block|,
literal|'F'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"fini"
block|,
name|KEY_FINI
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"format"
block|,
literal|'b'
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"gc-sections"
block|,
name|KEY_GC_SECTIONS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"hash-style"
block|,
name|KEY_HASH_STYLE
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"help"
block|,
name|KEY_HELP
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"init"
block|,
name|KEY_INIT
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"just-symbols"
block|,
literal|'R'
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"library"
block|,
literal|'l'
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"library-path"
block|,
literal|'L'
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"mri-script"
block|,
literal|'c'
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"nmagic"
block|,
literal|'n'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"nostdlib"
block|,
name|KEY_NO_STDLIB
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-accept-unknown-input-arch"
block|,
name|KEY_NO_UNKNOWN
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-allow-shlib-undefined"
block|,
name|KEY_NO_SHLIB_UNDEF
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-as-needed"
block|,
name|KEY_NO_AS_NEEDED
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-check-sections"
block|,
name|KEY_NO_CHECK_SECTIONS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-define-common"
block|,
name|KEY_NO_DEFINE_COMMON
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-demangle"
block|,
name|KEY_NO_DEMANGLE
block|,
name|ANY_DASH
block|,
name|OPT_ARG
block|}
block|,
block|{
literal|"no-gc-sections"
block|,
name|KEY_NO_GC_SECTIONS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-keep-memorg"
block|,
name|KEY_NO_KEEP_MEMORY
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-omagic"
block|,
name|KEY_NO_OMAGIC
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-print-gc-sections"
block|,
name|KEY_NO_PRINT_GC_SECTIONS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-undefined"
block|,
name|KEY_Z_DEFS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-undefined-version"
block|,
name|KEY_NO_UNDEF_VERSION
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-whole-archive"
block|,
name|KEY_NO_WHOLE_ARCHIVE
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"no-warn-mismatch"
block|,
name|KEY_NO_WARN_MISMATCH
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"non_shared"
block|,
name|KEY_STATIC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"oformat"
block|,
name|KEY_OFORMAT
block|,
name|TWO_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"omagic"
block|,
literal|'N'
block|,
name|TWO_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"output"
block|,
literal|'o'
block|,
name|TWO_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"pic-executable"
block|,
name|KEY_PIE
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"pie"
block|,
name|KEY_PIE
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"print-gc-sections"
block|,
name|KEY_PRINT_GC_SECTIONS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"print-map"
block|,
literal|'M'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"qmagic"
block|,
name|KEY_QMAGIC
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"relax"
block|,
name|KEY_RELAX
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"relocatable"
block|,
literal|'r'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"retain-symbols-file"
block|,
name|KEY_RETAIN_SYM_FILE
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"rpath"
block|,
name|KEY_RPATH
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"rpath-link"
block|,
name|KEY_RPATH_LINK
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"runpath"
block|,
name|KEY_RUNPATH
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"script"
block|,
literal|'T'
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"section-start"
block|,
name|KEY_SECTION_START
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"shared"
block|,
name|KEY_SHARED
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"soname"
block|,
literal|'h'
block|,
name|ONE_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"sort-common"
block|,
name|KEY_SORT_COMMON
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"split-by-file"
block|,
name|KEY_SPLIT_BY_FILE
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"split-by-reloc"
block|,
name|KEY_SPLIT_BY_RELOC
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"start-group"
block|,
literal|'('
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"stats"
block|,
name|KEY_STATS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"static"
block|,
name|KEY_STATIC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"strip-all"
block|,
literal|'s'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"strip-debug"
block|,
literal|'S'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"trace"
block|,
literal|'t'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"trace_symbol"
block|,
literal|'y'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"traditional-format"
block|,
name|KEY_TRADITIONAL_FORMAT
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"undefined"
block|,
literal|'u'
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"unique"
block|,
name|KEY_UNIQUE
block|,
name|ANY_DASH
block|,
name|OPT_ARG
block|}
block|,
block|{
literal|"unresolved-symbols"
block|,
name|KEY_UNRESOLVED_SYMBOLS
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"verbose"
block|,
literal|'v'
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"version"
block|,
name|KEY_VERSION
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"version-script"
block|,
name|KEY_VERSION_SCRIPT
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"warn-common"
block|,
name|KEY_WARN_COMMON
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"warn-constructors"
block|,
name|KEY_WARN_CONSTRUCTORS
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"warn-multiple-gp"
block|,
name|KEY_WARN_MULTIPLE_GP
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"warn-once"
block|,
name|KEY_WARN_ONCE
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"warn-section-align"
block|,
name|KEY_WARN_SECTION_ALIGN
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"warn-shared-textrel"
block|,
name|KEY_WARN_SHARED_TEXTREL
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"warn-unresolved-symbols"
block|,
name|KEY_WARN_UNRESOLVE_SYM
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"whole_archive"
block|,
name|KEY_WHOLE_ARCHIVE
block|,
name|ANY_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"wrap"
block|,
name|KEY_WRAP
block|,
name|ANY_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"EB"
block|,
name|KEY_EB
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"EL"
block|,
name|KEY_EL
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"Map"
block|,
name|KEY_MAP
block|,
name|ONE_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"Qy"
block|,
name|KEY_QY
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"Tbss"
block|,
name|KEY_TBSS
block|,
name|ONE_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"Tdata"
block|,
name|KEY_TDATA
block|,
name|ONE_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"Ttext"
block|,
name|KEY_TTEXT
block|,
name|ONE_DASH
block|,
name|REQ_ARG
block|}
block|,
block|{
literal|"Ur"
block|,
name|KEY_UR
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ld_option
name|ld_opts_B
index|[]
init|=
block|{
block|{
literal|"shareable"
block|,
name|KEY_SHARED
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"static"
block|,
name|KEY_STATIC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"dynamic"
block|,
name|KEY_DYNAMIC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"group"
block|,
name|KEY_GROUP
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"symbolic"
block|,
name|KEY_SYMBOLIC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"symbolic_functions"
block|,
name|KEY_SYMBOLIC_FUNC
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ld_option
name|ld_opts_z
index|[]
init|=
block|{
block|{
literal|"nodefaultlib"
block|,
name|KEY_Z_NO_DEFAULT_LIB
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"allextract"
block|,
name|KEY_WHOLE_ARCHIVE
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"defaultextract"
block|,
name|KEY_Z_DEFAULT_EXTRACT
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"weakextract"
block|,
name|KEY_Z_WEAK_EXTRACT
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"muldefs"
block|,
name|KEY_Z_MULDEFS
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"defs"
block|,
name|KEY_Z_DEFS
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"execstack"
block|,
name|KEY_Z_EXEC_STACK
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"nodefs"
block|,
name|KEY_Z_NO_DEFS
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"origin"
block|,
name|KEY_Z_ORIGIN
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"now"
block|,
name|KEY_Z_NOW
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"nodelete"
block|,
name|KEY_Z_NO_DELETE
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"initfirst"
block|,
name|KEY_Z_INIT_FIRST
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"lazyload"
block|,
name|KEY_Z_LAZYLOAD
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"noexecstack"
block|,
name|KEY_Z_NO_EXEC_STACK
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"nodlopen"
block|,
name|KEY_Z_NO_DLOPEN
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"nolazyload"
block|,
name|KEY_Z_NO_LAZYLOAD
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"ignore"
block|,
name|KEY_Z_IGNORE
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"record"
block|,
name|KEY_Z_RECORD
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|,
block|{
literal|"systemlibrary"
block|,
name|KEY_Z_SYSTEM_LIBRARY
block|,
name|ONE_DASH
block|,
name|NO_ARG
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|_copy_optarg
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
modifier|*
name|dst
parameter_list|,
name|char
modifier|*
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_process_options
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|key
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_parse_long_options
parameter_list|(
name|struct
name|ld
modifier|*
parameter_list|,
name|struct
name|ld_option
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|enum
name|ld_dash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_print_version
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ld_options_parse
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|enum
name|ld_dash
name|d
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p0
decl_stmt|,
modifier|*
name|oli
decl_stmt|;
name|int
name|ac
decl_stmt|,
name|ac0
decl_stmt|;
name|ac
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|ac
operator|<
name|argc
condition|)
block|{
name|p
operator|=
name|argv
index|[
name|ac
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'-'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|_process_options
argument_list|(
name|ld
argument_list|,
name|KEY_FILE
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ac
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Option --. Ignore the rest of options. */
return|return;
block|}
name|p
operator|++
expr_stmt|;
name|d
operator|=
name|TWO_DASH
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|ONE_DASH
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'B'
operator|||
operator|*
name|p
operator|==
literal|'z'
condition|)
block|{
name|ac0
operator|=
name|ac
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p0
operator|=
name|p
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
name|p0
operator|=
name|argv
index|[
operator|++
name|ac0
index|]
expr_stmt|;
name|ac
operator|=
name|_parse_long_options
argument_list|(
name|ld
argument_list|,
operator|*
name|p
operator|==
literal|'B'
condition|?
name|ld_opts_B
else|:
name|ld_opts_z
argument_list|,
name|ac0
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|p0
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|0
condition|)
continue|continue;
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"unrecognized options -%c: %s"
argument_list|,
operator|*
name|p
argument_list|,
name|p0
argument_list|)
expr_stmt|;
block|}
block|}
name|ac0
operator|=
name|_parse_long_options
argument_list|(
name|ld
argument_list|,
name|ld_opts
argument_list|,
name|ac
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|p
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac0
operator|>
literal|0
condition|)
block|{
name|ac
operator|=
name|ac0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|d
operator|==
name|TWO_DASH
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"unrecognized option %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * Search short options. 		 */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|oli
operator|=
name|strchr
argument_list|(
name|ld_short_opts
argument_list|,
operator|*
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"unrecognized option -%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|oli
operator|!=
literal|':'
condition|)
block|{
name|_process_options
argument_list|(
name|ld
argument_list|,
operator|*
name|p
operator|++
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|_process_options
argument_list|(
name|ld
argument_list|,
operator|*
name|p
argument_list|,
operator|&
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oli
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|++
name|ac
operator|>=
name|argc
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"require arg for"
literal|" option -%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|_process_options
argument_list|(
name|ld
argument_list|,
operator|*
name|p
argument_list|,
name|argv
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|ac
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|_parse_long_options
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_option
modifier|*
name|opts
parameter_list|,
name|int
name|ac
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|opt
parameter_list|,
name|enum
name|ld_dash
name|dash
parameter_list|)
block|{
name|char
modifier|*
name|equal
decl_stmt|;
name|size_t
name|av_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|match
decl_stmt|;
if|if
condition|(
operator|(
name|equal
operator|=
name|strchr
argument_list|(
name|opt
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|av_len
operator|=
name|equal
operator|-
name|opt
expr_stmt|;
name|equal
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|equal
operator|==
literal|'\0'
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"no argument after ="
argument_list|)
expr_stmt|;
block|}
else|else
name|av_len
operator|=
name|strlen
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|lo_long
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|lo_dash
operator|!=
name|ANY_DASH
operator|&&
name|opts
index|[
name|i
index|]
operator|.
name|lo_dash
operator|!=
name|dash
condition|)
continue|continue;
if|if
condition|(
name|strlen
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|lo_long
argument_list|)
operator|==
name|av_len
operator|&&
operator|!
name|strncmp
argument_list|(
name|opt
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|lo_long
argument_list|,
name|av_len
argument_list|)
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|lo_arg
condition|)
block|{
case|case
name|NO_ARG
case|:
if|if
condition|(
name|equal
operator|!=
name|NULL
condition|)
block|{
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"option %s does not accept argument"
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|lo_long
argument_list|)
expr_stmt|;
block|}
name|_process_options
argument_list|(
name|ld
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|lo_key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|REQ_ARG
case|:
if|if
condition|(
name|equal
operator|!=
name|NULL
condition|)
name|_process_options
argument_list|(
name|ld
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|lo_key
argument_list|,
name|equal
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|++
name|ac
operator|>=
name|argc
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"require arg for option %s"
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|lo_long
argument_list|)
expr_stmt|;
name|_process_options
argument_list|(
name|ld
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|lo_key
argument_list|,
name|argv
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPT_ARG
case|:
name|_process_options
argument_list|(
name|ld
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|lo_key
argument_list|,
name|equal
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|++
name|ac
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_process_options
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|key
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|assert
argument_list|(
name|ld
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'b'
case|:
name|ls
operator|->
name|ls_itgt
operator|=
name|elftc_bfd_find_target
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|ls_itgt
operator|==
name|NULL
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"invalid BFD target `%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|ld
operator|->
name|ld_common_alloc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|_copy_optarg
argument_list|(
name|ld
argument_list|,
operator|&
name|ld
operator|->
name|ld_entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|_copy_optarg
argument_list|(
name|ld
argument_list|,
operator|&
name|ld
operator|->
name|ld_soname
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|_copy_optarg
argument_list|(
name|ld
argument_list|,
operator|&
name|ld
operator|->
name|ld_interp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|ld_path_search_library
argument_list|(
name|ld
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|ld_path_add
argument_list|(
name|ld
argument_list|,
name|arg
argument_list|,
name|LPT_L
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|ld
operator|->
name|ld_print_linkmap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|_copy_optarg
argument_list|(
name|ld
argument_list|,
operator|&
name|ld
operator|->
name|ld_output_file
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|ld
operator|->
name|ld_emit_reloc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ld
operator|->
name|ld_reloc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|ld_script_parse
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|ld_symbols_add_extern
argument_list|(
name|ld
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|_print_version
argument_list|(
name|ld
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|ls
operator|->
name|ls_group_level
operator|++
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|ls_group_level
operator|>
name|LD_MAX_NESTED_GROUP
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"too many nested archive groups"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|ls
operator|->
name|ls_group_level
operator|--
expr_stmt|;
break|break;
case|case
name|KEY_AS_NEEDED
case|:
name|ls
operator|->
name|ls_as_needed
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_DYNAMIC
case|:
name|ls
operator|->
name|ls_static
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_EH_FRAME_HDR
case|:
name|ld
operator|->
name|ld_ehframe_hdr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_GC_SECTIONS
case|:
name|ld
operator|->
name|ld_gc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_NO_AS_NEEDED
case|:
name|ls
operator|->
name|ls_as_needed
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_NO_DEFINE_COMMON
case|:
name|ld
operator|->
name|ld_common_no_alloc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_NO_GC_SECTIONS
case|:
name|ld
operator|->
name|ld_gc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_NO_PRINT_GC_SECTIONS
case|:
name|ld
operator|->
name|ld_gc_print
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_NO_WHOLE_ARCHIVE
case|:
name|ls
operator|->
name|ls_whole_archive
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_OFORMAT
case|:
name|ld_output_format
argument_list|(
name|ld
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_PIE
case|:
name|ld
operator|->
name|ld_exec
operator|=
literal|0
expr_stmt|;
name|ld
operator|->
name|ld_pie
operator|=
literal|1
expr_stmt|;
name|ld
operator|->
name|ld_dynamic_link
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_PRINT_GC_SECTIONS
case|:
name|ld
operator|->
name|ld_gc_print
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_RPATH
case|:
name|ld_path_add_multiple
argument_list|(
name|ld
argument_list|,
name|arg
argument_list|,
name|LPT_RPATH
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_RPATH_LINK
case|:
name|ld_path_add_multiple
argument_list|(
name|ld
argument_list|,
name|arg
argument_list|,
name|LPT_RPATH_LINK
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_SHARED
case|:
name|ld
operator|->
name|ld_exec
operator|=
literal|0
expr_stmt|;
name|ld
operator|->
name|ld_dso
operator|=
literal|1
expr_stmt|;
name|ld
operator|->
name|ld_dynamic_link
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_STATIC
case|:
name|ls
operator|->
name|ls_static
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_WHOLE_ARCHIVE
case|:
name|ls
operator|->
name|ls_whole_archive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_FILE
case|:
name|ld_file_add
argument_list|(
name|ld
argument_list|,
name|arg
argument_list|,
name|LFT_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_VERSION_SCRIPT
case|:
name|ld_script_parse
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_Z_EXEC_STACK
case|:
name|ld
operator|->
name|ld_gen_gnustack
operator|=
literal|1
expr_stmt|;
name|ld
operator|->
name|ld_stack_exec_set
operator|=
literal|1
expr_stmt|;
name|ld
operator|->
name|ld_stack_exec
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_Z_NO_EXEC_STACK
case|:
name|ld
operator|->
name|ld_gen_gnustack
operator|=
literal|1
expr_stmt|;
name|ld
operator|->
name|ld_stack_exec_set
operator|=
literal|1
expr_stmt|;
name|ld
operator|->
name|ld_stack_exec
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_print_version
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s (%s)\n"
argument_list|,
name|ELFTC_GETPROGNAME
argument_list|()
argument_list|,
name|elftc_version
argument_list|()
argument_list|)
expr_stmt|;
name|ld
operator|->
name|ld_print_version
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_copy_optarg
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
modifier|*
name|dst
parameter_list|,
name|char
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
operator|*
name|dst
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|*
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|dst
operator|=
name|strdup
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ld_wildcard
modifier|*
name|ld_wildcard_alloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_wildcard
modifier|*
name|lw
decl_stmt|;
if|if
condition|(
operator|(
name|lw
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lw
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
return|return
operator|(
name|lw
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ld_wildcard_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|ld_wildcard
modifier|*
name|lw
decl_stmt|;
name|lw
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|lw
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|lw
operator|->
name|lw_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lw
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

