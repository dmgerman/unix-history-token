begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011-2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ld_arch.h"
end_include

begin_include
include|#
directive|include
file|"ld_dynamic.h"
end_include

begin_include
include|#
directive|include
file|"ld_ehframe.h"
end_include

begin_include
include|#
directive|include
file|"ld_exp.h"
end_include

begin_include
include|#
directive|include
file|"ld_file.h"
end_include

begin_include
include|#
directive|include
file|"ld_script.h"
end_include

begin_include
include|#
directive|include
file|"ld_input.h"
end_include

begin_include
include|#
directive|include
file|"ld_output.h"
end_include

begin_include
include|#
directive|include
file|"ld_reloc.h"
end_include

begin_include
include|#
directive|include
file|"ld_layout.h"
end_include

begin_include
include|#
directive|include
file|"ld_options.h"
end_include

begin_include
include|#
directive|include
file|"ld_symbols.h"
end_include

begin_include
include|#
directive|include
file|"ld_strtab.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: ld_layout.c 3276 2015-12-11 21:39:06Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ld_wildcard_match
block|{
name|char
modifier|*
name|wm_name
decl_stmt|;
name|unsigned
name|wm_no_match
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|wm_os
decl_stmt|;
name|struct
name|ld_input_section_head
modifier|*
name|wm_islist
decl_stmt|;
name|struct
name|ld_script_sections_output_input
modifier|*
name|wm_ldoi
decl_stmt|;
name|struct
name|ld_wildcard_match
modifier|*
name|wm_next
decl_stmt|;
name|UT_hash_handle
name|hh
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Support routines for output section layout.  */
end_comment

begin_function_decl
specifier|static
name|void
name|_calc_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_calc_output_section_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_calc_reloc_section_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_calc_shdr_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_check_filename_constraint
parameter_list|(
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|struct
name|ld_script_sections_output_input
modifier|*
name|ldoi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_insert_input_to_output
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_input_section_head
modifier|*
name|islist
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_layout_input_sections
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_layout_orphan_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_layout_sections
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_sections
modifier|*
name|ldss
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_parse_output_section_descriptor
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_prepare_output_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_sections_output
modifier|*
name|ldso
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_print_section_layout
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_print_wildcard
parameter_list|(
name|struct
name|ld_wildcard
modifier|*
name|lw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_print_wildcard_list
parameter_list|(
name|struct
name|ld_script_list
modifier|*
name|ldl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_record_wildcard_match
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|,
name|struct
name|ld_output_element
modifier|*
name|oe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_record_wildcard_no_match
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_set_output_section_loadable_flag
parameter_list|(
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_wildcard_match
parameter_list|(
name|struct
name|ld_wildcard
modifier|*
name|lw
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_wildcard_list_match
parameter_list|(
name|struct
name|ld_script_list
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ld_layout_sections
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_script
modifier|*
name|lds
decl_stmt|;
name|struct
name|ld_script_cmd
modifier|*
name|ldc
decl_stmt|;
name|int
name|sections_cmd_exist
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|lds
operator|=
name|ld
operator|->
name|ld_scp
expr_stmt|;
name|sections_cmd_exist
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ldc
argument_list|,
argument|&lds->lds_c
argument_list|,
argument|ldc_next
argument_list|)
block|{
switch|switch
condition|(
name|ldc
operator|->
name|ldc_type
condition|)
block|{
case|case
name|LSC_ASSERT
case|:
name|ld_output_create_element
argument_list|(
name|ld
argument_list|,
operator|&
name|lo
operator|->
name|lo_oelist
argument_list|,
name|OET_ASSERT
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_ASSIGN
case|:
name|ld_output_create_element
argument_list|(
name|ld
argument_list|,
operator|&
name|lo
operator|->
name|lo_oelist
argument_list|,
name|OET_ASSIGN
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_ENTRY
case|:
name|ld_output_create_element
argument_list|(
name|ld
argument_list|,
operator|&
name|lo
operator|->
name|lo_oelist
argument_list|,
name|OET_ENTRY
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_SECTIONS
case|:
if|if
condition|(
name|sections_cmd_exist
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"found multiple SECTIONS commands"
literal|" in the linker script"
argument_list|)
expr_stmt|;
name|sections_cmd_exist
operator|=
literal|1
expr_stmt|;
name|_layout_sections
argument_list|(
name|ld
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|sections_cmd_exist
condition|)
name|_layout_sections
argument_list|(
name|ld
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Scan and optimize .eh_frame section. */
name|ld_ehframe_scan
argument_list|(
name|ld
argument_list|)
expr_stmt|;
comment|/* Initialise sections for dyanmically linked output object. */
name|ld_dynamic_create
argument_list|(
name|ld
argument_list|)
expr_stmt|;
comment|/* Create ELF sections. */
name|ld_output_create_elf_sections
argument_list|(
name|ld
argument_list|)
expr_stmt|;
comment|/* Calculate section offsets of the output object. */
name|_calc_offset
argument_list|(
name|ld
argument_list|)
expr_stmt|;
comment|/* Calculate symbol values and indices of the output object. */
name|ld_symbols_update
argument_list|(
name|ld
argument_list|)
expr_stmt|;
comment|/* Print out link map if requested. */
if|if
condition|(
name|ld
operator|->
name|ld_print_linkmap
condition|)
name|ld_layout_print_linkmap
argument_list|(
name|ld
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_layout_print_linkmap
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_input
modifier|*
name|li
decl_stmt|;
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_element
modifier|*
name|oe
decl_stmt|;
name|struct
name|ld_script
modifier|*
name|lds
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print out the list of discarded sections. */
name|printf
argument_list|(
literal|"\nDiscarded input sections:\n\n"
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|li
argument_list|,
argument|&ld->ld_lilist
argument_list|,
argument|li_next
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|li
operator|->
name|li_shnum
condition|;
name|i
operator|++
control|)
block|{
name|is
operator|=
operator|&
name|li
operator|->
name|li_is
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_discard
condition|)
block|{
name|printf
argument_list|(
literal|" %-20s "
argument_list|,
name|is
operator|->
name|is_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|"0x%08jx "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|is
operator|->
name|is_addr
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x%016jx "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|is
operator|->
name|is_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%jx "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|is
operator|->
name|is_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ld_input_get_fullname
argument_list|(
name|ld
argument_list|,
name|li
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|lds
operator|=
name|ld
operator|->
name|ld_scp
expr_stmt|;
if|if
condition|(
name|lds
operator|==
name|NULL
condition|)
return|return;
comment|/* TODO: Dump memory configuration */
name|printf
argument_list|(
literal|"\nLinker script and memory map\n\n"
argument_list|)
expr_stmt|;
comment|/* TODO: Dump loaded objects. */
name|STAILQ_FOREACH
argument_list|(
argument|oe
argument_list|,
argument|&lo->lo_oelist
argument_list|,
argument|oe_next
argument_list|)
block|{
switch|switch
condition|(
name|oe
operator|->
name|oe_type
condition|)
block|{
case|case
name|OET_ASSERT
case|:
comment|/* TODO */
break|break;
case|case
name|OET_ASSIGN
case|:
name|ld_script_assign_dump
argument_list|(
name|ld
argument_list|,
name|oe
operator|->
name|oe_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|OET_ENTRY
case|:
comment|/* TODO */
break|break;
case|case
name|OET_OUTPUT_SECTION
case|:
name|_print_section_layout
argument_list|(
name|ld
argument_list|,
name|oe
operator|->
name|oe_entry
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_print_section_layout
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|struct
name|ld_input_section_head
modifier|*
name|islist
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_element
modifier|*
name|oe
decl_stmt|;
name|struct
name|ld_script_sections_output_input
modifier|*
name|ldoi
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_empty
condition|)
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
name|os
operator|->
name|os_name
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\n%-15s"
argument_list|,
name|os
operator|->
name|os_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|" 0x%08jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|os
operator|->
name|os_addr
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" 0x%016jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|os
operator|->
name|os_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %#10jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|os
operator|->
name|os_size
argument_list|)
expr_stmt|;
block|}
name|STAILQ_FOREACH
argument_list|(
argument|oe
argument_list|,
argument|&os->os_e
argument_list|,
argument|oe_next
argument_list|)
block|{
switch|switch
condition|(
name|oe
operator|->
name|oe_type
condition|)
block|{
case|case
name|OET_ASSIGN
case|:
name|ld_script_assign_dump
argument_list|(
name|ld
argument_list|,
name|oe
operator|->
name|oe_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|OET_INPUT_SECTION_LIST
case|:
comment|/* 			 * Print out wildcard patterns and input sections 			 * matched by these patterns. 			 */
name|ldoi
operator|=
name|oe
operator|->
name|oe_entry
expr_stmt|;
if|if
condition|(
name|ldoi
operator|==
name|NULL
condition|)
break|break;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldoi
operator|->
name|ldoi_ar
condition|)
block|{
name|_print_wildcard
argument_list|(
name|ldoi
operator|->
name|ldoi_ar
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
name|_print_wildcard
argument_list|(
name|ldoi
operator|->
name|ldoi_file
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldoi
operator|->
name|ldoi_exclude
condition|)
block|{
name|printf
argument_list|(
literal|"(EXCLUDE_FILE("
argument_list|)
expr_stmt|;
name|_print_wildcard_list
argument_list|(
name|ldoi
operator|->
name|ldoi_exclude
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|_print_wildcard_list
argument_list|(
name|ldoi
operator|->
name|ldoi_sec
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|islist
operator|=
name|oe
operator|->
name|oe_islist
operator|)
operator|==
name|NULL
condition|)
break|break;
name|STAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|islist
argument_list|,
argument|is_next
argument_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|is
operator|->
name|is_name
argument_list|,
literal|"COMMON"
argument_list|)
operator|&&
name|is
operator|->
name|is_size
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|" %-14s"
argument_list|,
name|is
operator|->
name|is_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|)
name|printf
argument_list|(
literal|" 0x%08jx"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|os
operator|->
name|os_addr
operator|+
name|is
operator|->
name|is_reloff
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" 0x%016jx"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|os
operator|->
name|os_addr
operator|+
name|is
operator|->
name|is_reloff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_size
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" %10s"
argument_list|,
literal|"0x0"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %#10jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|is
operator|->
name|is_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|ld_input_get_fullname
argument_list|(
name|ld
argument_list|,
name|is
operator|->
name|is_input
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_print_wildcard
parameter_list|(
name|struct
name|ld_wildcard
modifier|*
name|lw
parameter_list|)
block|{
switch|switch
condition|(
name|lw
operator|->
name|lw_sort
condition|)
block|{
case|case
name|LWS_NONE
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|lw
operator|->
name|lw_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|LWS_NAME
case|:
name|printf
argument_list|(
literal|"SORT_BY_NAME(%s)"
argument_list|,
name|lw
operator|->
name|lw_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|LWS_ALIGN
case|:
name|printf
argument_list|(
literal|"SORT_BY_ALIGNMENT(%s)"
argument_list|,
name|lw
operator|->
name|lw_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|LWS_NAME_ALIGN
case|:
name|printf
argument_list|(
literal|"SORT_BY_NAME(SORT_BY_ALIGNMENT(%s))"
argument_list|,
name|lw
operator|->
name|lw_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|LWS_ALIGN_NAME
case|:
name|printf
argument_list|(
literal|"SORT_BY_ALIGNMENT(SORT_BY_NAME(%s))"
argument_list|,
name|lw
operator|->
name|lw_name
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_print_wildcard_list
parameter_list|(
name|struct
name|ld_script_list
modifier|*
name|ldl
parameter_list|)
block|{
name|_print_wildcard
argument_list|(
name|ldl
operator|->
name|ldl_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldl
operator|->
name|ldl_next
operator|!=
name|NULL
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|_print_wildcard_list
argument_list|(
name|ldl
operator|->
name|ldl_next
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|off_t
name|ld_layout_calc_header_size
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_script_phdr
modifier|*
name|ldsp
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|off_t
name|header_size
decl_stmt|;
name|unsigned
name|ec
decl_stmt|,
name|w
decl_stmt|,
name|num_phdrs
decl_stmt|;
name|int
name|new
decl_stmt|,
name|tls
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|header_size
operator|=
literal|0
expr_stmt|;
name|ec
operator|=
name|elftc_bfd_target_class
argument_list|(
name|ld
operator|->
name|ld_otgt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ec
operator|==
name|ELFCLASS32
condition|)
name|header_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_Ehdr
argument_list|)
expr_stmt|;
else|else
name|header_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_Ehdr
argument_list|)
expr_stmt|;
comment|/* Do not generate segments for relocatable output. */
if|if
condition|(
name|ld
operator|->
name|ld_reloc
condition|)
block|{
name|lo
operator|->
name|lo_phdr_num
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|header_size
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ld
operator|->
name|ld_scp
operator|->
name|lds_p
argument_list|)
condition|)
block|{
name|num_phdrs
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ldsp
argument_list|,
argument|&ld->ld_scp->lds_p
argument_list|,
argument|ldsp_next
argument_list|)
name|num_phdrs
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lo
operator|->
name|lo_phdr_num
operator|>
literal|0
condition|)
name|num_phdrs
operator|=
name|lo
operator|->
name|lo_phdr_num
expr_stmt|;
else|else
block|{
name|num_phdrs
operator|=
literal|0
expr_stmt|;
name|new
operator|=
literal|1
expr_stmt|;
name|tls
operator|=
literal|0
expr_stmt|;
name|w
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|os
argument_list|,
argument|&lo->lo_oslist
argument_list|,
argument|os_next
argument_list|)
block|{
if|if
condition|(
name|os
operator|->
name|os_empty
condition|)
continue|continue;
if|if
condition|(
operator|(
name|os
operator|->
name|os_flags
operator|&
name|SHF_ALLOC
operator|)
operator|==
literal|0
condition|)
block|{
name|new
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|os
operator|->
name|os_flags
operator|&
name|SHF_WRITE
operator|)
operator|!=
name|w
operator|||
name|new
condition|)
block|{
name|new
operator|=
literal|0
expr_stmt|;
name|num_phdrs
operator|++
expr_stmt|;
name|w
operator|=
name|os
operator|->
name|os_flags
operator|&
name|SHF_WRITE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|os
operator|->
name|os_flags
operator|&
name|SHF_TLS
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|tls
condition|)
block|{
name|tls
operator|=
literal|1
expr_stmt|;
name|num_phdrs
operator|++
expr_stmt|;
block|}
block|}
comment|/* 			 * PT_PHDR and PT_DYNAMIC for dynamic linking. But 			 * do not create PT_PHDR for shared libraries. 			 */
if|if
condition|(
name|lo
operator|->
name|lo_dso_needed
operator|>
literal|0
condition|)
block|{
name|num_phdrs
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ld
operator|->
name|ld_dso
condition|)
name|num_phdrs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|->
name|lo_interp
operator|!=
name|NULL
condition|)
name|num_phdrs
operator|++
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_phdr_note
condition|)
name|num_phdrs
operator|++
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_ehframe_hdr
condition|)
name|num_phdrs
operator|++
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_gen_gnustack
condition|)
name|num_phdrs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ec
operator|==
name|ELFCLASS32
condition|)
name|header_size
operator|+=
name|num_phdrs
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_Phdr
argument_list|)
expr_stmt|;
else|else
name|header_size
operator|+=
name|num_phdrs
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_Phdr
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_phdr_num
operator|=
name|num_phdrs
expr_stmt|;
return|return
operator|(
name|header_size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_layout_sections
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_sections
modifier|*
name|ldss
parameter_list|)
block|{
name|struct
name|ld_input
modifier|*
name|li
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_script_cmd
modifier|*
name|ldc
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
comment|/* 	 * Process commands inside the SECTIONS command and create 	 * output elements. 	 */
name|STAILQ_FOREACH
argument_list|(
argument|ldc
argument_list|,
argument|&ldss->ldss_c
argument_list|,
argument|ldc_next
argument_list|)
block|{
switch|switch
condition|(
name|ldc
operator|->
name|ldc_type
condition|)
block|{
case|case
name|LSC_ASSERT
case|:
name|ld_output_create_element
argument_list|(
name|ld
argument_list|,
operator|&
name|lo
operator|->
name|lo_oelist
argument_list|,
name|OET_ASSIGN
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
case|case
name|LSC_ASSIGN
case|:
name|ld_output_create_element
argument_list|(
name|ld
argument_list|,
operator|&
name|lo
operator|->
name|lo_oelist
argument_list|,
name|OET_ASSIGN
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_ENTRY
case|:
name|ld_output_create_element
argument_list|(
name|ld
argument_list|,
operator|&
name|lo
operator|->
name|lo_oelist
argument_list|,
name|OET_ENTRY
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_SECTIONS_OUTPUT
case|:
name|_prepare_output_section
argument_list|(
name|ld
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_SECTIONS_OVERLAY
case|:
comment|/* TODO */
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Lay out each input object. */
name|STAILQ_FOREACH
argument_list|(
argument|li
argument_list|,
argument|&ld->ld_lilist
argument_list|,
argument|li_next
argument_list|)
block|{
comment|/* Only lay out relocatable input objects. */
if|if
condition|(
name|li
operator|->
name|li_type
operator|!=
name|LIT_RELOCATABLE
condition|)
continue|continue;
comment|/* Lay out sections for the input object. */
name|_layout_input_sections
argument_list|(
name|ld
argument_list|,
name|li
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_prepare_output_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_sections_output
modifier|*
name|ldso
parameter_list|)
block|{
name|struct
name|ld_script_cmd
modifier|*
name|ldc
decl_stmt|;
name|struct
name|ld_input_section_head
modifier|*
name|islist
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|struct
name|ld_output_element
modifier|*
name|oe
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|ldso
operator|->
name|ldso_name
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|!=
name|NULL
condition|)
return|return;
name|os
operator|=
name|ld_output_alloc_section
argument_list|(
name|ld
argument_list|,
name|ldso
operator|->
name|ldso_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_ldso
operator|=
name|ldso
expr_stmt|;
name|_set_output_section_loadable_flag
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ldc
argument_list|,
argument|&ldso->ldso_c
argument_list|,
argument|ldc_next
argument_list|)
block|{
switch|switch
condition|(
name|ldc
operator|->
name|ldc_type
condition|)
block|{
case|case
name|LSC_ASSERT
case|:
name|oe
operator|=
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_ASSERT
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_ASSIGN
case|:
name|oe
operator|=
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_ASSIGN
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_SECTIONS_OUTPUT_DATA
case|:
name|oe
operator|=
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_DATA
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_SECTIONS_OUTPUT_INPUT
case|:
name|islist
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|islist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|islist
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|islist
argument_list|)
expr_stmt|;
name|oe
operator|=
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_INPUT_SECTION_LIST
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|oe
operator|->
name|oe_islist
operator|=
name|islist
expr_stmt|;
break|break;
case|case
name|LSC_SECTIONS_OUTPUT_KEYWORD
case|:
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_KEYWORD
argument_list|,
name|ldc
operator|->
name|ldc_cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"internal: invalid output section "
literal|"command: %d"
argument_list|,
name|ldc
operator|->
name|ldc_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|_wildcard_match
parameter_list|(
name|struct
name|ld_wildcard
modifier|*
name|lw
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
operator|(
name|fnmatch
argument_list|(
name|lw
operator|->
name|lw_name
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_wildcard_list_match
parameter_list|(
name|struct
name|ld_script_list
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|ld_script_list
modifier|*
name|ldl
decl_stmt|;
for|for
control|(
name|ldl
operator|=
name|list
init|;
name|ldl
operator|!=
name|NULL
condition|;
name|ldl
operator|=
name|ldl
operator|->
name|ldl_next
control|)
if|if
condition|(
name|_wildcard_match
argument_list|(
name|ldl
operator|->
name|ldl_entry
argument_list|,
name|string
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_set_output_section_loadable_flag
parameter_list|(
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|)
block|{
name|struct
name|ld_script_sections_output
modifier|*
name|ldso
decl_stmt|;
name|struct
name|ld_exp
modifier|*
name|le
decl_stmt|;
if|if
condition|(
operator|(
name|ldso
operator|=
name|os
operator|->
name|os_ldso
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ldso
operator|->
name|ldso_vma
operator|==
name|NULL
condition|)
name|os
operator|->
name|os_flags
operator||=
name|SHF_ALLOC
expr_stmt|;
else|else
block|{
name|le
operator|=
name|ldso
operator|->
name|ldso_vma
expr_stmt|;
if|if
condition|(
name|le
operator|->
name|le_op
operator|!=
name|LEOP_CONSTANT
operator|||
name|le
operator|->
name|le_val
operator|!=
literal|0
condition|)
name|os
operator|->
name|os_flags
operator||=
name|SHF_ALLOC
expr_stmt|;
block|}
if|if
condition|(
name|ldso
operator|->
name|ldso_type
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|ldso
operator|->
name|ldso_type
argument_list|,
literal|"NOLOAD"
argument_list|)
operator|==
literal|0
condition|)
name|os
operator|->
name|os_flags
operator|&=
operator|~
name|SHF_ALLOC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|_check_filename_constraint
parameter_list|(
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|struct
name|ld_script_sections_output_input
modifier|*
name|ldoi
parameter_list|)
block|{
name|struct
name|ld_file
modifier|*
name|lf
decl_stmt|;
comment|/* Internal sections always suffice any constraint. */
if|if
condition|(
name|li
operator|->
name|li_name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|lf
operator|=
name|li
operator|->
name|li_file
expr_stmt|;
if|if
condition|(
name|ldoi
operator|->
name|ldoi_ar
operator|!=
name|NULL
operator|&&
name|li
operator|->
name|li_lam
operator|!=
name|NULL
operator|&&
operator|!
name|_wildcard_match
argument_list|(
name|ldoi
operator|->
name|ldoi_ar
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|assert
argument_list|(
name|ldoi
operator|->
name|ldoi_file
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_wildcard_match
argument_list|(
name|ldoi
operator|->
name|ldoi_file
argument_list|,
name|li
operator|->
name|li_name
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ldoi
operator|->
name|ldoi_exclude
operator|!=
name|NULL
operator|&&
name|_wildcard_list_match
argument_list|(
name|ldoi
operator|->
name|ldoi_exclude
argument_list|,
name|li
operator|->
name|li_name
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_record_wildcard_match
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|,
name|struct
name|ld_output_element
modifier|*
name|oe
parameter_list|)
block|{
name|struct
name|ld_wildcard_match
modifier|*
name|wm
decl_stmt|,
modifier|*
name|_wm
decl_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
operator|&&
name|os
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|oe
operator|!=
name|NULL
operator|&&
name|oe
operator|->
name|oe_type
operator|==
name|OET_INPUT_SECTION_LIST
argument_list|)
expr_stmt|;
name|HASH_FIND_STR
argument_list|(
name|ld
operator|->
name|ld_wm
argument_list|,
name|name
argument_list|,
name|wm
argument_list|)
expr_stmt|;
comment|/* Create a new wildcard match. */
if|if
condition|(
name|wm
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|wm
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wm
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wm
operator|->
name|wm_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|wm
operator|->
name|wm_os
operator|=
name|os
expr_stmt|;
name|wm
operator|->
name|wm_islist
operator|=
name|oe
operator|->
name|oe_islist
expr_stmt|;
name|wm
operator|->
name|wm_ldoi
operator|=
name|oe
operator|->
name|oe_entry
expr_stmt|;
name|wm
operator|->
name|wm_next
operator|=
name|NULL
expr_stmt|;
name|HASH_ADD_KEYPTR
argument_list|(
name|hh
argument_list|,
name|ld
operator|->
name|ld_wm
argument_list|,
name|wm
operator|->
name|wm_name
argument_list|,
name|strlen
argument_list|(
name|wm
operator|->
name|wm_name
argument_list|)
argument_list|,
name|wm
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Wildcard match already exist, compare the "ldoi" to check 	 * if this is a new wildcard match with a different file/archive 	 * constraint. If so, Insert it to the tail of the wildcard match 	 * list. 	 */
do|do
block|{
if|if
condition|(
name|oe
operator|->
name|oe_entry
operator|==
operator|(
name|void
operator|*
operator|)
name|wm
operator|->
name|wm_ldoi
condition|)
return|return;
block|}
do|while
condition|(
name|wm
operator|->
name|wm_next
operator|!=
name|NULL
operator|&&
operator|(
name|wm
operator|=
name|wm
operator|->
name|wm_next
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|_wm
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|_wm
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|_wm
operator|->
name|wm_os
operator|=
name|os
expr_stmt|;
name|_wm
operator|->
name|wm_islist
operator|=
name|oe
operator|->
name|oe_islist
expr_stmt|;
name|_wm
operator|->
name|wm_ldoi
operator|=
name|oe
operator|->
name|oe_entry
expr_stmt|;
name|_wm
operator|->
name|wm_next
operator|=
name|NULL
expr_stmt|;
name|wm
operator|->
name|wm_next
operator|=
name|_wm
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_record_wildcard_no_match
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ld_wildcard_match
modifier|*
name|wm
decl_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|HASH_FIND_STR
argument_list|(
name|ld
operator|->
name|ld_wm
argument_list|,
name|name
argument_list|,
name|wm
argument_list|)
expr_stmt|;
comment|/* 	 * Unfortunately this section is an orphan section because 	 * it doesn't satisfy the file/archive constraint but does 	 * match certain section name wildcard. We can not record this. 	 */
if|if
condition|(
name|wm
operator|!=
name|NULL
condition|)
return|return;
comment|/* Create the wildcard "no-match" for the orphan. */
if|if
condition|(
operator|(
name|wm
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wm
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wm
operator|->
name|wm_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|wm
operator|->
name|wm_no_match
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_layout_input_sections
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|struct
name|ld_output_element
modifier|*
name|oe
decl_stmt|;
name|struct
name|ld_wildcard_match
modifier|*
name|wm
decl_stmt|;
name|struct
name|ld_script_sections_output_input
modifier|*
name|ldoi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|li
operator|->
name|li_shnum
condition|;
name|i
operator|++
control|)
block|{
name|is
operator|=
operator|&
name|li
operator|->
name|li_is
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_type
operator|==
name|SHT_NULL
condition|)
continue|continue;
comment|/* Ignore discarded section groups. */
if|if
condition|(
name|is
operator|->
name|is_discard
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|is
operator|->
name|is_name
argument_list|,
literal|".shstrtab"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|is
operator|->
name|is_name
argument_list|,
literal|".symtab"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|is
operator|->
name|is_name
argument_list|,
literal|".strtab"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Search the wildcard match table for a quick match. */
name|HASH_FIND_STR
argument_list|(
name|ld
operator|->
name|ld_wm
argument_list|,
name|is
operator|->
name|is_name
argument_list|,
name|wm
argument_list|)
expr_stmt|;
if|if
condition|(
name|wm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wm
operator|->
name|wm_no_match
condition|)
block|{
comment|/* 				 * We found a "no-match". This is certainly 				 * an orphan section. 				 */
name|_layout_orphan_section
argument_list|(
name|ld
argument_list|,
name|is
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
goto|goto
name|full_search
goto|;
comment|/* There is a match! Verify file/archive constraint. */
while|while
condition|(
name|wm
operator|!=
name|NULL
condition|)
block|{
name|ldoi
operator|=
name|wm
operator|->
name|wm_ldoi
expr_stmt|;
if|if
condition|(
operator|!
name|_check_filename_constraint
argument_list|(
name|li
argument_list|,
name|ldoi
argument_list|)
condition|)
goto|goto
name|next_wm
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|wm
operator|->
name|wm_os
operator|->
name|os_name
argument_list|,
literal|"/DISCARD/"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_discard
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 			 * File/archive constraint satisfied. Insert the 			 * this section to the input section list of the 			 * output section element. 			 */
name|_insert_input_to_output
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|,
name|wm
operator|->
name|wm_os
argument_list|,
name|is
argument_list|,
name|wm
operator|->
name|wm_islist
argument_list|)
expr_stmt|;
break|break;
name|next_wm
label|:
name|wm
operator|=
name|wm
operator|->
name|wm_next
expr_stmt|;
block|}
if|if
condition|(
name|wm
operator|!=
name|NULL
condition|)
continue|continue;
name|full_search
label|:
comment|/* 		 * Otherwise, we have to do a full search for the section 		 * name in all the wildcard list. 		 */
name|STAILQ_FOREACH
argument_list|(
argument|os
argument_list|,
argument|&lo->lo_oslist
argument_list|,
argument|os_next
argument_list|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|oe
argument_list|,
argument|&os->os_e
argument_list|,
argument|oe_next
argument_list|)
block|{
if|if
condition|(
name|oe
operator|->
name|oe_type
operator|!=
name|OET_INPUT_SECTION_LIST
condition|)
continue|continue;
comment|/* 				 * Skip output sections created for orphan 				 * input sections. They don't have wildcard 				 * list. 				 */
if|if
condition|(
operator|(
name|ldoi
operator|=
name|oe
operator|->
name|oe_entry
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Check if the section name match wildcard */
name|assert
argument_list|(
name|ldoi
operator|->
name|ldoi_sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_wildcard_list_match
argument_list|(
name|ldoi
operator|->
name|ldoi_sec
argument_list|,
name|is
operator|->
name|is_name
argument_list|)
condition|)
continue|continue;
comment|/* 				 * Record this wildcard match to speed up 				 * wildcard match for sections with the same 				 * name. 				 */
name|_record_wildcard_match
argument_list|(
name|ld
argument_list|,
name|is
operator|->
name|is_name
argument_list|,
name|os
argument_list|,
name|oe
argument_list|)
expr_stmt|;
comment|/* Check file/archive constraint.  */
if|if
condition|(
operator|!
name|_check_filename_constraint
argument_list|(
name|li
argument_list|,
name|ldoi
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* Check if we should discard the section. */
if|if
condition|(
name|strcmp
argument_list|(
name|os
operator|->
name|os_name
argument_list|,
literal|"/DISCARD/"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|is
operator|->
name|is_discard
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_input_section
goto|;
block|}
comment|/* Match! Insert to the input section list. */
name|_insert_input_to_output
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|,
name|os
argument_list|,
name|is
argument_list|,
name|oe
operator|->
name|oe_islist
argument_list|)
expr_stmt|;
goto|goto
name|next_input_section
goto|;
block|}
block|}
comment|/* 		 * We found an orphan section. Record this so we can quickly 		 * identify other orphan sections with the same name. 		 */
name|_record_wildcard_no_match
argument_list|(
name|ld
argument_list|,
name|is
operator|->
name|is_name
argument_list|)
expr_stmt|;
comment|/* Lay out the orphan section. */
name|_layout_orphan_section
argument_list|(
name|ld
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|next_input_section
label|:
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_layout_orphan_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|)
block|{
name|struct
name|ld_input_section_head
modifier|*
name|islist
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_element
modifier|*
name|oe
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|,
modifier|*
name|_os
decl_stmt|;
comment|/* 	 * Layout the input sections that are not listed in the output 	 * section descriptor in the linker script. 	 */
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_discard
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|is
operator|->
name|is_name
argument_list|,
literal|".shstrtab"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|is
operator|->
name|is_name
argument_list|,
literal|".symtab"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|is
operator|->
name|is_name
argument_list|,
literal|".strtab"
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|is
operator|->
name|is_type
operator|==
name|SHT_REL
operator|||
name|is
operator|->
name|is_type
operator|==
name|SHT_RELA
operator|)
operator|&&
operator|!
name|is
operator|->
name|is_dynrel
condition|)
return|return;
comment|/* 	 * When garbage collection is enabled (option `-gc-sections' 	 * specified), remove sections that are not used. 	 */
if|if
condition|(
name|ld
operator|->
name|ld_gc
condition|)
block|{
if|if
condition|(
operator|(
name|is
operator|->
name|is_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|is
operator|->
name|is_refed
condition|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_gc_print
condition|)
name|ld_info
argument_list|(
name|ld
argument_list|,
literal|"Remove unused ection `%s' in "
literal|"file %s"
argument_list|,
name|is
operator|->
name|is_name
argument_list|,
name|ld_input_get_fullname
argument_list|(
name|ld
argument_list|,
name|is
operator|->
name|is_input
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|is
operator|->
name|is_name
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|!=
name|NULL
condition|)
block|{
name|oe
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|os
operator|->
name|os_e
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|oe
operator|!=
name|NULL
operator|&&
name|oe
operator|->
name|oe_type
operator|==
name|OET_INPUT_SECTION_LIST
argument_list|)
expr_stmt|;
name|_insert_input_to_output
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|,
name|os
argument_list|,
name|is
argument_list|,
name|oe
operator|->
name|oe_islist
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Create a new output secton and put it in a proper place, 	 * based on the section flag. 	 */
name|_os
operator|=
name|ld_layout_insert_output_section
argument_list|(
name|ld
argument_list|,
name|is
operator|->
name|is_name
argument_list|,
name|is
operator|->
name|is_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|islist
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|islist
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|islist
argument_list|)
expr_stmt|;
name|oe
operator|=
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|_os
argument_list|,
name|OET_INPUT_SECTION_LIST
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|oe
operator|->
name|oe_islist
operator|=
name|islist
expr_stmt|;
name|_insert_input_to_output
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|,
name|_os
argument_list|,
name|is
argument_list|,
name|oe
operator|->
name|oe_islist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ld_output_section
modifier|*
name|ld_layout_insert_output_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|flags
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|,
modifier|*
name|_os
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|os
argument_list|,
argument|&lo->lo_oslist
argument_list|,
argument|os_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|os
operator|->
name|os_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
operator|(
name|flags
operator|&
name|SHF_ALLOC
operator|)
condition|)
continue|continue;
if|if
condition|(
name|os
operator|->
name|os_flags
operator|==
name|flags
condition|)
block|{
name|_os
operator|=
name|STAILQ_NEXT
argument_list|(
name|os
argument_list|,
name|os_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|_os
operator|==
name|NULL
operator|||
name|_os
operator|->
name|os_flags
operator|!=
name|flags
condition|)
break|break;
block|}
name|_os
operator|=
name|STAILQ_NEXT
argument_list|(
name|os
argument_list|,
name|os_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|_os
operator|!=
name|NULL
operator|&&
operator|(
name|_os
operator|->
name|os_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
operator|(
name|flags
operator|&
name|SHF_ALLOC
operator|)
condition|)
break|break;
block|}
name|_os
operator|=
name|ld_output_alloc_section
argument_list|(
name|ld
argument_list|,
name|name
argument_list|,
name|os
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_os
operator|->
name|os_flags
operator||=
name|flags
operator|&
name|SHF_ALLOC
expr_stmt|;
return|return
operator|(
name|_os
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_insert_input_to_output
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|,
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_input_section_head
modifier|*
name|islist
parameter_list|)
block|{
name|struct
name|ld_output_section
modifier|*
name|_os
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 	 * Relocation sections is handled separately. 	 */
if|if
condition|(
operator|(
name|is
operator|->
name|is_type
operator|==
name|SHT_REL
operator|||
name|is
operator|->
name|is_type
operator|==
name|SHT_RELA
operator|)
operator|&&
operator|!
name|is
operator|->
name|is_dynrel
condition|)
return|return;
name|os
operator|->
name|os_empty
operator|=
literal|0
expr_stmt|;
name|os
operator|->
name|os_flags
operator||=
name|is
operator|->
name|is_flags
operator|&
operator|(
name|SHF_EXECINSTR
operator||
name|SHF_WRITE
operator||
name|SHF_TLS
operator|)
expr_stmt|;
name|os
operator|->
name|os_dynrel
operator||=
name|is
operator|->
name|is_dynrel
expr_stmt|;
name|os
operator|->
name|os_pltrel
operator||=
name|is
operator|->
name|is_pltrel
expr_stmt|;
if|if
condition|(
operator|!
name|is
operator|->
name|is_dynrel
operator|&&
operator|!
name|is
operator|->
name|is_pltrel
operator|&&
name|is
operator|->
name|is_type
operator|!=
name|SHT_NOBITS
operator|&&
name|is
operator|->
name|is_size
operator|!=
literal|0
condition|)
name|is
operator|->
name|is_need_reloc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_align
operator|>
name|os
operator|->
name|os_align
condition|)
name|os
operator|->
name|os_align
operator|=
name|is
operator|->
name|is_align
expr_stmt|;
comment|/* 	 * The entsize of the output section is determined by the 	 * input sections it contains. If all the input sections has 	 * the same entsize, the output section will also have that 	 * entsize. If any input section has a different entsize, 	 * the entsize for output section is set to 0, meaning that 	 * it has variable entry sizes. 	 */
if|if
condition|(
operator|!
name|os
operator|->
name|os_entsize_set
condition|)
block|{
name|os
operator|->
name|os_entsize
operator|=
name|is
operator|->
name|is_entsize
expr_stmt|;
name|os
operator|->
name|os_entsize_set
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|os
operator|->
name|os_entsize
operator|!=
name|is
operator|->
name|is_entsize
condition|)
name|os
operator|->
name|os_entsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_type
operator|==
name|SHT_NULL
condition|)
name|os
operator|->
name|os_type
operator|=
name|is
operator|->
name|is_type
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_type
operator|==
name|SHT_NOTE
condition|)
name|lo
operator|->
name|lo_phdr_note
operator|=
literal|1
expr_stmt|;
name|is
operator|->
name|is_output
operator|=
name|os
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|islist
argument_list|,
name|is
argument_list|,
name|is_next
argument_list|)
expr_stmt|;
comment|/* 	 * Lay out relocation section for this input section if the linker 	 * creates relocatable output object or if -emit-relocs option is 	 * sepcified. 	 */
if|if
condition|(
operator|(
name|ld
operator|->
name|ld_reloc
operator|||
name|ld
operator|->
name|ld_emit_reloc
operator|)
operator|&&
name|is
operator|->
name|is_ris
operator|!=
name|NULL
operator|&&
name|is
operator|->
name|is_ris
operator|->
name|is_num_reloc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|os_r
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Create relocation section for output sections. 			 */
if|if
condition|(
name|ld
operator|->
name|ld_arch
operator|->
name|reloc_is_rela
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|os
operator|->
name|os_name
argument_list|)
operator|+
literal|6
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
literal|".rela%s"
argument_list|,
name|os
operator|->
name|os_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|os
operator|->
name|os_name
argument_list|)
operator|+
literal|5
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
literal|".rel%s"
argument_list|,
name|os
operator|->
name|os_name
argument_list|)
expr_stmt|;
block|}
name|_os
operator|=
name|ld_output_alloc_section
argument_list|(
name|ld
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|_os
operator|->
name|os_rel
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Fill in entry size, alignment and type for output 			 * relocation sections. 			 */
name|_os
operator|->
name|os_entsize
operator|=
name|ld
operator|->
name|ld_arch
operator|->
name|reloc_entsize
expr_stmt|;
name|_os
operator|->
name|os_type
operator|=
name|ld
operator|->
name|ld_arch
operator|->
name|reloc_is_rela
condition|?
name|SHT_RELA
else|:
name|SHT_REL
expr_stmt|;
name|_os
operator|->
name|os_align
operator|=
name|ld
operator|->
name|ld_arch
operator|->
name|reloc_is_64bit
condition|?
literal|8
else|:
literal|4
expr_stmt|;
comment|/* Setup sh_link and sh_info. */
if|if
condition|(
operator|(
name|_os
operator|->
name|os_link
operator|=
name|strdup
argument_list|(
literal|".symtab"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|_os
operator|->
name|os_info
operator|=
name|os
expr_stmt|;
comment|/* Relocation sections are not allocated in memory. */
name|_os
operator|->
name|os_addr
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|_os
operator|=
name|os
operator|->
name|os_r
expr_stmt|;
name|_os
operator|->
name|os_size
operator|+=
name|is
operator|->
name|is_ris
operator|->
name|is_num_reloc
operator|*
name|_os
operator|->
name|os_entsize
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_parse_output_section_descriptor
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|)
block|{
name|struct
name|ld_script_sections_output
modifier|*
name|ldso
decl_stmt|;
if|if
condition|(
operator|(
name|ldso
operator|=
name|os
operator|->
name|os_ldso
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ldso
operator|->
name|ldso_vma
operator|!=
name|NULL
condition|)
name|os
operator|->
name|os_addr
operator|=
name|ld_exp_eval
argument_list|(
name|ld
argument_list|,
name|ldso
operator|->
name|ldso_vma
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldso
operator|->
name|ldso_lma
operator|!=
name|NULL
condition|)
name|os
operator|->
name|os_lma
operator|=
name|ld_exp_eval
argument_list|(
name|ld
argument_list|,
name|ldso
operator|->
name|ldso_lma
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldso
operator|->
name|ldso_align
operator|!=
name|NULL
condition|)
name|os
operator|->
name|os_align
operator|=
name|ld_exp_eval
argument_list|(
name|ld
argument_list|,
name|ldso
operator|->
name|ldso_align
argument_list|)
expr_stmt|;
comment|/* TODO: handle other output section parameters. */
block|}
end_function

begin_function
specifier|static
name|void
name|_calc_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_element
modifier|*
name|oe
decl_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|ls
operator|->
name|ls_loc_counter
operator|=
literal|0
expr_stmt|;
name|ls
operator|->
name|ls_offset
operator|=
name|ld_layout_calc_header_size
argument_list|(
name|ld
argument_list|)
expr_stmt|;
name|ls
operator|->
name|ls_first_output_sec
operator|=
literal|1
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|oe
argument_list|,
argument|&lo->lo_oelist
argument_list|,
argument|oe_next
argument_list|)
block|{
switch|switch
condition|(
name|oe
operator|->
name|oe_type
condition|)
block|{
case|case
name|OET_ASSERT
case|:
comment|/* TODO */
break|break;
case|case
name|OET_ASSIGN
case|:
name|ld_script_process_assign
argument_list|(
name|ld
argument_list|,
name|oe
operator|->
name|oe_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|OET_ENTRY
case|:
name|ld_script_process_entry
argument_list|(
name|ld
argument_list|,
name|oe
operator|->
name|oe_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|OET_OUTPUT_SECTION
case|:
name|_parse_output_section_descriptor
argument_list|(
name|ld
argument_list|,
name|oe
operator|->
name|oe_entry
argument_list|)
expr_stmt|;
name|_calc_output_section_offset
argument_list|(
name|ld
argument_list|,
name|oe
operator|->
name|oe_entry
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Emit .note.GNU-stack section for reloctable output object. */
if|if
condition|(
name|ld
operator|->
name|ld_gen_gnustack
operator|&&
name|ld
operator|->
name|ld_reloc
condition|)
name|ld_output_emit_gnu_stack_section
argument_list|(
name|ld
argument_list|)
expr_stmt|;
comment|/* Lay out section header table after normal input sections. */
name|_calc_shdr_offset
argument_list|(
name|ld
argument_list|)
expr_stmt|;
comment|/* Create .shstrtab section and put it after section header table. */
name|ld_output_create_string_table_section
argument_list|(
name|ld
argument_list|,
literal|".shstrtab"
argument_list|,
name|ld
operator|->
name|ld_shstrtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Lay out relocation sections. */
if|if
condition|(
name|ld
operator|->
name|ld_reloc
operator|||
name|ld
operator|->
name|ld_emit_reloc
condition|)
name|_calc_reloc_section_offset
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_calc_output_section_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output_section
modifier|*
name|os
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_output_element
modifier|*
name|oe
decl_stmt|;
name|struct
name|ld_output_data_buffer
modifier|*
name|odb
decl_stmt|;
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|struct
name|ld_input_section_head
modifier|*
name|islist
decl_stmt|;
name|struct
name|ld_symbol_table
modifier|*
name|sy
decl_stmt|;
name|struct
name|ld_strtab
modifier|*
name|st
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
comment|/* Relocation sections are handled separately. */
if|if
condition|(
name|os
operator|->
name|os_rel
condition|)
return|return;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
comment|/* 	 * Position independent output object should have VMA from 0. 	 * So if we are building a DSO or PIE, and this output section is 	 * the first one, we should set current VMA to SIZEOF_HEADERS 	 * and ignore all the previous assignments to the location counter. 	 */
if|if
condition|(
operator|(
name|ld
operator|->
name|ld_dso
operator|||
name|ld
operator|->
name|ld_pie
operator|)
operator|&&
name|ls
operator|->
name|ls_first_output_sec
condition|)
block|{
name|ls
operator|->
name|ls_loc_counter
operator|=
name|ld_layout_calc_header_size
argument_list|(
name|ld
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|os
operator|->
name|os_empty
condition|)
name|ls
operator|->
name|ls_first_output_sec
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Location counter stores the end VMA offset of the previous output 	 * section. We use that value as the base VMA offset for this output 	 * section. 	 */
name|addr
operator|=
name|ls
operator|->
name|ls_loc_counter
expr_stmt|;
comment|/* 	 * Location counter when refered inside an output section descriptor, 	 * is an offset relative to the start of the section. 	 */
name|ls
operator|->
name|ls_loc_counter
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|oe
argument_list|,
argument|&os->os_e
argument_list|,
argument|oe_next
argument_list|)
block|{
switch|switch
condition|(
name|oe
operator|->
name|oe_type
condition|)
block|{
case|case
name|OET_ASSERT
case|:
comment|/* TODO */
break|break;
case|case
name|OET_ASSIGN
case|:
name|ld_script_process_assign
argument_list|(
name|ld
argument_list|,
name|oe
operator|->
name|oe_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|OET_DATA
case|:
comment|/* TODO */
break|break;
case|case
name|OET_DATA_BUFFER
case|:
name|odb
operator|=
name|oe
operator|->
name|oe_entry
expr_stmt|;
name|odb
operator|->
name|odb_off
operator|=
name|roundup
argument_list|(
name|ls
operator|->
name|ls_loc_counter
argument_list|,
name|odb
operator|->
name|odb_align
argument_list|)
expr_stmt|;
name|ls
operator|->
name|ls_loc_counter
operator|=
name|odb
operator|->
name|odb_off
operator|+
name|odb
operator|->
name|odb_size
expr_stmt|;
break|break;
case|case
name|OET_ENTRY
case|:
name|ld_script_process_entry
argument_list|(
name|ld
argument_list|,
name|oe
operator|->
name|oe_entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|OET_INPUT_SECTION_LIST
case|:
name|islist
operator|=
name|oe
operator|->
name|oe_islist
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|is
argument_list|,
argument|islist
argument_list|,
argument|is_next
argument_list|)
block|{
if|if
condition|(
name|is
operator|->
name|is_size
operator|==
literal|0
condition|)
continue|continue;
name|is
operator|->
name|is_reloff
operator|=
name|roundup
argument_list|(
name|ls
operator|->
name|ls_loc_counter
argument_list|,
name|is
operator|->
name|is_align
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("\t%s(%s): %#jx,%#jx(%#jx)\n", 				    is->is_input->li_name, 				    is->is_name, is->is_reloff, 				    is->is_size, is->is_align);
endif|#
directive|endif
name|ls
operator|->
name|ls_loc_counter
operator|=
name|is
operator|->
name|is_reloff
operator|+
name|is
operator|->
name|is_size
expr_stmt|;
block|}
break|break;
case|case
name|OET_KEYWORD
case|:
comment|/* TODO */
break|break;
case|case
name|OET_SYMTAB
case|:
name|assert
argument_list|(
name|ls
operator|->
name|ls_loc_counter
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sy
operator|=
name|oe
operator|->
name|oe_entry
expr_stmt|;
name|ls
operator|->
name|ls_loc_counter
operator|=
name|sy
operator|->
name|sy_size
operator|*
name|os
operator|->
name|os_entsize
expr_stmt|;
break|break;
case|case
name|OET_STRTAB
case|:
name|assert
argument_list|(
name|ls
operator|->
name|ls_loc_counter
operator|==
literal|0
argument_list|)
expr_stmt|;
name|st
operator|=
name|oe
operator|->
name|oe_entry
expr_stmt|;
name|ls
operator|->
name|ls_loc_counter
operator|=
name|ld_strtab_getsize
argument_list|(
name|st
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * Properly align section vma and offset to the required section 	 * alignment. 	 */
if|if
condition|(
operator|(
name|os
operator|->
name|os_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|ld
operator|->
name|ld_reloc
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|os_ldso
operator|==
name|NULL
operator|||
name|os
operator|->
name|os_ldso
operator|->
name|ldso_vma
operator|==
name|NULL
condition|)
name|os
operator|->
name|os_addr
operator|=
name|roundup
argument_list|(
name|addr
argument_list|,
name|os
operator|->
name|os_align
argument_list|)
expr_stmt|;
block|}
else|else
name|os
operator|->
name|os_addr
operator|=
literal|0
expr_stmt|;
name|os
operator|->
name|os_off
operator|=
name|roundup
argument_list|(
name|ls
operator|->
name|ls_offset
argument_list|,
name|os
operator|->
name|os_align
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_size
operator|=
name|ls
operator|->
name|ls_loc_counter
expr_stmt|;
if|#
directive|if
literal|0
block|printf("layout output section %s: (off:%#jx,size:%#jx) " 	    "vma:%#jx,align:%#jx\n", os->os_name, os->os_off, os->os_size, 	    os->os_addr, os->os_align);
endif|#
directive|endif
comment|/* 	 * Calculate the file offset for the next output section. Note that 	 * only sections with type other than SHT_NOBITS consume file space. 	 */
name|ls
operator|->
name|ls_offset
operator|=
name|os
operator|->
name|os_off
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_type
operator|!=
name|SHT_NOBITS
condition|)
name|ls
operator|->
name|ls_offset
operator|+=
name|os
operator|->
name|os_size
expr_stmt|;
comment|/* Reset location counter to the current VMA. */
if|if
condition|(
name|os
operator|->
name|os_flags
operator|&
name|SHF_ALLOC
condition|)
block|{
name|ls
operator|->
name|ls_loc_counter
operator|=
name|os
operator|->
name|os_addr
expr_stmt|;
comment|/* 		 * Do not allocate VMA for TLS .tbss sections. TLS sections 		 * are only used as an initialization image and .tbss section 		 * will not be allocated in memory. 		 */
if|if
condition|(
name|os
operator|->
name|os_type
operator|!=
name|SHT_NOBITS
operator|||
operator|(
name|os
operator|->
name|os_flags
operator|&
name|SHF_TLS
operator|)
operator|==
literal|0
condition|)
name|ls
operator|->
name|ls_loc_counter
operator|+=
name|os
operator|->
name|os_size
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_calc_reloc_section_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|,
modifier|*
name|_os
decl_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|os
argument_list|,
argument|&lo->lo_oslist
argument_list|,
argument|os_next
argument_list|)
block|{
if|if
condition|(
name|os
operator|->
name|os_r
operator|!=
name|NULL
condition|)
block|{
name|_os
operator|=
name|os
operator|->
name|os_r
expr_stmt|;
name|_os
operator|->
name|os_off
operator|=
name|roundup
argument_list|(
name|ls
operator|->
name|ls_offset
argument_list|,
name|_os
operator|->
name|os_align
argument_list|)
expr_stmt|;
name|ls
operator|->
name|ls_offset
operator|=
name|_os
operator|->
name|os_off
operator|+
name|_os
operator|->
name|os_size
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_calc_shdr_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|uint64_t
name|shoff
decl_stmt|;
name|int
name|n
decl_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|)
name|shoff
operator|=
name|roundup
argument_list|(
name|ls
operator|->
name|ls_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|shoff
operator|=
name|roundup
argument_list|(
name|ls
operator|->
name|ls_offset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ls
operator|->
name|ls_offset
operator|=
name|shoff
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|os
argument_list|,
argument|&lo->lo_oslist
argument_list|,
argument|os_next
argument_list|)
block|{
if|if
condition|(
name|os
operator|->
name|os_scn
operator|!=
name|NULL
condition|)
name|n
operator|++
expr_stmt|;
block|}
comment|/* TODO: n + 2 if ld(1) will not create symbol table. */
name|ls
operator|->
name|ls_offset
operator|+=
name|gelf_fsize
argument_list|(
name|lo
operator|->
name|lo_elf
argument_list|,
name|ELF_T_SHDR
argument_list|,
name|n
operator|+
literal|4
argument_list|,
name|EV_CURRENT
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_shoff
operator|=
name|shoff
expr_stmt|;
block|}
end_function

end_unit

