begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012,2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ld_arch.h"
end_include

begin_include
include|#
directive|include
file|"ld_dynamic.h"
end_include

begin_include
include|#
directive|include
file|"ld_input.h"
end_include

begin_include
include|#
directive|include
file|"ld_output.h"
end_include

begin_include
include|#
directive|include
file|"ld_reloc.h"
end_include

begin_include
include|#
directive|include
file|"ld_symbols.h"
end_include

begin_include
include|#
directive|include
file|"ld_utils.h"
end_include

begin_include
include|#
directive|include
file|"i386.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: i386.c 2967 2013-10-12 23:58:13Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|_create_plt_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_got_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|type
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_copy_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_dynamic_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|type
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_scan_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_got_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_gotplt_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_plt_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_get_max_page_size
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_get_common_page_size
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_process_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|_reloc2str
parameter_list|(
name|uint64_t
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_reserve_got_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_reserve_gotplt_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_reserve_plt_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_is_absolute_reloc
parameter_list|(
name|uint64_t
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_is_relative_reloc
parameter_list|(
name|uint64_t
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_warn_pic
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|_got_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|uint64_t
name|_get_max_page_size
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ld
expr_stmt|;
return|return
operator|(
literal|0x1000
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_get_common_page_size
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ld
expr_stmt|;
return|return
operator|(
literal|0x1000
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_reloc2str
parameter_list|(
name|uint64_t
name|r
parameter_list|)
block|{
specifier|static
name|char
name|s
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"R_386_NONE"
return|;
case|case
literal|1
case|:
return|return
literal|"R_386_32"
return|;
case|case
literal|2
case|:
return|return
literal|"R_386_PC32"
return|;
case|case
literal|3
case|:
return|return
literal|"R_386_GOT32"
return|;
case|case
literal|4
case|:
return|return
literal|"R_386_PLT32"
return|;
case|case
literal|5
case|:
return|return
literal|"R_386_COPY"
return|;
case|case
literal|6
case|:
return|return
literal|"R_386_GLOB_DAT"
return|;
case|case
literal|7
case|:
return|return
literal|"R_386_JMP_SLOT"
return|;
case|case
literal|8
case|:
return|return
literal|"R_386_RELATIVE"
return|;
case|case
literal|9
case|:
return|return
literal|"R_386_GOTOFF"
return|;
case|case
literal|10
case|:
return|return
literal|"R_386_GOTPC"
return|;
case|case
literal|14
case|:
return|return
literal|"R_386_TLS_TPOFF"
return|;
case|case
literal|15
case|:
return|return
literal|"R_386_TLS_IE"
return|;
case|case
literal|16
case|:
return|return
literal|"R_386_TLS_GOTI"
return|;
case|case
literal|17
case|:
return|return
literal|"R_386_TLS_LE"
return|;
case|case
literal|18
case|:
return|return
literal|"R_386_TLS_GD"
return|;
case|case
literal|19
case|:
return|return
literal|"R_386_TLS_LDM"
return|;
case|case
literal|24
case|:
return|return
literal|"R_386_TLS_GD_32"
return|;
case|case
literal|25
case|:
return|return
literal|"R_386_TLS_GD_PUSH"
return|;
case|case
literal|26
case|:
return|return
literal|"R_386_TLS_GD_CALL"
return|;
case|case
literal|27
case|:
return|return
literal|"R_386_TLS_GD_POP"
return|;
case|case
literal|28
case|:
return|return
literal|"R_386_TLS_LDM_32"
return|;
case|case
literal|29
case|:
return|return
literal|"R_386_TLS_LDM_PUSH"
return|;
case|case
literal|30
case|:
return|return
literal|"R_386_TLS_LDM_CALL"
return|;
case|case
literal|31
case|:
return|return
literal|"R_386_TLS_LDM_POP"
return|;
case|case
literal|32
case|:
return|return
literal|"R_386_TLS_LDO_32"
return|;
case|case
literal|33
case|:
return|return
literal|"R_386_TLS_IE_32"
return|;
case|case
literal|34
case|:
return|return
literal|"R_386_TLS_LE_32"
return|;
case|case
literal|35
case|:
return|return
literal|"R_386_TLS_DTPMOD32"
return|;
case|case
literal|36
case|:
return|return
literal|"R_386_TLS_DTPOFF32"
return|;
case|case
literal|37
case|:
return|return
literal|"R_386_TLS_TPOFF32"
return|;
default|default:
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"<unkown: %ju>"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|_is_absolute_reloc
parameter_list|(
name|uint64_t
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|==
name|R_386_32
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_is_relative_reloc
parameter_list|(
name|uint64_t
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|==
name|R_386_RELATIVE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_warn_pic
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
name|lsb
operator|=
name|lre
operator|->
name|lre_sym
expr_stmt|;
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|!=
name|STB_LOCAL
condition|)
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"relocation %s against `%s' can not be used"
literal|" by runtime linker; recompile with -fPIC"
argument_list|,
name|_reloc2str
argument_list|(
name|lre
operator|->
name|lre_type
argument_list|)
argument_list|,
name|lsb
operator|->
name|lsb_name
argument_list|)
expr_stmt|;
else|else
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"relocation %s can not be used by runtime linker;"
literal|" recompile with -fPIC"
argument_list|,
name|_reloc2str
argument_list|(
name|lre
operator|->
name|lre_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_got_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
comment|/* Check if the GOT section is already created. */
name|is
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
return|return
operator|(
name|is
operator|)
return|;
if|if
condition|(
name|create
condition|)
block|{
name|is
operator|=
name|ld_input_add_internal_section
argument_list|(
name|ld
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_entsize
operator|=
literal|4
expr_stmt|;
name|is
operator|->
name|is_align
operator|=
literal|4
expr_stmt|;
name|is
operator|->
name|is_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|is
operator|->
name|is_flags
operator|=
name|SHF_ALLOC
operator||
name|SHF_WRITE
expr_stmt|;
block|}
return|return
operator|(
name|is
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_gotplt_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
comment|/* Check if the GOT (for PLT) section is already created. */
name|is
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
return|return
operator|(
name|is
operator|)
return|;
if|if
condition|(
name|create
condition|)
block|{
name|is
operator|=
name|ld_input_add_internal_section
argument_list|(
name|ld
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_entsize
operator|=
literal|4
expr_stmt|;
name|is
operator|->
name|is_align
operator|=
literal|4
expr_stmt|;
name|is
operator|->
name|is_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|is
operator|->
name|is_flags
operator|=
name|SHF_ALLOC
operator||
name|SHF_WRITE
expr_stmt|;
comment|/* Reserve space for the initial entries. */
operator|(
name|void
operator|)
name|ld_input_reserve_ibuf
argument_list|(
name|is
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Create _GLOBAL_OFFSET_TABLE_ symbol. */
name|ld_symbols_add_internal
argument_list|(
name|ld
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|is
operator|->
name|is_index
argument_list|,
name|STB_LOCAL
argument_list|,
name|STT_OBJECT
argument_list|,
name|STV_HIDDEN
argument_list|,
name|is
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|is
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_input_section
modifier|*
name|_find_and_create_plt_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
comment|/* Check if the PLT section is already created. */
name|is
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
return|return
operator|(
name|is
operator|)
return|;
if|if
condition|(
name|create
condition|)
block|{
name|is
operator|=
name|ld_input_add_internal_section
argument_list|(
name|ld
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|is
operator|->
name|is_entsize
operator|=
literal|4
expr_stmt|;
name|is
operator|->
name|is_align
operator|=
literal|4
expr_stmt|;
name|is
operator|->
name|is_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|is
operator|->
name|is_flags
operator|=
name|SHF_ALLOC
operator||
name|SHF_EXECINSTR
expr_stmt|;
comment|/* Reserve space for the initial entry. */
operator|(
name|void
operator|)
name|ld_input_reserve_ibuf
argument_list|(
name|is
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|is
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_reserve_got_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|_find_and_create_got_section
argument_list|(
name|ld
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check if the entry already has a GOT entry. */
if|if
condition|(
name|lsb
operator|->
name|lsb_got
condition|)
return|return;
comment|/* Reserve GOT entries. */
name|lsb
operator|->
name|lsb_got_off
operator|=
name|ld_input_reserve_ibuf
argument_list|(
name|is
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_got
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_reserve_gotplt_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|uint64_t
name|off
decl_stmt|;
name|is
operator|=
name|_find_and_create_gotplt_section
argument_list|(
name|ld
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Reserve a GOT entry for PLT. */
name|off
operator|=
name|ld_input_reserve_ibuf
argument_list|(
name|is
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Record a R_386_JMP_SLOT entry for this symbol. Note that 	 * we don't need to record the offset (relative to the GOT section) 	 * here, since the PLT relocations will be sorted later and we 	 * will generate GOT section according to the new order. 	 */
name|_create_plt_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_reserve_plt_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|_find_and_create_plt_section
argument_list|(
name|ld
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ld_input_reserve_ibuf
argument_list|(
name|is
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_plt
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_plt_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rel.plt"
argument_list|,
name|NULL
argument_list|,
name|R_386_JMP_SLOT
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_dynrel
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_got_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|type
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|tis
decl_stmt|;
name|tis
operator|=
name|_find_and_create_got_section
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tis
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rel.got"
argument_list|,
name|tis
argument_list|,
name|type
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|R_386_RELATIVE
condition|)
name|lsb
operator|->
name|lsb_dynrel
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_copy_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_input_section
modifier|*
name|tis
decl_stmt|;
name|ld_dynamic_reserve_dynbss_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|tis
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tis
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rel.bss"
argument_list|,
name|tis
argument_list|,
name|R_386_COPY
argument_list|,
name|lsb
argument_list|,
name|lsb
operator|->
name|lsb_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_dynrel
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_dynamic_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint64_t
name|type
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|==
name|STB_LOCAL
condition|)
block|{
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
name|SHF_WRITE
condition|)
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rel.data.rel.local"
argument_list|,
name|is
argument_list|,
name|type
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rel.data.rel.ro.local"
argument_list|,
name|is
argument_list|,
name|type
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is
operator|->
name|is_flags
operator|&
name|SHF_WRITE
condition|)
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rel.data.rel"
argument_list|,
name|is
argument_list|,
name|type
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ld_reloc_create_entry
argument_list|(
name|ld
argument_list|,
literal|".rel.data.rel.ro"
argument_list|,
name|is
argument_list|,
name|type
argument_list|,
name|lsb
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|R_386_RELATIVE
condition|)
name|lsb
operator|->
name|lsb_dynrel
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_scan_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|)
block|{
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
name|lsb
operator|=
name|ld_symbols_ref
argument_list|(
name|lre
operator|->
name|lre_sym
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lre
operator|->
name|lre_type
condition|)
block|{
case|case
name|R_386_NONE
case|:
break|break;
case|case
name|R_386_32
case|:
comment|/* 		 * For a local symbol, if te linker output a PIE or DSO, 		 * we should generate a R_386_RELATIVE reloc for R_386_32. 		 */
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|==
name|STB_LOCAL
condition|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_pie
operator|||
name|ld
operator|->
name|ld_dso
condition|)
name|_create_dynamic_reloc
argument_list|(
name|ld
argument_list|,
name|is
argument_list|,
name|lsb
argument_list|,
name|R_386_RELATIVE
argument_list|,
name|lre
operator|->
name|lre_offset
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * For a global symbol, we probably need to generate PLE entry 		 * and/ore a dynamic relocation. 		 * 		 * Note here, normally the compiler will generate a PC-relative 		 * relocation for function calls. However, if the code retrieve 		 * the address of a function and call it indirectly, assembler 		 * will generate absolute relocation instead. That's why we 		 * should check if we need to create a PLT entry here. Also, if 		 * we're going to create the PLT entry, we should also set the 		 * symbol value to the address of PLT entry just in case the 		 * function address is used to compare with other function 		 * addresses. (If PLT address is used, function will have 		 * unified address in the main executable and DSOs) 		 */
if|if
condition|(
name|ld_reloc_require_plt
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|lsb
operator|->
name|lsb_plt
condition|)
block|{
name|_reserve_gotplt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|_reserve_plt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Note here even if we have generated PLT for this 			 * function before, we still need to set this flag. 			 * It's possible that we first see the relative 			 * relocation then this absolute relocation, in 			 * other words, the same function can be called in 			 * different ways. 			 */
name|lsb
operator|->
name|lsb_func_addr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ld_reloc_require_copy_reloc
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
operator|&&
operator|!
name|lsb
operator|->
name|lsb_copy_reloc
condition|)
name|_create_copy_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ld_reloc_require_dynamic_reloc
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
block|{
comment|/* 			 * Check if we can relax R_386_32 to 			 * R_386_RELATIVE instead. 			 */
if|if
condition|(
name|ld_reloc_relative_relax
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
name|_create_dynamic_reloc
argument_list|(
name|ld
argument_list|,
name|is
argument_list|,
name|lsb
argument_list|,
name|R_386_RELATIVE
argument_list|,
name|lre
operator|->
name|lre_offset
argument_list|)
expr_stmt|;
else|else
name|_create_dynamic_reloc
argument_list|(
name|ld
argument_list|,
name|is
argument_list|,
name|lsb
argument_list|,
name|R_386_32
argument_list|,
name|lre
operator|->
name|lre_offset
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_386_PLT32
case|:
comment|/* 		 * In some cases we don't really need to generate a PLT 		 * entry, then a R_386_PLT32 relocation can be relaxed 		 * to a R_386_PC32 relocation. 		 */
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|==
name|STB_LOCAL
operator|||
operator|!
name|ld_reloc_require_plt
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
block|{
name|lre
operator|->
name|lre_type
operator|=
name|R_386_PC32
expr_stmt|;
break|break;
block|}
comment|/* 		 * If linker outputs an normal executable and the symbol is 		 * defined but is not defined inside a DSO, we can generate 		 * a R_386_PC32 relocation instead. 		 */
if|if
condition|(
name|ld
operator|->
name|ld_exec
operator|&&
name|lsb
operator|->
name|lsb_shndx
operator|!=
name|SHN_UNDEF
operator|&&
operator|(
name|lsb
operator|->
name|lsb_input
operator|==
name|NULL
operator|||
name|lsb
operator|->
name|lsb_input
operator|->
name|li_type
operator|!=
name|LIT_DSO
operator|)
condition|)
block|{
name|lre
operator|->
name|lre_type
operator|=
name|R_386_PC32
expr_stmt|;
break|break;
block|}
comment|/* Create an PLT entry otherwise. */
if|if
condition|(
operator|!
name|lsb
operator|->
name|lsb_plt
condition|)
block|{
name|_reserve_gotplt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|_reserve_plt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_386_PC32
case|:
comment|/* 		 * When R_386_PC32 apply to a global symbol, we should 		 * check if we need to generate PLT entry and/or a dynamic 		 * relocation. 		 */
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|!=
name|STB_LOCAL
condition|)
block|{
if|if
condition|(
name|ld_reloc_require_plt
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
operator|&&
operator|!
name|lsb
operator|->
name|lsb_plt
condition|)
block|{
name|_reserve_gotplt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|_reserve_plt_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ld_reloc_require_copy_reloc
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
operator|&&
operator|!
name|lsb
operator|->
name|lsb_copy_reloc
condition|)
name|_create_copy_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ld_reloc_require_dynamic_reloc
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
block|{
comment|/* 				 * We can not generate dynamic relocation for 				 * these PC-relative relocation since they 				 * are probably not supported by the runtime 				 * linkers. 				 */
name|_warn_pic
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_386_GOTOFF
case|:
case|case
name|R_386_GOTPC
case|:
comment|/* 		 * These relocation types use GOT address as a base address 		 * and instruct the linker to build a GOT. 		 */
operator|(
name|void
operator|)
name|_find_and_create_got_section
argument_list|(
name|ld
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_386_GOT32
case|:
comment|/* 		 * R_386_GOT32 relocation instructs the linker to build a 		 * GOT and generate a GOT entry. 		 */
if|if
condition|(
operator|!
name|lsb
operator|->
name|lsb_got
condition|)
block|{
name|_reserve_got_entry
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * TODO: For now we always create a R_386_GLOB_DAT 			 * relocation for a GOT entry. There are cases that 			 * the symbol's address is known at link time and 			 * the GOT entry value can be filled in by the program 			 * linker instead. 			 */
if|if
condition|(
name|ld_reloc_require_glob_dat
argument_list|(
name|ld
argument_list|,
name|lre
argument_list|)
condition|)
name|_create_got_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
name|R_386_GLOB_DAT
argument_list|,
name|lsb
operator|->
name|lsb_got_off
argument_list|)
expr_stmt|;
else|else
name|_create_got_reloc
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|,
name|R_386_RELATIVE
argument_list|,
name|lsb
operator|->
name|lsb_got_off
argument_list|)
expr_stmt|;
block|}
default|default:
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"can not handle relocation %ju"
argument_list|,
name|lre
operator|->
name|lre_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|_got_offset
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|assert
argument_list|(
name|lsb
operator|->
name|lsb_got
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_got
operator|==
name|NULL
condition|)
block|{
name|ld
operator|->
name|ld_got
operator|=
name|_find_and_create_got_section
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ld
operator|->
name|ld_got
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|os
operator|=
name|ld
operator|->
name|ld_got
operator|->
name|is_output
expr_stmt|;
return|return
operator|(
name|os
operator|->
name|os_addr
operator|+
name|ld
operator|->
name|ld_got
operator|->
name|is_reloff
operator|+
name|lsb
operator|->
name|lsb_got_off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_process_reloc
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input_section
modifier|*
name|is
parameter_list|,
name|struct
name|ld_reloc_entry
modifier|*
name|lre
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|uint32_t
name|p
decl_stmt|,
name|s
decl_stmt|,
name|l
decl_stmt|,
name|g
decl_stmt|,
name|got
decl_stmt|;
name|int32_t
name|a
decl_stmt|,
name|v
decl_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|l
operator|=
name|lsb
operator|->
name|lsb_plt_off
expr_stmt|;
name|p
operator|=
name|lre
operator|->
name|lre_offset
operator|+
name|is
operator|->
name|is_output
operator|->
name|os_addr
operator|+
name|is
operator|->
name|is_reloff
expr_stmt|;
name|got
operator|=
name|ld
operator|->
name|ld_got
operator|->
name|is_output
operator|->
name|os_addr
expr_stmt|;
name|s
operator|=
operator|(
name|uint32_t
operator|)
name|lsb
operator|->
name|lsb_value
expr_stmt|;
name|READ_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|a
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lre
operator|->
name|lre_type
condition|)
block|{
case|case
name|R_386_NONE
case|:
break|break;
case|case
name|R_386_32
case|:
name|v
operator|=
name|s
operator|+
name|a
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_386_PC32
case|:
if|if
condition|(
name|lsb
operator|->
name|lsb_plt
condition|)
name|v
operator|=
name|l
operator|+
name|a
operator|-
name|p
expr_stmt|;
else|else
name|v
operator|=
name|s
operator|+
name|a
operator|-
name|p
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_386_PLT32
case|:
if|if
condition|(
operator|!
name|ls
operator|->
name|ls_ignore_next_plt
condition|)
block|{
name|v
operator|=
name|l
operator|+
name|a
operator|-
name|p
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
name|ls
operator|->
name|ls_ignore_next_plt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_386_GOT32
case|:
name|g
operator|=
name|_got_offset
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
name|v
operator|=
name|g
operator|+
name|a
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_386_GOTOFF
case|:
name|v
operator|=
name|s
operator|+
name|a
operator|-
name|got
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_386_GOTPC
case|:
name|v
operator|=
name|got
operator|+
name|a
operator|-
name|p
expr_stmt|;
name|WRITE_32
argument_list|(
name|buf
operator|+
name|lre
operator|->
name|lre_offset
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"Relocation %d not supported"
argument_list|,
name|lre
operator|->
name|lre_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|i386_register
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_arch
modifier|*
name|i386_arch
decl_stmt|;
if|if
condition|(
operator|(
name|i386_arch
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i386_arch
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|i386_arch
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|i386_arch
operator|->
name|name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
literal|"i386"
argument_list|)
expr_stmt|;
name|i386_arch
operator|->
name|script
operator|=
name|i386_script
expr_stmt|;
name|i386_arch
operator|->
name|get_max_page_size
operator|=
name|_get_max_page_size
expr_stmt|;
name|i386_arch
operator|->
name|get_common_page_size
operator|=
name|_get_common_page_size
expr_stmt|;
name|i386_arch
operator|->
name|scan_reloc
operator|=
name|_scan_reloc
expr_stmt|;
name|i386_arch
operator|->
name|process_reloc
operator|=
name|_process_reloc
expr_stmt|;
name|i386_arch
operator|->
name|is_absolute_reloc
operator|=
name|_is_absolute_reloc
expr_stmt|;
name|i386_arch
operator|->
name|is_relative_reloc
operator|=
name|_is_relative_reloc
expr_stmt|;
name|i386_arch
operator|->
name|reloc_is_64bit
operator|=
literal|0
expr_stmt|;
name|i386_arch
operator|->
name|reloc_is_rela
operator|=
literal|0
expr_stmt|;
name|i386_arch
operator|->
name|reloc_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Rel
argument_list|)
expr_stmt|;
name|HASH_ADD_STR
argument_list|(
name|ld
operator|->
name|ld_arch_list
argument_list|,
name|name
argument_list|,
name|i386_arch
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

