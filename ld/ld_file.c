begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ld_arch.h"
end_include

begin_include
include|#
directive|include
file|"ld_file.h"
end_include

begin_include
include|#
directive|include
file|"ld_path.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: ld_file.c 3281 2015-12-11 21:39:23Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Support routines for input file handling.  */
end_comment

begin_function_decl
specifier|static
name|void
name|_add_file
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|ld_file_type
name|type
parameter_list|,
name|int
name|first
parameter_list|,
name|struct
name|ld_file
modifier|*
name|after
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ld_file_cleanup
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_file
modifier|*
name|lf
decl_stmt|,
modifier|*
name|_lf
decl_stmt|;
name|struct
name|ld_archive_member
modifier|*
name|lam
decl_stmt|,
modifier|*
name|_lam
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|lf
argument_list|,
argument|&ld->ld_lflist
argument_list|,
argument|lf_next
argument_list|,
argument|_lf
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ld
operator|->
name|ld_lflist
argument_list|,
name|lf
argument_list|,
name|lf_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf
operator|->
name|lf_ar
operator|!=
name|NULL
condition|)
block|{
name|HASH_ITER
argument_list|(
argument|hh
argument_list|,
argument|lf->lf_ar->la_m
argument_list|,
argument|lam
argument_list|,
argument|_lam
argument_list|)
block|{
name|HASH_DEL
argument_list|(
name|lf
operator|->
name|lf_ar
operator|->
name|la_m
argument_list|,
name|lam
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lam
operator|->
name|lam_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lam
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|lf
operator|->
name|lf_ar
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|lf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ld_file_add
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|ld_file_type
name|type
parameter_list|)
block|{
name|_add_file
argument_list|(
name|ld
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_file_add_first
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|ld_file_type
name|type
parameter_list|)
block|{
name|_add_file
argument_list|(
name|ld
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_file_add_after
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|ld_file_type
name|type
parameter_list|,
name|struct
name|ld_file
modifier|*
name|after
parameter_list|)
block|{
name|_add_file
argument_list|(
name|ld
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_file_load
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_file
modifier|*
name|lf
parameter_list|)
block|{
name|struct
name|ld_archive
modifier|*
name|la
decl_stmt|;
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|Elf_Kind
name|k
decl_stmt|;
name|GElf_Ehdr
name|ehdr
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|assert
argument_list|(
name|lf
operator|!=
name|NULL
operator|&&
name|lf
operator|->
name|lf_name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|ls_file
operator|==
name|lf
condition|)
return|return;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|lf
operator|->
name|lf_name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"%s: open"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"%s: stat"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|==
literal|0
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: File truncated"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
name|lf
operator|->
name|lf_size
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
operator|(
name|lf
operator|->
name|lf_mmap
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|lf
operator|->
name|lf_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"%s: mmap"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf
operator|->
name|lf_type
operator|==
name|LFT_BINARY
condition|)
return|return;
if|if
condition|(
operator|(
name|lf
operator|->
name|lf_elf
operator|=
name|elf_memory
argument_list|(
name|lf
operator|->
name|lf_mmap
argument_list|,
name|lf
operator|->
name|lf_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: elf_memory failed: %s"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|=
name|elf_kind
argument_list|(
name|lf
operator|->
name|lf_elf
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|ELF_K_AR
condition|)
block|{
name|lf
operator|->
name|lf_type
operator|=
name|LFT_ARCHIVE
expr_stmt|;
if|if
condition|(
name|lf
operator|->
name|lf_ar
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|la
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|la
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|lf
operator|->
name|lf_ar
operator|=
name|la
expr_stmt|;
block|}
return|return;
block|}
name|assert
argument_list|(
name|k
operator|!=
name|ELF_K_AR
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|ELF_K_NONE
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: File format not recognized"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|lf
operator|->
name|lf_elf
argument_list|,
operator|&
name|ehdr
argument_list|)
operator|==
name|NULL
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: gelf_getehdr failed: %s"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ehdr
operator|.
name|e_type
condition|)
block|{
case|case
name|ET_NONE
case|:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: ELF type ET_NONE not supported"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
case|case
name|ET_REL
case|:
name|lf
operator|->
name|lf_type
operator|=
name|LFT_RELOCATABLE
expr_stmt|;
break|break;
case|case
name|ET_EXEC
case|:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: ELF type ET_EXEC not supported yet"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
case|case
name|ET_DYN
case|:
name|lf
operator|->
name|lf_type
operator|=
name|LFT_DSO
expr_stmt|;
break|break;
case|case
name|ET_CORE
case|:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: ELF type ET_NONE not supported"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
default|default:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: unknown ELF type %u"
argument_list|,
name|ehdr
operator|.
name|e_type
argument_list|)
expr_stmt|;
block|}
name|ld_arch_verify
argument_list|(
name|ld
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|,
name|ehdr
operator|.
name|e_machine
argument_list|,
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|,
name|ehdr
operator|.
name|e_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_file_unload
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_file
modifier|*
name|lf
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
if|if
condition|(
name|lf
operator|->
name|lf_type
operator|!=
name|LFT_BINARY
condition|)
name|elf_end
argument_list|(
name|lf
operator|->
name|lf_elf
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf
operator|->
name|lf_mmap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|munmap
argument_list|(
name|lf
operator|->
name|lf_mmap
argument_list|,
name|lf
operator|->
name|lf_size
argument_list|)
operator|<
literal|0
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"%s: munmap"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ls
operator|->
name|ls_file
operator|==
name|lf
condition|)
name|ls
operator|->
name|ls_file
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_add_file
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|ld_file_type
name|type
parameter_list|,
name|int
name|first
parameter_list|,
name|struct
name|ld_file
modifier|*
name|after
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_file
modifier|*
name|lf
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|assert
argument_list|(
name|ld
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"-l"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|ld_path_search_library
argument_list|(
name|ld
argument_list|,
operator|&
name|name
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
if|if
condition|(
operator|(
name|lf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lf
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lf
operator|->
name|lf_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|lf
operator|->
name|lf_type
operator|=
name|type
expr_stmt|;
name|lf
operator|->
name|lf_whole_archive
operator|=
name|ls
operator|->
name|ls_whole_archive
expr_stmt|;
name|lf
operator|->
name|lf_as_needed
operator|=
name|ls
operator|->
name|ls_as_needed
expr_stmt|;
name|lf
operator|->
name|lf_group_level
operator|=
name|ls
operator|->
name|ls_group_level
expr_stmt|;
name|lf
operator|->
name|lf_search_dir
operator|=
name|ls
operator|->
name|ls_search_dir
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|lf
operator|->
name|lf_name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|lf
operator|->
name|lf_search_dir
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"%s: open"
argument_list|,
name|lf
operator|->
name|lf_name
argument_list|)
expr_stmt|;
comment|/* Search library path for this file. */
name|ld_path_search_file
argument_list|(
name|ld
argument_list|,
name|lf
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf
operator|->
name|lf_type
operator|==
name|LFT_UNKNOWN
operator|&&
name|ls
operator|->
name|ls_itgt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|elftc_bfd_target_flavor
argument_list|(
name|ls
operator|->
name|ls_itgt
argument_list|)
operator|==
name|ETF_BINARY
condition|)
name|lf
operator|->
name|lf_type
operator|=
name|LFT_BINARY
expr_stmt|;
block|}
if|if
condition|(
name|lf
operator|->
name|lf_type
operator|==
name|LFT_DSO
condition|)
name|ld
operator|->
name|ld_dynamic_link
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|ld
operator|->
name|ld_lflist
argument_list|,
name|after
argument_list|,
name|lf
argument_list|,
name|lf_next
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ld
operator|->
name|ld_lflist
argument_list|,
name|lf
argument_list|,
name|lf_next
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ld
operator|->
name|ld_lflist
argument_list|,
name|lf
argument_list|,
name|lf_next
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

