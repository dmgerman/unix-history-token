begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* First C source file for actual execution test.  */
end_comment

begin_comment
comment|/* The main point of this test is to make sure that the code and data    are truly position independent.  We statically initialize several    global variables, and make sure that they are correctly adjusted at    runtime.  */
end_comment

begin_decl_stmt
name|int
name|i
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|j
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|small_buf
index|[]
init|=
literal|"aaaa"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|small_pointer
init|=
name|small_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|big_buf
index|[]
init|=
literal|"aaaaaaaaaaaaaaaa"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|big_pointer
init|=
name|big_buf
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|bar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|pbar
function_decl|)
parameter_list|()
init|=
name|bar
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|foo2
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|l
operator|=
name|arg
expr_stmt|;
return|return
name|i
operator|+
name|j
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|pfoo2
function_decl|)
parameter_list|()
init|=
name|foo2
function_decl|;
end_function_decl

begin_function
name|int
name|chkstr
parameter_list|(
name|z
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
comment|/* Switch statements need extra effort to be position independent,      so we run one here, even though most of the cases will never be      taken.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
return|return
name|i
operator|-
literal|1
return|;
case|case
literal|4
case|:
break|break;
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
case|case
literal|9
case|:
return|return
name|i
operator|*
name|j
return|;
case|case
literal|10
case|:
case|case
literal|11
case|:
case|case
literal|12
case|:
case|case
literal|13
case|:
case|case
literal|14
case|:
case|case
literal|15
case|:
return|return
name|j
return|;
case|case
literal|16
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
if|if
condition|(
operator|*
name|z
operator|++
operator|!=
literal|'a'
condition|)
return|return
literal|0
return|;
return|return
operator|*
name|z
operator|==
literal|'\0'
return|;
block|}
end_function

begin_comment
comment|/* This function is called by the assembler startup routine.  It tries    to test that everything was correctly initialized.  It returns 0 on    success, something else on failure.  */
end_comment

begin_function
name|int
name|foo
parameter_list|()
block|{
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|!
name|chkstr
argument_list|(
name|small_buf
argument_list|,
literal|4
argument_list|)
condition|)
return|return
literal|3
return|;
if|if
condition|(
operator|!
name|chkstr
argument_list|(
name|small_pointer
argument_list|,
literal|4
argument_list|)
condition|)
return|return
literal|4
return|;
if|if
condition|(
operator|!
name|chkstr
argument_list|(
name|big_buf
argument_list|,
literal|16
argument_list|)
condition|)
return|return
literal|5
return|;
if|if
condition|(
operator|!
name|chkstr
argument_list|(
name|big_pointer
argument_list|,
literal|16
argument_list|)
condition|)
return|return
literal|6
return|;
if|if
condition|(
name|l
operator|!=
literal|0
condition|)
return|return
literal|7
return|;
if|if
condition|(
name|foo2
argument_list|(
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|8
return|;
if|if
condition|(
name|l
operator|!=
literal|1
condition|)
return|return
literal|9
return|;
if|if
condition|(
call|(
modifier|*
name|pfoo2
call|)
argument_list|(
literal|2
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|10
return|;
if|if
condition|(
name|l
operator|!=
literal|2
condition|)
return|return
literal|11
return|;
if|if
condition|(
name|bar
argument_list|(
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|12
return|;
if|if
condition|(
name|bar
argument_list|(
operator|-
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|13
return|;
if|if
condition|(
call|(
modifier|*
name|pbar
call|)
argument_list|(
literal|0xa5a5a5a5
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
literal|14
return|;
if|if
condition|(
name|k
operator|!=
literal|0xa5a5a5a5
condition|)
return|return
literal|15
return|;
if|if
condition|(
call|(
modifier|*
name|pbar
call|)
argument_list|(
literal|0
argument_list|)
operator|!=
literal|0xa5a5a5a5
condition|)
return|return
literal|16
return|;
if|if
condition|(
name|k
operator|!=
literal|0
condition|)
return|return
literal|17
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

