begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Load and run a MIPS position independent ECOFF file.    Written by Ian Lance Taylor<ian@cygnus.com>    Public domain.  */
end_comment

begin_comment
comment|/* This program will load an ECOFF file into memory and execute it.    The file must have been compiled using the GNU -membedded-pic    switch to produce position independent code.  This will only work    if this program is run on a MIPS system with the same endianness as    the ECOFF file.  The ECOFF file must be complete.  System calls may    not work correctly.     There are further restrictions on the file (they could be removed    by doing some additional programming).  The file must be aligned    such that it does not require any gaps introduced in the data    segment; the GNU linker produces such files by default.  However,    the file must not assume that the text or data segment is aligned    on a page boundary.  The start address must be at the start of the    text segment.     The ECOFF file is run by calling it as though it were a function.    The address of the data segment is passed as the only argument.    The file is expected to return an integer value, which will be    printed.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* Structures used in ECOFF files.  We assume that a short is two    bytes and an int is four bytes.  This is not much of an assumption,    since we already assume that we are running on a MIPS host with the    same endianness as the file we are examining.  */
end_comment

begin_struct
struct|struct
name|ecoff_filehdr
block|{
name|unsigned
name|short
name|f_magic
decl_stmt|;
comment|/* magic number                 */
name|unsigned
name|short
name|f_nscns
decl_stmt|;
comment|/* number of sections           */
name|unsigned
name|int
name|f_timdat
decl_stmt|;
comment|/* time& date stamp            */
name|unsigned
name|int
name|f_symptr
decl_stmt|;
comment|/* file pointer to symtab       */
name|unsigned
name|int
name|f_nsyms
decl_stmt|;
comment|/* number of symtab entries     */
name|unsigned
name|short
name|f_opthdr
decl_stmt|;
comment|/* sizeof(optional hdr)         */
name|unsigned
name|short
name|f_flags
decl_stmt|;
comment|/* flags                        */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecoff_aouthdr
block|{
name|unsigned
name|short
name|magic
decl_stmt|;
comment|/* type of file				*/
name|unsigned
name|short
name|vstamp
decl_stmt|;
comment|/* version stamp			*/
name|unsigned
name|int
name|tsize
decl_stmt|;
comment|/* text size in bytes, padded to FW bdry*/
name|unsigned
name|int
name|dsize
decl_stmt|;
comment|/* initialized data "  "		*/
name|unsigned
name|int
name|bsize
decl_stmt|;
comment|/* uninitialized data "   "		*/
name|unsigned
name|int
name|entry
decl_stmt|;
comment|/* entry pt.				*/
name|unsigned
name|int
name|text_start
decl_stmt|;
comment|/* base of text used for this file */
name|unsigned
name|int
name|data_start
decl_stmt|;
comment|/* base of data used for this file */
name|unsigned
name|int
name|bss_start
decl_stmt|;
comment|/* base of bss used for this file */
name|unsigned
name|int
name|gprmask
decl_stmt|;
comment|/* ?? */
name|unsigned
name|int
name|cprmask
index|[
literal|4
index|]
decl_stmt|;
comment|/* ?? */
name|unsigned
name|int
name|gp_value
decl_stmt|;
comment|/* value for gp register */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ECOFF_SCNHDR_SIZE
value|(40)
end_define

begin_function
specifier|static
name|void
name|die
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
name|struct
name|ecoff_filehdr
modifier|*
name|fh
decl_stmt|;
name|struct
name|ecoff_aouthdr
modifier|*
name|ah
decl_stmt|;
name|unsigned
name|int
name|toff
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|int
function_decl|(
modifier|*
name|pfn
function_decl|)
parameter_list|()
function_decl|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s file\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|die
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"stat"
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|s
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
name|die
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
name|s
operator|.
name|st_size
argument_list|,
name|f
argument_list|)
operator|!=
name|s
operator|.
name|st_size
condition|)
name|die
argument_list|(
literal|"fread"
argument_list|)
expr_stmt|;
comment|/* We need to figure out the start of the text segment, which is the      location we are going to call, and the start of the data segment,      which we are going to pass as an argument.  We also need the size      and start address of the bss segment.  This information is all in      the ECOFF a.out header.  */
name|fh
operator|=
operator|(
expr|struct
name|ecoff_filehdr
operator|*
operator|)
name|z
expr_stmt|;
if|if
condition|(
name|fh
operator|->
name|f_opthdr
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_aouthdr
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unexpected opthdr size: is %u, want %u\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|fh
operator|->
name|f_opthdr
argument_list|,
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_aouthdr
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ah
operator|=
operator|(
expr|struct
name|ecoff_aouthdr
operator|*
operator|)
operator|(
name|z
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_filehdr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|magic
operator|!=
literal|0413
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad aouthdr magic number 0%o (want 0413)\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ah
operator|->
name|magic
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We should clear the bss segment at this point.  This is the      ah->bsize bytes starting at ah->bss_start, To do this correctly,      we would have to make sure our memory block is large enough.  It      so happens that our test case does not have any additional pages      for the bss segment--it is contained within the data segment.      So, we don't bother.  */
if|if
condition|(
name|ah
operator|->
name|bsize
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bss segment is %u bytes; non-zero sizes not supported\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|ah
operator|->
name|bsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The text section starts just after all the headers, rounded to a      16 byte boundary.  */
name|toff
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_filehdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ecoff_aouthdr
argument_list|)
operator|+
name|fh
operator|->
name|f_nscns
operator|*
name|ECOFF_SCNHDR_SIZE
operator|)
expr_stmt|;
name|toff
operator|+=
literal|15
expr_stmt|;
name|toff
operator|&=
operator|~
literal|15
expr_stmt|;
name|t
operator|=
name|z
operator|+
name|toff
expr_stmt|;
comment|/* The tsize field gives us the start of the data segment.  */
name|d
operator|=
name|z
operator|+
name|ah
operator|->
name|tsize
expr_stmt|;
comment|/* Call the code as a function.  */
name|pfn
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|t
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|pfn
call|)
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s ran and returned %d\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

