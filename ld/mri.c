begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mri.c -- handle MRI style linker scripts    Copyright 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.     This bit does the tree decoration when MRI style link scripts    are parsed.     Contributed by Steve Chamberlain<sac@cygnus.com>.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"mri.h"
end_include

begin_include
include|#
directive|include
file|<ldgram.h>
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_struct
struct|struct
name|section_name_struct
block|{
name|struct
name|section_name_struct
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|alias
decl_stmt|;
name|etree_type
modifier|*
name|vma
decl_stmt|;
name|etree_type
modifier|*
name|align
decl_stmt|;
name|etree_type
modifier|*
name|subalign
decl_stmt|;
name|int
name|ok_to_load
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|symbol_truncate
init|=
literal|10000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_name_struct
modifier|*
name|order
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_name_struct
modifier|*
name|only_load
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_name_struct
modifier|*
name|address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_name_struct
modifier|*
name|alias
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_name_struct
modifier|*
name|alignment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_name_struct
modifier|*
name|subalignment
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|section_name_struct
modifier|*
modifier|*
name|lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|section_name_struct
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|section_name_struct
modifier|*
modifier|*
name|ptr
init|=
name|list
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
operator|(
operator|*
name|ptr
operator|)
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
comment|/* If this is a match, delete it, we only keep the last instance 	   of any name.  */
operator|*
name|ptr
operator|=
operator|(
operator|*
name|ptr
operator|)
operator|->
name|next
expr_stmt|;
else|else
name|ptr
operator|=
operator|&
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_name_struct
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mri_add_to_list
parameter_list|(
name|struct
name|section_name_struct
modifier|*
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|etree_type
modifier|*
name|vma
parameter_list|,
specifier|const
name|char
modifier|*
name|zalias
parameter_list|,
name|etree_type
modifier|*
name|align
parameter_list|,
name|etree_type
modifier|*
name|subalign
parameter_list|)
block|{
name|struct
name|section_name_struct
modifier|*
modifier|*
name|ptr
init|=
name|lookup
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
decl_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|->
name|ok_to_load
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|->
name|alias
operator|=
name|zalias
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|->
name|align
operator|=
name|align
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|->
name|subalign
operator|=
name|subalign
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mri_output_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|etree_type
modifier|*
name|vma
parameter_list|)
block|{
name|mri_add_to_list
argument_list|(
operator|&
name|address
argument_list|,
name|name
argument_list|,
name|vma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If any ABSOLUTE<name> are in the script, only load those files    marked thus.  */
end_comment

begin_function
name|void
name|mri_only_load
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|mri_add_to_list
argument_list|(
operator|&
name|only_load
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mri_base
parameter_list|(
name|etree_type
modifier|*
name|exp
parameter_list|)
block|{
name|base
operator|=
name|exp
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|done_tree
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|mri_draw_tree
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|done_tree
condition|)
return|return;
comment|/* Now build the statements for the ldlang machine.  */
comment|/* Attach the addresses of any which have addresses,      and add the ones not mentioned.  */
if|if
condition|(
name|address
operator|!=
name|NULL
condition|)
block|{
name|struct
name|section_name_struct
modifier|*
name|alist
decl_stmt|;
name|struct
name|section_name_struct
modifier|*
name|olist
decl_stmt|;
if|if
condition|(
name|order
operator|==
name|NULL
condition|)
name|order
operator|=
name|address
expr_stmt|;
for|for
control|(
name|alist
operator|=
name|address
init|;
name|alist
operator|!=
name|NULL
condition|;
name|alist
operator|=
name|alist
operator|->
name|next
control|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
for|for
control|(
name|olist
operator|=
name|order
init|;
name|done
operator|==
literal|0
operator|&&
name|olist
operator|!=
name|NULL
condition|;
name|olist
operator|=
name|olist
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|alist
operator|->
name|name
argument_list|,
name|olist
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|olist
operator|->
name|vma
operator|=
name|alist
operator|->
name|vma
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
comment|/* Add this onto end of order list.  */
name|mri_add_to_list
argument_list|(
operator|&
name|order
argument_list|,
name|alist
operator|->
name|name
argument_list|,
name|alist
operator|->
name|vma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If we're only supposed to load a subset of them in, then prune      the list.  */
if|if
condition|(
name|only_load
operator|!=
name|NULL
condition|)
block|{
name|struct
name|section_name_struct
modifier|*
name|ptr1
decl_stmt|;
name|struct
name|section_name_struct
modifier|*
name|ptr2
decl_stmt|;
if|if
condition|(
name|order
operator|==
name|NULL
condition|)
name|order
operator|=
name|only_load
expr_stmt|;
comment|/* See if this name is in the list, if it is then we can load it.  */
for|for
control|(
name|ptr1
operator|=
name|only_load
init|;
name|ptr1
condition|;
name|ptr1
operator|=
name|ptr1
operator|->
name|next
control|)
for|for
control|(
name|ptr2
operator|=
name|order
init|;
name|ptr2
condition|;
name|ptr2
operator|=
name|ptr2
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ptr2
operator|->
name|name
argument_list|,
name|ptr1
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|ptr2
operator|->
name|ok_to_load
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* No only load list, so everything is ok to load.  */
name|struct
name|section_name_struct
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|order
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|ptr
operator|->
name|ok_to_load
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Create the order of sections to load.  */
if|if
condition|(
name|order
operator|!=
name|NULL
condition|)
block|{
comment|/* Been told to output the sections in a certain order.  */
name|struct
name|section_name_struct
modifier|*
name|p
init|=
name|order
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|struct
name|section_name_struct
modifier|*
name|aptr
decl_stmt|;
name|etree_type
modifier|*
name|align
init|=
literal|0
decl_stmt|;
name|etree_type
modifier|*
name|subalign
init|=
literal|0
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|tmp
decl_stmt|;
comment|/* See if an alignment has been specified.  */
for|for
control|(
name|aptr
operator|=
name|alignment
init|;
name|aptr
condition|;
name|aptr
operator|=
name|aptr
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|aptr
operator|->
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|align
operator|=
name|aptr
operator|->
name|align
expr_stmt|;
for|for
control|(
name|aptr
operator|=
name|subalignment
init|;
name|aptr
condition|;
name|aptr
operator|=
name|aptr
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|aptr
operator|->
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|subalign
operator|=
name|aptr
operator|->
name|subalign
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|base
operator|=
name|p
operator|->
name|vma
condition|?
name|p
operator|->
name|vma
else|:
name|exp_nameop
argument_list|(
name|NAME
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|lang_enter_output_section_statement
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|base
argument_list|,
name|p
operator|->
name|ok_to_load
condition|?
literal|0
else|:
name|noload_section
argument_list|,
name|align
argument_list|,
name|subalign
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tmp
operator|->
name|spec
operator|.
name|name
operator|=
name|p
operator|->
name|name
expr_stmt|;
name|tmp
operator|->
name|spec
operator|.
name|exclude_name_list
operator|=
name|NULL
expr_stmt|;
name|tmp
operator|->
name|spec
operator|.
name|sorted
operator|=
name|none
expr_stmt|;
name|lang_add_wild
argument_list|(
name|NULL
argument_list|,
name|tmp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* If there is an alias for this section, add it too.  */
for|for
control|(
name|aptr
operator|=
name|alias
init|;
name|aptr
condition|;
name|aptr
operator|=
name|aptr
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|aptr
operator|->
name|alias
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tmp
operator|->
name|spec
operator|.
name|name
operator|=
name|aptr
operator|->
name|name
expr_stmt|;
name|tmp
operator|->
name|spec
operator|.
name|exclude_name_list
operator|=
name|NULL
expr_stmt|;
name|tmp
operator|->
name|spec
operator|.
name|sorted
operator|=
name|none
expr_stmt|;
name|lang_add_wild
argument_list|(
name|NULL
argument_list|,
name|tmp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|lang_leave_output_section_statement
argument_list|(
literal|0
argument_list|,
literal|"*default*"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
name|done_tree
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mri_load
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|base
operator|=
literal|0
expr_stmt|;
name|lang_add_input_file
argument_list|(
name|name
argument_list|,
name|lang_input_file_is_file_enum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mri_order
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|mri_add_to_list
argument_list|(
operator|&
name|order
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mri_alias
parameter_list|(
specifier|const
name|char
modifier|*
name|want
parameter_list|,
specifier|const
name|char
modifier|*
name|is
parameter_list|,
name|int
name|isn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
comment|/* Some sections are digits.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|isn
argument_list|)
expr_stmt|;
name|is
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|mri_add_to_list
argument_list|(
operator|&
name|alias
argument_list|,
name|is
argument_list|,
literal|0
argument_list|,
name|want
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mri_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|lang_add_output
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mri_format
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"S"
argument_list|)
operator|==
literal|0
condition|)
name|lang_add_output_format
argument_list|(
literal|"srec"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"IEEE"
argument_list|)
operator|==
literal|0
condition|)
name|lang_add_output_format
argument_list|(
literal|"ieee"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"COFF"
argument_list|)
operator|==
literal|0
condition|)
name|lang_add_output_format
argument_list|(
literal|"coff-m68k"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: unknown format type %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mri_public
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|etree_type
modifier|*
name|exp
parameter_list|)
block|{
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
name|name
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mri_align
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|etree_type
modifier|*
name|exp
parameter_list|)
block|{
name|mri_add_to_list
argument_list|(
operator|&
name|alignment
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mri_alignmod
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|etree_type
modifier|*
name|exp
parameter_list|)
block|{
name|mri_add_to_list
argument_list|(
operator|&
name|subalignment
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mri_truncate
parameter_list|(
name|unsigned
name|int
name|exp
parameter_list|)
block|{
name|symbol_truncate
operator|=
name|exp
expr_stmt|;
block|}
end_function

end_unit

