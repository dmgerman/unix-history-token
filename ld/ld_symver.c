begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ld_input.h"
end_include

begin_include
include|#
directive|include
file|"ld_layout.h"
end_include

begin_include
include|#
directive|include
file|"ld_output.h"
end_include

begin_include
include|#
directive|include
file|"ld_script.h"
end_include

begin_include
include|#
directive|include
file|"ld_symbols.h"
end_include

begin_include
include|#
directive|include
file|"ld_symver.h"
end_include

begin_include
include|#
directive|include
file|"ld_strtab.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: ld_symver.c 2917 2013-02-16 07:16:02Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Symbol versioning sections are the same for 32bit and 64bit  * ELF objects.  */
end_comment

begin_define
define|#
directive|define
name|Elf_Verdef
value|Elf32_Verdef
end_define

begin_define
define|#
directive|define
name|Elf_Verdaux
value|Elf32_Verdaux
end_define

begin_define
define|#
directive|define
name|Elf_Verneed
value|Elf32_Verneed
end_define

begin_define
define|#
directive|define
name|Elf_Vernaux
value|Elf32_Vernaux
end_define

begin_function_decl
specifier|static
name|void
name|_add_version_name
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|int
name|ndx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_symver_vda
modifier|*
name|_alloc_vda
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ld_symver_verdef
modifier|*
name|svd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_symver_vna
modifier|*
name|_alloc_vna
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ld_symver_verneed
modifier|*
name|svn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_symver_verdef
modifier|*
name|_alloc_verdef
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symver_verdef_head
modifier|*
name|head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_symver_verneed
modifier|*
name|_alloc_verneed
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|struct
name|ld_symver_verneed_head
modifier|*
name|head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_symver_verdef
modifier|*
name|_load_verdef
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf_Verdef
modifier|*
name|vd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_load_verdef_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf
modifier|*
name|e
parameter_list|,
name|Elf_Scn
modifier|*
name|verdef
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_load_verneed_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf
modifier|*
name|e
parameter_list|,
name|Elf_Scn
modifier|*
name|verneed
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ld_symver_load_symbol_version_info
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf
modifier|*
name|e
parameter_list|,
name|Elf_Scn
modifier|*
name|versym
parameter_list|,
name|Elf_Scn
modifier|*
name|verneed
parameter_list|,
name|Elf_Scn
modifier|*
name|verdef
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|d_vs
decl_stmt|;
name|int
name|elferr
decl_stmt|;
if|if
condition|(
name|versym
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d_vs
operator|=
name|elf_getdata
argument_list|(
name|versym
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: elf_getdata failed: %s"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d_vs
operator|->
name|d_size
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|li
operator|->
name|li_versym
operator|=
name|malloc
argument_list|(
name|d_vs
operator|->
name|d_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|li
operator|->
name|li_versym
argument_list|,
name|d_vs
operator|->
name|d_buf
argument_list|,
name|d_vs
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|li
operator|->
name|li_versym_sz
operator|=
name|d_vs
operator|->
name|d_size
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
name|_add_version_name
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
literal|0
argument_list|,
literal|"*local*"
argument_list|)
expr_stmt|;
name|_add_version_name
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
literal|1
argument_list|,
literal|"*global*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verneed
operator|!=
name|NULL
condition|)
name|_load_verneed_section
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
name|e
argument_list|,
name|verneed
argument_list|)
expr_stmt|;
if|if
condition|(
name|verdef
operator|!=
name|NULL
condition|)
name|_load_verdef_section
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
name|e
argument_list|,
name|verdef
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_symver_create_verneed_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_input
modifier|*
name|li
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|struct
name|ld_output_data_buffer
modifier|*
name|odb
decl_stmt|;
name|struct
name|ld_symver_verdef
modifier|*
name|svd
decl_stmt|;
name|struct
name|ld_symver_verneed
modifier|*
name|svn
decl_stmt|;
name|struct
name|ld_symver_vda
modifier|*
name|sda
decl_stmt|;
name|struct
name|ld_symver_vna
modifier|*
name|sna
decl_stmt|;
name|char
name|verneed_name
index|[]
init|=
literal|".gnu.version_r"
decl_stmt|;
name|Elf_Verneed
modifier|*
name|vn
decl_stmt|;
name|Elf_Vernaux
modifier|*
name|vna
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|buf2
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|->
name|lo_dynstr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Create .gnu.version_r section. 	 */
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|verneed_name
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|==
name|NULL
condition|)
name|os
operator|=
name|ld_layout_insert_output_section
argument_list|(
name|ld
argument_list|,
name|verneed_name
argument_list|,
name|SHF_ALLOC
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_type
operator|=
name|SHT_GNU_verneed
expr_stmt|;
name|os
operator|->
name|os_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|os
operator|->
name|os_entsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|)
name|os
operator|->
name|os_align
operator|=
literal|4
expr_stmt|;
else|else
name|os
operator|->
name|os_align
operator|=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|os
operator|->
name|os_link
operator|=
name|strdup
argument_list|(
literal|".dynstr"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_verneed
operator|=
name|os
expr_stmt|;
comment|/* 	 * Build Verneed/Vernaux structures. 	 */
name|sz
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|li
argument_list|,
argument|&ld->ld_lilist
argument_list|,
argument|li_next
argument_list|)
block|{
if|if
condition|(
name|li
operator|->
name|li_type
operator|!=
name|LIT_DSO
operator|||
name|li
operator|->
name|li_dso_refcnt
operator|==
literal|0
operator|||
name|li
operator|->
name|li_verdef
operator|==
name|NULL
condition|)
continue|continue;
name|svn
operator|=
name|NULL
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|svd
argument_list|,
argument|li->li_verdef
argument_list|,
argument|svd_next
argument_list|)
block|{
if|if
condition|(
name|svd
operator|->
name|svd_flags
operator|&
name|VER_FLG_BASE
condition|)
continue|continue;
comment|/* Skip version definition that is never ref'ed. */
if|if
condition|(
name|svd
operator|->
name|svd_ref
operator|==
literal|0
condition|)
continue|continue;
comment|/* Invalid Verdef? */
if|if
condition|(
operator|(
name|sda
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|svd
operator|->
name|svd_aux
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|lo
operator|->
name|lo_vnlist
operator|==
name|NULL
condition|)
block|{
name|lo
operator|->
name|lo_vnlist
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lo
operator|->
name|lo_vnlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_vnlist
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|lo
operator|->
name|lo_vnlist
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate Verneed entry. */
if|if
condition|(
name|svn
operator|==
name|NULL
condition|)
block|{
name|svn
operator|=
name|_alloc_verneed
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
name|lo
operator|->
name|lo_vnlist
argument_list|)
expr_stmt|;
name|svn
operator|->
name|svn_version
operator|=
name|VER_NEED_CURRENT
expr_stmt|;
name|svn
operator|->
name|svn_cnt
operator|=
literal|0
expr_stmt|;
name|svn
operator|->
name|svn_fileindex
operator|=
name|ld_strtab_insert_no_suffix
argument_list|(
name|ld
argument_list|,
name|ld
operator|->
name|ld_dynstr
argument_list|,
name|svn
operator|->
name|svn_file
argument_list|)
expr_stmt|;
name|sz
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Verneed
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_verneed_num
operator|++
expr_stmt|;
block|}
comment|/* Allocate Vernaux entry. */
name|sna
operator|=
name|_alloc_vna
argument_list|(
name|ld
argument_list|,
name|sda
operator|->
name|sda_name
argument_list|,
name|svn
argument_list|)
expr_stmt|;
name|sna
operator|->
name|sna_other
operator|=
name|lo
operator|->
name|lo_version_index
operator|++
expr_stmt|;
name|sna
operator|->
name|sna_nameindex
operator|=
name|ld_strtab_insert_no_suffix
argument_list|(
name|ld
argument_list|,
name|ld
operator|->
name|ld_dynstr
argument_list|,
name|sna
operator|->
name|sna_name
argument_list|)
expr_stmt|;
comment|/* TODO: flags? VER_FLG_WEAK */
name|svn
operator|->
name|svn_cnt
operator|++
expr_stmt|;
name|sz
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Vernaux
argument_list|)
expr_stmt|;
comment|/* 			 * Store the index in Verdef structure, so later we can 			 * quickly find the version index for a dynamic symbol, 			 * when we build the .gnu.version section. 			 */
name|svd
operator|->
name|svd_ndx_output
operator|=
name|sna
operator|->
name|sna_other
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lo
operator|->
name|lo_verneed_num
operator|==
literal|0
condition|)
return|return;
comment|/* Store the number of verneed entries in the sh_info field. */
name|os
operator|->
name|os_info_val
operator|=
name|lo
operator|->
name|lo_verneed_num
expr_stmt|;
comment|/* 	 * Write Verneed/Vernaux structures. 	 */
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|odb
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|odb
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|odb
operator|->
name|odb_buf
operator|=
name|buf
expr_stmt|;
name|odb
operator|->
name|odb_size
operator|=
name|sz
expr_stmt|;
name|odb
operator|->
name|odb_align
operator|=
name|os
operator|->
name|os_align
expr_stmt|;
name|odb
operator|->
name|odb_type
operator|=
name|ELF_T_VNEED
expr_stmt|;
comment|/* enable libelf translation */
name|end
operator|=
name|buf
operator|+
name|sz
expr_stmt|;
name|vn
operator|=
name|NULL
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|svn
argument_list|,
argument|lo->lo_vnlist
argument_list|,
argument|svn_next
argument_list|)
block|{
name|vn
operator|=
operator|(
name|Elf_Verneed
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|vn
operator|->
name|vn_version
operator|=
name|VER_NEED_CURRENT
expr_stmt|;
name|vn
operator|->
name|vn_cnt
operator|=
name|svn
operator|->
name|svn_cnt
expr_stmt|;
name|vn
operator|->
name|vn_file
operator|=
name|svn
operator|->
name|svn_fileindex
expr_stmt|;
name|vn
operator|->
name|vn_aux
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Verneed
argument_list|)
expr_stmt|;
name|vn
operator|->
name|vn_next
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Verneed
argument_list|)
operator|+
name|svn
operator|->
name|svn_cnt
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Vernaux
argument_list|)
expr_stmt|;
comment|/* 		 * Write Vernaux entries. 		 */
name|buf2
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verneed
argument_list|)
expr_stmt|;
name|vna
operator|=
name|NULL
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|sna
argument_list|,
argument|&svn->svn_aux
argument_list|,
argument|sna_next
argument_list|)
block|{
name|vna
operator|=
operator|(
name|Elf_Vernaux
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf2
expr_stmt|;
name|vna
operator|->
name|vna_hash
operator|=
name|sna
operator|->
name|sna_hash
expr_stmt|;
name|vna
operator|->
name|vna_flags
operator|=
literal|0
expr_stmt|;
comment|/* TODO: VER_FLG_WEAK? */
name|vna
operator|->
name|vna_other
operator|=
name|sna
operator|->
name|sna_other
expr_stmt|;
name|vna
operator|->
name|vna_name
operator|=
name|sna
operator|->
name|sna_nameindex
expr_stmt|;
name|vna
operator|->
name|vna_next
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Vernaux
argument_list|)
expr_stmt|;
name|buf2
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Vernaux
argument_list|)
expr_stmt|;
block|}
comment|/* Set last Vernaux entry's vna_next to 0. */
if|if
condition|(
name|vna
operator|!=
name|NULL
condition|)
name|vna
operator|->
name|vna_next
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
name|vn
operator|->
name|vn_next
expr_stmt|;
block|}
comment|/* Set last Verneed entry's vn_next to 0 */
if|if
condition|(
name|vn
operator|!=
name|NULL
condition|)
name|vn
operator|->
name|vn_next
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|buf
operator|==
name|end
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_DATA_BUFFER
argument_list|,
name|odb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_symver_create_verdef_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_script
modifier|*
name|lds
decl_stmt|;
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|struct
name|ld_output_data_buffer
modifier|*
name|odb
decl_stmt|;
name|struct
name|ld_script_version_node
modifier|*
name|ldvn
decl_stmt|;
name|char
name|verdef_name
index|[]
init|=
literal|".gnu.version_d"
decl_stmt|;
name|Elf_Verdef
modifier|*
name|vd
decl_stmt|;
name|Elf_Verdaux
modifier|*
name|vda
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|soname
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|->
name|lo_dynstr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lds
operator|=
name|ld
operator|->
name|ld_scp
expr_stmt|;
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|lds
operator|->
name|lds_vn
argument_list|)
condition|)
return|return;
comment|/* 	 * Create .gnu.version_d section. 	 */
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|verdef_name
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|==
name|NULL
condition|)
name|os
operator|=
name|ld_layout_insert_output_section
argument_list|(
name|ld
argument_list|,
name|verdef_name
argument_list|,
name|SHF_ALLOC
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_type
operator|=
name|SHT_GNU_verdef
expr_stmt|;
name|os
operator|->
name|os_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|os
operator|->
name|os_entsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|)
name|os
operator|->
name|os_align
operator|=
literal|4
expr_stmt|;
else|else
name|os
operator|->
name|os_align
operator|=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|os
operator|->
name|os_link
operator|=
name|strdup
argument_list|(
literal|".dynstr"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_verdef
operator|=
name|os
expr_stmt|;
comment|/* 	 * Calculate verdef section size: .gnu.version_d section consists 	 * of one file version entry and several symbol version definition 	 * entries (with corresponding) auxiliary entries. 	 */
name|lo
operator|->
name|lo_verdef_num
operator|=
literal|1
expr_stmt|;
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verdaux
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ldvn
argument_list|,
argument|&lds->lds_vn
argument_list|,
argument|ldvn_next
argument_list|)
block|{
name|sz
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verdaux
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldvn
operator|->
name|ldvn_dep
operator|!=
name|NULL
condition|)
name|sz
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Verdaux
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_verdef_num
operator|++
expr_stmt|;
block|}
comment|/* Store the number of verdef entries in the sh_info field. */
name|os
operator|->
name|os_info_val
operator|=
name|lo
operator|->
name|lo_verdef_num
expr_stmt|;
comment|/* Allocate buffer for Verdef/Verdaux entries. */
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|sz
expr_stmt|;
if|if
condition|(
operator|(
name|odb
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|odb
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|odb
operator|->
name|odb_buf
operator|=
name|buf
expr_stmt|;
name|odb
operator|->
name|odb_size
operator|=
name|sz
expr_stmt|;
name|odb
operator|->
name|odb_align
operator|=
name|os
operator|->
name|os_align
expr_stmt|;
name|odb
operator|->
name|odb_type
operator|=
name|ELF_T_VDEF
expr_stmt|;
comment|/* enable libelf translation */
comment|/* 	 * Set file version name to `soname' if it is provided, 	 * otherwise set version name to output file name. 	 */
if|if
condition|(
name|ld
operator|->
name|ld_soname
operator|!=
name|NULL
condition|)
name|soname
operator|=
name|ld
operator|->
name|ld_soname
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|soname
operator|=
name|strrchr
argument_list|(
name|ld
operator|->
name|ld_output_file
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|soname
operator|=
name|ld
operator|->
name|ld_output_file
expr_stmt|;
else|else
name|soname
operator|++
expr_stmt|;
block|}
comment|/* Write file version entry. */
name|vd
operator|=
operator|(
name|Elf_Verdef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|vd
operator|->
name|vd_version
operator|=
name|VER_DEF_CURRENT
expr_stmt|;
name|vd
operator|->
name|vd_flags
operator||=
name|VER_FLG_BASE
expr_stmt|;
name|vd
operator|->
name|vd_ndx
operator|=
literal|1
expr_stmt|;
name|vd
operator|->
name|vd_cnt
operator|=
literal|1
expr_stmt|;
name|vd
operator|->
name|vd_hash
operator|=
name|elf_hash
argument_list|(
name|soname
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_aux
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_next
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verdaux
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
expr_stmt|;
comment|/* Write file version auxiliary entry. */
name|vda
operator|=
operator|(
name|Elf_Verdaux
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|vda
operator|->
name|vda_name
operator|=
name|ld_strtab_insert_no_suffix
argument_list|(
name|ld
argument_list|,
name|ld
operator|->
name|ld_dynstr
argument_list|,
name|soname
argument_list|)
expr_stmt|;
name|vda
operator|->
name|vda_next
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Verdaux
argument_list|)
expr_stmt|;
comment|/* Write symbol version definition entries. */
name|STAILQ_FOREACH
argument_list|(
argument|ldvn
argument_list|,
argument|&lds->lds_vn
argument_list|,
argument|ldvn_next
argument_list|)
block|{
name|vd
operator|=
operator|(
name|Elf_Verdef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|vd
operator|->
name|vd_version
operator|=
name|VER_DEF_CURRENT
expr_stmt|;
name|vd
operator|->
name|vd_flags
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vd_ndx
operator|=
name|lo
operator|->
name|lo_version_index
operator|++
expr_stmt|;
name|vd
operator|->
name|vd_cnt
operator|=
operator|(
name|ldvn
operator|->
name|ldvn_dep
operator|==
name|NULL
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|vd
operator|->
name|vd_hash
operator|=
name|elf_hash
argument_list|(
name|ldvn
operator|->
name|ldvn_name
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vd_aux
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_NEXT
argument_list|(
name|ldvn
argument_list|,
name|ldvn_next
argument_list|)
operator|==
name|NULL
condition|)
name|vd
operator|->
name|vd_next
operator|=
literal|0
expr_stmt|;
else|else
name|vd
operator|->
name|vd_next
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
operator|+
operator|(
operator|(
name|ldvn
operator|->
name|ldvn_dep
operator|==
name|NULL
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Verdaux
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
expr_stmt|;
comment|/* Write version name auxiliary entry. */
name|vda
operator|=
operator|(
name|Elf_Verdaux
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|vda
operator|->
name|vda_name
operator|=
name|ld_strtab_insert_no_suffix
argument_list|(
name|ld
argument_list|,
name|ld
operator|->
name|ld_dynstr
argument_list|,
name|ldvn
operator|->
name|ldvn_name
argument_list|)
expr_stmt|;
name|vda
operator|->
name|vda_next
operator|=
name|ldvn
operator|->
name|ldvn_dep
operator|==
name|NULL
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
name|Elf_Verdaux
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Verdaux
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldvn
operator|->
name|ldvn_dep
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Write version dependency auxiliary entry. */
name|vda
operator|=
operator|(
name|Elf_Verdaux
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|vda
operator|->
name|vda_name
operator|=
name|ld_strtab_insert_no_suffix
argument_list|(
name|ld
argument_list|,
name|ld
operator|->
name|ld_dynstr
argument_list|,
name|ldvn
operator|->
name|ldvn_dep
argument_list|)
expr_stmt|;
name|vda
operator|->
name|vda_next
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Verdaux
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|buf
operator|==
name|end
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_DATA_BUFFER
argument_list|,
name|odb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_symver_create_versym_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|struct
name|ld_output_data_buffer
modifier|*
name|odb
decl_stmt|;
name|struct
name|ld_symbol
modifier|*
name|lsb
decl_stmt|;
name|char
name|versym_name
index|[]
init|=
literal|".gnu.version"
decl_stmt|;
name|uint16_t
modifier|*
name|buf
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|->
name|lo_dynsym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ld
operator|->
name|ld_dynsym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Create .gnu.version section. 	 */
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|versym_name
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|==
name|NULL
condition|)
name|os
operator|=
name|ld_layout_insert_output_section
argument_list|(
name|ld
argument_list|,
name|versym_name
argument_list|,
name|SHF_ALLOC
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_type
operator|=
name|SHT_GNU_versym
expr_stmt|;
name|os
operator|->
name|os_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|os
operator|->
name|os_entsize
operator|=
literal|2
expr_stmt|;
name|os
operator|->
name|os_align
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|os
operator|->
name|os_link
operator|=
name|strdup
argument_list|(
literal|".dynsym"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_versym
operator|=
name|os
expr_stmt|;
comment|/* 	 * Write versym table. 	 */
name|sz
operator|=
name|ld
operator|->
name|ld_dynsym
operator|->
name|sy_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* special index 0 symbol */
name|i
operator|=
literal|1
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|lsb
argument_list|,
argument|ld->ld_dyn_symbols
argument_list|,
argument|lsb_dyn
argument_list|)
block|{
comment|/* 		 * Assign version index according to the following rules: 		 * 		 * 1. If the symbol is local, the version is *local*. 		 * 		 * 2. If the symbol is defined in shared libraries and there 		 *    exists a version definition for this symbol, use the 		 *    version defined by the shared library. 		 * 		 * 3. If the symbol is defined in regular objects and the 		 *    linker creates a shared library, use the version 		 *    defined in the version script, if provided. 		 * 		 * 4. Otherwise, the version is *global*. 		 */
if|if
condition|(
name|lsb
operator|->
name|lsb_bind
operator|==
name|STB_LOCAL
condition|)
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Version is *local* */
elseif|else
if|if
condition|(
name|lsb
operator|->
name|lsb_vd
operator|!=
name|NULL
condition|)
name|buf
index|[
name|i
index|]
operator|=
name|lsb
operator|->
name|lsb_vd
operator|->
name|svd_ndx_output
expr_stmt|;
elseif|else
if|if
condition|(
name|ld
operator|->
name|ld_dso
operator|&&
name|ld_symbols_in_regular
argument_list|(
name|lsb
argument_list|)
condition|)
name|buf
index|[
name|i
index|]
operator|=
name|ld_symver_search_version_script
argument_list|(
name|ld
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Version is *global* */
block|}
name|i
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
operator|(
name|size_t
operator|)
name|i
operator|==
name|ld
operator|->
name|ld_dynsym
operator|->
name|sy_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|odb
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|odb
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|odb
operator|->
name|odb_buf
operator|=
operator|(
name|void
operator|*
operator|)
name|buf
expr_stmt|;
name|odb
operator|->
name|odb_size
operator|=
name|sz
expr_stmt|;
name|odb
operator|->
name|odb_align
operator|=
name|os
operator|->
name|os_align
expr_stmt|;
name|odb
operator|->
name|odb_type
operator|=
name|ELF_T_HALF
expr_stmt|;
comment|/* enable libelf translation */
operator|(
name|void
operator|)
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_DATA_BUFFER
argument_list|,
name|odb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_symver_add_verdef_refcnt
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_symbol_defver
modifier|*
name|dv
decl_stmt|;
name|struct
name|ld_symver_verdef
modifier|*
name|svd
decl_stmt|;
name|struct
name|ld_symver_vda
modifier|*
name|sda
decl_stmt|;
name|struct
name|ld_input
modifier|*
name|li
decl_stmt|;
specifier|const
name|char
modifier|*
name|ver
decl_stmt|;
name|li
operator|=
name|lsb
operator|->
name|lsb_input
expr_stmt|;
name|assert
argument_list|(
name|li
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|li_verdef
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|lsb
operator|->
name|lsb_ver
operator|!=
name|NULL
condition|)
name|ver
operator|=
name|lsb
operator|->
name|lsb_ver
expr_stmt|;
else|else
block|{
name|HASH_FIND_STR
argument_list|(
name|ld
operator|->
name|ld_defver
argument_list|,
name|lsb
operator|->
name|lsb_name
argument_list|,
name|dv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dv
operator|==
name|NULL
operator|||
name|dv
operator|->
name|dv_ver
operator|==
name|NULL
condition|)
return|return;
name|ver
operator|=
name|dv
operator|->
name|dv_ver
expr_stmt|;
block|}
name|STAILQ_FOREACH
argument_list|(
argument|svd
argument_list|,
argument|li->li_verdef
argument_list|,
argument|svd_next
argument_list|)
block|{
if|if
condition|(
name|svd
operator|->
name|svd_flags
operator|&
name|VER_FLG_BASE
condition|)
continue|continue;
comment|/* Invalid Verdef? */
if|if
condition|(
operator|(
name|sda
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|svd
operator|->
name|svd_aux
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ver
argument_list|,
name|sda
operator|->
name|sda_name
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|svd
operator|!=
name|NULL
condition|)
block|{
name|svd
operator|->
name|svd_ref
operator|++
expr_stmt|;
name|lsb
operator|->
name|lsb_vd
operator|=
name|svd
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_add_version_name
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|int
name|ndx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndx
operator|<=
literal|1
condition|)
return|return;
if|if
condition|(
name|li
operator|->
name|li_vername
operator|==
name|NULL
condition|)
block|{
name|li
operator|->
name|li_vername_sz
operator|=
literal|10
expr_stmt|;
name|li
operator|->
name|li_vername
operator|=
name|calloc
argument_list|(
name|li
operator|->
name|li_vername_sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|li
operator|->
name|li_vername
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|li_vername
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|ndx
operator|>=
name|li
operator|->
name|li_vername_sz
condition|)
block|{
name|li
operator|->
name|li_vername
operator|=
name|realloc
argument_list|(
name|li
operator|->
name|li_vername
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|li
operator|->
name|li_vername
argument_list|)
operator|*
name|li
operator|->
name|li_vername_sz
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|li_vername
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"realloc"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|li
operator|->
name|li_vername_sz
init|;
operator|(
name|size_t
operator|)
name|i
operator|<
name|li
operator|->
name|li_vername_sz
operator|*
literal|2
condition|;
name|i
operator|++
control|)
name|li
operator|->
name|li_vername
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|li
operator|->
name|li_vername_sz
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|li
operator|->
name|li_vername
index|[
name|ndx
index|]
operator|==
name|NULL
condition|)
block|{
name|li
operator|->
name|li_vername
index|[
name|ndx
index|]
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|li_vername
index|[
name|ndx
index|]
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_symver_vna
modifier|*
name|_alloc_vna
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ld_symver_verneed
modifier|*
name|svn
parameter_list|)
block|{
name|struct
name|ld_symver_vna
modifier|*
name|sna
decl_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sna
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sna
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sna
operator|->
name|sna_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|sna
operator|->
name|sna_hash
operator|=
operator|(
name|uint32_t
operator|)
name|elf_hash
argument_list|(
name|sna
operator|->
name|sna_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn
operator|!=
name|NULL
condition|)
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|svn
operator|->
name|svn_aux
argument_list|,
name|sna
argument_list|,
name|sna_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|sna
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_symver_vda
modifier|*
name|_alloc_vda
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ld_symver_verdef
modifier|*
name|svd
parameter_list|)
block|{
name|struct
name|ld_symver_vda
modifier|*
name|sda
decl_stmt|;
if|if
condition|(
operator|(
name|sda
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sda
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sda
operator|->
name|sda_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|svd
operator|!=
name|NULL
condition|)
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|svd
operator|->
name|svd_aux
argument_list|,
name|sda
argument_list|,
name|sda_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|sda
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_symver_verneed
modifier|*
name|_alloc_verneed
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|struct
name|ld_symver_verneed_head
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ld_symver_verneed
modifier|*
name|svn
decl_stmt|;
specifier|const
name|char
modifier|*
name|bn
decl_stmt|;
if|if
condition|(
operator|(
name|svn
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|svn
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|li_soname
operator|!=
name|NULL
condition|)
name|bn
operator|=
name|li
operator|->
name|li_soname
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|bn
operator|=
name|strrchr
argument_list|(
name|li
operator|->
name|li_name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|bn
operator|=
name|li
operator|->
name|li_name
expr_stmt|;
else|else
name|bn
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|svn
operator|->
name|svn_file
operator|=
name|strdup
argument_list|(
name|bn
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|svn
operator|->
name|svn_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
name|STAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|svn
argument_list|,
name|svn_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|svn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_symver_verdef
modifier|*
name|_alloc_verdef
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symver_verdef_head
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ld_symver_verdef
modifier|*
name|svd
decl_stmt|;
if|if
condition|(
operator|(
name|svd
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|svd
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|svd
operator|->
name|svd_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
name|STAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|svd
argument_list|,
name|svd_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|svd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_load_verneed_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf
modifier|*
name|e
parameter_list|,
name|Elf_Scn
modifier|*
name|verneed
parameter_list|)
block|{
name|Elf_Data
modifier|*
name|d_vn
decl_stmt|;
name|Elf_Verneed
modifier|*
name|vn
decl_stmt|;
name|Elf_Vernaux
modifier|*
name|vna
decl_stmt|;
name|GElf_Shdr
name|sh_vn
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|verneed
argument_list|,
operator|&
name|sh_vn
argument_list|)
operator|!=
operator|&
name|sh_vn
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: gelf_getshdr failed: %s"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d_vn
operator|=
name|elf_getdata
argument_list|(
name|verneed
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: elf_getdata failed: %s"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d_vn
operator|->
name|d_size
operator|==
literal|0
condition|)
return|return;
name|buf
operator|=
name|d_vn
operator|->
name|d_buf
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|d_vn
operator|->
name|d_size
expr_stmt|;
while|while
condition|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verneed
argument_list|)
operator|<=
name|end
condition|)
block|{
name|vn
operator|=
operator|(
name|Elf_Verneed
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|buf2
operator|=
name|buf
operator|+
name|vn
operator|->
name|vn_aux
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf2
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Vernaux
argument_list|)
operator|<=
name|end
operator|&&
name|i
operator|<
name|vn
operator|->
name|vn_cnt
condition|)
block|{
name|vna
operator|=
operator|(
name|Elf32_Vernaux
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf2
expr_stmt|;
name|name
operator|=
name|elf_strptr
argument_list|(
name|e
argument_list|,
name|sh_vn
operator|.
name|sh_link
argument_list|,
name|vna
operator|->
name|vna_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|_add_version_name
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
operator|(
name|int
operator|)
name|vna
operator|->
name|vna_other
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|buf2
operator|+=
name|vna
operator|->
name|vna_next
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|vn
operator|->
name|vn_next
operator|==
literal|0
condition|)
break|break;
name|buf
operator|+=
name|vn
operator|->
name|vn_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_load_verdef_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf
modifier|*
name|e
parameter_list|,
name|Elf_Scn
modifier|*
name|verdef
parameter_list|)
block|{
name|struct
name|ld_symver_verdef
modifier|*
name|svd
decl_stmt|;
name|Elf_Data
modifier|*
name|d_vd
decl_stmt|;
name|Elf_Verdef
modifier|*
name|vd
decl_stmt|;
name|Elf_Verdaux
modifier|*
name|vda
decl_stmt|;
name|GElf_Shdr
name|sh_vd
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|verdef
argument_list|,
operator|&
name|sh_vd
argument_list|)
operator|!=
operator|&
name|sh_vd
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: gelf_getshdr failed: %s"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d_vd
operator|=
name|elf_getdata
argument_list|(
name|verdef
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"%s: elf_getdata failed: %s"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d_vd
operator|->
name|d_size
operator|==
literal|0
condition|)
return|return;
name|buf
operator|=
name|d_vd
operator|->
name|d_buf
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|d_vd
operator|->
name|d_size
expr_stmt|;
while|while
condition|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verdef
argument_list|)
operator|<=
name|end
condition|)
block|{
name|vd
operator|=
operator|(
name|Elf_Verdef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|svd
operator|=
name|_load_verdef
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|buf
operator|+
name|vd
operator|->
name|vd_aux
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf2
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Verdaux
argument_list|)
operator|<=
name|end
operator|&&
name|i
operator|<
name|vd
operator|->
name|vd_cnt
condition|)
block|{
name|vda
operator|=
operator|(
name|Elf_Verdaux
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|buf2
expr_stmt|;
name|name
operator|=
name|elf_strptr
argument_list|(
name|e
argument_list|,
name|sh_vd
operator|.
name|sh_link
argument_list|,
name|vda
operator|->
name|vda_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|_add_version_name
argument_list|(
name|ld
argument_list|,
name|li
argument_list|,
operator|(
name|int
operator|)
name|vd
operator|->
name|vd_ndx
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_alloc_vda
argument_list|(
name|ld
argument_list|,
name|name
argument_list|,
name|svd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vda
operator|->
name|vda_next
operator|==
literal|0
condition|)
break|break;
name|buf2
operator|+=
name|vda
operator|->
name|vda_next
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vd_next
operator|==
literal|0
condition|)
break|break;
name|buf
operator|+=
name|vd
operator|->
name|vd_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_symver_verdef
modifier|*
name|_load_verdef
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf_Verdef
modifier|*
name|vd
parameter_list|)
block|{
name|struct
name|ld_symver_verdef
modifier|*
name|svd
decl_stmt|;
if|if
condition|(
name|li
operator|->
name|li_verdef
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|li
operator|->
name|li_verdef
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|li
operator|->
name|li_verdef
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|li
operator|->
name|li_verdef
argument_list|)
expr_stmt|;
block|}
name|svd
operator|=
name|_alloc_verdef
argument_list|(
name|ld
argument_list|,
name|li
operator|->
name|li_verdef
argument_list|)
expr_stmt|;
name|svd
operator|->
name|svd_version
operator|=
name|vd
operator|->
name|vd_version
expr_stmt|;
name|svd
operator|->
name|svd_flags
operator|=
name|vd
operator|->
name|vd_flags
expr_stmt|;
name|svd
operator|->
name|svd_ndx
operator|=
name|vd
operator|->
name|vd_ndx
expr_stmt|;
name|svd
operator|->
name|svd_cnt
operator|=
name|vd
operator|->
name|vd_cnt
expr_stmt|;
name|svd
operator|->
name|svd_hash
operator|=
name|vd
operator|->
name|vd_hash
expr_stmt|;
return|return
operator|(
name|svd
operator|)
return|;
block|}
end_function

begin_function
name|uint16_t
name|ld_symver_search_version_script
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_script
modifier|*
name|lds
decl_stmt|;
name|struct
name|ld_script_version_node
modifier|*
name|ldvn
decl_stmt|;
name|struct
name|ld_script_version_entry
modifier|*
name|ldve
decl_stmt|,
modifier|*
name|ldve_g
decl_stmt|;
name|uint16_t
name|ndx
decl_stmt|,
name|ret_ndx
decl_stmt|,
name|ret_ndx_g
decl_stmt|;
comment|/* If the symbol version index was known, return it directly. */
if|if
condition|(
name|lsb
operator|->
name|lsb_vndx_known
condition|)
return|return
operator|(
name|lsb
operator|->
name|lsb_vndx
operator|)
return|;
comment|/* The symbol version index will be known after searching. */
name|lsb
operator|->
name|lsb_vndx_known
operator|=
literal|1
expr_stmt|;
name|lds
operator|=
name|ld
operator|->
name|ld_scp
expr_stmt|;
comment|/* If there isn't a version script, the default version is *global* */
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|lds
operator|->
name|lds_vn
argument_list|)
condition|)
block|{
name|lsb
operator|->
name|lsb_vndx
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Search for a match in the version patterns. */
name|ndx
operator|=
literal|2
expr_stmt|;
name|ldve_g
operator|=
name|NULL
expr_stmt|;
name|ret_ndx_g
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ldvn
argument_list|,
argument|&lds->lds_vn
argument_list|,
argument|ldvn_next
argument_list|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|ldve
argument_list|,
argument|ldvn->ldvn_e
argument_list|,
argument|ldve_next
argument_list|)
block|{
name|assert
argument_list|(
name|ldve
operator|->
name|ldve_sym
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnmatch
argument_list|(
name|ldve
operator|->
name|ldve_sym
argument_list|,
name|lsb
operator|->
name|lsb_name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ldve
operator|->
name|ldve_local
condition|)
name|ret_ndx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ldvn
operator|->
name|ldvn_name
operator|!=
name|NULL
condition|)
name|ret_ndx
operator|=
name|ndx
expr_stmt|;
else|else
name|ret_ndx
operator|=
literal|1
expr_stmt|;
comment|/* 				 * If the version name is a globbing pattern, 				 * we only consider it is a match when there 				 * doesn't exist a exact match. 				 */
if|if
condition|(
name|ldve
operator|->
name|ldve_glob
condition|)
block|{
if|if
condition|(
name|ldve_g
operator|==
name|NULL
condition|)
block|{
name|ldve_g
operator|=
name|ldve
expr_stmt|;
name|ret_ndx_g
operator|=
name|ret_ndx
expr_stmt|;
block|}
block|}
else|else
block|{
name|lsb
operator|->
name|lsb_vndx
operator|=
name|ret_ndx
expr_stmt|;
return|return
operator|(
name|ret_ndx
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|ldvn
operator|->
name|ldvn_name
operator|!=
name|NULL
condition|)
name|ndx
operator|++
expr_stmt|;
block|}
comment|/* There is no exact match, check if there is a globbing match. */
if|if
condition|(
name|ldve_g
operator|!=
name|NULL
condition|)
block|{
name|lsb
operator|->
name|lsb_vndx
operator|=
name|ret_ndx_g
expr_stmt|;
return|return
operator|(
name|ret_ndx_g
operator|)
return|;
block|}
comment|/* 	 * Symbol doesn't match any version definition, set version 	 * to *global*. 	 */
name|lsb
operator|->
name|lsb_vndx
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

