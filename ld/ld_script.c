begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011-2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ld_exp.h"
end_include

begin_include
include|#
directive|include
file|"ld_options.h"
end_include

begin_include
include|#
directive|include
file|"ld_script.h"
end_include

begin_include
include|#
directive|include
file|"ld_file.h"
end_include

begin_include
include|#
directive|include
file|"ld_symbols.h"
end_include

begin_include
include|#
directive|include
file|"ld_output.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: ld_script.c 3281 2015-12-11 21:39:23Z kaiwang27 $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|_input_file_add
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_input_file
modifier|*
name|ldif
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_overlay_section_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ld_script_variable
modifier|*
name|_variable_find
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|_variable_add
parameter_list|(
name|v
parameter_list|)
define|\
value|HASH_ADD_KEYPTR(hh, ld->ld_scp->lds_v, (v)->ldv_name, \ 	    strlen((v)->ldv_name), (v))
end_define

begin_function
name|struct
name|ld_script_cmd
modifier|*
name|ld_script_assert
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_exp
modifier|*
name|exp
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|ld_script_assert
modifier|*
name|a
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|a
operator|->
name|lda_exp
operator|=
name|exp
expr_stmt|;
name|a
operator|->
name|lda_msg
operator|=
name|msg
expr_stmt|;
return|return
operator|(
name|ld_script_cmd
argument_list|(
name|ld
argument_list|,
name|LSC_ASSERT
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ld_script_assign
modifier|*
name|ld_script_assign
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_exp
modifier|*
name|var
parameter_list|,
name|enum
name|ld_script_assign_op
name|op
parameter_list|,
name|struct
name|ld_exp
modifier|*
name|val
parameter_list|,
name|unsigned
name|provide
parameter_list|,
name|unsigned
name|hidden
parameter_list|)
block|{
name|struct
name|ld_script_assign
modifier|*
name|lda
decl_stmt|;
name|struct
name|ld_script_variable
modifier|*
name|ldv
decl_stmt|;
if|if
condition|(
operator|(
name|lda
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lda
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|lda
operator|->
name|lda_var
operator|=
name|var
expr_stmt|;
name|lda
operator|->
name|lda_op
operator|=
name|op
expr_stmt|;
name|lda
operator|->
name|lda_val
operator|=
name|val
expr_stmt|;
name|lda
operator|->
name|lda_provide
operator|=
name|provide
expr_stmt|;
if|if
condition|(
operator|(
name|ldv
operator|=
name|_variable_find
argument_list|(
name|ld
argument_list|,
name|var
operator|->
name|le_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ldv
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ldv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ldv
operator|->
name|ldv_name
operator|=
name|strdup
argument_list|(
name|var
operator|->
name|le_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|_variable_add
argument_list|(
name|ldv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|var
operator|->
name|le_name
operator|!=
literal|'.'
condition|)
name|ld_symbols_add_variable
argument_list|(
name|ld
argument_list|,
name|ldv
argument_list|,
name|provide
argument_list|,
name|hidden
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lda
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ld_script_assign_dump
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_assign
modifier|*
name|lda
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%16s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%016jx "
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lda
operator|->
name|lda_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|lda
operator|->
name|lda_provide
condition|)
name|printf
argument_list|(
literal|"PROVIDE("
argument_list|)
expr_stmt|;
name|ld_exp_dump
argument_list|(
name|ld
argument_list|,
name|lda
operator|->
name|lda_var
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lda
operator|->
name|lda_op
condition|)
block|{
case|case
name|LSAOP_ADD_E
case|:
name|printf
argument_list|(
literal|" += "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSAOP_AND_E
case|:
name|printf
argument_list|(
literal|"&= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSAOP_DIV_E
case|:
name|printf
argument_list|(
literal|" /= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSAOP_E
case|:
name|printf
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSAOP_LSHIFT_E
case|:
name|printf
argument_list|(
literal|"<<= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSAOP_MUL_E
case|:
name|printf
argument_list|(
literal|" *= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSAOP_OR_E
case|:
name|printf
argument_list|(
literal|" |= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSAOP_RSHIFT_E
case|:
name|printf
argument_list|(
literal|">>= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSAOP_SUB_E
case|:
name|printf
argument_list|(
literal|" -= "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"internal: unknown assignment op: %d"
argument_list|,
name|lda
operator|->
name|lda_op
argument_list|)
expr_stmt|;
block|}
name|ld_exp_dump
argument_list|(
name|ld
argument_list|,
name|lda
operator|->
name|lda_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|lda
operator|->
name|lda_provide
condition|)
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_script_assign_free
parameter_list|(
name|struct
name|ld_script_assign
modifier|*
name|lda
parameter_list|)
block|{
if|if
condition|(
name|lda
operator|==
name|NULL
condition|)
return|return;
name|ld_exp_free
argument_list|(
name|lda
operator|->
name|lda_var
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|lda
operator|->
name|lda_val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lda
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_update_variable_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_variable
modifier|*
name|ldv
parameter_list|)
block|{
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|,
modifier|*
name|last
decl_stmt|;
if|if
condition|(
name|ldv
operator|->
name|ldv_os_base
condition|)
block|{
comment|/* Get base address of the section. */
name|STAILQ_FOREACH
argument_list|(
argument|os
argument_list|,
argument|&ld->ld_output->lo_oslist
argument_list|,
argument|os_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|os
operator|->
name|os_name
argument_list|,
name|ldv
operator|->
name|ldv_os_base
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ldv
operator|->
name|ldv_base
operator|=
name|os
operator|->
name|os_addr
expr_stmt|;
name|ldv
operator|->
name|ldv_os_ref
operator|=
name|ldv
operator|->
name|ldv_os_base
expr_stmt|;
name|ldv
operator|->
name|ldv_os_base
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ldv
operator|->
name|ldv_os_ref
condition|)
block|{
comment|/* Bind the symbol to the last section. */
name|last
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|os
argument_list|,
argument|&ld->ld_output->lo_oslist
argument_list|,
argument|os_next
argument_list|)
block|{
if|if
condition|(
operator|!
name|os
operator|->
name|os_empty
condition|)
name|last
operator|=
name|os
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|os
operator|->
name|os_name
argument_list|,
name|ldv
operator|->
name|ldv_os_ref
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last
condition|)
block|{
name|ldv
operator|->
name|ldv_symbol
operator|->
name|lsb_shndx
operator|=
name|elf_ndxscn
argument_list|(
name|last
operator|->
name|os_scn
argument_list|)
expr_stmt|;
block|}
name|ldv
operator|->
name|ldv_os_ref
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|ld_script_process_assign
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_assign
modifier|*
name|lda
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_exp
modifier|*
name|var
decl_stmt|;
name|struct
name|ld_script_variable
modifier|*
name|ldv
decl_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
name|var
operator|=
name|lda
operator|->
name|lda_var
expr_stmt|;
name|ldv
operator|=
name|_variable_find
argument_list|(
name|ld
argument_list|,
name|var
operator|->
name|le_name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ldv
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ldv
operator|->
name|ldv_val
operator|=
name|ld_exp_eval
argument_list|(
name|ld
argument_list|,
name|lda
operator|->
name|lda_val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|var
operator|->
name|le_name
operator|==
literal|'.'
condition|)
block|{
comment|/* 		 * TODO: location counter is allowed to move backwards 		 * outside output section descriptor, as long as the 		 * move will not cause overlapping LMA's. 		 */
if|if
condition|(
operator|(
name|uint64_t
operator|)
name|ldv
operator|->
name|ldv_val
operator|<
name|ls
operator|->
name|ls_loc_counter
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"cannot move location counter backwards"
literal|" from %#jx to %#jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ls
operator|->
name|ls_loc_counter
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ldv
operator|->
name|ldv_val
argument_list|)
expr_stmt|;
name|ls
operator|->
name|ls_loc_counter
operator|=
operator|(
name|uint64_t
operator|)
name|ldv
operator|->
name|ldv_val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldv
operator|->
name|ldv_symbol
operator|!=
name|NULL
condition|)
block|{
name|_update_variable_section
argument_list|(
name|ld
argument_list|,
name|ldv
argument_list|)
expr_stmt|;
name|ldv
operator|->
name|ldv_symbol
operator|->
name|lsb_value
operator|=
name|ldv
operator|->
name|ldv_val
operator|+
name|ldv
operator|->
name|ldv_base
expr_stmt|;
block|}
name|lda
operator|->
name|lda_res
operator|=
name|ldv
operator|->
name|ldv_val
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_script_process_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|ld
operator|->
name|ld_scp
operator|->
name|lds_entry_point
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ld
operator|->
name|ld_scp
operator|->
name|lds_entry_point
argument_list|)
expr_stmt|;
name|ld
operator|->
name|ld_scp
operator|->
name|lds_entry_point
operator|=
name|NULL
expr_stmt|;
block|}
name|ld
operator|->
name|ld_scp
operator|->
name|lds_entry_point
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_scp
operator|->
name|lds_entry_point
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int64_t
name|ld_script_variable_value
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ld_script_variable
modifier|*
name|ldv
decl_stmt|;
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
return|return
operator|(
name|ls
operator|->
name|ls_loc_counter
operator|)
return|;
name|ldv
operator|=
name|_variable_find
argument_list|(
name|ld
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ldv
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ldv
operator|->
name|ldv_val
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ld_script_cmd
modifier|*
name|ld_script_cmd
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|enum
name|ld_script_cmd_type
name|type
parameter_list|,
name|void
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|ld_script_cmd
modifier|*
name|ldc
decl_stmt|;
if|if
condition|(
operator|(
name|ldc
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ldc
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|ldc
operator|->
name|ldc_type
operator|=
name|type
expr_stmt|;
name|ldc
operator|->
name|ldc_cmd
operator|=
name|cmd
expr_stmt|;
return|return
operator|(
name|ldc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ld_script_cmd_insert
parameter_list|(
name|struct
name|ld_script_cmd_head
modifier|*
name|head
parameter_list|,
name|struct
name|ld_script_cmd
modifier|*
name|ldc
parameter_list|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|ldc
argument_list|,
name|ldc_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_overlay_section_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|ld_script_cmd
modifier|*
name|c
decl_stmt|,
modifier|*
name|_c
decl_stmt|;
name|struct
name|ld_script_sections_overlay_section
modifier|*
name|ldos
decl_stmt|;
name|ldos
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|ldos
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|ldos
operator|->
name|ldos_name
argument_list|)
expr_stmt|;
name|ld_script_list_free
argument_list|(
name|ldos
operator|->
name|ldos_phdr
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|ldos
operator|->
name|ldos_fill
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|c
argument_list|,
argument|&ldos->ldos_c
argument_list|,
argument|ldc_next
argument_list|,
argument|_c
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ldos
operator|->
name|ldos_c
argument_list|,
name|c
argument_list|,
name|ld_script_cmd
argument_list|,
name|ldc_next
argument_list|)
expr_stmt|;
name|ld_script_cmd_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ldos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_script_cmd_free
parameter_list|(
name|struct
name|ld_script_cmd
modifier|*
name|ldc
parameter_list|)
block|{
name|struct
name|ld_script_cmd
modifier|*
name|c
decl_stmt|,
modifier|*
name|_c
decl_stmt|;
name|struct
name|ld_script_assert
modifier|*
name|lda
decl_stmt|;
name|struct
name|ld_script_sections
modifier|*
name|ldss
decl_stmt|;
name|struct
name|ld_script_sections_output
modifier|*
name|ldso
decl_stmt|;
name|struct
name|ld_script_sections_output_data
modifier|*
name|ldod
decl_stmt|;
name|struct
name|ld_script_sections_output_input
modifier|*
name|ldoi
decl_stmt|;
name|struct
name|ld_script_sections_overlay
modifier|*
name|ldso2
decl_stmt|;
switch|switch
condition|(
name|ldc
operator|->
name|ldc_type
condition|)
block|{
case|case
name|LSC_ASSERT
case|:
name|lda
operator|=
name|ldc
operator|->
name|ldc_cmd
expr_stmt|;
name|ld_exp_free
argument_list|(
name|lda
operator|->
name|lda_exp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lda
operator|->
name|lda_msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lda
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_ASSIGN
case|:
name|ld_script_assign_free
argument_list|(
name|ldc
operator|->
name|ldc_cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_ENTRY
case|:
name|free
argument_list|(
name|ldc
operator|->
name|ldc_cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_SECTIONS
case|:
name|ldss
operator|=
name|ldc
operator|->
name|ldc_cmd
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|c
argument_list|,
argument|&ldss->ldss_c
argument_list|,
argument|ldc_next
argument_list|,
argument|_c
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ldss
operator|->
name|ldss_c
argument_list|,
name|c
argument_list|,
name|ld_script_cmd
argument_list|,
name|ldc_next
argument_list|)
expr_stmt|;
name|ld_script_cmd_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ldss
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_SECTIONS_OUTPUT
case|:
name|ldso
operator|=
name|ldc
operator|->
name|ldc_cmd
expr_stmt|;
name|free
argument_list|(
name|ldso
operator|->
name|ldso_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldso
operator|->
name|ldso_type
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|ldso
operator|->
name|ldso_vma
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|ldso
operator|->
name|ldso_lma
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|ldso
operator|->
name|ldso_align
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|ldso
operator|->
name|ldso_subalign
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldso
operator|->
name|ldso_constraint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldso
operator|->
name|ldso_region
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldso
operator|->
name|ldso_lma_region
argument_list|)
expr_stmt|;
name|ld_script_list_free
argument_list|(
name|ldso
operator|->
name|ldso_phdr
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|ldso
operator|->
name|ldso_fill
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|c
argument_list|,
argument|&ldso->ldso_c
argument_list|,
argument|ldc_next
argument_list|,
argument|_c
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ldso
operator|->
name|ldso_c
argument_list|,
name|c
argument_list|,
name|ld_script_cmd
argument_list|,
name|ldc_next
argument_list|)
expr_stmt|;
name|ld_script_cmd_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ldso
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_SECTIONS_OUTPUT_DATA
case|:
name|ldod
operator|=
name|ldc
operator|->
name|ldc_cmd
expr_stmt|;
name|ld_exp_free
argument_list|(
name|ldod
operator|->
name|ldod_exp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldod
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_SECTIONS_OUTPUT_INPUT
case|:
name|ldoi
operator|=
name|ldc
operator|->
name|ldc_cmd
expr_stmt|;
name|ld_wildcard_free
argument_list|(
name|ldoi
operator|->
name|ldoi_ar
argument_list|)
expr_stmt|;
name|ld_wildcard_free
argument_list|(
name|ldoi
operator|->
name|ldoi_file
argument_list|)
expr_stmt|;
name|ld_script_list_free
argument_list|(
name|ldoi
operator|->
name|ldoi_exclude
argument_list|,
name|ld_wildcard_free
argument_list|)
expr_stmt|;
name|ld_script_list_free
argument_list|(
name|ldoi
operator|->
name|ldoi_sec
argument_list|,
name|ld_wildcard_free
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldoi
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSC_SECTIONS_OVERLAY
case|:
name|ldso2
operator|=
name|ldc
operator|->
name|ldc_cmd
expr_stmt|;
name|ld_exp_free
argument_list|(
name|ldso2
operator|->
name|ldso_vma
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|ldso2
operator|->
name|ldso_lma
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldso2
operator|->
name|ldso_region
argument_list|)
expr_stmt|;
name|ld_script_list_free
argument_list|(
name|ldso2
operator|->
name|ldso_phdr
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|ldso2
operator|->
name|ldso_fill
argument_list|)
expr_stmt|;
name|ld_script_list_free
argument_list|(
name|ldso2
operator|->
name|ldso_s
argument_list|,
name|_overlay_section_free
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldso2
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|free
argument_list|(
name|ldc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_script_extern
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|ld_script_list
modifier|*
name|ldl
decl_stmt|;
name|ldl
operator|=
name|list
expr_stmt|;
while|while
condition|(
name|ldl
operator|!=
name|NULL
condition|)
block|{
name|ld_symbols_add_extern
argument_list|(
name|ld
argument_list|,
name|ldl
operator|->
name|ldl_entry
argument_list|)
expr_stmt|;
name|ldl
operator|=
name|ldl
operator|->
name|ldl_next
expr_stmt|;
block|}
name|ld_script_list_free
argument_list|(
name|list
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_script_group
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|ld_script_list
modifier|*
name|ldl
decl_stmt|;
name|ld
operator|->
name|ld_state
operator|.
name|ls_group_level
operator|++
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_state
operator|.
name|ls_group_level
operator|>
name|LD_MAX_NESTED_GROUP
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"too many nested archive groups"
argument_list|)
expr_stmt|;
name|ldl
operator|=
name|list
expr_stmt|;
while|while
condition|(
name|ldl
operator|!=
name|NULL
condition|)
block|{
name|_input_file_add
argument_list|(
name|ld
argument_list|,
name|ldl
operator|->
name|ldl_entry
argument_list|)
expr_stmt|;
name|ldl
operator|=
name|ldl
operator|->
name|ldl_next
expr_stmt|;
block|}
name|ld
operator|->
name|ld_state
operator|.
name|ls_group_level
operator|--
expr_stmt|;
name|ld_script_list_free
argument_list|(
name|list
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_script_init
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|ld
operator|->
name|ld_scp
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ld
operator|->
name|ld_scp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_scp
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ld
operator|->
name|ld_scp
operator|->
name|lds_a
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ld
operator|->
name|ld_scp
operator|->
name|lds_c
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ld
operator|->
name|ld_scp
operator|->
name|lds_n
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ld
operator|->
name|ld_scp
operator|->
name|lds_p
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ld
operator|->
name|ld_scp
operator|->
name|lds_r
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ld
operator|->
name|ld_scp
operator|->
name|lds_vn
argument_list|)
expr_stmt|;
name|ld_script_parse_internal
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_script_cleanup
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_script
modifier|*
name|lds
decl_stmt|;
name|struct
name|ld_script_phdr
modifier|*
name|p
decl_stmt|,
modifier|*
name|_p
decl_stmt|;
name|struct
name|ld_script_region
modifier|*
name|r
decl_stmt|,
modifier|*
name|_r
decl_stmt|;
name|struct
name|ld_script_region_alias
modifier|*
name|a
decl_stmt|,
modifier|*
name|_a
decl_stmt|;
name|struct
name|ld_script_nocrossref
modifier|*
name|n
decl_stmt|,
modifier|*
name|_n
decl_stmt|;
name|struct
name|ld_script_cmd
modifier|*
name|c
decl_stmt|,
modifier|*
name|_c
decl_stmt|;
name|struct
name|ld_script_variable
modifier|*
name|v
decl_stmt|,
modifier|*
name|_v
decl_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_scp
operator|==
name|NULL
condition|)
return|return;
name|lds
operator|=
name|ld
operator|->
name|ld_scp
expr_stmt|;
if|if
condition|(
name|lds
operator|->
name|lds_entry_point
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|lds
operator|->
name|lds_entry_point
argument_list|)
expr_stmt|;
name|lds
operator|->
name|lds_entry_point
operator|=
name|NULL
expr_stmt|;
block|}
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|p
argument_list|,
argument|&lds->lds_p
argument_list|,
argument|ldsp_next
argument_list|,
argument|_p
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|lds
operator|->
name|lds_p
argument_list|,
name|p
argument_list|,
name|ld_script_phdr
argument_list|,
name|ldsp_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|ldsp_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|ldsp_type
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|p
operator|->
name|ldsp_addr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|r
argument_list|,
argument|&lds->lds_r
argument_list|,
argument|ldsr_next
argument_list|,
argument|_r
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|lds
operator|->
name|lds_r
argument_list|,
name|r
argument_list|,
name|ld_script_region
argument_list|,
name|ldsr_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
operator|->
name|ldsr_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
operator|->
name|ldsr_attr
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|r
operator|->
name|ldsr_origin
argument_list|)
expr_stmt|;
name|ld_exp_free
argument_list|(
name|r
operator|->
name|ldsr_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|a
argument_list|,
argument|&lds->lds_a
argument_list|,
argument|ldra_next
argument_list|,
argument|_a
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|lds
operator|->
name|lds_a
argument_list|,
name|a
argument_list|,
name|ld_script_region_alias
argument_list|,
name|ldra_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|ldra_alias
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|ldra_region
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|n
argument_list|,
argument|&lds->lds_n
argument_list|,
argument|ldn_next
argument_list|,
argument|_n
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|lds
operator|->
name|lds_n
argument_list|,
name|n
argument_list|,
name|ld_script_nocrossref
argument_list|,
name|ldn_next
argument_list|)
expr_stmt|;
name|ld_script_list_free
argument_list|(
name|n
operator|->
name|ldn_l
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|c
argument_list|,
argument|&lds->lds_c
argument_list|,
argument|ldc_next
argument_list|,
argument|_c
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|lds
operator|->
name|lds_c
argument_list|,
name|c
argument_list|,
name|ld_script_cmd
argument_list|,
name|ldc_next
argument_list|)
expr_stmt|;
name|ld_script_cmd_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lds
operator|->
name|lds_v
operator|!=
name|NULL
condition|)
block|{
name|HASH_ITER
argument_list|(
argument|hh
argument_list|,
argument|lds->lds_v
argument_list|,
argument|v
argument_list|,
argument|_v
argument_list|)
block|{
name|HASH_DEL
argument_list|(
name|lds
operator|->
name|lds_v
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
operator|->
name|ldv_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|lds
operator|->
name|lds_v
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ld_script_input
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|ld_script_list
modifier|*
name|ldl
decl_stmt|;
name|ld
operator|->
name|ld_state
operator|.
name|ls_search_dir
operator|=
literal|1
expr_stmt|;
name|ldl
operator|=
name|list
expr_stmt|;
while|while
condition|(
name|ldl
operator|!=
name|NULL
condition|)
block|{
name|_input_file_add
argument_list|(
name|ld
argument_list|,
name|ldl
operator|->
name|ldl_entry
argument_list|)
expr_stmt|;
name|ldl
operator|=
name|ldl
operator|->
name|ldl_next
expr_stmt|;
block|}
name|ld
operator|->
name|ld_state
operator|.
name|ls_search_dir
operator|=
literal|0
expr_stmt|;
name|ld_script_list_free
argument_list|(
name|list
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ld_script_input_file
modifier|*
name|ld_script_input_file
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|unsigned
name|as_needed
parameter_list|,
name|void
modifier|*
name|in
parameter_list|)
block|{
name|struct
name|ld_script_input_file
modifier|*
name|ldif
decl_stmt|;
if|if
condition|(
operator|(
name|ldif
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ldif
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|ldif
operator|->
name|ldif_as_needed
operator|=
name|as_needed
expr_stmt|;
if|if
condition|(
name|as_needed
condition|)
name|ldif
operator|->
name|ldif_u
operator|.
name|ldif_ldl
operator|=
name|in
expr_stmt|;
else|else
name|ldif
operator|->
name|ldif_u
operator|.
name|ldif_name
operator|=
name|in
expr_stmt|;
return|return
operator|(
name|ldif
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ld_script_list
modifier|*
name|ld_script_list
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_list
modifier|*
name|list
parameter_list|,
name|void
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|ld_script_list
modifier|*
name|ldl
decl_stmt|;
if|if
condition|(
operator|(
name|ldl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ldl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|ldl
operator|->
name|ldl_entry
operator|=
name|entry
expr_stmt|;
name|ldl
operator|->
name|ldl_next
operator|=
name|list
expr_stmt|;
return|return
operator|(
name|ldl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ld_script_list_free
parameter_list|(
name|struct
name|ld_script_list
modifier|*
name|list
parameter_list|,
name|void
function_decl|(
modifier|*
name|_free
function_decl|)
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
parameter_list|)
block|{
name|struct
name|ld_script_list
modifier|*
name|ldl
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return;
do|do
block|{
name|ldl
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|ldl
operator|->
name|ldl_next
expr_stmt|;
if|if
condition|(
name|ldl
operator|->
name|ldl_entry
condition|)
name|_free
argument_list|(
name|ldl
operator|->
name|ldl_entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldl
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|list
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
name|struct
name|ld_script_list
modifier|*
name|ld_script_list_reverse
parameter_list|(
name|struct
name|ld_script_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|ld_script_list
modifier|*
name|root
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|root
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|list
operator|->
name|ldl_next
expr_stmt|;
name|list
operator|->
name|ldl_next
operator|=
name|root
expr_stmt|;
name|root
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
name|root
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ld_script_nocrossrefs
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|ld_script_nocrossref
modifier|*
name|ldn
decl_stmt|;
if|if
condition|(
operator|(
name|ldn
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ldn
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|ldn
operator|->
name|ldn_l
operator|=
name|list
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ld
operator|->
name|ld_scp
operator|->
name|lds_n
argument_list|,
name|ldn
argument_list|,
name|ldn_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ld_script_phdr
modifier|*
name|ld_script_phdr
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|type
parameter_list|,
name|unsigned
name|filehdr
parameter_list|,
name|unsigned
name|phdrs
parameter_list|,
name|struct
name|ld_exp
modifier|*
name|addr
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|struct
name|ld_script_phdr
modifier|*
name|ldsp
decl_stmt|;
if|if
condition|(
operator|(
name|ldsp
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ldsp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|ldsp
operator|->
name|ldsp_name
operator|=
name|name
expr_stmt|;
name|ldsp
operator|->
name|ldsp_type
operator|=
name|type
expr_stmt|;
name|ldsp
operator|->
name|ldsp_filehdr
operator|=
name|filehdr
expr_stmt|;
name|ldsp
operator|->
name|ldsp_phdrs
operator|=
name|phdrs
expr_stmt|;
name|ldsp
operator|->
name|ldsp_addr
operator|=
name|addr
expr_stmt|;
name|ldsp
operator|->
name|ldsp_flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|ldsp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ld_script_region
modifier|*
name|ld_script_region
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|attr
parameter_list|,
name|struct
name|ld_exp
modifier|*
name|origin
parameter_list|,
name|struct
name|ld_exp
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|ld_script_region
modifier|*
name|ldsr
decl_stmt|;
if|if
condition|(
operator|(
name|ldsr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ldsr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|ldsr
operator|->
name|ldsr_name
operator|=
name|name
expr_stmt|;
name|ldsr
operator|->
name|ldsr_attr
operator|=
name|attr
expr_stmt|;
name|ldsr
operator|->
name|ldsr_origin
operator|=
name|origin
expr_stmt|;
name|ldsr
operator|->
name|ldsr_len
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|ldsr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ld_script_region_alias
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|alias
parameter_list|,
name|char
modifier|*
name|region
parameter_list|)
block|{
name|struct
name|ld_script_region_alias
modifier|*
name|ldra
decl_stmt|;
if|if
condition|(
operator|(
name|ldra
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ldra
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|ldra
operator|->
name|ldra_alias
operator|=
name|alias
expr_stmt|;
name|ldra
operator|->
name|ldra_region
operator|=
name|region
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ld
operator|->
name|ld_scp
operator|->
name|lds_a
argument_list|,
name|ldra
argument_list|,
name|ldra_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_script_version_add_node
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|ver
parameter_list|,
name|void
modifier|*
name|head
parameter_list|,
name|char
modifier|*
name|depend
parameter_list|)
block|{
name|struct
name|ld_script_version_node
modifier|*
name|ldvn
decl_stmt|;
if|if
condition|(
operator|(
name|ldvn
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ldvn
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|ldvn
operator|->
name|ldvn_name
operator|=
name|ver
expr_stmt|;
if|if
condition|(
name|ldvn
operator|->
name|ldvn_name
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Version name can be omitted only when this is the only 		 * node in the version script. 		 */
if|if
condition|(
name|ld
operator|->
name|ld_scp
operator|->
name|lds_vn_name_omitted
operator|||
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ld
operator|->
name|ld_scp
operator|->
name|lds_vn
argument_list|)
condition|)
name|ld_fatal
argument_list|(
name|ld
argument_list|,
literal|"version script can only have one "
literal|"version node that is without a version name"
argument_list|)
expr_stmt|;
name|ld
operator|->
name|ld_scp
operator|->
name|lds_vn_name_omitted
operator|=
literal|1
expr_stmt|;
block|}
name|ldvn
operator|->
name|ldvn_dep
operator|=
name|depend
expr_stmt|;
name|ldvn
operator|->
name|ldvn_e
operator|=
name|head
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ld
operator|->
name|ld_scp
operator|->
name|lds_vn
argument_list|,
name|ldvn
argument_list|,
name|ldvn_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ld_script_version_entry
modifier|*
name|ld_script_version_alloc_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|sym
parameter_list|,
name|void
modifier|*
name|extern_block
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_script_version_entry
modifier|*
name|ldve
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
if|if
condition|(
operator|(
name|ldve
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ldve
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|ldve
operator|->
name|ldve_sym
operator|=
name|sym
expr_stmt|;
name|ldve
operator|->
name|ldve_local
operator|=
name|ls
operator|->
name|ls_version_local
expr_stmt|;
name|ldve
operator|->
name|ldve_list
operator|=
name|extern_block
expr_stmt|;
if|if
condition|(
name|ldve
operator|->
name|ldve_sym
operator|==
name|NULL
condition|)
return|return
operator|(
name|ldve
operator|)
return|;
name|ignore
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ldve
operator|->
name|ldve_sym
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
comment|/* Ignore the next char */
name|ignore
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
case|case
literal|'['
case|:
if|if
condition|(
operator|!
name|ignore
condition|)
block|{
name|ldve
operator|->
name|ldve_glob
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|ignore
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|done
label|:
return|return
operator|(
name|ldve
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ld_script_version_link_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_version_entry_head
modifier|*
name|head
parameter_list|,
name|struct
name|ld_script_version_entry
modifier|*
name|ldve
parameter_list|)
block|{
if|if
condition|(
name|ldve
operator|==
name|NULL
condition|)
return|return
operator|(
name|head
operator|)
return|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|head
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|head
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ldve
operator|->
name|ldve_list
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_CONCAT
argument_list|(
name|head
argument_list|,
name|ldve
operator|->
name|ldve_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldve
operator|->
name|ldve_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldve
argument_list|)
expr_stmt|;
block|}
else|else
name|STAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|ldve
argument_list|,
name|ldve_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ld_script_version_set_lang
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_version_entry_head
modifier|*
name|head
parameter_list|,
name|char
modifier|*
name|lang
parameter_list|)
block|{
name|struct
name|ld_script_version_entry
modifier|*
name|ldve
decl_stmt|;
name|enum
name|ld_script_version_lang
name|vl
decl_stmt|;
name|vl
operator|=
name|VL_C
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|lang
argument_list|,
literal|"c"
argument_list|)
condition|)
name|vl
operator|=
name|VL_C
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|lang
argument_list|,
literal|"c++"
argument_list|)
condition|)
name|vl
operator|=
name|VL_CPP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|lang
argument_list|,
literal|"java"
argument_list|)
condition|)
name|vl
operator|=
name|VL_JAVA
expr_stmt|;
else|else
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"unrecognized language `%s' in version script"
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ldve
argument_list|,
argument|head
argument_list|,
argument|ldve_next
argument_list|)
block|{
comment|/* Do not overwrite lang set by inner extern blocks. */
if|if
condition|(
operator|!
name|ldve
operator|->
name|ldve_lang_set
condition|)
block|{
name|ldve
operator|->
name|ldve_lang
operator|=
name|vl
expr_stmt|;
name|ldve
operator|->
name|ldve_lang_set
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_input_file_add
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_script_input_file
modifier|*
name|ldif
parameter_list|)
block|{
name|struct
name|ld_state
modifier|*
name|ls
decl_stmt|;
name|struct
name|ld_script_list
modifier|*
name|ldl
decl_stmt|;
name|unsigned
name|old_as_needed
decl_stmt|;
name|ls
operator|=
operator|&
name|ld
operator|->
name|ld_state
expr_stmt|;
if|if
condition|(
operator|!
name|ldif
operator|->
name|ldif_as_needed
condition|)
block|{
name|ld_file_add
argument_list|(
name|ld
argument_list|,
name|ldif
operator|->
name|ldif_u
operator|.
name|ldif_name
argument_list|,
name|LFT_UNKNOWN
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldif
operator|->
name|ldif_u
operator|.
name|ldif_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old_as_needed
operator|=
name|ls
operator|->
name|ls_as_needed
expr_stmt|;
name|ls
operator|->
name|ls_as_needed
operator|=
literal|1
expr_stmt|;
name|ldl
operator|=
name|ldif
operator|->
name|ldif_u
operator|.
name|ldif_ldl
expr_stmt|;
while|while
condition|(
name|ldl
operator|!=
name|NULL
condition|)
block|{
name|ld_file_add
argument_list|(
name|ld
argument_list|,
name|ldl
operator|->
name|ldl_entry
argument_list|,
name|LFT_UNKNOWN
argument_list|)
expr_stmt|;
name|ldl
operator|=
name|ldl
operator|->
name|ldl_next
expr_stmt|;
block|}
name|ls
operator|->
name|ls_as_needed
operator|=
name|old_as_needed
expr_stmt|;
name|ld_script_list_free
argument_list|(
name|ldif
operator|->
name|ldif_u
operator|.
name|ldif_ldl
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ld_script_variable
modifier|*
name|_variable_find
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ld_script_variable
modifier|*
name|ldv
decl_stmt|;
name|HASH_FIND_STR
argument_list|(
name|ld
operator|->
name|ld_scp
operator|->
name|lds_v
argument_list|,
name|name
argument_list|,
name|ldv
argument_list|)
expr_stmt|;
return|return
operator|(
name|ldv
operator|)
return|;
block|}
end_function

end_unit

