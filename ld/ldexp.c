begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This module handles expression trees.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support<sac@cygnus.com>.     This file is part of GLD, the Gnu Linker.     GLD is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GLD is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GLD; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* This module is in charge of working out the contents of expressions.     It has to keep track of the relative/absness of a symbol etc. This    is done by keeping all values in a struct (an etree_value_type)    which contains a value, a section to which it is relative and a    valid bit.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|<ldgram.h>
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_function_decl
specifier|static
name|void
name|exp_fold_tree_1
parameter_list|(
name|etree_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exp_fold_tree_no_dot
parameter_list|(
name|etree_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|align_n
parameter_list|(
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|segment_type
modifier|*
name|segments
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ldexp_control
name|expld
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the string representation of the given token.  Surround it    with spaces if INFIX_P is TRUE.  */
end_comment

begin_function
specifier|static
name|void
name|exp_print_token
parameter_list|(
name|token_code_type
name|code
parameter_list|,
name|int
name|infix_p
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
name|token_code_type
name|code
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|table
index|[]
init|=
block|{
block|{
name|INT
block|,
literal|"int"
block|}
block|,
block|{
name|NAME
block|,
literal|"NAME"
block|}
block|,
block|{
name|PLUSEQ
block|,
literal|"+="
block|}
block|,
block|{
name|MINUSEQ
block|,
literal|"-="
block|}
block|,
block|{
name|MULTEQ
block|,
literal|"*="
block|}
block|,
block|{
name|DIVEQ
block|,
literal|"/="
block|}
block|,
block|{
name|LSHIFTEQ
block|,
literal|"<<="
block|}
block|,
block|{
name|RSHIFTEQ
block|,
literal|">>="
block|}
block|,
block|{
name|ANDEQ
block|,
literal|"&="
block|}
block|,
block|{
name|OREQ
block|,
literal|"|="
block|}
block|,
block|{
name|OROR
block|,
literal|"||"
block|}
block|,
block|{
name|ANDAND
block|,
literal|"&&"
block|}
block|,
block|{
name|EQ
block|,
literal|"=="
block|}
block|,
block|{
name|NE
block|,
literal|"!="
block|}
block|,
block|{
name|LE
block|,
literal|"<="
block|}
block|,
block|{
name|GE
block|,
literal|">="
block|}
block|,
block|{
name|LSHIFT
block|,
literal|"<<"
block|}
block|,
block|{
name|RSHIFT
block|,
literal|">>"
block|}
block|,
block|{
name|ALIGN_K
block|,
literal|"ALIGN"
block|}
block|,
block|{
name|BLOCK
block|,
literal|"BLOCK"
block|}
block|,
block|{
name|QUAD
block|,
literal|"QUAD"
block|}
block|,
block|{
name|SQUAD
block|,
literal|"SQUAD"
block|}
block|,
block|{
name|LONG
block|,
literal|"LONG"
block|}
block|,
block|{
name|SHORT
block|,
literal|"SHORT"
block|}
block|,
block|{
name|BYTE
block|,
literal|"BYTE"
block|}
block|,
block|{
name|SECTIONS
block|,
literal|"SECTIONS"
block|}
block|,
block|{
name|SIZEOF_HEADERS
block|,
literal|"SIZEOF_HEADERS"
block|}
block|,
block|{
name|MEMORY
block|,
literal|"MEMORY"
block|}
block|,
block|{
name|DEFINED
block|,
literal|"DEFINED"
block|}
block|,
block|{
name|TARGET_K
block|,
literal|"TARGET"
block|}
block|,
block|{
name|SEARCH_DIR
block|,
literal|"SEARCH_DIR"
block|}
block|,
block|{
name|MAP
block|,
literal|"MAP"
block|}
block|,
block|{
name|ENTRY
block|,
literal|"ENTRY"
block|}
block|,
block|{
name|NEXT
block|,
literal|"NEXT"
block|}
block|,
block|{
name|SIZEOF
block|,
literal|"SIZEOF"
block|}
block|,
block|{
name|ADDR
block|,
literal|"ADDR"
block|}
block|,
block|{
name|LOADADDR
block|,
literal|"LOADADDR"
block|}
block|,
block|{
name|MAX_K
block|,
literal|"MAX_K"
block|}
block|,
block|{
name|REL
block|,
literal|"relocatable"
block|}
block|,
block|{
name|DATA_SEGMENT_ALIGN
block|,
literal|"DATA_SEGMENT_ALIGN"
block|}
block|,
block|{
name|DATA_SEGMENT_RELRO_END
block|,
literal|"DATA_SEGMENT_RELRO_END"
block|}
block|,
block|{
name|DATA_SEGMENT_END
block|,
literal|"DATA_SEGMENT_END"
block|}
block|,
block|{
name|ORIGIN
block|,
literal|"ORIGIN"
block|}
block|,
block|{
name|LENGTH
block|,
literal|"LENGTH"
block|}
block|,
block|{
name|SEGMENT_START
block|,
literal|"SEGMENT_START"
block|}
block|}
struct|;
name|unsigned
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|ARRAY_SIZE
argument_list|(
name|table
argument_list|)
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|table
index|[
name|idx
index|]
operator|.
name|code
operator|==
name|code
condition|)
break|break;
if|if
condition|(
name|infix_p
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|config
operator|.
name|map_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|ARRAY_SIZE
argument_list|(
name|table
argument_list|)
condition|)
name|fputs
argument_list|(
name|table
index|[
name|idx
index|]
operator|.
name|name
argument_list|,
name|config
operator|.
name|map_file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|<
literal|127
condition|)
name|fputc
argument_list|(
name|code
argument_list|,
name|config
operator|.
name|map_file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"<code %d>"
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|infix_p
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|config
operator|.
name|map_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_abs
parameter_list|(
name|void
parameter_list|)
block|{
name|expld
operator|.
name|result
operator|.
name|value
operator|+=
name|expld
operator|.
name|result
operator|.
name|section
operator|->
name|vma
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_abs
parameter_list|(
name|bfd_vma
name|value
parameter_list|)
block|{
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|=
name|TRUE
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_intop
parameter_list|(
name|bfd_vma
name|value
parameter_list|)
block|{
name|etree_type
modifier|*
name|new
init|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|value
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|type
operator|.
name|node_code
operator|=
name|INT
expr_stmt|;
name|new
operator|->
name|value
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|new
operator|->
name|value
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|type
operator|.
name|node_class
operator|=
name|etree_value
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_bigintop
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|etree_type
modifier|*
name|new
init|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|value
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|type
operator|.
name|node_code
operator|=
name|INT
expr_stmt|;
name|new
operator|->
name|value
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|new
operator|->
name|value
operator|.
name|str
operator|=
name|str
expr_stmt|;
name|new
operator|->
name|type
operator|.
name|node_class
operator|=
name|etree_value
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing an unnamed relocatable value.  */
end_comment

begin_function
name|etree_type
modifier|*
name|exp_relop
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
name|etree_type
modifier|*
name|new
init|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|rel
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|type
operator|.
name|node_code
operator|=
name|REL
expr_stmt|;
name|new
operator|->
name|type
operator|.
name|node_class
operator|=
name|etree_rel
expr_stmt|;
name|new
operator|->
name|rel
operator|.
name|section
operator|=
name|section
expr_stmt|;
name|new
operator|->
name|rel
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_rel
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|=
name|TRUE
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|str
operator|=
name|str
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|section
operator|=
name|section
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_rel_from_abs
parameter_list|(
name|bfd_vma
name|value
parameter_list|)
block|{
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|=
name|TRUE
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|value
operator|-
name|expld
operator|.
name|section
operator|->
name|vma
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|section
operator|=
name|expld
operator|.
name|section
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fold_unary
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|)
block|{
name|exp_fold_tree_1
argument_list|(
name|tree
operator|->
name|unary
operator|.
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
block|{
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
name|ALIGN_K
case|:
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_first_phase_enum
condition|)
name|new_rel_from_abs
argument_list|(
name|align_n
argument_list|(
name|expld
operator|.
name|dot
argument_list|,
name|expld
operator|.
name|result
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|ABSOLUTE
case|:
name|make_abs
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|make_abs
argument_list|()
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|value
operator|=
operator|~
name|expld
operator|.
name|result
operator|.
name|value
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|make_abs
argument_list|()
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|value
operator|=
operator|!
name|expld
operator|.
name|result
operator|.
name|value
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|make_abs
argument_list|()
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|value
operator|=
operator|-
name|expld
operator|.
name|result
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|NEXT
case|:
comment|/* Return next place aligned to value.  */
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|make_abs
argument_list|()
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|align_n
argument_list|(
name|expld
operator|.
name|dot
argument_list|,
name|expld
operator|.
name|result
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DATA_SEGMENT_END
case|:
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_first_phase_enum
operator|&&
name|expld
operator|.
name|section
operator|==
name|bfd_abs_section_ptr
operator|&&
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_align_seen
operator|||
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_relro_seen
operator|||
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_adjust
operator|||
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_relro_adjust
operator|||
name|expld
operator|.
name|phase
operator|==
name|lang_final_phase_enum
operator|)
condition|)
block|{
if|if
condition|(
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_align_seen
operator|||
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_relro_seen
condition|)
block|{
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|=
name|exp_dataseg_end_seen
expr_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|end
operator|=
name|expld
operator|.
name|result
operator|.
name|value
expr_stmt|;
block|}
block|}
else|else
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fold_binary
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|)
block|{
name|exp_fold_tree_1
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|lhs
argument_list|)
expr_stmt|;
comment|/* The SEGMENT_START operator is special because its first      operand is a string, not the name of a symbol.  */
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|&&
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
name|SEGMENT_START
condition|)
block|{
specifier|const
name|char
modifier|*
name|segment_name
decl_stmt|;
name|segment_type
modifier|*
name|seg
decl_stmt|;
comment|/* Check to see if the user has overridden the default 	 value.  */
name|segment_name
operator|=
name|tree
operator|->
name|binary
operator|.
name|rhs
operator|->
name|name
operator|.
name|name
expr_stmt|;
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
condition|;
name|seg
operator|=
name|seg
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|seg
operator|->
name|name
argument_list|,
name|segment_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|seg
operator|->
name|used
operator|=
name|TRUE
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|seg
operator|->
name|value
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|section
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
block|{
name|etree_value_type
name|lhs
init|=
name|expld
operator|.
name|result
decl_stmt|;
name|exp_fold_tree_1
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
block|{
comment|/* If the values are from different sections, or this is an 	     absolute expression, make both the source arguments 	     absolute.  However, adding or subtracting an absolute 	     value from a relative value is meaningful, and is an 	     exception.  */
if|if
condition|(
name|expld
operator|.
name|section
operator|!=
name|bfd_abs_section_ptr
operator|&&
name|lhs
operator|.
name|section
operator|==
name|bfd_abs_section_ptr
operator|&&
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
literal|'+'
condition|)
block|{
comment|/* Keep the section of the rhs term.  */
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|lhs
operator|.
name|value
operator|+
name|expld
operator|.
name|result
operator|.
name|value
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|expld
operator|.
name|section
operator|!=
name|bfd_abs_section_ptr
operator|&&
name|expld
operator|.
name|result
operator|.
name|section
operator|==
name|bfd_abs_section_ptr
operator|&&
operator|(
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
literal|'+'
operator|||
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
literal|'-'
operator|)
condition|)
block|{
comment|/* Keep the section of the lhs term.  */
name|expld
operator|.
name|result
operator|.
name|section
operator|=
name|lhs
operator|.
name|section
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|section
operator|!=
name|lhs
operator|.
name|section
operator|||
name|expld
operator|.
name|section
operator|==
name|bfd_abs_section_ptr
condition|)
block|{
name|make_abs
argument_list|()
expr_stmt|;
name|lhs
operator|.
name|value
operator|+=
name|lhs
operator|.
name|section
operator|->
name|vma
expr_stmt|;
block|}
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
literal|'%'
case|:
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|value
operator|!=
literal|0
condition|)
name|expld
operator|.
name|result
operator|.
name|value
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|lhs
operator|.
name|value
operator|%
operator|(
name|bfd_signed_vma
operator|)
name|expld
operator|.
name|result
operator|.
name|value
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S %% by zero\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|value
operator|!=
literal|0
condition|)
name|expld
operator|.
name|result
operator|.
name|value
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|lhs
operator|.
name|value
operator|/
operator|(
name|bfd_signed_vma
operator|)
name|expld
operator|.
name|result
operator|.
name|value
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S / by zero\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
define|#
directive|define
name|BOP
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|case x:							\ 	      expld.result.value = lhs.value y expld.result.value;	\ 	      break;
name|BOP
argument_list|(
literal|'+'
argument_list|,
operator|+
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'*'
argument_list|,
operator|*
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'-'
argument_list|,
operator|-
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|LSHIFT
argument_list|,
operator|<<
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|RSHIFT
argument_list|,
operator|>>
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|EQ
argument_list|,
operator|==
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|NE
argument_list|,
operator|!=
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'<'
argument_list|,
operator|<
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'>'
argument_list|,
operator|>
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|LE
argument_list|,
operator|<=
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|GE
argument_list|,
operator|>=
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'&'
argument_list|,
operator|&
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'^'
argument_list|,
operator|^
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'|'
argument_list|,
operator||
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|ANDAND
argument_list|,
operator|&&
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|OROR
argument_list|,
operator|||
argument_list|)
expr_stmt|;
case|case
name|MAX_K
case|:
if|if
condition|(
name|lhs
operator|.
name|value
operator|>
name|expld
operator|.
name|result
operator|.
name|value
condition|)
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|lhs
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|MIN_K
case|:
if|if
condition|(
name|lhs
operator|.
name|value
operator|<
name|expld
operator|.
name|result
operator|.
name|value
condition|)
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|lhs
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|ALIGN_K
case|:
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|align_n
argument_list|(
name|lhs
operator|.
name|value
argument_list|,
name|expld
operator|.
name|result
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_SEGMENT_ALIGN
case|:
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_first_phase_enum
operator|&&
name|expld
operator|.
name|section
operator|==
name|bfd_abs_section_ptr
operator|&&
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_none
operator|||
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_adjust
operator|||
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_relro_adjust
operator|||
name|expld
operator|.
name|phase
operator|==
name|lang_final_phase_enum
operator|)
condition|)
block|{
name|bfd_vma
name|maxpage
init|=
name|lhs
operator|.
name|value
decl_stmt|;
name|bfd_vma
name|commonpage
init|=
name|expld
operator|.
name|result
operator|.
name|value
decl_stmt|;
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|align_n
argument_list|(
name|expld
operator|.
name|dot
argument_list|,
name|maxpage
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_relro_adjust
condition|)
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|expld
operator|.
name|dataseg
operator|.
name|base
expr_stmt|;
elseif|else
if|if
condition|(
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|!=
name|exp_dataseg_adjust
condition|)
block|{
name|expld
operator|.
name|result
operator|.
name|value
operator|+=
name|expld
operator|.
name|dot
operator|&
operator|(
name|maxpage
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|phase
operator|==
name|lang_allocating_phase_enum
condition|)
block|{
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|=
name|exp_dataseg_align_seen
expr_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|min_base
operator|=
name|align_n
argument_list|(
name|expld
operator|.
name|dot
argument_list|,
name|maxpage
argument_list|)
expr_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|base
operator|=
name|expld
operator|.
name|result
operator|.
name|value
expr_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
operator|=
name|commonpage
expr_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|maxpagesize
operator|=
name|maxpage
expr_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|commonpage
operator|<
name|maxpage
condition|)
name|expld
operator|.
name|result
operator|.
name|value
operator|+=
operator|(
operator|(
name|expld
operator|.
name|dot
operator|+
name|commonpage
operator|-
literal|1
operator|)
operator|&
operator|(
name|maxpage
operator|-
name|commonpage
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DATA_SEGMENT_RELRO_END
case|:
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_first_phase_enum
operator|&&
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_align_seen
operator|||
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_adjust
operator|||
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_relro_adjust
operator|||
name|expld
operator|.
name|phase
operator|==
name|lang_final_phase_enum
operator|)
condition|)
block|{
if|if
condition|(
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_align_seen
operator|||
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_relro_adjust
condition|)
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
operator|=
name|lhs
operator|.
name|value
operator|+
name|expld
operator|.
name|result
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_relro_adjust
operator|&&
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
operator|&
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
operator|+=
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
operator|-
literal|1
expr_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
operator|&=
operator|~
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
operator|-
literal|1
operator|)
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|value
operator|=
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
operator|-
name|expld
operator|.
name|result
operator|.
name|value
operator|)
expr_stmt|;
block|}
else|else
name|expld
operator|.
name|result
operator|.
name|value
operator|=
name|lhs
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_align_seen
condition|)
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|=
name|exp_dataseg_relro_seen
expr_stmt|;
block|}
else|else
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fold_trinary
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|)
block|{
name|exp_fold_tree_1
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
name|exp_fold_tree_1
argument_list|(
name|expld
operator|.
name|result
operator|.
name|value
condition|?
name|tree
operator|->
name|trinary
operator|.
name|lhs
else|:
name|tree
operator|->
name|trinary
operator|.
name|rhs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fold_name
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|expld
operator|.
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|expld
operator|.
name|result
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
name|SIZEOF_HEADERS
case|:
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|bfd_vma
name|hdr_size
init|=
literal|0
decl_stmt|;
comment|/* Don't find the real header size if only marking sections; 	     The bfd function may cache incorrect data.  */
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
name|hdr_size
operator|=
name|bfd_sizeof_headers
argument_list|(
name|output_bfd
argument_list|,
name|link_info
operator|.
name|relocatable
argument_list|)
expr_stmt|;
name|new_abs
argument_list|(
name|hdr_size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DEFINED
case|:
if|if
condition|(
name|expld
operator|.
name|phase
operator|==
name|lang_first_phase_enum
condition|)
name|lang_track_definedness
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|int
name|def_iteration
init|=
name|lang_symbol_definition_iteration
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
decl_stmt|;
name|h
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|value
operator|=
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_common
operator|)
operator|&&
operator|(
name|def_iteration
operator|==
name|lang_statement_iteration
operator|||
name|def_iteration
operator|==
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|NAME
case|:
if|if
condition|(
name|expld
operator|.
name|phase
operator|==
name|lang_first_phase_enum
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|tree
operator|->
name|name
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|tree
operator|->
name|name
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|new_rel_from_abs
argument_list|(
name|expld
operator|.
name|dot
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
name|new_abs
argument_list|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|output_section
decl_stmt|;
name|output_section
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%S: unresolvable symbol `%s'"
literal|" referenced in expression\n"
argument_list|)
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|new_rel
argument_list|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
argument_list|,
name|NULL
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|expld
operator|.
name|phase
operator|==
name|lang_final_phase_enum
operator|||
name|expld
operator|.
name|assigning_to_dot
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S: undefined symbol `%s' referenced in expression\n"
argument_list|)
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|next
operator|==
name|NULL
operator|&&
name|h
operator|!=
name|link_info
operator|.
name|hash
operator|->
name|undefs_tail
condition|)
name|bfd_link_add_undef
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ADDR
case|:
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|!=
name|NULL
operator|&&
name|os
operator|->
name|processed
condition|)
name|new_rel
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOADADDR
case|:
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|!=
name|NULL
operator|&&
name|os
operator|->
name|processed
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|load_base
operator|==
name|NULL
condition|)
name|new_rel
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
else|else
name|exp_fold_tree_1
argument_list|(
name|os
operator|->
name|load_base
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SIZEOF
case|:
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|int
name|opb
init|=
name|bfd_octets_per_byte
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|==
name|NULL
condition|)
name|new_abs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|os
operator|->
name|processed
condition|)
name|new_abs
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|size
operator|/
name|opb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LENGTH
case|:
block|{
name|lang_memory_region_type
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
name|lang_memory_region_lookup
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|!=
name|NULL
condition|)
name|new_abs
argument_list|(
name|mem
operator|->
name|length
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S: undefined MEMORY region `%s'"
literal|" referenced in expression\n"
argument_list|)
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ORIGIN
case|:
block|{
name|lang_memory_region_type
modifier|*
name|mem
decl_stmt|;
name|mem
operator|=
name|lang_memory_region_lookup
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|!=
name|NULL
condition|)
name|new_abs
argument_list|(
name|mem
operator|->
name|origin
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S: undefined MEMORY region `%s'"
literal|" referenced in expression\n"
argument_list|)
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exp_fold_tree_1
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|)
block|{
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
block|{
name|memset
argument_list|(
operator|&
name|expld
operator|.
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|expld
operator|.
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
condition|)
block|{
case|case
name|etree_value
case|:
name|new_rel
argument_list|(
name|tree
operator|->
name|value
operator|.
name|value
argument_list|,
name|tree
operator|->
name|value
operator|.
name|str
argument_list|,
name|expld
operator|.
name|section
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_rel
case|:
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|asection
modifier|*
name|output_section
init|=
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|output_section
decl_stmt|;
name|new_rel
argument_list|(
name|tree
operator|->
name|rel
operator|.
name|value
operator|+
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|output_offset
argument_list|,
name|NULL
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
operator|&
name|expld
operator|.
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|expld
operator|.
name|result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_assert
case|:
name|exp_fold_tree_1
argument_list|(
name|tree
operator|->
name|assert_s
operator|.
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|phase
operator|==
name|lang_final_phase_enum
operator|&&
operator|!
name|expld
operator|.
name|result
operator|.
name|value
condition|)
name|einfo
argument_list|(
literal|"%X%P: %s\n"
argument_list|,
name|tree
operator|->
name|assert_s
operator|.
name|message
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_unary
case|:
name|fold_unary
argument_list|(
name|tree
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_binary
case|:
name|fold_binary
argument_list|(
name|tree
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_trinary
case|:
name|fold_trinary
argument_list|(
name|tree
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_assign
case|:
case|case
name|etree_provide
case|:
case|case
name|etree_provided
case|:
if|if
condition|(
name|tree
operator|->
name|assign
operator|.
name|dst
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|tree
operator|->
name|assign
operator|.
name|dst
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Assignment to dot can only be done during allocation.  */
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
operator|!=
name|etree_assign
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S can not PROVIDE assignment to location counter\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|phase
operator|==
name|lang_mark_phase_enum
operator|||
name|expld
operator|.
name|phase
operator|==
name|lang_allocating_phase_enum
operator|||
operator|(
name|expld
operator|.
name|phase
operator|==
name|lang_final_phase_enum
operator|&&
name|expld
operator|.
name|section
operator|==
name|bfd_abs_section_ptr
operator|)
condition|)
block|{
comment|/* Notify the folder that this is an assignment to dot.  */
name|expld
operator|.
name|assigning_to_dot
operator|=
name|TRUE
expr_stmt|;
name|exp_fold_tree_1
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|)
expr_stmt|;
name|expld
operator|.
name|assigning_to_dot
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
block|{
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S invalid assignment to location counter\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expld
operator|.
name|dotp
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S assignment to location counter"
literal|" invalid outside of SECTION\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_vma
name|nextdot
decl_stmt|;
name|nextdot
operator|=
name|expld
operator|.
name|result
operator|.
name|value
operator|+
name|expld
operator|.
name|section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|nextdot
operator|<
name|expld
operator|.
name|dot
operator|&&
name|expld
operator|.
name|section
operator|!=
name|bfd_abs_section_ptr
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S cannot move location counter backwards"
literal|" (from %V to %V)\n"
argument_list|)
argument_list|,
name|expld
operator|.
name|dot
argument_list|,
name|nextdot
argument_list|)
expr_stmt|;
else|else
block|{
name|expld
operator|.
name|dot
operator|=
name|nextdot
expr_stmt|;
operator|*
name|expld
operator|.
name|dotp
operator|=
name|nextdot
expr_stmt|;
block|}
block|}
block|}
else|else
name|memset
argument_list|(
operator|&
name|expld
operator|.
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|expld
operator|.
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
operator|==
name|etree_provide
condition|)
block|{
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_new
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
operator|)
condition|)
block|{
comment|/* Do nothing.  The symbol was never referenced, or was 		     defined by some object.  */
break|break;
block|}
block|}
name|exp_fold_tree_1
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F:%s: hash creation failed\n"
argument_list|)
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: Should we worry if the symbol is already 		 defined?  */
name|lang_update_definedness
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|expld
operator|.
name|result
operator|.
name|value
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|expld
operator|.
name|result
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
operator|==
name|etree_provide
condition|)
name|tree
operator|->
name|type
operator|.
name|node_class
operator|=
name|etree_provided
expr_stmt|;
block|}
block|}
break|break;
case|case
name|etree_name
case|:
name|fold_name
argument_list|(
name|tree
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|expld
operator|.
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|expld
operator|.
name|result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|exp_fold_tree
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|asection
modifier|*
name|current_section
parameter_list|,
name|bfd_vma
modifier|*
name|dotp
parameter_list|)
block|{
name|expld
operator|.
name|dot
operator|=
operator|*
name|dotp
expr_stmt|;
name|expld
operator|.
name|dotp
operator|=
name|dotp
expr_stmt|;
name|expld
operator|.
name|section
operator|=
name|current_section
expr_stmt|;
name|exp_fold_tree_1
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|exp_fold_tree_no_dot
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|)
block|{
name|expld
operator|.
name|dot
operator|=
literal|0
expr_stmt|;
name|expld
operator|.
name|dotp
operator|=
name|NULL
expr_stmt|;
name|expld
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|exp_fold_tree_1
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_binop
parameter_list|(
name|int
name|code
parameter_list|,
name|etree_type
modifier|*
name|lhs
parameter_list|,
name|etree_type
modifier|*
name|rhs
parameter_list|)
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|value
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|binary
operator|.
name|lhs
operator|=
name|lhs
expr_stmt|;
name|value
operator|.
name|binary
operator|.
name|rhs
operator|=
name|rhs
expr_stmt|;
name|value
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_binary
expr_stmt|;
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
return|return
name|exp_intop
argument_list|(
name|expld
operator|.
name|result
operator|.
name|value
argument_list|)
return|;
name|new
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|binary
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|binary
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_trinop
parameter_list|(
name|int
name|code
parameter_list|,
name|etree_type
modifier|*
name|cond
parameter_list|,
name|etree_type
modifier|*
name|lhs
parameter_list|,
name|etree_type
modifier|*
name|rhs
parameter_list|)
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|value
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|trinary
operator|.
name|lhs
operator|=
name|lhs
expr_stmt|;
name|value
operator|.
name|trinary
operator|.
name|cond
operator|=
name|cond
expr_stmt|;
name|value
operator|.
name|trinary
operator|.
name|rhs
operator|=
name|rhs
expr_stmt|;
name|value
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_trinary
expr_stmt|;
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
return|return
name|exp_intop
argument_list|(
name|expld
operator|.
name|result
operator|.
name|value
argument_list|)
return|;
name|new
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|trinary
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|trinary
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_unop
parameter_list|(
name|int
name|code
parameter_list|,
name|etree_type
modifier|*
name|child
parameter_list|)
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|value
operator|.
name|unary
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|unary
operator|.
name|child
operator|=
name|child
expr_stmt|;
name|value
operator|.
name|unary
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_unary
expr_stmt|;
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
return|return
name|exp_intop
argument_list|(
name|expld
operator|.
name|result
operator|.
name|value
argument_list|)
return|;
name|new
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|unary
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|unary
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_nameop
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|value
operator|.
name|name
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|name
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|value
operator|.
name|name
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_name
expr_stmt|;
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
return|return
name|exp_intop
argument_list|(
name|expld
operator|.
name|result
operator|.
name|value
argument_list|)
return|;
name|new
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_assop
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|etree_type
modifier|*
name|src
parameter_list|)
block|{
name|etree_type
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|assign
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|new
operator|->
name|type
operator|.
name|node_class
operator|=
name|etree_assign
expr_stmt|;
name|new
operator|->
name|assign
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|new
operator|->
name|assign
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Handle PROVIDE.  */
end_comment

begin_function
name|etree_type
modifier|*
name|exp_provide
parameter_list|(
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|etree_type
modifier|*
name|src
parameter_list|,
name|bfd_boolean
name|hidden
parameter_list|)
block|{
name|etree_type
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|n
operator|->
name|assign
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|type
operator|.
name|node_code
operator|=
literal|'='
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_provide
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|hidden
operator|=
name|hidden
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Handle ASSERT.  */
end_comment

begin_function
name|etree_type
modifier|*
name|exp_assert
parameter_list|(
name|etree_type
modifier|*
name|exp
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|etree_type
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|n
operator|->
name|assert_s
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|assert_s
operator|.
name|type
operator|.
name|node_code
operator|=
literal|'!'
expr_stmt|;
name|n
operator|->
name|assert_s
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_assert
expr_stmt|;
name|n
operator|->
name|assert_s
operator|.
name|child
operator|=
name|exp
expr_stmt|;
name|n
operator|->
name|assert_s
operator|.
name|message
operator|=
name|message
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|void
name|exp_print_tree
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|)
block|{
if|if
condition|(
name|config
operator|.
name|map_file
operator|==
name|NULL
condition|)
name|config
operator|.
name|map_file
operator|=
name|stderr
expr_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
block|{
name|minfo
argument_list|(
literal|"NULL TREE\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
condition|)
block|{
case|case
name|etree_value
case|:
name|minfo
argument_list|(
literal|"0x%v"
argument_list|,
name|tree
operator|->
name|value
operator|.
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
name|etree_rel
case|:
if|if
condition|(
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%B:"
argument_list|,
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"%s+0x%v"
argument_list|,
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|name
argument_list|,
name|tree
operator|->
name|rel
operator|.
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
name|etree_assign
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%s"
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|)
expr_stmt|;
name|exp_print_token
argument_list|(
name|tree
operator|->
name|type
operator|.
name|node_code
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_provide
case|:
case|case
name|etree_provided
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"PROVIDE (%s, "
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_binary
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|exp_print_token
argument_list|(
name|tree
operator|->
name|type
operator|.
name|node_code
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|rhs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_trinary
case|:
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|cond
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_unary
case|:
name|exp_print_token
argument_list|(
name|tree
operator|->
name|unary
operator|.
name|type
operator|.
name|node_code
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|unary
operator|.
name|child
condition|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|unary
operator|.
name|child
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|etree_assert
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"ASSERT ("
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|assert_s
operator|.
name|child
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|", %s)"
argument_list|,
name|tree
operator|->
name|assert_s
operator|.
name|message
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_name
case|:
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
name|NAME
condition|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%s"
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exp_print_token
argument_list|(
name|tree
operator|->
name|type
operator|.
name|node_code
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|name
operator|.
name|name
condition|)
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|" (%s)"
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|bfd_vma
name|exp_get_vma
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|bfd_vma
name|def
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|tree
operator|!=
name|NULL
condition|)
block|{
name|exp_fold_tree_no_dot
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
return|return
name|expld
operator|.
name|result
operator|.
name|value
return|;
elseif|else
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S nonconstant expression for %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|def
return|;
block|}
end_function

begin_function
name|int
name|exp_get_value_int
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|int
name|def
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|exp_get_vma
argument_list|(
name|tree
argument_list|,
name|def
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|fill_type
modifier|*
name|exp_get_fill
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|fill_type
modifier|*
name|def
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fill_type
modifier|*
name|fill
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return
name|def
return|;
name|exp_fold_tree_no_dot
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
block|{
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S nonconstant expression for %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|def
return|;
block|}
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|str
operator|!=
name|NULL
operator|&&
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|expld
operator|.
name|result
operator|.
name|str
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|fill
operator|=
name|xmalloc
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|2
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|fill
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill
operator|->
name|size
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|dst
operator|=
name|fill
operator|->
name|data
expr_stmt|;
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|expld
operator|.
name|result
operator|.
name|str
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|unsigned
name|int
name|digit
decl_stmt|;
name|digit
operator|=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>
literal|9
condition|)
name|digit
operator|=
operator|(
name|digit
operator|-
literal|'A'
operator|+
literal|'0'
operator|+
literal|10
operator|)
operator|&
literal|0xf
expr_stmt|;
name|val
operator|<<=
literal|4
expr_stmt|;
name|val
operator|+=
name|digit
expr_stmt|;
operator|--
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|len
operator|!=
literal|0
condition|)
do|;
block|}
else|else
block|{
name|fill
operator|=
name|xmalloc
argument_list|(
literal|4
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|fill
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|expld
operator|.
name|result
operator|.
name|value
expr_stmt|;
name|fill
operator|->
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fill
operator|->
name|data
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fill
operator|->
name|data
index|[
literal|2
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fill
operator|->
name|data
index|[
literal|3
index|]
operator|=
operator|(
name|val
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fill
operator|->
name|size
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|fill
return|;
block|}
end_function

begin_function
name|bfd_vma
name|exp_get_abs_int
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|int
name|def
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|tree
operator|!=
name|NULL
condition|)
block|{
name|exp_fold_tree_no_dot
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
block|{
name|expld
operator|.
name|result
operator|.
name|value
operator|+=
name|expld
operator|.
name|result
operator|.
name|section
operator|->
name|vma
expr_stmt|;
return|return
name|expld
operator|.
name|result
operator|.
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S non constant expression for %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|def
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|align_n
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|bfd_vma
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|<=
literal|1
condition|)
return|return
name|value
return|;
name|value
operator|=
operator|(
name|value
operator|+
name|align
operator|-
literal|1
operator|)
operator|/
name|align
expr_stmt|;
return|return
name|value
operator|*
name|align
return|;
block|}
end_function

end_unit

