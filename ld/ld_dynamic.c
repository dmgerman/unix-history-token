begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012,2013 Kai Wang  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ld_arch.h"
end_include

begin_include
include|#
directive|include
file|"ld_dynamic.h"
end_include

begin_include
include|#
directive|include
file|"ld_file.h"
end_include

begin_include
include|#
directive|include
file|"ld_hash.h"
end_include

begin_include
include|#
directive|include
file|"ld_input.h"
end_include

begin_include
include|#
directive|include
file|"ld_layout.h"
end_include

begin_include
include|#
directive|include
file|"ld_output.h"
end_include

begin_include
include|#
directive|include
file|"ld_path.h"
end_include

begin_include
include|#
directive|include
file|"ld_symbols.h"
end_include

begin_include
include|#
directive|include
file|"ld_symver.h"
end_include

begin_include
include|#
directive|include
file|"ld_strtab.h"
end_include

begin_expr_stmt
name|ELFTC_VCSID
argument_list|(
literal|"$Id: ld_dynamic.c 3384 2016-01-31 13:12:41Z jkoshy $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|_check_dso_needed
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_dynamic
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_interp
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_create_dynsym_and_dynstr_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_finalize_dynamic
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ld_dynamic_create
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check how many DSOs is needed for output object. */
name|_check_dso_needed
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|)
expr_stmt|;
comment|/* Link statically if we don't use DSOs? */
if|if
condition|(
name|lo
operator|->
name|lo_dso_needed
operator|==
literal|0
condition|)
return|return;
name|ld
operator|->
name|ld_dynamic_link
operator|=
literal|1
expr_stmt|;
comment|/* Create .interp section. */
if|if
condition|(
operator|!
name|ld
operator|->
name|ld_dso
condition|)
name|_create_interp
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|)
expr_stmt|;
comment|/* Create .dynamic section. */
name|_create_dynamic
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|)
expr_stmt|;
comment|/* Create .dynsym and .dynstr sections. */
name|_create_dynsym_and_dynstr_section
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|)
expr_stmt|;
comment|/* Create .hash section. */
name|ld_hash_create_svr4_hash_section
argument_list|(
name|ld
argument_list|)
expr_stmt|;
comment|/* 	 * Create .gnu.version_d section if the linker creats a shared 	 * library and version script is provided. 	 */
name|lo
operator|->
name|lo_version_index
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_dso
condition|)
name|ld_symver_create_verdef_section
argument_list|(
name|ld
argument_list|)
expr_stmt|;
comment|/* Create .gnu.version_r section. */
name|ld_symver_create_verneed_section
argument_list|(
name|ld
argument_list|)
expr_stmt|;
comment|/* Create .gnu.version section. */
name|ld_symver_create_versym_section
argument_list|(
name|ld
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_dynamic_finalize
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|)
block|{
name|struct
name|ld_output
modifier|*
name|lo
decl_stmt|;
name|lo
operator|=
name|ld
operator|->
name|ld_output
expr_stmt|;
name|assert
argument_list|(
name|lo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_dso_needed
operator|==
literal|0
condition|)
return|return;
comment|/* Finalize .dynamic section */
name|_finalize_dynamic
argument_list|(
name|ld
argument_list|,
name|lo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ld_dynamic_load_dso_dynamic
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_input
modifier|*
name|li
parameter_list|,
name|Elf
modifier|*
name|e
parameter_list|,
name|Elf_Scn
modifier|*
name|scn
parameter_list|,
name|size_t
name|strndx
parameter_list|)
block|{
name|GElf_Shdr
name|shdr
decl_stmt|;
name|GElf_Dyn
name|dyn
decl_stmt|;
name|Elf_Data
modifier|*
name|d
decl_stmt|;
name|int
name|elferr
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|strndx
operator|==
name|SHN_UNDEF
condition|)
return|return;
if|if
condition|(
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|shdr
argument_list|)
operator|!=
operator|&
name|shdr
condition|)
block|{
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"%s: gelf_getshdr failed: %s"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|elf_getdata
argument_list|(
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|elferr
operator|=
name|elf_errno
argument_list|()
expr_stmt|;
if|if
condition|(
name|elferr
operator|!=
literal|0
condition|)
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"%s: elf_getdata failed: %s"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|elf_errmsg
argument_list|(
name|elferr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|d
operator|->
name|d_size
operator|/
name|shdr
operator|.
name|sh_entsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getdyn
argument_list|(
name|d
argument_list|,
name|i
argument_list|,
operator|&
name|dyn
argument_list|)
operator|!=
operator|&
name|dyn
condition|)
block|{
name|ld_warn
argument_list|(
name|ld
argument_list|,
literal|"%s: gelf_getdyn failed: %s"
argument_list|,
name|li
operator|->
name|li_name
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_SONAME
case|:
name|name
operator|=
name|elf_strptr
argument_list|(
name|e
argument_list|,
name|strndx
argument_list|,
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|li
operator|->
name|li_soname
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NEEDED
case|:
name|name
operator|=
name|elf_strptr
argument_list|(
name|e
argument_list|,
name|strndx
argument_list|,
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|ld_path_search_dso_needed
argument_list|(
name|ld
argument_list|,
name|li
operator|->
name|li_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ld_dynamic_reserve_dynbss_entry
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_symbol
modifier|*
name|lsb
parameter_list|)
block|{
name|struct
name|ld_input
modifier|*
name|li
decl_stmt|;
name|struct
name|ld_input_section
modifier|*
name|dynbss
decl_stmt|,
modifier|*
name|is
decl_stmt|;
name|uint64_t
name|a
decl_stmt|;
comment|/* Create .dynbss section if it doesn't yet exist. */
name|dynbss
operator|=
name|ld_input_find_internal_section
argument_list|(
name|ld
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbss
operator|==
name|NULL
condition|)
block|{
name|dynbss
operator|=
name|ld_input_add_internal_section
argument_list|(
name|ld
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|dynbss
operator|->
name|is_type
operator|=
name|SHT_NOBITS
expr_stmt|;
block|}
name|li
operator|=
name|lsb
operator|->
name|lsb_input
expr_stmt|;
name|assert
argument_list|(
name|li
operator|!=
name|NULL
operator|&&
name|li
operator|->
name|li_type
operator|==
name|LIT_DSO
argument_list|)
expr_stmt|;
comment|/* 	 * TODO: we don't have to create copy relocation 	 * for every import object. Some import objects 	 * are read-only, in that case we can create other 	 * dynamic relocations for them. 	 */
comment|/* 	 * If the section to which the symbols belong has a larger 	 * alignment requirement, we increase .dynbss section alignment 	 * accordingly. XXX What if it is a DSO common symbol? 	 */
name|is
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lsb
operator|->
name|lsb_shndx
operator|!=
name|SHN_COMMON
condition|)
block|{
name|assert
argument_list|(
name|lsb
operator|->
name|lsb_shndx
operator|<
name|li
operator|->
name|li_shnum
operator|-
literal|1
argument_list|)
expr_stmt|;
name|is
operator|=
operator|&
name|li
operator|->
name|li_is
index|[
name|lsb
operator|->
name|lsb_shndx
index|]
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|is_align
operator|>
name|dynbss
operator|->
name|is_align
condition|)
name|dynbss
operator|->
name|is_align
operator|=
name|is
operator|->
name|is_align
expr_stmt|;
block|}
comment|/* 	 * Calculate the alignment for this object. 	 */
if|if
condition|(
name|is
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|a
operator|=
name|is
operator|->
name|is_align
init|;
name|a
operator|>
literal|1
condition|;
name|a
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|lsb
operator|->
name|lsb_value
operator|-
name|is
operator|->
name|is_off
operator|)
operator|%
name|a
operator|==
literal|0
condition|)
break|break;
block|}
block|}
else|else
name|a
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|a
operator|>
literal|1
condition|)
name|dynbss
operator|->
name|is_size
operator|=
name|roundup
argument_list|(
name|dynbss
operator|->
name|is_size
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|lsb
operator|->
name|lsb_value
operator|=
name|dynbss
operator|->
name|is_size
expr_stmt|;
name|lsb
operator|->
name|lsb_copy_reloc
operator|=
literal|1
expr_stmt|;
name|lsb
operator|->
name|lsb_input
operator|=
name|dynbss
operator|->
name|is_input
expr_stmt|;
name|lsb
operator|->
name|lsb_shndx
operator|=
name|dynbss
operator|->
name|is_index
expr_stmt|;
name|lsb
operator|->
name|lsb_is
operator|=
name|dynbss
expr_stmt|;
name|dynbss
operator|->
name|is_size
operator|+=
name|lsb
operator|->
name|lsb_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_interp
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
block|{
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|struct
name|ld_output_data_buffer
modifier|*
name|odb
decl_stmt|;
specifier|const
name|char
modifier|*
name|interp
decl_stmt|;
name|char
name|interp_name
index|[]
init|=
literal|".interp"
decl_stmt|;
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|interp_name
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|==
name|NULL
condition|)
name|os
operator|=
name|ld_layout_insert_output_section
argument_list|(
name|ld
argument_list|,
name|interp_name
argument_list|,
name|SHF_ALLOC
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|os
operator|->
name|os_align
operator|=
literal|1
expr_stmt|;
name|os
operator|->
name|os_entsize
operator|=
literal|0
expr_stmt|;
name|os
operator|->
name|os_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|lo
operator|->
name|lo_interp
operator|=
name|os
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_interp
operator|!=
name|NULL
condition|)
name|interp
operator|=
name|ld
operator|->
name|ld_interp
expr_stmt|;
else|else
name|interp
operator|=
name|ld
operator|->
name|ld_arch
operator|->
name|interp
expr_stmt|;
name|assert
argument_list|(
name|interp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|odb
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|odb
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|odb
operator|->
name|odb_size
operator|=
name|strlen
argument_list|(
name|interp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|odb
operator|->
name|odb_align
operator|=
literal|1
expr_stmt|;
name|odb
operator|->
name|odb_type
operator|=
name|ELF_T_BYTE
expr_stmt|;
if|if
condition|(
operator|(
name|odb
operator|->
name|odb_buf
operator|=
name|calloc
argument_list|(
name|odb
operator|->
name|odb_size
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|odb
operator|->
name|odb_buf
argument_list|,
name|interp
argument_list|,
name|strlen
argument_list|(
name|interp
argument_list|)
argument_list|)
expr_stmt|;
name|odb
operator|->
name|odb_buf
index|[
name|strlen
argument_list|(
name|interp
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_DATA_BUFFER
argument_list|,
name|odb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_dynamic
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
block|{
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|,
modifier|*
name|_os
decl_stmt|;
name|struct
name|ld_output_data_buffer
modifier|*
name|odb
decl_stmt|;
name|char
name|dynamic_name
index|[]
init|=
literal|".dynamic"
decl_stmt|;
name|char
name|init_name
index|[]
init|=
literal|".init"
decl_stmt|;
name|char
name|fini_name
index|[]
init|=
literal|".fini"
decl_stmt|;
name|char
modifier|*
name|rpath
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|dynamic_name
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|==
name|NULL
condition|)
name|os
operator|=
name|ld_layout_insert_output_section
argument_list|(
name|ld
argument_list|,
name|dynamic_name
argument_list|,
name|SHF_ALLOC
operator||
name|SHF_WRITE
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_type
operator|=
name|SHT_DYNAMIC
expr_stmt|;
name|os
operator|->
name|os_flags
operator|=
name|SHF_ALLOC
operator||
name|SHF_WRITE
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|)
block|{
name|os
operator|->
name|os_entsize
operator|=
literal|8
expr_stmt|;
name|os
operator|->
name|os_align
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|os
operator|->
name|os_entsize
operator|=
literal|16
expr_stmt|;
name|os
operator|->
name|os_align
operator|=
literal|8
expr_stmt|;
block|}
name|lo
operator|->
name|lo_dynamic
operator|=
name|os
expr_stmt|;
comment|/* .dynamic section should link to .dynstr section. */
if|if
condition|(
operator|(
name|os
operator|->
name|os_link
operator|=
name|strdup
argument_list|(
literal|".dynstr"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
comment|/* DT_NEEDED */
name|entries
operator|=
name|lo
operator|->
name|lo_dso_needed
expr_stmt|;
comment|/* DT_SONAME. */
if|if
condition|(
name|ld
operator|->
name|ld_soname
operator|!=
name|NULL
condition|)
block|{
name|lo
operator|->
name|lo_soname_nameindex
operator|=
name|ld_strtab_insert_no_suffix
argument_list|(
name|ld
argument_list|,
name|ld
operator|->
name|ld_dynstr
argument_list|,
name|ld
operator|->
name|ld_soname
argument_list|)
expr_stmt|;
name|entries
operator|++
expr_stmt|;
block|}
comment|/* DT_INIT */
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|init_name
argument_list|,
name|_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|_os
operator|!=
name|NULL
operator|&&
operator|!
name|_os
operator|->
name|os_empty
condition|)
block|{
name|lo
operator|->
name|lo_init
operator|=
name|_os
expr_stmt|;
name|entries
operator|++
expr_stmt|;
block|}
comment|/* DT_FINI */
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|fini_name
argument_list|,
name|_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|_os
operator|!=
name|NULL
operator|&&
operator|!
name|_os
operator|->
name|os_empty
condition|)
block|{
name|lo
operator|->
name|lo_fini
operator|=
name|_os
expr_stmt|;
name|entries
operator|++
expr_stmt|;
block|}
comment|/* DT_HASH, DT_STRTAB, DT_SYMTAB, DT_STRSZ and DT_SYMENT */
if|if
condition|(
name|ld
operator|->
name|ld_dynsym
condition|)
name|entries
operator|+=
literal|5
expr_stmt|;
comment|/* DT_RPATH. */
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ld
operator|->
name|ld_state
operator|.
name|ls_rplist
argument_list|)
condition|)
block|{
name|rpath
operator|=
name|ld_path_join_rpath
argument_list|(
name|ld
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_rpath_nameindex
operator|=
name|ld_strtab_insert_no_suffix
argument_list|(
name|ld
argument_list|,
name|ld
operator|->
name|ld_dynstr
argument_list|,
name|rpath
argument_list|)
expr_stmt|;
name|entries
operator|++
expr_stmt|;
block|}
comment|/* 	 * DT_DEBUG. dynamic linker changes this at runtime, gdb uses 	 * it to find all the loaded DSOs. (thus .dynamic has to be 	 * writable) 	 */
if|if
condition|(
operator|!
name|ld
operator|->
name|ld_dso
condition|)
name|entries
operator|++
expr_stmt|;
comment|/* DT_PLTGOT, DT_PLTRELSZ, DT_PLTREL and DT_JMPREL. */
name|entries
operator|+=
literal|4
expr_stmt|;
comment|/* DT_REL/DT_RELA, DT_RELSZ/DT_RELASZ and DT_RELENT/DT_RELAENT */
name|entries
operator|+=
literal|3
expr_stmt|;
comment|/* 	 * DT_VERNEED, DT_VERNEEDNUM, DT_VERDEF, DT_VERDEFNUM and DT_VERSYM. 	 */
name|entries
operator|+=
literal|5
expr_stmt|;
comment|/* DT_RELCOUNT/DT_RELACOUNT. */
if|if
condition|(
name|ld
operator|->
name|ld_state
operator|.
name|ls_relative_reloc
operator|>
literal|0
condition|)
name|entries
operator|++
expr_stmt|;
comment|/* DT_NULL. TODO: Reserve multiple DT_NULL entries for DT_RPATH? */
name|entries
operator|++
expr_stmt|;
comment|/* 	 * Reserve space for .dynamic section, based on number of entries. 	 */
if|if
condition|(
operator|(
name|odb
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|odb
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|odb
operator|->
name|odb_size
operator|=
name|entries
operator|*
name|os
operator|->
name|os_entsize
expr_stmt|;
if|if
condition|(
operator|(
name|odb
operator|->
name|odb_buf
operator|=
name|malloc
argument_list|(
name|odb
operator|->
name|odb_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|odb
operator|->
name|odb_align
operator|=
name|os
operator|->
name|os_align
expr_stmt|;
name|odb
operator|->
name|odb_type
operator|=
name|ELF_T_DYN
expr_stmt|;
operator|(
name|void
operator|)
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_DATA_BUFFER
argument_list|,
name|odb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_dynamic_odb
operator|=
name|odb
expr_stmt|;
comment|/* Create _DYNAMIC symobl. */
name|ld_symbols_add_internal
argument_list|(
name|ld
argument_list|,
literal|"_DYNAMIC"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SHN_ABS
argument_list|,
name|STB_LOCAL
argument_list|,
name|STT_OBJECT
argument_list|,
name|STV_HIDDEN
argument_list|,
name|NULL
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DT_ENTRY_VAL
parameter_list|(
name|tag
parameter_list|,
name|val
parameter_list|)
define|\
value|do {							\ 		if (lo->lo_ec == ELFCLASS32) {			\ 			assert(dt32< end32); 			\ 			dt32->d_tag = (int32_t) (tag);		\ 			dt32->d_un.d_val = (uint32_t) (val);	\ 			dt32++;					\ 		} else {					\ 			assert(dt64< end64); 			\ 			dt64->d_tag = (tag);			\ 			dt64->d_un.d_val = (val);		\ 			dt64++;					\ 		}						\ 	} while(0)
end_define

begin_define
define|#
directive|define
name|DT_ENTRY_PTR
parameter_list|(
name|tag
parameter_list|,
name|ptr
parameter_list|)
define|\
value|do {							\ 		if (lo->lo_ec == ELFCLASS32) {			\ 			assert(dt32< end32); 			\ 			dt32->d_tag = (int32_t) (tag);		\ 			dt32->d_un.d_ptr = (uint32_t) (ptr);	\ 			dt32++;					\ 		} else {					\ 			assert(dt64< end64); 			\ 			dt64->d_tag = (tag);			\ 			dt64->d_un.d_ptr = (ptr);		\ 			dt64++;					\ 		}						\ 	} while(0)
end_define

begin_define
define|#
directive|define
name|DT_ENTRY_NULL
define|\
value|do {							\ 		if (lo->lo_ec == ELFCLASS32) {			\ 			assert(dt32< end32); 			\ 			while (dt32< end32)			\ 				DT_ENTRY_VAL(DT_NULL, 0);	\ 			assert(dt32 == end32);			\ 		} else {					\ 			assert(dt64< end64); 			\ 			while (dt64< end64)			\ 				DT_ENTRY_VAL(DT_NULL, 0);	\ 			assert(dt64 == end64);			\ 		}						\ 	} while(0)
end_define

begin_function
specifier|static
name|void
name|_finalize_dynamic
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
block|{
name|struct
name|ld_output_data_buffer
modifier|*
name|odb
decl_stmt|;
name|Elf32_Dyn
modifier|*
name|dt32
decl_stmt|,
modifier|*
name|end32
decl_stmt|;
name|Elf64_Dyn
modifier|*
name|dt64
decl_stmt|,
modifier|*
name|end64
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
name|odb
operator|=
name|lo
operator|->
name|lo_dynamic_odb
expr_stmt|;
name|assert
argument_list|(
name|odb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dt32
operator|=
operator|(
name|Elf32_Dyn
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|odb
operator|->
name|odb_buf
expr_stmt|;
name|dt64
operator|=
operator|(
name|Elf64_Dyn
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|odb
operator|->
name|odb_buf
expr_stmt|;
name|end32
operator|=
operator|(
name|Elf32_Dyn
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|odb
operator|->
name|odb_buf
operator|+
name|odb
operator|->
name|odb_size
argument_list|)
expr_stmt|;
name|end64
operator|=
operator|(
name|Elf64_Dyn
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|odb
operator|->
name|odb_buf
operator|+
name|odb
operator|->
name|odb_size
argument_list|)
expr_stmt|;
comment|/* DT_NEEDED. */
for|for
control|(
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|utarray_front
argument_list|(
name|lo
operator|->
name|lo_dso_nameindex
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|utarray_next
argument_list|(
name|lo
operator|->
name|lo_dso_nameindex
argument_list|,
name|p
argument_list|)
control|)
name|DT_ENTRY_VAL
argument_list|(
name|DT_NEEDED
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* DT_SONAME. */
if|if
condition|(
name|ld
operator|->
name|ld_soname
operator|!=
name|NULL
condition|)
name|DT_ENTRY_VAL
argument_list|(
name|DT_SONAME
argument_list|,
name|lo
operator|->
name|lo_soname_nameindex
argument_list|)
expr_stmt|;
comment|/* DT_INIT and DT_FINI */
if|if
condition|(
name|lo
operator|->
name|lo_init
operator|!=
name|NULL
condition|)
name|DT_ENTRY_PTR
argument_list|(
name|DT_INIT
argument_list|,
name|lo
operator|->
name|lo_init
operator|->
name|os_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_fini
operator|!=
name|NULL
condition|)
name|DT_ENTRY_PTR
argument_list|(
name|DT_FINI
argument_list|,
name|lo
operator|->
name|lo_fini
operator|->
name|os_addr
argument_list|)
expr_stmt|;
comment|/* DT_HASH */
if|if
condition|(
name|lo
operator|->
name|lo_hash
operator|!=
name|NULL
condition|)
name|DT_ENTRY_PTR
argument_list|(
name|DT_HASH
argument_list|,
name|lo
operator|->
name|lo_hash
operator|->
name|os_addr
argument_list|)
expr_stmt|;
comment|/* DT_HASH, DT_STRTAB, DT_SYMTAB, DT_STRSZ and DT_SYMENT */
if|if
condition|(
name|lo
operator|->
name|lo_dynsym
operator|!=
name|NULL
operator|&&
name|lo
operator|->
name|lo_dynstr
operator|!=
name|NULL
condition|)
block|{
name|DT_ENTRY_PTR
argument_list|(
name|DT_STRTAB
argument_list|,
name|lo
operator|->
name|lo_dynstr
operator|->
name|os_addr
argument_list|)
expr_stmt|;
name|DT_ENTRY_PTR
argument_list|(
name|DT_SYMTAB
argument_list|,
name|lo
operator|->
name|lo_dynsym
operator|->
name|os_addr
argument_list|)
expr_stmt|;
name|DT_ENTRY_VAL
argument_list|(
name|DT_STRSZ
argument_list|,
name|ld_strtab_getsize
argument_list|(
name|ld
operator|->
name|ld_dynstr
argument_list|)
argument_list|)
expr_stmt|;
name|DT_ENTRY_VAL
argument_list|(
name|DT_SYMENT
argument_list|,
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|?
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* DT_RPATH */
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|ld
operator|->
name|ld_state
operator|.
name|ls_rplist
argument_list|)
condition|)
name|DT_ENTRY_VAL
argument_list|(
name|DT_RPATH
argument_list|,
name|lo
operator|->
name|lo_rpath_nameindex
argument_list|)
expr_stmt|;
comment|/* DT_DEBUG */
if|if
condition|(
operator|!
name|ld
operator|->
name|ld_dso
condition|)
name|DT_ENTRY_VAL
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DT_PLTGOT, DT_PLTRELSZ, DT_PLTREL and DT_JMPREL. */
if|if
condition|(
name|lo
operator|->
name|lo_gotplt
operator|!=
name|NULL
condition|)
name|DT_ENTRY_PTR
argument_list|(
name|DT_PLTGOT
argument_list|,
name|lo
operator|->
name|lo_gotplt
operator|->
name|os_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_rel_plt
operator|!=
name|NULL
condition|)
block|{
name|DT_ENTRY_VAL
argument_list|(
name|DT_PLTRELSZ
argument_list|,
name|lo
operator|->
name|lo_rel_plt
operator|->
name|os_size
argument_list|)
expr_stmt|;
name|DT_ENTRY_VAL
argument_list|(
name|DT_PLTREL
argument_list|,
name|ld
operator|->
name|ld_arch
operator|->
name|reloc_is_rela
condition|?
name|DT_RELA
else|:
name|DT_REL
argument_list|)
expr_stmt|;
name|DT_ENTRY_PTR
argument_list|(
name|DT_JMPREL
argument_list|,
name|lo
operator|->
name|lo_rel_plt
operator|->
name|os_addr
argument_list|)
expr_stmt|;
block|}
comment|/* DT_REL/DT_RELA, DT_RELSZ/DT_RELASZ and DT_RELENT/DT_RELAENT */
if|if
condition|(
name|lo
operator|->
name|lo_rel_dyn
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ld
operator|->
name|ld_arch
operator|->
name|reloc_is_rela
condition|)
block|{
name|DT_ENTRY_PTR
argument_list|(
name|DT_REL
argument_list|,
name|lo
operator|->
name|lo_rel_dyn
operator|->
name|os_addr
argument_list|)
expr_stmt|;
name|DT_ENTRY_VAL
argument_list|(
name|DT_RELSZ
argument_list|,
name|lo
operator|->
name|lo_rel_dyn
operator|->
name|os_size
argument_list|)
expr_stmt|;
name|DT_ENTRY_VAL
argument_list|(
name|DT_RELENT
argument_list|,
name|ld
operator|->
name|ld_arch
operator|->
name|reloc_entsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DT_ENTRY_PTR
argument_list|(
name|DT_RELA
argument_list|,
name|lo
operator|->
name|lo_rel_dyn
operator|->
name|os_addr
argument_list|)
expr_stmt|;
name|DT_ENTRY_VAL
argument_list|(
name|DT_RELASZ
argument_list|,
name|lo
operator|->
name|lo_rel_dyn
operator|->
name|os_size
argument_list|)
expr_stmt|;
name|DT_ENTRY_VAL
argument_list|(
name|DT_RELAENT
argument_list|,
name|ld
operator|->
name|ld_arch
operator|->
name|reloc_entsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * DT_VERNEED, DT_VERNEEDNUM, DT_VERDEF, DT_VERDEFNUM and 	 * DT_VERSYM. 	 */
if|if
condition|(
name|lo
operator|->
name|lo_verdef
operator|!=
name|NULL
condition|)
block|{
name|DT_ENTRY_PTR
argument_list|(
name|DT_VERDEF
argument_list|,
name|lo
operator|->
name|lo_verdef
operator|->
name|os_addr
argument_list|)
expr_stmt|;
name|DT_ENTRY_VAL
argument_list|(
name|DT_VERDEFNUM
argument_list|,
name|lo
operator|->
name|lo_verdef_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|->
name|lo_verneed
operator|!=
name|NULL
condition|)
block|{
name|DT_ENTRY_PTR
argument_list|(
name|DT_VERNEED
argument_list|,
name|lo
operator|->
name|lo_verneed
operator|->
name|os_addr
argument_list|)
expr_stmt|;
name|DT_ENTRY_VAL
argument_list|(
name|DT_VERNEEDNUM
argument_list|,
name|lo
operator|->
name|lo_verneed_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|->
name|lo_versym
operator|!=
name|NULL
condition|)
name|DT_ENTRY_PTR
argument_list|(
name|DT_VERSYM
argument_list|,
name|lo
operator|->
name|lo_versym
operator|->
name|os_addr
argument_list|)
expr_stmt|;
comment|/* DT_RELCOUNT/DT_RELACOUNT. */
if|if
condition|(
name|ld
operator|->
name|ld_state
operator|.
name|ls_relative_reloc
operator|>
literal|0
condition|)
name|DT_ENTRY_VAL
argument_list|(
name|ld
operator|->
name|ld_arch
operator|->
name|reloc_is_rela
condition|?
name|DT_RELACOUNT
else|:
name|DT_RELCOUNT
argument_list|,
name|ld
operator|->
name|ld_state
operator|.
name|ls_relative_reloc
argument_list|)
expr_stmt|;
comment|/* Fill in the space left with DT_NULL entries */
name|DT_ENTRY_NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_create_dynsym_and_dynstr_section
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
block|{
name|struct
name|ld_output_section
modifier|*
name|os
decl_stmt|;
name|char
name|dynsym_name
index|[]
init|=
literal|".dynsym"
decl_stmt|;
name|char
name|dynstr_name
index|[]
init|=
literal|".dynstr"
decl_stmt|;
comment|/* 	 * Create .dynsym section. 	 */
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|dynsym_name
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|==
name|NULL
condition|)
name|os
operator|=
name|ld_layout_insert_output_section
argument_list|(
name|ld
argument_list|,
name|dynsym_name
argument_list|,
name|SHF_ALLOC
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_type
operator|=
name|SHT_DYNSYM
expr_stmt|;
name|os
operator|->
name|os_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_ec
operator|==
name|ELFCLASS32
condition|)
block|{
name|os
operator|->
name|os_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Sym
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_align
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|os
operator|->
name|os_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_Sym
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_align
operator|=
literal|8
expr_stmt|;
block|}
name|lo
operator|->
name|lo_dynsym
operator|=
name|os
expr_stmt|;
operator|(
name|void
operator|)
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_SYMTAB
argument_list|,
name|ld
operator|->
name|ld_dynsym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Create .dynstr section. 	 */
name|HASH_FIND_STR
argument_list|(
name|lo
operator|->
name|lo_ostbl
argument_list|,
name|dynstr_name
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|==
name|NULL
condition|)
name|os
operator|=
name|ld_layout_insert_output_section
argument_list|(
name|ld
argument_list|,
name|dynstr_name
argument_list|,
name|SHF_ALLOC
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|os
operator|->
name|os_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|os
operator|->
name|os_entsize
operator|=
literal|0
expr_stmt|;
name|os
operator|->
name|os_align
operator|=
literal|1
expr_stmt|;
name|lo
operator|->
name|lo_dynstr
operator|=
name|os
expr_stmt|;
operator|(
name|void
operator|)
name|ld_output_create_section_element
argument_list|(
name|ld
argument_list|,
name|os
argument_list|,
name|OET_STRTAB
argument_list|,
name|ld
operator|->
name|ld_dynstr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lo
operator|->
name|lo_dynsym
operator|->
name|os_link
operator|=
name|strdup
argument_list|(
literal|".dynstr"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ld_fatal_std
argument_list|(
name|ld
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_check_dso_needed
parameter_list|(
name|struct
name|ld
modifier|*
name|ld
parameter_list|,
name|struct
name|ld_output
modifier|*
name|lo
parameter_list|)
block|{
name|struct
name|ld_input
modifier|*
name|li
decl_stmt|;
name|char
modifier|*
name|bn
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|lo
operator|->
name|lo_dso_needed
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|li
argument_list|,
argument|&ld->ld_lilist
argument_list|,
argument|li_next
argument_list|)
block|{
if|if
condition|(
name|li
operator|->
name|li_type
operator|!=
name|LIT_DSO
condition|)
continue|continue;
if|if
condition|(
name|li
operator|->
name|li_dso_refcnt
operator|>
literal|0
operator|||
operator|!
name|li
operator|->
name|li_file
operator|->
name|lf_as_needed
condition|)
block|{
name|lo
operator|->
name|lo_dso_needed
operator|++
expr_stmt|;
if|if
condition|(
name|ld
operator|->
name|ld_dynstr
operator|==
name|NULL
condition|)
name|ld
operator|->
name|ld_dynstr
operator|=
name|ld_strtab_alloc
argument_list|(
name|ld
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Insert DSO name to the .dynstr string table. */
if|if
condition|(
name|li
operator|->
name|li_soname
operator|!=
name|NULL
condition|)
name|bn
operator|=
name|li
operator|->
name|li_soname
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|bn
operator|=
name|strrchr
argument_list|(
name|li
operator|->
name|li_name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|bn
operator|=
name|li
operator|->
name|li_name
expr_stmt|;
else|else
name|bn
operator|++
expr_stmt|;
block|}
name|ndx
operator|=
name|ld_strtab_insert_no_suffix
argument_list|(
name|ld
argument_list|,
name|ld
operator|->
name|ld_dynstr
argument_list|,
name|bn
argument_list|)
expr_stmt|;
comment|/* Save the generated name index for later use. */
if|if
condition|(
name|lo
operator|->
name|lo_dso_nameindex
operator|==
name|NULL
condition|)
name|utarray_new
argument_list|(
name|lo
operator|->
name|lo_dso_nameindex
argument_list|,
operator|&
name|ut_int_icd
argument_list|)
expr_stmt|;
name|utarray_push_back
argument_list|(
name|lo
operator|->
name|lo_dso_nameindex
argument_list|,
operator|&
name|ndx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

