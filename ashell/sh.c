begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sh.h"
end_include

begin_comment
comment|/*  * Shell  *  * Modified by Bill Joy  * UC Berkeley 1976/1977  *  	Features remaining to be fixed up and/or implemented 	======== ========= == == ===== == === == ===========   * Commands insert and delete on argument lists should be  * implemented also set 3= when have 2 arguments should be  * handled somehow (perhaps optionally valid).  * Also note that $12 should really be done correctly.   * A notion of terse ?   * time time ... time time date etc. are funny  * These should be implemented correctly with the internal versions  * of exit repeat if goto etc.  Probably want to maintain a timed  * process number list and check this when processes die (this uses  * less processes than forking a time).   * Better facilities for string manipulation ?   * The exit status variable should be implemented (status)  * and set too by the internal commands.  When do this get  * rid of kludge about prompt not set for exit on error or  * fix up in some way.  Also should rewrite the argument  * processing section to be cleaner and make some sense.   * Do verbose more cleanly.   * Implement next (recursively!)   * Implement shell filters and<<. This probably involves some more  * modularization of the scanner and deciphering of the two different  * options available in the bell shell.   * Other stuff from Bell shell -  *  *	Any more control facilities ?  *	||&&  *<>,><,>2, 2>, etc.  *	Terminate  *	Can we build high level commands out of gotos which have  *	    optional defaults and ifs that set variables which one  *	    can test ? Think so !  *	    but what about "for" ?  *	Prompt for more input ?  *	Command substitution `   ` ?  *	Trap ?  *	Exec ?  *	Eval ?  *	.acct ?  *	Some way to set stdin to be input when filters can happen.   * What about file name substitution and quoting in set.   * Conditional expressions should be fixed up with set name@  * and to allow quoting at least between ? ... : ... }.   * internal if, repeat, nohup, goto, exit, echo, echononl  * Repeat, time, nohup, etc. should allow  *  *	repeat 10 { sleep 5; echo hi }&  *	time { pc -l *.p ; obj }  * or perhaps with ('s since that is illegal now anyways  * although the above is more like if.   * Changes to glob to allow ~, prevent too long path, and prevent  * perhaps running out of directories.  Also change it so it doesn't  * exit so ungracefully, i.e. on:  *	chdir /asdf/adfas/a*  * In error diagnostics the command name is often not set or set  * wrong on calls to bferr.  Could have more calls to bferr2.  * Should be able to distinguish between ``No more processes'' and  * ``Too many processes.''   * Shell flags to exit on error, make undefined variables an error.   * Interrupted waits and errors in glob cost storage.  * Scratch should go away.  * Set a="abc" should print back similarly.   * Last, but certainly not least, some of the INTERLISP redo etc features.   */
end_comment

begin_expr_stmt
name|char
name|prompt
index|[]
literal|"prompt"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|pcs
index|[]
literal|"pcs"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|shell
index|[]
literal|"shell"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|pid
index|[]
literal|"pid"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|home
index|[]
literal|"home"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|path
index|[]
literal|"path"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|n_args
index|[]
literal|"nargs"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|tim
index|[]
literal|"time"
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|narginp
decl_stmt|,
name|nonelflg
decl_stmt|,
name|nverbose
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|c
parameter_list|,
name|av
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
specifier|register
name|f
expr_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|v
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|settimes
argument_list|()
expr_stmt|;
name|v
operator|=
name|av
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|loginsh
operator|=
operator|*
operator|*
name|v
operator|==
literal|'-'
expr_stmt|;
name|set
argument_list|(
name|home
argument_list|,
name|gethome
argument_list|()
operator|==
literal|0
condition|?
name|savestr
argument_list|(
name|hentry
operator|.
name|home
argument_list|)
else|:
literal|"."
argument_list|)
expr_stmt|;
name|set1
argument_list|(
literal|"0404"
argument_list|,
literal|"/usr/bin/px"
argument_list|,
operator|&
name|interps
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|prompt
argument_list|,
name|uid
operator|==
literal|0
condition|?
literal|"#\240"
else|:
literal|"\246\240"
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|shell
argument_list|,
literal|"/usr/bin/ashell"
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|pid
argument_list|,
name|putn
argument_list|(
name|getpid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|set1
argument_list|(
name|tim
argument_list|,
literal|"tyme"
argument_list|,
operator|&
name|aliases
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|3
init|;
name|f
operator|<
literal|15
condition|;
name|f
operator|++
control|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|v
index|[
literal|1
index|]
operator|)
operator|==
literal|'-'
condition|)
block|{
do|do
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'V'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
case|case
literal|'v'
case|:
name|nverbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|c
operator|>
literal|2
condition|)
name|narginp
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
goto|goto
name|l1
goto|;
case|case
literal|'t'
case|:
name|nonelflg
operator|=
literal|2
expr_stmt|;
case|case
literal|'\0'
case|:
name|l1
label|:
name|set
argument_list|(
name|prompt
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|unsetv
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
case|case
literal|'i'
case|:
operator|*
operator|*
name|v
operator|=
literal|'-'
expr_stmt|;
name|nofile
operator|++
expr_stmt|;
break|break;
block|}
do|while
condition|(
operator|*
name|cp
condition|)
do|;
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nofile
operator|==
literal|0
operator|&&
name|c
operator|>
literal|1
condition|)
block|{
name|set
argument_list|(
name|prompt
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|unsetv
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
name|cp
operator|=
name|v
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|prs
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|": Cannot open"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|gtty
argument_list|(
literal|0
argument_list|,
name|scratch
argument_list|)
operator|==
literal|0
operator|&&
name|gtty
argument_list|(
literal|1
argument_list|,
name|scratch
argument_list|)
operator|==
literal|0
condition|)
operator|*
operator|*
name|v
operator|=
literal|'-'
expr_stmt|;
name|c
operator|--
expr_stmt|;
name|v
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
literal|1
expr_stmt|;
name|v
operator|=
name|av
expr_stmt|;
block|}
name|setargs
argument_list|(
name|c
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|path
argument_list|,
literal|"-/bin-/usr/bin"
argument_list|)
expr_stmt|;
name|pfile
argument_list|(
literal|"/.profile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loginsh
condition|)
name|pfile
argument_list|(
literal|"/.login"
argument_list|)
expr_stmt|;
name|arginp
operator|=
name|narginp
expr_stmt|;
name|onelflg
operator|=
name|nonelflg
expr_stmt|;
name|verbose
operator|=
name|nverbose
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|av
operator|==
literal|'-'
condition|)
block|{
name|setintr
operator|++
expr_stmt|;
name|signal
argument_list|(
name|QUIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|INTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* mask the name ?? */
name|process
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|loginsh
condition|)
name|prs
argument_list|(
literal|"logout\n"
argument_list|)
expr_stmt|;
name|goodbye
argument_list|(
name|loginsh
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|pfile
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|oldinput
decl_stmt|,
name|c
decl_stmt|;
name|strcpy
argument_list|(
name|scratch
argument_list|,
name|hentry
operator|.
name|home
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|scratch
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|oldinput
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|open
argument_list|(
name|scratch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|process
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|dup
argument_list|(
name|oldinput
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|oldinput
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|goodbye
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|f
condition|)
block|{
name|signal
argument_list|(
name|QUIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|INTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setintr
operator|=
literal|0
expr_stmt|;
name|pfile
argument_list|(
literal|"/.logout"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|process
argument_list|(
argument|pro
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|setexit
argument_list|()
expr_stmt|;
if|if
condition|(
name|doneinp
condition|)
block|{
name|doneinp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|cp
operator|=
name|value
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pro
condition|)
name|prs
argument_list|(
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|echo
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|main1
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|main1
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|t
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|lex
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|err
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|freelex
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|syntax
argument_list|(
name|paraml
operator|.
name|next
argument_list|,
operator|&
name|paraml
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|err
argument_list|(
name|error
argument_list|)
expr_stmt|;
else|else
name|execute
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|freesyn
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|freelex
argument_list|(
operator|&
name|paraml
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|echo
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|c
operator|=
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_macro
name|err
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|prs
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|value
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
block|{
name|seek
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|prs
argument_list|(
name|os
argument_list|)
specifier|register
name|char
operator|*
name|os
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|os
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|os
argument_list|,
name|s
operator|-
name|os
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|digit
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|c
operator|=
operator|&
literal|0177
expr_stmt|;
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_block

begin_macro
name|letter
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|c
operator|=
operator|&
literal|0177
expr_stmt|;
return|return
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|||
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
return|;
block|}
end_block

begin_macro
name|any
argument_list|(
argument|c
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|char
name|htmp
index|[]
literal|"/etc/htmp"
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|tty
decl_stmt|;
end_decl_stmt

begin_macro
name|gethome
argument_list|()
end_macro

begin_block
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|bufp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|loginsh
condition|)
name|exechome
argument_list|()
expr_stmt|;
name|tty
operator|=
name|ttyn
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|readhome
argument_list|()
operator|==
literal|0
operator|&&
name|hentry
operator|.
name|uid
operator|==
name|uid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|getpw
argument_list|(
name|uid
argument_list|,
name|buf
argument_list|)
operator|&&
name|sleep
argument_list|(
literal|15
argument_list|)
operator|,
name|getpw
argument_list|(
name|uid
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bufp
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|bufp
operator|!=
literal|':'
condition|)
if|if
condition|(
operator|*
name|bufp
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bufp
operator|++
expr_stmt|;
block|}
comment|/* 	printf("buf %s bufp %s", buf, bufp); */
for|for
control|(
name|cp
operator|=
name|bufp
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|':'
condition|;
name|cp
operator|++
control|)
continue|continue;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
comment|/* 	printf("bufp %s\n", bufp); */
name|hentry
operator|.
name|uid
operator|==
name|uid
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
name|hentry
operator|.
name|home
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|hentry
operator|.
name|home
index|[
name|i
index|]
operator|=
operator|*
name|bufp
condition|?
operator|*
name|bufp
operator|++
else|:
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|readhome
argument_list|()
end_macro

begin_block
block|{
name|int
name|htmpf
decl_stmt|;
name|htmpf
operator|=
name|open
argument_list|(
name|htmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|htmpf
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|seek
argument_list|(
name|htmpf
argument_list|,
name|tty
operator|*
sizeof|sizeof
name|hentry
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|htmpf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|htmpf
argument_list|,
operator|&
name|hentry
argument_list|,
sizeof|sizeof
name|hentry
argument_list|)
operator|!=
sizeof|sizeof
name|hentry
condition|)
block|{
name|close
argument_list|(
name|htmpf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|close
argument_list|(
name|htmpf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|exechome
argument_list|()
end_macro

begin_block
block|{
name|int
name|status
decl_stmt|;
specifier|static
name|reenter
expr_stmt|;
if|if
condition|(
name|reenter
condition|)
return|return;
name|reenter
operator|=
literal|1
expr_stmt|;
comment|/* 	if (fork()) { 		wait(&status); 		if (tty == 'x') 			tty = status>> 8; 	} else { 		execl("/usr/bin/sethome", loginsh ? "-" : "x", 0); 		exit(0177); 	} */
block|}
end_block

begin_macro
name|getpw
argument_list|(
argument|uid
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|pbuf
index|[
literal|512
index|]
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|pbufp
decl_stmt|;
name|int
name|pwf
decl_stmt|,
name|m
decl_stmt|,
name|pbufc
decl_stmt|;
name|pwf
operator|=
name|open
argument_list|(
literal|"/etc/passwd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwf
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|pbufc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
do|do
block|{
if|if
condition|(
name|pbufc
operator|==
literal|0
condition|)
block|{
name|pbufc
operator|=
name|read
argument_list|(
name|pwf
argument_list|,
operator|&
name|pbuf
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbufc
operator|<=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|pbufp
operator|=
name|pbuf
expr_stmt|;
block|}
name|pbufc
operator|--
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|bp
operator|++
operator|=
operator|*
name|pbufp
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
do|;
operator|*
name|bp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		printf("uid %d xid %d buf %s", uid, xid(buf), buf); */
if|if
condition|(
name|xid
argument_list|(
name|buf
argument_list|)
operator|==
name|uid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|xid
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|uid
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|bp
operator|!=
literal|':'
condition|)
if|if
condition|(
operator|*
name|bp
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|++
operator|)
operator|!=
literal|':'
condition|)
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|digit
argument_list|(
name|c
argument_list|)
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|uid
operator|=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|++
operator|)
operator|!=
literal|':'
condition|)
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|digit
argument_list|(
name|c
argument_list|)
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
name|i
operator|<<
literal|8
operator||
name|uid
operator|)
return|;
block|}
end_block

end_unit

