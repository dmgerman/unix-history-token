begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c */
end_comment

begin_comment
comment|/*     *  EGP User Process, ISI 23-Jun-84  */
end_comment

begin_include
include|#
directive|include
file|"include.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
name|int
name|install
init|=
name|INSTALL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* install routes from now on */
end_comment

begin_comment
comment|/* "egpup" is a user process that implements the Exterior Gateway Protocol   * under Unix 4.2 BSD according to the spec. in RFC 888 and 904.  * Usage: egpup [-t[i][e][r][p]] [logfile]  * where t => (if alone) trace all error messages, route changes and packets,  *	 i => trace internal errors,  *	 e => trace external errors due to EGP, and egp state changes,  *	 r => trace all routing changes,  *	 p => trace all EGP packets,  *	 logfile is the output log file.  * Fatal error messages are always logged.  *  * Written by Paul Kirton@ISI, based on EGP code written for C-gateway by Liza  * Martin and Unix 4.2 BSD "routed" code.  */
end_comment

begin_decl_stmt
name|int
name|tracelevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trace
index|[]
init|=
block|{
literal|0
block|,
name|TR_INT
operator||
name|TR_EXT
block|,
name|TR_INT
operator||
name|TR_EXT
operator||
name|TR_RT
block|,
name|TR_INT
operator||
name|TR_EXT
operator||
name|TR_RT
operator||
name|TR_PKT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|logfile
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|sigtrace
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|sigvec
name|vec
decl_stmt|,
name|ovec
decl_stmt|;
name|int
name|selectbits
decl_stmt|,
name|forever
init|=
name|TRUE
decl_stmt|,
name|error
init|=
name|FALSE
decl_stmt|,
name|count
decl_stmt|,
name|arg_n
init|=
literal|0
decl_stmt|,
name|time
decl_stmt|;
name|char
modifier|*
name|strtime
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* check arguments for turning on tracing and a trace file */
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|!
name|error
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|arg_n
operator|++
expr_stmt|;
switch|switch
condition|(
name|arg_n
condition|)
block|{
case|case
literal|1
case|:
name|cp
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
else|else
name|logfile
operator|=
operator|*
name|argv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'t'
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|tracing
operator|=
name|TR_INT
operator||
name|TR_EXT
operator||
name|TR_RT
operator||
name|TR_PKT
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'i'
case|:
name|tracing
operator||=
name|TR_INT
expr_stmt|;
name|tracelevel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|tracing
operator||=
name|TR_EXT
expr_stmt|;
name|tracelevel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|tracing
operator||=
name|TR_RT
expr_stmt|;
name|tracelevel
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|tracing
operator||=
name|TR_PKT
expr_stmt|;
name|tracelevel
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
empty_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|logfile
operator|=
operator|*
name|argv
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: egpup [-t[i][e][r][p]] [logfile]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DEBUG
if|if
condition|(
operator|!
name|tracing
operator|||
name|logfile
operator|!=
name|NULL
condition|)
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|20
condition|;
name|t
operator|++
control|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|t
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|logfile
operator|!=
name|NULL
condition|)
block|{
name|freopen
argument_list|(
name|logfile
argument_list|,
literal|"a"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|freopen
argument_list|(
name|logfile
argument_list|,
literal|"a"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"File \"%s\" logs trace and error messages for "
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"the EGP user process, \"egpup\".\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Tracing levels turned on: "
argument_list|)
expr_stmt|;
name|TRACE_INT
argument_list|(
literal|"i "
argument_list|)
expr_stmt|;
name|TRACE_EXT
argument_list|(
literal|"e "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracing
operator|&
name|TR_RT
condition|)
name|printf
argument_list|(
literal|"r "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracing
operator|&
name|TR_PKT
condition|)
name|printf
argument_list|(
literal|"p "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tracing
condition|)
block|{
name|getod
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|strtime
operator|=
name|ctime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Start egpup at %s\n"
argument_list|,
name|strtime
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|sigtrace
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|sigtrace
argument_list|)
expr_stmt|;
comment|/* get socket for sending EGP packets - single socket  			   so kernel assigns correct source address */
name|init_if
argument_list|()
expr_stmt|;
comment|/* initialize tables for internet interfaces except 			/* loopback */
name|init_sock
argument_list|()
expr_stmt|;
comment|/* open sockets on each interface */
name|s
operator|=
name|ifnet
operator|->
name|int_egpsock
expr_stmt|;
comment|/* socket descriptor for ioctl calls 					to install routes */
name|fp
operator|=
name|fopen
argument_list|(
name|EGPINITFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* open initialization file */
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"main: initialization file %s missing\n"
argument_list|,
name|EGPINITFILE
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
name|init_egpngh
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* read egp neighbor list */
name|init_egp
argument_list|()
expr_stmt|;
comment|/* initialize EGP neighbor tables */
name|rt_init
argument_list|()
expr_stmt|;
comment|/* initialize route hash tables */
comment|/*	rt_readkernel();	/* Initailize routing tables consistent with 				 * kernel's initial state */
name|rt_ifinit
argument_list|()
expr_stmt|;
comment|/* initialize interior routes for direct nets 				 */
if|if
condition|(
name|install
condition|)
block|{
name|TRACE_RT
argument_list|(
literal|"\n***Routes are being installed in kernel\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|TRACE_RT
argument_list|(
literal|"\n***Routes are not being installed in kernel\n\n"
argument_list|)
expr_stmt|;
name|rt_dumbinit
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* initialize interior routes for non-routing 				 * gateways */
name|rt_NRadvise_init
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/*  initialize interior routes to be advised 				 * in NR mesages */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* setup abort signal */
name|vec
operator|.
name|sv_handler
operator|=
name|egpallcease
expr_stmt|;
name|vec
operator|.
name|sv_mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|sigvec
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|vec
argument_list|,
operator|&
name|ovec
argument_list|)
condition|)
block|{
name|p_error
argument_list|(
literal|"main:sigvec"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
comment|/* commence periodic EGP and route-age processing */
name|vec
operator|.
name|sv_handler
operator|=
name|timeout
expr_stmt|;
name|vec
operator|.
name|sv_mask
operator|=
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|vec
argument_list|,
operator|&
name|ovec
argument_list|)
condition|)
block|{
name|p_error
argument_list|(
literal|"main:sigvec"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
name|timeout
argument_list|()
expr_stmt|;
comment|/* wait to receive EGP, ICMP or IMP messages */
name|selectbits
operator|=
literal|0
expr_stmt|;
comment|/* select descriptor mask */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
name|selectbits
operator||=
literal|1
operator|<<
name|ifp
operator|->
name|int_egpsock
expr_stmt|;
comment|/* EGP socket */
name|selectbits
operator||=
literal|1
operator|<<
name|ifp
operator|->
name|int_icmpsock
expr_stmt|;
comment|/* ICMP socket */
block|}
comment|/* IMP sockets not included yet */
while|while
condition|(
name|forever
condition|)
block|{
name|int
name|ibits
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|ibits
operator|=
name|selectbits
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
literal|20
argument_list|,
operator|&
name|ibits
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* multiplex input */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|p_error
argument_list|(
literal|"main:select"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
comment|/* receive EGP packet */
if|if
condition|(
name|ibits
operator|&
operator|(
literal|1
operator|<<
name|ifp
operator|->
name|int_egpsock
operator|)
condition|)
name|recvpkt
argument_list|(
name|ifp
operator|->
name|int_egpsock
argument_list|,
name|IPPROTO_EGP
argument_list|)
expr_stmt|;
comment|/* receive ICMP packet 					- not implemeted - need new protocol 					number for listening to ICMP redirects 					see work book 4, p.26 */
if|if
condition|(
name|ibits
operator|&
operator|(
literal|1
operator|<<
name|ifp
operator|->
name|int_icmpsock
operator|)
condition|)
name|recvpkt
argument_list|(
name|ifp
operator|->
name|int_icmpsock
argument_list|,
name|IPPROTO_ICMP
argument_list|)
expr_stmt|;
block|}
comment|/* handle IMP messages - not implemented */
block|}
block|}
end_function

begin_macro
name|sigtrace
argument_list|(
argument|sig
argument_list|)
end_macro

begin_block
block|{
name|time_t
name|time
decl_stmt|;
if|if
condition|(
name|sig
operator|==
name|SIGIOT
condition|)
name|tracelevel
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|tracelevel
operator|<
literal|3
condition|)
name|tracelevel
operator|++
expr_stmt|;
if|if
condition|(
name|tracing
operator|==
literal|0
operator|&&
name|trace
index|[
name|tracelevel
index|]
condition|)
block|{
name|freopen
argument_list|(
name|logfile
argument_list|,
literal|"a"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|freopen
argument_list|(
name|logfile
argument_list|,
literal|"a"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tracing
operator|=
name|trace
index|[
name|tracelevel
index|]
expr_stmt|;
name|getod
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Change tracing at %s\n"
argument_list|,
name|ctime
argument_list|(
operator|&
name|time
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Tracing levels turned on: "
argument_list|)
expr_stmt|;
name|TRACE_INT
argument_list|(
literal|"i "
argument_list|)
expr_stmt|;
name|TRACE_EXT
argument_list|(
literal|"e "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracing
operator|&
name|TR_RT
condition|)
name|printf
argument_list|(
literal|"r "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracing
operator|&
name|TR_PKT
condition|)
name|printf
argument_list|(
literal|"p "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracing
operator|==
literal|0
condition|)
block|{
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"a"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"a"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|recvpkt
argument_list|(
argument|sock
argument_list|,
argument|protocol
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sock
decl_stmt|,
name|protocol
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|u_char
name|packet
index|[
name|MAXPACKETSIZE
operator|+
literal|10
index|]
decl_stmt|;
comment|/* packet buffer */
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|int
name|fromlen
init|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
decl_stmt|,
name|count
decl_stmt|,
name|omask
decl_stmt|;
name|short
name|hlen
decl_stmt|;
name|count
operator|=
name|recvfrom
argument_list|(
name|sock
argument_list|,
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
name|packet
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
if|if
condition|(
name|tracing
operator|&
name|TR_INT
condition|)
name|p_error
argument_list|(
literal|"recvpkt:recvfrom"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fromlen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|TRACE_INT
argument_list|(
literal|"recvpkt: fromlen %d invalid\n\n"
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|count
operator|>
name|MAXPACKETSIZE
condition|)
block|{
name|TRACE_INT
argument_list|(
literal|"recvfrom: packet discarded, length %d> %d"
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|packet
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE_INT
argument_list|(
literal|", from addr %s\n\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGTERM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTE: Unix raw socket passes IP packet data length in place of the total  length, this and id and offset are in vax format not network. (but ICMP  packet does not include the IP header). */
if|if
condition|(
name|tracing
operator|&
name|TR_PKT
condition|)
name|tracercv
argument_list|(
name|sock
argument_list|,
name|protocol
argument_list|,
name|packet
argument_list|,
name|count
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|protocol
condition|)
block|{
case|case
name|IPPROTO_EGP
case|:
name|egpin
argument_list|(
name|packet
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|icmpin
argument_list|(
name|packet
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMPLINK_IP
case|:
break|break;
comment|/* not implemented - need care with different 				address family for imp? */
block|}
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* process ICMP redirect message */
end_comment

begin_expr_stmt
name|icmpin
argument_list|(
name|ip
argument_list|,
name|cc
argument_list|)
specifier|register
expr|struct
name|ip
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|icmp
modifier|*
name|icmppkt
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|struct
name|sockaddr_in
name|gateway
decl_stmt|,
comment|/* gateway address */
name|dest
decl_stmt|;
comment|/* destination addr */
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|cc
operator|<
name|hlen
operator|+
name|ICMP_MINLEN
condition|)
return|return;
name|cc
operator|-=
name|hlen
expr_stmt|;
name|icmppkt
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|hlen
operator|)
expr_stmt|;
if|if
condition|(
name|icmppkt
operator|->
name|icmp_type
operator|!=
name|ICMP_REDIRECT
condition|)
return|return;
elseif|else
if|if
condition|(
name|icmppkt
operator|->
name|icmp_code
operator|!=
name|ICMP_REDIRECT_NET
condition|)
return|return;
else|else
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|gateway
argument_list|,
sizeof|sizeof
argument_list|(
name|gateway
argument_list|)
argument_list|)
expr_stmt|;
name|gateway
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|gateway
operator|.
name|sin_addr
operator|=
name|icmppkt
operator|->
name|icmp_gwaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dest
operator|.
name|sin_addr
operator|=
name|icmppkt
operator|->
name|icmp_ip
operator|.
name|ip_dst
expr_stmt|;
comment|/* set local part zero */
name|dest
operator|.
name|sin_addr
operator|=
name|inet_makeaddr
argument_list|(
name|inet_netof
argument_list|(
name|dest
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rt_redirect
argument_list|(
operator|&
name|dest
argument_list|,
operator|&
name|gateway
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_comment
comment|/* timer control for periodic EGP and route-age processing */
end_comment

begin_macro
name|timeout
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|next_egpjob
init|=
literal|0
decl_stmt|,
name|next_rttime
init|=
literal|0
decl_stmt|;
name|int
name|time
decl_stmt|,
name|interval
decl_stmt|;
name|struct
name|itimerval
name|value
decl_stmt|,
name|ovalue
decl_stmt|;
name|getod
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_rttime
operator|==
literal|0
condition|)
comment|/* initialization */
name|next_rttime
operator|=
name|time
operator|+
name|RT_TIMERRATE
expr_stmt|;
comment|/* execute routines past time */
if|if
condition|(
name|time
operator|>=
name|next_egpjob
condition|)
block|{
name|egpjob
argument_list|()
expr_stmt|;
name|next_egpjob
operator|=
name|time
operator|+
name|egpsleep
expr_stmt|;
block|}
if|if
condition|(
name|time
operator|>=
name|next_rttime
condition|)
block|{
name|rt_time
argument_list|()
expr_stmt|;
name|next_rttime
operator|=
name|time
operator|+
name|RT_TIMERRATE
expr_stmt|;
block|}
comment|/* determine next timeout interval  					and reset timer */
name|interval
operator|=
name|egpsleep
expr_stmt|;
if|if
condition|(
name|RT_TIMERRATE
operator|<
name|egpsleep
condition|)
name|interval
operator|=
name|RT_TIMERRATE
expr_stmt|;
name|value
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|/* no auto timer reload */
name|value
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|value
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|interval
expr_stmt|;
name|value
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|ovalue
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* periodically flush output */
return|return;
block|}
end_block

begin_comment
comment|/* get time of day in seconds */
end_comment

begin_macro
name|getod
argument_list|(
argument|timept
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|timept
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
name|struct
name|timezone
name|tzp
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
condition|)
name|p_error
argument_list|(
literal|"getod: gettimeofday"
argument_list|)
expr_stmt|;
operator|*
name|timept
operator|=
name|tp
operator|.
name|tv_sec
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* exit egpup */
end_comment

begin_macro
name|quit
argument_list|()
end_macro

begin_block
block|{
name|int
name|time
decl_stmt|;
name|char
modifier|*
name|strtime
decl_stmt|;
if|if
condition|(
name|rt_default_status
operator|==
name|NOTINSTALLED
condition|)
name|rt_default
argument_list|(
literal|"ADD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracing
condition|)
block|{
name|getod
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|strtime
operator|=
name|ctime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Exit egpup at %s\n\n"
argument_list|,
name|strtime
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print error message  *  * First flush stdout stream to preserve log order as perror writes directly  * to file  */
end_comment

begin_macro
name|p_error
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

