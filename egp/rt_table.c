begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	rt_table.c  */
end_comment

begin_comment
comment|/* EGP User Process, ISI 23-Jun-84 */
end_comment

begin_comment
comment|/*  * Routing table management routines.  * Modified from Routing Table Management Daemon tables.c  */
end_comment

begin_include
include|#
directive|include
file|"include.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|install
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if 1 call kernel, it is set by 					 * main() after kernel routes  					 * initially read and read in table2.c 					 */
end_comment

begin_comment
comment|/*  * Lookup dst in the exterior route tables for an exact match.  */
end_comment

begin_function
name|struct
name|rt_entry
modifier|*
name|rt_ext_lookup
parameter_list|(
name|dst
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|dst
decl_stmt|;
block|{
specifier|register
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
specifier|register
name|struct
name|rthash
modifier|*
name|rh
decl_stmt|;
specifier|register
name|unsigned
name|hash
decl_stmt|;
if|if
condition|(
name|dst
operator|->
name|sin_family
operator|!=
name|AF_INET
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hash
operator|=
name|inet_netof
argument_list|(
name|dst
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
name|rh
operator|=
operator|&
name|nethash
index|[
name|hash
operator|%
name|ROUTEHASHSIZ
index|]
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|rh
operator|->
name|rt_forw
init|;
name|rt
operator|!=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
name|rh
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_forw
control|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_hash
operator|!=
name|hash
condition|)
continue|continue;
if|if
condition|(
name|equal
argument_list|(
operator|&
name|rt
operator|->
name|rt_dst
argument_list|,
name|dst
argument_list|)
condition|)
return|return
operator|(
name|rt
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* rt_int_lookup() looks for exact destination match in internal routing table  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|rthash
name|rt_interior
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|rt_entry
modifier|*
name|rt_int_lookup
parameter_list|(
name|dst
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
block|{
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
for|for
control|(
name|rt
operator|=
name|rt_interior
operator|.
name|rt_forw
init|;
name|rt
operator|!=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
operator|&
name|rt_interior
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_forw
control|)
if|if
condition|(
name|equal
argument_list|(
operator|&
name|rt
operator|->
name|rt_dst
argument_list|,
name|dst
argument_list|)
condition|)
return|return
operator|(
name|rt
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add a route to either the interior or exterior routing tables  */
end_comment

begin_macro
name|rt_add
argument_list|(
argument|table
argument_list|,
argument|dst
argument_list|,
argument|gate
argument_list|,
argument|metric
argument_list|,
argument|state
argument_list|)
end_macro

begin_decl_stmt
name|int
name|table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interior or exterior table */
end_comment

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|,
modifier|*
name|gate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|metric
decl_stmt|,
name|state
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|struct
name|rthash
modifier|*
name|rh
decl_stmt|;
name|unsigned
name|hash
decl_stmt|;
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
return|return;
name|hash
operator|=
name|inet_netof
argument_list|(
name|in_addr_ofs
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|EXTERIOR
condition|)
name|rh
operator|=
operator|&
name|nethash
index|[
name|hash
operator|%
name|ROUTEHASHSIZ
index|]
expr_stmt|;
comment|/* start ext. list */
else|else
name|rh
operator|=
operator|(
expr|struct
name|rthash
operator|*
operator|)
name|rt_interior
operator|.
name|rt_back
expr_stmt|;
comment|/* end int. list */
name|rt
operator|=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" rt_add: malloc: out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rt
operator|->
name|rt_hash
operator|=
name|hash
expr_stmt|;
name|rt
operator|->
name|rt_dst
operator|=
operator|*
name|dst
expr_stmt|;
comment|/* set local part of dest addr zero for nets*/
if|if
condition|(
name|inet_lnaof
argument_list|(
name|in_addr_ofs
argument_list|(
operator|&
name|rt
operator|->
name|rt_dst
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|in_addr_ofs
argument_list|(
operator|&
name|rt
operator|->
name|rt_dst
argument_list|)
operator|=
name|inet_makeaddr
argument_list|(
name|inet_netof
argument_list|(
name|in_addr_ofs
argument_list|(
operator|&
name|rt
operator|->
name|rt_dst
argument_list|)
argument_list|)
argument_list|,
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_router
operator|=
operator|*
name|gate
expr_stmt|;
name|rt
operator|->
name|rt_metric
operator|=
name|metric
expr_stmt|;
name|rt
operator|->
name|rt_timer
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|=
name|RTF_UP
expr_stmt|;
name|rt
operator|->
name|rt_state
operator|=
name|state
operator||
name|RTS_CHANGED
expr_stmt|;
name|rt
operator|->
name|rt_ifp
operator|=
name|if_withnet
argument_list|(
operator|&
name|rt
operator|->
name|rt_router
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|EXTERIOR
condition|)
block|{
name|rt
operator|->
name|rt_flags
operator||=
name|RTF_GATEWAY
expr_stmt|;
comment|/* for exterior routing table 						all routes are gateways, with 						EGP we dont necessarily know 						the meaning of the metric */
name|TRACE_ACTION
argument_list|(
argument|ADD EXT
argument_list|,
argument|rt
argument_list|)
block|}
else|else
block|{
if|if
condition|(
name|metric
condition|)
comment|/* interior routing uses hop  						count as metric => interfaces 						have zero metric */
name|rt
operator|->
name|rt_flags
operator||=
name|RTF_GATEWAY
expr_stmt|;
name|TRACE_ACTION
argument_list|(
argument|ADD INT
argument_list|,
argument|rt
argument_list|)
block|}
name|insque
argument_list|(
name|rt
argument_list|,
name|rh
argument_list|)
expr_stmt|;
comment|/* 	 * If the ioctl fails because the gateway is unreachable 	 * from this host, discard the entry.  This should only 	 * occur because of an incorrect entry in /etc/egp_gateways. 	 */
if|if
condition|(
name|install
operator|&&
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RTS_NOTINSTALL
operator|)
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCADDRT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_rt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p_error
argument_list|(
literal|"rt_add: SIOCADDRT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENETUNREACH
condition|)
block|{
name|TRACE_ACTION
argument_list|(
name|DELETE
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* change a route&/or note that update received.  * returns 1 if change made  */
end_comment

begin_macro
name|rt_change
argument_list|(
argument|rt
argument_list|,
argument|gate
argument_list|,
argument|metric
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|gate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|metric
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|doioctl
init|=
literal|0
decl_stmt|,
name|metricchanged
init|=
literal|0
decl_stmt|;
name|struct
name|rtentry
name|oldroute
decl_stmt|;
name|rt
operator|->
name|rt_state
operator||=
name|RTS_CHANGED
expr_stmt|;
comment|/* ensures route age reset */
if|if
condition|(
operator|!
name|equal
argument_list|(
operator|&
name|rt
operator|->
name|rt_router
argument_list|,
name|gate
argument_list|)
condition|)
name|doioctl
operator|++
expr_stmt|;
if|if
condition|(
name|metric
operator|!=
name|rt
operator|->
name|rt_metric
condition|)
block|{
name|metricchanged
operator|++
expr_stmt|;
name|rt
operator|->
name|rt_metric
operator|=
name|metric
expr_stmt|;
block|}
if|if
condition|(
name|doioctl
condition|)
block|{
name|oldroute
operator|=
name|rt
operator|->
name|rt_rt
expr_stmt|;
name|rt
operator|->
name|rt_router
operator|=
operator|*
name|gate
expr_stmt|;
if|if
condition|(
name|install
operator|&&
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RTS_NOTINSTALL
operator|)
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCADDRT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_rt
argument_list|)
operator|<
literal|0
condition|)
name|p_error
argument_list|(
literal|"rt_change: SIOCADDRT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCDELRT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oldroute
argument_list|)
operator|<
literal|0
condition|)
name|p_error
argument_list|(
literal|"rt_change: SIOCDELRT"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doioctl
operator|||
name|metricchanged
condition|)
block|{
name|TRACE_ACTION
argument_list|(
name|CHANGE
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* delete route from exterior routing table.  */
end_comment

begin_macro
name|rt_delete
argument_list|(
argument|rt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TRACE_ACTION
argument_list|(
argument|DELETE EXT
argument_list|,
argument|rt
argument_list|)
empty_stmt|;
if|if
condition|(
name|install
operator|&&
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RTS_NOTINSTALL
operator|)
operator|&&
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCDELRT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_rt
argument_list|)
operator|<
literal|0
condition|)
name|p_error
argument_list|(
literal|"rt_delete: SIOCDELRT"
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* rt_ifupdate() sets the status (up/down) of all routes in the interior   * routing table according to the status of the  associated output interface.  */
end_comment

begin_macro
name|rt_ifupdate
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
for|for
control|(
name|rt
operator|=
name|rt_interior
operator|.
name|rt_forw
init|;
name|rt
operator|!=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
operator|&
name|rt_interior
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_forw
control|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|->
name|int_flags
operator|&
name|IFF_UP
condition|)
name|rt
operator|->
name|rt_flags
operator||=
name|RTF_UP
expr_stmt|;
else|else
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_UP
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* rt_default() adds or deletes default route in kernel.  * Called by egpstngh() to delete default after first egp neighbor acquired  * and by quit() to add default route before terminating.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rt_default_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default route status */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|install
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if TRUE install routes in kernel */
end_comment

begin_macro
name|rt_default
argument_list|(
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|struct
name|sockaddr_in
name|defaultdst
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|defaultdst
argument_list|,
sizeof|sizeof
argument_list|(
name|defaultdst
argument_list|)
argument_list|)
expr_stmt|;
name|defaultdst
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|defaultdst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|DEFAULTNET
expr_stmt|;
name|rt
operator|=
name|rt_ext_lookup
argument_list|(
operator|&
name|defaultdst
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rt_default: no default route\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"DELETE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TRACE_ACTION
argument_list|(
argument|DELETE DEFAULT
argument_list|,
argument|rt
argument_list|)
empty_stmt|;
name|rt_default_status
operator|=
name|NOTINSTALLED
expr_stmt|;
if|if
condition|(
name|install
condition|)
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCDELRT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_rt
argument_list|)
operator|<
literal|0
condition|)
name|p_error
argument_list|(
literal|"rt_default: SIOCDELRT"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"ADD"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TRACE_ACTION
argument_list|(
argument|ADD DEFAULT
argument_list|,
argument|rt
argument_list|)
empty_stmt|;
name|rt_default_status
operator|=
name|INSTALLED
expr_stmt|;
if|if
condition|(
name|install
condition|)
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCADDRT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_rt
argument_list|)
operator|<
literal|0
condition|)
name|p_error
argument_list|(
literal|"rt_default: SIOCADDRT"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_comment
comment|/* rt_time() increments the age of all routes in the exterior routing table  * If any routes are older than rt_maxage (set in egpstime() ) the routes are  * deleted.  */
end_comment

begin_macro
name|rt_time
argument_list|()
end_macro

begin_block
block|{
name|struct
name|rthash
modifier|*
name|rh
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|,
modifier|*
name|old_rt
decl_stmt|;
specifier|static
name|int
name|last_time
decl_stmt|;
name|int
name|time
decl_stmt|,
name|old_routes
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|strtime
decl_stmt|;
name|getod
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
for|for
control|(
name|rh
operator|=
name|nethash
init|;
name|rh
operator|<
operator|&
name|nethash
index|[
name|ROUTEHASHSIZ
index|]
condition|;
name|rh
operator|++
control|)
block|{
for|for
control|(
name|rt
operator|=
name|rh
operator|->
name|rt_forw
init|;
name|rt
operator|!=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
name|rh
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_forw
control|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_state
operator|&
name|RTS_CHANGED
condition|)
block|{
comment|/* recently updated */
name|rt
operator|->
name|rt_state
operator|&=
operator|~
name|RTS_CHANGED
expr_stmt|;
name|rt
operator|->
name|rt_timer
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RTS_PASSIVE
operator|)
condition|)
comment|/* dont age passive 							 routes e.g. default*/
name|rt
operator|->
name|rt_timer
operator|+=
name|time
operator|-
name|last_time
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_timer
operator|>=
name|rt_maxage
condition|)
block|{
comment|/* route too old */
name|old_routes
operator|=
name|TRUE
expr_stmt|;
name|old_rt
operator|=
name|rt
expr_stmt|;
name|rt
operator|=
name|rt
operator|->
name|rt_back
expr_stmt|;
name|TRACE_RT
argument_list|(
literal|"OLD: "
argument_list|)
expr_stmt|;
name|rt_delete
argument_list|(
name|old_rt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* if no acq. egp neigh. and old 					routes delete, reinstall default 					route */
if|if
condition|(
name|old_routes
condition|)
block|{
if|if
condition|(
name|n_acquired
operator|==
literal|0
operator|&&
name|rt_default_status
operator|==
name|NOTINSTALLED
condition|)
block|{
name|TRACE_RT
argument_list|(
literal|"rt_time: no acquired EGP neighbors\n"
argument_list|)
expr_stmt|;
name|rt_default
argument_list|(
literal|"ADD"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tracing
operator|&
name|TR_RT
condition|)
block|{
name|strtime
operator|=
name|ctime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rt_time: above old routes deleted %s\n"
argument_list|,
name|strtime
argument_list|)
expr_stmt|;
block|}
block|}
name|last_time
operator|=
name|time
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* rt_unreach() deletes all routes for a specified gateway */
end_comment

begin_macro
name|rt_unreach
argument_list|(
argument|gateway
argument_list|)
end_macro

begin_decl_stmt
name|u_long
name|gateway
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internet address of gateway */
end_comment

begin_block
block|{
name|struct
name|rthash
modifier|*
name|rh
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|,
modifier|*
name|unreach_rt
decl_stmt|;
for|for
control|(
name|rh
operator|=
name|nethash
init|;
name|rh
operator|<
operator|&
name|nethash
index|[
name|ROUTEHASHSIZ
index|]
condition|;
name|rh
operator|++
control|)
block|{
for|for
control|(
name|rt
operator|=
name|rh
operator|->
name|rt_forw
init|;
name|rt
operator|!=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
name|rh
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_forw
control|)
block|{
if|if
condition|(
name|sock_inaddr
argument_list|(
operator|&
name|rt
operator|->
name|rt_router
argument_list|)
operator|==
name|gateway
operator|&&
operator|!
operator|(
name|rt
operator|->
name|rt_state
operator|&
name|RTS_PASSIVE
operator|)
condition|)
block|{
comment|/* e.g. don't delete 							     default route */
name|unreach_rt
operator|=
name|rt
expr_stmt|;
name|rt
operator|=
name|rt
operator|->
name|rt_back
expr_stmt|;
name|TRACE_RT
argument_list|(
literal|"GW UNREACH: "
argument_list|)
expr_stmt|;
name|rt_delete
argument_list|(
name|unreach_rt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_block

begin_comment
comment|/* change the routing tables in response to an ICMP redirect message */
end_comment

begin_macro
name|rt_redirect
argument_list|(
argument|dst
argument_list|,
argument|gateway
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|,
modifier|*
name|gateway
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|saveinstall
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
comment|/* check gateway directly reachable */
if|if
condition|(
name|if_withnet
argument_list|(
name|gateway
argument_list|)
operator|==
name|NULL
condition|)
return|return;
comment|/* bad ICMP redirect gateway addr */
name|saveinstall
operator|=
name|install
expr_stmt|;
name|install
operator|=
name|FALSE
expr_stmt|;
comment|/* dont update kernel routing tables 					as redirect has already done so */
comment|/* interior routing table is for 					dumb gateways internal to my aut. sys. 					hence I should never get redirects 					for these nets */
if|if
condition|(
name|rt_int_lookup
argument_list|(
name|dst
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TRACE_EXT
argument_list|(
literal|"rt_redirect: dest. %s in internal table of"
argument_list|,
name|inet_ntoa
argument_list|(
name|sock_inaddr
argument_list|(
name|dst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE_EXT
argument_list|(
literal|" dumb routes => init error?\n"
argument_list|)
expr_stmt|;
block|}
name|TRACE_RT
argument_list|(
literal|"REDIRECT:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|=
name|rt_ext_lookup
argument_list|(
name|dst
argument_list|)
condition|)
name|rt_change
argument_list|(
name|rt
argument_list|,
name|gateway
argument_list|,
name|rt
operator|->
name|rt_metric
argument_list|)
expr_stmt|;
else|else
name|rt_add
argument_list|(
name|EXTERIOR
argument_list|,
name|dst
argument_list|,
name|gateway
argument_list|,
name|HOPCNT_INFINITY
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|install
operator|=
name|saveinstall
expr_stmt|;
return|return;
block|}
end_block

end_unit

