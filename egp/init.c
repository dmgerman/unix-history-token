begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* init.c  */
end_comment

begin_comment
comment|/* EGP User Process, ISI 23-Jun-84 */
end_comment

begin_comment
comment|/* Initialization routines */
end_comment

begin_include
include|#
directive|include
file|"include.h"
end_include

begin_comment
comment|/* Determine addresses and names of internet interfaces configured. /* Results returned in global linked list of interface tables. /* The interface names are required for later ioctl calls re interface status.  *  * External variables:  * ifnet - pointer to interface list  * n_interfaces - number of direct internet interfaces (set here)  */
end_comment

begin_decl_stmt
name|int
name|lookforinterfaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for later */
end_comment

begin_macro
name|init_if
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|s
decl_stmt|,
name|n_intf
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifreq_buf
decl_stmt|;
comment|/* buffer for receiving interace 					 * configuration info from ioctl */
name|struct
name|ifconf
name|ifconf_req
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|a
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
comment|/* Determine internet addresses of all internet interfaces, except /* ignore loopback interface. */
comment|/* First must open a temporary socket to get a valid socket descriptor for /* ioctl call. */
if|if
condition|(
operator|(
name|s
operator|=
name|getsocket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|quit
argument_list|()
expr_stmt|;
comment|/* get interface configuration */
comment|/* allocate buffer for config. if 					 * insufficient double size */
name|bufsize
operator|=
literal|5
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* ioctl assumes> size ifreq */
for|for
control|(
init|;
condition|;
control|)
block|{
name|ifreq_buf
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifreq_buf
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"init_if: malloc: out of memory\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
name|ifconf_req
operator|.
name|ifc_len
operator|=
name|bufsize
expr_stmt|;
comment|/*sizeof(ifreq_buf);*/
name|ifconf_req
operator|.
name|ifc_req
operator|=
name|ifreq_buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifconf_req
argument_list|)
condition|)
block|{
name|p_error
argument_list|(
literal|"init_if:ioctl SIOCGIFCONF:\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
comment|/* if spare buffer space for at least 					 * one more interface all found */
if|if
condition|(
operator|(
name|bufsize
operator|-
name|ifconf_req
operator|.
name|ifc_len
operator|)
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
condition|)
break|break;
comment|/* else double buffer size and retry*/
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ifreq_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
literal|40
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"init_if: more than 39 interfaces\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
name|bufsize
operator|<<=
literal|1
expr_stmt|;
block|}
name|n_intf
operator|=
name|ifconf_req
operator|.
name|ifc_len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
comment|/* number 								interfaces */
name|j
operator|=
literal|0
expr_stmt|;
comment|/* internet interface index */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_intf
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ifreq_buf
index|[
name|i
index|]
operator|.
name|ifr_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
name|addr
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq_buf
index|[
name|i
index|]
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ifp
operator|=
operator|(
expr|struct
name|interface
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"init_if: malloc: out of memory\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
comment|/* save name for future ioctl calls */
name|ifp
operator|->
name|int_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ifreq_buf
index|[
name|i
index|]
operator|.
name|ifr_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_name
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"init_if: malloc: out of memory\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|ifp
operator|->
name|int_name
argument_list|,
name|ifreq_buf
index|[
name|i
index|]
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|int_addr
operator|=
name|ifreq_buf
index|[
name|i
index|]
operator|.
name|ifr_addr
expr_stmt|;
name|ifp
operator|->
name|int_metric
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq_buf
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl (get netmask)"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ifp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ifp
operator|->
name|int_flags
operator|=
name|ifreq_buf
index|[
name|i
index|]
operator|.
name|ifr_flags
operator||
name|IFF_INTERFACE
expr_stmt|;
comment|/* no one cares about software loopback interfaces */
if|if
condition|(
name|ifp
operator|->
name|int_flags
operator|&
name|IFF_LOOPBACK
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifp
operator|->
name|int_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|||
name|ifp
operator|->
name|int_addr
operator|.
name|sa_family
operator|==
name|AF_UNSPEC
condition|)
block|{
name|lookforinterfaces
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ifp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq_buf
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ioctl (get netmask)"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ifp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq_buf
index|[
name|i
index|]
operator|.
name|ifr_addr
expr_stmt|;
name|ifp
operator|->
name|int_subnetmask
operator|=
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|a
operator|=
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|a
argument_list|)
condition|)
name|ifp
operator|->
name|int_netmask
operator|=
name|IN_CLASSA_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|a
argument_list|)
condition|)
name|ifp
operator|->
name|int_netmask
operator|=
name|IN_CLASSB_NET
expr_stmt|;
else|else
name|ifp
operator|->
name|int_netmask
operator|=
name|IN_CLASSC_NET
expr_stmt|;
name|ifp
operator|->
name|int_net
operator|=
name|a
operator|&
name|ifp
operator|->
name|int_netmask
expr_stmt|;
name|ifp
operator|->
name|int_subnet
operator|=
name|a
operator|&
name|ifp
operator|->
name|int_subnetmask
expr_stmt|;
name|ifp
operator|->
name|int_next
operator|=
name|ifnet
expr_stmt|;
name|ifnet
operator|=
name|ifp
expr_stmt|;
name|TRACE_INT
argument_list|(
literal|"init_if: interface name: %s, address %s\n"
argument_list|,
name|ifp
operator|->
name|int_name
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/**/
comment|/* if multiple interfaces with same net number exit as the rpoting tables  * assume at most one interface per net.  */
for|for
control|(
name|ifp
operator|=
name|ifnet
operator|->
name|int_next
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
if|if
condition|(
name|ifnet
operator|->
name|int_subnet
operator|==
name|ifp
operator|->
name|int_subnet
condition|)
block|{
name|printf
argument_list|(
literal|"init_if: Exit as multiple "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"interfaces to net of interface %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|n_interfaces
operator|=
name|j
expr_stmt|;
comment|/* number internet interfaces */
if|if
condition|(
name|n_interfaces
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"if_init: Exit no interfaces\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ifreq_buf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Open raw sockets for sending and receiving packets on each interface.  *  * External variables:  * ifnet - interface list  */
end_comment

begin_macro
name|init_sock
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
comment|/* open socket on each interface */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
literal|0
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
name|addr
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifp
operator|->
name|int_addr
expr_stmt|;
name|addr
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
comment|/* Open raw socket for EGP packets */
name|ifp
operator|->
name|int_egpsock
operator|=
name|getsocket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|addr
argument_list|,
name|IPPROTO_EGP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_egpsock
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"init_sock: exit as failed to open"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"egp socket\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
comment|/* open raw socket for receiving ICMP messages */
name|ifp
operator|->
name|int_icmpsock
operator|=
name|getsocket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|addr
argument_list|,
name|IPPROTO_ICMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|int_icmpsock
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"init_sock: exit as failed to open"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"icmp socket\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* end for */
comment|/* Open raw socket for receiving IMP messages */
comment|/* not implemented */
return|return;
block|}
end_block

begin_comment
comment|/* getsocket gets a socket, retries later if ni buffers at present, and binds  * an address to the socket unless sin is a null pointer.  */
end_comment

begin_macro
name|getsocket
argument_list|(
argument|domain
argument_list|,
argument|type
argument_list|,
argument|sin
argument_list|,
argument|protocol
argument_list|)
end_macro

begin_decl_stmt
name|int
name|domain
decl_stmt|,
name|type
decl_stmt|,
name|protocol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retry
decl_stmt|,
name|s
decl_stmt|;
name|int
name|bufsize
init|=
literal|4
operator|*
name|MAXPACKETSIZE
decl_stmt|;
name|retry
operator|=
literal|2
expr_stmt|;
comment|/* if no buffers a retry might work */
while|while
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
operator|)
operator|<
literal|0
operator|&&
name|retry
operator|--
condition|)
block|{
name|p_error
argument_list|(
literal|"getsocket:socket"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|sin
condition|)
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p_error
argument_list|(
literal|"getsocket:bind"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SO_RCVBUF
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|bufsize
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"getsocket: setsockopt SO_RCVBUF"
argument_list|)
expr_stmt|;
name|bufsize
operator|=
name|MAXPACKETSIZE
operator|+
literal|1024
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|bufsize
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"getsocket: setsockopt SO_SNDBUF"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_comment
comment|/* init_egpngh() reads names of EGP neighbors from EGPINITFILE  * The format is: # comment  *		  autonomoussystem value  *		  egpneighbor name  *		  egpmaxacquire value  * where name is either a symbolic name in /etc/hosts or an internet address  * in dot notation and value is the maximum nuber of EGP neighbors to acquire.  * All EGP neighbors must be on the same net.  * A state table is allocated for the neighbor and added to a linked list  * terminated by a NULL pointer.  *  * External variables:  *   mysystem - autonomous sytem number  *   maxacq - maximum number of EGP neighbors to acquire  *   nneigh - # egp neighbors  *   egpngh - pointer to start of linked list of egp neighbor state tables.  */
end_comment

begin_macro
name|init_egpngh
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|char
name|name
index|[
name|MAXHOSTNAMELENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|error
init|=
name|FALSE
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|egpngh
modifier|*
name|ngp
decl_stmt|,
modifier|*
name|egpngh_last
decl_stmt|;
name|nneigh
operator|=
literal|0
expr_stmt|;
name|egpngh
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
operator|!=
name|EOF
condition|)
block|{
comment|/* read first word of line and 						   compare to key words */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"autonomoussystem"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mysystem
argument_list|)
operator|!=
literal|1
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"egpmaxacquire"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|maxacq
argument_list|)
operator|!=
literal|1
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
else|else
name|TRACE_INT
argument_list|(
literal|"init_egpngh: egpmaxacquire = %d\n"
argument_list|,
name|maxacq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"egpneighbor"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
operator|!=
literal|1
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|getnetorhostname
argument_list|(
literal|"host"
argument_list|,
name|name
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|ngp
operator|=
operator|(
expr|struct
name|egpngh
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|egpngh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"init_egpngh: malloc: out of memory\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
comment|/* add to end of egp neighbor table linked 				   list so order same as in EGPINITFILE, 				   although simpler to add to front. 				 */
if|if
condition|(
name|egpngh
operator|==
name|NULL
condition|)
name|egpngh
operator|=
name|ngp
expr_stmt|;
comment|/* first neighbor */
else|else
name|egpngh_last
operator|->
name|ng_next
operator|=
name|ngp
expr_stmt|;
name|egpngh_last
operator|=
name|ngp
expr_stmt|;
name|ngp
operator|->
name|ng_next
operator|=
name|NULL
expr_stmt|;
name|ngp
operator|->
name|ng_addr
operator|=
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|nneigh
operator|++
expr_stmt|;
name|TRACE_INT
argument_list|(
literal|"init_egpngh: EGP neighbor %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|SAMENET
comment|/* check all neighbors on same net */
if|if
condition|(
name|nneigh
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|inet_netof
argument_list|(
name|ngp
operator|->
name|ng_addr
operator|.
name|i_long
argument_list|)
operator|!=
name|inet_netof
argument_list|(
name|egpngh
operator|->
name|ng_addr
operator|.
name|i_long
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"init_egpngh: EGP neighbors on"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" different nets\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* end else if getnetorhostname... */
else|else
block|{
name|printf
argument_list|(
literal|"init_egpngh: invalid neighbor name or"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" address %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* end else egpneighbor */
do|do
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
comment|/* next line */
block|}
comment|/* end while */
if|if
condition|(
name|mysystem
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"init_egpngh: autonomous system # 0\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|maxacq
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"init_egpngh: egpmaxacquire = 0\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|maxacq
operator|>
name|nneigh
condition|)
block|{
name|printf
argument_list|(
literal|"init_egpngh: egpmaxacquire = %d> # neighbors = %d\n"
argument_list|,
name|maxacq
argument_list|,
name|nneigh
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|nneigh
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"init_egpngh: no EGP neighbors\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"init_egpngh: %s: initialization error\n"
argument_list|,
name|EGPINITFILE
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Given host or net name or internet address in dot notation assign the  * internet address in byte format.  * source is ../routed/startup.c with minor changes to detect syntax errors.  *  * Unfortunately the library routine inet_addr() does not detect mal formed  * addresses that have characters or byte values> 255.  */
end_comment

begin_macro
name|getnetorhostname
argument_list|(
argument|type
argument_list|,
argument|name
argument_list|,
argument|sin
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|,
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"net"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|netent
modifier|*
name|np
init|=
name|getnetbyname
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|u_long
name|n
decl_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|inet_network
argument_list|(
name|name
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|np
operator|->
name|n_addrtype
operator|!=
name|AF_INET
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|=
name|np
operator|->
name|n_net
expr_stmt|;
block|}
comment|/* 		 * We use unshifted network numbers internally, 		 * but inet_network and getnetbyname return shifted numbers. 		 */
if|if
condition|(
name|n
condition|)
while|while
condition|(
operator|(
name|n
operator|&
literal|0xff000000
operator|)
operator|==
literal|0
condition|)
name|n
operator|<<=
literal|8
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|inet_makeaddr
argument_list|(
name|n
argument_list|,
name|INADDR_ANY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"host"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|hostent
modifier|*
name|hp
init|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|hp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|name
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* init_egp() initializes the state tables for each potential EGP neighbor  */
end_comment

begin_macro
name|init_egp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|egpng
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|u_short
name|nn
decl_stmt|;
name|long
name|time
decl_stmt|;
name|u_short
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|struct
name|sockaddr_in
name|dst
decl_stmt|;
name|egpsleep
operator|=
name|MINHELLOINT
operator|+
name|HELLOMARGIN
expr_stmt|;
name|rt_maxage
operator|=
name|RT_MINAGE
expr_stmt|;
comment|/* minimum time before routes are 					deleted when not updated */
name|getod
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
for|for
control|(
name|ngp
operator|=
name|egpngh
init|;
name|ngp
operator|!=
name|NULL
condition|;
name|ngp
operator|=
name|ngp
operator|->
name|ng_next
control|)
block|{
name|ngp
operator|->
name|ng_state
operator|=
name|UNACQUIRED
expr_stmt|;
name|ngp
operator|->
name|ng_flags
operator|=
literal|0
expr_stmt|;
name|ngp
operator|->
name|ng_sid
operator|=
literal|1
expr_stmt|;
name|ngp
operator|->
name|ng_retry
operator|=
literal|0
expr_stmt|;
name|ngp
operator|->
name|ng_hint
operator|=
name|MINHELLOINT
operator|+
name|HELLOMARGIN
expr_stmt|;
name|ngp
operator|->
name|ng_htime
operator|=
name|time
expr_stmt|;
name|ngp
operator|->
name|ng_rcmd
operator|=
literal|0
expr_stmt|;
comment|/* Check that I have a direct net to neighbor */
name|dst
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ngp
operator|->
name|ng_addr
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|if_withnet
argument_list|(
operator|&
name|dst
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ngp
operator|->
name|ng_myaddr
operator|=
name|sock_inaddr
argument_list|(
operator|&
name|ifp
operator|->
name|int_addr
argument_list|)
expr_stmt|;
else|else
block|{
name|TRACE_INT
argument_list|(
literal|"init_egp: no direct net to %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|ngp
operator|->
name|ng_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ngp
operator|->
name|ng_state
operator|=
name|EMPTY
expr_stmt|;
block|}
block|}
comment|/* Debug */
if|#
directive|if
name|ALLOWNONNEIGHBORS
name|init_egp2
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Testing only, allows peers which do not share a direct net. The source  * interface is defined by DEFAULTIF in defs.h  */
end_comment

begin_if
if|#
directive|if
name|ALLOWNONNEIGHBORS
end_if

begin_macro
name|init_egp2
argument_list|()
end_macro

begin_block
block|{
name|reg
name|egpng
modifier|*
name|ngp
decl_stmt|;
name|printf
argument_list|(
literal|"init_egp2 called\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ngp
operator|=
name|egpngh
init|;
name|ngp
operator|!=
name|NULL
condition|;
name|ngp
operator|=
name|ngp
operator|->
name|ng_next
control|)
block|{
if|if
condition|(
name|ngp
operator|->
name|ng_state
operator|!=
name|EMPTY
condition|)
continue|continue;
name|ngp
operator|->
name|ng_state
operator|=
name|UNACQUIRED
expr_stmt|;
name|ngp
operator|->
name|ng_myaddr
operator|=
name|inet_addr
argument_list|(
name|DEFAULTIF
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

