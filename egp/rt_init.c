begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* rt_init.c */
end_comment

begin_comment
comment|/* EGP User Process, ISI 23-Jun-84 */
end_comment

begin_comment
comment|/* rt_init(), rt_readkernel(), rt_ifinit(), rt_dumbinit(fp),  * rt_NRadvise_init()  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_comment
comment|/* route.h */
end_comment

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|KERNEL
value|1
end_define

begin_comment
comment|/* to ensure all<net/route.h> compiled */
end_comment

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_comment
comment|/* definitions from routed */
end_comment

begin_include
include|#
directive|include
file|"trace_egp.h"
end_include

begin_include
include|#
directive|include
file|"if.h"
end_include

begin_include
include|#
directive|include
file|"rt_table.h"
end_include

begin_comment
comment|/* new definitions */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_comment
comment|/* rt_init() initializes exterior and interior routing tables.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|rthash
name|nethash
index|[]
decl_stmt|,
name|rt_interior
decl_stmt|;
end_decl_stmt

begin_macro
name|rt_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|rthash
modifier|*
name|rh
decl_stmt|;
for|for
control|(
name|rh
operator|=
name|nethash
init|;
name|rh
operator|<
operator|&
name|nethash
index|[
name|ROUTEHASHSIZ
index|]
condition|;
name|rh
operator|++
control|)
comment|/* interior */
name|rh
operator|->
name|rt_forw
operator|=
name|rh
operator|->
name|rt_back
operator|=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
name|rh
expr_stmt|;
name|rt_interior
operator|.
name|rt_forw
operator|=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
operator|&
name|rt_interior
expr_stmt|;
comment|/* exterior */
name|rt_interior
operator|.
name|rt_back
operator|=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
operator|&
name|rt_interior
expr_stmt|;
block|}
end_block

begin_comment
comment|/* rt_readkernel() initializes the EGP routing tables from the current kernel  * routing tables through /dev/kmem.  * This is necessary to ensure consistency when the EGP process is terminated  * and restarted while the supporting host continues to run. This may be done  * if configuration information needs to be changed.  */
end_comment

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
define|#
directive|define
name|N_RTHOST
value|0
block|{
literal|"_rthost"
block|}
block|,
define|#
directive|define
name|N_RTNET
value|1
block|{
literal|"_rtnet"
block|}
block|,
block|{
literal|""
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_macro
name|rt_readkernel
argument_list|()
end_macro

begin_block
block|{
name|int
name|oldinstall
decl_stmt|;
comment|/* Defined in<net/route.h>  *  *	struct mbuf *rtnet[RTHASHSIZ];  */
specifier|extern
name|int
name|install
decl_stmt|;
comment|/* if TRUE install route in kernel */
comment|/*  ..routed/table.h redefines some of the elements of   * struct rtentry defined in<net/route.h>. In order for the code from routed  * to be able to be utilized part of the kernel structure has been redefined   * with a preceding k_.    */
struct|struct
name|k_rtentry
block|{
name|u_long
name|k_rt_hash
decl_stmt|;
comment|/* to speed lookups */
name|struct
name|sockaddr
name|k_rt_dst
decl_stmt|;
comment|/* key */
name|struct
name|sockaddr
name|k_rt_gateway
decl_stmt|;
comment|/* value */
name|short
name|k_rt_flags
decl_stmt|;
comment|/* up/down?, host/net */
block|}
modifier|*
name|rt
struct|;
name|int
name|i
decl_stmt|,
name|kmem
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|,
name|m_buf
decl_stmt|;
name|nlist
argument_list|(
literal|"/vmunix"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nl
index|[
name|N_RTHOST
index|]
operator|.
name|n_value
operator|==
literal|0
operator|)
operator|||
operator|(
name|nl
index|[
name|N_RTNET
index|]
operator|.
name|n_value
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"rt_readkernel: rthost and rtnet not in namelist\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
name|kmem
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmem
operator|<
literal|0
condition|)
block|{
name|p_error
argument_list|(
literal|"rt_readkernel: /dev/kmem"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
comment|/* read table of net hash chains */
if|if
condition|(
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|N_RTNET
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rtnet
argument_list|,
sizeof|sizeof
argument_list|(
name|rtnet
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|rtnet
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rt_readkernel: error reading kmem\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
comment|/* read all routing entries of each network hash chain */
name|TRACE_RT
argument_list|(
literal|"rt_readkernel: Initial indirect routes read from kernel"
argument_list|)
expr_stmt|;
name|TRACE_RT
argument_list|(
literal|" (if any):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RTHASHSIZ
condition|;
name|i
operator|++
control|)
block|{
comment|/* Read each route entry from net hash 					 * chain i and copy into EGP route  					 * table, the chain is  					 * terminated by a null pointer */
for|for
control|(
name|next
operator|=
name|rtnet
index|[
name|i
index|]
init|;
name|next
operator|!=
name|NULL
condition|;
name|next
operator|=
name|m_buf
operator|.
name|m_next
control|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|next
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|m_buf
argument_list|,
name|MMINOFF
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|k_rtentry
argument_list|)
argument_list|)
operator|!=
name|MMINOFF
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|k_rtentry
argument_list|)
condition|)
block|{
name|p_error
argument_list|(
literal|"rt_readkernel: read"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
name|rt
operator|=
name|mtod
argument_list|(
operator|&
name|m_buf
argument_list|,
expr|struct
name|k_rtentry
operator|*
argument_list|)
expr_stmt|;
comment|/* ignore direct routes */
if|if
condition|(
operator|!
operator|(
name|rt
operator|->
name|k_rt_flags
operator|&
name|RTF_GATEWAY
operator|)
condition|)
continue|continue;
comment|/* ignore non-internet addresses */
if|if
condition|(
name|rt
operator|->
name|k_rt_gateway
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
comment|/* add route to table of exterior 					 * routes, if the route is in fact an 					 * interior route it will be deleted 					 * by rt_dumbinit() */
name|oldinstall
operator|=
name|install
expr_stmt|;
name|install
operator|=
name|FALSE
expr_stmt|;
comment|/* don't install routes in kernel */
comment|/* metric unknown - set largest reachable */
name|rt_add
argument_list|(
name|EXTERIOR
argument_list|,
operator|&
name|rt
operator|->
name|k_rt_dst
argument_list|,
operator|&
name|rt
operator|->
name|k_rt_gateway
argument_list|,
name|HOPCNT_INFINITY
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|install
operator|=
name|oldinstall
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|kmem
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* rt_ifinit() initializes the interior routing table with direct nets as  * per the interface table.  *  * External variables:  *	rt_interior - start interior routes linked list  *	ifnet - start interface table  *	install - if FALSE don't install routes in kernel  */
end_comment

begin_macro
name|rt_ifinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|interface
modifier|*
name|ifp
decl_stmt|;
name|int
name|oldinstall
init|=
name|install
decl_stmt|;
comment|/* Add direct nets to interior route table as per interface list */
name|install
operator|=
name|FALSE
expr_stmt|;
comment|/* routes for interfaces already 					 * installed by kernel */
name|TRACE_RT
argument_list|(
literal|"rt_ifinit: interior routes for direct interfaces:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
operator|!=
name|NULL
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|int_next
control|)
block|{
name|rt_add
argument_list|(
name|INTERIOR
argument_list|,
operator|&
name|ifp
operator|->
name|int_addr
argument_list|,
operator|&
name|ifp
operator|->
name|int_addr
argument_list|,
literal|0
argument_list|,
name|RTS_INTERFACE
argument_list|)
expr_stmt|;
block|}
name|install
operator|=
name|oldinstall
expr_stmt|;
block|}
end_block

begin_comment
comment|/* rt_dumbinit() reads the initialization file EGPINITFILE to  * initialize:   * - the interior route table with routes to known non-routing gateways on a  * shared net, these routes are static and not updated;  * - a default gateway prior to an EGP neighbor being acquired and polled;  *  * EGPINITFILE relevant format is:  * net name gateway name metric value  * defaultgateway name  *  * where name is either a symbolic name in /etc/hosts or /etc/networks or an  * internet address in dot notation and value is the distance in gateway hops  * from this gateway to the specified net.  *  * External variables:  *	rt_interior - start interior routes linked list  *	n_remote_nets - number remote nets in interior route table, set here  *	install - if TRUE install routes in kernel  *	s - socket for ioctl  *	rt_default_status - default route status  */
end_comment

begin_macro
name|rt_dumbinit
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|keyword
index|[
name|MAXHOSTNAMELENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|netname
index|[
name|MAXHOSTNAMELENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|gname
index|[
name|MAXHOSTNAMELENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|netaddr
decl_stmt|,
name|gateway
decl_stmt|,
name|defaultdst
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|int
name|metric
decl_stmt|,
name|c
decl_stmt|,
name|error
init|=
name|FALSE
decl_stmt|,
name|old_install
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|netaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|netaddr
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|gateway
argument_list|,
sizeof|sizeof
argument_list|(
name|gateway
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|defaultdst
argument_list|,
sizeof|sizeof
argument_list|(
name|defaultdst
argument_list|)
argument_list|)
expr_stmt|;
name|TRACE_RT
argument_list|(
literal|"rt_dumbinit: non-routing gateway routes (if any):\n"
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|keyword
argument_list|)
operator|!=
name|EOF
condition|)
block|{
comment|/* read first word of line 						   and compare to key words */
if|if
condition|(
name|strcmp
argument_list|(
name|keyword
argument_list|,
literal|"net"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s gateway %s metric %d"
argument_list|,
name|netname
argument_list|,
name|gname
argument_list|,
operator|&
name|metric
argument_list|)
operator|!=
literal|3
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|getnetorhostname
argument_list|(
literal|"net"
argument_list|,
name|netname
argument_list|,
operator|&
name|netaddr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rt_dumbinit: invalid net name or"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" address %s\n"
argument_list|,
name|netname
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|getnetorhostname
argument_list|(
literal|"host"
argument_list|,
name|gname
argument_list|,
operator|&
name|gateway
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rt_dumbinit: invalid gateway name or"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" address %s\n"
argument_list|,
name|gname
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Initialize routings tables with 				 * non-routing gateway */
name|n_remote_nets
operator|++
expr_stmt|;
comment|/* first delete any old route in exterior  				 * route table read from kernel. 				 */
name|old_install
operator|=
name|install
expr_stmt|;
name|rt
operator|=
name|rt_ext_lookup
argument_list|(
operator|&
name|netaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|equal
argument_list|(
operator|&
name|rt
operator|->
name|rt_router
argument_list|,
operator|&
name|gateway
argument_list|)
condition|)
name|install
operator|=
name|FALSE
expr_stmt|;
comment|/* already in kernel*/
name|rt_delete
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|notdef
comment|/* don't install, we route through a different interface */
name|install
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* add to interior routing table */
name|rt_add
argument_list|(
name|INTERIOR
argument_list|,
operator|&
name|netaddr
argument_list|,
operator|&
name|gateway
argument_list|,
name|metric
argument_list|,
name|RTS_PASSIVE
argument_list|)
expr_stmt|;
name|install
operator|=
name|old_install
expr_stmt|;
block|}
block|}
comment|/* end "net" entry */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyword
argument_list|,
literal|"defaultgateway"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|gname
argument_list|)
operator|!=
literal|1
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|getnetorhostname
argument_list|(
literal|"host"
argument_list|,
name|gname
argument_list|,
operator|&
name|gateway
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rt_dumbinit: invalid gateway name or"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" address %s\n"
argument_list|,
name|gname
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Initialize default gateway */
comment|/* check if a kernel entry exists for default 				 * route, if not add new default else change  				 * to new default */
name|defaultdst
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|defaultdst
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|DEFAULTNET
expr_stmt|;
name|metric
operator|=
name|HOPCNT_INFINITY
operator|-
literal|1
expr_stmt|;
name|rt
operator|=
name|rt_ext_lookup
argument_list|(
operator|&
name|defaultdst
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
name|rt_add
argument_list|(
name|EXTERIOR
argument_list|,
operator|&
name|defaultdst
argument_list|,
operator|&
name|gateway
argument_list|,
name|metric
argument_list|,
name|RTS_PASSIVE
argument_list|)
expr_stmt|;
else|else
block|{
name|rt_change
argument_list|(
name|rt
argument_list|,
operator|&
name|gateway
argument_list|,
name|metric
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_state
operator||=
name|RTS_PASSIVE
expr_stmt|;
block|}
name|rt_default_status
operator|=
name|INSTALLED
expr_stmt|;
block|}
block|}
comment|/* end "defaultgateway" entry */
do|do
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
comment|/* next line */
block|}
comment|/*end while*/
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"rt_dumbinit: %s: initialization error\n"
argument_list|,
name|EGPINITFILE
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
name|TRACE_RT
argument_list|(
literal|"rt_dumbinit: commence EGP route updates:\n\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* rt_NRadvise_init() reads the initialization file EGPINITFILE to  * initialize user specified nets to be advised in Network Reachability  * messages. If any such nets are specified, only those specified are advised,  * else the nets to be specified are computed in accord with normal stub   * gateway NR messages. Any such nets should be either direct nets or nets  * reached via non-routing gateways reported in EGPINITFILE, if the net  * is not one of these it is ignored.  *  * EGPINITFILE relevant format is:  * egpnetsreachable name name .... name  *  * External variables:  *	rt_interior - start interior routes linked list  */
end_comment

begin_macro
name|rt_NRadvise_init
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|keyword
index|[
name|MAXHOSTNAMELENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|netname
index|[
name|MAXHOSTNAMELENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|netaddr
decl_stmt|;
name|struct
name|rt_entry
modifier|*
name|rt
decl_stmt|;
name|int
name|notadvise_set
init|=
name|FALSE
decl_stmt|,
name|c
decl_stmt|,
name|error
init|=
name|FALSE
decl_stmt|,
name|morenets
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|netaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|netaddr
argument_list|)
argument_list|)
expr_stmt|;
name|netaddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* read first word of line and compare to key words */
while|while
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|keyword
argument_list|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|keyword
argument_list|,
literal|"egpnetsreachable"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* initially flag all interior routes as not 				 * to be advised in NR messages, this is only  				 * done for first occurrence of  				 * "egpnetsreachable" */
if|if
condition|(
operator|!
name|notadvise_set
condition|)
block|{
for|for
control|(
name|rt
operator|=
name|rt_interior
operator|.
name|rt_forw
init|;
name|rt
operator|!=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
operator|&
name|rt_interior
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_forw
control|)
name|rt
operator|->
name|rt_state
operator||=
name|RTS_NOTADVISENR
expr_stmt|;
name|notadvise_set
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* read successive net strings into destination until end of line */
name|morenets
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|morenets
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* end line read below */
case|case
literal|'#'
case|:
comment|/* start comment */
name|morenets
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
break|break;
comment|/* next character */
default|default:
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|netname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getnetorhostname
argument_list|(
literal|"net"
argument_list|,
name|netname
argument_list|,
operator|&
name|netaddr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rt_NRadvise_init: invalid net name "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"or address %s\n"
argument_list|,
name|netname
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* search interior route table for net and 				 * set to be advised in NR messages */
for|for
control|(
name|rt
operator|=
name|rt_interior
operator|.
name|rt_forw
init|;
name|rt
operator|!=
operator|(
expr|struct
name|rt_entry
operator|*
operator|)
operator|&
name|rt_interior
condition|;
name|rt
operator|=
name|rt
operator|->
name|rt_forw
control|)
if|if
condition|(
name|equal
argument_list|(
operator|&
name|rt
operator|->
name|rt_dst
argument_list|,
operator|&
name|netaddr
argument_list|)
condition|)
block|{
name|rt
operator|->
name|rt_state
operator|&=
operator|~
name|RTS_NOTADVISENR
expr_stmt|;
name|printf
argument_list|(
literal|"advise %s, "
argument_list|,
name|inet_ntoa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_dst
operator|)
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"gateway %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rt
operator|->
name|rt_router
operator|)
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* end switch c */
block|}
comment|/* end while morenets */
block|}
comment|/* end if "egpnetsreachable" */
do|do
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
comment|/* next line */
block|}
comment|/*end while*/
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"rt_NRadvise_init: %s: initialization error\n"
argument_list|,
name|EGPINITFILE
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
block|}
end_block

end_unit

