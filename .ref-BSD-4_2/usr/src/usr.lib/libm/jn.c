begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	@(#)jn.c	4.1	12/25/82	*/
end_comment

begin_comment
comment|/* 	floating point Bessel's function of 	the first and second kinds and of 	integer order.  	int n; 	double x; 	jn(n,x);  	returns the value of Jn(x) for all 	integer values of n and all real values 	of x.  	There are no error returns. 	Calls j0, j1.  	For n=0, j0(x) is called, 	for n=1, j1(x) is called, 	for n<x, forward recursion us used starting 	from values of j0(x) and j1(x). 	for n>x, a continued fraction approximation to 	j(n,x)/j(n-1,x) is evaluated and then backward 	recursion is used starting from a supposed value 	for j(n,x). The resulting value of j(0,x) is 	compared with the actual value to correct the 	supposed value of j(n,x).  	yn(n,x) is similar in all respects, except 	that forward recursion is used for all 	values of n>1. */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|jn
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
name|int
name|n
decl_stmt|;
name|double
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|double
name|a
decl_stmt|,
name|b
decl_stmt|,
name|temp
decl_stmt|;
name|double
name|xsq
decl_stmt|,
name|t
decl_stmt|;
name|double
name|j0
argument_list|()
decl_stmt|,
name|j1
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|j0
argument_list|(
name|x
argument_list|)
operator|)
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
operator|(
name|j1
argument_list|(
name|x
argument_list|)
operator|)
return|;
if|if
condition|(
name|x
operator|==
literal|0.
condition|)
return|return
operator|(
literal|0.
operator|)
return|;
if|if
condition|(
name|n
operator|>
name|x
condition|)
goto|goto
name|recurs
goto|;
name|a
operator|=
name|j0
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|b
operator|=
name|j1
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|b
expr_stmt|;
name|b
operator|=
operator|(
literal|2.
operator|*
name|i
operator|/
name|x
operator|)
operator|*
name|b
operator|-
name|a
expr_stmt|;
name|a
operator|=
name|temp
expr_stmt|;
block|}
return|return
operator|(
name|b
operator|)
return|;
name|recurs
label|:
name|xsq
operator|=
name|x
operator|*
name|x
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
operator|,
name|i
operator|=
name|n
operator|+
literal|16
init|;
name|i
operator|>
name|n
condition|;
name|i
operator|--
control|)
block|{
name|t
operator|=
name|xsq
operator|/
operator|(
literal|2.
operator|*
name|i
operator|-
name|t
operator|)
expr_stmt|;
block|}
name|t
operator|=
name|x
operator|/
operator|(
literal|2.
operator|*
name|n
operator|-
name|t
operator|)
expr_stmt|;
name|a
operator|=
name|t
expr_stmt|;
name|b
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|temp
operator|=
name|b
expr_stmt|;
name|b
operator|=
operator|(
literal|2.
operator|*
name|i
operator|/
name|x
operator|)
operator|*
name|b
operator|-
name|a
expr_stmt|;
name|a
operator|=
name|temp
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|*
name|j0
argument_list|(
name|x
argument_list|)
operator|/
name|b
operator|)
return|;
block|}
end_function

begin_function
name|double
name|yn
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
name|int
name|n
decl_stmt|;
name|double
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|double
name|a
decl_stmt|,
name|b
decl_stmt|,
name|temp
decl_stmt|;
name|double
name|y0
argument_list|()
decl_stmt|,
name|y1
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
block|{
name|errno
operator|=
name|EDOM
expr_stmt|;
return|return
operator|(
operator|-
name|HUGE
operator|)
return|;
block|}
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|2
operator|==
literal|1
condition|)
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|y0
argument_list|(
name|x
argument_list|)
operator|)
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
operator|(
name|sign
operator|*
name|y1
argument_list|(
name|x
argument_list|)
operator|)
return|;
name|a
operator|=
name|y0
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|b
operator|=
name|y1
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|b
expr_stmt|;
name|b
operator|=
operator|(
literal|2.
operator|*
name|i
operator|/
name|x
operator|)
operator|*
name|b
operator|-
name|a
expr_stmt|;
name|a
operator|=
name|temp
expr_stmt|;
block|}
return|return
operator|(
name|sign
operator|*
name|b
operator|)
return|;
block|}
end_function

end_unit

