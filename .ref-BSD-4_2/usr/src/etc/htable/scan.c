begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_define
define|#
directive|define
name|U
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_define
define|#
directive|define
name|NLSTATE
value|yyprevious=YYNEWLINE
end_define

begin_define
define|#
directive|define
name|BEGIN
value|yybgin = yysvec + 1 +
end_define

begin_define
define|#
directive|define
name|INITIAL
value|0
end_define

begin_define
define|#
directive|define
name|YYLERR
value|yysvec
end_define

begin_define
define|#
directive|define
name|YYSTATE
value|(yyestate-yysvec-1)
end_define

begin_define
define|#
directive|define
name|YYOPTIM
value|1
end_define

begin_define
define|#
directive|define
name|YYLMAX
value|200
end_define

begin_define
define|#
directive|define
name|output
parameter_list|(
name|c
parameter_list|)
value|putc(c,yyout)
end_define

begin_define
define|#
directive|define
name|input
parameter_list|()
value|(((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==10?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)
end_define

begin_define
define|#
directive|define
name|unput
parameter_list|(
name|c
parameter_list|)
value|{yytchar= (c);if(yytchar=='\n')yylineno--;*yysptr++=yytchar;}
end_define

begin_define
define|#
directive|define
name|yymore
parameter_list|()
value|(yymorfg=1)
end_define

begin_define
define|#
directive|define
name|ECHO
value|fprintf(yyout, "%s",yytext)
end_define

begin_define
define|#
directive|define
name|REJECT
value|{ nstr = yyreject(); goto yyfussy;}
end_define

begin_decl_stmt
name|int
name|yyleng
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|yytext
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yymorfg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|yysptr
decl_stmt|,
name|yysbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yytchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|yyin
init|=
block|{
name|stdin
block|}
decl_stmt|,
modifier|*
name|yyout
init|=
block|{
name|stdout
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|yylineno
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|yysvf
block|{
name|struct
name|yywork
modifier|*
name|yystoff
decl_stmt|;
name|struct
name|yysvf
modifier|*
name|yyother
decl_stmt|;
name|int
modifier|*
name|yystops
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|yysvf
modifier|*
name|yyestate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|yysvf
name|yysvec
index|[]
decl_stmt|,
modifier|*
name|yybgin
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)scan.l	4.1 (Berkeley) 10/20/82"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_include
include|#
directive|include
file|"htable.h"
end_include

begin_define
define|#
directive|define
name|YYNEWLINE
value|10
end_define

begin_macro
name|yylex
argument_list|()
end_macro

begin_block
block|{
name|int
name|nstr
decl_stmt|;
specifier|extern
name|int
name|yyprevious
decl_stmt|;
while|while
condition|(
operator|(
name|nstr
operator|=
name|yylook
argument_list|()
operator|)
operator|>=
literal|0
condition|)
name|yyfussy
label|:
switch|switch
condition|(
name|nstr
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|yywrap
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|1
case|:
block|{
name|yylval
operator|.
name|number
operator|=
name|KW_NET
expr_stmt|;
return|return
operator|(
name|KEYWORD
operator|)
return|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|yylval
operator|.
name|number
operator|=
name|KW_GATEWAY
expr_stmt|;
return|return
operator|(
name|KEYWORD
operator|)
return|;
block|}
break|break;
case|case
literal|3
case|:
block|{
name|yylval
operator|.
name|number
operator|=
name|KW_HOST
expr_stmt|;
return|return
operator|(
name|KEYWORD
operator|)
return|;
block|}
break|break;
case|case
literal|4
case|:
block|{
name|yylval
operator|.
name|namelist
operator|=
name|newname
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
return|return
operator|(
name|NAME
operator|)
return|;
block|}
break|break;
case|case
literal|5
case|:
return|return
operator|(
name|NAME
operator|)
return|;
break|break;
case|case
literal|6
case|:
block|{
name|yylval
operator|.
name|number
operator|=
name|atoi
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
return|return
operator|(
name|NUMBER
operator|)
return|;
block|}
break|break;
case|case
literal|7
case|:
return|return
operator|(
literal|'.'
operator|)
return|;
break|break;
case|case
literal|8
case|:
return|return
operator|(
literal|':'
operator|)
return|;
break|break;
case|case
literal|9
case|:
return|return
operator|(
literal|','
operator|)
return|;
break|break;
case|case
literal|10
case|:
return|return
operator|(
literal|'/'
operator|)
return|;
break|break;
case|case
literal|11
case|:
empty_stmt|;
break|break;
case|case
literal|12
case|:
empty_stmt|;
break|break;
case|case
literal|13
case|:
empty_stmt|;
break|break;
case|case
literal|14
case|:
return|return
operator|(
name|END
operator|)
return|;
break|break;
case|case
literal|15
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Illegal char: '%s'\n"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
break|break;
default|default:
name|fprintf
argument_list|(
name|yyout
argument_list|,
literal|"bad switch yylook %d"
argument_list|,
name|nstr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end of yylex */
end_comment

begin_macro
name|yywrap
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|yyvstop
index|[]
init|=
block|{
literal|0
block|,
literal|15
block|,
literal|0
block|,
literal|13
block|,
literal|15
block|,
literal|0
block|,
literal|14
block|,
literal|0
block|,
literal|9
block|,
literal|15
block|,
literal|0
block|,
literal|7
block|,
literal|15
block|,
literal|0
block|,
literal|10
block|,
literal|15
block|,
literal|0
block|,
literal|6
block|,
literal|15
block|,
literal|0
block|,
literal|8
block|,
literal|15
block|,
literal|0
block|,
literal|11
block|,
literal|15
block|,
literal|0
block|,
literal|5
block|,
literal|15
block|,
literal|0
block|,
literal|5
block|,
literal|15
block|,
literal|0
block|,
literal|5
block|,
literal|15
block|,
literal|0
block|,
literal|5
block|,
literal|15
block|,
literal|0
block|,
literal|13
block|,
literal|0
block|,
literal|12
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|,
literal|11
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYTYPE
value|char
end_define

begin_struct
struct|struct
name|yywork
block|{
name|YYTYPE
name|verify
decl_stmt|,
name|advance
decl_stmt|;
block|}
name|yycrank
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|11
block|,
literal|19
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|4
block|,
literal|1
block|,
literal|5
block|,
literal|4
block|,
literal|16
block|,
literal|5
block|,
literal|17
block|,
literal|0
block|,
literal|0
block|,
literal|11
block|,
literal|19
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|19
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|16
block|,
literal|5
block|,
literal|17
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|6
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|7
block|,
literal|1
block|,
literal|8
block|,
literal|1
block|,
literal|9
block|,
literal|2
block|,
literal|6
block|,
literal|11
block|,
literal|19
block|,
literal|2
block|,
literal|7
block|,
literal|2
block|,
literal|8
block|,
literal|11
block|,
literal|19
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|10
block|,
literal|1
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|10
block|,
literal|2
block|,
literal|11
block|,
literal|1
block|,
literal|12
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|11
block|,
literal|19
block|,
literal|1
block|,
literal|13
block|,
literal|1
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|1
block|,
literal|15
block|,
literal|13
block|,
literal|22
block|,
literal|30
block|,
literal|31
block|,
literal|0
block|,
literal|0
block|,
literal|15
block|,
literal|24
block|,
literal|2
block|,
literal|15
block|,
literal|9
block|,
literal|18
block|,
literal|9
block|,
literal|18
block|,
literal|9
block|,
literal|18
block|,
literal|9
block|,
literal|18
block|,
literal|9
block|,
literal|18
block|,
literal|9
block|,
literal|18
block|,
literal|9
block|,
literal|18
block|,
literal|9
block|,
literal|18
block|,
literal|9
block|,
literal|18
block|,
literal|9
block|,
literal|18
block|,
literal|12
block|,
literal|20
block|,
literal|12
block|,
literal|20
block|,
literal|12
block|,
literal|20
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|14
block|,
literal|23
block|,
literal|22
block|,
literal|25
block|,
literal|23
block|,
literal|26
block|,
literal|24
block|,
literal|27
block|,
literal|25
block|,
literal|28
block|,
literal|26
block|,
literal|29
block|,
literal|28
block|,
literal|30
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|12
block|,
literal|21
block|,
literal|31
block|,
literal|32
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|yysvf
name|yysvec
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|yycrank
operator|+
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|yycrank
operator|+
operator|-
literal|6
block|,
name|yysvec
operator|+
literal|1
block|,
literal|0
block|,
name|yycrank
operator|+
literal|0
block|,
literal|0
block|,
name|yyvstop
operator|+
literal|1
block|,
name|yycrank
operator|+
literal|3
block|,
literal|0
block|,
name|yyvstop
operator|+
literal|3
block|,
name|yycrank
operator|+
literal|4
block|,
literal|0
block|,
name|yyvstop
operator|+
literal|6
block|,
name|yycrank
operator|+
literal|0
block|,
literal|0
block|,
name|yyvstop
operator|+
literal|8
block|,
name|yycrank
operator|+
literal|0
block|,
literal|0
block|,
name|yyvstop
operator|+
literal|11
block|,
name|yycrank
operator|+
literal|0
block|,
literal|0
block|,
name|yyvstop
operator|+
literal|14
block|,
name|yycrank
operator|+
literal|37
block|,
literal|0
block|,
name|yyvstop
operator|+
literal|17
block|,
name|yycrank
operator|+
literal|0
block|,
literal|0
block|,
name|yyvstop
operator|+
literal|20
block|,
name|yycrank
operator|+
operator|-
literal|6
block|,
literal|0
block|,
name|yyvstop
operator|+
literal|23
block|,
name|yycrank
operator|+
literal|50
block|,
literal|0
block|,
name|yyvstop
operator|+
literal|26
block|,
name|yycrank
operator|+
literal|15
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|29
block|,
name|yycrank
operator|+
literal|29
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|32
block|,
name|yycrank
operator|+
literal|14
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|35
block|,
name|yycrank
operator|+
literal|0
block|,
name|yysvec
operator|+
literal|4
block|,
name|yyvstop
operator|+
literal|38
block|,
name|yycrank
operator|+
literal|0
block|,
name|yysvec
operator|+
literal|5
block|,
name|yyvstop
operator|+
literal|40
block|,
name|yycrank
operator|+
literal|0
block|,
name|yysvec
operator|+
literal|9
block|,
name|yyvstop
operator|+
literal|42
block|,
name|yycrank
operator|+
operator|-
literal|14
block|,
name|yysvec
operator|+
literal|11
block|,
name|yyvstop
operator|+
literal|44
block|,
name|yycrank
operator|+
literal|0
block|,
name|yysvec
operator|+
literal|12
block|,
literal|0
block|,
name|yycrank
operator|+
literal|0
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|46
block|,
name|yycrank
operator|+
literal|25
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|48
block|,
name|yycrank
operator|+
literal|27
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|50
block|,
name|yycrank
operator|+
literal|27
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|52
block|,
name|yycrank
operator|+
literal|43
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|54
block|,
name|yycrank
operator|+
literal|29
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|56
block|,
name|yycrank
operator|+
literal|0
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|58
block|,
name|yycrank
operator|+
literal|27
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|61
block|,
name|yycrank
operator|+
literal|0
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|63
block|,
name|yycrank
operator|+
literal|16
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|66
block|,
name|yycrank
operator|+
literal|52
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|68
block|,
name|yycrank
operator|+
literal|0
block|,
name|yysvec
operator|+
literal|12
block|,
name|yyvstop
operator|+
literal|70
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|yywork
modifier|*
name|yytop
init|=
name|yycrank
operator|+
literal|141
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|yysvf
modifier|*
name|yybgin
init|=
name|yysvec
operator|+
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|yymatch
index|[]
init|=
block|{
literal|00
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|011
block|,
literal|012
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|011
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|'-'
block|,
literal|'-'
block|,
literal|'-'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|'A'
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|01
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|yyextra
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	ncform	4.1	83/08/11	*/
end_comment

begin_decl_stmt
name|int
name|yylineno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYU
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_define
define|#
directive|define
name|NLSTATE
value|yyprevious=YYNEWLINE
end_define

begin_decl_stmt
name|char
name|yytext
index|[
name|YYLMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|yysvf
modifier|*
name|yylstate
index|[
name|YYLMAX
index|]
decl_stmt|,
modifier|*
modifier|*
name|yylsp
decl_stmt|,
modifier|*
modifier|*
name|yyolsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|yysbuf
index|[
name|YYLMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yysptr
init|=
name|yysbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|yyfnd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|yysvf
modifier|*
name|yyestate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yyprevious
init|=
name|YYNEWLINE
decl_stmt|;
end_decl_stmt

begin_macro
name|yylook
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|yysvf
modifier|*
name|yystate
decl_stmt|,
modifier|*
modifier|*
name|lsp
decl_stmt|;
specifier|register
name|struct
name|yywork
modifier|*
name|yyt
decl_stmt|;
name|struct
name|yysvf
modifier|*
name|yyz
decl_stmt|;
name|int
name|yych
decl_stmt|;
name|struct
name|yywork
modifier|*
name|yyr
decl_stmt|;
ifdef|#
directive|ifdef
name|LEXDEBUG
name|int
name|debug
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|yylastch
decl_stmt|;
comment|/* start off machines */
ifdef|#
directive|ifdef
name|LEXDEBUG
name|debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|yymorfg
condition|)
name|yylastch
operator|=
name|yytext
expr_stmt|;
else|else
block|{
name|yymorfg
operator|=
literal|0
expr_stmt|;
name|yylastch
operator|=
name|yytext
operator|+
name|yyleng
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|lsp
operator|=
name|yylstate
expr_stmt|;
name|yyestate
operator|=
name|yystate
operator|=
name|yybgin
expr_stmt|;
if|if
condition|(
name|yyprevious
operator|==
name|YYNEWLINE
condition|)
name|yystate
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|LEXDEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|yyout
argument_list|,
literal|"state %d\n"
argument_list|,
name|yystate
operator|-
name|yysvec
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yyt
operator|=
name|yystate
operator|->
name|yystoff
expr_stmt|;
if|if
condition|(
name|yyt
operator|==
name|yycrank
condition|)
block|{
comment|/* may not be any transitions */
name|yyz
operator|=
name|yystate
operator|->
name|yyother
expr_stmt|;
if|if
condition|(
name|yyz
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|yyz
operator|->
name|yystoff
operator|==
name|yycrank
condition|)
break|break;
block|}
operator|*
name|yylastch
operator|++
operator|=
name|yych
operator|=
name|input
argument_list|()
expr_stmt|;
name|tryagain
label|:
ifdef|#
directive|ifdef
name|LEXDEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|yyout
argument_list|,
literal|"char "
argument_list|)
expr_stmt|;
name|allprint
argument_list|(
name|yych
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|yyr
operator|=
name|yyt
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|yyt
operator|>
operator|(
name|int
operator|)
name|yycrank
condition|)
block|{
name|yyt
operator|=
name|yyr
operator|+
name|yych
expr_stmt|;
if|if
condition|(
name|yyt
operator|<=
name|yytop
operator|&&
name|yyt
operator|->
name|verify
operator|+
name|yysvec
operator|==
name|yystate
condition|)
block|{
if|if
condition|(
name|yyt
operator|->
name|advance
operator|+
name|yysvec
operator|==
name|YYLERR
condition|)
comment|/* error transitions */
block|{
name|unput
argument_list|(
operator|*
operator|--
name|yylastch
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|lsp
operator|++
operator|=
name|yystate
operator|=
name|yyt
operator|->
name|advance
operator|+
name|yysvec
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|YYOPTIM
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|yyt
operator|<
operator|(
name|int
operator|)
name|yycrank
condition|)
block|{
comment|/* r< yycrank */
name|yyt
operator|=
name|yyr
operator|=
name|yycrank
operator|+
operator|(
name|yycrank
operator|-
name|yyt
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEXDEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|yyout
argument_list|,
literal|"compressed state\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yyt
operator|=
name|yyt
operator|+
name|yych
expr_stmt|;
if|if
condition|(
name|yyt
operator|<=
name|yytop
operator|&&
name|yyt
operator|->
name|verify
operator|+
name|yysvec
operator|==
name|yystate
condition|)
block|{
if|if
condition|(
name|yyt
operator|->
name|advance
operator|+
name|yysvec
operator|==
name|YYLERR
condition|)
comment|/* error transitions */
block|{
name|unput
argument_list|(
operator|*
operator|--
name|yylastch
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|lsp
operator|++
operator|=
name|yystate
operator|=
name|yyt
operator|->
name|advance
operator|+
name|yysvec
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
name|yyt
operator|=
name|yyr
operator|+
name|YYU
argument_list|(
name|yymatch
index|[
name|yych
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEXDEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|yyout
argument_list|,
literal|"try fall back character "
argument_list|)
expr_stmt|;
name|allprint
argument_list|(
name|YYU
argument_list|(
name|yymatch
index|[
name|yych
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|yyt
operator|<=
name|yytop
operator|&&
name|yyt
operator|->
name|verify
operator|+
name|yysvec
operator|==
name|yystate
condition|)
block|{
if|if
condition|(
name|yyt
operator|->
name|advance
operator|+
name|yysvec
operator|==
name|YYLERR
condition|)
comment|/* error transition */
block|{
name|unput
argument_list|(
operator|*
operator|--
name|yylastch
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|lsp
operator|++
operator|=
name|yystate
operator|=
name|yyt
operator|->
name|advance
operator|+
name|yysvec
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|yystate
operator|=
name|yystate
operator|->
name|yyother
operator|)
operator|&&
operator|(
name|yyt
operator|=
name|yystate
operator|->
name|yystoff
operator|)
operator|!=
name|yycrank
condition|)
block|{
ifdef|#
directive|ifdef
name|LEXDEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|yyout
argument_list|,
literal|"fall back to state %d\n"
argument_list|,
name|yystate
operator|-
name|yysvec
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|tryagain
goto|;
block|}
endif|#
directive|endif
else|else
block|{
name|unput
argument_list|(
operator|*
operator|--
name|yylastch
argument_list|)
expr_stmt|;
break|break;
block|}
name|contin
label|:
ifdef|#
directive|ifdef
name|LEXDEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|yyout
argument_list|,
literal|"state %d char "
argument_list|,
name|yystate
operator|-
name|yysvec
operator|-
literal|1
argument_list|)
expr_stmt|;
name|allprint
argument_list|(
name|yych
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
empty_stmt|;
block|}
ifdef|#
directive|ifdef
name|LEXDEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|yyout
argument_list|,
literal|"stopped at %d with "
argument_list|,
operator|*
operator|(
name|lsp
operator|-
literal|1
operator|)
operator|-
name|yysvec
operator|-
literal|1
argument_list|)
expr_stmt|;
name|allprint
argument_list|(
name|yych
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|lsp
operator|--
operator|>
name|yylstate
condition|)
block|{
operator|*
name|yylastch
operator|--
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|lsp
operator|!=
literal|0
operator|&&
operator|(
name|yyfnd
operator|=
operator|(
operator|*
name|lsp
operator|)
operator|->
name|yystops
operator|)
operator|&&
operator|*
name|yyfnd
operator|>
literal|0
condition|)
block|{
name|yyolsp
operator|=
name|lsp
expr_stmt|;
if|if
condition|(
name|yyextra
index|[
operator|*
name|yyfnd
index|]
condition|)
block|{
comment|/* must backup */
while|while
condition|(
name|yyback
argument_list|(
operator|(
operator|*
name|lsp
operator|)
operator|->
name|yystops
argument_list|,
operator|-
operator|*
name|yyfnd
argument_list|)
operator|!=
literal|1
operator|&&
name|lsp
operator|>
name|yylstate
condition|)
block|{
name|lsp
operator|--
expr_stmt|;
name|unput
argument_list|(
operator|*
name|yylastch
operator|--
argument_list|)
expr_stmt|;
block|}
block|}
name|yyprevious
operator|=
name|YYU
argument_list|(
operator|*
name|yylastch
argument_list|)
expr_stmt|;
name|yylsp
operator|=
name|lsp
expr_stmt|;
name|yyleng
operator|=
name|yylastch
operator|-
name|yytext
operator|+
literal|1
expr_stmt|;
name|yytext
index|[
name|yyleng
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LEXDEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|yyout
argument_list|,
literal|"\nmatch "
argument_list|)
expr_stmt|;
name|sprint
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|yyout
argument_list|,
literal|" action %d\n"
argument_list|,
operator|*
name|yyfnd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|*
name|yyfnd
operator|++
operator|)
return|;
block|}
name|unput
argument_list|(
operator|*
name|yylastch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yytext
index|[
literal|0
index|]
operator|==
literal|0
comment|/*&& feof(yyin) */
condition|)
block|{
name|yysptr
operator|=
name|yysbuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|yyprevious
operator|=
name|yytext
index|[
literal|0
index|]
operator|=
name|input
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyprevious
operator|>
literal|0
condition|)
name|output
argument_list|(
name|yyprevious
argument_list|)
expr_stmt|;
name|yylastch
operator|=
name|yytext
expr_stmt|;
ifdef|#
directive|ifdef
name|LEXDEBUG
if|if
condition|(
name|debug
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_macro
name|yyback
argument_list|(
argument|p
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|m
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* the following are only used in the lex library */
end_comment

begin_macro
name|yyinput
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|input
argument_list|()
operator|)
return|;
block|}
end_block

begin_macro
name|yyoutput
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|output
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|yyunput
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unput
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

