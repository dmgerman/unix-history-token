begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)unctime.c	1.2 (Berkeley) 4/28/83"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"include.4.1/sys/types.h"
end_include

begin_include
include|#
directive|include
file|"include.4.1/time.h"
end_include

begin_comment
comment|/*  * Convert a ctime(3) format string into a system format date.  * Return the date thus calculated.  *  * Return -1 if the string is not in ctime format.  */
end_comment

begin_comment
comment|/*  * Offsets into the ctime string to various parts.  */
end_comment

begin_define
define|#
directive|define
name|E_MONTH
value|4
end_define

begin_define
define|#
directive|define
name|E_DAY
value|8
end_define

begin_define
define|#
directive|define
name|E_HOUR
value|11
end_define

begin_define
define|#
directive|define
name|E_MINUTE
value|14
end_define

begin_define
define|#
directive|define
name|E_SECOND
value|17
end_define

begin_define
define|#
directive|define
name|E_YEAR
value|20
end_define

begin_function
name|time_t
name|unctime
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|tm
name|then
decl_stmt|;
name|char
name|dbuf
index|[
literal|30
index|]
decl_stmt|;
name|time_t
name|emitl
parameter_list|()
function_decl|;
if|if
condition|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|!=
literal|25
condition|)
name|str
index|[
literal|25
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|dbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|dbuf
index|[
name|E_MONTH
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|then
operator|.
name|tm_mon
operator|=
name|lookup
argument_list|(
operator|&
name|dbuf
index|[
name|E_MONTH
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
empty_stmt|;
name|then
operator|.
name|tm_mday
operator|=
name|atoi
argument_list|(
operator|&
name|dbuf
index|[
name|E_DAY
index|]
argument_list|)
expr_stmt|;
name|then
operator|.
name|tm_hour
operator|=
name|atoi
argument_list|(
operator|&
name|dbuf
index|[
name|E_HOUR
index|]
argument_list|)
expr_stmt|;
name|then
operator|.
name|tm_min
operator|=
name|atoi
argument_list|(
operator|&
name|dbuf
index|[
name|E_MINUTE
index|]
argument_list|)
expr_stmt|;
name|then
operator|.
name|tm_sec
operator|=
name|atoi
argument_list|(
operator|&
name|dbuf
index|[
name|E_SECOND
index|]
argument_list|)
expr_stmt|;
name|then
operator|.
name|tm_year
operator|=
name|atoi
argument_list|(
operator|&
name|dbuf
index|[
name|E_YEAR
index|]
argument_list|)
operator|-
literal|1900
expr_stmt|;
return|return
operator|(
name|emitl
argument_list|(
operator|&
name|then
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|months
index|[]
init|=
literal|"JanFebMarAprMayJunJulAugSepOctNovDec"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|lookup
argument_list|(
argument|str
argument_list|)
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|months
operator|,
name|cp2
operator|=
name|str
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|+=
literal|3
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|cp2
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|cp
operator|-
name|months
operator|)
operator|/
literal|3
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Routine to convert a localtime(3) format date back into  * a system format date.  *  *	Use a binary search.  */
end_comment

begin_function_decl
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|time_t
name|emitl
parameter_list|(
name|dp
parameter_list|)
name|struct
name|tm
modifier|*
name|dp
decl_stmt|;
block|{
name|time_t
name|conv
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|bit
decl_stmt|;
name|struct
name|tm
name|dcopy
decl_stmt|;
name|dcopy
operator|=
operator|*
name|dp
expr_stmt|;
name|dp
operator|=
operator|&
name|dcopy
expr_stmt|;
name|conv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|bit
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
name|conv
operator||=
name|bit
expr_stmt|;
if|if
condition|(
name|dcmp
argument_list|(
name|localtime
argument_list|(
operator|&
name|conv
argument_list|)
argument_list|,
name|dp
argument_list|)
operator|>
literal|0
condition|)
name|conv
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
return|return
operator|(
name|conv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two localtime dates, return result.  */
end_comment

begin_define
define|#
directive|define
name|DECIDE
parameter_list|(
name|a
parameter_list|)
define|\
value|if (dp->a> dp2->a) \ 		return(1); \ 	if (dp->a< dp2->a) \ 		return(-1)
end_define

begin_expr_stmt
specifier|static
name|dcmp
argument_list|(
name|dp
argument_list|,
name|dp2
argument_list|)
specifier|register
expr|struct
name|tm
operator|*
name|dp
operator|,
operator|*
name|dp2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|DECIDE
argument_list|(
name|tm_year
argument_list|)
expr_stmt|;
name|DECIDE
argument_list|(
name|tm_mon
argument_list|)
expr_stmt|;
name|DECIDE
argument_list|(
name|tm_mday
argument_list|)
expr_stmt|;
name|DECIDE
argument_list|(
name|tm_hour
argument_list|)
expr_stmt|;
name|DECIDE
argument_list|(
name|tm_min
argument_list|)
expr_stmt|;
name|DECIDE
argument_list|(
name|tm_sec
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

