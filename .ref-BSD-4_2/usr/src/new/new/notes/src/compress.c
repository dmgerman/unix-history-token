begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"%W%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_comment
comment|/*  *	compress(io) struct io_f  *	compresses the notefile specified. All wasted space  *	reclaimed. The process is a simple one which, like dcheck,  *	does not work so well on active file systems.  *	As a consequence, the director options (which call this)  *	require the notefile to be closed before allowing compression  *	to take place.   *	The code generates 3 scratch files, corresponding with the  *	two index files and the text file. These are made to  *	represent a virgin notefile. The descriptor is copied over  *	with the appropriate fields zapped, and then we go through  *	a cycle of (read note; write note; (read resp; write resp))  *	until all the notes and responses are moved over.  *	the new files are then copied back into place.  *	  *	Returns:	0 - all successful  *			-1 - if notesfiles compressed already  *  *			otherwise will core dump with the notefile  *			in a shambles from the users view point,  *			but still recoverable by a hotshot-pro.  *  *	Original Coding:	Ray Essick	January 1981  */
end_comment

begin_macro
name|compress
argument_list|(
argument|io
argument_list|,
argument|lockflag
argument_list|,
argument|numnotes
argument_list|,
argument|numresps
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lockflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|numnotes
decl_stmt|,
modifier|*
name|numresps
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|io_f
name|tmpio
decl_stmt|;
comment|/* scratch notefile */
name|struct
name|note_f
name|note
decl_stmt|;
comment|/* hold a note record */
name|struct
name|resp_f
name|resp
decl_stmt|;
comment|/* hold the response format */
name|char
name|fn1
index|[
name|WDLEN
index|]
decl_stmt|,
name|fn2
index|[
name|WDLEN
index|]
decl_stmt|,
name|fn3
index|[
name|WDLEN
index|]
decl_stmt|;
name|char
name|on1
index|[
name|WDLEN
index|]
decl_stmt|,
name|on2
index|[
name|WDLEN
index|]
decl_stmt|,
name|on3
index|[
name|WDLEN
index|]
decl_stmt|;
name|char
name|txtfn
index|[
name|WDLEN
index|]
decl_stmt|;
comment|/* hold text going between files */
name|char
name|cmd
index|[
name|CMDLEN
index|]
decl_stmt|;
comment|/* monster move command */
name|struct
name|daddr_f
name|where
decl_stmt|;
name|FILE
modifier|*
name|txtfile
decl_stmt|;
name|int
name|nnotes
decl_stmt|,
name|nresps
decl_stmt|,
name|dint
decl_stmt|,
name|roffset
decl_stmt|,
name|num
decl_stmt|,
name|rblock
decl_stmt|;
specifier|register
name|int
name|newnum
decl_stmt|,
name|presps
decl_stmt|,
name|rnum
decl_stmt|;
name|struct
name|daddr_f
name|daddr
decl_stmt|;
comment|/* build names of files - in notefile directory */
name|sprintf
argument_list|(
name|fn1
argument_list|,
literal|"%s/%s/tmp.%s"
argument_list|,
name|MSTDIR
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|INDEXN
argument_list|)
expr_stmt|;
comment|/* new files */
name|sprintf
argument_list|(
name|fn2
argument_list|,
literal|"%s/%s/tmp.%s"
argument_list|,
name|MSTDIR
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|INDEXR
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fn3
argument_list|,
literal|"%s/%s/tmp.%s"
argument_list|,
name|MSTDIR
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|on1
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|MSTDIR
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|INDEXN
argument_list|)
expr_stmt|;
comment|/* old files */
name|sprintf
argument_list|(
name|on2
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|MSTDIR
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|INDEXR
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|on3
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|MSTDIR
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
comment|/* 	 * if the notesfile is not already locked, 	 * do so now.  This also insures signals will 	 * be ignored 	 */
if|if
condition|(
name|lockflag
condition|)
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* lock up the notefile */
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidndx
operator|=
name|creat
argument_list|(
name|fn1
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: create nindex"
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidrdx
operator|=
name|creat
argument_list|(
name|fn2
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: create rindex"
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidtxt
operator|=
name|creat
argument_list|(
name|fn3
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: create txt"
argument_list|)
expr_stmt|;
name|dint
operator|=
literal|0
expr_stmt|;
comment|/* resp index free pointer */
name|daddr
operator|.
name|addr
operator|=
sizeof|sizeof
name|daddr
expr_stmt|;
comment|/* and for text file */
name|x
argument_list|(
name|write
argument_list|(
name|tmpio
operator|.
name|fidrdx
argument_list|,
operator|&
name|dint
argument_list|,
sizeof|sizeof
argument_list|(
name|dint
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|dint
argument_list|)
argument_list|,
literal|"compress: resp ptr"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|write
argument_list|(
name|tmpio
operator|.
name|fidtxt
argument_list|,
operator|&
name|daddr
argument_list|,
sizeof|sizeof
argument_list|(
name|daddr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|daddr
argument_list|)
argument_list|,
literal|"Compress: text ptr"
argument_list|)
expr_stmt|;
name|closenf
argument_list|(
operator|&
name|tmpio
argument_list|)
expr_stmt|;
comment|/* close them up */
ifdef|#
directive|ifdef
name|BSD4
name|.1c
comment|/* open R/W */
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidndx
operator|=
name|open
argument_list|(
name|fn1
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: reopen 1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidrdx
operator|=
name|open
argument_list|(
name|fn2
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: reopen 2"
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidtxt
operator|=
name|open
argument_list|(
name|fn3
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: reopen 3"
argument_list|)
expr_stmt|;
else|#
directive|else
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidndx
operator|=
name|open
argument_list|(
name|fn1
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: reopen 1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidrdx
operator|=
name|open
argument_list|(
name|fn2
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: reopen 2"
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidtxt
operator|=
name|open
argument_list|(
name|fn3
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: reopen 3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD4.1c
name|strmove
argument_list|(
name|io
operator|->
name|nf
argument_list|,
name|tmpio
operator|.
name|nf
argument_list|)
expr_stmt|;
comment|/* copy over notefile name */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|tmpio
operator|.
name|descr
argument_list|)
expr_stmt|;
comment|/* grab descriptor */
if|if
condition|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|NFINVALID
condition|)
block|{
comment|/* fix to clean up things, from Steve Potter, Tektronix */
name|closenf
argument_list|(
operator|&
name|tmpio
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|fn1
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove tmp 1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|fn2
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove tmp 2"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|fn3
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove tmp 3"
argument_list|)
expr_stmt|;
comment|/* end of fix */
if|if
condition|(
name|lockflag
condition|)
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nnotes
operator|=
name|nresps
operator|=
literal|0
expr_stmt|;
comment|/* init counts of living notes */
name|sprintf
argument_list|(
name|txtfn
argument_list|,
literal|"/tmp/nfc%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|tmpio
operator|.
name|descr
operator|.
name|d_nnote
operator|=
literal|0
expr_stmt|;
comment|/* reset note count */
name|putdscr
argument_list|(
operator|&
name|tmpio
argument_list|,
operator|&
name|tmpio
operator|.
name|descr
argument_list|)
expr_stmt|;
comment|/* place it into the file */
if|if
condition|(
name|io
operator|->
name|descr
operator|.
name|d_plcy
condition|)
block|{
comment|/* copy the policy note over */
name|getnrec
argument_list|(
name|io
argument_list|,
literal|0
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* descriptor */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress:bad txt"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress: bad txt read"
argument_list|)
expr_stmt|;
name|pagein
argument_list|(
operator|&
name|tmpio
argument_list|,
name|txtfile
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|putnote
argument_list|(
operator|&
name|tmpio
argument_list|,
operator|&
name|where
argument_list|,
name|note
operator|.
name|ntitle
argument_list|,
name|note
operator|.
name|n_stat
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
name|POLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|note
operator|.
name|n_from
argument_list|,
name|NOADDTIME
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|num
operator|=
literal|1
init|;
name|num
operator|<=
name|io
operator|->
name|descr
operator|.
name|d_nnote
condition|;
name|num
operator|++
control|)
block|{
name|getnrec
argument_list|(
name|io
argument_list|,
name|num
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|.
name|n_stat
operator|&
name|DELETED
condition|)
continue|continue;
comment|/* deleted - we throw away */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress:bad txt"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress: bad txt read"
argument_list|)
expr_stmt|;
name|pagein
argument_list|(
operator|&
name|tmpio
argument_list|,
name|txtfile
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* save max number of responses */
name|presps
operator|=
name|note
operator|.
name|n_nresp
expr_stmt|;
name|newnum
operator|=
name|putnote
argument_list|(
operator|&
name|tmpio
argument_list|,
operator|&
name|where
argument_list|,
name|note
operator|.
name|ntitle
argument_list|,
name|note
operator|.
name|n_stat
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|note
operator|.
name|n_from
argument_list|,
name|NOADDTIME
argument_list|)
expr_stmt|;
name|nnotes
operator|++
expr_stmt|;
comment|/* add a note */
for|for
control|(
name|rnum
operator|=
literal|1
init|;
name|rnum
operator|<=
name|presps
condition|;
name|rnum
operator|++
control|)
block|{
comment|/* process responses */
if|if
condition|(
name|lrsp
argument_list|(
name|io
argument_list|,
name|num
argument_list|,
name|rnum
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|roffset
argument_list|,
operator|&
name|rblock
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* bad response chain - drop rest */
break|break;
block|}
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress:bad txt"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
name|io
argument_list|,
operator|&
name|resp
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress: bad txt read"
argument_list|)
expr_stmt|;
name|pagein
argument_list|(
operator|&
name|tmpio
argument_list|,
name|txtfile
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|putresp
argument_list|(
operator|&
name|tmpio
argument_list|,
operator|&
name|where
argument_list|,
name|resp
operator|.
name|r_stat
index|[
name|roffset
index|]
argument_list|,
name|newnum
argument_list|,
operator|&
name|resp
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
operator|&
name|resp
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|note
argument_list|,
name|NOLOCKIT
argument_list|,
operator|&
name|resp
operator|.
name|r_id
index|[
name|roffset
index|]
argument_list|,
name|NOADDID
argument_list|,
name|resp
operator|.
name|r_from
index|[
name|roffset
index|]
argument_list|,
name|NOADDTIME
argument_list|,
operator|&
name|resp
operator|.
name|r_rcvd
index|[
name|roffset
index|]
argument_list|)
expr_stmt|;
name|nresps
operator|++
expr_stmt|;
comment|/* count responses */
block|}
block|}
comment|/* 	 * well, we have now copied the entire notefile over, 	 * so the time has come to move it back into the correct 	 * file names - we will do this by linking 	 */
name|closenf
argument_list|(
operator|&
name|tmpio
argument_list|)
expr_stmt|;
comment|/* close the new one */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
name|io
operator|->
name|descr
operator|.
name|d_stat
operator||=
name|NFINVALID
expr_stmt|;
comment|/* mark it bad */
name|putdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
name|closenf
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* close the old one */
ifdef|#
directive|ifdef
name|BSD4
name|.1c
name|x
argument_list|(
name|rename
argument_list|(
name|fn1
argument_list|,
name|on1
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: rename 1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|rename
argument_list|(
name|fn2
argument_list|,
name|on2
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: rename 1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|rename
argument_list|(
name|fn3
argument_list|,
name|on3
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: rename 1"
argument_list|)
expr_stmt|;
else|#
directive|else
name|x
argument_list|(
name|unlink
argument_list|(
name|on1
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove old 1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|link
argument_list|(
name|fn1
argument_list|,
name|on1
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: link new 1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|fn1
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove tmp 1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|on2
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove old 2"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|link
argument_list|(
name|fn2
argument_list|,
name|on2
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: link new 2"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|fn2
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove tmp 2"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|on3
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove old 3"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|link
argument_list|(
name|fn3
argument_list|,
name|on3
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: link new 3"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|fn3
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove tmp 3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD4.1c
name|unlink
argument_list|(
name|txtfn
argument_list|)
expr_stmt|;
name|opennf
argument_list|(
name|io
argument_list|,
name|io
operator|->
name|nf
argument_list|)
expr_stmt|;
comment|/* relink to new one */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* get the new descriptor */
if|if
condition|(
name|lockflag
condition|)
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
operator|*
name|numnotes
operator|=
name|nnotes
expr_stmt|;
operator|*
name|numresps
operator|=
name|nresps
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* return ok */
block|}
end_block

end_unit

