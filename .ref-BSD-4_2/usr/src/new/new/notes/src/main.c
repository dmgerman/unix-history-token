begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"%W%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	this  main program will take in a notefile name, and  *	then proceed to handle all of the processing for it. This includes  *	calling all of the appropriate routines. It should stay in the   *	package pretty much as is. It may not be the master routine, but  *	it will be the chief 'driver' while within a particular note.  *  *	Original author: Rob Kolstad	Winter, 1980.  *	Modifications:	Ray Essick	June, 1981.  *	Modified more:	Ray Essick	May, 1982.  *	Modified even more:  Rick L Spickelmier   UCB  1982  *	Modified even more:  Lou Salkind   	  NYU  1983  *  *	This program is code-sharable.   */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_comment
comment|/* everything that belongs in a mainline */
end_comment

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|autoseq
init|=
literal|0
decl_stmt|;
name|int
name|notesargs
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|cmdline
index|[
name|CMDLEN
index|]
decl_stmt|;
include|#
directive|include
file|"main.i"
comment|/* common init code and such */
if|if
condition|(
name|globuid
operator|==
name|ANONUID
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, you have the wrong uid for notesfiles, talk to the notes guru\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
comment|/* find out if we are autoseq or not */
if|if
condition|(
name|p
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|AUTOSEQ
argument_list|)
operator|==
literal|0
condition|)
name|autoseq
operator|++
expr_stmt|;
comment|/* 	 * Get Various Environmental Variables: 	 * PAGER, SHELL, EDITOR, MAILER, WRITE 	 */
if|if
condition|(
operator|(
name|mypager
operator|=
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|mypager
operator|=
name|PAGER
expr_stmt|;
if|if
condition|(
operator|(
name|myshell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myshell
operator|=
name|SHELL
expr_stmt|;
if|if
condition|(
operator|(
name|myeditor
operator|=
name|getenv
argument_list|(
literal|"NFED"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|myeditor
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myeditor
operator|=
name|EDITOR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mymailer
operator|=
name|getenv
argument_list|(
literal|"MAILER"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|mymailer
operator|=
name|MAILER
expr_stmt|;
if|if
condition|(
operator|(
name|mywrite
operator|=
name|getenv
argument_list|(
literal|"WRITE"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|mywrite
operator|=
name|WRITE
expr_stmt|;
name|myhome
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
name|myterm
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|autoseq
condition|)
name|setseq
argument_list|(
name|NORMSEQ
argument_list|)
expr_stmt|;
comment|/* 	 * COMMAND LINE DECODER 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* option */
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* -S-equencer */
case|case
literal|'x'
case|:
comment|/* e-X-tended sequencer */
case|case
literal|'i'
case|:
comment|/* indexing sequencer */
case|case
literal|'n'
case|:
comment|/* -N-o sequencer */
name|expand
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* overiding tty type */
comment|/* CHECK AGAINST ARGC HERE */
name|myterm
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* -f file option */
comment|/* CHECK AGAINST ARGC HERE */
name|notesrc
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Bad switch `%c'\n"
argument_list|,
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* PROCESS FILE ARGUMENT */
name|expand
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|notesargs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|myterm
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Please set your TERM environmental variable\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"or specify [-t ttytype] as a command line option\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * CHECK FOR NOTESRC FILE 	 */
if|if
condition|(
name|notesrc
condition|)
block|{
if|if
condition|(
name|readrc
argument_list|(
name|notesrc
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|notesrc
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|notesargs
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"%s/%s"
argument_list|,
name|myhome
condition|?
name|myhome
else|:
literal|"."
argument_list|,
name|NOTESRC
argument_list|)
expr_stmt|;
name|notesrc
operator|=
name|strsave
argument_list|(
name|cmdline
argument_list|)
expr_stmt|;
if|if
condition|(
name|readrc
argument_list|(
name|notesrc
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 			 * the user didn't specify a notesfile on the command 			 * and doesn't have a default notesrc file.  Error. 			 */
name|printf
argument_list|(
literal|"Usage: %s [-s] [-t ttytype] [-f file] topic [...]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wfchar
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|MSTDIR
argument_list|,
name|UTILITY
argument_list|,
name|AVAILHLP
argument_list|)
expr_stmt|;
name|dounix
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|mypager
argument_list|,
name|cmdline
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cursget
argument_list|()
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown terminal type: %s\n"
argument_list|,
name|myterm
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|jenv
argument_list|)
condition|)
name|cleanup
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
name|catchem
argument_list|()
expr_stmt|;
name|ttystrt
argument_list|()
expr_stmt|;
comment|/* CBREAK mode */
comment|/* 	 * Arguments all processed.  Read the notesfiles. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_group
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|group
index|[
name|i
index|]
operator|.
name|lookat
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|control
argument_list|(
name|group
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|group
index|[
name|i
index|]
operator|.
name|seqtyp
argument_list|)
condition|)
block|{
case|case
name|QUITFAST
case|:
case|case
name|QUITUPD
case|:
name|cleanup
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
case|case
name|QUITBAD
case|:
break|break;
case|case
name|QUITNEX
case|:
name|printf
argument_list|(
literal|"No such notesfile `%s'\n"
argument_list|,
name|group
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|printf
argument_list|(
literal|"%s..."
argument_list|,
name|group
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|at
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|cleanup
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|cleanup
argument_list|(
argument|Status
argument_list|)
end_macro

begin_block
block|{
comment|/* at(0, 1); */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|ttystop
argument_list|()
expr_stmt|;
comment|/* back to normal mode */
name|exit
argument_list|(
name|Status
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

