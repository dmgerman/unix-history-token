begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)resp.c	1.2 2/2/83"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4
name|.1c
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|L_SET
value|0
end_define

begin_define
define|#
directive|define
name|L_INCR
value|1
end_define

begin_define
define|#
directive|define
name|L_XTND
value|2
end_define

begin_endif
endif|#
directive|endif
endif|BSD4.1c
end_endif

begin_comment
comment|/*  * putresp (io, text, status, noteno, anon)  *  *	writes out a response to noteno in the last position.  *	returns 0 to indicate note has been deleted,  *	otherwise it returns the response number it inserted.  *  *  * delresp(io, noteno, resprec, resphys)  *  *	Deletes PHYSICAL response located at resprec (record id)  *	resphys (internal subscript), updates note's response count  *  *  * getfrsp(io) gets the next free response index -- simple free list chained  *   off first two bytes of file, currently.  *  */
end_comment

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* declare for type checking */
end_comment

begin_macro
name|putresp
argument_list|(
argument|io
argument_list|,
argument|where
argument_list|,
argument|status
argument_list|,
argument|noteno
argument_list|,
argument|adate
argument_list|,
argument|auth
argument_list|,
argument|note
argument_list|,
argument|lockit
argument_list|,
argument|theid
argument_list|,
argument|addid
argument_list|,
argument|fromsys
argument_list|,
argument|addtime
argument_list|,
argument|rcvdtime
argument_list|)
end_macro

begin_comment
comment|/* all input params */
end_comment

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|daddr_f
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|note_f
modifier|*
name|note
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|when_f
modifier|*
name|adate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|auth_f
modifier|*
name|auth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|id_f
modifier|*
name|theid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fromsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* addtime - whether to modify time stamps - useed for compression */
end_comment

begin_decl_stmt
name|struct
name|when_f
modifier|*
name|rcvdtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time to mark as written */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|phys
decl_stmt|,
comment|/* physical subscript number */
name|lastin
decl_stmt|;
comment|/* address of resp record in memory */
name|struct
name|resp_f
name|resp
decl_stmt|;
if|if
condition|(
name|lockit
condition|)
block|{
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* entirely critical */
block|}
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|NFINVALID
condition|)
block|{
name|closenf
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|opennf
argument_list|(
name|io
argument_list|,
name|io
operator|->
name|nf
argument_list|)
expr_stmt|;
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* and updated descriptor */
if|if
condition|(
name|lockit
condition|)
block|{
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* entirely critical */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|getnrec
argument_list|(
name|io
argument_list|,
name|noteno
argument_list|,
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|note
operator|->
name|n_stat
operator|&
name|DELETED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* is this note deleted? */
comment|/* see, it could be deleted by someone else in the intermediary */
if|if
condition|(
name|lockit
condition|)
block|{
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* entirely critical */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* putresp failed */
block|}
if|if
condition|(
name|note
operator|->
name|n_rindx
operator|<
literal|0
condition|)
block|{
comment|/* is there an attached response record ? */
name|lastin
operator|=
name|note
operator|->
name|n_rindx
operator|=
name|getfrsp
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* no, make one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RESPSZ
condition|;
name|i
operator|++
control|)
block|{
name|resp
operator|.
name|r_stat
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* mark all as undeleted at start */
block|}
block|}
else|else
block|{
name|getrrec
argument_list|(
name|io
argument_list|,
name|lastin
operator|=
name|note
operator|->
name|n_rindx
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
comment|/* get 1st resp record */
block|}
name|i
operator|=
name|phys
operator|=
literal|0
expr_stmt|;
comment|/* logical/phys records start here */
while|while
condition|(
name|i
operator|<
name|note
operator|->
name|n_nresp
condition|)
block|{
comment|/* until we get to end */
if|if
condition|(
name|phys
operator|>=
name|RESPSZ
condition|)
block|{
comment|/* off end? -- need next recd */
name|phys
operator|=
literal|0
expr_stmt|;
comment|/* beginning of next one */
name|getrrec
argument_list|(
name|io
argument_list|,
name|lastin
operator|=
name|resp
operator|.
name|r_next
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
comment|/* next recd */
block|}
if|if
condition|(
operator|(
name|resp
operator|.
name|r_stat
index|[
name|phys
index|]
operator|&
name|DELETED
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
comment|/* count this entry if undeleted */
block|}
name|phys
operator|++
expr_stmt|;
comment|/* always count these */
block|}
comment|/* could have gone off end with last phys++ */
if|if
condition|(
name|phys
operator|>=
name|RESPSZ
condition|)
block|{
name|phys
operator|=
literal|0
expr_stmt|;
name|resp
operator|.
name|r_next
operator|=
name|getfrsp
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|putrrec
argument_list|(
name|io
argument_list|,
name|lastin
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
comment|/* out w/modified link */
name|lastin
operator|=
name|resp
operator|.
name|r_next
expr_stmt|;
name|resp
operator|.
name|r_next
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* helps debugging */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RESPSZ
condition|;
name|i
operator|++
control|)
block|{
name|resp
operator|.
name|r_stat
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* mark all as undeleted */
block|}
block|}
name|note
operator|->
name|n_nresp
operator|++
expr_stmt|;
comment|/* one more response! */
name|resp
operator|.
name|r_addr
index|[
name|phys
index|]
operator|.
name|addr
operator|=
name|where
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|addtime
condition|)
block|{
name|gettime
argument_list|(
operator|&
name|resp
operator|.
name|r_rcvd
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copydate
argument_list|(
name|rcvdtime
argument_list|,
operator|&
name|resp
operator|.
name|r_rcvd
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
comment|/* use supplied */
block|}
name|copydate
argument_list|(
name|adate
argument_list|,
operator|&
name|resp
operator|.
name|r_when
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
comment|/* copy date over */
name|copyauth
argument_list|(
name|auth
argument_list|,
operator|&
name|resp
operator|.
name|r_auth
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
comment|/* and author */
name|strmove
argument_list|(
name|fromsys
argument_list|,
name|resp
operator|.
name|r_from
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
comment|/* who gave it to us */
if|if
condition|(
name|addid
condition|)
block|{
comment|/* generate unique id */
name|strmove
argument_list|(
name|io
operator|->
name|descr
operator|.
name|d_id
operator|.
name|sys
argument_list|,
name|resp
operator|.
name|r_id
index|[
name|phys
index|]
operator|.
name|sys
argument_list|)
expr_stmt|;
name|resp
operator|.
name|r_id
index|[
name|phys
index|]
operator|.
name|uniqid
operator|=
operator|++
operator|(
name|io
operator|->
name|descr
operator|.
name|d_id
operator|.
name|uniqid
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIQPLEX
name|resp
operator|.
name|r_id
index|[
name|phys
index|]
operator|.
name|uniqid
operator|+=
name|UNIQPLEX
operator|*
name|io
operator|->
name|descr
operator|.
name|d_nfnum
expr_stmt|;
comment|/* mpx in the nf number */
endif|#
directive|endif
block|}
else|else
block|{
comment|/* use the supplied unique id */
name|strmove
argument_list|(
name|theid
operator|->
name|sys
argument_list|,
name|resp
operator|.
name|r_id
index|[
name|phys
index|]
operator|.
name|sys
argument_list|)
expr_stmt|;
name|resp
operator|.
name|r_id
index|[
name|phys
index|]
operator|.
name|uniqid
operator|=
name|theid
operator|->
name|uniqid
expr_stmt|;
block|}
name|resp
operator|.
name|r_stat
index|[
name|phys
index|]
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|addtime
condition|)
block|{
comment|/* timestamp ? */
name|gettime
argument_list|(
operator|&
name|note
operator|->
name|n_lmod
argument_list|)
expr_stmt|;
comment|/* last modified entire note */
name|gettime
argument_list|(
operator|&
name|io
operator|->
name|descr
operator|.
name|d_lastm
argument_list|)
expr_stmt|;
comment|/* last modified entire file */
block|}
name|putrrec
argument_list|(
name|io
argument_list|,
name|lastin
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
name|putnrec
argument_list|(
name|io
argument_list|,
name|noteno
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|putdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* order of these three keeps disk consistent */
if|if
condition|(
name|lockit
condition|)
block|{
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* entirely critical */
block|}
name|io
operator|->
name|nrspwrit
operator|++
expr_stmt|;
comment|/* add count of writes */
return|return
operator|(
name|note
operator|->
name|n_nresp
operator|)
return|;
comment|/* success */
block|}
end_block

begin_macro
name|getfrsp
argument_list|(
argument|io
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* will contain the free pointer */
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidrdx
argument_list|,
literal|0L
argument_list|,
name|L_SET
argument_list|)
operator|<
literal|0
argument_list|,
literal|"getfrsp: seek I"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|read
argument_list|(
name|io
operator|->
name|fidrdx
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|,
literal|"getfrsp: read"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* next free */
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidrdx
argument_list|,
literal|0L
argument_list|,
name|L_SET
argument_list|)
operator|<
literal|0
argument_list|,
literal|"getfrsp: seek II"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|write
argument_list|(
name|io
operator|->
name|fidrdx
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|,
literal|"getfrsp: write"
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|delresp
argument_list|(
argument|io
argument_list|,
argument|noteno
argument_list|,
argument|resprec
argument_list|,
argument|resphys
argument_list|,
argument|lockit
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|noteno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|resprec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|resphys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lockit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|resp_f
name|resp
decl_stmt|;
name|struct
name|note_f
name|note
decl_stmt|;
if|if
condition|(
name|lockit
condition|)
block|{
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* entirely critical */
block|}
name|getrrec
argument_list|(
name|io
argument_list|,
name|resprec
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|resp
operator|.
name|r_stat
index|[
name|resphys
index|]
operator|&
name|DELETED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* makes sure that someone hasn't zapped at same time */
name|resp
operator|.
name|r_stat
index|[
name|resphys
index|]
operator||=
name|DELETED
expr_stmt|;
comment|/* deleted */
name|putrrec
argument_list|(
name|io
argument_list|,
name|resprec
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
name|getnrec
argument_list|(
name|io
argument_list|,
name|noteno
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
operator|--
name|note
operator|.
name|n_nresp
expr_stmt|;
name|putnrec
argument_list|(
name|io
argument_list|,
name|noteno
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lockit
condition|)
block|{
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* entirely critical */
block|}
return|return;
block|}
end_block

end_unit

