begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)note.c	1.2 2/2/83"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_comment
comment|/*  *	Putnote  *  *	Take the given text, and make put it into the note file.  *	following algorithm:  *	reserve space for text  *	write the text  *	make the note header record  *	lock the index file  *	write the note header info  *	unlock the index file  *	rewrite the correct text header info  *  *  *	Delnote(io, noteno):  marks the status word as deleted.  *  *	Original authors:	Rob Kolstad and Ray Essick	Winter 1980  *	modified;	Ray Essick	December 1981  */
end_comment

begin_macro
name|putnote
argument_list|(
argument|io
argument_list|,
argument|where
argument_list|,
argument|title
argument_list|,
argument|status
argument_list|,
argument|note
argument_list|,
argument|auth
argument_list|,
argument|policy
argument_list|,
argument|lockit
argument_list|,
argument|addid
argument_list|,
argument|fromsys
argument_list|,
argument|addtime
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|daddr_f
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|title
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|note_f
modifier|*
name|note
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|auth_f
modifier|*
name|auth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* policy = true if this is the policy note */
end_comment

begin_comment
comment|/* addid = fales if we already have an id for the note */
end_comment

begin_comment
comment|/* addtime = false if we already have a time for the note */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fromsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whom we recieved it from (routing) */
end_comment

begin_block
block|{
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|notenum
decl_stmt|;
name|note
operator|->
name|n_nresp
operator|=
literal|0
expr_stmt|;
comment|/* no responses yet */
if|if
condition|(
name|addtime
condition|)
block|{
comment|/* dont if compressing... */
name|gettime
argument_list|(
operator|&
name|note
operator|->
name|n_rcvd
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|note
operator|->
name|n_lmod
argument_list|)
expr_stmt|;
comment|/* date of last mod is same */
block|}
name|copyauth
argument_list|(
name|auth
argument_list|,
operator|&
name|note
operator|->
name|n_auth
argument_list|)
expr_stmt|;
comment|/* move author over */
name|strmove
argument_list|(
name|fromsys
argument_list|,
name|note
operator|->
name|n_from
argument_list|)
expr_stmt|;
comment|/* who gave it to us */
name|note
operator|->
name|n_rindx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no place for responses yet */
name|note
operator|->
name|n_stat
operator|=
name|status
expr_stmt|;
comment|/* director message, deleted, etc */
name|note
operator|->
name|n_addr
operator|.
name|addr
operator|=
name|where
operator|->
name|addr
expr_stmt|;
comment|/* where on disk */
name|p
operator|=
name|note
operator|->
name|ntitle
expr_stmt|;
name|count
operator|=
name|TITLEN
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|title
operator|++
expr_stmt|;
comment|/* move title over */
block|}
if|if
condition|(
name|lockit
condition|)
block|{
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* CRITICAL */
block|}
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* grab notesfile header */
if|if
condition|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|NFINVALID
condition|)
block|{
if|if
condition|(
name|lockit
condition|)
block|{
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* CRITICAL */
block|}
name|closenf
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|opennf
argument_list|(
name|io
argument_list|,
name|io
operator|->
name|nf
argument_list|)
expr_stmt|;
comment|/* get new links */
name|printf
argument_list|(
literal|"Sorry, your note has been lost in a compression"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|addid
condition|)
block|{
name|strmove
argument_list|(
name|io
operator|->
name|descr
operator|.
name|d_id
operator|.
name|sys
argument_list|,
name|note
operator|->
name|n_id
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* copy over sys name */
name|note
operator|->
name|n_id
operator|.
name|uniqid
operator|=
operator|++
operator|(
name|io
operator|->
name|descr
operator|.
name|d_id
operator|.
name|uniqid
operator|)
expr_stmt|;
comment|/* and unique id num */
ifdef|#
directive|ifdef
name|UNIQPLEX
name|note
operator|->
name|n_id
operator|.
name|uniqid
operator|+=
name|UNIQPLEX
operator|*
name|io
operator|->
name|descr
operator|.
name|d_nfnum
expr_stmt|;
comment|/* mpx in nf num */
endif|#
directive|endif
block|}
if|if
condition|(
name|policy
condition|)
block|{
name|io
operator|->
name|descr
operator|.
name|d_plcy
operator|=
literal|1
expr_stmt|;
comment|/* mark as having a policy note */
name|notenum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|notenum
operator|=
operator|++
name|io
operator|->
name|descr
operator|.
name|d_nnote
expr_stmt|;
comment|/* this note's number */
block|}
if|if
condition|(
name|addtime
condition|)
block|{
comment|/* see if want timestamp */
name|gettime
argument_list|(
operator|&
name|io
operator|->
name|descr
operator|.
name|d_lastm
argument_list|)
expr_stmt|;
comment|/* last time file modified */
block|}
name|putnrec
argument_list|(
name|io
argument_list|,
name|notenum
argument_list|,
name|note
argument_list|)
expr_stmt|;
comment|/* write note info */
name|putdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* rewrite header info */
if|if
condition|(
name|lockit
condition|)
block|{
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* CRITICAL */
block|}
name|io
operator|->
name|nnotwrit
operator|++
expr_stmt|;
comment|/* bump count of writes */
return|return
operator|(
name|io
operator|->
name|descr
operator|.
name|d_nnote
operator|)
return|;
comment|/* tell which slot it is in */
block|}
end_block

begin_macro
name|delnote
argument_list|(
argument|io
argument_list|,
argument|noteno
argument_list|,
argument|lockit
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|note_f
name|note
decl_stmt|;
if|if
condition|(
name|lockit
condition|)
block|{
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* CRITICAL */
block|}
name|getnrec
argument_list|(
name|io
argument_list|,
name|noteno
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* get the note */
name|note
operator|.
name|n_stat
operator||=
name|DELETED
expr_stmt|;
comment|/* deleted */
name|putnrec
argument_list|(
name|io
argument_list|,
name|noteno
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockit
condition|)
block|{
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* CRITICAL */
block|}
block|}
end_block

end_unit

