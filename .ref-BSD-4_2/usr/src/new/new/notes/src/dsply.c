begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"%W%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_comment
comment|/*  * dspnote(io,note) struct io_f *io; struct note_f *note;  *  *    displays a completely formatted note on the screen.  It calls  *    gettrec to get the text of the note.  *  * dspresp(io,note,resp,phys,logical) is a little trickier.  *  *   it prints out the response to<note> from response form<resp>  *   (at index of<resp> of<phys>).<logical> is the logical number  *   of the note and is displayed.  *  *	Original coding:	Rob Kolstad	Winter 1980  *	Modified:		Ray Essick	December 1981  *		- reordered display so went top to bottom, left to right  *		- to facilitate use on dumb terminals (or tty's)  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Anon
init|=
literal|"Anonymous"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Fromnews
init|=
literal|"(From News system)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Continued
init|=
literal|"-- more  %d%% --"
decl_stmt|;
end_decl_stmt

begin_macro
name|dspnote
argument_list|(
argument|io
argument_list|,
argument|note
argument_list|,
argument|notenum
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|note_f
modifier|*
name|note
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|long
name|where
decl_stmt|;
comment|/* for seeking */
name|struct
name|txthead_f
name|txthead
decl_stmt|;
comment|/* used for seeking */
name|struct
name|dsply_f
name|dispbuf
decl_stmt|;
name|long
name|pagecnt
index|[
name|PAGESAV
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|pagesout
decl_stmt|;
name|io
operator|->
name|nnotread
operator|++
expr_stmt|;
comment|/* bump count of notes read */
name|pagesout
operator|=
literal|0
expr_stmt|;
name|pagecnt
index|[
name|pagesout
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|note
operator|->
name|n_addr
operator|.
name|addr
operator|==
literal|0
condition|)
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
operator|=
literal|0
expr_stmt|;
comment|/* so can get a header */
else|else
name|gethrec
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|->
name|n_addr
argument_list|,
operator|&
name|dispbuf
operator|.
name|d_head
argument_list|)
expr_stmt|;
comment|/* get header */
name|dispbuf
operator|.
name|outcount
operator|=
name|dispbuf
operator|.
name|optr
operator|=
name|dispbuf
operator|.
name|olim
operator|=
literal|0
expr_stmt|;
comment|/* fix buffer */
do|do
block|{
comment|/* always show the first page */
comment|/* display loop */
name|erase
argument_list|()
expr_stmt|;
comment|/* write header crap */
name|at
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|notenum
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dispbuf
operator|.
name|outcount
condition|)
comment|/* nth page */
name|printf
argument_list|(
literal|"[Continued] "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Note %d"
argument_list|,
name|notenum
argument_list|)
expr_stmt|;
block|}
name|center
argument_list|(
name|io
operator|->
name|descr
operator|.
name|d_title
argument_list|,
name|NNLEN
argument_list|,
literal|1
argument_list|,
literal|40
operator|-
name|NNLEN
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|->
name|n_nresp
operator|>
literal|0
condition|)
block|{
name|at
argument_list|(
literal|1
argument_list|,
literal|67
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d response"
argument_list|,
name|note
operator|->
name|n_nresp
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|->
name|n_nresp
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
block|}
name|at
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|note
operator|->
name|n_auth
operator|.
name|aname
argument_list|)
expr_stmt|;
name|center
argument_list|(
name|note
operator|->
name|ntitle
argument_list|,
name|TITLEN
argument_list|,
literal|2
argument_list|,
literal|40
operator|-
name|TITLEN
operator|/
literal|2
argument_list|)
expr_stmt|;
name|at
argument_list|(
literal|2
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|prdate
argument_list|(
operator|&
name|note
operator|->
name|n_date
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|SYSTEM
argument_list|,
name|note
operator|->
name|n_id
operator|.
name|sys
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|Anon
argument_list|,
name|note
operator|->
name|n_auth
operator|.
name|aname
argument_list|)
condition|)
block|{
name|at
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* print system name if not local */
name|printf
argument_list|(
literal|"(at %s)"
argument_list|,
name|note
operator|->
name|n_id
operator|.
name|sys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|note
operator|->
name|n_stat
operator|&
name|DIRMES
condition|)
name|center
argument_list|(
name|io
operator|->
name|descr
operator|.
name|d_drmes
argument_list|,
name|DMLEN
argument_list|,
literal|3
argument_list|,
literal|40
operator|-
name|DMLEN
operator|/
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|note
operator|->
name|n_stat
operator|&
name|WRITONLY
condition|)
block|{
name|at
argument_list|(
literal|3
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-- (Write Only) --"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|note
operator|->
name|n_stat
operator|&
name|FRMNEWS
condition|)
block|{
name|at
argument_list|(
literal|3
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Fromnews
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
operator|==
literal|0
condition|)
block|{
name|c
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
comment|/* header is it for empties */
block|}
name|at
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* make sure soft-tabs work */
name|c
operator|=
name|showit
argument_list|(
name|io
argument_list|,
operator|&
name|dispbuf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
comment|/* wants the next page */
case|case
literal|'l'
case|:
comment|/* universal seq, RLS */
if|if
condition|(
name|pagesout
operator|<
name|PAGESAV
condition|)
name|pagecnt
index|[
operator|++
name|pagesout
index|]
operator|=
name|dispbuf
operator|.
name|outcount
expr_stmt|;
comment|/* save new start */
break|break;
case|case
literal|'-'
case|:
comment|/* go back to previous */
case|case
literal|'\b'
case|:
comment|/* same for backspace */
if|if
condition|(
name|pagesout
operator|--
operator|==
literal|0
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* pass the buck */
name|dispbuf
operator|.
name|optr
operator|=
name|dispbuf
operator|.
name|olim
operator|=
literal|0
expr_stmt|;
name|dispbuf
operator|.
name|outcount
operator|=
name|pagecnt
index|[
name|pagesout
index|]
expr_stmt|;
name|where
operator|=
name|note
operator|->
name|n_addr
operator|.
name|addr
operator|+
operator|(
sizeof|sizeof
name|txthead
operator|)
operator|+
name|dispbuf
operator|.
name|outcount
expr_stmt|;
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidtxt
argument_list|,
name|where
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
argument_list|,
literal|"dspnote: bad seek"
argument_list|)
expr_stmt|;
break|break;
comment|/* are all set now */
case|case
literal|'\014'
case|:
comment|/* redraw current screen */
name|dispbuf
operator|.
name|optr
operator|=
name|dispbuf
operator|.
name|olim
operator|=
literal|0
expr_stmt|;
name|dispbuf
operator|.
name|outcount
operator|=
name|pagecnt
index|[
name|pagesout
index|]
expr_stmt|;
name|where
operator|=
name|note
operator|->
name|n_addr
operator|.
name|addr
operator|+
operator|(
sizeof|sizeof
name|txthead
operator|)
operator|+
name|dispbuf
operator|.
name|outcount
expr_stmt|;
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidtxt
argument_list|,
name|where
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
argument_list|,
literal|"dspnote: bad seek"
argument_list|)
expr_stmt|;
break|break;
comment|/* are all set now */
default|default:
comment|/* pass the buck */
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
do|while
condition|(
name|dispbuf
operator|.
name|outcount
operator|<
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
condition|)
do|;
if|if
condition|(
name|note
operator|->
name|n_stat
operator|&
name|CONTINUED
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
operator|-
literal|40
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-- Continued in next response --"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
comment|/* didn't field a command */
block|}
end_block

begin_comment
comment|/*  *	Code to print the header and manage the paging of a response  *	It calls the "showit" routine to print pages of text  */
end_comment

begin_macro
name|dspresp
argument_list|(
argument|io
argument_list|,
argument|note
argument_list|,
argument|resp
argument_list|,
argument|phys
argument_list|,
argument|logical
argument_list|,
argument|notenum
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|note_f
modifier|*
name|note
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|resp_f
modifier|*
name|resp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|struct
name|txthead_f
name|txthead
decl_stmt|;
name|struct
name|dsply_f
name|dispbuf
decl_stmt|;
name|long
name|where
decl_stmt|,
name|pagecnt
index|[
name|PAGESAV
index|]
decl_stmt|;
comment|/* stack for backing up */
name|int
name|pagesout
decl_stmt|;
name|io
operator|->
name|nrspread
operator|++
expr_stmt|;
comment|/* bump count or responses read */
name|pagesout
operator|=
literal|0
expr_stmt|;
name|pagecnt
index|[
name|pagesout
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|r_addr
index|[
name|phys
index|]
operator|.
name|addr
operator|==
literal|0
condition|)
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
operator|=
literal|0
expr_stmt|;
comment|/* so can get a header */
else|else
name|gethrec
argument_list|(
name|io
argument_list|,
operator|&
name|resp
operator|->
name|r_addr
index|[
name|phys
index|]
argument_list|,
operator|&
name|dispbuf
operator|.
name|d_head
argument_list|)
expr_stmt|;
comment|/* get header */
name|dispbuf
operator|.
name|outcount
operator|=
name|dispbuf
operator|.
name|optr
operator|=
name|dispbuf
operator|.
name|olim
operator|=
literal|0
expr_stmt|;
comment|/* fix buffer */
do|do
block|{
comment|/* always make 1 pass */
name|erase
argument_list|()
expr_stmt|;
comment|/* paint the header */
name|at
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispbuf
operator|.
name|outcount
condition|)
comment|/* nth page */
name|printf
argument_list|(
literal|"[Continued] "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Note %d"
argument_list|,
name|notenum
argument_list|)
expr_stmt|;
name|center
argument_list|(
name|io
operator|->
name|descr
operator|.
name|d_title
argument_list|,
name|NNLEN
argument_list|,
literal|1
argument_list|,
literal|40
operator|-
name|NNLEN
operator|/
literal|2
argument_list|)
expr_stmt|;
name|at
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|resp
operator|->
name|r_auth
index|[
name|phys
index|]
operator|.
name|aname
argument_list|)
expr_stmt|;
name|at
argument_list|(
literal|2
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Response %2d of %2d"
argument_list|,
name|logical
argument_list|,
name|note
operator|->
name|n_nresp
argument_list|)
expr_stmt|;
name|at
argument_list|(
literal|2
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|prdate
argument_list|(
operator|&
name|resp
operator|->
name|r_when
index|[
name|phys
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|SYSTEM
argument_list|,
name|resp
operator|->
name|r_id
index|[
name|phys
index|]
operator|.
name|sys
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|Anon
argument_list|,
name|resp
operator|->
name|r_auth
index|[
name|phys
index|]
operator|.
name|aname
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* print sys name if not here */
name|at
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(at %s)"
argument_list|,
name|resp
operator|->
name|r_id
index|[
name|phys
index|]
operator|.
name|sys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resp
operator|->
name|r_stat
index|[
name|phys
index|]
operator|&
name|DIRMES
condition|)
name|center
argument_list|(
name|io
operator|->
name|descr
operator|.
name|d_drmes
argument_list|,
name|DMLEN
argument_list|,
literal|3
argument_list|,
literal|40
operator|-
name|DMLEN
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|r_stat
index|[
name|phys
index|]
operator|&
name|FRMNEWS
condition|)
block|{
name|at
argument_list|(
literal|3
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Fromnews
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
operator|==
literal|0
condition|)
block|{
name|c
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
comment|/* header is all for empties */
block|}
name|at
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* make sure soft-tabs work */
name|c
operator|=
name|showit
argument_list|(
name|io
argument_list|,
operator|&
name|dispbuf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
comment|/* wants the next page */
case|case
literal|'l'
case|:
comment|/* universal seq, RLS */
if|if
condition|(
name|pagesout
operator|<
name|PAGESAV
condition|)
name|pagecnt
index|[
operator|++
name|pagesout
index|]
operator|=
name|dispbuf
operator|.
name|outcount
expr_stmt|;
comment|/* save new start */
break|break;
case|case
literal|'-'
case|:
comment|/* go back to previous */
case|case
literal|'\b'
case|:
if|if
condition|(
name|pagesout
operator|--
operator|==
literal|0
condition|)
return|return
name|c
return|;
comment|/* pass the buck */
name|dispbuf
operator|.
name|optr
operator|=
name|dispbuf
operator|.
name|olim
operator|=
literal|0
expr_stmt|;
name|dispbuf
operator|.
name|outcount
operator|=
name|pagecnt
index|[
name|pagesout
index|]
expr_stmt|;
name|where
operator|=
name|note
operator|->
name|n_addr
operator|.
name|addr
operator|+
operator|(
sizeof|sizeof
name|txthead
operator|)
operator|+
name|dispbuf
operator|.
name|outcount
expr_stmt|;
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidtxt
argument_list|,
name|where
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
argument_list|,
literal|"dspnote: bad seek"
argument_list|)
expr_stmt|;
break|break;
comment|/* are all set now */
case|case
literal|'\014'
case|:
comment|/* redraw current screen */
name|dispbuf
operator|.
name|optr
operator|=
name|dispbuf
operator|.
name|olim
operator|=
literal|0
expr_stmt|;
name|dispbuf
operator|.
name|outcount
operator|=
name|pagecnt
index|[
name|pagesout
index|]
expr_stmt|;
name|where
operator|=
name|note
operator|->
name|n_addr
operator|.
name|addr
operator|+
operator|(
sizeof|sizeof
name|txthead
operator|)
operator|+
name|dispbuf
operator|.
name|outcount
expr_stmt|;
name|x
argument_list|(
name|lseek
argument_list|(
name|io
operator|->
name|fidtxt
argument_list|,
name|where
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
argument_list|,
literal|"dspnote: bad seek"
argument_list|)
expr_stmt|;
break|break;
comment|/* are all set now */
default|default:
comment|/* pass the buck */
return|return
name|c
return|;
block|}
block|}
do|while
condition|(
name|dispbuf
operator|.
name|outcount
operator|<
name|dispbuf
operator|.
name|d_head
operator|.
name|textlen
condition|)
do|;
if|if
condition|(
name|resp
operator|->
name|r_stat
index|[
name|phys
index|]
operator|&
name|CONTINUED
condition|)
block|{
name|at
argument_list|(
literal|0
argument_list|,
operator|-
literal|40
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-- Continued in next response --"
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
comment|/* didn't field a command */
block|}
end_block

begin_comment
comment|/*  *	showit  *  *	accepts a pointer to a dsply_f and dumps text until runs out  *	or the screen is filled.  *	Counts things like lines, columns, and also prints a "more" line  *  *	Ray Essick	June 15, 1982  */
end_comment

begin_macro
name|showit
argument_list|(
argument|io
argument_list|,
argument|dbuf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dsply_f
modifier|*
name|dbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|lines
decl_stmt|,
name|wides
decl_stmt|;
comment|/* screen fill stuff */
name|int
name|c
decl_stmt|;
name|long
name|retval
init|=
literal|0
decl_stmt|;
name|lines
operator|=
literal|4
expr_stmt|;
comment|/* header eats 4 */
name|wides
operator|=
literal|0
expr_stmt|;
comment|/* start in col 1 */
while|while
condition|(
name|lines
operator|<
name|nrows
operator|-
literal|2
operator|&&
name|dbuf
operator|->
name|outcount
operator|<
name|dbuf
operator|->
name|d_head
operator|.
name|textlen
condition|)
block|{
if|if
condition|(
name|dbuf
operator|->
name|optr
operator|==
name|dbuf
operator|->
name|olim
condition|)
block|{
comment|/* buffer is empty */
name|x
argument_list|(
operator|(
name|dbuf
operator|->
name|olim
operator|=
name|read
argument_list|(
name|io
operator|->
name|fidtxt
argument_list|,
name|dbuf
operator|->
name|d_buf
operator|.
name|txtbuf
argument_list|,
name|BUFSIZE
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"dspnote: text read"
argument_list|)
expr_stmt|;
name|dbuf
operator|->
name|optr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* show the character */
name|putchar
argument_list|(
name|dbuf
operator|->
name|d_buf
operator|.
name|txtbuf
index|[
name|dbuf
operator|->
name|optr
index|]
argument_list|)
expr_stmt|;
name|dbuf
operator|->
name|outcount
operator|++
expr_stmt|;
switch|switch
condition|(
name|dbuf
operator|->
name|d_buf
operator|.
name|txtbuf
index|[
name|dbuf
operator|->
name|optr
operator|++
index|]
condition|)
block|{
comment|/* some special chars */
case|case
literal|'\n'
case|:
comment|/* next line */
name|wides
operator|=
literal|0
expr_stmt|;
name|lines
operator|++
expr_stmt|;
comment|/* check for typeahead every once in a while */
if|if
condition|(
name|isinput
argument_list|()
condition|)
goto|goto
name|exisho
goto|;
break|break;
case|case
literal|'\014'
case|:
comment|/* force next page */
name|lines
operator|=
name|nrows
expr_stmt|;
comment|/* forces loop exit */
break|break;
case|case
literal|'\t'
case|:
comment|/* almost forgot tabs */
name|wides
operator|+=
operator|(
literal|8
operator|-
operator|(
name|wides
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* tab stops */
break|break;
case|case
literal|'\b'
case|:
comment|/* perverts using backspaces */
name|wides
operator|--
expr_stmt|;
break|break;
default|default:
comment|/* dull characters */
name|wides
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wides
operator|>=
name|ncols
condition|)
block|{
comment|/* test line overflow */
name|lines
operator|++
expr_stmt|;
name|wides
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dbuf
operator|->
name|outcount
operator|<
name|dbuf
operator|->
name|d_head
operator|.
name|textlen
condition|)
block|{
name|at
argument_list|(
operator|-
literal|1
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|Continued
argument_list|,
name|dbuf
operator|->
name|outcount
operator|*
literal|100
operator|/
name|dbuf
operator|->
name|d_head
operator|.
name|textlen
argument_list|)
expr_stmt|;
block|}
name|exisho
label|:
name|cmdprompt
argument_list|()
expr_stmt|;
name|c
operator|=
name|gchar
argument_list|()
expr_stmt|;
comment|/* grab command */
return|return
operator|(
name|c
operator|)
return|;
comment|/* so let caller handle it */
block|}
end_block

end_unit

