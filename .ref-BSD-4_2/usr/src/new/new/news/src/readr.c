begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * readr - /bin/mail and msgs interface and associated functions.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)readr.c	2.26	5/3/83"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"rparams.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|lbuf
index|[
name|BUFLEN
operator|*
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|saveart
value|oobit = bit;strcpy(ofilename1, filename);strcpy(ogroupdir, groupdir);hbufcp(&hbuf1,&h);ongsize = pngsize
end_define

begin_define
define|#
directive|define
name|NLINES
parameter_list|(
name|h
parameter_list|,
name|fp
parameter_list|)
value|(h.numlines[0] ? h.intnumlines : (h.intnumlines=linecnt(fp),sprintf(h.numlines, "%d", h.intnumlines), h.intnumlines))
end_define

begin_decl_stmt
name|char
modifier|*
name|tft
init|=
literal|"/tmp/folXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hascaught
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|catchintr
argument_list|()
block|{
name|hascaught
operator|=
literal|1
block|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
block|;
name|fflush
argument_list|(
name|stdout
argument_list|)
block|; }
comment|/*  * These were made static for u370 with its buggy cc.  * I judged it better to have one copy with no ifdefs than  * to conditionally compile them as automatic variables  * in readr (which they originally were).  Performance  * considerations might warrent moving some of the simple  * things into register variables, but I don't know what  * breaks the u370 cc.  */
specifier|static
name|char
name|goodone
index|[
name|BUFLEN
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* last decent article		*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|ogroupdir
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last groupdir		*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|address
index|[
name|PATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for reply copy		*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|edcmdbuf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|folbuf
index|[
literal|160
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rfq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for last article		*/
end_comment

begin_decl_stmt
specifier|static
name|long
name|ongsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Previous ngsize		*/
end_comment

begin_decl_stmt
specifier|static
name|long
name|pngsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Printing ngsize		*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temp pointer.		*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|srec
name|srec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* srec for sys file entries	*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tfilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary file name 		*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|ofilename1
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous file name		*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hbuf
name|hbuf1
decl_stmt|,
name|hbuf2
decl_stmt|,
modifier|*
name|hptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for minusing			*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ptr1
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|,
modifier|*
name|ptr3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for reply manipulation	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|news
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|abs
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if we asked absolutely	*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ed
decl_stmt|,
name|tf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hbuf
name|h
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ditto.			*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oobit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last bit, really		*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|oldsig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dgest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|ofp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current output file to terminal*/
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current article to be printed*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|holdup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 iff should stop before hdr */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignorenews
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 iff readnews -p> /dev/null*/
end_comment

begin_decl_stmt
specifier|static
name|long
name|timelastsaved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time newsrc last written out */
end_comment

begin_function_decl
name|int
name|catchcont
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_macro
name|readr
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readr()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|aflag
condition|)
block|{
if|if
condition|(
operator|*
name|datebuf
condition|)
block|{
if|if
condition|(
operator|(
name|atime
operator|=
name|cgtdate
argument_list|(
name|datebuf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|xerror
argument_list|(
literal|"Cannot parse date string"
argument_list|)
expr_stmt|;
block|}
else|else
name|atime
operator|=
literal|0L
expr_stmt|;
block|}
if|if
condition|(
name|pflag
operator|&&
name|ignoring
argument_list|()
condition|)
name|ignorenews
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|xflag
condition|)
name|uflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uflag
condition|)
name|time
argument_list|(
operator|&
name|timelastsaved
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|cflag
operator|&&
name|coptbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
comment|/* get "unique" file name */
name|ofp
operator|=
name|xfopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|N_UMASK
argument_list|)
expr_stmt|;
name|cflag
operator|=
name|FALSE
expr_stmt|;
name|pflag
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* loop reading articles. */
name|fp
operator|=
name|NULL
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|nextng
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|getnextart
argument_list|(
name|FALSE
argument_list|)
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"after getnextart, fp %x, pos %d, bit %d, group '%s', filename '%s'\n"
argument_list|,
name|fp
argument_list|,
name|ftell
argument_list|(
name|fp
argument_list|)
argument_list|,
name|bit
argument_list|,
name|groupdir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|goodone
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflag
operator|||
name|lflag
operator|||
name|eflag
condition|)
block|{
comment|/* This code should be gotten rid of */
if|if
condition|(
name|sigtrap
condition|)
block|{
name|qfflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|cdump
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* kludge! drop when qfflush works */
return|return;
block|}
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
continue|continue;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|pp
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGCONT
name|int
function_decl|(
modifier|*
name|ocont
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
name|sigtrap
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
block|{
if|if
condition|(
name|rfq
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Last article.  [qfr] "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"(%d lines) More? [ynq] "
argument_list|,
name|NLINES
argument_list|(
name|h
argument_list|,
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"? "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|bptr
operator|=
name|lbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGCONT
name|ocont
operator|=
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|catchcont
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pp
operator|=
name|fgets
argument_list|(
name|bptr
argument_list|,
name|BUFLEN
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGCONT
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|ocont
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|sigtrap
condition|)
return|return;
ifdef|#
directive|ifdef
name|SIGCONT
if|if
condition|(
name|sigtrap
operator|!=
name|SIGCONT
condition|)
endif|#
directive|endif
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|nstrip
argument_list|(
name|bptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|bptr
operator|==
literal|' '
operator|||
operator|*
name|bptr
operator|==
literal|'\t'
condition|)
name|bptr
operator|++
expr_stmt|;
name|i
operator|=
name|command
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|news
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No news.\n"
argument_list|)
expr_stmt|;
name|cout
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_define
define|#
directive|define
name|EOL
parameter_list|()
value|if (*bptr != '\0') { fprintf(ofp, "? for commands.\n"); return FALSE; }
end_define

begin_comment
comment|/*  * Process one command, which has already been typed in.  */
end_comment

begin_macro
name|command
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|findhist
parameter_list|()
function_decl|;
switch|switch
condition|(
name|i
operator|=
operator|*
name|bptr
operator|++
condition|)
block|{
comment|/* No.  Go on to next article. */
case|case
literal|'n'
case|:
name|EOL
argument_list|()
expr_stmt|;
name|itsbeenseen
argument_list|(
name|h
operator|.
name|ident
argument_list|)
expr_stmt|;
name|readmode
operator|=
name|NEXT
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
break|break;
comment|/* Undigestify the article. */
case|case
literal|'d'
case|:
name|dgest
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
comment|/* yes: print this article, go on. */
case|case
literal|'y'
case|:
name|EOL
argument_list|()
expr_stmt|;
comment|/* fall through. */
comment|/* The user hit return.  Default is 'y' unless rfq, then it's 'q'. */
case|case
literal|'\0'
case|:
if|if
condition|(
operator|!
name|bptr
index|[
operator|-
literal|1
index|]
operator|&&
name|rfq
condition|)
return|return;
name|readmode
operator|=
name|NEXT
expr_stmt|;
name|showtail
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
break|break;
comment|/* 	 * Unsubscribe to the newsgroup and go on to next group 	 */
case|case
literal|'u'
case|:
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"To unsubscribe, use 'U'\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Unsubscribing to newsgroup: %s\n"
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|rfq
operator|=
literal|0
expr_stmt|;
name|zapng
operator|=
name|TRUE
expr_stmt|;
name|saveart
expr_stmt|;
if|if
condition|(
name|nextng
argument_list|()
condition|)
block|{
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Can't back up.\n"
argument_list|)
expr_stmt|;
else|else
return|return
name|TRUE
return|;
block|}
break|break;
comment|/* Print the current version of news */
case|case
literal|'v'
case|:
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"News version: %s\n"
argument_list|,
name|news_version
argument_list|)
expr_stmt|;
break|break;
comment|/* reprint the article */
case|case
literal|'p'
case|:
name|EOL
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
goto|goto
name|minus
goto|;
name|readmode
operator|=
name|NEXT
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|bit
operator|=
name|last
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
comment|/* decrypt joke */
case|case
literal|'D'
case|:
name|caesar_command
argument_list|()
expr_stmt|;
name|readmode
operator|=
name|NEXT
expr_stmt|;
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
break|break;
comment|/* write out the article someplace */
case|case
literal|'s'
case|:
case|case
literal|'w'
case|:
block|{
name|char
modifier|*
name|grn
init|=
name|groupdir
decl_stmt|;
name|tfilename
operator|=
name|filename
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
name|bptr
operator|++
expr_stmt|;
name|grn
operator|=
name|ogroupdir
expr_stmt|;
if|if
condition|(
operator|*
name|ofilename1
condition|)
name|tfilename
operator|=
name|ofilename1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bptr
operator|!=
literal|'\0'
operator|&&
operator|*
name|bptr
operator|!=
literal|' '
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Bad file name.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
name|bptr
operator|==
literal|' '
condition|)
name|bptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|!=
literal|'|'
operator|&&
operator|*
name|bptr
operator|!=
literal|'/'
condition|)
block|{
name|char
name|hetyped
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|boxptr
decl_stmt|;
name|strcpy
argument_list|(
name|hetyped
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|boxptr
operator|=
name|getenv
argument_list|(
literal|"NEWSBOX"
argument_list|)
condition|)
if|if
condition|(
name|index
argument_list|(
name|boxptr
argument_list|,
literal|'%'
argument_list|)
condition|)
name|sprintf
argument_list|(
name|bptr
argument_list|,
name|boxptr
argument_list|,
name|grn
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|bptr
argument_list|,
name|boxptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hetyped
index|[
literal|0
index|]
operator|==
literal|'~'
operator|&&
name|hetyped
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|hetyped
argument_list|,
name|bptr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bptr
argument_list|,
name|userhome
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|bptr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bptr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hetyped
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|strcat
argument_list|(
name|bptr
argument_list|,
name|hetyped
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|bptr
argument_list|,
literal|"Articles"
argument_list|)
expr_stmt|;
block|}
name|fwait
argument_list|(
name|fsubr
argument_list|(
name|save
argument_list|,
name|tfilename
argument_list|,
name|bptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* back up  */
case|case
literal|'-'
case|:
name|minus
label|:
name|rfq
operator|=
literal|0
expr_stmt|;
name|abs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ofilename1
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Can't back up.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
else|else
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
name|hbufcp
argument_list|(
operator|&
name|hbuf2
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
name|hbufcp
argument_list|(
operator|&
name|h
argument_list|,
operator|&
name|hbuf1
argument_list|)
expr_stmt|;
name|hbufcp
argument_list|(
operator|&
name|hbuf1
argument_list|,
operator|&
name|hbuf2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|ofilename1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ofilename1
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|obit
operator|=
name|bit
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|selectng
argument_list|(
name|ogroupdir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ogroupdir
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|ngrp
operator|=
literal|1
expr_stmt|;
name|back
argument_list|()
expr_stmt|;
block|}
name|bit
operator|=
name|oobit
expr_stmt|;
name|oobit
operator|=
name|obit
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|getnextart
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* skip forwards */
case|case
literal|'+'
case|:
name|caseplus
label|:
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'\0'
condition|)
name|strcat
argument_list|(
name|bptr
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|rfq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|last
operator|=
name|bit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|atoi
argument_list|(
name|bptr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|nextbit
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bit
operator|>
name|pngsize
operator|)
operator|||
operator|(
name|rflag
operator|&&
name|bit
operator|<
literal|1
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|cflag
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
comment|/* exit - time updated to that of most recently read article */
case|case
literal|'q'
case|:
name|EOL
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
comment|/* exit - no time update. */
case|case
literal|'x'
case|:
name|EOL
argument_list|()
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* cancel the article. */
case|case
literal|'c'
case|:
name|cancel_command
argument_list|()
expr_stmt|;
break|break;
comment|/* escape to shell */
case|case
literal|'!'
case|:
name|fwait
argument_list|(
name|fsubr
argument_list|(
name|ushell
argument_list|,
name|bptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|hdr
argument_list|()
expr_stmt|;
break|break;
comment|/* mail reply */
case|case
literal|'r'
case|:
name|reply_command
argument_list|()
expr_stmt|;
break|break;
comment|/* send to some system */
case|case
literal|'X'
case|:
name|xmit_command
argument_list|()
expr_stmt|;
break|break;
comment|/* next newsgroup */
case|case
literal|'P'
case|:
operator|*
name|bptr
operator|=
literal|'-'
expr_stmt|;
case|case
literal|'N'
case|:
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|next_ng_command
argument_list|()
condition|)
return|return
name|TRUE
return|;
break|break;
comment|/* specific no. */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|sscanf
argument_list|(
operator|--
name|bptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Bad article no.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|pngsize
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Not that many articles.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|readmode
operator|=
name|SPEC
expr_stmt|;
name|abs
operator|=
name|TRUE
expr_stmt|;
name|bit
operator|=
name|i
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|rfq
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* specific message ID. */
case|case
literal|'<'
case|:
name|ptr1
operator|=
name|findhist
argument_list|(
operator|--
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr1
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"No such article: %s.\n"
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptr2
operator|=
name|index
argument_list|(
name|ptr1
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|ptr3
operator|=
name|index
argument_list|(
operator|++
name|ptr2
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|ptr2
operator|=
name|index
argument_list|(
operator|++
name|ptr3
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr2
condition|)
operator|*
name|ptr2
operator|=
literal|'\0'
expr_stmt|;
name|ptr2
operator|=
name|index
argument_list|(
name|ptr3
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|ptr2
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|abs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
else|else
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
name|hbufcp
argument_list|(
operator|&
name|hbuf1
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|strcpy
argument_list|(
name|ogroupdir
argument_list|,
name|ptr3
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|selectng
argument_list|(
name|ogroupdir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ogroupdir
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|back
argument_list|()
expr_stmt|;
block|}
name|sscanf
argument_list|(
name|ptr2
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|bit
argument_list|)
expr_stmt|;
name|oobit
operator|=
name|obit
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|getnextart
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|rfq
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* follow-up article */
case|case
literal|'f'
case|:
name|followup_command
argument_list|()
expr_stmt|;
break|break;
comment|/* erase - pretend we haven't seen this article. */
case|case
literal|'e'
case|:
if|if
condition|(
name|rfq
operator|||
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
condition|)
block|{
name|i
operator|=
name|bit
expr_stmt|;
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|selectng
argument_list|(
name|ogroupdir
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|oobit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Holding article %d newsgroup %s\n"
argument_list|,
name|oobit
argument_list|,
name|ogroupdir
argument_list|)
operator|,
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
expr_stmt|;
name|selectng
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
name|bit
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Holding article %d\n"
argument_list|,
name|oobit
argument_list|)
operator|,
name|set
argument_list|(
name|oobit
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Holding article %d\n"
argument_list|,
name|bit
argument_list|)
operator|,
name|set
argument_list|(
name|bit
argument_list|)
expr_stmt|;
goto|goto
name|caseplus
goto|;
comment|/* skip this article for now */
block|}
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
if|if
condition|(
operator|!
name|hflag
condition|)
name|dash
argument_list|(
literal|8
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|oobit
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article %d:\n"
argument_list|,
name|oobit
argument_list|)
expr_stmt|;
name|hprint
argument_list|(
operator|&
name|hbuf1
argument_list|,
name|ofp
argument_list|,
literal|1
operator|+
operator|(
name|i
operator|==
literal|'H'
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article %d of %ld: %s\n"
argument_list|,
name|rfq
condition|?
name|oobit
else|:
name|bit
argument_list|,
name|pngsize
argument_list|,
name|h
operator|.
name|ident
argument_list|)
expr_stmt|;
name|hprint
argument_list|(
operator|&
name|h
argument_list|,
name|ofp
argument_list|,
literal|1
operator|+
operator|(
name|i
operator|==
literal|'H'
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hflag
condition|)
name|dash
argument_list|(
literal|8
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article %d of %ld: newsgroup %s\n"
argument_list|,
name|rfq
condition|?
name|oobit
else|:
name|bit
argument_list|,
name|pngsize
argument_list|,
name|rfq
condition|?
name|ogroupdir
else|:
name|groupdir
argument_list|)
expr_stmt|;
break|break;
comment|/* error */
case|case
literal|'?'
case|:
name|help
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"? for commands.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|cancel_command
argument_list|()
end_macro

begin_block
block|{
name|tfilename
operator|=
name|filename
expr_stmt|;
name|hptr
operator|=
operator|&
name|h
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
name|ofilename1
condition|)
block|{
name|tfilename
operator|=
name|ofilename1
expr_stmt|;
name|hptr
operator|=
operator|&
name|hbuf1
expr_stmt|;
block|}
name|bptr
operator|++
expr_stmt|;
block|}
name|EOL
argument_list|()
expr_stmt|;
name|readmode
operator|=
name|SPEC
expr_stmt|;
name|strcpy
argument_list|(
name|rcbuf
argument_list|,
name|hptr
operator|->
name|path
argument_list|)
expr_stmt|;
name|ptr1
operator|=
name|index
argument_list|(
name|rcbuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr1
condition|)
operator|*
name|ptr1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uid
operator|==
name|ROOTID
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* root gets to cancel */
else|else
name|i
operator|=
name|strcmp
argument_list|(
name|username
argument_list|,
name|rcbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Can't cancel what you didn't write.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|cancel
argument_list|(
name|ofp
argument_list|,
name|hptr
argument_list|,
name|i
argument_list|)
operator|&&
name|hptr
operator|==
operator|&
name|h
condition|)
block|{
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|reply_command
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|pathptr
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|int
name|edit
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|ed
decl_stmt|;
name|FILE
modifier|*
name|tfp
decl_stmt|;
name|char
name|curberk
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|replyname
parameter_list|()
function_decl|;
name|char
name|subj
index|[
literal|100
index|]
decl_stmt|;
name|char
name|folbuf
index|[
literal|100
index|]
decl_stmt|;
specifier|extern
name|char
name|MAILPARSER
index|[]
decl_stmt|;
name|hptr
operator|=
operator|&
name|h
expr_stmt|;
while|while
condition|(
operator|*
name|bptr
operator|&&
name|index
argument_list|(
literal|"d-"
argument_list|,
operator|*
name|bptr
argument_list|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|bptr
condition|)
block|{
comment|/* Followup the previous article. */
case|case
literal|'-'
case|:
name|hptr
operator|=
operator|&
name|hbuf1
expr_stmt|;
break|break;
comment|/* Don't edit the headers */
case|case
literal|'d'
case|:
name|edit
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|bptr
operator|++
expr_stmt|;
block|}
name|EOL
argument_list|()
expr_stmt|;
if|if
condition|(
name|edit
operator|&&
name|access
argument_list|(
name|MAILPARSER
argument_list|,
literal|1
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|IHCC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't edit headers, 'recmail' missing.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't edit headers without %s\n"
argument_list|,
name|MAILPARSER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|edit
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|rcbuf
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|curberk
operator|=
literal|'\0'
expr_stmt|;
name|pathptr
operator|=
name|replyname
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
empty_stmt|;
name|ptr
operator|=
name|pathptr
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ptr1
operator|=
name|address
operator|,
name|ptr2
operator|=
name|pathptr
init|;
operator|*
name|ptr2
condition|;
name|ptr1
operator|++
operator|,
name|ptr2
operator|++
control|)
block|{
if|if
condition|(
name|index
argument_list|(
literal|"\"\\$"
argument_list|,
operator|*
name|ptr2
argument_list|)
condition|)
operator|*
name|ptr1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|ptr1
operator|=
operator|*
name|ptr2
expr_stmt|;
block|}
operator|*
name|ptr1
operator|=
literal|'\0'
expr_stmt|;
name|folbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* References */
if|if
condition|(
name|hptr
operator|->
name|followid
index|[
literal|0
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|folbuf
argument_list|,
name|hptr
operator|->
name|followid
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|folbuf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|folbuf
argument_list|,
name|hptr
operator|->
name|ident
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|subj
argument_list|,
name|hptr
operator|->
name|title
argument_list|)
expr_stmt|;
comment|/* Subject */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|bptr
argument_list|)
condition|)
name|bptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|!=
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|subj
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
argument_list|(
name|subj
argument_list|,
literal|"Re:"
argument_list|)
operator|&&
operator|!
name|prefix
argument_list|(
name|subj
argument_list|,
literal|"re:"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|subj
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|subj
argument_list|,
literal|"Re: %s"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|edit
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|pathptr
argument_list|)
expr_stmt|;
name|ed
operator|=
name|index
argument_list|(
name|MAILER
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|&&
name|ed
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subj
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
block|}
comment|/* Put the user in the editor to create the body of the followup. */
if|if
condition|(
name|edit
condition|)
block|{
name|strcpy
argument_list|(
name|tf
argument_list|,
name|tft
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|ed
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|NULL
condition|)
name|ed
operator|=
name|DFTEDITOR
expr_stmt|;
name|tfp
operator|=
name|fopen
argument_list|(
name|tf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|pathptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subj
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"References: %s\n\n"
argument_list|,
name|folbuf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|edcmdbuf
argument_list|,
literal|"%s %s"
argument_list|,
name|ed
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|edcmdbuf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rcbuf
argument_list|,
name|MAILPARSER
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rcbuf
argument_list|,
literal|" -t"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rcbuf
argument_list|,
literal|"< "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rcbuf
argument_list|,
name|tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|tf
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reply not sent: no input file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Sending reply.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
name|system
argument_list|(
name|rcbuf
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
name|MAILER
argument_list|,
name|hptr
operator|->
name|title
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s %s"
argument_list|,
name|rcbuf
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
name|hdr
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|xmit_command
argument_list|()
end_macro

begin_block
block|{
name|tfilename
operator|=
name|filename
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
name|ofilename1
condition|)
name|tfilename
operator|=
name|ofilename1
expr_stmt|;
name|bptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bptr
operator|!=
literal|'\0'
operator|&&
operator|*
name|bptr
operator|!=
literal|' '
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Bad system name.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|*
name|bptr
operator|==
literal|' '
condition|)
name|bptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Missing system name.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|s_find
argument_list|(
operator|&
name|srec
argument_list|,
name|bptr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%s not in SYSFILE\n"
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|transmit
argument_list|(
operator|&
name|srec
argument_list|,
name|tfilename
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|next_ng_command
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
operator|*
name|bptr
operator|||
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
condition|)
name|actdirect
operator|=
name|BACKWARD
expr_stmt|;
name|rfq
operator|=
literal|0
expr_stmt|;
name|saveart
expr_stmt|;
if|if
condition|(
name|nextng
argument_list|()
condition|)
block|{
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Can't back up.\n"
argument_list|)
expr_stmt|;
else|else
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|bptr
argument_list|)
condition|)
name|bptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|validng
argument_list|(
name|bptr
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"No such group.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|readmode
operator|=
name|SPEC
expr_stmt|;
name|rfq
operator|=
literal|0
expr_stmt|;
name|saveart
expr_stmt|;
name|back
argument_list|()
expr_stmt|;
name|selectng
argument_list|(
name|bptr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|followup_command
argument_list|()
end_macro

begin_block
block|{
name|int
name|edit
init|=
literal|1
decl_stmt|;
name|char
name|subj
index|[
literal|100
index|]
decl_stmt|;
name|char
name|folbuf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|ng
decl_stmt|;
name|FILE
modifier|*
name|tfp
decl_stmt|;
name|hptr
operator|=
operator|&
name|h
expr_stmt|;
while|while
condition|(
operator|*
name|bptr
operator|&&
name|index
argument_list|(
literal|"d-"
argument_list|,
operator|*
name|bptr
argument_list|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|bptr
condition|)
block|{
comment|/* Followup the previous article. */
case|case
literal|'-'
case|:
name|hptr
operator|=
operator|&
name|hbuf1
expr_stmt|;
break|break;
comment|/* Don't edit the headers */
case|case
literal|'d'
case|:
name|edit
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|bptr
operator|++
expr_stmt|;
block|}
comment|/* Figure out the subject, newsgroups, and references for the followup. */
name|ng
operator|=
name|hptr
operator|->
name|nbuf
expr_stmt|;
comment|/* Newsgroups */
if|if
condition|(
name|hptr
operator|->
name|followto
index|[
literal|0
index|]
condition|)
name|ng
operator|=
name|hptr
operator|->
name|followto
expr_stmt|;
name|launder
argument_list|(
name|ng
argument_list|)
expr_stmt|;
name|folbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* References */
if|if
condition|(
name|hptr
operator|->
name|followid
index|[
literal|0
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|folbuf
argument_list|,
name|hptr
operator|->
name|followid
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|folbuf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|folbuf
argument_list|,
name|hptr
operator|->
name|ident
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|subj
argument_list|,
name|hptr
operator|->
name|title
argument_list|)
expr_stmt|;
comment|/* Subject */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|bptr
argument_list|)
condition|)
name|bptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|!=
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|subj
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
argument_list|(
name|subj
argument_list|,
literal|"Re:"
argument_list|)
operator|&&
operator|!
name|prefix
argument_list|(
name|subj
argument_list|,
literal|"re:"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|subj
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|subj
argument_list|,
literal|"Re: %s"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
block|}
comment|/* Determine the command line for the shell. */
if|if
condition|(
name|edit
condition|)
block|{
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s -h -D"
argument_list|,
name|FOLLOWUP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s -D -F '%s' -n %s -t \'"
argument_list|,
name|FOLLOWUP
argument_list|,
name|folbuf
argument_list|,
name|ng
argument_list|)
expr_stmt|;
name|strqcat
argument_list|(
name|bfr
argument_list|,
name|subj
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bfr
argument_list|,
literal|"\'"
argument_list|)
expr_stmt|;
block|}
comment|/* backslash special characters */
for|for
control|(
name|ptr1
operator|=
name|rcbuf
operator|,
name|ptr2
operator|=
name|bfr
init|;
operator|*
name|ptr2
condition|;
name|ptr1
operator|++
operator|,
name|ptr2
operator|++
control|)
block|{
if|if
condition|(
name|index
argument_list|(
literal|"\\"
argument_list|,
operator|*
name|ptr2
argument_list|)
condition|)
operator|*
name|ptr1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|ptr1
operator|=
operator|*
name|ptr2
expr_stmt|;
block|}
operator|*
name|ptr1
operator|=
literal|'\0'
expr_stmt|;
comment|/* Let the user know what's going on. */
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Posting followup article to network.  Please use\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"reply ('r') instead unless your article is of general\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"interest.  (To abort press BREAK.)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subj
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Newsgroups: %s\n"
argument_list|,
name|ng
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Hit<return> to continue, BREAK to abort: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
comment|/* Give the user a chance to hit BREAK and back out. */
name|hascaught
operator|=
literal|0
expr_stmt|;
name|oldsig
operator|=
operator|(
name|char
operator|*
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catchintr
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|edcmdbuf
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oldsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|hascaught
condition|)
return|return;
comment|/* Play obnoxious warnings, if necessary. */
if|if
condition|(
name|recording
argument_list|(
name|hptr
operator|->
name|nbuf
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* Put the user in the editor to create the body of the followup. */
name|ed
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|NULL
operator|||
operator|*
name|ed
operator|==
literal|'\0'
condition|)
name|ed
operator|=
name|DFTEDITOR
expr_stmt|;
if|if
condition|(
name|ed
condition|)
block|{
name|strcpy
argument_list|(
name|tf
argument_list|,
name|tft
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|fopen
argument_list|(
name|tf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit
condition|)
block|{
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"Newsgroups: %s\n"
argument_list|,
name|ng
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subj
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"References: %s\n"
argument_list|,
name|folbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hptr
operator|->
name|keywords
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"Keywords: %s\n"
argument_list|,
name|hptr
operator|->
name|keywords
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|edcmdbuf
argument_list|,
literal|"%s %s"
argument_list|,
name|ed
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|edcmdbuf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rcbuf
argument_list|,
literal|"< "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rcbuf
argument_list|,
name|tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|tf
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Article not posted: no input file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Posting article.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
name|system
argument_list|(
name|rcbuf
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|rcbuf
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|rcbuf
argument_list|)
expr_stmt|;
block|}
name|hdr
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|caesar_command
argument_list|()
end_macro

begin_block
block|{
name|char
name|temp
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|pp
init|=
name|bptr
decl_stmt|;
name|FILE
modifier|*
name|pfp
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Caesar decoding:\n"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|CAESAR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
condition|)
block|{
name|strcat
argument_list|(
name|temp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NLINES
argument_list|(
name|h
argument_list|,
name|fp
argument_list|)
operator|>
name|LNCNT
operator|&&
operator|*
name|PAGER
condition|)
block|{
name|strcat
argument_list|(
name|temp
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|PAGER
argument_list|)
expr_stmt|;
block|}
name|pfp
operator|=
name|popen
argument_list|(
name|temp
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|tprint
argument_list|(
name|fp
argument_list|,
name|pfp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|itsbeenseen
argument_list|(
name|h
operator|.
name|ident
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|pclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Show the user the tail, if any, of the message on file  * descriptor fd, and close fd.  The digester is considered,  * and the pager is used if appropriate.  */
end_comment

begin_macro
name|showtail
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dgest
condition|)
block|{
name|digest
argument_list|(
name|fd
argument_list|,
name|ofp
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|lflag
operator|&&
operator|!
name|pflag
operator|&&
operator|!
name|eflag
condition|)
block|{
ifdef|#
directive|ifdef
name|PAGE
comment|/* Filter the tail of long messages through PAGER. */
if|if
condition|(
name|NLINES
argument_list|(
name|h
argument_list|,
name|fd
argument_list|)
operator|>
name|LNCNT
operator|&&
operator|*
name|PAGER
condition|)
block|{
if|if
condition|(
operator|!
name|index
argument_list|(
name|PAGER
argument_list|,
name|FMETA
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|pfp
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|pfp
operator|=
name|popen
argument_list|(
name|PAGER
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
name|pfp
operator|=
name|ofp
expr_stmt|;
comment|/* 				 * What follows is an attempt to prevent the 				 * next message from scrolling part of this 				 * message off the top of the screen before 				 * the poor luser can read it. 				 */
name|tprint
argument_list|(
name|fd
argument_list|,
name|pfp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|itsbeenseen
argument_list|(
name|h
operator|.
name|ident
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
block|}
else|else
name|pout
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOCOLON
name|holdup
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
endif|NOCOLON
block|}
else|else
endif|#
directive|endif
name|tprint
argument_list|(
name|fd
argument_list|,
name|ofp
argument_list|,
name|FALSE
argument_list|)
operator|,
name|itsbeenseen
argument_list|(
name|h
operator|.
name|ident
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Find the next article we want to consider, if we're done with  * the last one, and show the header.  */
end_comment

begin_macro
name|getnextart
argument_list|(
argument|minus
argument_list|)
end_macro

begin_decl_stmt
name|int
name|minus
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|minus
condition|)
goto|goto
name|nextart2
goto|;
comment|/* Kludge for "-" command. */
if|if
condition|(
name|bit
operator|==
name|obit
condition|)
comment|/* Return if still on same article as last time */
return|return
literal|0
return|;
name|sigtrap
operator|=
name|FALSE
expr_stmt|;
name|nextart
label|:
name|dgest
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bit
operator|<
literal|1
operator|&&
operator|!
name|rflag
condition|)
name|bit
operator|=
literal|1
expr_stmt|;
comment|/* If done with this newsgroup, find the next one. */
while|while
condition|(
operator|(
operator|(
name|long
operator|)
name|bit
operator|>
name|ngsize
operator|)
operator|||
operator|(
name|rflag
operator|&&
name|bit
operator|<
literal|1
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|i
operator|=
name|nextng
argument_list|()
condition|)
block|{
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Can't back up.\n"
argument_list|)
expr_stmt|;
name|actdirect
operator|=
name|FORWARD
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rfq
operator|++
operator|||
name|pflag
operator|||
name|cflag
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|rflag
condition|)
name|bit
operator|=
name|ngsize
operator|+
literal|1L
expr_stmt|;
else|else
name|bit
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|uflag
condition|)
block|{
name|long
name|now
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|timelastsaved
operator|>
literal|5
operator|*
literal|60
comment|/* 5 minutes */
condition|)
block|{
name|printf
argument_list|(
literal|"[Saving .newsrc]\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|writeoutrc
argument_list|()
expr_stmt|;
name|timelastsaved
operator|=
name|now
expr_stmt|;
block|}
block|}
block|}
name|nextart2
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"article: %s/%d\n"
argument_list|,
name|groupdir
argument_list|,
name|bit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rcreadok
condition|)
name|rcreadok
operator|=
literal|2
expr_stmt|;
comment|/* have seen>= 1 article */
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/%d"
argument_list|,
name|dirname
argument_list|(
name|groupdir
argument_list|)
argument_list|,
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfq
operator|&&
name|goodone
index|[
literal|0
index|]
condition|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|goodone
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigtrap
condition|)
block|{
if|if
condition|(
name|sigtrap
operator|==
name|SIGHUP
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|rcreadok
condition|)
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Abort (n)?  "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bfr
operator|==
literal|'y'
operator|||
operator|*
name|bfr
operator|==
literal|'Y'
condition|)
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sigtrap
operator|=
name|FALSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"filename = '%s'\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Decide if we want to show this article. */
if|if
condition|(
name|ignorenews
operator|||
name|access
argument_list|(
name|filename
argument_list|,
literal|4
argument_list|)
operator|||
operator|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hread
argument_list|(
operator|&
name|h
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
name|rfq
operator|&&
operator|!
name|select
argument_list|(
operator|&
name|h
argument_list|,
name|abs
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad article '%s'\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
name|abs
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|nextart
goto|;
block|}
name|abs
operator|=
name|FALSE
expr_stmt|;
name|actdirect
operator|=
name|FORWARD
expr_stmt|;
name|news
operator|=
name|TRUE
expr_stmt|;
name|hdr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&&
operator|!
name|lflag
operator|&&
operator|!
name|eflag
operator|)
operator|||
name|pflag
condition|)
name|tprint
argument_list|(
name|fp
argument_list|,
name|ofp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|&&
name|lflag
operator|&&
name|eflag
operator|||
name|pflag
condition|)
block|{
name|itsbeenseen
argument_list|(
name|h
operator|.
name|ident
argument_list|)
expr_stmt|;
name|sigtrap
operator|=
name|FALSE
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|obit
operator|=
name|bit
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Print out whatever the appropriate header is  */
end_comment

begin_macro
name|hdr
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|rfq
condition|)
return|return;
ifndef|#
directive|ifndef
name|NOCOLON
comment|/* Wait for user to read previous article. */
if|if
condition|(
name|holdup
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|holdup
operator|=
name|FALSE
expr_stmt|;
name|bfr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|gets
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfr
index|[
literal|0
index|]
condition|)
name|explaincolon
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
endif|NOCOLON
if|if
condition|(
name|lflag
operator|||
name|eflag
condition|)
block|{
name|hprint
argument_list|(
operator|&
name|h
argument_list|,
name|ofp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Print out a header */
if|if
condition|(
name|ngrp
condition|)
block|{
name|pngsize
operator|=
name|ngsize
expr_stmt|;
name|ngrp
operator|--
expr_stmt|;
name|nghprint
argument_list|(
name|groupdir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hflag
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article %d of %ld, %s.\n"
argument_list|,
name|bit
argument_list|,
name|pngsize
argument_list|,
name|briefdate
argument_list|(
name|h
operator|.
name|subdate
argument_list|)
argument_list|)
expr_stmt|;
name|hprint
argument_list|(
operator|&
name|h
argument_list|,
name|ofp
argument_list|,
name|pflag
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|explaincolon
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|calledbefore
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n'%s' ignored.\n"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|calledbefore
operator|++
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"The colon is to give you a chance to finish reading the\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"previous article before the next header scrolls it off\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"the top of the screen.  You should hit `return' or `newline'\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"when you are ready to go on to the next article.\n\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nghprint
argument_list|(
argument|title
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|title
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|tstr
init|=
literal|"Newsgroup "
decl_stmt|;
name|int
name|l
init|=
name|strlen
argument_list|(
name|title
argument_list|)
operator|+
name|strlen
argument_list|(
name|tstr
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
condition|)
block|{
name|dash
argument_list|(
name|l
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%s%s\n"
argument_list|,
name|tstr
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|dash
argument_list|(
name|l
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%s%s, "
argument_list|,
name|tstr
argument_list|,
name|title
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|==
name|pngsize
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%ld\n"
argument_list|,
name|pngsize
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%d-%ld\n"
argument_list|,
name|bit
argument_list|,
name|pngsize
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Routine to catch a continue signal.  */
end_comment

begin_macro
name|catchcont
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|SIGCONT
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|catchcont
argument_list|)
expr_stmt|;
name|sigtrap
operator|=
name|SIGCONT
expr_stmt|;
endif|#
directive|endif
name|hdr
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

