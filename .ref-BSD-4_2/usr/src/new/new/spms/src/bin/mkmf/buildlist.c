begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header$ */
end_comment

begin_comment
comment|/*  * Author: Peter J. Nicklin  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"Mkmf.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"null.h"
end_include

begin_include
include|#
directive|include
file|"path.h"
end_include

begin_include
include|#
directive|include
file|"slist.h"
end_include

begin_include
include|#
directive|include
file|"suffix.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"yesno.h"
end_include

begin_comment
comment|/*  * buftolist() copies the items from a buffer to a singly-linked list.  * Returns integer YES if successful, otherwise NO.  */
end_comment

begin_macro
name|buftolist
argument_list|(
argument|buf
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* item buffer */
end_comment

begin_decl_stmt
name|SLIST
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receiving list */
end_comment

begin_block
block|{
name|char
modifier|*
name|gettoken
parameter_list|()
function_decl|;
comment|/* get next token */
name|char
modifier|*
name|slappend
parameter_list|()
function_decl|;
comment|/* append file name to list */
name|char
name|token
index|[
name|MAXNAMLEN
index|]
decl_stmt|;
comment|/* item buffer */
while|while
condition|(
operator|(
name|buf
operator|=
name|gettoken
argument_list|(
name|token
argument_list|,
name|buf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|slappend
argument_list|(
name|token
argument_list|,
name|list
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * buildliblist() reads library pathnames from the LIBLIST macro  * definition, and adds them to the library pathname list. Libraries  * may be specified as `-lx'. Returns integer YES if successful,  * otherwise NO.  */
end_comment

begin_macro
name|buildliblist
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|SLIST
modifier|*
name|LIBLIST
decl_stmt|;
comment|/* library pathname list */
specifier|extern
name|HASH
modifier|*
name|MDEFTABLE
decl_stmt|;
comment|/* macro definition table */
name|HASHBLK
modifier|*
name|htb
decl_stmt|;
comment|/* hash table block */
name|HASHBLK
modifier|*
name|htlookup
parameter_list|()
function_decl|;
comment|/* find hash table entry */
name|int
name|libbuftolist
parameter_list|()
function_decl|;
comment|/* load library pathnames into list */
name|SLIST
modifier|*
name|slinit
parameter_list|()
function_decl|;
comment|/* initialize singly-linked list */
name|void
name|htrm
parameter_list|()
function_decl|;
comment|/* remove hash table entry */
name|LIBLIST
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|htb
operator|=
name|htlookup
argument_list|(
name|MLIBLIST
argument_list|,
name|MDEFTABLE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIBLIST
operator|=
name|slinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|libbuftolist
argument_list|(
name|htb
operator|->
name|h_def
argument_list|,
name|LIBLIST
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
name|htrm
argument_list|(
name|MLIBLIST
argument_list|,
name|MDEFTABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * buildsrclist() takes source and header file names from command line  * macro definitions or the current directory and appends them to source  * or header file name lists as appropriate. Returns integer YES if  * if successful, otherwise NO.  */
end_comment

begin_macro
name|buildsrclist
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|HASH
modifier|*
name|MDEFTABLE
decl_stmt|;
comment|/* macro definition table */
specifier|extern
name|SLIST
modifier|*
name|HEADLIST
decl_stmt|;
comment|/* header file name list */
specifier|extern
name|SLIST
modifier|*
name|SRCLIST
decl_stmt|;
comment|/* source file name list */
name|char
modifier|*
name|slappend
parameter_list|()
function_decl|;
comment|/* append file name to list */
name|HASHBLK
modifier|*
name|headhtb
decl_stmt|;
comment|/* HEADERS macro hash table block */
name|HASHBLK
modifier|*
name|htlookup
parameter_list|()
function_decl|;
comment|/* find hash table entry */
name|HASHBLK
modifier|*
name|srchtb
decl_stmt|;
comment|/* SOURCE macro hash table block */
name|int
name|buftolist
parameter_list|()
function_decl|;
comment|/* copy items from buffer to list */
name|int
name|needheaders
init|=
literal|1
decl_stmt|;
comment|/* need header file names */
name|int
name|needsource
init|=
literal|1
decl_stmt|;
comment|/* need source file names */
name|int
name|read_dir
parameter_list|()
function_decl|;
comment|/* read dir for source and headers */
name|int
name|slsort
parameter_list|()
function_decl|;
comment|/* sort singly-linked list */
name|int
name|strcmp
parameter_list|()
function_decl|;
comment|/* string comparison */
name|SLIST
modifier|*
name|slinit
parameter_list|()
function_decl|;
comment|/* initialize singly-linked list */
name|HEADLIST
operator|=
name|slinit
argument_list|()
expr_stmt|;
name|SRCLIST
operator|=
name|slinit
argument_list|()
expr_stmt|;
comment|/* build lists from command line macro definitions */
if|if
condition|(
operator|(
name|headhtb
operator|=
name|htlookup
argument_list|(
name|MHEADERS
argument_list|,
name|MDEFTABLE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buftolist
argument_list|(
name|headhtb
operator|->
name|h_def
argument_list|,
name|HEADLIST
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
name|needheaders
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|srchtb
operator|=
name|htlookup
argument_list|(
name|MSOURCE
argument_list|,
name|MDEFTABLE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buftolist
argument_list|(
name|srchtb
operator|->
name|h_def
argument_list|,
name|SRCLIST
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
name|needsource
operator|--
expr_stmt|;
block|}
comment|/* read the current directory to get source and header file names */
if|if
condition|(
name|needheaders
operator|||
name|needsource
condition|)
if|if
condition|(
name|read_dir
argument_list|(
name|needheaders
argument_list|,
name|needsource
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
name|slsort
argument_list|(
name|strcmp
argument_list|,
name|SRCLIST
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
name|slsort
argument_list|(
name|strcmp
argument_list|,
name|HEADLIST
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * expandlibpath() converts a library file specified by `-lx' into a full  * pathname. /lib and /usr/lib are searched for the library in the form  * libx.a. An integer YES is returned if the library was found, otherwise NO.  * A library file which doesn't begin with `-' is left unchanged.  */
end_comment

begin_macro
name|expandlibpath
argument_list|(
argument|libpath
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|libpath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* library pathname buffer */
end_comment

begin_block
block|{
name|char
modifier|*
name|lib
decl_stmt|;
comment|/* /lib library pathname template */
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
comment|/* string copy */
name|char
modifier|*
name|usrlib
decl_stmt|;
comment|/* /usr/lib library pathname template */
name|int
name|i
decl_stmt|;
comment|/* library pathname index */
name|lib
operator|=
literal|"/lib/libxxxxxxxxxxxxxxxxxxxxxxxxx"
expr_stmt|;
name|usrlib
operator|=
literal|"/usr/lib/libxxxxxxxxxxxxxxxxxxxxxxxxx"
expr_stmt|;
if|if
condition|(
name|libpath
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|libpath
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|libpath
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|'\0'
operator|&&
name|i
operator|<
literal|22
condition|;
name|i
operator|++
control|)
block|{
name|lib
index|[
name|i
operator|+
literal|8
index|]
operator|=
name|libpath
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|usrlib
index|[
name|i
operator|+
literal|12
index|]
operator|=
name|libpath
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
name|lib
index|[
name|i
operator|+
literal|8
index|]
operator|=
name|usrlib
index|[
name|i
operator|+
literal|12
index|]
operator|=
literal|'.'
expr_stmt|;
name|lib
index|[
name|i
operator|+
literal|9
index|]
operator|=
name|usrlib
index|[
name|i
operator|+
literal|13
index|]
operator|=
literal|'a'
expr_stmt|;
name|lib
index|[
name|i
operator|+
literal|10
index|]
operator|=
name|usrlib
index|[
name|i
operator|+
literal|14
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|FILEXIST
argument_list|(
name|lib
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|libpath
argument_list|,
name|lib
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|FILEXIST
argument_list|(
name|usrlib
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|libpath
argument_list|,
name|usrlib
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
else|else
return|return
operator|(
name|NO
operator|)
return|;
block|}
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * libbuftolist() appends each library pathname specified in libbuf to  * the liblist library pathname list.  */
end_comment

begin_macro
name|libbuftolist
argument_list|(
argument|libbuf
argument_list|,
argument|liblist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|libbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* library pathname buffer */
end_comment

begin_decl_stmt
name|SLIST
modifier|*
name|liblist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* library pathname list */
end_comment

begin_block
block|{
name|char
modifier|*
name|gettoken
parameter_list|()
function_decl|;
comment|/* get next token */
name|char
name|libpath
index|[
name|PATHSIZE
index|]
decl_stmt|;
comment|/* library file pathname */
name|char
modifier|*
name|slappend
parameter_list|()
function_decl|;
comment|/* append file name to list */
name|int
name|expandlibpath
parameter_list|()
function_decl|;
comment|/* -lx -> full library pathname */
while|while
condition|(
operator|(
name|libbuf
operator|=
name|gettoken
argument_list|(
name|libpath
argument_list|,
name|libbuf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|expandlibpath
argument_list|(
name|libpath
argument_list|)
operator|==
name|NO
condition|)
block|{
name|warn
argument_list|(
literal|"can't find library %s"
argument_list|,
name|libpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
if|if
condition|(
name|slappend
argument_list|(
name|libpath
argument_list|,
name|liblist
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * read_dir() reads filenames from the current directory and adds them  * to the source or header file name lists as appropriate. Returns  * integer YES if successful, otherwise NO.  */
end_comment

begin_macro
name|read_dir
argument_list|(
argument|needheaders
argument_list|,
argument|needsource
argument_list|)
end_macro

begin_decl_stmt
name|int
name|needheaders
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need header file names */
end_comment

begin_decl_stmt
name|int
name|needsource
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need source file names */
end_comment

begin_block
block|{
specifier|extern
name|SLIST
modifier|*
name|HEADLIST
decl_stmt|;
comment|/* header file name list */
specifier|extern
name|SLIST
modifier|*
name|SRCLIST
decl_stmt|;
comment|/* source file name list */
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
comment|/* find last occurrence of character */
name|char
modifier|*
name|slappend
parameter_list|()
function_decl|;
comment|/* append file name to list */
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* pointer to file name suffix */
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* directory stream */
name|DIR
modifier|*
name|opendir
parameter_list|()
function_decl|;
comment|/* open directory stream */
name|int
name|lookupsfx
parameter_list|()
function_decl|;
comment|/* get suffix type */
name|int
name|sfxtyp
decl_stmt|;
comment|/* type of suffix */
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
comment|/* directory entry pointer */
name|struct
name|direct
modifier|*
name|readdir
parameter_list|()
function_decl|;
comment|/* read a directory entry */
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|CURDIR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"can't open current directory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
for|for
control|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
control|)
if|if
condition|(
operator|(
name|suffix
operator|=
name|rindex
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|suffix
operator|++
expr_stmt|;
name|sfxtyp
operator|=
name|lookupsfx
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfxtyp
operator|==
name|SFXSRC
condition|)
block|{
if|if
condition|(
name|needsource
condition|)
if|if
condition|(
name|slappend
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|SRCLIST
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sfxtyp
operator|==
name|SFXHEAD
condition|)
block|{
if|if
condition|(
name|needheaders
condition|)
if|if
condition|(
name|slappend
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|HEADLIST
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

end_unit

