begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS revision generation  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/wft/RCS/SRC/RCS/rcsgen.c,v 3.3 82/11/28 21:36:49 wft Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************************************  *********************************************************************************  *  * Copyright (C) 1982 by Walter F. Tichy  *                       Purdue University  *                       Computer Science Department  *                       West Lafayette, IN 47907  *  * All rights reserved. No part of this software may be sold or distributed  * in any form or by any means without the prior written permission of the  * author.  * Report problems and direct all inquiries to Tichy@purdue (ARPA net).  */
end_comment

begin_comment
comment|/* $Log:	rcsgen.c,v $  * Revision 3.3  82/11/28  21:36:49  wft  * Replaced ferror() followed by fclose() with ffclose().  * Putdesc() now suppresses the prompts if stdin  * is not a terminal. A pointer to the current log message is now  * inserted into the corresponding delta, rather than leaving it in a  * global variable.  *   * Revision 3.2  82/10/18  21:11:26  wft  * I added checks for write errors during editing, and improved  * the prompt on putdesc().  *  * Revision 3.1  82/10/13  15:55:09  wft  * corrected type of variables assigned to by getc (char --> int)  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|getnum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern savestring(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|genrevs
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern editstring(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|int
name|nextc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next character from lexical analyzer          */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|RCSfilename
decl_stmt|,
modifier|*
name|workfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|hshentry
modifier|*
name|targetdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delta to be generated              */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Ktext
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keywords from syntax analyzer                 */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Klog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keyword "log"                                 */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Kdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keyword for description                       */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RCS input file                                */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new RCS file                                  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|fcopy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result file during editing                    */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|fedit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* edit file                                     */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|resultfile
decl_stmt|,
modifier|*
name|editfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file names for fcopy and fedit       */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rewriteflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether to rewrite the input file   */
end_comment

begin_decl_stmt
name|char
name|curlogmsg
index|[
name|logsize
index|]
comment|/* buffer for current log message                */
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|stringwork
block|{
name|copy
block|,
name|edit
block|,
name|expand
block|,
name|edit_expand
block|}
enum|;
end_enum

begin_comment
comment|/* parameter to scandeltatext() */
end_comment

begin_function
name|char
modifier|*
name|buildrevision
parameter_list|(
name|deltas
parameter_list|,
name|target
parameter_list|,
name|dir
parameter_list|,
name|expandflag
parameter_list|)
name|struct
name|hshentry
modifier|*
modifier|*
name|deltas
decl_stmt|,
decl|*
name|target
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expandflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Generates the revision given by target  * by retrieving all deltas given by parameter deltas and combining them.  * If dir==nil, the revision is printed on the standard output,  * otherwise written into a temporary file in directory dir.  * if expandflag==true, keyword expansion is performed.  * returns false on errors, the name of the file with the revision otherwise.  *  * Algorithm: Copy inital revision unchanged. Then edit all revisions but  * the last one into it, alternating input and output files (resultfile and  * editfile). The last revision is then edited in, performing simultaneous  * keyword substitution (this saves one extra pass).  * All this simplifies if only one revision needs to be generated,  * or no keyword expansion is necessary, or if output goes to stdout.  */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|deltas
index|[
literal|0
index|]
operator|==
name|target
condition|)
block|{
comment|/* only latest revision to generate */
if|if
condition|(
name|dir
operator|==
name|nil
condition|)
block|{
comment|/* print directly to stdout */
name|fcopy
operator|=
name|stdout
expr_stmt|;
name|scandeltatext
argument_list|(
name|target
argument_list|,
name|expand
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|true
return|;
block|}
else|else
block|{
name|initeditfiles
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|scandeltatext
argument_list|(
name|target
argument_list|,
name|expandflag
condition|?
name|expand
else|:
name|copy
argument_list|)
expr_stmt|;
name|ffclose
argument_list|(
name|fcopy
argument_list|)
expr_stmt|;
return|return
operator|(
name|resultfile
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* several revisions to generate */
name|initeditfiles
argument_list|(
name|dir
condition|?
name|dir
else|:
literal|"/tmp/"
argument_list|)
expr_stmt|;
comment|/* write initial revision into fcopy, no keyword expansion */
name|scandeltatext
argument_list|(
name|deltas
index|[
literal|0
index|]
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|deltas
index|[
name|i
operator|+
literal|1
index|]
operator|!=
name|nil
condition|)
block|{
comment|/* do all deltas except last one */
name|scandeltatext
argument_list|(
name|deltas
index|[
name|i
operator|++
index|]
argument_list|,
name|edit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|expandflag
condition|)
block|{
comment|/* no keyword expansion; only invoked from ci */
name|scandeltatext
argument_list|(
name|deltas
index|[
name|i
index|]
argument_list|,
name|edit
argument_list|)
expr_stmt|;
name|finishedit
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|ffclose
argument_list|(
name|fcopy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* perform keyword expansion*/
comment|/* first, get to beginning of file*/
name|finishedit
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|swapeditfiles
argument_list|(
name|dir
operator|==
name|nil
argument_list|)
expr_stmt|;
name|scandeltatext
argument_list|(
name|deltas
index|[
name|i
index|]
argument_list|,
name|edit_expand
argument_list|)
expr_stmt|;
name|finishedit
argument_list|(
name|deltas
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|nil
condition|)
name|ffclose
argument_list|(
name|fcopy
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|resultfile
operator|)
return|;
comment|/*doesn't matter for dir==nil*/
block|}
block|}
end_block

begin_macro
name|scandeltatext
argument_list|(
argument|delta
argument_list|,
argument|func
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|stringwork
name|func
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Scans delta text nodes up to and including the one given  * by delta. For the one given by delta, the log message is saved into  * curlogmsg and the text is processed according to parameter func.  * Assumes the initial lexeme must be read in first.  * Does not advance nexttok after it is finished.  */
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|nextdelta
decl_stmt|;
do|do
block|{
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nextdelta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
block|{
name|fatserror
argument_list|(
literal|"Can't find delta for revision %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Klog
argument_list|)
operator|||
name|nexttok
operator|!=
name|STRING
condition|)
name|serror
argument_list|(
literal|"Missing log entry"
argument_list|)
expr_stmt|;
name|elsif
argument_list|(
argument|delta==nextdelta
argument_list|)
block|{
name|savestring
argument_list|(
name|curlogmsg
argument_list|,
name|logsize
argument_list|)
expr_stmt|;
name|delta
operator|->
name|log
operator|=
name|curlogmsg
expr_stmt|;
block|}
else|else
block|{
name|readstring
argument_list|()
expr_stmt|;
name|delta
operator|->
name|log
operator|=
literal|""
expr_stmt|;
block|}
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Ktext
argument_list|)
operator|||
name|nexttok
operator|!=
name|STRING
condition|)
name|fatserror
argument_list|(
literal|"Missing delta text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
name|nextdelta
condition|)
comment|/* got the one we're looking for */
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|copy
case|:
name|copystring
argument_list|()
expr_stmt|;
break|break;
case|case
name|expand
case|:
name|xpandstring
argument_list|(
name|delta
argument_list|)
expr_stmt|;
break|break;
case|case
name|edit
case|:
name|editstring
argument_list|(
name|nil
argument_list|)
expr_stmt|;
break|break;
case|case
name|edit_expand
case|:
name|editstring
argument_list|(
name|delta
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|readstring
argument_list|()
expr_stmt|;
comment|/* skip over it */
block|}
do|while
condition|(
name|delta
operator|!=
name|nextdelta
condition|)
do|;
block|}
end_block

begin_function
name|int
name|putdesc
parameter_list|(
name|initflag
parameter_list|,
name|textflag
parameter_list|,
name|textfile
parameter_list|,
name|quietflag
parameter_list|)
name|int
name|initflag
decl_stmt|,
name|textflag
decl_stmt|;
name|char
modifier|*
name|textfile
decl_stmt|;
name|int
name|quietflag
decl_stmt|;
comment|/* Function: puts the descriptive text into file frewrite.  * if !initflag&& !textflag, the text is simply copied from finptr.  * Otherwise, if the textfile!=nil, the text is read from that  * file, or from stdin, if textfile==nil.  * if initflag&&quietflag&&!textflag, an empty text is inserted.  * if !initflag, the old descriptive text is discarded.  * Returns true is successful, false otherwise.  */
block|{
name|FILE
modifier|*
name|txt
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|old1
decl_stmt|,
name|old2
decl_stmt|;
if|if
condition|(
operator|!
name|initflag
operator|&&
operator|!
name|textflag
condition|)
block|{
comment|/* copy old description */
name|fprintf
argument_list|(
name|frewrite
argument_list|,
literal|"\n\n%s%c"
argument_list|,
name|Kdesc
argument_list|,
name|nextc
argument_list|)
expr_stmt|;
name|rewriteflag
operator|=
name|true
expr_stmt|;
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
comment|/* get new description */
if|if
condition|(
operator|!
name|initflag
condition|)
block|{
comment|/*skip old description*/
name|rewriteflag
operator|=
name|false
expr_stmt|;
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|frewrite
argument_list|,
literal|"\n\n%s\n%c"
argument_list|,
name|Kdesc
argument_list|,
name|SDELIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|textfile
condition|)
block|{
name|old1
operator|=
literal|'\n'
expr_stmt|;
comment|/* copy textfile */
if|if
condition|(
operator|(
name|txt
operator|=
name|fopen
argument_list|(
name|textfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|txt
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
comment|/*double up*/
name|putc
argument_list|(
name|c
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|old1
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|old1
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txt
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|SDELIM
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Can't open file with description%s"
argument_list|,
name|textfile
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initflag
operator|&&
name|quietflag
condition|)
block|{
name|warn
argument_list|(
literal|"empty descriptive text"
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|SDELIM
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* read text from stdin */
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"enter description, terminated with ^D or '.':\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"NOTE: This is NOT the log message!\n>> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
literal|'\0'
expr_stmt|;
name|old2
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
operator|(
name|old1
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|old1
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|old1
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|old1
operator|==
literal|'.'
operator|&&
name|old2
operator|==
literal|'\n'
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
literal|">> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|old1
operator|==
name|SDELIM
condition|)
name|putc
argument_list|(
name|old1
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
comment|/* double up*/
name|putc
argument_list|(
name|old1
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|old2
operator|=
name|old1
expr_stmt|;
name|old1
operator|=
name|c
expr_stmt|;
block|}
comment|/* end for */
name|putc
argument_list|(
name|SDELIM
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
end_function

end_unit

