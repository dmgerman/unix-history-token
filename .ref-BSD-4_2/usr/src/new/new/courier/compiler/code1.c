begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)code1.c	4.2 (Berkeley) 9/27/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"Courier.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|program_name
init|=
literal|"Unknown"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|print_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for pretty-printing C code */
end_comment

begin_comment
comment|/*  * Return a printable representation of an object (number or string).  */
end_comment

begin_function
name|char
modifier|*
name|obj_rep
parameter_list|(
name|o
parameter_list|)
name|struct
name|object
modifier|*
name|o
decl_stmt|;
block|{
specifier|static
name|char
name|rep
index|[
name|MAXSTR
index|]
decl_stmt|;
switch|switch
condition|(
name|class_of
argument_list|(
name|o
argument_list|)
condition|)
block|{
case|case
name|O_CONSTANT
case|:
name|sprintf
argument_list|(
name|rep
argument_list|,
literal|"%d"
argument_list|,
name|o
operator|->
name|o_value
argument_list|)
expr_stmt|;
return|return
operator|(
name|rep
operator|)
return|;
case|case
name|O_SYMBOL
case|:
return|return
operator|(
name|o
operator|->
name|o_name
operator|)
return|;
default|default:
name|yyerror
argument_list|(
literal|"Internal error in obj_rep: bad object class"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_macro
name|program_header
argument_list|(
argument|symbol
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|object
modifier|*
name|symbol
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|program_name
operator|=
name|symbol
operator|->
name|o_name
expr_stmt|;
name|fprintf
argument_list|(
name|hf
argument_list|,
literal|"/*\n\  * Declarations for Courier program %s.\n\  */\n\ #include<courier.h>\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf1
argument_list|,
literal|"/*\n\  * Routines for Courier program %s.\n\  */\n\ #include \"%s.h\"\n"
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|uf
argument_list|,
literal|"/*\n\  * User access to Courier program %s.\n\  */\n\ #include \"%s_stubs.c\"\n"
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sf
argument_list|,
literal|"/*\n\  * Server for Courier program %s.\n\  */\n\ #include \"%s_stubs.c\"\n"
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explicit
condition|)
name|generate_binding_functions
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|pack_function
parameter_list|(
name|type
parameter_list|)
name|struct
name|object
modifier|*
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXSTR
index|]
decl_stmt|;
if|if
condition|(
name|class_of
argument_list|(
name|type
argument_list|)
operator|==
name|O_TYPE
condition|)
return|return
operator|(
name|type
operator|->
name|t_pfname
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Pack%s"
argument_list|,
name|type
operator|->
name|o_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|unpack_function
parameter_list|(
name|type
parameter_list|)
name|struct
name|object
modifier|*
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXSTR
index|]
decl_stmt|;
if|if
condition|(
name|class_of
argument_list|(
name|type
argument_list|)
operator|==
name|O_TYPE
condition|)
return|return
operator|(
name|type
operator|->
name|t_ufname
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unpack%s"
argument_list|,
name|type
operator|->
name|o_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate definitions for types.  */
end_comment

begin_macro
name|compile_type
argument_list|(
argument|symbol
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|object
modifier|*
name|symbol
decl_stmt|,
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|type
operator|->
name|t_constr
operator|==
name|C_PROCEDURE
operator|||
name|type
operator|->
name|t_constr
operator|==
name|C_ERROR
condition|)
return|return;
name|name
operator|=
name|symbol
operator|->
name|o_name
expr_stmt|;
name|fprintf
argument_list|(
name|hf
argument_list|,
literal|"\ntypedef "
argument_list|)
expr_stmt|;
name|print_decl
argument_list|(
name|hf
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf1
argument_list|,
literal|"\n#define Pack%s %s\n#define Unpack%s %s\n"
argument_list|,
name|name
argument_list|,
name|pack_function
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
name|unpack_function
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|declare
argument_list|(
operator|&
name|Values
argument_list|,
name|symbol
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Generate definitions corresponding to constant declarations.  */
end_comment

begin_macro
name|compile_def
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|object
modifier|*
name|name
decl_stmt|,
modifier|*
name|type
decl_stmt|,
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|object
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|basetype
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_constr
operator|==
name|C_PROCEDURE
condition|)
name|proc_functions
argument_list|(
name|name
operator|->
name|o_name
argument_list|,
name|t
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|hf
argument_list|,
literal|"\n#define %s %s\n"
argument_list|,
name|name
operator|->
name|o_name
argument_list|,
name|obj_rep
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|declare
argument_list|(
operator|&
name|Values
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|declare
argument_list|(
operator|&
name|Types
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print a C type declaration for a Courier type.  *  * If the nonewline flag is on, don't follow the declaration  * by ";\n" (used for declaring the return value of a function.)  */
end_comment

begin_macro
name|print_decl
argument_list|(
argument|f
argument_list|,
argument|name
argument_list|,
argument|type
argument_list|,
argument|nonewline
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|object
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nonewline
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list
name|p
decl_stmt|,
name|q
decl_stmt|;
name|struct
name|object
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|member
decl_stmt|;
name|char
name|newname
index|[
name|MAXSTR
index|]
decl_stmt|;
if|if
condition|(
name|class_of
argument_list|(
name|type
argument_list|)
operator|==
name|O_SYMBOL
condition|)
block|{
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s %s"
argument_list|,
name|type
operator|->
name|o_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|class_of
argument_list|(
name|type
argument_list|)
operator|!=
name|O_TYPE
condition|)
block|{
name|yyerror
argument_list|(
literal|"Internal error in print_decl: bad object class for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
operator|->
name|t_constr
condition|)
block|{
case|case
name|C_ENUMERATION
case|:
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"enum {\n"
argument_list|)
expr_stmt|;
name|print_level
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|t_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|q
operator|=
name|car
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|member
operator|=
name|name_of
argument_list|(
name|car
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s = %s"
argument_list|,
name|member
argument_list|,
name|obj_rep
argument_list|(
name|cdr
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|p
argument_list|)
operator|!=
name|NIL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|print_level
operator|--
expr_stmt|;
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"} %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C_ARRAY
case|:
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|"%s[%s]"
argument_list|,
name|name
argument_list|,
name|obj_rep
argument_list|(
name|type
operator|->
name|t_size
argument_list|)
argument_list|)
expr_stmt|;
name|print_decl
argument_list|(
name|f
argument_list|,
name|newname
argument_list|,
name|type
operator|->
name|t_basetype
argument_list|,
name|nonewline
argument_list|)
expr_stmt|;
return|return;
case|case
name|C_SEQUENCE
case|:
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"struct {\n"
argument_list|)
expr_stmt|;
name|print_level
operator|++
expr_stmt|;
name|print_decl
argument_list|(
name|f
argument_list|,
literal|"length"
argument_list|,
name|Cardinal_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_decl
argument_list|(
name|f
argument_list|,
literal|"*sequence"
argument_list|,
name|type
operator|->
name|t_basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_level
operator|--
expr_stmt|;
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"} %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C_RECORD
case|:
if|if
condition|(
name|type
operator|->
name|t_list
operator|==
name|NIL
condition|)
block|{
comment|/* C complains about this, but accepts it */
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"int %s[0]"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"struct {\n"
argument_list|)
expr_stmt|;
name|print_level
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|t_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|t
operator|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|cdr
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|car
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
control|)
name|print_decl
argument_list|(
name|f
argument_list|,
name|name_of
argument_list|(
name|car
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|print_level
operator|--
expr_stmt|;
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"} %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|C_CHOICE
case|:
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"struct {\n"
argument_list|)
expr_stmt|;
name|print_level
operator|++
expr_stmt|;
name|print_decl
argument_list|(
name|f
argument_list|,
literal|"designator"
argument_list|,
name|type
operator|->
name|t_designator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"union {\n"
argument_list|)
expr_stmt|;
name|print_level
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|t_candidates
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|t
operator|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|cdr
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|car
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
control|)
block|{
name|member
operator|=
name|name_of
argument_list|(
name|car
argument_list|(
name|car
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|"u_%s"
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|print_decl
argument_list|(
name|f
argument_list|,
name|newname
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#define %s_case u.u_%s\n"
argument_list|,
name|member
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
block|}
name|print_level
operator|--
expr_stmt|;
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"} u;\n"
argument_list|)
expr_stmt|;
name|print_level
operator|--
expr_stmt|;
name|tab
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"} %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
default|default:
name|yyerror
argument_list|(
literal|"Internal error in print_decl: bad type constructor for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
label|:
if|if
condition|(
operator|!
name|nonewline
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|gensym
parameter_list|(
name|prefix
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
specifier|static
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|MAXSTR
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%d"
argument_list|,
name|prefix
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
return|return
operator|(
name|copy
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate C functions to pack and unpack a Courier type.  * Put their names in the type structure.  */
end_comment

begin_macro
name|type_functions
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|object
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list
name|p
decl_stmt|,
name|q
decl_stmt|;
name|struct
name|object
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|,
modifier|*
name|uname
decl_stmt|,
modifier|*
name|format
decl_stmt|,
modifier|*
name|ref
decl_stmt|,
modifier|*
name|member
decl_stmt|,
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|class_of
argument_list|(
name|type
argument_list|)
operator|!=
name|O_TYPE
operator|||
name|type
operator|->
name|t_constr
operator|==
name|C_PREDEF
condition|)
return|return;
if|if
condition|(
name|type
operator|->
name|t_constr
operator|!=
name|C_ENUMERATION
condition|)
block|{
name|type
operator|->
name|t_pfname
operator|=
name|pname
operator|=
name|gensym
argument_list|(
literal|"Pack"
argument_list|)
expr_stmt|;
name|type
operator|->
name|t_ufname
operator|=
name|uname
operator|=
name|gensym
argument_list|(
literal|"Unpack"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
operator|->
name|t_constr
condition|)
block|{
case|case
name|C_ENUMERATION
case|:
name|type
operator|->
name|t_pfname
operator|=
literal|"PackCardinal"
expr_stmt|;
name|type
operator|->
name|t_ufname
operator|=
literal|"UnpackCardinal"
expr_stmt|;
return|return;
case|case
name|C_ARRAY
case|:
name|function_heading
argument_list|(
name|cf1
argument_list|,
name|pname
argument_list|,
name|type
operator|->
name|t_basetype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|function_heading
argument_list|(
name|cf2
argument_list|,
name|uname
argument_list|,
name|type
operator|->
name|t_basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"{\n\ \tregister Unspecified *bp;\n\ \tregister Cardinal i;\n\ \n\ \tbp = buf;\n\ \tfor (i = 0; i< %s; i++)\n\ \t\tbp += %s(%sp[i], bp%s);\n"
expr_stmt|;
name|ref
operator|=
name|refstr
argument_list|(
name|type
operator|->
name|t_basetype
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf1
argument_list|,
name|format
argument_list|,
name|obj_rep
argument_list|(
name|type
operator|->
name|t_size
argument_list|)
argument_list|,
name|pack_function
argument_list|(
name|type
operator|->
name|t_basetype
argument_list|)
argument_list|,
name|ref
argument_list|,
literal|", flag"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf2
argument_list|,
name|format
argument_list|,
name|obj_rep
argument_list|(
name|type
operator|->
name|t_size
argument_list|)
argument_list|,
name|unpack_function
argument_list|(
name|type
operator|->
name|t_basetype
argument_list|)
argument_list|,
name|ref
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_SEQUENCE
case|:
name|function_heading
argument_list|(
name|cf1
argument_list|,
name|pname
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|function_heading
argument_list|(
name|cf2
argument_list|,
name|uname
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"{\n\ \tregister Unspecified *bp;\n\ \tregister Cardinal i;\n\ \n\ \tbp = buf;\n\ \tbp += %sCardinal(&p->length, bp%s);\n"
expr_stmt|;
name|fprintf
argument_list|(
name|cf1
argument_list|,
name|format
argument_list|,
literal|"Pack"
argument_list|,
literal|", flag"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf2
argument_list|,
name|format
argument_list|,
literal|"Unpack"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 		 * The unpack function needs to dynamically 		 * allocate space for the sequence elements. 		 */
name|fprintf
argument_list|(
name|cf2
argument_list|,
literal|"\tp->sequence = ("
argument_list|)
expr_stmt|;
name|print_decl
argument_list|(
name|cf2
argument_list|,
literal|"*"
argument_list|,
name|type
operator|->
name|t_basetype
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf2
argument_list|,
literal|")\n\t\tAllocate(p->length * sizeof("
argument_list|)
expr_stmt|;
name|print_decl
argument_list|(
name|cf2
argument_list|,
literal|""
argument_list|,
name|type
operator|->
name|t_basetype
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf2
argument_list|,
literal|")/sizeof(Unspecified));\n"
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"\tfor (i = 0; i< p->length; i++)\n\ \t\tbp += %s(%sp->sequence[i], bp%s);\n"
expr_stmt|;
name|ref
operator|=
name|refstr
argument_list|(
name|type
operator|->
name|t_basetype
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf1
argument_list|,
name|format
argument_list|,
name|pack_function
argument_list|(
name|type
operator|->
name|t_basetype
argument_list|)
argument_list|,
name|ref
argument_list|,
literal|", flag"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf2
argument_list|,
name|format
argument_list|,
name|unpack_function
argument_list|(
name|type
operator|->
name|t_basetype
argument_list|)
argument_list|,
name|ref
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_RECORD
case|:
name|function_heading
argument_list|(
name|cf1
argument_list|,
name|pname
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|function_heading
argument_list|(
name|cf2
argument_list|,
name|uname
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"{\n\ \tregister Unspecified *bp;\n\ \n\ \tbp = buf;\n"
expr_stmt|;
name|fprintf
argument_list|(
name|cf1
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf2
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"\tbp += %s(%sp->%s, bp%s);\n"
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|t_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|t
operator|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|cdr
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|refstr
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|car
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
control|)
block|{
name|member
operator|=
name|name_of
argument_list|(
name|car
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf1
argument_list|,
name|format
argument_list|,
name|pack_function
argument_list|(
name|t
argument_list|)
argument_list|,
name|ref
argument_list|,
name|member
argument_list|,
literal|", flag"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf2
argument_list|,
name|format
argument_list|,
name|unpack_function
argument_list|(
name|t
argument_list|)
argument_list|,
name|ref
argument_list|,
name|member
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|C_CHOICE
case|:
name|function_heading
argument_list|(
name|cf1
argument_list|,
name|pname
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|function_heading
argument_list|(
name|cf2
argument_list|,
name|uname
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"{\n\ \tregister Unspecified *bp;\n\ \n\ \tbp = buf;\n\ \tbp += %sCardinal(&p->designator, bp%s);\n\ \tswitch (p->designator) {\n"
expr_stmt|;
name|fprintf
argument_list|(
name|cf1
argument_list|,
name|format
argument_list|,
literal|"Pack"
argument_list|,
literal|", flag"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf2
argument_list|,
name|format
argument_list|,
literal|"Unpack"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"\tcase %s:\n\ \t\tbp += %s(%sp->%s_case, bp%s);\n\ \t\tbreak;\n"
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|t_candidates
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|t
operator|=
operator|(
expr|struct
name|object
operator|*
operator|)
name|cdr
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|ref
operator|=
name|refstr
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|car
argument_list|(
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
control|)
block|{
name|member
operator|=
name|name_of
argument_list|(
name|car
argument_list|(
name|car
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf1
argument_list|,
name|format
argument_list|,
name|member
argument_list|,
name|pack_function
argument_list|(
name|t
argument_list|)
argument_list|,
name|ref
argument_list|,
name|member
argument_list|,
literal|", flag"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf2
argument_list|,
name|format
argument_list|,
name|member
argument_list|,
name|unpack_function
argument_list|(
name|t
argument_list|)
argument_list|,
name|ref
argument_list|,
name|member
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|cf1
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf2
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_PROCEDURE
case|:
case|case
name|C_ERROR
case|:
return|return;
default|default:
name|yyerror
argument_list|(
literal|"Internal error in type_functions: bad type constructor"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|format
operator|=
literal|"\treturn (bp - buf);\n\ }\n"
expr_stmt|;
name|fprintf
argument_list|(
name|cf1
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cf2
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print the heading for a type packing or unpacking function.  */
end_comment

begin_macro
name|function_heading
argument_list|(
argument|f
argument_list|,
argument|name
argument_list|,
argument|type
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|object
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nstatic %s(p, buf%s)\n"
argument_list|,
name|name
argument_list|,
name|flag
condition|?
literal|", flag"
else|:
literal|""
argument_list|)
expr_stmt|;
name|print_level
operator|++
expr_stmt|;
name|print_decl
argument_list|(
name|f
argument_list|,
literal|"*p"
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_level
operator|--
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\tregister Unspecified *buf;\n%s"
argument_list|,
name|flag
condition|?
literal|"\tBoolean flag;\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|tab
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|print_level
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

