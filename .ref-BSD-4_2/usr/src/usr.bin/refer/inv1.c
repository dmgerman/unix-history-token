begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)inv1.c	4.1 (Berkeley) 5/6/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
comment|/* Make inverted file indexes.  Reads a stream from mkey which 	 * gives record pointer items and keys.  Generates set of files 	 *	a. NHASH pointers to file b. 	 *	b. lists of record numbers. 	 *	c. record pointer items. 	 * 	 *  these files are named xxx.ia, xxx.ib, xxx.ic; 	 *  where xxx is taken from arg1. 	 *  If the files exist they are updated. 	 */
name|FILE
modifier|*
name|fa
decl_stmt|,
modifier|*
name|fb
decl_stmt|,
modifier|*
name|fc
decl_stmt|,
modifier|*
name|fta
decl_stmt|,
modifier|*
name|ftb
decl_stmt|,
modifier|*
name|ftc
decl_stmt|,
modifier|*
name|fd
decl_stmt|;
name|int
name|nhash
init|=
literal|256
decl_stmt|;
name|int
name|appflg
init|=
literal|1
decl_stmt|;
name|int
name|keepkey
init|=
literal|0
decl_stmt|,
name|pipein
init|=
literal|0
decl_stmt|;
name|char
name|nma
index|[
literal|100
index|]
decl_stmt|,
name|nmb
index|[
literal|100
index|]
decl_stmt|,
name|nmc
index|[
literal|100
index|]
decl_stmt|,
name|com
index|[
literal|100
index|]
decl_stmt|,
name|nmd
index|[
literal|100
index|]
decl_stmt|;
name|char
name|tmpa
index|[
literal|20
index|]
decl_stmt|,
name|tmpb
index|[
literal|20
index|]
decl_stmt|,
name|tmpc
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|remove
init|=
name|NULL
decl_stmt|;
name|int
name|chatty
init|=
literal|0
decl_stmt|,
name|docs
decl_stmt|,
name|hashes
decl_stmt|,
name|fp
index|[
literal|2
index|]
decl_stmt|,
name|fr
decl_stmt|,
name|fw
decl_stmt|,
name|pfork
decl_stmt|,
name|pwait
decl_stmt|,
name|status
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|long
name|keys
decl_stmt|;
name|int
name|iflong
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|sortdir
decl_stmt|;
name|sortdir
operator|=
operator|(
name|access
argument_list|(
literal|"/crp/tmp"
argument_list|,
literal|06
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|"/crp/tmp"
else|:
literal|"/usr/tmp"
expr_stmt|;
while|while
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'h'
case|:
comment|/* size of hash table */
name|nhash
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* new, don't append */
name|appflg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* append to old file */
name|appflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* verbose output */
name|chatty
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* keep keys on file .id for check on searching */
name|keepkey
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* pipe into sort (saves space, costs time)*/
name|pipein
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* input is on file, not stdin */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|"Can't read input %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|'u'
condition|)
comment|/* unlink */
name|remove
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
break|break;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|nma
argument_list|,
name|argc
operator|>=
literal|2
condition|?
name|argv
index|[
literal|1
index|]
else|:
literal|"Index"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|nmb
argument_list|,
name|nma
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|nmc
argument_list|,
name|nma
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|nmd
argument_list|,
name|nma
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|nma
argument_list|,
literal|".ia"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|nmb
argument_list|,
literal|".ib"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|nmc
argument_list|,
literal|".ic"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|nmd
argument_list|,
literal|".id"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpa
argument_list|,
literal|"junk%di"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipein
condition|)
block|{
name|pipe
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fr
operator|=
name|fp
index|[
literal|0
index|]
expr_stmt|;
name|fw
operator|=
name|fp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pfork
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|fw
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|_assert
argument_list|(
name|dup
argument_list|(
name|fr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fr
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/sort"
argument_list|,
literal|"sort"
argument_list|,
literal|"-T"
argument_list|,
name|sortdir
argument_list|,
literal|"-o"
argument_list|,
name|tmpa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/sort"
argument_list|,
literal|"sort"
argument_list|,
literal|"-T"
argument_list|,
name|sortdir
argument_list|,
literal|"-o"
argument_list|,
name|tmpa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|_assert
argument_list|(
name|pfork
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fr
argument_list|)
expr_stmt|;
name|fta
operator|=
name|fopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fta
operator|->
name|_file
argument_list|)
expr_stmt|;
name|fta
operator|->
name|_file
operator|=
name|fw
expr_stmt|;
block|}
else|else
comment|/* use tmp file */
block|{
name|fta
operator|=
name|fopen
argument_list|(
name|tmpa
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|_assert
argument_list|(
name|fta
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|fb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|appflg
condition|)
block|{
if|if
condition|(
name|fb
operator|=
name|fopen
argument_list|(
name|nmb
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|tmpb
argument_list|,
literal|"junk%dj"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|ftb
operator|=
name|fopen
argument_list|(
name|tmpb
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftb
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|"Can't get scratch file %s"
argument_list|,
name|tmpb
argument_list|)
expr_stmt|;
name|nhash
operator|=
name|recopy
argument_list|(
name|ftb
argument_list|,
name|fb
argument_list|,
name|fopen
argument_list|(
name|nma
argument_list|,
literal|"r"
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ftb
argument_list|)
expr_stmt|;
block|}
else|else
name|appflg
operator|=
literal|0
expr_stmt|;
block|}
name|fc
operator|=
name|fopen
argument_list|(
name|nmc
argument_list|,
name|appflg
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keepkey
condition|)
name|fd
operator|=
name|keepkey
condition|?
name|fopen
argument_list|(
name|nmd
argument_list|,
literal|"w"
argument_list|)
else|:
literal|0
expr_stmt|;
name|docs
operator|=
name|newkeys
argument_list|(
name|fta
argument_list|,
name|stdin
argument_list|,
name|fc
argument_list|,
name|nhash
argument_list|,
name|fd
argument_list|,
operator|&
name|iflong
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
operator|!=
name|NULL
condition|)
name|unlink
argument_list|(
name|remove
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fta
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipein
condition|)
block|{
name|pwait
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pfork %o pwait %o status %d\n"
argument_list|,
name|pfork
argument_list|,
name|pwait
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|_assert
argument_list|(
name|pwait
operator|==
name|pfork
argument_list|)
expr_stmt|;
name|_assert
argument_list|(
name|status
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|com
argument_list|,
literal|"sort -T %s %s -o %s"
argument_list|,
name|sortdir
argument_list|,
name|tmpa
argument_list|,
name|tmpa
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|com
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|appflg
condition|)
block|{
name|sprintf
argument_list|(
name|tmpc
argument_list|,
literal|"junk%dk"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|com
argument_list|,
literal|"mv %s %s"
argument_list|,
name|tmpa
argument_list|,
name|tmpc
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|com
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|com
argument_list|,
literal|"sort -T %s  -m %s %s -o %s"
argument_list|,
name|sortdir
argument_list|,
name|tmpb
argument_list|,
name|tmpc
argument_list|,
name|tmpa
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|com
argument_list|)
expr_stmt|;
block|}
name|fta
operator|=
name|fopen
argument_list|(
name|tmpa
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fa
operator|=
name|fopen
argument_list|(
name|nma
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fb
operator|=
name|fopen
argument_list|(
name|nmb
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|whash
argument_list|(
name|fta
argument_list|,
name|fa
argument_list|,
name|fb
argument_list|,
name|nhash
argument_list|,
name|iflong
argument_list|,
operator|&
name|keys
argument_list|,
operator|&
name|hashes
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fta
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|D1
name|unlink
argument_list|(
name|tmpa
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|appflg
condition|)
block|{
name|unlink
argument_list|(
name|tmpb
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chatty
condition|)
name|printf
argument_list|(
literal|"%ld key occurrences,  %d hashes, %d docs\n"
argument_list|,
name|keys
argument_list|,
name|hashes
argument_list|,
name|docs
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

