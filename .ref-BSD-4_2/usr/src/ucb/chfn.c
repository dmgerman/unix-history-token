begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)chfn.c	4.6 (Berkeley) 7/10/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  *	 changefinger - change finger entries  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_struct
struct|struct
name|default_values
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|office_num
decl_stmt|;
name|char
modifier|*
name|office_phone
decl_stmt|;
name|char
modifier|*
name|home_phone
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|char
name|passwd
index|[]
init|=
literal|"/etc/passwd"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|temp
index|[]
init|=
literal|"/etc/ptmp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|getpwent
argument_list|()
decl_stmt|,
modifier|*
name|getpwnam
argument_list|()
decl_stmt|,
modifier|*
name|getpwuid
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|endpwent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|crypt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getpass
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|user_uid
decl_stmt|;
name|char
name|replacement
index|[
literal|4
operator|*
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|tf
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: changefinger [user]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Error check to make sure the user (foolishly) typed their own name. 	 */
name|user_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|==
literal|2
operator|)
operator|&&
operator|(
name|user_uid
operator|!=
literal|0
operator|)
condition|)
block|{
name|pwd
operator|=
name|getpwnam
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s%s%s%s%s%s%s%s"
argument_list|,
literal|"There is no account for "
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|" on this machine.\n"
argument_list|,
literal|"You probably mispelled your login name;\n"
argument_list|,
literal|"only root is allowed to change another"
argument_list|,
literal|" person's finger entry.\n"
argument_list|,
literal|"Note:  you do not need to type your login"
argument_list|,
literal|" name as an argument.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|!=
name|user_uid
condition|)
block|{
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
literal|"You are not allowed to change another"
argument_list|,
literal|" person's finger entry.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If root is changing a finger entry, then find the uid that 	 * corresponds to the user's login name. 	 */
if|if
condition|(
operator|(
name|argc
operator|==
literal|2
operator|)
operator|&&
operator|(
name|user_uid
operator|==
literal|0
operator|)
condition|)
block|{
name|pwd
operator|=
name|getpwnam
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"There is no account for %s on this machine\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|user_uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|pwd
operator|=
name|getpwuid
argument_list|(
name|user_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No passwd file entry!?\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Collect name, room number, school phone, and home phone. 	 */
name|get_info
argument_list|(
name|pwd
operator|->
name|pw_gecos
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|temp
argument_list|,
name|O_CREAT
operator||
name|O_EXCL
operator||
name|O_RDWR
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Temporary file busy -- try again\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tf
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Absurd fdopen failure - seek help\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|unlimit
argument_list|(
name|RLIMIT_CPU
argument_list|)
expr_stmt|;
name|unlimit
argument_list|(
name|RLIMIT_FSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Copy passwd to temp, replacing matching lines 	 * with new gecos field. 	 */
while|while
condition|(
operator|(
name|pwd
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|==
name|user_uid
condition|)
name|pwd
operator|->
name|pw_gecos
operator|=
name|replacement
expr_stmt|;
name|fprintf
argument_list|(
name|tf
argument_list|,
literal|"%s:%s:%d:%d:%s:%s:%s\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|,
name|pwd
operator|->
name|pw_gecos
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|temp
argument_list|,
name|passwd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"chfn: "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"rename"
argument_list|)
expr_stmt|;
name|out
label|:
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|unlimit
argument_list|(
argument|lim
argument_list|)
end_macro

begin_block
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
operator|=
name|RLIM_INFINITY
expr_stmt|;
operator|(
name|void
operator|)
name|setrlimit
argument_list|(
name|lim
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get name, room number, school phone, and home phone.  */
end_comment

begin_macro
name|get_info
argument_list|(
argument|gecos_field
argument_list|,
argument|answer
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|gecos_field
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|answer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|;
name|char
name|in_str
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|default_values
modifier|*
name|defaults
decl_stmt|,
modifier|*
name|get_defaults
argument_list|()
decl_stmt|;
name|answer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|defaults
operator|=
name|get_defaults
argument_list|(
name|gecos_field
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Default values are printed inside of of '[]'.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"To accept the default, type<return>.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"To have a blank entry, type the word 'none'.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Get name. 	 */
do|do
block|{
name|printf
argument_list|(
literal|"\nName [%s]: "
argument_list|,
name|defaults
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|in_str
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|special_case
argument_list|(
name|in_str
argument_list|,
name|defaults
operator|->
name|name
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|illegal_input
argument_list|(
name|in_str
argument_list|)
condition|)
do|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|answer
argument_list|,
name|in_str
argument_list|)
expr_stmt|;
comment|/* 	 * Get room number. 	 */
do|do
block|{
name|printf
argument_list|(
literal|"Room number (Exs: 597E or 197C) [%s]: "
argument_list|,
name|defaults
operator|->
name|office_num
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|in_str
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|special_case
argument_list|(
name|in_str
argument_list|,
name|defaults
operator|->
name|office_num
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|illegal_input
argument_list|(
name|in_str
argument_list|)
operator|||
name|illegal_building
argument_list|(
name|in_str
argument_list|)
condition|)
do|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|strcat
argument_list|(
name|answer
argument_list|,
literal|","
argument_list|)
argument_list|,
name|in_str
argument_list|)
expr_stmt|;
comment|/* 	 * Get office phone number. 	 * Remove hyphens and 642, x2, or 2 prefixes if present. 	 */
do|do
block|{
name|printf
argument_list|(
literal|"Office Phone (Ex: 1632) [%s]: "
argument_list|,
name|defaults
operator|->
name|office_phone
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|in_str
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|special_case
argument_list|(
name|in_str
argument_list|,
name|defaults
operator|->
name|office_phone
argument_list|)
condition|)
break|break;
name|remove_hyphens
argument_list|(
name|in_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|in_str
argument_list|)
operator|==
literal|8
operator|)
operator|&&
operator|(
name|strcmpn
argument_list|(
name|in_str
argument_list|,
literal|"642"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|in_str
argument_list|,
name|in_str
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|in_str
argument_list|)
operator|==
literal|7
operator|)
operator|&&
operator|(
name|strcmpn
argument_list|(
name|in_str
argument_list|,
literal|"x2"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|in_str
argument_list|,
name|in_str
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|in_str
argument_list|)
operator|==
literal|6
operator|)
operator|&&
operator|(
name|in_str
index|[
literal|0
index|]
operator|==
literal|'2'
operator|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|in_str
argument_list|,
name|in_str
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|illegal_input
argument_list|(
name|in_str
argument_list|)
operator|||
name|not_all_digits
argument_list|(
name|in_str
argument_list|)
operator|||
name|wrong_length
argument_list|(
name|in_str
argument_list|,
literal|4
argument_list|)
condition|)
do|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|strcat
argument_list|(
name|answer
argument_list|,
literal|","
argument_list|)
argument_list|,
name|in_str
argument_list|)
expr_stmt|;
comment|/* 	 * Get home phone number. 	 * Remove hyphens if present. 	 */
do|do
block|{
name|printf
argument_list|(
literal|"Home Phone (Ex: 9875432) [%s]: "
argument_list|,
name|defaults
operator|->
name|home_phone
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|in_str
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|special_case
argument_list|(
name|in_str
argument_list|,
name|defaults
operator|->
name|home_phone
argument_list|)
condition|)
break|break;
name|remove_hyphens
argument_list|(
name|in_str
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|illegal_input
argument_list|(
name|in_str
argument_list|)
operator|||
name|not_all_digits
argument_list|(
name|in_str
argument_list|)
condition|)
do|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|strcat
argument_list|(
name|answer
argument_list|,
literal|","
argument_list|)
argument_list|,
name|in_str
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Prints an error message if a ':' or a newline is found in the string.  * A message is also printed if the input string is too long.  * The password file uses :'s as seperators, and are not allowed in the "gcos"  * field.  Newlines serve as delimiters between users in the password file,  * and so, those too, are checked for.  (I don't think that it is possible to  * type them in, but better safe than sorry)  *  * Returns '1' if a colon or newline is found or the input line is too long.  */
end_comment

begin_macro
name|illegal_input
argument_list|(
argument|input_str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|input_str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|error_flag
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|input_str
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
argument_list|(
name|input_str
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"':' is not allowed.\n"
argument_list|)
expr_stmt|;
name|error_flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|input_str
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* the newline and the '\0' eat up two characters */
name|printf
argument_list|(
literal|"Maximum number of characters allowed is %d\n"
argument_list|,
name|BUFSIZ
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* flush the rest of the input line */
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|'\n'
condition|)
comment|/* void */
empty_stmt|;
name|error_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Delete newline by shortening string by 1. 	 */
name|input_str
index|[
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Don't allow control characters, etc in input string. 	 */
for|for
control|(
name|ptr
operator|=
name|input_str
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
operator|*
name|ptr
operator|<
literal|040
condition|)
block|{
name|printf
argument_list|(
literal|"Control characters are not allowed.\n"
argument_list|)
expr_stmt|;
name|error_flag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|error_flag
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Removes '-'s from the input string.  */
end_comment

begin_macro
name|remove_hyphens
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|hyphen
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|hyphen
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hyphen
argument_list|,
name|hyphen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *  Checks to see if 'str' contains only digits (0-9).  If not, then  *  an error message is printed and '1' is returned.  */
end_comment

begin_macro
name|not_all_digits
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|str
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
operator|++
name|ptr
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Phone numbers can only contain digits.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Returns 1 when the length of the input string is not zero or equal to n.  * Prints an error message in this case.  */
end_comment

begin_macro
name|wrong_length
argument_list|(
argument|str
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|!=
name|n
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"The phone number should be %d digits long.\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Make sure that building is 'E' or 'C'.  * Error correction is done if building is 'e', 'c', "evans", or "cory".  * Correction changes "str".  * The finger program determines the building by looking at the last  * character.  Currently, finger only allows that character to be 'E' or 'C'.  *  * Returns 1 if incorrect room format.  *   * Note: this function assumes that the newline has been removed from str.  */
end_comment

begin_macro
name|illegal_building
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|char
modifier|*
name|last_ch
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
comment|/* 	 * Zero length strings are acceptable input. 	 */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Delete "vans" and "ory". 	 */
if|if
condition|(
name|strcmpn
argument_list|(
name|str
operator|+
name|length
operator|-
literal|4
argument_list|,
literal|"vans"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|length
operator|-=
literal|4
expr_stmt|;
name|str
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|strcmpn
argument_list|(
name|str
operator|+
name|length
operator|-
literal|3
argument_list|,
literal|"ory"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|length
operator|-=
literal|3
expr_stmt|;
name|str
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|last_ch
operator|=
name|str
operator|+
name|length
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Now change e to E or c to C. 	 */
if|if
condition|(
operator|*
name|last_ch
operator|==
literal|'e'
condition|)
operator|*
name|last_ch
operator|=
literal|'E'
expr_stmt|;
if|if
condition|(
operator|*
name|last_ch
operator|==
literal|'c'
condition|)
operator|*
name|last_ch
operator|=
literal|'C'
expr_stmt|;
comment|/* 	 * Delete any spaces before the E or C. 	 */
for|for
control|(
name|ptr
operator|=
name|last_ch
operator|-
literal|1
init|;
name|ptr
operator|>
name|str
condition|;
name|ptr
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|' '
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
name|last_ch
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure building is evans or cory. 	 */
if|if
condition|(
operator|(
operator|*
name|last_ch
operator|!=
literal|'E'
operator|)
operator|&&
operator|(
operator|*
name|last_ch
operator|!=
literal|'C'
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s%s%s"
argument_list|,
literal|"The finger program requires that your"
argument_list|,
literal|" office be in Cory or Evans.\n"
argument_list|,
literal|"Enter this as (for example) 597E or 197C.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* get_defaults picks apart "str" and returns a structure points.  * "str" contains up to 4 fields separated by commas.  * Any field that is missing is set to blank.  */
end_comment

begin_function
name|struct
name|default_values
modifier|*
name|get_defaults
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|default_values
modifier|*
name|answer
decl_stmt|;
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
name|answer
operator|=
operator|(
expr|struct
name|default_values
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|default_values
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
operator|(
expr|struct
name|default_values
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nUnable to allocate storage in get_defaults!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Values if no corresponding string in "str". 	 */
name|answer
operator|->
name|name
operator|=
name|str
expr_stmt|;
name|answer
operator|->
name|office_num
operator|=
literal|""
expr_stmt|;
name|answer
operator|->
name|office_phone
operator|=
literal|""
expr_stmt|;
name|answer
operator|->
name|home_phone
operator|=
literal|""
expr_stmt|;
name|str
operator|=
name|index
argument_list|(
name|answer
operator|->
name|name
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
operator|(
name|answer
operator|)
return|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|answer
operator|->
name|office_num
operator|=
name|str
operator|+
literal|1
expr_stmt|;
name|str
operator|=
name|index
argument_list|(
name|answer
operator|->
name|office_num
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
operator|(
name|answer
operator|)
return|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|answer
operator|->
name|office_phone
operator|=
name|str
operator|+
literal|1
expr_stmt|;
name|str
operator|=
name|index
argument_list|(
name|answer
operator|->
name|office_phone
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
operator|(
name|answer
operator|)
return|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|answer
operator|->
name|home_phone
operator|=
name|str
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  special_case returns true when either the default is accepted  *  (str = '\n'), or when 'none' is typed.  'none' is accepted in  *  either upper or lower case (or any combination).  'str' is modified  *  in these two cases.  */
end_comment

begin_function
name|int
name|special_case
parameter_list|(
name|str
parameter_list|,
name|default_str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|default_str
decl_stmt|;
block|{
specifier|static
name|char
name|word
index|[]
init|=
literal|"none\n"
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|wordptr
decl_stmt|;
comment|/* 	 *  If the default is accepted, then change the old string do the  	 *  default string. 	 */
if|if
condition|(
operator|*
name|str
operator|==
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|str
argument_list|,
name|default_str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 *  Check to see if str is 'none'.  (It is questionable if case 	 *  insensitivity is worth the hair). 	 */
name|wordptr
operator|=
name|word
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|str
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
operator|++
name|ptr
control|)
block|{
operator|++
name|wordptr
expr_stmt|;
if|if
condition|(
operator|*
name|wordptr
operator|==
literal|'\0'
condition|)
comment|/* then words are different sizes */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|ptr
operator|==
operator|*
name|wordptr
condition|)
continue|continue;
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|(
name|tolower
argument_list|(
operator|*
name|ptr
argument_list|)
operator|==
operator|*
name|wordptr
operator|)
condition|)
continue|continue;
comment|/* 		 * At this point we have a mismatch, so we return 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Make sure that words are the same length. 	 */
if|if
condition|(
operator|*
operator|(
name|wordptr
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Change 'str' to be the null string 	 */
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

