begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: fex1.c,v 1.3 83/09/07 17:55:28 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sat Mar  5 19:50:28 1983 by layer]-  * 	fex1.c				$Locker:  $  * nlambda functions  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* Nprog ****************************************************************/
end_comment

begin_comment
comment|/* This first sets the local variables to nil while saving their old	*/
end_comment

begin_comment
comment|/* values on the name stack.  Then, pointers to various things are	*/
end_comment

begin_comment
comment|/* saved as this function may be returned to by an "Ngo" or by a	*/
end_comment

begin_comment
comment|/* "Lreturn".  At the end is the loop that cycles through the contents	*/
end_comment

begin_comment
comment|/* of the prog.								*/
end_comment

begin_function
name|lispval
name|Nprog
parameter_list|()
block|{
specifier|register
name|lispval
name|where
decl_stmt|,
name|temp
decl_stmt|;
name|struct
name|nament
modifier|*
name|savedbnp
init|=
name|bnp
decl_stmt|;
specifier|extern
name|struct
name|frame
modifier|*
name|errp
decl_stmt|;
name|pbuf
name|pb
decl_stmt|;
specifier|extern
name|int
name|retval
decl_stmt|;
specifier|extern
name|lispval
name|lispretval
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|-
name|lbot
operator|)
operator|<
literal|1
condition|)
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"prog"
argument_list|)
expr_stmt|;
comment|/* shallow bind the local variables to nil */
if|if
condition|(
name|lbot
operator|->
name|val
operator|->
name|d
operator|.
name|car
operator|!=
name|nil
condition|)
block|{
for|for
control|(
name|where
operator|=
name|lbot
operator|->
name|val
operator|->
name|d
operator|.
name|car
init|;
name|where
operator|!=
name|nil
condition|;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
control|)
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|!=
name|DTPR
operator|||
name|TYPE
argument_list|(
name|temp
operator|=
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
operator|!=
name|ATOM
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Illegal local variable list in prog "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|1
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|PUSHDOWN
argument_list|(
name|temp
argument_list|,
name|nil
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* put a frame on the stack which can be 'return'ed to or 'go'ed to */
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_PROG
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|where
operator|=
name|lbot
operator|->
name|val
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/* first thing in the prog body */
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|C_RET
case|:
comment|/* 			 * returning from this prog, value to return 			 * is in lispretval 			 */
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|lispretval
operator|)
return|;
case|case
name|C_GO
case|:
comment|/* 			 * going to a certain label, label to go to in 			 * in lispretval 			 */
name|where
operator|=
operator|(
name|lbot
operator|->
name|val
operator|)
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
while|while
condition|(
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|==
name|DTPR
operator|)
operator|&&
operator|(
name|where
operator|->
name|d
operator|.
name|car
operator|!=
name|lispretval
operator|)
condition|)
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|where
operator|->
name|d
operator|.
name|car
operator|==
name|lispretval
condition|)
block|{
name|popnames
argument_list|(
name|errp
operator|->
name|svbnp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* label not found in this prog, must  			 * go up to higher prog 			 */
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
comment|/* go to next frame */
name|Inonlocalgo
argument_list|(
name|C_GO
argument_list|,
name|lispretval
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|C_INITIAL
case|:
break|break;
block|}
while|while
condition|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|==
name|DTPR
condition|)
block|{
name|temp
operator|=
name|where
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
name|ATOM
condition|)
name|eval
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|where
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|!=
name|DTPR
operator|)
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Illegal form in prog body "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
comment|/* pop off locals */
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|lispval
name|globtag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Ncatch is now linked to the lisp symbol *catch , which has the form      (*catch tag form)     tag is evaluated and then the catch entry is set up.       then form is evaluated     finally the catch entry is removed.    *catch is still an nlambda since its arguments should not be evaluated    before this routine is called.     (catch form [tag]) is translated to (*catch 'tag form) by a macro.  */
end_comment

begin_function
name|lispval
name|Ncatch
parameter_list|()
block|{
specifier|register
name|lispval
name|tag
decl_stmt|;
name|pbuf
name|pb
decl_stmt|;
name|Savestack
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* save stack pointers */
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|DTPR
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|protect
argument_list|(
name|tag
operator|=
name|eval
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|d
operator|.
name|car
argument_list|)
argument_list|)
expr_stmt|;
comment|/* protect tag from gc */
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_CATCH
argument_list|,
name|tag
argument_list|,
name|nil
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|C_THROW
case|:
comment|/* 		       	 * value thrown is in lispretval 		       	 */
break|break;
case|case
name|C_INITIAL
case|:
comment|/* 			 * calculate value of expression 			 */
name|lispretval
operator|=
name|eval
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
block|}
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|lispretval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* (errset form [flag])      if present, flag determines if the error message will be printed    if an error reaches the errset.    if no error occurs, errset returns a list of one element, the      value returned from form.    if an error occurs, nil is usually returned although it could     be non nil if err threw a non nil value   */
end_comment

begin_function
name|lispval
name|Nerrset
parameter_list|()
block|{
name|lispval
name|temp
decl_stmt|,
name|flag
decl_stmt|;
name|pbuf
name|pb
decl_stmt|;
name|Savestack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|DTPR
condition|)
return|return
operator|(
name|nil
operator|)
return|;
comment|/* no form */
comment|/* evaluate and save flag first */
name|flag
operator|=
name|lbot
operator|->
name|val
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|flag
argument_list|)
operator|==
name|DTPR
condition|)
name|flag
operator|=
name|eval
argument_list|(
name|flag
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
else|else
name|flag
operator|=
name|tatom
expr_stmt|;
comment|/* if not present , assume t */
name|protect
argument_list|(
name|flag
argument_list|)
expr_stmt|;
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_CATCH
argument_list|,
name|Verall
argument_list|,
name|flag
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|C_THROW
case|:
comment|/* 			 * error thrown to this routine, value thrown is 			 * in lispretval 			 */
break|break;
case|case
name|C_INITIAL
case|:
comment|/* 			 * normally just evaluate expression and listify it. 			 */
name|temp
operator|=
name|eval
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|(
name|lispretval
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|temp
expr_stmt|;
break|break;
block|}
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|lispretval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this was changed from throw to *throw 21nov79    it is now a lambda and really should be called Lthrow */
end_comment

begin_function
name|lispval
name|Nthrow
parameter_list|()
block|{
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|0
case|:
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
break|break;
default|default:
name|argerr
argument_list|(
literal|"throw"
argument_list|)
expr_stmt|;
block|}
name|Inonlocalgo
argument_list|(
name|C_THROW
argument_list|,
name|lbot
operator|->
name|val
argument_list|,
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
end_function

begin_comment
comment|/* Ngo ******************************************************************/
end_comment

begin_comment
comment|/* First argument only is checked - and must be an atom or evaluate	*/
end_comment

begin_comment
comment|/* to one.								*/
end_comment

begin_function
name|lispval
name|Ngo
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"go"
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|lbot
operator|->
name|val
operator|)
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|!=
name|ATOM
condition|)
block|{
name|temp
operator|=
name|eval
argument_list|(
name|temp
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|!=
name|ATOM
condition|)
name|temp
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Illegal tag to go to"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|Inonlocalgo
argument_list|(
name|C_GO
argument_list|,
name|temp
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
end_function

begin_comment
comment|/* Nreset ***************************************************************/
end_comment

begin_comment
comment|/* All arguments are ignored.  This just returns-from-break to depth 0.	*/
end_comment

begin_function
name|lispval
name|Nreset
parameter_list|()
block|{
name|Inonlocalgo
argument_list|(
name|C_RESET
argument_list|,
name|inewint
argument_list|(
literal|0
argument_list|)
argument_list|,
name|nil
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nresetio *************************************************************/
end_comment

begin_function
name|lispval
name|Nresetio
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|_iob
index|[
literal|3
index|]
init|;
name|p
operator|<
name|_iob
operator|+
name|_NFILE
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|_flag
operator|&
operator|(
name|_IOWRT
operator||
name|_IOREAD
operator|)
condition|)
name|fclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nbreak ***************************************************************/
end_comment

begin_comment
comment|/* If first argument is not nil, this is evaluated and printed.  Then	*/
end_comment

begin_comment
comment|/* error is called with the "breaking" message.				*/
end_comment

begin_function
name|lispval
name|Nbreak
parameter_list|()
block|{
specifier|register
name|lispval
name|hold
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
name|port
operator|=
name|okport
argument_list|(
name|Vpoport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|port
argument_list|,
literal|"Breaking:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hold
operator|=
name|lbot
operator|->
name|val
operator|)
operator|!=
name|nil
operator|&&
operator|(
operator|(
name|hold
operator|=
name|hold
operator|->
name|d
operator|.
name|car
operator|)
operator|!=
name|nil
operator|)
condition|)
block|{
name|printr
argument_list|(
name|hold
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|dmpport
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|errorh
argument_list|(
name|Verbrk
argument_list|,
literal|""
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nexit ****************************************************************/
end_comment

begin_comment
comment|/* Just calls lispend with no message.					*/
end_comment

begin_macro
name|Nexit
argument_list|()
end_macro

begin_block
block|{
name|lispend
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Nsys *****************************************************************/
end_comment

begin_comment
comment|/* Just calls lispend with no message.					*/
end_comment

begin_function
name|lispval
name|Nsys
parameter_list|()
block|{
name|lispend
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|lispval
name|Ndef
parameter_list|()
block|{
specifier|register
name|lispval
name|arglist
decl_stmt|,
name|body
decl_stmt|,
name|name
decl_stmt|,
name|form
decl_stmt|;
name|form
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|name
operator|=
name|form
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|body
operator|=
name|form
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|arglist
operator|=
name|body
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|arglist
argument_list|)
operator|)
operator|!=
name|DTPR
operator|&&
name|arglist
operator|!=
name|nil
condition|)
name|error
argument_list|(
literal|"Warning: defining function with nonlist of args"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|name
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|body
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nquote
parameter_list|()
block|{
return|return
operator|(
operator|(
name|lbot
operator|->
name|val
operator|)
operator|->
name|d
operator|.
name|car
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nsetq
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|where
decl_stmt|,
name|value
decl_stmt|;
specifier|register
name|int
name|lefttype
decl_stmt|;
name|value
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|where
operator|=
name|lbot
operator|->
name|val
init|;
name|where
operator|!=
name|nil
condition|;
name|where
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
control|)
block|{
name|handy
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|)
operator|!=
name|DTPR
condition|)
name|error
argument_list|(
literal|"odd number of args to setq"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lefttype
operator|=
name|TYPE
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
operator|)
operator|==
name|ATOM
condition|)
block|{
if|if
condition|(
name|where
operator|->
name|d
operator|.
name|car
operator|==
name|nil
condition|)
name|error
argument_list|(
literal|"Attempt to set nil"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|where
operator|->
name|d
operator|.
name|car
operator|->
name|a
operator|.
name|clb
operator|=
name|value
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lefttype
operator|==
name|VALUE
condition|)
name|where
operator|->
name|d
operator|.
name|car
operator|->
name|l
operator|=
name|value
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
else|else
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Can only setq atoms or values"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ncond
parameter_list|()
block|{
specifier|register
name|lispval
name|where
decl_stmt|,
name|last
decl_stmt|;
name|where
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|last
operator|=
name|nil
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|)
operator|!=
name|DTPR
condition|)
break|break;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
operator|)
operator|!=
name|DTPR
condition|)
break|break;
if|if
condition|(
operator|(
name|last
operator|=
name|eval
argument_list|(
operator|(
name|where
operator|->
name|d
operator|.
name|car
operator|)
operator|->
name|d
operator|.
name|car
argument_list|)
operator|)
operator|!=
name|nil
condition|)
break|break;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|)
operator|!=
name|DTPR
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|where
operator|=
operator|(
name|where
operator|->
name|d
operator|.
name|car
operator|)
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
while|while
condition|(
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|)
operator|==
name|DTPR
condition|)
block|{
name|last
operator|=
name|eval
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
block|}
return|return
operator|(
name|last
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nand
parameter_list|()
block|{
specifier|register
name|lispval
name|current
decl_stmt|,
name|temp
decl_stmt|;
name|current
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|temp
operator|=
name|tatom
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|nil
condition|)
if|if
condition|(
operator|(
name|temp
operator|=
name|current
operator|->
name|d
operator|.
name|car
operator|)
operator|!=
name|nil
operator|&&
operator|(
name|temp
operator|=
name|eval
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
name|nil
condition|)
name|current
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
else|else
block|{
name|current
operator|=
name|nil
expr_stmt|;
name|temp
operator|=
name|nil
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nor
parameter_list|()
block|{
specifier|register
name|lispval
name|current
decl_stmt|,
name|temp
decl_stmt|;
name|current
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|temp
operator|=
name|nil
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|nil
condition|)
if|if
condition|(
operator|(
name|temp
operator|=
name|eval
argument_list|(
name|current
operator|->
name|d
operator|.
name|car
argument_list|)
operator|)
operator|==
name|nil
condition|)
name|current
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
else|else
break|break;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

end_unit

