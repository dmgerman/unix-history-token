begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: eval2.c,v 1.6 83/09/12 14:18:02 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sat May  7 23:38:37 1983 by jkf]-  * 	eval2.c				$Locker:  $  * more of the evaluator  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* Iarray - handle array call.  *  fun - array object  *  args - arguments to the array call , most likely subscripts.  *  evalp - flag, if TRUE then the arguments should be evaluated when they  *	are stacked.  */
end_comment

begin_function
name|lispval
name|Iarray
parameter_list|(
name|fun
parameter_list|,
name|args
parameter_list|,
name|evalp
parameter_list|)
specifier|register
name|lispval
name|fun
decl_stmt|,
name|args
decl_stmt|;
block|{
name|Savestack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|fun
operator|->
name|ar
operator|.
name|accfun
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|args
operator|!=
name|nil
condition|;
name|args
operator|=
name|args
operator|->
name|d
operator|.
name|cdr
control|)
comment|/* stack subscripts */
if|if
condition|(
name|evalp
condition|)
name|protect
argument_list|(
name|eval
argument_list|(
name|args
operator|->
name|d
operator|.
name|car
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|protect
argument_list|(
name|args
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|fun
argument_list|)
expr_stmt|;
name|vtemp
operator|=
name|Lfuncal
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|vtemp
operator|)
return|;
block|}
end_function

begin_macro
name|dumpmydata
argument_list|(
argument|thing
argument_list|)
end_macro

begin_decl_stmt
name|int
name|thing
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|ip
init|=
operator|&
name|thing
decl_stmt|;
specifier|register
name|int
modifier|*
name|lim
init|=
name|ip
operator|+
name|nargs
argument_list|()
decl_stmt|;
name|printf
argument_list|(
literal|"Dumpdata got %d args:\n"
argument_list|,
name|nargs
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|ip
operator|<
name|lim
condition|)
name|printf
argument_list|(
literal|"%x\n"
argument_list|,
operator|*
name|ip
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Ifcall :: call foreign function/subroutine  *   Ifcall is handed a binary object which is the function to call.  * This function has already been determined to be a foreign function  * by noticing that its discipline field is a string.    * The arguments to pass have already been evaluated and stacked.  We  * create on the stack a 'callg' type argument list to give to the   * function.  What is passed to the foreign function depends on the  * type of argument.  Certain args are passes directly, others must be  * copied since the foreign function my want to change them.  * When the foreign function returns, we may have to box the result,  * depending on the type of foreign function.  */
end_comment

begin_function
name|lispval
name|Ifcall
parameter_list|(
name|a
parameter_list|)
name|lispval
name|a
decl_stmt|;
block|{
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
name|long
name|callg_
parameter_list|()
function_decl|;
specifier|register
name|int
modifier|*
name|arglist
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|mynp
decl_stmt|;
specifier|register
name|lispval
name|ltemp
decl_stmt|;
name|pbuf
name|pb
decl_stmt|;
name|int
name|nargs
init|=
name|np
operator|-
name|lbot
decl_stmt|,
name|kind
decl_stmt|,
name|mysize
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|Keepxs
argument_list|()
expr_stmt|;
comment|/* put a frame on the stack which will save np and lbot in a 	   easy to find place in a standard way */
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_TO_FORT
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|mynp
operator|=
name|lbot
expr_stmt|;
name|kind
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|a
operator|->
name|bcd
operator|.
name|discipline
operator|)
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* dispatch according to whether call by reference or value semantics */
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'i'
case|:
case|case
literal|'s'
case|:
case|case
literal|'r'
case|:
name|arglist
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|arglist
operator|=
name|nargs
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|1
init|;
name|index
operator|<=
name|nargs
condition|;
name|index
operator|++
control|)
block|{
switch|switch
condition|(
name|TYPE
argument_list|(
name|ltemp
operator|=
name|mynp
operator|->
name|val
argument_list|)
condition|)
block|{
comment|/* fixnums and flonums must be reboxed */
case|case
name|INT
case|:
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|arglist
index|[
name|index
index|]
operator|=
operator|(
name|int
operator|)
name|sp
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arglist
index|[
name|index
index|]
operator|=
name|ltemp
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|arglist
index|[
name|index
index|]
operator|=
operator|(
name|int
operator|)
name|sp
argument_list|()
expr_stmt|;
operator|*
operator|(
name|double
operator|*
operator|)
name|arglist
index|[
name|index
index|]
operator|=
name|ltemp
operator|->
name|r
expr_stmt|;
break|break;
comment|/* these cause only part of the structure to be sent */
case|case
name|ARRAY
case|:
name|arglist
index|[
name|index
index|]
operator|=
operator|(
name|int
operator|)
name|ltemp
operator|->
name|ar
operator|.
name|data
expr_stmt|;
break|break;
case|case
name|BCD
case|:
name|arglist
index|[
name|index
index|]
operator|=
operator|(
name|int
operator|)
name|ltemp
operator|->
name|bcd
operator|.
name|start
expr_stmt|;
break|break;
comment|/* anything else should be sent directly */
default|default:
name|arglist
index|[
name|index
index|]
operator|=
operator|(
name|int
operator|)
name|ltemp
expr_stmt|;
break|break;
block|}
name|mynp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
while|while
condition|(
name|TYPE
argument_list|(
name|mynp
operator|->
name|val
argument_list|)
operator|!=
name|VECTORI
condition|)
name|mynp
operator|->
name|val
operator|=
name|error
argument_list|(
literal|"First arg to c-function-returning-vector must be of type vector-immediate"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|nargs
operator|--
expr_stmt|;
name|mynp
operator|++
expr_stmt|;
name|lbot
operator|++
expr_stmt|;
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
comment|/* make one pass over args  		calculating size of arglist */
while|while
condition|(
name|mynp
operator|<
name|np
condition|)
switch|switch
condition|(
name|TYPE
argument_list|(
name|ltemp
operator|=
name|mynp
operator|++
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|DOUB
case|:
name|nargs
operator|+=
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|VECTORI
case|:
if|if
condition|(
name|ltemp
operator|->
name|v
operator|.
name|vector
index|[
operator|-
literal|1
index|]
operator|==
name|Vpbv
condition|)
block|{
name|nargs
operator|+=
operator|-
literal|1
operator|+
name|VecTotSize
argument_list|(
name|ltemp
operator|->
name|vl
operator|.
name|vectorl
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|arglist
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|arglist
operator|=
name|nargs
expr_stmt|;
name|ap
operator|=
name|arglist
operator|+
literal|1
expr_stmt|;
comment|/* make another pass over the args 		   actually copying the arguments */
for|for
control|(
name|mynp
operator|=
name|lbot
init|;
name|mynp
operator|<
name|np
condition|;
name|mynp
operator|++
control|)
switch|switch
condition|(
name|TYPE
argument_list|(
name|ltemp
operator|=
name|mynp
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
operator|*
name|ap
operator|++
operator|=
name|ltemp
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
operator|*
operator|(
name|double
operator|*
operator|)
name|ap
operator|=
name|ltemp
operator|->
name|r
expr_stmt|;
name|ap
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|VECTORI
case|:
if|if
condition|(
name|ltemp
operator|->
name|v
operator|.
name|vector
index|[
operator|-
literal|1
index|]
operator|==
name|Vpbv
condition|)
block|{
name|mysize
operator|=
name|ltemp
operator|->
name|vl
operator|.
name|vectorl
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|mysize
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|VecTotSize
argument_list|(
name|mysize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ap
argument_list|,
name|ltemp
argument_list|,
name|mysize
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|(
name|long
operator|*
operator|)
operator|(
name|mysize
operator|+
operator|(
name|int
operator|)
name|ap
operator|)
expr_stmt|;
break|break;
block|}
default|default:
operator|*
name|ap
operator|++
operator|=
operator|(
name|long
operator|)
name|ltemp
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|'i'
case|:
comment|/* integer-function */
case|case
literal|'c'
case|:
comment|/* C-function */
name|ltemp
operator|=
name|inewint
argument_list|(
name|callg_
argument_list|(
name|a
operator|->
name|bcd
operator|.
name|start
argument_list|,
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* real-function*/
case|case
literal|'d'
case|:
comment|/* C function declared returning double */
block|{
name|double
name|result
init|=
operator|(
operator|*
operator|(
operator|(
name|double
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|callg_
operator|)
operator|)
operator|(
name|a
operator|->
name|bcd
operator|.
name|start
expr|,
name|arglist
operator|)
decl_stmt|;
name|ltemp
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|ltemp
operator|->
name|r
operator|=
name|result
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
comment|/* function */
name|ltemp
operator|=
operator|(
name|lispval
operator|)
name|callg_
argument_list|(
name|a
operator|->
name|bcd
operator|.
name|start
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* C function returning a structure */
name|ap
operator|=
operator|(
name|long
operator|*
operator|)
name|callg_
argument_list|(
name|a
operator|->
name|bcd
operator|.
name|start
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|ltemp
operator|=
operator|(
operator|--
name|lbot
operator|)
operator|->
name|val
expr_stmt|;
name|mysize
operator|=
name|ltemp
operator|->
name|vl
operator|.
name|vectorl
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|mysize
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|VecTotSize
argument_list|(
name|mysize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ltemp
argument_list|,
name|ap
argument_list|,
name|mysize
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
literal|'s'
case|:
comment|/* subroutine */
name|callg_
argument_list|(
name|a
operator|->
name|bcd
operator|.
name|start
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|ltemp
operator|=
name|tatom
expr_stmt|;
block|}
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|Freexs
argument_list|()
expr_stmt|;
return|return
operator|(
name|ltemp
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|bcopy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
specifier|register
name|char
operator|*
name|to
operator|,
operator|*
name|from
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|size
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|--
name|size
operator|>=
literal|0
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|lispval
name|ftolsp_
parameter_list|(
name|arg1
parameter_list|)
name|lispval
name|arg1
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
specifier|register
name|lispval
modifier|*
name|ap
init|=
operator|&
name|arg1
decl_stmt|;
name|lispval
name|save
decl_stmt|;
name|pbuf
name|pb
decl_stmt|;
name|Savestack
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|=
name|nargs
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return;
empty_stmt|;
if|if
condition|(
name|errp
operator|->
name|class
operator|==
name|F_TO_FORT
condition|)
name|np
operator|=
name|errp
operator|->
name|svnp
expr_stmt|;
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_TO_LISP
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
name|np
operator|++
operator|->
name|val
operator|=
operator|*
name|ap
operator|++
expr_stmt|;
name|save
operator|=
name|Lfuncal
argument_list|()
expr_stmt|;
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|save
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Ifclosure :: evaluate a fclosure  (new version)  * the argument clos is a vector whose property is the atom fclosure  * the form of the vector is  *   0: function to run  * then for each symbol there is on vector entry containing a  * pointer to a sequence of two list cells of this form:  *	(name value . count)  * name is the symbol name to close over  * value is the saved value of the closure  *	(if the closure is 'active', the current value will be in the  *	 symbol itself)  * count is a fixnum box (which can be destructively modified safely)  *  it is normally 0.  Each time the variable is put on the stack, it is  *  incremented.  It is decremented each time the the closure is left.  *  If the closure is invoked recusively without a rebinding of the  *  closure variable X, then the count will not be incremented.  *  * when entering a fclosure, for each variable there are three  * possibities:  *  (a) this is the first instance of this closed variable  *  (b) this is the second or greater recursive instance of  *      this closure variable, however it hasn't been normally lambda  *	bound since the last closure invocation  *  (c) like (b) but it has been lambda bound before the most recent  *	closure.  *  * case (a) can be determined by seeing if the count is 0.  * if the count is>0 then we must scan from the top of the stack down  * until we find either the closure or a lambda binding of the variable  * this determines whether it is case (b) or (c).  *  * There are three actions to perform in this routine:  * 1.  determine the closure type (a,b or c) and do any binding necessary  * 2.  call the closure function  * 3.  unbind any necessary closure variables.  *  * Now, the details of those actions:  * 1. for case (b), do nothing as we are still working with the correct  *    value  *    for case (a), pushdown the symbol and give it the value from  *	the closure, inc the closure count  *      push a closure marker on the bindstack too.  *    for case (c), must locate the correct value to set by searching  *      for the last lambda binding before the previous closure.  *      pushdown the symbol and that value, inc the closure count  *      push a closure marker on the bindstack too.  *    a closure marker has atom == int:closure-marker and value pointing  *      to the closure list.  This will be noticed when unbinding.  *  *  3. unbinding is just like popnames except if a closure marker is  *     seen, then this must be done:  *	if the count is 1, just store the symbol's value in the closure  *	 and decrement the count.  *      if the count is>1, then search up the stack for the last  *	 lambda before the next occurance of this closure variable  *	 and set its value to the current value of the closure.  *	 decrement the closure count.  *  * clos is the fclosure, funcallp is TRUE if this is called from funcall,  * otherwise it is called from apply  */
end_comment

begin_define
define|#
directive|define
name|Case_A
value|0
end_define

begin_define
define|#
directive|define
name|Case_B
value|1
end_define

begin_define
define|#
directive|define
name|Case_C
value|2
end_define

begin_function
name|lispval
name|Ifclosure
parameter_list|(
name|clos
parameter_list|,
name|funcallp
parameter_list|)
specifier|register
name|lispval
name|clos
decl_stmt|;
block|{
name|struct
name|nament
modifier|*
name|oldbnp
init|=
name|bnp
decl_stmt|,
modifier|*
name|lbnp
decl_stmt|,
modifier|*
name|locatevar
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|lispval
name|vect
decl_stmt|;
name|int
name|numvars
decl_stmt|,
name|vlength
decl_stmt|,
name|tcase
decl_stmt|,
name|foundc
decl_stmt|;
name|lispval
name|handy
decl_stmt|,
name|atm_dtpr
decl_stmt|,
name|value_dtpr
decl_stmt|,
name|Ifuncal
argument_list|()
decl_stmt|,
name|Lapply
argument_list|()
decl_stmt|;
name|Savestack
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* bind variables to their values given in the fclosure */
name|vlength
operator|=
name|VecTotSize
argument_list|(
name|clos
operator|->
name|vl
operator|.
name|vectorl
index|[
name|VSizeOff
index|]
argument_list|)
expr_stmt|;
comment|/* vector length must be positive (it has to have a function at least) */
if|if
condition|(
name|vlength
operator|<
literal|1
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"funcall: fclosure has wrong size "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|clos
argument_list|)
expr_stmt|;
name|numvars
operator|=
operator|(
name|vlength
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* number of varibles */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|vlength
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|atm_dtpr
operator|=
name|clos
operator|->
name|v
operator|.
name|vector
index|[
name|i
index|]
expr_stmt|;
comment|/* car is symbol name */
name|value_dtpr
operator|=
name|atm_dtpr
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/* car: value, cdr:  fixnum count */
if|if
condition|(
name|value_dtpr
operator|->
name|d
operator|.
name|cdr
operator|->
name|i
operator|==
literal|0
condition|)
name|tcase
operator|=
name|Case_A
expr_stmt|;
comment|/* first call */
else|else
block|{
name|lbnp
operator|=
name|locatevar
argument_list|(
name|atm_dtpr
argument_list|,
operator|&
name|foundc
argument_list|,
name|bnp
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundc
condition|)
block|{
comment|/* didn't find the expected closure, count must be 		   wrong, correct it and assume case (a) 		 */
name|tcase
operator|=
name|Case_A
expr_stmt|;
name|value_dtpr
operator|->
name|d
operator|.
name|cdr
operator|->
name|i
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lbnp
condition|)
name|tcase
operator|=
name|Case_C
expr_stmt|;
comment|/* found intermediate lambda bnd*/
else|else
name|tcase
operator|=
name|Case_B
expr_stmt|;
comment|/* no intermediate lambda bind */
block|}
comment|/* now bind the value if necessary */
switch|switch
condition|(
name|tcase
condition|)
block|{
case|case
name|Case_A
case|:
name|PUSHDOWN
argument_list|(
name|atm_dtpr
operator|->
name|d
operator|.
name|car
argument_list|,
name|value_dtpr
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|PUSHVAL
argument_list|(
name|clos_marker
argument_list|,
name|atm_dtpr
argument_list|)
expr_stmt|;
name|value_dtpr
operator|->
name|d
operator|.
name|cdr
operator|->
name|i
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|Case_B
case|:
break|break;
comment|/* nothing to do */
case|case
name|Case_C
case|:
comment|/* push first bound value after last close */
name|PUSHDOWN
argument_list|(
name|atm_dtpr
operator|->
name|d
operator|.
name|car
argument_list|,
name|lbnp
operator|->
name|val
argument_list|)
expr_stmt|;
name|PUSHVAL
argument_list|(
name|clos_marker
argument_list|,
name|atm_dtpr
argument_list|)
expr_stmt|;
name|value_dtpr
operator|->
name|d
operator|.
name|cdr
operator|->
name|i
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|funcallp
condition|)
name|handy
operator|=
name|Ifuncal
argument_list|(
name|clos
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|handy
operator|=
name|lbot
index|[
operator|-
literal|2
index|]
operator|.
name|val
expr_stmt|;
comment|/* get args to apply.  This is hacky and may        				   fail if apply is changed */
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|clos
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|handy
operator|=
name|Lapply
argument_list|()
expr_stmt|;
block|}
name|xpopnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
comment|/* pop names with consideration for closure markers */
if|if
condition|(
operator|!
name|funcallp
condition|)
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* xpopnames :: pop values from bindstack, but look out for  *  closure markers.  This is  used (instead of the faster popnames)  * when we know there will be closure markers or when we can't  * be sure that there won't be closure markers (eg. in non-local go's)  */
end_comment

begin_expr_stmt
name|xpopnames
argument_list|(
name|llimit
argument_list|)
specifier|register
expr|struct
name|nament
operator|*
name|llimit
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|nament
modifier|*
name|rnp
decl_stmt|,
modifier|*
name|lbnp
decl_stmt|;
name|lispval
name|atm_dtpr
decl_stmt|,
name|value_dtpr
decl_stmt|;
name|int
name|foundc
decl_stmt|;
for|for
control|(
name|rnp
operator|=
name|bnp
init|;
operator|--
name|rnp
operator|>=
name|llimit
condition|;
control|)
block|{
if|if
condition|(
name|rnp
operator|->
name|atm
operator|==
name|clos_marker
condition|)
block|{
name|atm_dtpr
operator|=
name|rnp
operator|->
name|val
expr_stmt|;
name|value_dtpr
operator|=
name|atm_dtpr
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|value_dtpr
operator|->
name|d
operator|.
name|cdr
operator|->
name|i
operator|<=
literal|1
condition|)
block|{
comment|/* this is the only occurance of this closure variable 		 * just restore current value to this closure. 		 */
name|value_dtpr
operator|->
name|d
operator|.
name|car
operator|=
name|atm_dtpr
operator|->
name|d
operator|.
name|car
operator|->
name|a
operator|.
name|clb
expr_stmt|;
block|}
else|else
block|{
comment|/* locate the last lambda before the next occurance of 		 * this closure and store the current symbol's value 		 * there 		 */
name|lbnp
operator|=
name|locatevar
argument_list|(
name|atm_dtpr
argument_list|,
operator|&
name|foundc
argument_list|,
name|rnp
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundc
condition|)
block|{
comment|/* strange, there wasn't a closure to be found. 		     * well, we will fix things up so the count is 		     * right. 		     */
name|value_dtpr
operator|->
name|d
operator|.
name|car
operator|=
name|atm_dtpr
operator|->
name|d
operator|.
name|car
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|value_dtpr
operator|->
name|d
operator|.
name|cdr
operator|->
name|i
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lbnp
condition|)
block|{
comment|/* note how the closures value isn't necessarily 		     * stored in the closure, it may be stored on 		     * the bindstack 		     */
name|lbnp
operator|->
name|val
operator|=
name|atm_dtpr
operator|->
name|d
operator|.
name|car
operator|->
name|a
operator|.
name|clb
expr_stmt|;
block|}
comment|/* the case where lbnp is 0 should never happen, but 		   if it does, we can just do nothing safely 		 */
block|}
name|value_dtpr
operator|->
name|d
operator|.
name|cdr
operator|->
name|i
operator|-=
literal|1
expr_stmt|;
block|}
else|else
name|rnp
operator|->
name|atm
operator|->
name|a
operator|.
name|clb
operator|=
name|rnp
operator|->
name|val
expr_stmt|;
comment|/* the normal case */
block|}
name|bnp
operator|=
name|llimit
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|nament
modifier|*
name|locatevar
parameter_list|(
name|clos
parameter_list|,
name|foundc
parameter_list|,
name|rnp
parameter_list|)
name|struct
name|nament
modifier|*
name|rnp
decl_stmt|;
name|lispval
name|clos
decl_stmt|;
name|int
modifier|*
name|foundc
decl_stmt|;
block|{
specifier|register
name|struct
name|nament
modifier|*
name|retbnp
decl_stmt|;
name|lispval
name|symb
decl_stmt|;
name|retbnp
operator|=
operator|(
expr|struct
name|nament
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|foundc
operator|=
literal|0
expr_stmt|;
name|symb
operator|=
name|clos
operator|->
name|d
operator|.
name|car
expr_stmt|;
for|for
control|(
init|;
name|rnp
operator|>=
name|orgbnp
condition|;
name|rnp
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|rnp
operator|->
name|atm
operator|==
name|clos_marker
operator|)
operator|&&
operator|(
name|rnp
operator|->
name|val
operator|==
name|clos
operator|)
condition|)
block|{
operator|*
name|foundc
operator|=
literal|1
expr_stmt|;
comment|/* found the closure */
return|return
operator|(
name|retbnp
operator|)
return|;
block|}
if|if
condition|(
name|rnp
operator|->
name|atm
operator|==
name|symb
condition|)
name|retbnp
operator|=
name|rnp
expr_stmt|;
block|}
return|return
operator|(
name|retbnp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|LIfss
parameter_list|()
block|{
specifier|register
name|lispval
name|atm_dtpr
decl_stmt|,
name|value_dtpr
decl_stmt|;
name|struct
name|nament
modifier|*
name|oldbnp
init|=
name|bnp
decl_stmt|,
modifier|*
name|lbnp
decl_stmt|;
name|int
name|tcase
decl_stmt|,
name|foundc
init|=
literal|0
decl_stmt|;
name|lispval
name|newval
decl_stmt|;
name|int
name|argc
init|=
literal|1
decl_stmt|;
name|Savestack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|2
case|:
name|newval
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|argc
operator|++
expr_stmt|;
case|case
literal|1
case|:
name|atm_dtpr
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|value_dtpr
operator|=
name|atm_dtpr
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
break|break;
default|default:
name|argerr
argument_list|(
literal|"int:fclosure-symbol-stuff"
argument_list|)
expr_stmt|;
block|}
comment|/* this code is copied from Ifclosure */
if|if
condition|(
name|value_dtpr
operator|->
name|d
operator|.
name|cdr
operator|->
name|i
operator|==
literal|0
condition|)
name|tcase
operator|=
name|Case_A
expr_stmt|;
comment|/* closure is not active */
else|else
block|{
name|lbnp
operator|=
name|locatevar
argument_list|(
name|atm_dtpr
argument_list|,
operator|&
name|foundc
argument_list|,
name|bnp
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundc
condition|)
block|{
comment|/* didn't find closure, count must be wrong, 			   correct it and assume case (a).*/
name|tcase
operator|=
name|Case_A
expr_stmt|;
name|value_dtpr
operator|->
name|d
operator|.
name|cdr
operator|->
name|i
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lbnp
condition|)
name|tcase
operator|=
name|Case_C
expr_stmt|;
comment|/* found intermediate lambda*/
else|else
name|tcase
operator|=
name|Case_B
expr_stmt|;
block|}
switch|switch
condition|(
name|tcase
condition|)
block|{
case|case
name|Case_B
case|:
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
return|return
operator|(
name|atm_dtpr
operator|->
name|d
operator|.
name|car
operator|->
name|a
operator|.
name|clb
operator|=
name|newval
operator|)
return|;
return|return
operator|(
name|atm_dtpr
operator|->
name|d
operator|.
name|car
operator|->
name|a
operator|.
name|clb
operator|)
return|;
case|case
name|Case_A
case|:
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
return|return
operator|(
name|value_dtpr
operator|->
name|d
operator|.
name|car
operator|=
name|newval
operator|)
return|;
return|return
operator|(
name|value_dtpr
operator|->
name|d
operator|.
name|car
operator|)
return|;
case|case
name|Case_C
case|:
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
return|return
operator|(
name|lbnp
operator|->
name|val
operator|=
name|newval
operator|)
return|;
return|return
operator|(
name|lbnp
operator|->
name|val
operator|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

end_unit

