begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * $Header: iso_pcb.c,v 4.5 88/06/29 14:59:56 hagens Exp $  * $Source: /usr/argo/sys/netiso/RCS/iso_pcb.c,v $  *  * Iso address family net-layer(s) pcb stuff. NEH 1/29/87  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: iso_pcb.c,v 4.5 88/06/29 14:59:56 hagens Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/clnp.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso_var.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_define
define|#
directive|define
name|PCBNULL
value|(struct isopcb *)0
end_define

begin_decl_stmt
name|struct
name|iso_addr
name|zeroiso_addr
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FUNCTION:		iso_pcballoc  *  * PURPOSE:			creates an isopcb structure in an mbuf,  *					with socket (so), and   *					puts it in the queue with head (head)  *  * RETURNS:			0 if OK, ENOBUFS if can't alloc the necessary mbuf  */
end_comment

begin_function
name|int
name|iso_pcballoc
parameter_list|(
name|so
parameter_list|,
name|head
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|head
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcballoc(so 0x%x)\n"
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m
init|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_PCB
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
name|isop
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|isopcb
operator|*
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_head
operator|=
name|head
expr_stmt|;
name|isop
operator|->
name|isop_socket
operator|=
name|so
expr_stmt|;
name|insque
argument_list|(
name|isop
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|isop
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_pcbbind  *  * PURPOSE:			binds the address given in *(nam) to the socket  *					specified by the isopcb in *(isop)  *					If the given address is zero, it makes sure the  *					address isn't already in use and if it's got a network  *					portion, we look for an interface with that network  *					address.  If the address given is zero, we allocate  *					a port and stuff it in the (nam) structure.  *  * RETURNS:			errno E* or 0 if ok.  *  * SIDE EFFECTS:	increments head->isop_lport if it allocates a port #  *  * NOTES:			  */
end_comment

begin_function
name|int
name|iso_pcbbind
parameter_list|(
name|isop
parameter_list|,
name|nam
parameter_list|)
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
block|{
specifier|register
name|struct
name|isopcb
modifier|*
name|head
init|=
name|isop
operator|->
name|isop_head
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ia
decl_stmt|;
name|u_short
name|suf
init|=
literal|0
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbbind(isop 0x%x, nam 0x%x)\n"
argument_list|,
name|isop
argument_list|,
name|nam
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|iso_ifaddr
operator|==
literal|0
condition|)
comment|/* any interfaces attached? */
return|return
name|EADDRNOTAVAIL
return|;
if|if
condition|(
name|isop
operator|->
name|isop_lport
condition|)
comment|/* already bound */
return|return
name|EADDRINUSE
return|;
if|if
condition|(
name|nam
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
goto|goto
name|noname
goto|;
name|siso
operator|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbbind(name len 0x%x)\n"
argument_list|,
name|nam
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The address is %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 * We would like sort of length check but since some OSI addrs 	 * do not have fixed length, we can't really do much. 	 * The ONLY thing we can say is that an osi addr has to have 	 * at LEAST an afi and one more byte and had better fit into 	 * a struct iso_addr. 	 * However, in fact the size of the whole thing is a struct 	 * sockaddr_iso, so probably this is what we should check for. 	 */
if|if
condition|(
operator|(
name|nam
operator|->
name|m_len
operator|<
literal|2
operator|)
operator|||
operator|(
name|nam
operator|->
name|m_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
operator|)
condition|)
block|{
return|return
name|ENAMETOOLONG
return|;
block|}
name|suf
operator|=
name|siso
operator|->
name|siso_tsuffix
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
operator|&
name|zeroiso_addr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* non-zero net addr- better match one of our interfaces */
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbbind: bind to NOT zeroisoaddr\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|siso
operator|->
name|siso_tsuffix
init|=
literal|0
decl_stmt|;
comment|/* yech... */
comment|/* PHASE 2: this call is ok */
if|if
condition|(
operator|(
name|ia
operator|=
name|ifa_ifwithaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|siso
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return
name|EADDRNOTAVAIL
return|;
comment|/* copy to the inpcb */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|&
operator|(
name|ia
operator|->
name|ifa_addr
operator|)
operator|)
operator|->
name|siso_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_tsuffix
operator|=
name|suf
expr_stmt|;
comment|/* copy also to the nam parameter */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
operator|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|siso
operator|->
name|siso_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
name|siso
operator|->
name|siso_tsuffix
operator|=
name|suf
expr_stmt|;
block|}
if|if
condition|(
name|suf
condition|)
block|{
if|if
condition|(
operator|(
name|suf
operator|<
name|ISO_PORT_RESERVED
operator|)
operator|&&
operator|(
name|u
operator|.
name|u_uid
operator|!=
literal|0
operator|)
condition|)
return|return
name|EACCES
return|;
if|if
condition|(
operator|(
name|isop
operator|->
name|isop_socket
operator|->
name|so_options
operator|&
name|SO_REUSEADDR
operator|)
operator|==
literal|0
operator|&&
name|iso_pcblookup
argument_list|(
name|head
argument_list|,
literal|0
argument_list|,
operator|&
operator|(
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
operator|)
argument_list|,
name|suf
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|EADDRINUSE
return|;
block|}
comment|/* copy the if addr to the result (siso) and to the isopcb */
name|noname
label|:
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbbind noname\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|suf
operator|==
literal|0
condition|)
do|do
block|{
if|if
condition|(
name|head
operator|->
name|isop_lport
operator|++
operator|<
name|ISO_PORT_RESERVED
operator|||
name|head
operator|->
name|isop_lport
operator|>
name|ISO_PORT_USERRESERVED
condition|)
name|head
operator|->
name|isop_lport
operator|=
name|ISO_PORT_RESERVED
expr_stmt|;
name|suf
operator|=
name|head
operator|->
name|isop_lport
expr_stmt|;
block|}
do|while
condition|(
name|iso_pcblookup
argument_list|(
name|head
argument_list|,
literal|0
argument_list|,
operator|&
operator|(
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
operator|)
argument_list|,
name|suf
argument_list|,
literal|0
argument_list|)
condition|)
do|;
name|isop
operator|->
name|isop_lport
operator|=
name|suf
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbbind returns 0, suf 0x%x\n"
argument_list|,
name|suf
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_pcbconnect  *  * PURPOSE:			Make the isopcb (isop) look like it's connected.  *					In other words, give it the peer address given in   *					the mbuf * (nam).   Make sure such a combination  *					of local, peer addresses doesn't already exist  *					for this protocol.  Internet mentality prevails here,  *					wherein a src,dst pair uniquely identifies a connection.  * 					Both net address and port must be specified in argument   *					(nam).  * 					If we don't have a local address for this socket yet,   *					we pick one by calling iso_pcbbind().  *  * RETURNS:			errno E* or 0 if ok.  *  * SIDE EFFECTS:	Looks up a route, which may cause one to be left  *					in the isopcb.  *  * NOTES:			  */
end_comment

begin_define
define|#
directive|define
name|satosiso
parameter_list|(
name|sa
parameter_list|)
value|((struct sockaddr_iso *)(sa))
end_define

begin_function
name|int
name|iso_pcbconnect
parameter_list|(
name|isop
parameter_list|,
name|nam
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|sockaddr_iso
name|ifaddr
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
decl_stmt|;
name|int
name|local_zero
init|=
literal|0
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbconnect(isop 0x%x sock 0x%x nam 0x%x nam->m_len 0x%x), addr:\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|,
name|nam
argument_list|,
name|nam
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|siso
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|nam
operator|->
name|m_len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|siso
argument_list|)
condition|)
return|return
name|ENAMETOOLONG
return|;
comment|/* not great but better than EINVAL! */
if|if
condition|(
name|siso
operator|->
name|siso_family
operator|!=
name|AF_ISO
condition|)
return|return
name|EAFNOSUPPORT
return|;
ifdef|#
directive|ifdef
name|notdef
comment|/* removed for the sake of extended tsels -  	 * user may setsockopt for extended tsel (foreign) and then 	 * connect to nsap w/ tsuffix zero  	 */
if|if
condition|(
name|siso
operator|->
name|siso_tsuffix
operator|==
literal|0
condition|)
return|return
name|EADDRNOTAVAIL
return|;
name|local_zero
operator|=
name|iso_addrmatch1
argument_list|(
operator|&
operator|(
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
operator|)
argument_list|,
operator|&
name|zeroiso_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|notdef
name|local_zero
operator|=
operator|!
name|bcmp
argument_list|(
operator|&
operator|(
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
operator|)
argument_list|,
operator|&
name|zeroiso_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PHASEONE
if|if
condition|(
name|local_zero
condition|)
block|{
comment|/* 		 *	We need to get the local nsap address. 		 *	First, route to the destination. This will provide us with 		 *	an ifp. Second, determine which local address linked on 		 *	that ifp is appropriate 		 */
name|struct
name|sockaddr_iso
modifier|*
name|first_hop
decl_stmt|;
comment|/* filled by clnp_route */
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* filled by clnp_route */
name|int
name|err
decl_stmt|;
name|struct
name|iso_addr
modifier|*
name|localaddr
decl_stmt|;
if|if
condition|(
name|err
operator|=
name|clnp_route
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
operator|&
name|isop
operator|->
name|isop_route
argument_list|,
comment|/* flags */
literal|0
argument_list|,
operator|&
name|first_hop
argument_list|,
operator|&
name|ifp
argument_list|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* determine local address based upon ifp */
if|if
condition|(
operator|(
name|localaddr
operator|=
name|clnp_srcaddr
argument_list|(
name|ifp
argument_list|,
operator|&
name|first_hop
operator|->
name|siso_addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENETUNREACH
operator|)
return|;
name|ifaddr
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|ifaddr
operator|.
name|siso_addr
operator|=
operator|*
name|localaddr
expr_stmt|;
if|if
condition|(
name|isop
operator|->
name|isop_lport
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|iso_pcbbind
argument_list|(
name|isop
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_laddr
operator|=
name|ifaddr
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|local_zero
condition|)
block|{
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
specifier|register
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbconnect localzero 1\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ia
init|=
operator|(
expr|struct
name|iso_ifaddr
operator|*
operator|)
literal|0
decl_stmt|;
comment|/*  		 * If route is known or can be allocated now, 		 * our src addr is taken from the i/f, else punt. 		 */
name|ro
operator|=
operator|&
name|isop
operator|->
name|isop_route
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbconnect rtalloc 1.1, ro->ro_rt 0x%x\n"
argument_list|,
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|&&
operator|!
name|iso_addrmatch1
argument_list|(
operator|&
operator|(
name|satosiso
argument_list|(
operator|&
name|ro
operator|->
name|ro_dst
argument_list|)
operator|->
name|siso_addr
operator|)
argument_list|,
operator|&
name|siso
operator|->
name|siso_addr
argument_list|)
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* 		 *	TODO: it seems this code has a lot in common with clnp_route. 		 *	Maybe they could be combined? (RAH) 		 */
if|if
condition|(
operator|(
name|isop
operator|->
name|isop_socket
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
operator|)
operator|==
literal|0
operator|&&
comment|/*XXX*/
operator|(
name|ro
operator|->
name|ro_rt
operator|==
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
operator|||
operator|(
name|ifp
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|)
operator|==
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
operator|)
condition|)
block|{
comment|/* No route yet, so try to acquire one */
name|ro
operator|->
name|ro_dst
operator|.
name|sa_family
operator|=
name|AF_ISO
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
operator|)
operator|->
name|siso_addr
operator|=
name|siso
operator|->
name|siso_addr
expr_stmt|;
name|rtalloc
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbconnect rtalloc 1.5, ro->ro_rt 0x%x\n"
argument_list|,
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ro->ro_rt->rt_refcnt %d\n"
argument_list|,
name|ro
operator|->
name|ro_rt
operator|->
name|rt_refcnt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rt entry rt_gateway (as sockaddr):\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
operator|&
name|ro
operator|->
name|ro_rt
operator|->
name|rt_gateway
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
comment|/* 				 * If we found a route, use the address 				 * corresponding to the outgoing interface 				 * unless it is the loopback (in case a route 				 * to our address on another net goes to loopback). 				 * 				 *	We must check to use the address that is of the 				 *	same type (in the case where the interface has more 				 *	than one type associated with it). (ie ecn0 has 				 *	both t37 and osinet addresses. 				 */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|&&
operator|(
name|ifp
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
condition|)
for|for
control|(
name|ia
operator|=
name|iso_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
name|struct
name|iso_addr
modifier|*
name|isoap
init|=
operator|&
name|IA_SIS
argument_list|(
name|ia
argument_list|)
operator|->
name|siso_addr
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbconnect: ia x%x yields: %s\n"
argument_list|,
name|ia
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|isoap
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|ia
operator|->
name|ia_ifp
operator|==
name|ifp
operator|)
operator|&&
operator|(
name|iso_eqtype
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
name|isoap
argument_list|)
operator|)
condition|)
break|break;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbconnect localzero 2: ia x%x\n"
argument_list|,
name|ia
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|ia
operator|==
literal|0
condition|)
block|{
name|ia
operator|=
operator|(
expr|struct
name|iso_ifaddr
operator|*
operator|)
name|ifa_ifwithdstaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|siso
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
literal|0
condition|)
name|ia
operator|=
name|iso_iaonnetof
argument_list|(
name|siso
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
literal|0
condition|)
return|return
name|EADDRNOTAVAIL
return|;
block|}
name|ifaddr
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|&
name|ia
operator|->
name|ia_addr
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"in iso_pcbconnect before lookup isop 0x%x isop->sock 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|local_zero
condition|)
block|{
if|if
condition|(
name|isop
operator|->
name|isop_lport
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|iso_pcbbind
argument_list|(
name|isop
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
operator|=
name|ifaddr
operator|.
name|siso_addr
expr_stmt|;
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
block|}
endif|#
directive|endif
endif|PHASEONE
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"in iso_pcbconnect before bcopy isop 0x%x isop->sock 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|siso
operator|->
name|siso_addr
operator|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|isop
operator|->
name|isop_faddr
operator|.
name|siso_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"in iso_pcbconnect after bcopy isop 0x%x isop->sock 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|isop
operator|->
name|isop_faddr
operator|.
name|siso_family
init|=
name|AF_ISO
decl_stmt|;
name|isop
operator|->
name|isop_fport
operator|=
name|siso
operator|->
name|siso_tsuffix
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"in iso_pcbconnect end isop 0x%x isop->sock 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iso_pcbconnect connected to addr:\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iso_pcbconnect end: src addr:\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|isop
operator|->
name|isop_laddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_pcbdisconnect()  *  * PURPOSE:			washes away the peer address info so the socket  *					appears to be disconnected.  *					If there's no file descriptor associated with the socket  *					it detaches the pcb.  *  * RETURNS:			Nada.  *  * SIDE EFFECTS:	May detach the pcb.  *  * NOTES:			  */
end_comment

begin_function
name|void
name|iso_pcbdisconnect
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|void
name|iso_pcbdetach
parameter_list|()
function_decl|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdisconnect(isop 0x%x)\n"
argument_list|,
name|isop
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
init|=
name|zeroiso_addr
decl_stmt|;
name|isop
operator|->
name|isop_fport
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isop
operator|->
name|isop_socket
operator|->
name|so_state
operator|&
name|SS_NOFDREF
condition|)
name|iso_pcbdetach
argument_list|(
name|isop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_pcbdetach  *  * PURPOSE:			detach the pcb at *(isop) from it's socket and free  *					the mbufs associated with the pcb..  *					Dequeues (isop) from its head.  *  * RETURNS:			Nada.  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|void
name|iso_pcbdetach
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|isop
operator|->
name|isop_socket
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach(isop 0x%x socket 0x%x so 0x%x)\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|so
condition|)
block|{
comment|/* in the x.25 domain, we sometimes have no socket */
name|so
operator|->
name|so_pcb
operator|=
literal|0
expr_stmt|;
name|sofree
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 2 \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|isop
operator|->
name|isop_options
condition|)
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|isop
operator|->
name|isop_options
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 3 \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
condition|)
name|rtfree
argument_list|(
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 3.1\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|isop
operator|->
name|isop_clnpcache
operator|!=
name|NULL
condition|)
block|{
name|struct
name|clnp_cache
modifier|*
name|clcp
init|=
name|mtod
argument_list|(
name|isop
operator|->
name|isop_clnpcache
argument_list|,
expr|struct
name|clnp_cache
operator|*
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 3.2: clcp 0x%x freeing clc_hdr x%x\n"
argument_list|,
name|clcp
argument_list|,
name|clcp
operator|->
name|clc_hdr
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|clcp
operator|->
name|clc_hdr
operator|!=
name|NULL
condition|)
name|m_free
argument_list|(
name|clcp
operator|->
name|clc_hdr
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 3.3: freeing cache x%x\n"
argument_list|,
name|isop
operator|->
name|isop_clnpcache
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m_free
argument_list|(
name|isop
operator|->
name|isop_clnpcache
argument_list|)
decl_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 4 \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|remque
argument_list|(
name|isop
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbdetach 5 \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
argument_list|(
argument|void
argument_list|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|isop
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/* NEEDED? */
end_comment

begin_function
name|void
name|iso_setsockaddr
parameter_list|(
name|isop
parameter_list|,
name|nam
parameter_list|)
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
decl_stmt|;
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|siso
argument_list|)
expr_stmt|;
name|siso
operator|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|siso
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|siso
argument_list|)
argument_list|)
expr_stmt|;
name|siso
operator|->
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|siso
operator|->
name|siso_tsuffix
operator|=
name|isop
operator|->
name|isop_lport
expr_stmt|;
name|siso
operator|->
name|siso_addr
operator|=
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NEEDED? */
end_comment

begin_function
name|void
name|iso_setpeeraddr
parameter_list|(
name|isop
parameter_list|,
name|nam
parameter_list|)
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
decl_stmt|;
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|siso
argument_list|)
expr_stmt|;
name|siso
operator|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|siso
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|siso
argument_list|)
argument_list|)
expr_stmt|;
name|siso
operator|->
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|siso
operator|->
name|siso_tsuffix
operator|=
name|isop
operator|->
name|isop_fport
expr_stmt|;
name|siso
operator|->
name|siso_addr
operator|=
name|isop
operator|->
name|isop_faddr
operator|.
name|siso_addr
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|notdef
end_endif

begin_comment
comment|/*  * FUNCTION:		iso_pcbnotify  *  * PURPOSE:			notify all connections in this protocol's queue (head)  *					that have peer address (dst) of the problem (errno)  *					by calling (notify) on the connections' isopcbs.  *  * RETURNS:			Rien.  *  * SIDE EFFECTS:	  *  * NOTES:			(notify) is called at splimp!  */
end_comment

begin_decl_stmt
name|void
name|iso_pcbnotify
argument_list|(
name|head
argument_list|,
name|dst
argument_list|,
name|errno
argument_list|,
name|notify
argument_list|)
decl|struct
name|isopcb
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|iso_addr
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errno
decl_stmt|,
argument_list|(
operator|*
name|notify
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|,
modifier|*
name|oisop
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbnotify(head 0x%x, notify 0x%x) dst:\n"
argument_list|,
name|head
argument_list|,
name|notify
argument_list|)
expr_stmt|;
name|ENDDEBUG
for|for
control|(
name|isop
operator|=
name|head
operator|->
name|isop_next
init|;
name|isop
operator|!=
name|head
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|iso_addrmatch1
argument_list|(
operator|&
operator|(
name|isop
operator|->
name|isop_faddr
operator|.
name|siso_addr
operator|)
argument_list|,
name|dst
argument_list|)
operator|||
name|isop
operator|->
name|isop_socket
operator|==
literal|0
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcbnotify: CONTINUE isop 0x%x, sock 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addrmatch cmp'd with (0x%x):\n"
argument_list|,
operator|&
operator|(
name|isop
operator|->
name|isop_faddr
operator|.
name|siso_addr
operator|)
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|isop
init|=
name|isop
operator|->
name|isop_next
decl_stmt|;
continue|continue;
block|}
if|if
condition|(
name|errno
condition|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
name|oisop
operator|=
name|isop
expr_stmt|;
name|isop
operator|=
name|isop
operator|->
name|isop_next
expr_stmt|;
if|if
condition|(
name|notify
condition|)
call|(
modifier|*
name|notify
call|)
argument_list|(
name|oisop
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"END OF iso_pcbnotify\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_pcblookup  *  * PURPOSE:			looks for a given combination of (faddr), (fport),  *					(lport), (laddr) in the queue named by (head).  *					Argument (flags) is ignored.  *  * RETURNS:			ptr to the isopcb if it finds a connection matching  *					these arguments, o.w. returns zero.  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|struct
name|isopcb
modifier|*
name|iso_pcblookup
parameter_list|(
name|head
parameter_list|,
name|fport
parameter_list|,
name|laddr
parameter_list|,
name|lport
parameter_list|,
name|flags
parameter_list|)
name|struct
name|isopcb
modifier|*
name|head
decl_stmt|;
name|struct
name|iso_addr
modifier|*
name|laddr
decl_stmt|;
name|u_short
name|fport
decl_stmt|,
name|lport
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_pcblookup(head 0x%x lport 0x%x fport 0x%x)\n"
argument_list|,
name|head
argument_list|,
name|lport
argument_list|,
name|fport
argument_list|)
expr_stmt|;
name|ENDDEBUG
for|for
control|(
name|isop
operator|=
name|head
operator|->
name|isop_next
init|;
name|isop
operator|!=
name|head
condition|;
name|isop
operator|=
name|isop
operator|->
name|isop_next
control|)
block|{
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * This should be changed to do bcmp on lsuffix in the tpcb instead 	 * since we should be ignoring the lport concept. 	 */
endif|#
directive|endif
endif|notdef
if|if
condition|(
name|isop
operator|->
name|isop_lport
operator|!=
name|lport
condition|)
continue|continue;
if|if
condition|(
name|isop
operator|->
name|isop_fport
operator|!=
name|fport
condition|)
continue|continue;
comment|/*	PHASE2 		 *	addrmatch1 should be iso_addrmatch(a, b, mask) 		 *	where mask is taken from isop->isop_laddrmask (new field) 		 *	isop_lnetmask will also be available in isop 		 */
if|if
condition|(
name|laddr
operator|!=
operator|&
name|zeroiso_addr
operator|&&
operator|!
name|iso_addrmatch1
argument_list|(
name|laddr
argument_list|,
operator|&
operator|(
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
operator|)
argument_list|)
condition|)
continue|continue;
return|return
operator|(
name|isop
operator|)
return|;
block|}
return|return
operator|(
expr|struct
name|isopcb
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

end_unit

