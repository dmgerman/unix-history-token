begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  *  * $Header: tp_subr2.c,v 5.5 88/11/18 17:28:55 nhall Exp $  * $Source: /usr/argo/sys/netiso/RCS/tp_subr2.c,v $  *  * Some auxiliary routines:  * 		tp_protocol_error: required by xebec- called when a combo of state,  *			event, predicate isn't covered for by the transition file.  *		tp_indicate: gives indications(signals) to the user process  *		tp_getoptions: initializes variables that are affected by the options  *          chosen.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: tp_subr2.c,v 5.5 88/11/18 17:28:55 nhall Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"argoxtwentyfive.h"
end_include

begin_comment
comment|/* this def'n is to cause the expansion of this macro in the  * routine tp_local_credit :  */
end_comment

begin_define
define|#
directive|define
name|LOCAL_CREDIT_EXPAND
end_define

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_undef
undef|#
directive|undef
name|MNULL
end_undef

begin_include
include|#
directive|include
file|"../netiso/tp_ip.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_param.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_timer.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_tpdu.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso_errno.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_seq.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_user.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/cons.h"
end_include

begin_comment
comment|/*  * NAME: 	tp_local_credit()  *  * CALLED FROM:  *  tp_emit(), tp_usrreq()  *  * FUNCTION and ARGUMENTS:  *	Computes the local credit and stashes it in tpcb->tp_lcredit.  *  It's a macro in the production system rather than a procdure.  *  * RETURNS:  *  * SIDE EFFECTS:  *  * NOTES:  *  This doesn't actually get called in a production system -   *  the macro gets expanded instead in place of calls to this proc.  *  But for debugging, we call this and that allows us to add  *  debugging messages easily here.  */
end_comment

begin_function
name|void
name|tp_local_credit
parameter_list|(
name|tpcb
parameter_list|)
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
name|LOCAL_CREDIT
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CREDIT
argument_list|)
name|printf
argument_list|(
literal|"ref 0x%x lcdt 0x%x l_tpdusize 0x%x decbit 0x%x\n"
argument_list|,
name|tpcb
operator|->
name|tp_refp
operator|-
name|tp_ref
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|,
name|tpcb
operator|->
name|tp_decbit
argument_list|,
name|tpcb
operator|->
name|tp_cong_win
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_CREDIT
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"lcdt tpdusz \n"
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
block|}
end_function

begin_comment
comment|/*  * NAME:  tp_protocol_error()  *  * CALLED FROM:  *  tp_driver(), when it doesn't know what to do with  * 	a combo of event, state, predicate  *  * FUNCTION and ARGUMENTS:  *  print error mesg   *  * RETURN VALUE:  *  EIO - always  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|int
name|tp_protocol_error
parameter_list|(
name|e
parameter_list|,
name|tpcb
parameter_list|)
name|struct
name|tp_event
modifier|*
name|e
decl_stmt|;
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"TP PROTOCOL ERROR! tpcb 0x%x event 0x%x, state 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|e
operator|->
name|ev_number
argument_list|,
name|tpcb
operator|->
name|tp_state
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_DRIVER
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"PROTOCOL ERROR tpcb event state"
argument_list|,
name|tpcb
argument_list|,
name|e
operator|->
name|ev_number
argument_list|,
name|tpcb
operator|->
name|tp_state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
return|return
name|EIO
return|;
comment|/* for lack of anything better */
block|}
end_function

begin_comment
comment|/* Not used at the moment */
end_comment

begin_function
name|ProtoHook
name|tp_drain
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * NAME: tp_indicate()  *  * CALLED FROM:  * 	tp.trans when XPD arrive, when a connection is being disconnected by  *  the arrival of a DR or ER, and when a connection times out.  *  * FUNCTION and ARGUMENTS:  *  (ind) is the type of indication : T_DISCONNECT, T_XPD  *  (error) is an E* value that will be put in the socket structure  *  to be passed along to the user later.  * 	Gives a SIGURG to the user process or group indicated by the socket  * 	attached to the tpcb.  *  * RETURNS:  Rien  *   * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|void
name|tp_indicate
parameter_list|(
name|ind
parameter_list|,
name|tpcb
parameter_list|,
name|error
parameter_list|)
name|int
name|ind
decl_stmt|;
name|u_short
name|error
decl_stmt|;
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
specifier|register
name|struct
name|socket
modifier|*
name|so
init|=
name|tpcb
operator|->
name|tp_sock
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_INDICATION
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTindicate
argument_list|,
name|ind
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_lsuffix
operator|)
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_fsuffix
operator|)
argument_list|,
name|error
argument_list|,
name|so
operator|->
name|so_pgrp
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_INDICATION
argument_list|)
name|u_char
modifier|*
name|ls
decl_stmt|,
modifier|*
name|fs
decl_stmt|;
name|ls
operator|=
name|tpcb
operator|->
name|tp_lsuffix
operator|,
name|fs
operator|=
name|tpcb
operator|->
name|tp_fsuffix
operator|,
name|printf
argument_list|(
literal|"indicate 0x%x lsuf 0x%02x%02x fsuf 0x%02x%02x err 0x%x prgp 0x%x noind 0x%x ref 0x%x\n"
argument_list|,
name|ind
argument_list|,
operator|*
name|ls
argument_list|,
operator|*
operator|(
name|ls
operator|+
literal|1
operator|)
argument_list|,
operator|*
name|fs
argument_list|,
operator|*
operator|(
name|fs
operator|+
literal|1
operator|)
argument_list|,
name|error
argument_list|,
name|so
operator|->
name|so_pgrp
argument_list|,
name|tpcb
operator|->
name|tp_no_disc_indications
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|so
operator|->
name|so_error
init|=
name|error
decl_stmt|;
if|if
condition|(
name|ind
operator|==
name|T_DISCONNECT
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_no_disc_indications
condition|)
return|return;
block|}
name|IFTRACE
argument_list|(
argument|D_INDICATION
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"doing sohasoutofband(so)"
argument_list|,
name|so
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|sohasoutofband
argument_list|(
name|so
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * NAME : tp_getoptions()  *  * CALLED FROM:  * 	tp.trans whenever we go into OPEN state   *  * FUNCTION and ARGUMENTS:  *  sets the proper flags and values in the tpcb, to control  *  the appropriate actions for the given class, options,  *  sequence space, etc, etc.  *   * RETURNS: Nada  *   * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|void
name|tp_getoptions
parameter_list|(
name|tpcb
parameter_list|)
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
name|tpcb
operator|->
name|tp_seqmask
operator|=
name|tpcb
operator|->
name|tp_xtd_format
condition|?
name|TP_XTD_FMT_MASK
else|:
name|TP_NML_FMT_MASK
expr_stmt|;
name|tpcb
operator|->
name|tp_seqbit
operator|=
name|tpcb
operator|->
name|tp_xtd_format
condition|?
name|TP_XTD_FMT_BIT
else|:
name|TP_NML_FMT_BIT
expr_stmt|;
name|tpcb
operator|->
name|tp_seqhalf
operator|=
name|tpcb
operator|->
name|tp_seqbit
operator|>>
literal|1
expr_stmt|;
name|tpcb
operator|->
name|tp_dt_ticks
operator|=
name|MAX
argument_list|(
name|tpcb
operator|->
name|tp_dt_ticks
argument_list|,
operator|(
name|tpcb
operator|->
name|tp_peer_acktime
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NAME:  tp_recycle_tsuffix()  *  * CALLED FROM:  *  Called when a ref is frozen.  *  * FUNCTION and ARGUMENTS:  *  allows the suffix to be reused.   *  * RETURNS: zilch  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|void
name|tp_recycle_tsuffix
parameter_list|(
name|tpcb
parameter_list|)
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
name|bzero
argument_list|(
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
sizeof|sizeof
argument_list|(
name|tpcb
operator|->
name|tp_lsuffix
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tpcb
operator|->
name|tp_fsuffix
argument_list|,
sizeof|sizeof
argument_list|(
name|tpcb
operator|->
name|tp_fsuffix
argument_list|)
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_fsuffixlen
operator|=
name|tpcb
operator|->
name|tp_lsuffixlen
operator|=
literal|0
expr_stmt|;
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_recycle_suffix
call|)
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NAME: tp_quench()  *  * CALLED FROM:  *  tp{af}_quench() when ICMP source quench or similar thing arrives.  *  * FUNCTION and ARGUMENTS:  *  Drop the congestion window back to 1.  *  Congestion window scheme:  *  Initial value is 1.  ("slow start" as Nagle, et. al. call it)  *  For each good ack that arrives, the congestion window is increased  *  by 1 (up to max size of logical infinity, which is to say,   *	it doesn't wrap around).  *  Source quench causes it to drop back to 1.  *  tp_send() uses the smaller of (regular window, congestion window).   *  One retransmission strategy option is to have any retransmission   *	cause reset the congestion window back  to 1.  *  *	(cmd) is either PRC_QUENCH: source quench, or  *		PRC_QUENCH2: dest. quench (dec bit)  *  * RETURNS:  *   * SIDE EFFECTS:  *   * NOTES:  */
end_comment

begin_function
name|void
name|tp_quench
parameter_list|(
name|tpcb
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|IFDEBUG
argument_list|(
argument|D_QUENCH
argument_list|)
name|printf
argument_list|(
literal|"tp_quench tpcb 0x%x ref 0x%x sufx 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_lsuffix
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cong_win 0x%x decbit 0x%x \n"
argument_list|,
name|tpcb
operator|->
name|tp_cong_win
argument_list|,
name|tpcb
operator|->
name|tp_decbit
argument_list|)
expr_stmt|;
name|ENDDEBUG
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_QUENCH
case|:
name|tpcb
operator|->
name|tp_cong_win
operator|=
literal|1
expr_stmt|;
name|IncStat
argument_list|(
name|ts_quench
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_QUENCH2
case|:
name|tpcb
operator|->
name|tp_cong_win
operator|=
literal|1
expr_stmt|;
comment|/* might as well quench source also */
name|tpcb
operator|->
name|tp_decbit
operator|=
name|TP_DECBIT_CLEAR_COUNT
expr_stmt|;
name|IncStat
argument_list|(
name|ts_rcvdecbit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * NAME:	tp_netcmd()  *  * CALLED FROM:			  *  * FUNCTION and ARGUMENTS:			  *  * RETURNS:			  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|tp_netcmd
argument_list|(
argument|tpcb
argument_list|,
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|#
directive|if
name|NARGOXTWENTYFIVE
operator|>
literal|0
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CONN_CLOSE
case|:
case|case
name|CONN_REFUSE
case|:
name|cons_netcmd
argument_list|(
name|cmd
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|,
literal|0
argument_list|,
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_4
argument_list|)
expr_stmt|;
comment|/* TODO: can this last param be replaced by  	 	*	tpcb->tp_netserv != ISO_CONS?) 		*/
break|break;
default|default:
name|printf
argument_list|(
literal|"tp_netcmd(0x%x, 0x%x) NOT IMPLEMENTED\n"
argument_list|,
name|tpcb
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
else|NARGOXTWENTYFIVE
name|printf
argument_list|(
literal|"tp_netcmd(): X25 NOT CONFIGURED!!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NARGOXTWENTYFIVE> 0
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  tp_ctloutput() and tp_emit()  * FUNCTION and ARGUMENTS:  * 	Convert a class mask to the highest numeric value it represents.  */
end_comment

begin_function
name|int
name|tp_mask_to_num
parameter_list|(
name|x
parameter_list|)
name|u_char
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|4
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|x
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
operator|(
name|j
operator|==
literal|4
operator|)
operator|||
operator|(
name|j
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* for now */
if|if
condition|(
operator|(
name|j
operator|!=
literal|4
operator|)
operator|&&
operator|(
name|j
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ASSERTION ERROR: tp_mask_to_num: x 0x%x j %d\n"
argument_list|,
name|x
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|IFTRACE
argument_list|(
argument|D_TPINPUT
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_mask_to_num(x) returns j"
argument_list|,
name|x
argument_list|,
name|j
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tp_mask_to_num(0x%x) returns 0x%x\n"
argument_list|,
name|x
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|ENDDEBUG
return|return
name|j
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|copyQOSparms
argument_list|(
argument|src
argument_list|,
argument|dst
argument_list|)
expr|struct
name|tp_conn_param
operator|*
name|src
operator|,
operator|*
name|dst
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* copy all but the bits stuff at the end */
define|#
directive|define
name|COPYSIZE
value|(12 * sizeof(short))
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|COPYSIZE
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_tpdusize
operator|=
name|src
operator|->
name|p_tpdusize
expr_stmt|;
name|dst
operator|->
name|p_ack_strat
operator|=
name|src
operator|->
name|p_ack_strat
expr_stmt|;
name|dst
operator|->
name|p_rx_strat
operator|=
name|src
operator|->
name|p_rx_strat
expr_stmt|;
undef|#
directive|undef
name|COPYSIZE
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  tp_usrreq on PRU_CONNECT and tp_input on receipt of CR  *	  * FUNCTION and ARGUMENTS:  * 	route directly to x.25 if the address is type 37 - GROT.  *  furthermore, let TP0 handle only type-37 addresses  *  *	Since this assumes that its address argument is in a mbuf, the  *	parameter was changed to reflect this assumtion. This also  *	implies that an mbuf must be allocated when this is  *	called from tp_input  *	  * RETURNS:  *	errno value	 :   *	EAFNOSUPPORT if can't find an nl_protosw for x.25 (really could panic)  *	ECONNREFUSED if trying to run TP0 with non-type 37 address  *  possibly other E* returned from cons_netcmd()  * NOTE:  *  Would like to eliminate as much of this as possible --   *  only one set of defaults (let the user set the parms according  *  to parameters provided in the directory service).  *  Left here for now 'cause we don't yet have a clean way to handle  *  it on the passive end.  */
end_comment

begin_function
name|int
name|tp_route_to
parameter_list|(
name|m
parameter_list|,
name|tpcb
parameter_list|,
name|channel
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|u_int
name|channel
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
comment|/* NOTE: this may be a sockaddr_in */
specifier|extern
name|struct
name|tp_conn_param
name|tp_conn_param
index|[]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|vc_to_kill
init|=
literal|0
decl_stmt|;
comment|/* kludge */
name|siso
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"route_to: so  afi netservice class"
argument_list|,
name|tpcb
operator|->
name|tp_sock
argument_list|,
name|siso
operator|->
name|siso_addr
operator|.
name|isoa_afi
argument_list|,
name|tpcb
operator|->
name|tp_netservice
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_route_to( m x%x, channel 0x%x, tpcb 0x%x netserv 0x%x)\n"
argument_list|,
name|m
argument_list|,
name|channel
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_netservice
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"m->mlen x%x, m->m_data:\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|siso
operator|->
name|siso_family
operator|!=
name|tpcb
operator|->
name|tp_domain
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|{
specifier|register
name|int
name|save_netservice
init|=
name|tpcb
operator|->
name|tp_netservice
decl_stmt|;
switch|switch
condition|(
name|tpcb
operator|->
name|tp_netservice
condition|)
block|{
case|case
name|ISO_COSNS
case|:
case|case
name|ISO_CLNS
case|:
comment|/* This is a kludge but seems necessary so the passive end 			 * can get long enough timers. sigh. 			 */
if|if
condition|(
name|siso
operator|->
name|siso_addr
operator|.
name|osinet_idi
index|[
literal|1
index|]
operator|==
operator|(
name|u_char
operator|)
name|IDI_OSINET
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_dont_change_params
operator|==
literal|0
condition|)
block|{
name|copyQOSparms
argument_list|(
operator|&
name|tp_conn_param
index|[
name|ISO_COSNS
index|]
argument_list|,
operator|&
name|tpcb
operator|->
name|_tp_param
argument_list|)
expr_stmt|;
block|}
name|tpcb
operator|->
name|tp_flags
operator||=
name|TPF_NLQOS_PDN
expr_stmt|;
block|}
comment|/* drop through to IN_CLNS*/
case|case
name|IN_CLNS
case|:
if|if
condition|(
operator|(
name|tpcb
operator|->
name|tp_class
operator|&
name|TP_CLASS_4
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EPROTOTYPE
expr_stmt|;
break|break;
block|}
name|tpcb
operator|->
name|tp_class
operator|=
name|TP_CLASS_4
expr_stmt|;
comment|/* IGNORE dont_change_parms */
break|break;
case|case
name|ISO_CONS
case|:
if|#
directive|if
name|NARGOXTWENTYFIVE
operator|>
literal|0
name|tpcb
operator|->
name|tp_flags
operator||=
name|TPF_NLQOS_PDN
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_dont_change_params
operator|==
literal|0
condition|)
block|{
name|copyQOSparms
argument_list|(
operator|&
name|tp_conn_param
index|[
name|ISO_CONS
index|]
argument_list|,
operator|&
name|tpcb
operator|->
name|_tp_param
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * for use over x.25 really need a small receive window, 			 * need to start slowly, need small max negotiable tpdu size, 			 * and need to use the congestion window to the max 			 * IGNORES tp_dont_change_params for these! 			 */
if|if
condition|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|>
literal|512
condition|)
block|{
operator|(
name|void
operator|)
name|soreserve
argument_list|(
name|tpcb
operator|->
name|tp_sock
argument_list|,
literal|512
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* GAG */
block|}
name|tpcb
operator|->
name|tp_rx_strat
operator|=
name|TPRX_USE_CW
expr_stmt|;
if|if
condition|(
operator|(
name|tpcb
operator|->
name|tp_nlproto
operator|!=
operator|&
name|nl_protosw
index|[
name|ISO_CONS
index|]
operator|)
condition|)
block|{
comment|/* if the listener was restricting us to clns, 				 * ( we never get here if the listener isn't af_iso ) 				 * refuse the connection : 				 * but we don't have a way to restrict thus - it's 				 * utterly permissive. 					if(channel)  { 						(void) cons_netcmd(CONN_REFUSE, tpcb->tp_npcb,  								channel, tpcb->tp_class == TP_CLASS_4); 						error = EPFNOSUPPORT; 						goto done; 					} 				 */
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_route_to( CHANGING nlproto old 0x%x new 0x%x)\n"
argument_list|,
name|tpcb
operator|->
name|tp_nlproto
argument_list|,
operator|&
name|nl_protosw
index|[
name|ISO_CONS
index|]
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tpcb
operator|->
name|tp_nlproto
init|=
operator|&
name|nl_protosw
index|[
name|ISO_CONS
index|]
decl_stmt|;
block|}
comment|/* Now we've got the right nl_protosw.  			 * If we already have a channel (we were called from tp_input()) 			 * tell cons that we'll hang onto this channel. 			 * If we don't already have one (we were called from usrreq()) 			 * -and if it's TP0 open a net connection and wait for it to finish. 			 */
if|if
condition|(
name|channel
condition|)
block|{
name|error
operator|=
name|cons_netcmd
argument_list|(
name|CONN_CONFIRM
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|channel
argument_list|,
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_4
argument_list|)
expr_stmt|;
name|vc_to_kill
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tpcb
operator|->
name|tp_class
operator|!=
name|TP_CLASS_4
comment|/* class 4 only */
condition|)
block|{
comment|/* better open vc if any possibility of ending up  				 * in non-multiplexing class 				 */
name|error
operator|=
name|cons_openvc
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|siso
argument_list|,
name|tpcb
operator|->
name|tp_sock
argument_list|)
expr_stmt|;
name|vc_to_kill
operator|++
expr_stmt|;
block|}
comment|/* class 4 doesn't need to open a vc now - may use one already  			 * opened or may open one only when it sends a pkt. 			 */
else|#
directive|else
else|NARGOXTWENTYFIVE> 0
name|error
operator|=
name|ECONNREFUSED
expr_stmt|;
endif|#
directive|endif
endif|NARGOXTWENTYFIVE> 0
break|break;
default|default:
name|error
operator|=
name|EPROTOTYPE
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|save_netservice
operator|==
name|tpcb
operator|->
name|tp_netservice
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_route_to  calling nlp_pcbconn, netserv %d\n"
argument_list|,
name|tpcb
operator|->
name|tp_netservice
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|error
init|=
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_pcbconn
call|)
argument_list|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_pcb
argument_list|,
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|&&
name|vc_to_kill
condition|)
block|{
name|tp_netcmd
argument_list|(
name|tpcb
argument_list|,
name|CONN_CLOSE
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* PHASE 2: replace iso_netmatch with iso_on_localnet(foreign addr) */
if|if
condition|(
name|iso_netmatch
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_pcb
operator|)
operator|)
operator|->
name|isop_laddr
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|isopcb
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_pcb
operator|)
operator|)
operator|->
name|isop_faddr
operator|)
argument_list|)
condition|)
block|{
name|tpcb
operator|->
name|tp_flags
operator||=
name|TPF_PEER_ON_SAMENET
expr_stmt|;
block|}
block|{
comment|/* start with the global rtt, rtv stats */
specifier|register
name|int
name|i
init|=
operator|(
name|int
operator|)
name|tpcb
operator|->
name|tp_flags
operator|&
operator|(
name|TPF_PEER_ON_SAMENET
operator||
name|TPF_NLQOS_PDN
operator|)
decl_stmt|;
name|tpcb
operator|->
name|tp_rtt
operator|=
name|tp_stat
operator|.
name|ts_rtt
index|[
name|i
index|]
expr_stmt|;
name|tpcb
operator|->
name|tp_rtv
operator|=
name|tp_stat
operator|.
name|ts_rtv
index|[
name|i
index|]
expr_stmt|;
block|}
name|done
label|:
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_route_to  returns 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_CONN
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"route_to: returns: error netserv class"
argument_list|,
name|error
argument_list|,
name|tpcb
operator|->
name|tp_netservice
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
end_ifdef

begin_comment
comment|/*  * CALLED FROM:  *  tp_ctloutput() when the user sets TPOPT_PERF_MEAS on  *  and tp_newsocket() when a new connection is made from   *  a listening socket with tp_perf_on == true.  * FUNCTION and ARGUMENTS:  *  (tpcb) is the usual; this procedure gets a clear cluster mbuf for  *  a tp_pmeas structure, and makes tpcb->tp_p_meas point to it.  * RETURN VALUE:  *  ENOBUFS if it cannot get a cluster mbuf.  */
end_comment

begin_function
name|int
name|tp_setup_perf
parameter_list|(
name|tpcb
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_p_meas
operator|==
operator|(
expr|struct
name|tp_pmeas
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* allocate a cluster for all the stats */
name|MGET
argument_list|(
name|q
argument_list|,
name|M_DONTWAIT
argument_list|,
name|TPMT_PERF
argument_list|)
expr_stmt|;
comment|/* something we don't otherwise use */
if|if
condition|(
name|q
operator|==
literal|0
condition|)
return|return
name|ENOBUFS
return|;
name|q
operator|->
name|m_act
operator|=
name|MNULL
expr_stmt|;
name|MCLGET
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* for the tp_pmeas struct */
if|if
condition|(
name|q
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
else|else
block|{
comment|/* point into the cluster */
name|tpcb
operator|->
name|tp_p_meas
operator|=
name|mtod
argument_list|(
name|q
argument_list|,
expr|struct
name|tp_pmeas
operator|*
argument_list|)
expr_stmt|;
comment|/* get rid of the original little mbuf */
name|q
operator|->
name|m_off
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m_free
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_p_meas
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tp_pmeas
argument_list|)
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_PERF_MEAS
argument_list|)
name|printf
argument_list|(
literal|"tpcb 0x%x so 0x%x ref 0x%x tp_p_meas 0x%x tp_perf_on 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sock
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|tpcb
operator|->
name|tp_p_meas
argument_list|,
name|tpcb
operator|->
name|tp_perf_on
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tpcb
operator|->
name|tp_perf_on
init|=
literal|1
decl_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|TP_PERF_MEAS
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_expr_stmt
name|dump_addr
argument_list|(
name|addr
argument_list|)
specifier|register
expr|struct
name|sockaddr
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|dump_inaddr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_ISO
case|:
name|dump_isoaddr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"BAD AF: 0x%x\n"
argument_list|,
name|addr
operator|->
name|sa_family
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|ARGO_DEBUG
end_endif

end_unit

