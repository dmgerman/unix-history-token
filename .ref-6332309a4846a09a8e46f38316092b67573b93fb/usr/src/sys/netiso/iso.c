begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * $Header: iso.c,v 4.11 88/09/19 14:58:35 root Exp $   * $Source: /usr/argo/sys/netiso/RCS/iso.c,v $   *  * iso.c: miscellaneous routines to support the iso address family  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: iso.c,v 4.11 88/09/19 14:58:35 root Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/types.h"
end_include

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/domain.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/uio.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../net/af.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso_var.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso_snpac.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/iso_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/clnp.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/argo_debug.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_decl_stmt
name|int
name|iso_interfaces
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of external interfaces */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|ifnet
name|loif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* loopback interface */
end_comment

begin_comment
comment|/*  * FUNCTION:		iso_init  *  * PURPOSE:			initialize the iso address family  *  * RETURNS:			nothing  *  * SIDE EFFECTS:	1) zeros the maptab table.  *  * NOTES:			  */
end_comment

begin_macro
name|iso_init
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|struct
name|maptab
name|iso_snpac
index|[]
decl_stmt|;
specifier|extern
name|int
name|iso_snpac_size
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|iso_snpac
argument_list|,
name|iso_snpac_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|snpa_cache
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_addrmatch1  *  * PURPOSE:			decide if the two iso_addrs passed are equal  *  * RETURNS:			true if the addrs match, false if they do not  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|iso_addrmatch1
argument_list|(
argument|isoaa
argument_list|,
argument|isoab
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoaa
decl_stmt|,
modifier|*
name|isoab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* addresses to check */
end_comment

begin_block
block|{
name|int
name|compare_len
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_addrmatch1: comparing lengths: %d to %d\n"
argument_list|,
name|isoaa
operator|->
name|isoa_len
argument_list|,
name|isoab
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"a:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
operator|(
name|caddr_t
operator|)
name|isoaa
argument_list|,
name|isoaa
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"b:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
operator|(
name|caddr_t
operator|)
name|isoab
argument_list|,
name|isoab
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|compare_len
operator|=
name|isoaa
operator|->
name|isoa_len
operator|)
operator|!=
name|isoab
operator|->
name|isoa_len
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_addrmatch1: returning false because of lengths\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
literal|0
return|;
block|}
comment|/* TODO : generalize this to all afis with masks */
if|if
condition|(
name|isoaa
operator|->
name|isoa_afi
operator|==
name|AFI_37
condition|)
block|{
comment|/* must not compare 2 least significant digits, or for 		 * that matter, the DSP 		 */
name|compare_len
operator|=
name|ADDR37_IDI_LEN
operator|-
literal|1
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|a
operator|=
operator|(
name|char
operator|*
operator|)
name|isoaa
expr_stmt|;
name|b
operator|=
operator|(
name|char
operator|*
operator|)
name|isoab
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|compare_len
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"<%x=%x>"
argument_list|,
name|a
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|,
name|b
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
name|i
index|]
operator|!=
name|b
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"\naddrs are not equal at byte %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addrs are equal\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|ENDDEBUG
return|return
operator|(
operator|!
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|isoaa
argument_list|,
operator|(
name|caddr_t
operator|)
name|isoab
argument_list|,
name|compare_len
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_addrmatch  *  * PURPOSE:			decide if the two sockadrr_isos passed are equal  *  * RETURNS:			true if the addrs match, false if they do not  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|iso_addrmatch
argument_list|(
argument|sisoa
argument_list|,
argument|sisob
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|sisoa
decl_stmt|,
modifier|*
name|sisob
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* addresses to check */
end_comment

begin_block
block|{
return|return
operator|(
name|iso_addrmatch1
argument_list|(
operator|&
name|sisoa
operator|->
name|siso_addr
argument_list|,
operator|&
name|sisob
operator|->
name|siso_addr
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_netmatch  *  * PURPOSE:			similar to iso_addrmatch but takes sockaddr_iso  *					as argument.  *  * RETURNS:			true if same net, false if not  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|iso_netmatch
argument_list|(
argument|sisoa
argument_list|,
argument|sisob
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|sisoa
decl_stmt|,
modifier|*
name|sisob
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
name|bufa
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
index|]
decl_stmt|;
name|u_char
name|bufb
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|lena
decl_stmt|,
name|lenb
decl_stmt|;
name|lena
operator|=
name|iso_netof
argument_list|(
operator|&
name|sisoa
operator|->
name|siso_addr
argument_list|,
name|bufa
argument_list|)
expr_stmt|;
name|lenb
operator|=
name|iso_netof
argument_list|(
operator|&
name|sisob
operator|->
name|siso_addr
argument_list|,
name|bufb
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_netmatch: comparing lengths: %d to %d\n"
argument_list|,
name|lena
argument_list|,
name|lenb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"a:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|bufa
argument_list|,
name|lena
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"b:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|bufb
argument_list|,
name|lenb
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
operator|(
name|lena
operator|==
name|lenb
operator|)
operator|&&
operator|(
operator|!
name|bcmp
argument_list|(
name|bufa
argument_list|,
name|bufb
argument_list|,
name|lena
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_hashchar  *  * PURPOSE:			Hash all character in the buffer specified into  *					a long. Return the long.  *  * RETURNS:			The hash value.  *  * SIDE EFFECTS:	  *  * NOTES:			The hash is achieved by exclusive ORing 4 byte  *					quantities.   */
end_comment

begin_function
name|u_long
name|iso_hashchar
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
specifier|register
name|caddr_t
name|buf
decl_stmt|;
comment|/* buffer to pack from */
specifier|register
name|int
name|len
decl_stmt|;
comment|/* length of buffer */
block|{
specifier|register
name|u_long
name|h
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|4
control|)
block|{
specifier|register
name|u_long
name|l
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|-
name|i
operator|)
operator|<
literal|4
condition|)
block|{
comment|/* buffer not multiple of 4 */
switch|switch
condition|(
name|len
operator|-
name|i
condition|)
block|{
case|case
literal|3
case|:
name|l
operator||=
name|buf
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
case|case
literal|2
case|:
name|l
operator||=
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|16
expr_stmt|;
case|case
literal|1
case|:
name|l
operator||=
name|buf
index|[
name|i
index|]
operator|<<
literal|24
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"iso_hashchar: unexpected value x%x\n"
argument_list|,
name|len
operator|-
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|l
operator||=
name|buf
index|[
name|i
index|]
operator|<<
literal|24
expr_stmt|;
name|l
operator||=
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|<<
literal|16
expr_stmt|;
name|l
operator||=
name|buf
index|[
name|i
operator|+
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
name|l
operator||=
name|buf
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|h
operator|^=
name|l
expr_stmt|;
block|}
name|h
operator|^=
call|(
name|u_long
call|)
argument_list|(
name|len
operator|%
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_hash  *  * PURPOSE:			Fill in fields of afhash structure based upon addr passed.  *  * RETURNS:			none  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|iso_hash
argument_list|(
argument|siso
argument_list|,
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address to perform hash on */
end_comment

begin_decl_stmt
name|struct
name|afhash
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN: hash info here */
end_comment

begin_block
block|{
name|u_long
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
operator|+
literal|1
operator|/
literal|4
index|]
decl_stmt|;
specifier|register
name|int
name|bufsize
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|bufsize
operator|=
name|iso_netof
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|hp
operator|->
name|afh_nethash
operator|=
name|iso_hashchar
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_hash: iso_netof: bufsize = %d\n"
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|hp
operator|->
name|afh_hosthash
init|=
name|iso_hashchar
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
name|siso
operator|->
name|siso_addr
operator|.
name|isoa_len
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_hash: %s: nethash = x%x, hosthash = x%x\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|)
argument_list|,
name|hp
operator|->
name|afh_nethash
argument_list|,
name|hp
operator|->
name|afh_hosthash
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_netof  *  * PURPOSE:			Extract the network portion of the iso address.  *					The network portion of the iso address varies depending  *					on the type of address. The network portion of the  *					address will include the IDP. The network portion is:  *			  *						TYPE			DESC  *					t37					The AFI and x.121 (IDI)  *					osinet				The AFI, orgid, snetid  *					rfc986				The AFI, vers and network part of  *										internet address.  *  * RETURNS:			number of bytes placed into buf.  *  * SIDE EFFECTS:	  *  * NOTES:			Buf is assumed to be big enough  */
end_comment

begin_macro
name|iso_netof
argument_list|(
argument|isoa
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address */
end_comment

begin_decl_stmt
name|caddr_t
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RESULT: network portion of address here */
end_comment

begin_block
block|{
name|u_int
name|len
init|=
literal|1
decl_stmt|;
comment|/* length of afi */
switch|switch
condition|(
name|isoa
operator|->
name|isoa_afi
condition|)
block|{
case|case
name|AFI_37
case|:
comment|/* 			 * Due to classic x.25 tunnel vision, there is no 			 * net portion of an x.121 address.  For our purposes 			 * the AFI will do, so that all x.25 -type addresses 			 * map to the single x.25 SNPA. (Cannot have more than 			 * one, obviously). 			 */
break|break;
comment|/* 		case AFI_OSINET:*/
case|case
name|AFI_RFC986
case|:
block|{
name|u_short
name|idi
decl_stmt|;
comment|/* value of idi */
comment|/* osinet and rfc986 have idi in the same place */
name|CTOH
argument_list|(
name|isoa
operator|->
name|rfc986_idi
index|[
literal|0
index|]
argument_list|,
name|isoa
operator|->
name|rfc986_idi
index|[
literal|1
index|]
argument_list|,
name|idi
argument_list|)
expr_stmt|;
if|if
condition|(
name|idi
operator|==
name|IDI_OSINET
condition|)
comment|/*  *	Network portion of OSINET address can only be the IDI. Clearly,  *	with one x25 interface, one could get to several orgids, and  *	several snetids. 				len += (ADDROSINET_IDI_LEN + OVLOSINET_ORGID_LEN +  						OVLOSINET_SNETID_LEN);  */
name|len
operator|+=
name|ADDROSINET_IDI_LEN
expr_stmt|;
elseif|else
if|if
condition|(
name|idi
operator|==
name|IDI_RFC986
condition|)
block|{
name|u_long
name|inetaddr
decl_stmt|;
name|struct
name|ovl_rfc986
modifier|*
name|o986
init|=
operator|(
expr|struct
name|ovl_rfc986
operator|*
operator|)
name|isoa
decl_stmt|;
comment|/* bump len to include idi and version (1 byte) */
name|len
operator|+=
name|ADDRRFC986_IDI_LEN
operator|+
literal|1
expr_stmt|;
comment|/* get inet addr long aligned */
name|bcopy
argument_list|(
name|o986
operator|->
name|o986_inetaddr
argument_list|,
operator|&
name|inetaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inetaddr
argument_list|)
argument_list|)
expr_stmt|;
name|inetaddr
operator|=
name|ntohl
argument_list|(
name|inetaddr
argument_list|)
expr_stmt|;
comment|/* convert to host byte order */
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_netof: isoa "
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|isoa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|isoa
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iso_netof: inetaddr 0x%x "
argument_list|,
name|inetaddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* bump len by size of network portion of inet address */
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|inetaddr
argument_list|)
condition|)
block|{
name|len
operator|+=
literal|4
operator|-
name|IN_CLASSA_NSHIFT
operator|/
literal|8
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_netof: class A net len is now %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|inetaddr
argument_list|)
condition|)
block|{
name|len
operator|+=
literal|4
operator|-
name|IN_CLASSB_NSHIFT
operator|/
literal|8
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_netof: class B net len is now %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
else|else
block|{
name|len
operator|+=
literal|4
operator|-
name|IN_CLASSC_NSHIFT
operator|/
literal|8
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_netof: class C net len is now %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
else|else
name|len
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|isoa
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"in_netof: isoa "
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|isoa
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"in_netof: net "
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|len
return|;
block|}
end_block

begin_comment
comment|/*  *	The following is a kludge until I figure something out. Since AFISO  *	allows>1 addr/ifp, SIOCGIFADDR can possibly return more than one  *	address. Rather than changing the ifreq structure, I have set up  *	the ioctl so it will return the address in sequential calls. When  *	all addresses have been read, EADDRNOTAVAIL will be returned.  *  *	A call to delete or set an addr will cause a subsequent get to  *	retrieve the first addr, even if the first had already been read.  *  *	The static pointer iso_ia keeps track of which addrs have been read.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|iso_ifaddr
modifier|*
name|iso_iap
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FUNCTION:		iso_control  *  * PURPOSE:			Generic iso control operations (ioctl's).  *					Ifp is 0 if this is not an interface-specific ioctl.  *  * RETURNS:			unix error code  *  * SIDE EFFECTS:	  *  * NOTES:			The iso address family will allow more than one  *					iso address per interface as long as they are different  *					iso address types. The three types currently supported   *					are rfc986, t37, and osinet.  */
end_comment

begin_macro
name|iso_control
argument_list|(
argument|so
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket ioctl arrived on */
end_comment

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioctl to perform */
end_comment

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data for the ioctl */
end_comment

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* optional interface ptr */
end_comment

begin_block
block|{
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia
init|=
literal|0
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
operator|!
name|suser
argument_list|()
condition|)
return|return
operator|(
name|u
operator|.
name|u_error
operator|)
return|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"iso_control: SIOCSIFADDR"
argument_list|)
expr_stmt|;
comment|/*  		 *	Check if a iso address of same type exists for ifp  		 *	If it does, then return an error. 		 */
for|for
control|(
name|ia
operator|=
name|iso_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
if|if
condition|(
name|ia
operator|->
name|ia_ifp
operator|==
name|ifp
condition|)
block|{
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
name|siso
operator|=
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_addr
expr_stmt|;
if|if
condition|(
name|iso_eqtype
argument_list|(
operator|&
name|IA_SIS
argument_list|(
name|ia
argument_list|)
operator|->
name|siso_addr
argument_list|,
operator|&
name|siso
operator|->
name|siso_addr
argument_list|)
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
block|}
comment|/* 		 *	Go ahead and create new ifaddr 		 * 		 *	Link addr into list of iso addresses 		 */
name|m
operator|=
name|m_getclr
argument_list|(
name|M_WAIT
argument_list|,
name|MT_IFADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
if|if
condition|(
name|ia
operator|=
name|iso_ifaddr
condition|)
block|{
for|for
control|(
init|;
name|ia
operator|->
name|ia_next
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
empty_stmt|;
name|ia
operator|->
name|ia_next
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|iso_ifaddr
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
name|iso_ifaddr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|iso_ifaddr
operator|*
argument_list|)
expr_stmt|;
name|iso_iap
operator|=
name|iso_ifaddr
expr_stmt|;
comment|/* 		 *	Link addr into list on interface 		 */
name|ia
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|iso_ifaddr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
condition|)
block|{
for|for
control|(
init|;
name|ifa
operator|->
name|ifa_next
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
empty_stmt|;
name|ifa
operator|->
name|ifa_next
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|ia
expr_stmt|;
block|}
else|else
name|ifp
operator|->
name|if_addrlist
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|ia
expr_stmt|;
name|ia
operator|->
name|ia_ifp
operator|=
name|ifp
expr_stmt|;
name|IA_SIS
argument_list|(
name|ia
argument_list|)
operator|->
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
operator|&
name|loif
condition|)
name|iso_interfaces
operator|++
expr_stmt|;
return|return
operator|(
name|iso_ifinit
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|,
operator|&
name|ifr
operator|->
name|ifr_addr
argument_list|)
operator|)
return|;
case|case
name|SIOCGIFADDR
case|:
for|for
control|(
name|ia
operator|=
name|iso_iap
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
if|if
condition|(
name|ia
operator|->
name|ia_ifp
operator|==
name|ifp
condition|)
block|{
name|ifr
operator|->
name|ifr_addr
operator|=
name|ia
operator|->
name|ia_addr
expr_stmt|;
name|iso_iap
operator|=
name|ia
operator|->
name|ia_next
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|iso_iap
operator|=
name|iso_ifaddr
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
case|case
name|SIOCDIFADDR
case|:
comment|/* TODO: what about this ioctl on other families */
if|if
condition|(
operator|!
name|suser
argument_list|()
condition|)
return|return
operator|(
name|u
operator|.
name|u_error
operator|)
return|;
name|iso_iap
operator|=
name|iso_ifaddr
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"iso_control: SIOCDIFADDR"
argument_list|)
expr_stmt|;
return|return
operator|(
name|iso_ifdelete
argument_list|(
name|ifp
argument_list|,
operator|&
name|ifr
operator|->
name|ifr_addr
argument_list|)
operator|)
return|;
default|default:
if|if
condition|(
name|ifp
operator|==
literal|0
operator|||
name|ifp
operator|->
name|if_ioctl
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_function
name|struct
name|ifaddr
modifier|*
name|iso_ifwithidi
parameter_list|(
name|addr
parameter_list|)
specifier|register
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
specifier|register
name|u_int
name|af
init|=
name|addr
operator|->
name|sa_family
decl_stmt|;
if|if
condition|(
name|af
operator|!=
name|AF_ISO
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|">>> iso_ifwithidi addr\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|(
name|addr
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|if_next
control|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_ifwithidi ifnet %s\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|)
expr_stmt|;
name|ENDDEBUG
for|for
control|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_ifwithidi address "
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|(
operator|&
name|ifa
operator|->
name|ifa_addr
operator|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|.
name|sa_family
operator|!=
name|addr
operator|->
name|sa_family
condition|)
continue|continue;
define|#
directive|define
name|IFA_SIS
parameter_list|(
name|ifa
parameter_list|)
define|\
value|((struct sockaddr_iso *)&((ifa)->ifa_addr))
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|" af same, args to iso_eqtype:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|IFA_SIS
argument_list|(
name|ifa
argument_list|)
operator|->
name|siso_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" 0x%x\n"
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|addr
operator|)
operator|->
name|siso_addr
operator|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|iso_eqtype
argument_list|(
operator|&
operator|(
name|IFA_SIS
argument_list|(
name|ifa
argument_list|)
operator|->
name|siso_addr
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|addr
operator|)
operator|->
name|siso_addr
operator|)
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"ifa_ifwithidi: ifa found\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
name|ifa
operator|)
return|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|" iso_eqtype failed\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
return|return
operator|(
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		iso_ifinit  *  * PURPOSE:			Initialize an interface's iso address and  *					routing table entry.  *  * RETURNS:			unix error code  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_expr_stmt
name|iso_ifinit
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|,
name|siso
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* interface to initialize */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* addr on ifnet list */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address to use */
end_comment

begin_block
block|{
name|struct
name|sockaddr
name|oldaddr
decl_stmt|;
name|struct
name|sockaddr_iso
name|netaddr
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 *	Make sure the address make sense 	 */
if|if
condition|(
operator|!
name|iso_ck_addr
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|siso
expr_stmt|;
name|printf
argument_list|(
literal|"The size of sockaddr_iso is %d\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_iso
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"sockaddr[%d] = 0x%x\n"
argument_list|,
name|i
argument_list|,
operator|*
name|ptr
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
name|oldaddr
init|=
name|ia
operator|->
name|ia_addr
decl_stmt|;
name|ia
operator|->
name|ia_addr
operator|=
operator|*
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|siso
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|netaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|netaddr
argument_list|)
argument_list|)
expr_stmt|;
name|netaddr
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
comment|/* 	 * Give the interface a chance to initialize 	 */
if|if
condition|(
name|ifp
operator|->
name|if_ioctl
operator|&&
operator|(
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|SIOCSIFADDR
argument_list|,
name|ia
argument_list|)
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ia
operator|->
name|ia_addr
operator|=
name|oldaddr
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Add route for the network. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
name|rtinit
argument_list|(
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
operator|(
name|int
operator|)
name|SIOCADDRT
argument_list|,
name|RTF_HOST
operator||
name|RTF_UP
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|iso_netof
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|netaddr
operator|.
name|siso_addr
argument_list|)
expr_stmt|;
name|netaddr
operator|.
name|siso_addr
operator|.
name|isoa_len
operator|=
name|len
expr_stmt|;
name|rtinit
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|netaddr
argument_list|,
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
operator|(
name|int
operator|)
name|SIOCADDRT
argument_list|,
name|RTF_UP
argument_list|)
expr_stmt|;
block|}
name|ia
operator|->
name|ia_flags
operator||=
name|IFA_ROUTE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_ifdelete  *  * PURPOSE:			Delete an iso address from an interface.  *  * RETURNS:			0 or unix error code  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|iso_ifdelete
argument_list|(
argument|ifp
argument_list|,
argument|siso
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interface to delete addr from */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address to delete */
end_comment

begin_block
block|{
name|struct
name|iso_addr
modifier|*
name|isoa
init|=
operator|&
name|siso
operator|->
name|siso_addr
decl_stmt|;
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|sockaddr_iso
name|netaddr
decl_stmt|;
comment|/*  	 *	Find the iso address of same type as specified and delete it. 	 */
for|for
control|(
name|ia
operator|=
name|iso_ifaddr
init|;
name|ia
condition|;
name|prev
operator|=
name|ia
operator|,
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
if|if
condition|(
name|ia
operator|->
name|ia_ifp
operator|==
name|ifp
condition|)
block|{
if|if
condition|(
name|iso_eqtype
argument_list|(
operator|&
name|IA_SIS
argument_list|(
name|ia
argument_list|)
operator|->
name|siso_addr
argument_list|,
name|isoa
argument_list|)
condition|)
block|{
comment|/* 				 * Delete any previous route for the address. 				 */
name|IFDEBUG
argument_list|(
argument|D_IOCTL
argument_list|)
name|printf
argument_list|(
literal|"iso_ifdelete: delete %s\n"
argument_list|,
argument|clnp_iso_addrp(isoa)
argument_list|)
name|ENDDEBUG
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|netaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|netaddr
argument_list|)
argument_list|)
expr_stmt|;
name|netaddr
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
if|if
condition|(
name|ia
operator|->
name|ia_flags
operator|&
name|IFA_ROUTE
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
name|rtinit
argument_list|(
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
operator|(
name|int
operator|)
name|SIOCDELRT
argument_list|,
name|RTF_HOST
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|iso_netof
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|netaddr
operator|.
name|siso_addr
argument_list|)
expr_stmt|;
name|rtinit
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|netaddr
argument_list|,
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
operator|(
name|int
operator|)
name|SIOCDELRT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ia
operator|->
name|ia_flags
operator|&=
operator|~
name|IFA_ROUTE
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 				 *	Remove from list of iso addresses 				 */
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|iso_ifaddr
operator|=
name|ia
operator|->
name|ia_next
expr_stmt|;
else|else
name|prev
operator|->
name|ia_next
operator|=
name|ia
operator|->
name|ia_next
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
operator|&
name|loif
condition|)
name|iso_interfaces
operator|--
expr_stmt|;
comment|/* 				 *	Remove from list of addrs on ifnet structure 				 */
if|if
condition|(
operator|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
operator|)
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|ia
condition|)
name|ifp
operator|->
name|if_addrlist
operator|=
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_next
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_next
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|ia
condition|)
block|{
name|ifa
operator|->
name|ifa_next
operator|=
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_next
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 				 *	Free the iso_ifaddr mbuf 				 */
name|m_free
argument_list|(
name|dtom
argument_list|(
name|ia
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_ck_addr  *  * PURPOSE:			return true if the iso_addr passed is   *					within the legal size limit for an iso address.  *  * RETURNS:			true or false  *  * SIDE EFFECTS:	  *  */
end_comment

begin_macro
name|iso_ck_addr
argument_list|(
argument|isoa
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address to check */
end_comment

begin_block
block|{
return|return
operator|(
name|isoa
operator|->
name|isoa_len
operator|<=
literal|20
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_eqtype  *  * PURPOSE:			Determine if two iso addresses are of the same type.  *  This is flaky.  Really we should consider all type 47 addrs to be the  *  same - but there do exist different structures for 47 addrs.  *  Gosip adds a 3rd.  *  * RETURNS:			true if the addresses are the same type  *  * SIDE EFFECTS:	  *  * NOTES:			By type, I mean rfc986, t37, or osinet  *  *					This will first compare afis. If they match, then  *					if the addr is not t37, the idis must be compared.  */
end_comment

begin_macro
name|iso_eqtype
argument_list|(
argument|isoaa
argument_list|,
argument|isoab
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoaa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first addr to check */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* other addr to check */
end_comment

begin_block
block|{
if|if
condition|(
name|isoaa
operator|->
name|isoa_afi
operator|==
name|isoab
operator|->
name|isoa_afi
condition|)
block|{
if|if
condition|(
name|isoaa
operator|->
name|isoa_afi
operator|==
name|AFI_37
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|!
name|bcmp
argument_list|(
operator|&
name|isoaa
operator|->
name|isoa_u
argument_list|,
operator|&
name|isoab
operator|->
name|isoa_u
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_iaonnetof()  *  * PURPOSE:			Find and interface addresss based on the network  *					portion of an address.  *  * RETURNS:			ptr to an interface address   *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|struct
name|iso_ifaddr
modifier|*
name|iso_iaonnetof
parameter_list|(
name|siso
parameter_list|)
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
block|{
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
for|for
control|(
name|ia
operator|=
name|iso_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
if|if
condition|(
name|iso_netmatch
argument_list|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
operator|(
operator|&
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_addr
operator|)
argument_list|,
name|siso
argument_list|)
condition|)
return|return
operator|(
name|ia
operator|)
return|;
return|return
operator|(
operator|(
expr|struct
name|iso_ifaddr
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NARGOXTWENTYFIVE
name|>
name|0
end_ifdef

begin_include
include|#
directive|include
file|"cons.h"
end_include

begin_endif
endif|#
directive|endif
endif|NARGOXTWENTYFIVE> 0
end_endif

begin_comment
comment|/*  * FUNCTION:		iso_nlctloutput  *  * PURPOSE:			Set options at the network level  *  * RETURNS:			E*  *  * SIDE EFFECTS:	  *  * NOTES:			This could embody some of the functions of  *					rclnp_ctloutput and cons_ctloutput.  */
end_comment

begin_macro
name|iso_nlctloutput
argument_list|(
argument|cmd
argument_list|,
argument|optname
argument_list|,
argument|pcb
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command:set or get */
end_comment

begin_decl_stmt
name|int
name|optname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* option of interest */
end_comment

begin_decl_stmt
name|caddr_t
name|pcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nl pcb */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data for set, buffer for get */
end_comment

begin_block
block|{
name|struct
name|isopcb
modifier|*
name|isop
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|pcb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* return value */
name|caddr_t
name|data
decl_stmt|;
comment|/* data for option */
name|int
name|data_len
decl_stmt|;
comment|/* data's length */
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_nlctloutput: cmd %x, opt %x, pcb %x, m %x\n"
argument_list|,
name|cmd
argument_list|,
name|optname
argument_list|,
name|pcb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|cmd
operator|!=
name|PRCO_GETOPT
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|PRCO_SETOPT
operator|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|data_len
operator|=
operator|(
name|m
operator|)
operator|->
name|m_len
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_nlctloutput: data is:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
switch|switch
condition|(
name|optname
condition|)
block|{
ifdef|#
directive|ifdef
name|NARGOXTWENTYFIVE
name|>
name|0
case|case
name|CONSOPT_X25CRUD
case|:
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|data_len
operator|>
name|MAXX25CRUDLEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|IFDEBUG
argument_list|(
argument|D_ISO
argument_list|)
name|printf
argument_list|(
literal|"iso_nlctloutput: setting x25 crud\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|bcopy
argument_list|(
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|isop
operator|->
name|isop_x25crud
argument_list|,
name|data_len
argument_list|)
decl_stmt|;
name|isop
operator|->
name|isop_x25crud_len
operator|=
name|data_len
expr_stmt|;
break|break;
endif|#
directive|endif
endif|NARGOXTWENTYFIVE> 0
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		iso_routeifp  *  * PURPOSE:			Route on a sockaddr and return ifp  *  * RETURNS:			ifp of outgoing interface, or null  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|struct
name|ifnet
modifier|*
name|iso_routeifp
parameter_list|(
name|dst
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
comment|/* destination to route to */
block|{
name|struct
name|route
name|ro
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|ro
operator|.
name|ro_dst
operator|=
operator|*
name|dst
expr_stmt|;
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_routeifp: dst:"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|rtalloc
argument_list|(
operator|&
name|ro
argument_list|)
decl_stmt|;
if|if
condition|(
name|ro
operator|.
name|ro_rt
condition|)
block|{
name|ifp
operator|=
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ROUTE
argument_list|)
name|printf
argument_list|(
literal|"iso_routeifp: ifp x%x"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
condition|)
name|printf
argument_list|(
literal|" (%s%d)\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
name|ifp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_comment
comment|/*  * FUNCTION:		dump_isoaddr  *  * PURPOSE:			debugging  *  * RETURNS:			nada   *  */
end_comment

begin_macro
name|dump_isoaddr
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|caddr_t
name|c
init|=
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|s
operator|->
name|siso_addr
operator|.
name|isoa_u
operator|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|siso_family
operator|==
name|AF_ISO
condition|)
block|{
name|printf
argument_list|(
literal|"len %d family: 0x%x  suffix 0x%x, afi 0x%x,"
argument_list|,
operator|(
name|int
operator|)
name|s
operator|->
name|siso_addr
operator|.
name|isoa_len
argument_list|,
operator|(
name|int
operator|)
name|s
operator|->
name|siso_family
argument_list|,
name|s
operator|->
name|siso_tsuffix
argument_list|,
operator|(
name|int
operator|)
name|s
operator|->
name|siso_addr
operator|.
name|isoa_afi
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|siso_addr
operator|.
name|isoa_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ERROR-ADDR TOO BIG %d\n"
argument_list|,
name|s
operator|->
name|siso_addr
operator|.
name|isoa_len
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|s
operator|->
name|siso_addr
operator|.
name|isoa_len
operator|!=
literal|0
condition|)
block|{
comment|/* -2 because we already skipped the afi */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|siso_addr
operator|.
name|isoa_len
operator|-
literal|2
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"0x%x."
argument_list|,
operator|*
operator|(
name|c
operator|+
name|i
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x\n"
argument_list|,
operator|*
operator|(
name|c
operator|+
name|i
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|siso_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* hack */
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|s
decl_stmt|;
name|printf
argument_list|(
literal|"%d.%d.%d.%d: %d"
argument_list|,
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|)
operator|&
literal|0xff
argument_list|,
name|sin
operator|->
name|sin_port
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|ARGO_DEBUG
end_endif

end_unit

