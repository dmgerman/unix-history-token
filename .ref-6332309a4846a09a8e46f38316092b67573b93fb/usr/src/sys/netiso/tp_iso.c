begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  * $Header: tp_iso.c,v 5.3 88/11/18 17:27:57 nhall Exp $  * $Source: /usr/argo/sys/netiso/RCS/tp_iso.c,v $  *  * Here is where you find the iso-dependent code.  We've tried  * keep all net-level and (primarily) address-family-dependent stuff  * out of the tp source, and everthing here is reached indirectly  * through a switch table (struct nl_protosw *) tpcb->tp_nlproto   * (see tp_pcb.c).   * The routines here are:  * 		iso_getsufx: gets transport suffix out of an isopcb structure.  * 		iso_putsufx: put transport suffix into an isopcb structure.  *		iso_putnetaddr: put a whole net addr into an isopcb.  *		iso_getnetaddr: get a whole net addr from an isopcb.  *		iso_recycle_suffix: clear suffix for reuse in isopcb  * 		tpclnp_ctlinput: handle ER CNLPdu : icmp-like stuff  * 		tpclnp_mtu: figure out what size tpdu to use  *		tpclnp_input: take a pkt from clnp, strip off its clnp header,   *				give to tp  *		tpclnp_output_dg: package a pkt for clnp given 2 addresses& some data  *		tpclnp_output: package a pkt for clnp given an isopcb& some data  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: tp_iso.c,v 5.3 88/11/18 17:27:57 nhall Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|"../h/types.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/domain.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/time.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_param.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_tpdu.h"
end_include

begin_include
include|#
directive|include
file|"../netiso/tp_clnp.h"
end_include

begin_comment
comment|/*  * CALLED FROM:  * 	pr_usrreq() on PRU_BIND, PRU_CONNECT, PRU_ACCEPT, and PRU_PEERADDR  * FUNCTION, ARGUMENTS, and RETURN VALUE:  * 	Return a transport suffix from an isopcb structure (inp).  *  (CAST TO AN INT)  * 	The argument (which) takes the value TP_LOCAL or TP_FOREIGN.  */
end_comment

begin_function
name|short
name|iso_getsufx
parameter_list|(
name|isop
parameter_list|,
name|which
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|TP_LOCAL
case|:
return|return
name|htons
argument_list|(
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_tsuffix
argument_list|)
return|;
case|case
name|TP_FOREIGN
case|:
return|return
name|htons
argument_list|(
name|isop
operator|->
name|isop_faddr
operator|.
name|siso_tsuffix
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* CALLED FROM:  * 	tp_newsocket(); i.e., when a connection is being established by an  * 	incoming CR_TPDU.  *  * FUNCTION, ARGUMENTS:  * 	Put a transport suffix (found in name) into an isopcb structure (isop).  * 	The argument (which) takes the value TP_LOCAL or TP_FOREIGN.  */
end_comment

begin_function
name|void
name|iso_putsufx
parameter_list|(
name|isop
parameter_list|,
name|name
parameter_list|,
name|which
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|name
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|TP_LOCAL
case|:
name|isop
operator|->
name|isop_lport
operator|=
name|ntohs
argument_list|(
name|name
operator|->
name|siso_tsuffix
argument_list|)
expr_stmt|;
break|break;
case|case
name|TP_FOREIGN
case|:
name|isop
operator|->
name|isop_fport
operator|=
name|ntohs
argument_list|(
name|name
operator|->
name|siso_tsuffix
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  * 	tp.trans whenever we go into REFWAIT state.  * FUNCTION and ARGUMENT:  *	 Called when a ref is frozen, to allow the suffix to be reused.   * 	(isop) is the net level pcb.  This really shouldn't have to be  * 	done in a NET level pcb but... for the internet world that just  * 	the way it is done in BSD...  * 	The alternative is to have the port unusable until the reference  * 	timer goes off.  */
end_comment

begin_function
name|void
name|iso_recycle_tsuffix
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_tsuffix
operator|=
name|isop
operator|->
name|isop_faddr
operator|.
name|siso_tsuffix
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  * 	tp_newsocket(); i.e., when a connection is being established by an  * 	incoming CR_TPDU.  *  * FUNCTION and ARGUMENTS:  * 	Copy a whole net addr from a struct sockaddr (name).  * 	into an isopcb (isop).  * 	The argument (which) takes values TP_LOCAL or TP_FOREIGN  */
end_comment

begin_function
name|void
name|iso_putnetaddr
parameter_list|(
name|isop
parameter_list|,
name|name
parameter_list|,
name|which
parameter_list|)
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|name
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|TP_LOCAL
case|:
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|name
operator|->
name|siso_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"PUT TP_LOCAL addr\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|isop
operator|->
name|isop_laddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
break|break;
case|case
name|TP_FOREIGN
case|:
name|isop
operator|->
name|isop_faddr
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
if|if
condition|(
name|name
operator|!=
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|name
operator|->
name|siso_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|isop
operator|->
name|isop_faddr
operator|.
name|siso_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"PUT TP_FOREIGN addr\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  pr_usrreq() PRU_SOCKADDR, PRU_ACCEPT, PRU_PEERADDR  * FUNCTION and ARGUMENTS:  * 	Copy a whole net addr from an isopcb (isop) into  * 	a struct sockaddr (name).  * 	The argument (which) takes values TP_LOCAL or TP_FOREIGN.  */
end_comment

begin_function
name|void
name|iso_getnetaddr
parameter_list|(
name|isop
parameter_list|,
name|name
parameter_list|,
name|which
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|name
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|TP_LOCAL
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|name
operator|->
name|siso_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TP_FOREIGN
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|isop
operator|->
name|isop_faddr
operator|.
name|siso_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|name
operator|->
name|siso_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_input() on incoming CR, CC, and pr_usrreq() for PRU_CONNECT  * FUNCTION, ARGUMENTS, SIDE EFFECTS and RETURN VALUE:  * Determine the proper maximum transmission unit, i.e., MTU, to use, given  * a) the header size for the network protocol and the max transmission  *	  unit on the subnet interface, determined from the information in (isop),  * b) the max size negotiated so far (negot)  * c) the window size used by the tp connection (found in so),  *  * The result is put in the integer *size in its integer form and in  * *negot in its logarithmic form.    *   * The rules are:  * a) can only negotiate down from the value found in *negot.  * b) the MTU must be< the windowsize,  * c) If src and dest are on the same net,  * 	  we will negotiate the closest size larger than  MTU but really USE   *    the actual device mtu - ll hdr sizes.  *   otherwise we negotiate the closest size smaller than MTU - ll hdr sizes.  */
end_comment

begin_function
name|void
name|tpclnp_mtu
parameter_list|(
name|so
parameter_list|,
name|isop
parameter_list|,
name|size
parameter_list|,
name|negot
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|int
modifier|*
name|size
decl_stmt|;
name|u_char
modifier|*
name|negot
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|windowsize
init|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
decl_stmt|;
name|int
name|clnp_size
decl_stmt|;
name|int
name|sizeismtu
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|iso_routeifp
parameter_list|()
function_decl|;
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_mtu(0x%x,0x%x,0x%x,0x%x)\n"
argument_list|,
name|so
argument_list|,
name|isop
argument_list|,
name|size
argument_list|,
name|negot
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"ENTER GET MTU: size negot \n"
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|negot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
modifier|*
name|size
init|=
literal|1
operator|<<
operator|*
name|negot
decl_stmt|;
if|if
condition|(
operator|*
name|size
operator|>
name|windowsize
condition|)
block|{
operator|*
name|size
operator|=
name|windowsize
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|=
name|iso_routeifp
argument_list|(
operator|&
name|isop
operator|->
name|isop_faddr
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* TODO - make this indirect off the socket structure to the 	 * network layer to get headersize 	 */
name|clnp_size
operator|=
name|clnp_hdrsize
argument_list|(
name|isop
operator|->
name|isop_laddr
operator|.
name|siso_addr
operator|.
name|isoa_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|size
operator|>
name|ifp
operator|->
name|if_mtu
operator|-
name|clnp_size
condition|)
block|{
operator|*
name|size
operator|=
name|ifp
operator|->
name|if_mtu
operator|-
name|clnp_size
expr_stmt|;
name|sizeismtu
operator|=
literal|1
expr_stmt|;
block|}
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"GET MTU MID: tpcb size negot i \n"
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|negot
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
comment|/* have to transform size to the log2 of size */
for|for
control|(
name|i
operator|=
name|TP_MIN_TPDUSIZE
init|;
operator|(
name|i
operator|<
name|TP_MAX_TPDUSIZE
operator|&&
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|<=
operator|*
name|size
operator|)
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|i
operator|--
expr_stmt|;
comment|/* are we on the same LAN? if so, negotiate one tpdu size larger, 	 * and actually send the real mtu size 	 */
comment|/* PHASE2: replace with iso_on_localnet(&isop->isop_faddr); 	 * or something along those lines 	 */
if|if
condition|(
name|iso_netmatch
argument_list|(
operator|&
name|isop
operator|->
name|isop_laddr
argument_list|,
operator|&
name|isop
operator|->
name|isop_faddr
argument_list|)
operator|&&
name|sizeismtu
condition|)
block|{
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|size
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
operator|*
name|negot
operator|=
name|i
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"GET MTU RETURNS: ifp %s size 0x%x negot 0x%x\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|negot
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"EXIT GET MTU: tpcb size negot \n"
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|negot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_emit()  * FUNCTION and ARGUMENTS:  *  Take a packet(m0) from tp and package it so that clnp will accept it.  *  This means prepending space for the clnp header and filling in a few  *  of the fields.  *  inp is the isopcb structure; datalen is the length of the data in the  *  mbuf string m0.  * RETURN VALUE:  *  whatever (E*) is returned form the net layer output routine.  */
end_comment

begin_function
name|int
name|tpclnp_output
parameter_list|(
name|isop
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|,
name|nochksum
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|int
name|nochksum
decl_stmt|;
block|{
name|IncStat
argument_list|(
name|ts_tpdu_sent
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|struct
name|tpdu
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|tpdu
operator|*
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"abt to call clnp_output: datalen 0x%x, hdr.li 0x%x, hdr.dutype 0x%x nocsum x%x dst addr:\n"
argument_list|,
name|datalen
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_li
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_type
argument_list|,
name|nochksum
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nsrc addr:\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|isop
operator|->
name|isop_laddr
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|m0
argument_list|,
literal|"at tpclnp_output"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|clnp_output
argument_list|(
name|m0
argument_list|,
name|isop
argument_list|,
name|datalen
argument_list|,
name|nochksum
condition|?
name|CLNP_NO_CKSUM
else|:
literal|0
comment|/* flags */
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_error_emit()  * FUNCTION and ARGUMENTS:  *  This is a copy of tpclnp_output that takes the addresses  *  instead of a pcb.  It's used by the tp_error_emit, when we  *  don't have an iso_pcb with which to call the normal output rtn.  * RETURN VALUE:  *  ENOBUFS or  *  whatever (E*) is returned form the net layer output routine.  */
end_comment

begin_function
name|int
name|tpclnp_output_dg
parameter_list|(
name|laddr
parameter_list|,
name|faddr
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|,
name|ro
parameter_list|,
name|nochksum
parameter_list|)
name|struct
name|iso_addr
modifier|*
name|laddr
decl_stmt|,
decl|*
name|faddr
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nochksum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|isopcb
name|tmppcb
decl_stmt|;
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_output_dg  datalen 0x%x m0 0x%x\n"
argument_list|,
name|datalen
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	Fill in minimal portion of isopcb so that clnp can send the 	 *	packet. 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tmppcb
argument_list|,
sizeof|sizeof
argument_list|(
name|tmppcb
argument_list|)
argument_list|)
decl_stmt|;
name|isoa
operator|=
operator|&
operator|(
name|tmppcb
operator|.
name|isop_laddr
operator|.
name|siso_addr
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|laddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|isoa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|isoa
operator|=
operator|&
operator|(
name|tmppcb
operator|.
name|isop_faddr
operator|.
name|siso_addr
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|faddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|isoa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_output_dg  faddr: \n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|tmppcb
operator|.
name|isop_faddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ntpclnp_output_dg  laddr: \n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|tmppcb
operator|.
name|isop_laddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	Do not use packet cache since this is a one shot error packet 	 */
name|flags
init|=
operator|(
name|CLNP_NOCACHE
operator||
operator|(
name|nochksum
condition|?
name|CLNP_NO_CKSUM
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|IncStat
argument_list|(
name|ts_tpdu_sent
argument_list|)
expr_stmt|;
name|err
operator|=
name|clnp_output
argument_list|(
name|m0
argument_list|,
operator|&
name|tmppcb
argument_list|,
name|datalen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 *	Free route allocated by clnp (if the route was indeed allocated) 	 */
if|if
condition|(
name|tmppcb
operator|.
name|isop_route
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|tmppcb
operator|.
name|isop_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  * 	clnp's input routine, indirectly through the protosw.  * FUNCTION and ARGUMENTS:  * Take a packet (m) from clnp, strip off the clnp header and give it to tp  * No return value.    */
end_comment

begin_function
name|ProtoHook
name|tpclnp_input
parameter_list|(
name|m
parameter_list|,
name|faddr
parameter_list|,
name|laddr
parameter_list|,
name|clnp_len
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|iso_addr
modifier|*
name|faddr
decl_stmt|,
decl|*
name|laddr
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|clnp_len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sockaddr_iso
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|IncStat
argument_list|(
name|ts_pkt_rcvd
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_input: m 0x%x clnp_len 0x%x\n"
argument_list|,
name|m
argument_list|,
name|clnp_len
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|m
argument_list|,
literal|"at tpclnp_input"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 * CLNP gives us an mbuf chain WITH the clnp header pulled up, 	 * and the length of the clnp header. 	 * First, strip off the Clnp header. leave the mbuf there for the 	 * pullup that follows. 	 */
name|m
operator|->
name|m_len
operator|-=
name|clnp_len
expr_stmt|;
name|m
operator|->
name|m_off
operator|+=
name|clnp_len
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|tp_inputprep
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|dump_mbuf
argument_list|(
name|m
argument_list|,
literal|"after tpclnp_input both pullups"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|src
operator|.
name|siso_family
init|=
name|dst
operator|.
name|siso_family
operator|=
name|AF_ISO
decl_stmt|;
name|bcopy
argument_list|(
name|faddr
argument_list|,
operator|&
name|src
operator|.
name|siso_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|laddr
argument_list|,
operator|&
name|dst
operator|.
name|siso_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"calling tp_input:&src 0x%x&dst 0x%x, src addr:\n"
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dst addr:\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|src
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|dst
argument_list|)
expr_stmt|;
name|ENDDEBUG
argument_list|(
argument|void
argument_list|)
name|tp_input
argument_list|(
name|m
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|dst
argument_list|,
literal|0
argument_list|,
name|tpclnp_output_dg
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_QUENCH
argument_list|)
block|{
if|if
condition|(
name|time
operator|.
name|tv_usec
operator|&
literal|0x4
operator|&&
name|time
operator|.
name|tv_usec
operator|&
literal|0x40
condition|)
block|{
name|printf
argument_list|(
literal|"tpclnp_input: FAKING %s\n"
argument_list|,
name|tp_stat
operator|.
name|ts_pkt_rcvd
operator|&
literal|0x1
condition|?
literal|"QUENCH"
else|:
literal|"QUENCH2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp_stat
operator|.
name|ts_pkt_rcvd
operator|&
literal|0x1
condition|)
block|{
name|tpclnp_ctlinput
argument_list|(
name|PRC_QUENCH
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tpclnp_ctlinput
argument_list|(
name|PRC_QUENCH2
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ENDDEBUG
name|splx
parameter_list|(
name|s
parameter_list|)
function_decl|;
return|return
literal|0
return|;
name|discard
label|:
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_input DISCARD\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_TPINPUT
parameter_list|)
function_decl|tptrace
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"tpclnp_input DISCARD m"
operator|,
function_decl|m
operator|,
function_decl|0
operator|,
function_decl|0
operator|,
function_decl|0
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
name|ENDTRACE
name|m_freem
parameter_list|(
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|IncStat
argument_list|(
name|ts_recv_drop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_macro
unit|}  ProtoHook
name|iso_rtchange
argument_list|()
end_macro

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  tpclnp_ctlinput()  * FUNCTION and ARGUMENTS:  *  find the tpcb pointer and pass it to tp_quench  */
end_comment

begin_function
name|void
name|tpiso_decbit
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|tp_quench
argument_list|(
name|isop
operator|->
name|isop_socket
operator|->
name|so_tpcb
argument_list|,
name|PRC_QUENCH2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tpclnp_ctlinput()  * FUNCTION and ARGUMENTS:  *  find the tpcb pointer and pass it to tp_quench  */
end_comment

begin_function
name|void
name|tpiso_quench
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|tp_quench
argument_list|(
name|isop
operator|->
name|isop_socket
operator|->
name|so_tpcb
argument_list|,
name|PRC_QUENCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  The network layer through the protosw table.  * FUNCTION and ARGUMENTS:  *	When clnp an ICMP-like msg this gets called.  *	It either returns an error status to the user or  *	it causes all connections on this address to be aborted  *	by calling the appropriate xx_notify() routine.  *	(cmd) is the type of ICMP error.     * 	(siso) is the address of the guy who sent the ER CLNPDU  */
end_comment

begin_function
name|ProtoHook
name|tpclnp_ctlinput
parameter_list|(
name|cmd
parameter_list|,
name|siso
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
block|{
specifier|extern
name|u_char
name|inetctlerrmap
index|[]
decl_stmt|;
specifier|extern
name|ProtoHook
name|tpiso_abort
parameter_list|()
function_decl|;
specifier|extern
name|ProtoHook
name|iso_rtchange
parameter_list|()
function_decl|;
specifier|extern
name|ProtoHook
name|tpiso_reset
parameter_list|()
function_decl|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_ctlinput: cmd 0x%x addr: "
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|siso
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|<
literal|0
operator|||
name|cmd
operator|>
name|PRC_NCMDS
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_QUENCH2
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
literal|0
argument_list|,
name|tpiso_decbit
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_QUENCH
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
literal|0
argument_list|,
name|tpiso_quench
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_TIMXCEED_REASS
case|:
case|case
name|PRC_ROUTEDEAD
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
literal|0
argument_list|,
name|tpiso_reset
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_HOSTUNREACH
case|:
case|case
name|PRC_UNREACH_NET
case|:
case|case
name|PRC_IFDOWN
case|:
case|case
name|PRC_HOSTDEAD
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
operator|(
name|int
operator|)
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|iso_rtchange
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		case	PRC_MSGSIZE: 		case	PRC_UNREACH_HOST: 		case	PRC_UNREACH_PROTOCOL: 		case	PRC_UNREACH_PORT: 		case	PRC_UNREACH_NEEDFRAG: 		case	PRC_UNREACH_SRCFAIL: 		case	PRC_REDIRECT_NET: 		case	PRC_REDIRECT_HOST: 		case	PRC_REDIRECT_TOSNET: 		case	PRC_REDIRECT_TOSHOST: 		case	PRC_TIMXCEED_INTRANS: 		case	PRC_PARAMPROB: 		*/
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
operator|(
name|int
operator|)
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|tpiso_abort
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * These next 2 routines are  * CALLED FROM:  *	xxx_notify() from tp_ctlinput() when  *  net level gets some ICMP-equiv. type event.  * FUNCTION and ARGUMENTS:  *  Cause the connection to be aborted with some sort of error  *  reason indicating that the network layer caused the abort.  *  Fakes an ER TPDU so we can go through the driver.  *  abort always aborts the TP connection.  *  reset may or may not, depending on the TP class that's in use.  */
end_comment

begin_function
name|ProtoHook
name|tpiso_abort
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|struct
name|tp_event
name|e
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tpiso_abort 0x%x\n"
argument_list|,
name|isop
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|e
operator|.
name|ev_number
init|=
name|ER_TPDU
decl_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|ER_TPDU
argument_list|)
operator|.
name|e_reason
operator|=
name|ECONNABORTED
expr_stmt|;
return|return
name|tp_driver
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_tpcb
argument_list|,
operator|&
name|e
argument_list|)
return|;
block|}
end_function

begin_function
name|ProtoHook
name|tpiso_reset
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|struct
name|tp_event
name|e
decl_stmt|;
name|e
operator|.
name|ev_number
operator|=
name|T_NETRESET
expr_stmt|;
return|return
name|tp_driver
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_tpcb
argument_list|,
operator|&
name|e
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

end_unit

