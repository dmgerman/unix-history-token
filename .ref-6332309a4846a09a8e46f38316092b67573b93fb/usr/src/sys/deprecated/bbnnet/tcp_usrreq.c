begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsident
index|[]
init|=
literal|"$Header: tcp_usrreq.c,v 1.30 85/07/31 09:43:43 walsh Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mbuf.h"
end_include

begin_include
include|#
directive|include
file|"../h/socket.h"
end_include

begin_include
include|#
directive|include
file|"../h/socketvar.h"
end_include

begin_include
include|#
directive|include
file|"../h/protosw.h"
end_include

begin_include
include|#
directive|include
file|"../h/errno.h"
end_include

begin_include
include|#
directive|include
file|"../h/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"../h/time.h"
end_include

begin_include
include|#
directive|include
file|"../h/kernel.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/in_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/net.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/fsm.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/tcp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/ip.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/icmp.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/macros.h"
end_include

begin_include
include|#
directive|include
file|"../bbnnet/sws.h"
end_include

begin_comment
comment|/*  * TCP protocol interface to socket abstraction.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GPROF
end_ifdef

begin_decl_stmt
name|int
name|tcp_acounts
index|[
name|TCP_NSTATES
index|]
index|[
name|PRU_NREQ
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_extern
extern|extern tcp_pcbdisconnect(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern tcp_binding_used(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|inpcb
name|tcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tcp_stat
name|tcpstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sequence
name|tcp_iss
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tcp initial send seq # */
end_comment

begin_decl_stmt
name|struct
name|dfilter
name|tcp_dfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pr_advice
name|tcp_advice
init|=
block|{
name|TCP_RESERVED
block|,
comment|/* application reserved */
name|TCP_USERRESERVED
block|,
comment|/* user reserved */
name|TCP_MAXPORT
block|,
comment|/* max port */
name|TCP_USERRESERVED
operator|+
literal|1
block|,
comment|/* random last used */
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
block|,
comment|/* port size */
name|tcp_binding_used
block|,
comment|/* confirmation routine */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|dowedebug
argument_list|(
name|inp
argument_list|,
name|so
argument_list|,
name|filter
argument_list|)
specifier|register
expr|struct
name|inpcb
operator|*
name|inp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|dfilter
modifier|*
name|filter
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|==
name|filter
operator|->
name|foreign_host
operator|.
name|s_addr
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_fport
operator|==
name|filter
operator|->
name|foreign_port
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|filter
operator|->
name|local_host
operator|.
name|s_addr
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_lport
operator|==
name|filter
operator|->
name|local_port
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|filter
operator|->
name|matches
condition|)
name|so
operator|->
name|so_options
operator||=
name|SO_DEBUG
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|tcp_noact
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* patchable */
end_comment

begin_comment
comment|/*  * Allocate and initialize a new TCB  * tcp_usrreq calls tcp_attach calls us.  tcp_usrreq splnet()'s  */
end_comment

begin_function
name|struct
name|tcpcb
modifier|*
name|tcp_newtcpcb
parameter_list|(
name|inp
parameter_list|)
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_getclr
argument_list|(
name|M_WAIT
argument_list|,
name|MT_PCB
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|tp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tcpcb
operator|*
argument_list|)
expr_stmt|;
comment|/* initialize non-zero tcb fields */
name|tp
operator|->
name|t_rcv_next
operator|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|tp
expr_stmt|;
name|tp
operator|->
name|t_rcv_prev
operator|=
operator|(
expr|struct
name|th
operator|*
operator|)
name|tp
expr_stmt|;
comment|/*      * Don't start off assuming minimum srtt/rxmitime.  If we do, and      * TCP_tvRXMIN is small and we decide to communicate over a      * reliable, but slow, network then we may not find true values for      * these.  We may assume an ACK was for a retransmission that      * we're measuring the srtt of, not the original packet.      *      * Instead, start high and approach from above in a deterministic      * fashion.  We should get close to the right values fairly rapidly.      *      * 7/85: start from above by special casing first round trip time      * measurement.  If srtt == 0, do not reset rtt, and do not use      * weighted averaging.  srtt starts as time to ack(xmit [+ rxmit...])      * and then gets smoothed with new round trip times.  This compromise      * for getting to long-term srtt more quickly on LANs should work      * on the Internet as well.  It will only hurt Internet connections      * if packet loss is high, and even then would only slow getting      * to long term srtt.      * This method can be turned off by initializing srtt with a non-zero      * value.      */
comment|/* tp->t_srtt   = TCP_tvMAXSRTT; */
name|tp
operator|->
name|t_rxmitime
operator|=
name|TCP_tvMAXSRTT
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|t_rttltimeo
operator|=
name|TCP_tvRTTL
expr_stmt|;
name|tp
operator|->
name|t_xmt_val
operator|=
name|tp
operator|->
name|snd_end
operator|=
name|tp
operator|->
name|seq_fin
operator|=
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_hi
operator|=
name|tp
operator|->
name|snd_una
operator|=
name|tp
operator|->
name|iss
operator|=
name|tcp_iss
expr_stmt|;
name|tcp_iss
operator|+=
name|ISSINCR
expr_stmt|;
comment|/*      * Imitate Berkeley code by setting push as a default.  This should      * increase compatibility at the user code level.      */
name|tp
operator|->
name|t_push
operator|=
name|TRUE
expr_stmt|;
comment|/*      * Berkeley 4.2 code sends a data byte beyond the window's edge to see      * if the other end is up.  If other end does not respond, connection      * times out and aborts.  This is dangerous since the byte may make its      * way into the input stream if the recipient is coded keeping in mind      * how expensive packets are.      *      * We'll provide for an optional method to send a well formed ack that      * will catch remote failure and generate a tcp reset.  Note that we      * don't care if the other end ignores the ack; we only hope for a well      * coded tcp to respond with a reset in the right circumstances.  This      * sort of handshaking/probing should really be done at the application      * level, but not all specs (eg., SMTP) provide for such a noop.      *      * Optional, since some networks charge for packets and since some might      * see this as unecessary traffic.      *      * also see tcp_ioctl()      */
if|if
condition|(
name|tp
operator|->
name|t_noact
operator|=
name|tcp_noact
condition|)
name|tp
operator|->
name|t_noactprobe
operator|=
name|TRUE
expr_stmt|;
comment|/* attach the tcpcb to the in_pcb */
name|inp
operator|->
name|inp_ppcb
operator|=
operator|(
name|caddr_t
operator|)
name|tp
expr_stmt|;
name|tp
operator|->
name|t_in_pcb
operator|=
name|inp
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is a tcp port/address pair already in use by some socket on this machine?  * Passed to in_pcbbind() to help it find a port/address binding  * that is unique for tcp.  */
end_comment

begin_function
name|int
name|tcp_binding_used
parameter_list|(
name|inp
parameter_list|,
name|lport
parameter_list|,
name|lsaddr
parameter_list|,
name|reuselocal
parameter_list|)
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|u_short
name|lport
decl_stmt|;
name|u_long
name|lsaddr
decl_stmt|;
block|{
specifier|register
name|struct
name|inpcb
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tcp
operator|.
name|inp_next
init|;
name|i
operator|!=
operator|&
name|tcp
condition|;
name|i
operator|=
name|i
operator|->
name|inp_next
control|)
block|{
comment|/* 	 * Since our inpcb is in this linked list, don't want to know 	 * if we, ourselves, are already using this binding. 	 */
if|if
condition|(
name|i
operator|!=
name|inp
condition|)
if|if
condition|(
name|i
operator|->
name|inp_lport
operator|==
name|lport
condition|)
comment|/* 		 * Our/His address is unbound (INADDR_ANY) iff 		 * not yet connected to foreign host. 		 */
if|if
condition|(
operator|(
name|i
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|lsaddr
operator|)
operator|||
operator|(
name|i
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
operator|||
operator|(
name|lsaddr
operator|==
name|INADDR_ANY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|reuselocal
condition|)
break|break;
if|if
condition|(
name|i
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
comment|/* 			 * We're both waiting for foreign 			 * connection.  Could only re-use if 			 * he was already connected. 			 */
break|break;
block|}
block|}
return|return
operator|(
name|i
operator|!=
operator|&
name|tcp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns a (struct tcpcb *) cast to a (char *).  This is  * so in_pcbconnect() can correctly handle return value. All  * other uses promptly cast back.  */
end_comment

begin_function
name|char
modifier|*
name|tcp_conn_used
parameter_list|(
name|inp
parameter_list|,
name|lport
parameter_list|,
name|lsaddr
parameter_list|,
name|fport
parameter_list|,
name|fsaddr
parameter_list|)
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|u_short
name|lport
decl_stmt|;
name|u_long
name|lsaddr
decl_stmt|;
name|u_short
name|fport
decl_stmt|;
name|u_long
name|fsaddr
decl_stmt|;
block|{
specifier|register
name|struct
name|inpcb
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tcp
operator|.
name|inp_next
init|;
name|i
operator|!=
operator|&
name|tcp
condition|;
name|i
operator|=
name|i
operator|->
name|inp_next
control|)
block|{
comment|/* 	 * Since our inpcb is in this linked list, don't want to know 	 * if we, ourselves, are already using this connetion. 	 */
if|if
condition|(
name|i
operator|!=
name|inp
condition|)
if|if
condition|(
operator|(
name|i
operator|->
name|inp_lport
operator|==
name|lport
operator|)
operator|&&
operator|(
name|i
operator|->
name|inp_fport
operator|==
name|fport
operator|)
operator|&&
operator|(
name|i
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|lsaddr
operator|)
operator|&&
operator|(
name|i
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|==
name|fsaddr
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|i
operator|->
name|inp_ppcb
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|tcp_ioctl
argument_list|(
argument|tp
argument_list|,
argument|command
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|command
condition|)
block|{
comment|/* push */
case|case
name|SIOCSPUSH
case|:
name|tp
operator|->
name|t_push
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|SIOCCPUSH
case|:
name|tp
operator|->
name|t_push
operator|=
name|FALSE
expr_stmt|;
break|break;
comment|/* no activity timer */
case|case
name|SIOCSNOACT
case|:
block|{
name|u_long
name|value
decl_stmt|;
name|value
operator|=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
name|data
operator|)
expr_stmt|;
comment|/* 	 * A shutdown socket should still be able to request some sort of 	 * check on the status of the remote end.  Also see tcp_newtcpcb(). 	 */
name|tp
operator|->
name|t_noactprobe
operator|=
operator|(
name|value
operator|&
name|TCP_NOACTPROBE
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|tp
operator|->
name|t_noactsig
operator|=
operator|(
name|value
operator|&
name|TCP_NOACTSIG
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|<=
name|ESTAB
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|==
name|CLOSE_WAIT
operator|)
condition|)
block|{
comment|/* don't interfere with system use of timer */
name|value
operator|&=
operator|~
operator|(
name|TCP_NOACTPROBE
operator||
name|TCP_NOACTSIG
operator|)
expr_stmt|;
name|tp
operator|->
name|t_noact
operator|=
name|MIN
argument_list|(
name|MAX_TCPTIMERVAL
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_timers
index|[
name|TNOACT
index|]
operator|=
name|tp
operator|->
name|t_noact
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SIOCGNOACT
case|:
block|{
name|u_long
name|value
decl_stmt|;
name|value
operator|=
name|tp
operator|->
name|t_noact
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_noactprobe
condition|)
name|value
operator||=
name|TCP_NOACTPROBE
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_noactsig
condition|)
name|value
operator||=
name|TCP_NOACTSIG
expr_stmt|;
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
name|data
operator|)
operator|=
name|value
expr_stmt|;
block|}
break|break;
comment|/* init timer */
case|case
name|SIOCSINIT
case|:
name|tp
operator|->
name|t_itimeo
operator|=
name|MIN
argument_list|(
name|MAX_TCPTIMERVAL
argument_list|,
operator|*
operator|(
operator|(
name|unsigned
operator|*
operator|)
name|data
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGINIT
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
name|tp
operator|->
name|t_itimeo
expr_stmt|;
break|break;
comment|/* retransmit took too long timer */
case|case
name|SIOCSRTTL
case|:
name|tp
operator|->
name|t_rttltimeo
operator|=
name|MIN
argument_list|(
name|MAX_TCPTIMERVAL
argument_list|,
operator|*
operator|(
operator|(
name|unsigned
operator|*
operator|)
name|data
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGRTTL
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
name|tp
operator|->
name|t_rttltimeo
expr_stmt|;
break|break;
case|case
name|SIOCABORT
case|:
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
comment|/* there really should be a generic way for 	     * a user to get to soabort() 	     */
name|tp
operator|->
name|usr_abort
operator|=
name|TRUE
expr_stmt|;
comment|/* 	     * Just in case asked to abort a LISTENing socket, 	     * Don't leave unattached, unaccepted connections. 	     */
name|so
operator|=
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_socket
expr_stmt|;
while|while
condition|(
name|so
operator|->
name|so_q0
operator|&&
operator|(
name|so
operator|->
name|so_q0
operator|!=
name|so
operator|)
condition|)
operator|(
name|void
operator|)
name|soabort
argument_list|(
name|so
operator|->
name|so_q0
argument_list|)
expr_stmt|;
while|while
condition|(
name|so
operator|->
name|so_q
operator|&&
operator|(
name|so
operator|->
name|so_q
operator|!=
name|so
operator|)
condition|)
operator|(
name|void
operator|)
name|soabort
argument_list|(
name|so
operator|->
name|so_q
argument_list|)
expr_stmt|;
name|w_alloc
argument_list|(
name|IUABORT
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|tp
operator|->
name|t_in_pcb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* not our ioctl, let lower level try ioctl */
return|return
name|ip_ioctl
argument_list|(
name|tp
operator|->
name|t_in_pcb
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process a TCP user request for TCP tb.  If this is a send request  * then m is the mbuf chain of send data.  If this is a timer expiration  * (called from the software clock routine), then timertype tells which timer.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|tcp_usrreq
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|rights
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam
decl_stmt|,
modifier|*
name|rights
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|int
name|act
decl_stmt|,
name|newstate
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* keep in mind call from ifioctl() */
if|if
condition|(
name|rights
operator|&&
name|req
operator|!=
name|PRU_CONTROL
condition|)
block|{
if|if
condition|(
name|rights
operator|->
name|m_len
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/*      * When a TCP is attached to a socket, then there will be      * a (struct inpcb) pointed at by the socket, and this      * structure will point at a subsidary (struct tcpcb).      */
if|if
condition|(
name|inp
operator|==
name|NULL
operator|&&
name|req
operator|!=
name|PRU_ATTACH
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX */
block|}
if|if
condition|(
name|inp
condition|)
block|{
name|tp
operator|=
name|inptotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* WHAT IF TP IS 0? */
ifdef|#
directive|ifdef
name|GPROF
name|tcp_acounts
index|[
name|tp
operator|->
name|t_state
index|]
index|[
name|req
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*      * This switch becomes a 'caseb', so put common ones at top.      */
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRU_RCVD
case|:
comment|/* 	 * After a receive, possibly send window update to peer. 	 */
name|W_ALLOC
argument_list|(
name|IURECV
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
name|so
argument_list|,
name|act
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SEND
case|:
comment|/* 	 * Do a send by initiating the proper entry to the FSM. 	 * Don't let urgent continue. 	 */
name|tp
operator|->
name|t_urg
operator|=
name|FALSE
expr_stmt|;
name|W_ALLOC
argument_list|(
name|IUSEND
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|m
argument_list|,
name|so
argument_list|,
name|act
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * TCP attaches to socket via PRU_ATTACH, reserving space, 	 * and an internet control block. 	 */
case|case
name|PRU_ATTACH
case|:
if|if
condition|(
name|inp
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|tcp_attach
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
operator|)
operator|&&
name|so
operator|->
name|so_linger
operator|==
literal|0
condition|)
name|so
operator|->
name|so_linger
operator|=
name|T_LINGERTIME
expr_stmt|;
name|tp
operator|=
name|sototcpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * PRU_DETACH detaches the TCP protocol from the socket. 	 * This is only done after SO_ISCONNECTED has been cleared. 	 */
case|case
name|PRU_DETACH
case|:
name|tcp_disconnect
argument_list|(
name|tp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Give the socket an address. 	 */
case|case
name|PRU_BIND
case|:
name|error
operator|=
name|in_pcbbind
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|,
operator|&
name|tcp_advice
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Prepare to accept connections. 	 */
case|case
name|PRU_LISTEN
case|:
if|if
condition|(
name|inp
operator|->
name|inp_lport
operator|==
literal|0
condition|)
name|error
operator|=
name|in_pcbbind
argument_list|(
name|inp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tcp_advice
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|w_alloc
argument_list|(
name|IUOPENA
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Initiate connection to peer. 	 * Bind the local end if not already. 	 * Set the routing. 	 * Crank up the TCP state machine. 	 */
case|case
name|PRU_CONNECT
case|:
block|{
name|struct
name|in_addr
name|laddr
decl_stmt|;
name|laddr
operator|=
name|inp
operator|->
name|inp_laddr
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_lport
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|in_pcbbind
argument_list|(
name|inp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tcp_advice
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|error
operator|=
name|in_pcbconnect
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|,
name|tcp_conn_used
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|in_broadcast
argument_list|(
name|inp
operator|->
name|inp_faddr
argument_list|)
condition|)
block|{
name|in_pcbdisconnect
argument_list|(
name|inp
argument_list|,
name|tcp_pcbdisconnect
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_laddr
operator|=
name|laddr
expr_stmt|;
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_template
operator|=
name|tcp_template
argument_list|(
name|tp
argument_list|)
operator|)
condition|)
block|{
name|in_pcbdisconnect
argument_list|(
name|inp
argument_list|,
name|tcp_pcbdisconnect
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_laddr
operator|=
name|laddr
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|tp
operator|->
name|sws_qff
operator|=
name|SWS_QFF_DEF
expr_stmt|;
comment|/* 	     * So can debug connection problems without having to change 	     * every program or apply debugging flag to each program every 	     * time run it. 	     */
name|dowedebug
argument_list|(
name|inp
argument_list|,
name|so
argument_list|,
operator|&
name|tcp_dfilter
argument_list|)
expr_stmt|;
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|w_alloc
argument_list|(
name|IUOPENR
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Create a TCP connection between two sockets. 	 */
case|case
name|PRU_CONNECT2
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
comment|/* 	 * Initiate disconnect from peer. 	 * If connection never passed embryonic stage, just drop; 	 * else if don't need to let data drain, then can just drop anyways, 	 * else have to begin TCP shutdown process: mark socket disconnecting, 	 * drain unread data, state switch to reflect user close, and 	 * send segment (e.g. FIN) to peer.  Socket will be really disconnected 	 * when peer sends FIN and acks ours. 	 */
case|case
name|PRU_DISCONNECT
case|:
name|tcp_disconnect
argument_list|(
name|tp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Accept a connection.  Essentially all the work is 	 * done at higher levels; just return the address 	 * of the peer, storing through addr. 	 * 	 * BBN-NOTE: upper levels do all the waiting;  this stays the same. 	 */
case|case
name|PRU_ACCEPT
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
decl_stmt|;
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|inp
operator|->
name|inp_fport
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|inp
operator|->
name|inp_faddr
expr_stmt|;
break|break;
block|}
comment|/* 	 * Mark the connection as being incapable of further output. 	 */
case|case
name|PRU_SHUTDOWN
case|:
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|usr_closed
condition|)
name|w_alloc
argument_list|(
name|IUCLOSE
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|inp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Abort the TCP. 	 */
case|case
name|PRU_ABORT
case|:
name|w_alloc
argument_list|(
name|IUABORT
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|inp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_CONTROL
case|:
name|error
operator|=
name|tcp_ioctl
argument_list|(
name|tp
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
name|nam
argument_list|)
expr_stmt|;
break|break;
comment|/* SOME AS YET UNIMPLEMENTED HOOKS */
case|case
name|PRU_SENSE
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
comment|/* END UNIMPLEMENTED HOOKS */
case|case
name|PRU_RCVOOB
case|:
block|{
name|int
name|desired
decl_stmt|;
if|if
condition|(
name|so
operator|->
name|so_oobmark
operator|==
literal|0
operator|&&
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_RCVATMARK
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tp
operator|->
name|oob_data
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
name|desired
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|int
operator|*
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|desired
operator|>
literal|0
operator|)
operator|&&
operator|(
name|tp
operator|->
name|oob_data
operator|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|desired
argument_list|,
name|tp
operator|->
name|oob_data
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|count
argument_list|,
name|MLEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|tp
operator|->
name|oob_data
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|p
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|count
expr_stmt|;
name|desired
operator|-=
name|count
expr_stmt|;
name|tp
operator|->
name|oob_data
operator|->
name|m_len
operator|-=
name|count
expr_stmt|;
name|tp
operator|->
name|oob_data
operator|->
name|m_off
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|oob_data
operator|->
name|m_len
operator|<=
literal|0
condition|)
name|tp
operator|->
name|oob_data
operator|=
name|m_free
argument_list|(
name|tp
operator|->
name|oob_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desired
operator|>
literal|0
operator|)
operator|&&
operator|(
name|tp
operator|->
name|oob_data
operator|)
condition|)
block|{
name|m
operator|->
name|m_next
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|PRU_SENDOOB
case|:
comment|/* 	 * allows up to MAX_TCPOOB bytes of out of band data 	 * even if user has used up all his allocated space. 	 */
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|<
operator|(
operator|-
name|MAX_TCPOOB
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|tp
operator|->
name|t_urg
operator|=
name|TRUE
expr_stmt|;
name|w_alloc
argument_list|(
name|IUSEND
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Return the address of this socket (local-side binding) 	 */
case|case
name|PRU_SOCKADDR
case|:
name|in_setsockaddr
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_PEERADDR
case|:
name|in_setpeeraddr
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * TCP slow timer went off; run down all those timers. 	 */
case|case
name|PRU_SLOWTIMO
case|:
name|tcp_timeo
argument_list|()
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"tcp_usrreq"
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * getsockopt() / setsockopt()  */
end_comment

begin_macro
name|tcp_ctloutput
argument_list|(
argument|req
argument_list|,
argument|so
argument_list|,
argument|level
argument_list|,
argument|optname
argument_list|,
argument|optval
argument_list|)
end_macro

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|,
name|optname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|optval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* like PRU/packet/timer entry into net code */
name|int
name|error
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
comment|/*      * possibly for us?      * Follow Berkeley methods: level is protocol number if meant for the      * protocol layer.  (Why not say if=0, arp=1, ip=2, udp/tcp/rdp=3....?)      *      * Problem: tcp needs to know about IP options in order to use right      * maxseg.  This doesn't quite work with the layering.      *      * Why not combine ioctl/setsockopt/getsockopt paths, since ioctl can be      * seen as fixed size sockopt- tried at BBN; removed for 4.3      */
comment|/* should be "mature" socket so pointers all valid... */
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRCO_GETOPT
case|:
name|error
operator|=
name|tcp_getopt
argument_list|(
name|inp
argument_list|,
name|optname
argument_list|,
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRCO_SETOPT
case|:
name|error
operator|=
name|tcp_setopt
argument_list|(
name|inp
argument_list|,
name|optname
argument_list|,
name|optval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"tcp_ctloutput"
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|tcp_getopt
argument_list|(
argument|inp
argument_list|,
argument|command
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*      * no TCP specific options accessed by getsockopt() as yet.      * let lower level at cmd      */
return|return
name|ip_getopt
argument_list|(
name|inp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
return|;
block|}
end_block

begin_macro
name|tcp_setopt
argument_list|(
argument|inp
argument_list|,
argument|command
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
comment|/* no TCP specific options accessed by setsockopt() as yet */
name|tp
operator|=
name|inptotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|SO_IPROUTE
condition|)
name|tp
operator|->
name|t_maxseg
operator|+=
name|inp
operator|->
name|inp_optlen
expr_stmt|;
name|error
operator|=
name|ip_setopt
argument_list|(
name|inp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|SO_IPROUTE
condition|)
name|tp
operator|->
name|t_maxseg
operator|-=
name|inp
operator|->
name|inp_optlen
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * These numbers come from measurements described in the paper  *	"Converting the BBN TCP/IP to 4.2BSD"  (S.L.C. USENIX)  * If your network handles packets larger than an ethernet frame, you  * could change tcp_init back to determine the largest net's packet size,  * multiply that by some number, and round up to a multiple of a CLSIZE.  */
end_comment

begin_decl_stmt
name|int
name|tcp_recvspace
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tcp_sendspace
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Attach TCP protocol to socket, allocating  * internet protocol control block, tcp control block, buffer space.  */
end_comment

begin_macro
name|tcp_attach
argument_list|(
argument|so
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|tcp_sendspace
argument_list|,
name|tcp_recvspace
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|in_pcballoc
argument_list|(
name|so
argument_list|,
operator|&
name|tcp
argument_list|)
operator|)
condition|)
block|{
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|=
name|tcp_newtcpcb
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* 		 * Should change state tables to have an UNOPENED state like 		 * the butterfly's which is different from SAME. 		 */
name|tp
operator|->
name|t_state
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|ENOBUFS
expr_stmt|;
name|in_pcbdetach
argument_list|(
name|inp
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Initiate (or continue) disconnect.  * If embryonic state, just send reset (once).  * If not in ``let data drain'' option, just drop.  * Otherwise (hard), mark socket disconnecting and drop  * current input data; switch states based on user close, and  * send segment to peer (with FIN).  */
end_comment

begin_expr_stmt
name|tcp_disconnect
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tcpcb
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|tp
operator|->
name|t_in_pcb
operator|->
name|inp_socket
decl_stmt|;
name|soisdisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sbflush
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|tp
operator|->
name|usr_abort
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|usr_closed
condition|)
name|w_alloc
argument_list|(
name|IUCLOSE
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|tp
operator|->
name|t_in_pcb
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|tcp_init
argument_list|()
end_macro

begin_block
block|{
comment|/*      * Leave these checks in!  It's a pain in the ass to find out      * problems caused by too small mbufs if someone changes the      * size of an mbuf.      */
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|inpcb
argument_list|)
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"inpcb too big"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|socket
argument_list|)
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"socket too big"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"th too big"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|tcpcb
argument_list|)
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"tcpcb too big"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|t_debug
argument_list|)
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"t_debug too big"
argument_list|)
expr_stmt|;
comment|/* init queue */
name|tcp
operator|.
name|inp_next
operator|=
name|tcp
operator|.
name|inp_prev
operator|=
operator|&
name|tcp
expr_stmt|;
comment|/* are only 4 things to match. turn off for now */
name|tcp_dfilter
operator|.
name|matches
operator|=
literal|5
expr_stmt|;
name|tcp_iss
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|ipsw
index|[
name|IPPROTO_TCP
index|]
operator|.
name|ipsw_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|th
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|tcp_ctlinput
argument_list|(
argument|prc_code
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|inetctlerrmap
index|[
name|prc_code
index|]
expr_stmt|;
switch|switch
condition|(
name|prc_code
condition|)
block|{
case|case
name|PRC_UNREACH_PROTOCOL
case|:
comment|/* icmp message */
case|case
name|PRC_UNREACH_PORT
case|:
case|case
name|PRC_MSGSIZE
case|:
block|{
specifier|register
name|struct
name|th
modifier|*
name|tp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|t
decl_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|th
operator|*
operator|)
operator|(
operator|&
operator|(
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|arg
operator|)
operator|->
name|ic_iphdr
operator|)
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|tcpcb
operator|*
operator|)
name|tcp_conn_used
argument_list|(
operator|(
expr|struct
name|inpcb
operator|*
operator|)
literal|0
argument_list|,
name|tp
operator|->
name|t_src
argument_list|,
name|tp
operator|->
name|t_s
operator|.
name|s_addr
argument_list|,
name|tp
operator|->
name|t_dst
argument_list|,
name|tp
operator|->
name|t_d
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|t_close
argument_list|(
name|t
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PRC_UNREACH_NET
case|:
case|case
name|PRC_UNREACH_HOST
case|:
block|{
specifier|register
name|struct
name|th
modifier|*
name|tp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|t
decl_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|th
operator|*
operator|)
operator|(
operator|&
operator|(
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|arg
operator|)
operator|->
name|ic_iphdr
operator|)
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|tcpcb
operator|*
operator|)
name|tcp_conn_used
argument_list|(
operator|(
expr|struct
name|inpcb
operator|*
operator|)
literal|0
argument_list|,
name|tp
operator|->
name|t_src
argument_list|,
name|tp
operator|->
name|t_s
operator|.
name|s_addr
argument_list|,
name|tp
operator|->
name|t_dst
argument_list|,
name|tp
operator|->
name|t_d
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|t
operator|->
name|t_in_pcb
operator|->
name|inp_socket
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
condition|)
name|advise_user
argument_list|(
name|so
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|t_close
argument_list|(
name|t
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PRC_GWDOWN
case|:
name|in_gdown
argument_list|(
operator|&
name|tcp
argument_list|,
operator|(
name|u_long
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_REDIRECT_NET
case|:
comment|/* icmp message */
case|case
name|PRC_REDIRECT_HOST
case|:
block|{
name|struct
name|tcpcb
modifier|*
name|t
decl_stmt|;
specifier|register
name|struct
name|th
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|th
operator|*
operator|)
operator|(
operator|&
operator|(
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|arg
operator|)
operator|->
name|ic_iphdr
operator|)
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|tcpcb
operator|*
operator|)
name|tcp_conn_used
argument_list|(
operator|(
expr|struct
name|inpcb
operator|*
operator|)
literal|0
argument_list|,
name|tp
operator|->
name|t_src
argument_list|,
name|tp
operator|->
name|t_s
operator|.
name|s_addr
argument_list|,
name|tp
operator|->
name|t_dst
argument_list|,
name|tp
operator|->
name|t_d
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|icmp_redirect_inp
argument_list|(
name|t
operator|->
name|t_in_pcb
argument_list|,
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|arg
argument_list|,
name|prc_code
operator|==
name|PRC_REDIRECT_NET
condition|?
name|rtnet
else|:
name|rthost
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PRC_TIMXCEED_INTRANS
case|:
comment|/* icmp message */
case|case
name|PRC_TIMXCEED_REASS
case|:
case|case
name|PRC_PARAMPROB
case|:
break|break;
case|case
name|PRC_QUENCH
case|:
comment|/* icmp message */
comment|/* 	     * See RFC 896.  The idea is, when we get a source quench message on 	     * a connection we should send fewer packets.  This ties in with the 	     * silly window syndrome whose solution is to send fewer, larger packets. 	     * Deal with quenches by altering threshold used by silly window 	     * syndrome.  This is similar to acting as if the window is smaller 	     * than it actually is for deciding when to send, except that when we 	     * do, we use as much as there really is. 	     */
block|{
specifier|register
name|struct
name|th
modifier|*
name|tp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|t
decl_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|th
operator|*
operator|)
operator|(
operator|&
operator|(
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|arg
operator|)
operator|->
name|ic_iphdr
operator|)
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|tcpcb
operator|*
operator|)
name|tcp_conn_used
argument_list|(
operator|(
expr|struct
name|inpcb
operator|*
operator|)
literal|0
argument_list|,
name|tp
operator|->
name|t_src
argument_list|,
name|tp
operator|->
name|t_s
operator|.
name|s_addr
argument_list|,
name|tp
operator|->
name|t_dst
argument_list|,
name|tp
operator|->
name|t_d
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|t
operator|->
name|sws_qff
operator|-=
name|SWS_QFF_DEC
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sws_qff
operator|<
name|SWS_QFF_MIN
condition|)
name|t
operator|->
name|sws_qff
operator|=
name|SWS_QFF_MIN
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PRC_IFDOWN
case|:
block|{
name|u_long
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|arg
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|inpcb_notify
argument_list|(
operator|&
name|tcp
argument_list|,
name|addr
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|inpcb_notify
argument_list|(
operator|&
name|tcp
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
name|addr
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PRC_HOSTDEAD
case|:
comment|/* from imp interface */
case|case
name|PRC_HOSTUNREACH
case|:
comment|/* 	     * get same message for destination hosts and gateways. 	     */
block|{
name|u_long
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|arg
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|in_gdown
argument_list|(
operator|&
name|tcp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|inpcb_notify
argument_list|(
operator|&
name|tcp
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
name|addr
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"tcp_ctlinput"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

