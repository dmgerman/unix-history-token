begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)fault.c	1.1 */
end_comment

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Rewritten by David Korn  * AT&T Bell Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_include
include|#
directive|include
file|"timeout.h"
end_include

begin_comment
comment|/* until the bug is fixed */
end_comment

begin_define
define|#
directive|define
name|VOID
value|int
end_define

begin_function_decl
name|VOID
name|fault
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|chktrap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|stdsig
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ignsig
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|getsig
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|oldsig
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|clrsig
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|VOID
name|done
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exitsh
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_str
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|setbrk
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|VFORK
end_ifdef

begin_decl_stmt
name|char
name|trapflg
index|[
name|MAXTRAP
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|trapflg
index|[
name|MAXTRAP
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VFORK */
end_comment

begin_comment
comment|/* ========	fault handling routines	   ======== */
end_comment

begin_function
name|VOID
name|fault
parameter_list|(
name|sig
parameter_list|)
specifier|register
name|int
name|sig
decl_stmt|;
block|{
specifier|register
name|int
name|flag
decl_stmt|;
ifdef|#
directive|ifdef
name|JOBS
ifndef|#
directive|ifndef
name|BSD
if|if
condition|(
name|sig
operator|==
name|SIGCLD
condition|)
block|{
name|trapnote
operator||=
name|SIGJOBS
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* BSD */
endif|#
directive|endif
comment|/* JOBS */
name|signal
argument_list|(
name|sig
argument_list|,
name|fault
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|SIGSEGV
condition|)
name|setbrk
argument_list|(
name|BRKINCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|SIGALRM
condition|)
block|{
if|if
condition|(
operator|(
name|states
operator|&
name|WAITING
operator|)
operator|&&
name|timeout
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|states
operator|&
name|RWAIT
condition|)
block|{
comment|/* force exit */
name|states
operator||=
name|FORKED
expr_stmt|;
name|error
argument_list|(
name|timed_out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|states
operator||=
name|RWAIT
expr_stmt|;
name|alarm
argument_list|(
name|TGRACE
argument_list|)
expr_stmt|;
name|p_str
argument_list|(
name|time_warn
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|p_flush
argument_list|()
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|JOBS
ifdef|#
directive|ifdef
name|BSD
elseif|else
if|if
condition|(
name|sig
operator|==
name|SIGCHLD
operator|||
name|sig
operator|==
name|SIGTSTP
operator|||
name|sig
operator|==
name|SIGTTIN
operator|||
name|sig
operator|==
name|SIGTTOU
condition|)
name|trapnote
operator||=
name|SIGJOBS
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
endif|#
directive|endif
comment|/* JOBS */
else|else
block|{
name|flag
operator|=
operator|(
name|trapcom
index|[
name|sig
index|]
condition|?
name|TRAPSET
else|:
name|SIGSET
operator|)
expr_stmt|;
name|trapnote
operator||=
name|flag
expr_stmt|;
name|trapflg
index|[
name|sig
index|]
operator||=
name|flag
expr_stmt|;
if|if
condition|(
name|sig
operator|<=
name|SIGQUIT
condition|)
name|trapnote
operator||=
name|SIGSLOW
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|JOBS
ifdef|#
directive|ifdef
name|BSD
comment|/* This is needed because broken reads automatically restart */
if|if
condition|(
name|states
operator|&
name|READC
condition|)
name|interrupt
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
endif|#
directive|endif
comment|/* JOBS */
block|}
end_function

begin_function
name|void
name|stdsigs
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|SYSPTR
name|syscan
init|=
name|signal_names
decl_stmt|;
while|while
condition|(
operator|*
name|syscan
operator|->
name|sysnam
condition|)
block|{
name|n
operator|=
name|syscan
operator|->
name|sysval
expr_stmt|;
name|i
operator|=
name|n
operator|&
operator|(
operator|(
literal|1
operator|<<
name|SIGBITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|n
operator|>>=
name|SIGBITS
expr_stmt|;
name|trapflg
index|[
operator|--
name|i
index|]
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|&
operator|(
name|SIGIGNORE
operator||
name|SIGNOSET
operator|)
operator|)
operator|==
literal|0
operator|&&
name|ignsig
argument_list|(
name|i
argument_list|)
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|i
argument_list|,
operator|(
name|n
operator|&
name|SIGCAUGHT
condition|?
name|fault
else|:
name|done
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|SIGQUIT
condition|)
name|ignsig
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
name|syscan
operator|++
expr_stmt|;
block|}
name|syscan
operator|=
name|sig_messages
expr_stmt|;
while|while
condition|(
name|n
operator|=
name|syscan
operator|->
name|sysval
condition|)
block|{
if|if
condition|(
operator|*
name|syscan
operator|->
name|sysnam
condition|)
name|sysmsg
index|[
name|n
operator|-
literal|1
index|]
operator|=
name|syscan
operator|->
name|sysnam
expr_stmt|;
name|syscan
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * set signal n to ignore  * returns 1 if signal was already ignored, 0 otherwise  */
end_comment

begin_function
name|int
name|ignsig
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
operator|(
name|signal
argument_list|(
name|n
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
operator|)
operator|)
operator|==
literal|0
condition|)
name|trapflg
index|[
name|n
index|]
operator||=
name|SIGMOD
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|void
name|getsig
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|trapflg
index|[
name|n
index|]
operator|&
name|SIGMOD
operator|||
name|ignsig
argument_list|(
name|n
argument_list|)
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|n
argument_list|,
name|fault
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|oldsigs
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|i
operator|=
name|MAXTRAP
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|t
operator|=
name|trapcom
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
operator|||
operator|*
name|t
condition|)
block|{
ifdef|#
directive|ifdef
name|VFORK
comment|/* don't free the trap string */
if|if
condition|(
name|states
operator|&
name|VFORKED
condition|)
empty_stmt|;
name|trapcom
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* VFORK */
name|clrsig
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|trapflg
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|trapnote
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clrsig
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|trapcom
index|[
name|n
index|]
condition|)
block|{
name|free
argument_list|(
name|trapcom
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|trapcom
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|trapflg
index|[
name|n
index|]
operator|&
name|SIGMOD
condition|)
block|{
if|if
condition|(
name|trapflg
index|[
name|n
index|]
operator|&
name|SIGCAUGHT
condition|)
name|signal
argument_list|(
name|n
argument_list|,
name|fault
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|trapflg
index|[
name|n
index|]
operator|&
name|SIGIGNORE
condition|)
name|signal
argument_list|(
name|n
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
else|else
name|signal
argument_list|(
name|n
argument_list|,
name|done
argument_list|)
expr_stmt|;
name|trapflg
index|[
name|n
index|]
operator|&=
operator|~
name|SIGMOD
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * check for traps  */
end_comment

begin_function
name|void
name|chktrap
parameter_list|()
block|{
specifier|register
name|int
name|i
init|=
name|MAXTRAP
operator|+
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|trapnote
operator|&=
operator|~
operator|(
name|TRAPSET
operator||
name|SIGSLOW
operator|)
expr_stmt|;
if|if
condition|(
name|states
operator|&
name|ERRFLG
condition|)
block|{
if|if
condition|(
name|is_option
argument_list|(
name|ONEFLG
argument_list|)
condition|)
name|exitsh
argument_list|(
name|exitval
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exitval
condition|)
block|{
if|if
condition|(
name|trapcom
index|[
name|MAXTRAP
index|]
condition|)
name|trapflg
index|[
name|MAXTRAP
index|]
operator|=
name|TRAPSET
expr_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|ERRFLG
argument_list|)
condition|)
name|exitsh
argument_list|(
name|exitval
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|--
name|i
condition|)
block|{
if|if
condition|(
name|trapflg
index|[
name|i
index|]
operator|&
name|TRAPSET
condition|)
block|{
name|trapflg
index|[
name|i
index|]
operator|&=
operator|~
name|TRAPSET
expr_stmt|;
if|if
condition|(
name|t
operator|=
name|trapcom
index|[
name|i
index|]
condition|)
block|{
name|int
name|savxit
init|=
name|exitval
decl_stmt|;
name|execexp
argument_list|(
name|t
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|exitval
operator|=
name|savxit
expr_stmt|;
name|exitset
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

