begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)main.c	1.1 */
end_comment

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Rewritten by David Korn  * AT&T Bell Laboratories  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD_4_2
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD_4_2 */
end_comment

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"mode.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"timeout.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_include
include|#
directive|include
file|<execargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pdp11 */
end_comment

begin_define
define|#
directive|define
name|FC_CHAR
value|'!'
end_define

begin_comment
comment|/* These routines are defined by this module */
end_comment

begin_function_decl
name|int
name|main
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|chkpr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getpwd
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* These routines are referenced by this module */
end_comment

begin_function_decl
specifier|extern
name|void
name|addblok
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|assign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|chkopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|TREPTR
name|cmd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|done
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fassign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getpwd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|gscan_some
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|hist_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_eof
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|initf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mactry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|mem_reinit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|meminit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|pathopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_num
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_str
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_setout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|rmlocal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strrchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|settemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|simple
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|stdsigs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tdystak
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|valup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pr_prompt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkmail
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following is defined for fixcmd */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stat
name|lastmail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|mailtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BOOL
name|beenhere
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|euserid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|egroupid
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|v
index|[]
decl_stmt|;
block|{
name|FILE
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|sim
decl_stmt|;
specifier|register
name|int
name|rsflag
init|=
literal|1
decl_stmt|;
comment|/* local restricted flag */
ifdef|#
directive|ifdef
name|apollo
specifier|extern
name|char
name|pm_$unix_env
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|_iobmax
decl_stmt|;
name|pm_$unix_env
operator|=
operator|-
literal|1
expr_stmt|;
name|_iobmax
operator|=
name|_iob
operator|+
literal|20
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
name|standout
operator|=
name|stdout
expr_stmt|;
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|standin
operator|=
operator|&
name|stdfile
expr_stmt|;
name|userid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|euserid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|egroupid
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|time
argument_list|(
operator|&
name|mailtime
argument_list|)
expr_stmt|;
name|stdsigs
argument_list|()
expr_stmt|;
comment|/* initialize storage allocation */
name|stakbot
operator|=
literal|0
expr_stmt|;
name|addblok
argument_list|(
operator|(
name|unsigned
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* set up memory for namenods */
name|meminit
argument_list|()
expr_stmt|;
comment|/* set names from userenv 	 *  'rsflag' is zero if SHELL variable is 	 * set in environment and contains an'r' in 	 * the simple file part of the value. 	 */
name|rsflag
operator|=
name|genenv
argument_list|()
expr_stmt|;
comment|/* a shell is also restricted if argv(0) has 	 *  an 'rsh' for its simple name 	 */
name|sim
operator|=
name|simple
argument_list|(
operator|*
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sim
operator|==
literal|'-'
condition|)
block|{
name|sim
operator|++
expr_stmt|;
name|login_sh
operator|=
literal|2
expr_stmt|;
block|}
comment|/* check for restricted shell */
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|gmatch
argument_list|(
name|sim
argument_list|,
literal|"*rsh"
argument_list|)
condition|)
name|rsflag
operator|=
literal|0
expr_stmt|;
comment|/* look for options */
comment|/* dolc is $#	*/
name|dolc
operator|=
name|arg_opts
argument_list|(
name|c
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|dolv
operator|=
name|v
operator|+
name|c
operator|-
name|dolc
operator|--
expr_stmt|;
name|dolv
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|dolc
operator|<
literal|1
condition|)
name|on_option
argument_list|(
name|STDFLG
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|STDFLG
operator||
name|CFLAG
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dolc
operator|--
expr_stmt|;
name|dolv
operator|++
expr_stmt|;
block|}
comment|/* set[ug]id scripts run with the -p flag */
if|if
condition|(
name|userid
operator|!=
name|euserid
operator|||
name|getgid
argument_list|()
operator|!=
name|egroupid
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD_4_2
comment|/* careful of #! setuid scripts with name beginning with - */
if|if
condition|(
name|login_sh
operator|&&
name|strcmp
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
name|prohibited
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD_4_2 */
name|assign
argument_list|(
name|PATHNOD
argument_list|,
name|defpath
argument_list|)
expr_stmt|;
name|on_option
argument_list|(
name|PRIVM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_option
argument_list|(
name|RSHFLG
argument_list|)
condition|)
block|{
name|rsflag
operator|=
literal|0
expr_stmt|;
name|off_option
argument_list|(
name|RSHFLG
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * return here for shell file execution 	 * but not for parenthesis subshells 	 */
name|setjmp
argument_list|(
name|subshell
argument_list|)
expr_stmt|;
name|cmdadr
operator|=
name|dolv
index|[
literal|0
index|]
expr_stmt|;
comment|/* cmdadr is $0 */
comment|/* set pidname '$$' */
name|movstr
argument_list|(
name|itos
argument_list|(
name|ppid
operator|=
name|getpid
argument_list|()
argument_list|)
argument_list|,
name|pidadr
argument_list|)
expr_stmt|;
name|srand
argument_list|(
name|ppid
argument_list|)
expr_stmt|;
name|ppid
operator|=
name|getppid
argument_list|()
expr_stmt|;
name|settemp
argument_list|(
name|pidadr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|beenhere
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|prof
init|=
operator|!
name|is_option
argument_list|(
name|PRIVM
argument_list|)
decl_stmt|;
comment|/* decide whether shell is interactive */
if|if
condition|(
name|is_option
argument_list|(
name|ONEFLG
operator||
name|CFLAG
argument_list|)
operator|==
literal|0
operator|&&
name|is_option
argument_list|(
name|STDFLG
argument_list|)
operator|&&
name|isatty
argument_list|(
literal|0
argument_list|)
operator|&&
name|isatty
argument_list|(
literal|2
argument_list|)
condition|)
name|on_option
argument_list|(
name|INTFLG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppid
operator|==
literal|1
condition|)
name|login_sh
operator|++
expr_stmt|;
if|if
condition|(
name|login_sh
operator|>=
literal|2
condition|)
block|{
comment|/* ? profile */
name|login_sh
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|JOBS
ifdef|#
directive|ifdef
name|BSD
name|init_jobs
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
ifdef|#
directive|ifdef
name|SXT
name|init_jobs
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SXT */
endif|#
directive|endif
comment|/* JOBS */
comment|/*	system profile	*/
if|if
condition|(
operator|(
name|input
operator|=
name|pathopen
argument_list|(
name|sysprofile
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|exfile
argument_list|(
name|TTYFLG
argument_list|)
expr_stmt|;
comment|/* file exists */
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prof
operator|&&
operator|(
name|input
operator|=
name|pathopen
argument_list|(
name|mactry
argument_list|(
name|profile
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|exfile
argument_list|(
name|TTYFLG
argument_list|)
expr_stmt|;
name|states
operator|&=
operator|~
name|TTYFLG
expr_stmt|;
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* make sure PWD is set up correctly */
if|if
condition|(
name|getpwd
argument_list|(
literal|1
argument_list|)
condition|)
name|attrib
argument_list|(
name|PWDNOD
argument_list|,
name|N_EXPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof
condition|)
block|{
if|if
condition|(
name|sim
operator|=
name|valup
argument_list|(
name|ENVNOD
argument_list|)
condition|)
if|if
condition|(
operator|*
operator|(
name|sim
operator|=
name|mactry
argument_list|(
name|sim
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|sim
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sim
operator|=
name|suid_profile
expr_stmt|;
if|if
condition|(
name|sim
operator|&&
operator|(
name|input
operator|=
name|pathopen
argument_list|(
name|sim
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|exfile
argument_list|(
name|TTYFLG
argument_list|)
expr_stmt|;
name|states
operator|&=
operator|~
name|TTYFLG
expr_stmt|;
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsflag
operator|==
literal|0
condition|)
name|on_option
argument_list|(
name|RSHFLG
argument_list|)
expr_stmt|;
comment|/* open input file if specified */
if|if
condition|(
name|comdiv
condition|)
block|{
name|estabf
argument_list|(
name|comdiv
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sim
operator|=
name|cmdadr
expr_stmt|;
name|cmdadr
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|STDFLG
argument_list|)
condition|)
name|input
operator|=
name|stdin
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|VFORK
name|char
modifier|*
name|sp
init|=
name|sim
decl_stmt|;
comment|/* avoid path search if we already have the 				 * path name in the environment 				 */
if|if
condition|(
name|strcmp
argument_list|(
name|sim
argument_list|,
name|simple
argument_list|(
operator|*
name|environ
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|sp
operator|=
operator|(
operator|*
name|environ
operator|)
operator|+
literal|2
expr_stmt|;
endif|#
directive|endif
comment|/* VFORK */
ifdef|#
directive|ifdef
name|SUID_EXEC
comment|/* open stream should have been passed into shell */
if|if
condition|(
name|gmatch
argument_list|(
name|sim
argument_list|,
name|devfdNN
argument_list|)
condition|)
block|{
name|struct
name|stat
name|statb
decl_stmt|;
name|int
name|fd
init|=
name|atoi
argument_list|(
name|sim
operator|+
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
name|failed
argument_list|(
name|cmdadr
argument_list|,
name|badopen
argument_list|)
expr_stmt|;
name|input
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|sim
operator|=
name|cmdadr
expr_stmt|;
name|off_option
argument_list|(
name|EXECPR
operator||
name|READPR
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* SUID_EXEC */
ifdef|#
directive|ifdef
name|VFORK
if|if
condition|(
operator|(
name|input
operator|=
name|pathopen
argument_list|(
name|sp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|input
operator|=
name|pathopen
argument_list|(
name|sim
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* for compatibility with bsh */
if|if
condition|(
operator|(
name|input
operator|=
name|chkopen
argument_list|(
name|sim
argument_list|)
operator|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
comment|/* VFORK */
name|failed
argument_list|(
name|sim
argument_list|,
name|badopen
argument_list|)
expr_stmt|;
comment|/* eliminate local aliases and functions */
name|gscan_some
argument_list|(
name|rmlocal
argument_list|,
name|alias
argument_list|,
name|N_EXPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gscan_some
argument_list|(
name|rmlocal
argument_list|,
name|prnames
argument_list|,
name|N_EXPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cmdadr
operator|=
name|sim
expr_stmt|;
name|comdiv
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|ACCT
name|initacct
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileno
argument_list|(
name|input
argument_list|)
operator|!=
literal|0
condition|)
name|preacct
argument_list|(
name|cmdadr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ACCT */
block|}
block|}
ifdef|#
directive|ifdef
name|pdp11
else|else
operator|*
name|execargs
operator|=
operator|(
name|char
operator|*
operator|)
name|dolv
expr_stmt|;
comment|/* for `ps' cmd */
endif|#
directive|endif
comment|/* pdp11 */
name|states
operator||=
name|is_option
argument_list|(
name|INTFLG
argument_list|)
expr_stmt|;
name|exfile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|states
operator|&
name|PROMPT
condition|)
name|newline
argument_list|()
expr_stmt|;
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|exfile
parameter_list|(
name|prof
parameter_list|)
specifier|register
name|int
name|prof
decl_stmt|;
block|{
name|long
name|curtime
decl_stmt|;
name|TREPTR
name|t
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|input
decl_stmt|;
specifier|register
name|struct
name|fixcmd
modifier|*
name|fixp
decl_stmt|;
specifier|register
name|int
name|fno
decl_stmt|;
name|unsigned
name|execflags
decl_stmt|;
comment|/* move input */
if|if
condition|(
name|fisopen
argument_list|(
name|fp
argument_list|)
operator|&&
operator|(
name|fno
operator|=
name|fileno
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|F_STRING
condition|)
block|{
if|if
condition|(
name|fno
operator|>
literal|0
condition|)
block|{
name|fp
operator|=
name|input
operator|=
name|frenumber
argument_list|(
name|fp
argument_list|,
name|INIO
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|_sibuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof
operator|==
literal|0
condition|)
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
comment|/* if stdin is a pipe it must be unbuffered */
else|else
name|setbuf
argument_list|(
name|fp
argument_list|,
name|ispipe
argument_list|(
name|fp
argument_list|)
condition|?
name|NIL
else|:
operator|(
name|char
operator|*
operator|)
name|_sibuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|states
operator|&
name|INTFLG
condition|)
block|{
if|if
condition|(
name|isnull
argument_list|(
name|PS1NOD
argument_list|)
condition|)
name|assign
argument_list|(
name|PS1NOD
argument_list|,
operator|(
name|euserid
condition|?
name|stdprompt
else|:
name|supprompt
operator|)
argument_list|)
expr_stmt|;
name|states
operator||=
name|TTYFLG
operator||
name|PROMPT
expr_stmt|;
name|ignsig
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
name|hist_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|fc_fix
condition|)
name|on_option
argument_list|(
name|FIXFLG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JOBS
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
name|login_sh
operator|<=
literal|1
condition|)
name|init_jobs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
ifdef|#
directive|ifdef
name|SXT
if|if
condition|(
name|login_sh
operator|<=
literal|1
condition|)
name|init_jobs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SXT */
endif|#
directive|endif
comment|/* JOBS */
block|}
else|else
block|{
if|if
condition|(
name|prof
condition|)
name|states
operator||=
name|prof
expr_stmt|;
else|else
block|{
name|off_option
argument_list|(
name|EDITVI
operator||
name|EMACS
operator||
name|GMACS
argument_list|)
expr_stmt|;
name|on_option
argument_list|(
name|HASHALL
operator||
name|INPROC
argument_list|)
expr_stmt|;
block|}
name|states
operator|&=
operator|~
operator|(
name|PROMPT
operator||
name|MONITOR
operator|)
expr_stmt|;
name|off_option
argument_list|(
name|FIXFLG
argument_list|)
expr_stmt|;
block|}
name|fixp
operator|=
name|fc_fix
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|errshell
argument_list|)
operator|&&
name|prof
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* error return here */
name|freturn
operator|=
operator|(
name|jmp_buf
operator|*
operator|)
name|errshell
expr_stmt|;
name|loopcnt
operator|=
name|peekc
operator|=
name|peekn
operator|=
literal|0
expr_stmt|;
name|iopend
operator|=
literal|0
expr_stmt|;
name|linked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|initf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
goto|goto
name|eof_or_error
goto|;
comment|/* command loop */
while|while
condition|(
literal|1
condition|)
block|{
name|tdystak
argument_list|(
operator|(
name|STKPTR
operator|)
literal|0
argument_list|)
expr_stmt|;
name|stakchk
argument_list|()
expr_stmt|;
comment|/* may reduce sbrk */
name|exitset
argument_list|()
expr_stmt|;
name|states
operator|&=
operator|~
operator|(
name|ERRFLG
operator||
name|READPR
operator||
name|RWAIT
operator||
name|MONITOR
operator|)
expr_stmt|;
name|states
operator||=
name|is_option
argument_list|(
name|READPR
argument_list|)
operator||
name|WAITING
operator||
name|ERRFLG
expr_stmt|;
comment|/* -eim  flags don't apply to profiles */
if|if
condition|(
name|prof
condition|)
name|states
operator|&=
operator|~
operator|(
name|INTFLG
operator||
name|ERRFLG
operator||
name|MONITOR
operator|)
expr_stmt|;
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|states
operator|&
name|PROMPT
operator|)
operator|&&
name|standin
operator|->
name|fstak
operator|==
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|mail
decl_stmt|;
ifdef|#
directive|ifdef
name|JOBS
comment|/* allow children to be stopped*/
name|states
operator|&=
operator|~
operator|(
name|MONITOR
operator||
name|NONSTOP
operator|)
expr_stmt|;
name|states
operator||=
name|is_option
argument_list|(
name|MONITOR
argument_list|)
expr_stmt|;
name|list_jobs
argument_list|(
name|N_FLAG
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
if|if
condition|(
operator|(
name|mail
operator|=
name|valup
argument_list|(
name|MAILPNOD
argument_list|)
operator|)
operator|||
operator|(
name|mail
operator|=
name|valup
argument_list|(
name|MAILNOD
argument_list|)
operator|)
condition|)
block|{
name|time
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curtime
operator|-
name|mailtime
operator|)
operator|>=
name|mailchk
condition|)
block|{
name|chkmail
argument_list|(
name|mail
argument_list|)
expr_stmt|;
name|mailtime
operator|=
name|curtime
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fixp
condition|)
name|hist_eof
argument_list|()
expr_stmt|;
name|pr_prompt
argument_list|(
name|mactry
argument_list|(
name|valup
argument_list|(
name|PS1NOD
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sets timeout for command entry */
if|#
directive|if
name|TIMEOUT
operator|!=
literal|0
if|if
condition|(
name|timeout
operator|<=
literal|0
operator|||
name|timeout
operator|>
name|TIMEOUT
condition|)
name|timeout
operator|=
name|TIMEOUT
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
name|timeout
argument_list|)
expr_stmt|;
name|standin
operator|->
name|flin
operator|=
literal|1
expr_stmt|;
block|}
name|trapnote
operator|=
literal|0
expr_stmt|;
name|peekc
operator|=
name|readc
argument_list|()
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|eof_or_error
label|:
if|if
condition|(
operator|(
name|states
operator|&
name|PROMPT
operator|)
operator|&&
name|standin
operator|->
name|fstak
operator|==
literal|0
operator|&&
name|ferror
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|NOEOF
argument_list|)
operator|&&
operator|!
name|ferror
argument_list|(
name|output
argument_list|)
condition|)
block|{
name|p_str
argument_list|(
name|logout
argument_list|,
name|NL
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|JOBS
elseif|else
if|if
condition|(
name|close_jobs
argument_list|()
operator|<
literal|0
condition|)
continue|continue;
endif|#
directive|endif
comment|/* JOBS */
name|hist_close
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|states
operator|&
name|PROMPT
operator|)
operator|&&
name|fixp
condition|)
block|{
name|hist_eof
argument_list|()
expr_stmt|;
name|putc
argument_list|(
name|peekc
argument_list|,
name|fixp
operator|->
name|fixfd
argument_list|)
expr_stmt|;
block|}
name|states
operator||=
name|is_option
argument_list|(
name|FIXFLG
argument_list|)
expr_stmt|;
name|states
operator|&=
operator|~
name|WAITING
expr_stmt|;
name|t
operator|=
name|cmd
argument_list|(
name|NL
argument_list|,
name|MTFLG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixp
condition|)
name|hist_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|execflags
operator|=
name|ERRFLG
expr_stmt|;
comment|/* sh -c simple-command may not have to fork */
if|if
condition|(
name|prof
operator|==
literal|0
operator|&&
name|is_option
argument_list|(
name|CFLAG
argument_list|)
operator|&&
operator|(
name|t
operator|->
name|tretyp
operator|&
name|COMMSK
operator|)
operator|==
name|TCOM
operator|&&
name|nextchar
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|execflags
operator||=
literal|1
expr_stmt|;
block|}
name|execute
argument_list|(
name|t
argument_list|,
name|execflags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * if there is pending input, the prompt is not printed.  * prints PS2 if flag is zero otherwise PS3  */
end_comment

begin_function
name|void
name|chkpr
parameter_list|(
name|flag
parameter_list|)
specifier|register
name|int
name|flag
decl_stmt|;
block|{
if|if
condition|(
name|flag
operator|||
operator|(
name|states
operator|&
name|PROMPT
operator|)
operator|&&
name|standin
operator|->
name|fstak
operator|==
literal|0
condition|)
block|{
comment|/* if characters are in input buffer don't issue prompt */
if|if
condition|(
operator|(
name|flag
condition|?
name|stdin
else|:
name|input
operator|)
operator|->
name|_cnt
operator|>
literal|0
condition|)
return|return;
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|valup
argument_list|(
name|flag
condition|?
name|PS3NOD
else|:
name|PS2NOD
argument_list|)
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* prints out messages if files in list have been modified since last call */
end_comment

begin_function
specifier|static
name|void
name|chkmail
parameter_list|(
name|files
parameter_list|)
name|char
modifier|*
name|files
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|qp
decl_stmt|;
specifier|register
name|char
name|save
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|files
operator|)
operator|==
literal|0
condition|)
return|return;
name|sp
operator|=
name|cp
expr_stmt|;
do|do
block|{
comment|/* skip to : or end of string saving first '?' */
for|for
control|(
name|qp
operator|=
literal|0
init|;
operator|*
name|sp
operator|&&
operator|*
name|sp
operator|!=
literal|':'
condition|;
name|sp
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|sp
operator|==
literal|'?'
operator|||
operator|*
name|sp
operator|==
literal|'%'
operator|)
operator|&&
name|qp
operator|==
literal|0
condition|)
name|qp
operator|=
name|sp
expr_stmt|;
name|save
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* change '?' to end-of-string */
if|if
condition|(
name|qp
condition|)
operator|*
name|qp
operator|=
literal|0
expr_stmt|;
name|gchain
operator|=
name|NULL
expr_stmt|;
do|do
block|{
comment|/* see if time has been modified since last checked 			 * and the access time<= the modification time 			 */
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|statb
argument_list|)
operator|>=
literal|0
operator|&&
name|statb
operator|.
name|st_mtime
operator|>=
name|mailtime
operator|&&
name|statb
operator|.
name|st_atime
operator|<=
name|statb
operator|.
name|st_mtime
condition|)
block|{
comment|/* check for directory */
if|if
condition|(
name|gchain
operator|==
name|NULL
operator|&&
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
comment|/* generate list of directory entries */
name|f_complete
argument_list|(
name|cp
argument_list|,
literal|"/*"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * If the file has shrunk, 					 * or if the size is zero 					 * then don't print anything 					 */
if|if
condition|(
name|statb
operator|.
name|st_size
operator|&&
operator|(
name|statb
operator|.
name|st_ino
operator|!=
name|lastmail
operator|.
name|st_ino
operator|||
name|statb
operator|.
name|st_dev
operator|!=
name|lastmail
operator|.
name|st_dev
operator|||
name|statb
operator|.
name|st_size
operator|>
name|lastmail
operator|.
name|st_size
operator|)
condition|)
block|{
comment|/* save and restore $_ */
name|char
modifier|*
name|save
init|=
name|lastarg
decl_stmt|;
name|lastarg
operator|=
name|cp
expr_stmt|;
name|p_str
argument_list|(
name|mactry
argument_list|(
name|qp
operator|==
literal|0
condition|?
name|mailmsg
else|:
name|qp
operator|+
literal|1
argument_list|)
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|lastarg
operator|=
name|save
expr_stmt|;
block|}
name|lastmail
operator|=
name|statb
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|gchain
condition|)
block|{
name|cp
operator|=
name|gchain
operator|->
name|argval
expr_stmt|;
name|gchain
operator|=
name|gchain
operator|->
name|argchn
expr_stmt|;
block|}
else|else
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|cp
condition|)
do|;
if|if
condition|(
name|qp
condition|)
operator|*
name|qp
operator|=
literal|'?'
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|save
expr_stmt|;
name|cp
operator|=
name|sp
expr_stmt|;
block|}
do|while
condition|(
name|save
condition|)
do|;
name|tdystak
argument_list|(
operator|(
name|STKPTR
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print the primary prompt  */
end_comment

begin_function
specifier|static
name|void
name|pr_prompt
parameter_list|(
name|string
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|static
name|short
name|cmdno
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD
name|int
name|mode
decl_stmt|;
include|#
directive|include
file|<sys/ioctl.h>
name|mode
operator|=
name|LFLUSHO
expr_stmt|;
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|output
argument_list|)
argument_list|,
name|TIOCLBIC
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
name|p_flush
argument_list|()
expr_stmt|;
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|string
init|;
name|c
operator|=
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
name|FC_CHAR
condition|)
block|{
comment|/* look at next character */
name|c
operator|=
operator|*
operator|++
name|cp
expr_stmt|;
comment|/* print out line number if not !! */
if|if
condition|(
name|c
operator|!=
name|FC_CHAR
condition|)
name|p_num
argument_list|(
name|fc_fix
condition|?
name|fc_fix
operator|->
name|fixind
else|:
operator|++
name|cmdno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|VSH
operator|||
name|ESH
operator|*
name|output
operator|->
name|_ptr
operator|=
literal|0
expr_stmt|;
comment|/* prompt flushed later */
else|#
directive|else
name|p_flush
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* make sure PWD is set up correctly */
end_comment

begin_comment
comment|/*  * Return the value of the PWD variable  * Invokes /bin/pwd if necessary  * If mode non-zero, then PWD must have same device/inode as dot  */
end_comment

begin_function
name|char
modifier|*
name|getpwd
parameter_list|(
name|mode
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|sim
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|sim
operator|=
name|valup
argument_list|(
name|PWDNOD
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|sim
operator|==
literal|0
operator|||
operator|(
name|mode
operator|&&
operator|!
name|eq_inode
argument_list|(
name|sim
argument_list|,
name|dot
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|count
operator|++
operator|>
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|sim
operator|=
name|valup
argument_list|(
name|HOME
argument_list|)
operator|)
operator|&&
operator|*
name|sim
operator|==
literal|'/'
operator|&&
name|eq_inode
argument_list|(
name|sim
argument_list|,
name|dot
argument_list|)
condition|)
block|{
name|fassign
argument_list|(
name|PWDNOD
argument_list|,
name|sim
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|apollo
name|char
name|buff
index|[
name|BUFSIZ
operator|+
literal|1
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getcwd
parameter_list|()
function_decl|;
name|sim
operator|=
name|getcwd
argument_list|(
name|buff
operator|+
literal|1
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|buff
index|[
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|buff
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
name|buff
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|buff
index|[
literal|1
index|]
operator|=
literal|'n'
expr_stmt|;
name|sim
operator|=
name|buff
expr_stmt|;
block|}
name|fassign
argument_list|(
name|PWDNOD
argument_list|,
name|sim
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* even restricted shells can pwd */
name|optflag
name|savflags
init|=
name|flags
decl_stmt|;
name|off_option
argument_list|(
name|RSHFLG
argument_list|)
expr_stmt|;
name|execexp
argument_list|(
name|setpwd
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|flags
operator|=
name|savflags
expr_stmt|;
endif|#
directive|endif
comment|/* apollo */
block|}
block|}
return|return
operator|(
name|sim
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This version of access checks against effective uid/gid  */
end_comment

begin_expr_stmt
name|access
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
specifier|register
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
return|return
operator|(
name|mode
operator|)
return|;
elseif|else
if|if
condition|(
name|euserid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
operator|||
name|mode
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* root needs execute permission for someone */
name|mode
operator|=
operator|(
name|S_IEXEC
operator||
operator|(
name|S_IEXEC
operator|>>
literal|3
operator|)
operator||
operator|(
name|S_IEXEC
operator|>>
literal|6
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|euserid
operator|==
name|statb
operator|.
name|st_uid
condition|)
name|mode
operator|<<=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|egroupid
operator|==
name|statb
operator|.
name|st_gid
condition|)
name|mode
operator|<<=
literal|3
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
ifdef|#
directive|ifdef
name|BSD_4_2
comment|/* in BSD_4_2 you can be in several groups */
else|else
block|{
name|int
name|groups
index|[
name|NGROUPS
index|]
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|getgroups
argument_list|(
name|NGROUPS
argument_list|,
name|groups
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|groups
index|[
name|n
index|]
operator|==
name|statb
operator|.
name|st_gid
condition|)
block|{
name|mode
operator|<<=
literal|3
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* BSD_4_2 */
endif|#
directive|endif
comment|/* BSD */
if|if
condition|(
name|statb
operator|.
name|st_mode
operator|&
name|mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

end_unit

