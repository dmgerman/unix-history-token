begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)args.c	1.1 */
end_comment

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Rewritten by David Korn  * AT&T Bell Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"mode.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|JOBS
end_ifdef

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOBS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVFD */
end_comment

begin_function_decl
name|void
name|arg_set
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arg_reset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arg_clear
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|DOLPTR
name|arg_free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|DOLPTR
name|arg_use
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|DOLPTR
name|arg_new
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|arg_opts
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
modifier|*
name|arg_build
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|arg_dolminus
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFD
end_ifdef

begin_function_decl
name|void
name|close_pipes
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVFD */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|macro
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|assign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|chkpipe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exitsh
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|gsort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|trim
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_str
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_nchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_setout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|qvalup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arg_expand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|DOLPTR
name|copyargs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_opts
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|split
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|null
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DOLPTR
name|argfor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* linked list of blocks to be cleaned up */
end_comment

begin_decl_stmt
specifier|static
name|DOLPTR
name|dolh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|flagadr
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|flagchar
index|[]
init|=
block|{
literal|'i'
block|,
literal|'n'
block|,
literal|'v'
block|,
literal|'t'
block|,
literal|'s'
block|,
literal|'x'
block|,
literal|'e'
block|,
literal|'r'
block|,
literal|'k'
block|,
literal|'u'
block|,
literal|'f'
block|,
literal|'a'
block|,
literal|'m'
block|,
literal|'h'
block|,
literal|'p'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|optflag
name|flagval
index|[]
init|=
block|{
name|INTFLG
block|,
name|NOEXEC
block|,
name|READPR
block|,
name|ONEFLG
block|,
name|STDFLG
block|,
name|EXECPR
block|,
name|ERRFLG
block|,
name|RSHFLG
block|,
name|KEYFLG
block|,
name|NOSET
block|,
name|NOGLOB
block|,
name|ALLEXP
block|,
name|MONITOR
block|,
name|HASHALL
block|,
name|PRIVM
block|,
name|CFLAG
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ======== option handling	======== */
end_comment

begin_comment
comment|/*  *  This routine turns options on and off  *  The options "sicr" are illegal from set command.  *  The -o option is used to set option by name  *  This routine returns the number of non-option arguments  */
end_comment

begin_function
name|int
name|arg_opts
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argp
init|=
name|argv
decl_stmt|;
specifier|register
name|char
modifier|*
name|flagc
decl_stmt|;
specifier|register
name|optflag
name|newflags
init|=
name|flags
decl_stmt|;
specifier|register
name|optflag
name|opt
decl_stmt|;
name|char
name|minus
decl_stmt|;
name|int
name|sort
init|=
literal|0
decl_stmt|;
name|int
name|setflag
init|=
name|eq
argument_list|(
operator|*
name|argp
argument_list|,
name|bset
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
operator|*
operator|++
name|argp
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|)
condition|)
block|{
name|minus
operator|=
operator|(
name|c
operator|==
literal|'-'
operator|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|cp
operator|)
operator|==
literal|0
condition|)
block|{
name|newflags
operator|&=
operator|~
operator|(
name|EXECPR
operator||
name|READPR
operator|)
expr_stmt|;
name|argp
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|setflag
condition|)
name|states
operator||=
name|RWAIT
expr_stmt|;
name|argp
operator|++
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|c
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
if|if
condition|(
name|setflag
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
block|{
name|sort
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"icr"
argument_list|,
name|c
argument_list|)
condition|)
name|failed
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|badopt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'c'
operator|&&
name|minus
operator|&&
name|argc
operator|>=
literal|2
operator|&&
name|comdiv
operator|==
literal|0
condition|)
block|{
name|comdiv
operator|=
operator|*
operator|++
name|argp
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|newflags
operator||=
name|CFLAG
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|flagc
operator|=
name|strchr
argument_list|(
name|flagchar
argument_list|,
name|c
argument_list|)
condition|)
name|opt
operator|=
name|flagval
index|[
name|flagc
operator|-
name|flagchar
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'o'
condition|)
name|failed
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|badopt
argument_list|)
expr_stmt|;
else|else
block|{
name|argp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|argp
operator|==
name|NULL
condition|)
block|{
name|print_opts
argument_list|(
name|newflags
argument_list|)
expr_stmt|;
name|argp
operator|--
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|argc
operator|--
expr_stmt|;
name|c
operator|=
name|syslook
argument_list|(
operator|*
name|argp
argument_list|,
name|option_flags
argument_list|)
expr_stmt|;
name|opt
operator|=
literal|1L
operator|<<
name|c
expr_stmt|;
if|if
condition|(
name|opt
operator|&
operator|(
literal|1
operator||
name|INTFLG
operator||
name|RSHFLG
operator|)
condition|)
name|failed
argument_list|(
operator|*
name|argp
argument_list|,
name|badopt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|minus
condition|)
block|{
if|#
directive|if
name|ESH
operator|||
name|VSH
if|if
condition|(
name|opt
operator|&
operator|(
name|EDITVI
operator||
name|EMACS
operator||
name|GMACS
operator|)
condition|)
name|newflags
operator|&=
operator|~
operator|(
name|EDITVI
operator||
name|EMACS
operator||
name|GMACS
operator|)
expr_stmt|;
endif|#
directive|endif
name|newflags
operator||=
name|opt
expr_stmt|;
block|}
else|else
name|newflags
operator|&=
operator|~
name|opt
expr_stmt|;
block|}
block|}
comment|/* cannot set -n for interactive shells since there is no way out */
if|if
condition|(
name|is_option
argument_list|(
name|INTFLG
argument_list|)
condition|)
name|newflags
operator|&=
operator|~
name|NOEXEC
expr_stmt|;
ifdef|#
directive|ifdef
name|RAWONLY
if|if
condition|(
name|is_option
argument_list|(
name|EDITVI
argument_list|)
condition|)
name|newflags
operator||=
name|VIRAW
expr_stmt|;
endif|#
directive|endif
comment|/* RAWONLY */
if|if
condition|(
name|sort
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|gsort
argument_list|(
name|argp
argument_list|,
name|argc
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|gsort
argument_list|(
name|dolv
operator|+
literal|1
argument_list|,
name|dolc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|newflags
operator|&
name|PRIVM
operator|)
operator|&&
operator|!
name|is_option
argument_list|(
name|PRIVM
argument_list|)
condition|)
name|assign
argument_list|(
name|PATHNOD
argument_list|,
name|defpath
argument_list|)
expr_stmt|;
name|flags
operator|=
name|newflags
expr_stmt|;
return|return
operator|(
name|argc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns the value of $-  */
end_comment

begin_function
name|char
modifier|*
name|arg_dolminus
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|flagc
init|=
name|flagchar
decl_stmt|;
specifier|register
name|char
modifier|*
name|flagp
init|=
name|flagadr
decl_stmt|;
while|while
condition|(
operator|*
name|flagc
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|flagval
index|[
name|flagc
operator|-
name|flagchar
index|]
condition|)
operator|*
name|flagp
operator|++
operator|=
operator|*
name|flagc
expr_stmt|;
name|flagc
operator|++
expr_stmt|;
block|}
operator|*
name|flagp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|flagadr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set up positional parameters   */
end_comment

begin_function
name|void
name|arg_set
parameter_list|(
name|argi
parameter_list|)
name|char
modifier|*
name|argi
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|argp
init|=
name|argi
decl_stmt|;
specifier|register
name|int
name|size
init|=
literal|0
decl_stmt|;
comment|/* count number of bytes needed for strings */
specifier|register
name|int
name|argn
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* count args and number of bytes of arglist */
while|while
condition|(
operator|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
name|argp
operator|++
operator|)
operator|!=
name|ENDARGS
condition|)
block|{
name|size
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* free old ones unless on for loop chain */
name|argn
operator|=
name|argp
operator|-
name|argi
expr_stmt|;
name|arg_free
argument_list|(
name|dolh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dolh
operator|=
name|copyargs
argument_list|(
name|argi
argument_list|,
operator|--
name|argn
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dolc
operator|=
name|argn
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free the argument list if the use count is 1  * If count is greater than 1 decrement count and return same blk  * Free the argument list if the use count is 1 and return next blk  * Delete the blk from the argfor chain  * If flag is set, then the block dolh is not freed  */
end_comment

begin_function
name|DOLPTR
name|arg_free
parameter_list|(
name|blk
parameter_list|,
name|flag
parameter_list|)
name|DOLPTR
name|blk
decl_stmt|;
block|{
specifier|register
name|DOLPTR
name|argr
init|=
name|blk
decl_stmt|;
specifier|register
name|DOLPTR
name|argblk
decl_stmt|;
if|if
condition|(
name|argblk
operator|=
name|argr
condition|)
block|{
if|if
condition|(
operator|(
operator|--
name|argblk
operator|->
name|doluse
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flag
operator|&&
name|argblk
operator|==
name|dolh
condition|)
name|dolh
operator|->
name|doluse
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* delete from chain */
if|if
condition|(
name|argfor
operator|==
name|argblk
condition|)
name|argfor
operator|=
name|argblk
operator|->
name|dolnxt
expr_stmt|;
else|else
block|{
for|for
control|(
name|argr
operator|=
name|argfor
init|;
name|argr
condition|;
name|argr
operator|=
name|argr
operator|->
name|dolnxt
control|)
if|if
condition|(
name|argr
operator|->
name|dolnxt
operator|==
name|argblk
condition|)
break|break;
if|if
condition|(
name|argr
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|argr
operator|->
name|dolnxt
operator|=
name|argblk
operator|->
name|dolnxt
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argblk
argument_list|)
expr_stmt|;
block|}
name|argr
operator|=
name|argblk
operator|->
name|dolnxt
expr_stmt|;
block|}
block|}
return|return
operator|(
name|argr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * grab space for arglist and link argblock for cleanup  * The strings are copied after the argment vector  */
end_comment

begin_function
specifier|static
name|DOLPTR
name|copyargs
parameter_list|(
name|from
parameter_list|,
name|n
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|from
index|[]
decl_stmt|;
block|{
specifier|register
name|DOLPTR
name|dp
init|=
operator|(
name|DOLPTR
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|DOLTYPE
operator|+
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
name|size
operator|+
name|n
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|dp
operator|->
name|doluse
operator|=
literal|1
expr_stmt|;
comment|/* use count */
comment|/* link into chain */
name|dp
operator|->
name|dolnxt
operator|=
name|argfor
expr_stmt|;
name|argfor
operator|=
name|dp
expr_stmt|;
name|pp
operator|=
name|dp
operator|->
name|dolarg
expr_stmt|;
name|dolv
operator|=
name|pp
expr_stmt|;
name|sp
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|+
name|DOLTYPE
operator|+
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|movstr
argument_list|(
operator|*
name|from
operator|++
argument_list|,
name|sp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|ENDARGS
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  used to set new argument chain for functions  */
end_comment

begin_function
name|DOLPTR
name|arg_new
parameter_list|(
name|argi
parameter_list|,
name|savargfor
parameter_list|)
name|char
modifier|*
name|argi
index|[]
decl_stmt|;
name|DOLPTR
modifier|*
name|savargfor
decl_stmt|;
block|{
specifier|register
name|DOLPTR
name|olddolh
init|=
name|dolh
decl_stmt|;
operator|*
name|savargfor
operator|=
name|argfor
expr_stmt|;
name|dolh
operator|=
name|NULL
expr_stmt|;
name|argfor
operator|=
name|NULL
expr_stmt|;
name|arg_set
argument_list|(
name|argi
argument_list|)
expr_stmt|;
return|return
operator|(
name|olddolh
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * reset arguments as they were before function  */
end_comment

begin_function
name|void
name|arg_reset
parameter_list|(
name|blk
parameter_list|,
name|afor
parameter_list|)
name|DOLPTR
name|blk
decl_stmt|;
name|DOLPTR
name|afor
decl_stmt|;
block|{
while|while
condition|(
name|argfor
operator|=
name|arg_free
argument_list|(
name|argfor
argument_list|,
literal|0
argument_list|)
condition|)
empty_stmt|;
name|dolh
operator|=
name|blk
expr_stmt|;
name|argfor
operator|=
name|afor
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arg_clear
parameter_list|()
block|{
comment|/* force `for' $* lists to go away */
while|while
condition|(
name|argfor
operator|=
name|arg_free
argument_list|(
name|argfor
argument_list|,
literal|1
argument_list|)
condition|)
empty_stmt|;
comment|/* clean up io files */
name|argfor
operator|=
name|dolh
expr_stmt|;
while|while
condition|(
name|pop
argument_list|(
literal|0
argument_list|)
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|DEVFD
name|close_pipes
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEVFD */
block|}
end_function

begin_comment
comment|/*  * increase the use count so that an arg_set will not make it go away  */
end_comment

begin_function
name|DOLPTR
name|arg_use
parameter_list|()
block|{
specifier|register
name|DOLPTR
name|dh
decl_stmt|;
if|if
condition|(
name|dh
operator|=
name|dolh
condition|)
name|dh
operator|->
name|doluse
operator|++
expr_stmt|;
return|return
operator|(
name|dh
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Print option settings on standard output  */
end_comment

begin_function
specifier|static
name|void
name|print_opts
parameter_list|(
name|oflags
parameter_list|)
ifndef|#
directive|ifndef
name|pdp11
specifier|register
endif|#
directive|endif
comment|/* pdp11 */
name|optflag
name|oflags
decl_stmt|;
block|{
specifier|register
name|SYSPTR
name|syscan
init|=
name|option_flags
decl_stmt|;
ifndef|#
directive|ifndef
name|pdp11
specifier|register
endif|#
directive|endif
comment|/* pdp11 */
name|optflag
name|value
decl_stmt|;
name|p_setout
argument_list|(
name|standout
argument_list|)
expr_stmt|;
name|p_str
argument_list|(
name|opt_heading
argument_list|,
name|NL
argument_list|)
expr_stmt|;
while|while
condition|(
name|value
operator|=
name|syscan
operator|->
name|sysval
condition|)
block|{
name|value
operator|=
literal|1
operator|<<
name|value
expr_stmt|;
name|p_str
argument_list|(
name|syscan
operator|->
name|sysnam
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|p_nchr
argument_list|(
name|SP
argument_list|,
literal|16
operator|-
name|strlen
argument_list|(
name|syscan
operator|->
name|sysnam
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oflags
operator|&
name|value
condition|)
name|p_str
argument_list|(
name|on_
argument_list|,
name|NL
argument_list|)
expr_stmt|;
else|else
name|p_str
argument_list|(
name|off_
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|syscan
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * build an argument list  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|arg_build
parameter_list|(
name|nargs
parameter_list|,
name|comptr
parameter_list|)
name|int
modifier|*
name|nargs
decl_stmt|;
name|COMPTR
name|comptr
decl_stmt|;
block|{
specifier|register
name|ARGPTR
name|argp
decl_stmt|;
block|{
specifier|register
name|COMPTR
name|ac
init|=
name|comptr
decl_stmt|;
specifier|register
name|ARGPTR
name|schain
decl_stmt|;
comment|/* see if the arguments have already been expanded */
if|if
condition|(
name|ac
operator|->
name|comarg
operator|==
name|NULL
condition|)
block|{
operator|*
name|nargs
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|null
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ac
operator|->
name|comtyp
operator|&
name|COMSCAN
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|nargs
operator|=
operator|(
operator|(
name|DOLPTR
operator|)
name|ac
operator|->
name|comarg
operator|)
operator|->
name|doluse
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|DOLPTR
operator|)
name|ac
operator|->
name|comarg
operator|)
operator|->
name|dolarg
operator|+
literal|1
operator|)
return|;
block|}
name|schain
operator|=
name|gchain
expr_stmt|;
name|gchain
operator|=
name|NULL
expr_stmt|;
operator|*
name|nargs
operator|=
name|arg_expand
argument_list|(
name|ac
argument_list|)
expr_stmt|;
name|argp
operator|=
name|gchain
expr_stmt|;
name|gchain
operator|=
name|schain
expr_stmt|;
block|}
block|{
specifier|register
name|char
modifier|*
modifier|*
name|comargn
decl_stmt|;
specifier|register
name|int
name|argn
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|comargm
decl_stmt|;
name|argn
operator|=
operator|*
name|nargs
expr_stmt|;
name|argn
operator|++
expr_stmt|;
comment|/* allow room to prepend interpreter name */
name|comargn
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|getstak
argument_list|(
name|BYTESPERWORD
operator|*
name|argn
operator|+
name|BYTESPERWORD
argument_list|)
expr_stmt|;
name|comargm
operator|=
name|comargn
operator|+=
name|argn
expr_stmt|;
operator|*
name|comargn
operator|=
name|ENDARGS
expr_stmt|;
while|while
condition|(
name|argp
condition|)
block|{
operator|*
operator|--
name|comargn
operator|=
name|argp
operator|->
name|argval
expr_stmt|;
if|if
condition|(
operator|(
name|argp
operator|->
name|argflag
operator|&
name|A_RAW
operator|)
operator|==
literal|0
condition|)
name|trim
argument_list|(
operator|*
name|comargn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argp
operator|=
name|argp
operator|->
name|argchn
operator|)
operator|==
literal|0
operator|||
operator|(
name|argp
operator|->
name|argflag
operator|&
name|A_MAKE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|argn
operator|=
name|comargm
operator|-
name|comargn
operator|)
operator|>
literal|1
condition|)
name|gsort
argument_list|(
name|comargn
argument_list|,
name|argn
argument_list|)
expr_stmt|;
name|comargm
operator|=
name|comargn
expr_stmt|;
block|}
block|}
return|return
operator|(
name|comargn
operator|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFD
end_ifdef

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|to_close
index|[
literal|15
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|close_pipes
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
modifier|*
name|fd
init|=
name|to_close
decl_stmt|;
while|while
condition|(
operator|*
name|fd
condition|)
block|{
name|fclose
argument_list|(
operator|*
name|fd
argument_list|)
expr_stmt|;
operator|*
name|fd
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVFD */
end_comment

begin_comment
comment|/* Argument list generation */
end_comment

begin_function
specifier|static
name|int
name|arg_expand
parameter_list|(
name|ac
parameter_list|)
name|COMPTR
name|ac
decl_stmt|;
block|{
specifier|register
name|ARGPTR
name|argp
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFD
name|int
name|indx
init|=
literal|0
decl_stmt|;
name|close_pipes
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEVFD */
if|if
condition|(
name|ac
condition|)
block|{
name|argp
operator|=
name|ac
operator|->
name|comarg
expr_stmt|;
while|while
condition|(
name|argp
condition|)
block|{
name|argp
operator|->
name|argflag
operator|&=
operator|~
name|A_MAKE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFD
if|if
condition|(
operator|*
name|argp
operator|->
name|argval
operator|==
literal|0
operator|&&
operator|(
name|argp
operator|->
name|argflag
operator|&
name|A_EXP
operator|)
condition|)
block|{
comment|/* argument of the form (cmd) */
specifier|register
name|ARGPTR
name|ap
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|FILE
modifier|*
name|pv
index|[
literal|2
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|ap
operator|=
operator|(
name|ARGPTR
operator|)
name|locstak
argument_list|()
expr_stmt|;
name|ap
operator|->
name|argflag
operator||=
name|A_MAKE
expr_stmt|;
name|ap
operator|->
name|argflag
operator|&=
operator|~
name|A_RAW
expr_stmt|;
name|ap
operator|->
name|argchn
operator|=
name|gchain
expr_stmt|;
name|gchain
operator|=
name|ap
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|cp
operator|=
name|movstr
argument_list|(
name|devfd
argument_list|,
name|ap
operator|->
name|argval
argument_list|)
expr_stmt|;
name|chkpipe
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|fd
operator|=
name|argp
operator|->
name|argflag
operator|&
name|A_RAW
expr_stmt|;
name|endstak
argument_list|(
name|movstr
argument_list|(
name|itos
argument_list|(
name|fileno
argument_list|(
name|pv
index|[
name|fd
index|]
argument_list|)
argument_list|)
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
condition|)
name|execute
argument_list|(
operator|(
name|TREPTR
operator|)
name|argp
operator|->
name|argchn
argument_list|,
name|states
operator|&
name|ERRFLG
argument_list|,
name|pv
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|execute
argument_list|(
operator|(
name|TREPTR
operator|)
name|argp
operator|->
name|argchn
argument_list|,
name|states
operator|&
name|ERRFLG
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|pv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JOBS
name|jobstat
operator|.
name|j_flag
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
name|fclose
argument_list|(
name|pv
index|[
literal|1
operator|-
name|fd
index|]
argument_list|)
expr_stmt|;
name|to_close
index|[
name|indx
operator|++
index|]
operator|=
name|pv
index|[
name|fd
index|]
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* DEVFD */
if|if
condition|(
operator|(
name|argp
operator|->
name|argflag
operator|&
name|A_RAW
operator|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
name|argp
operator|->
name|argval
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|argflag
operator|&
name|A_MAC
condition|)
name|ap
operator|=
name|macro
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|count
operator|+=
name|split
argument_list|(
name|ap
argument_list|,
name|argp
operator|->
name|argflag
operator|&
name|A_MAC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argp
operator|->
name|argchn
operator|=
name|gchain
expr_stmt|;
name|gchain
operator|=
name|argp
expr_stmt|;
name|argp
operator|->
name|argflag
operator||=
name|A_MAKE
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|argp
operator|=
name|argp
operator|->
name|argnxt
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|split
parameter_list|(
name|s
parameter_list|,
name|macflg
parameter_list|)
comment|/* blank interpretation routine */
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|argp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|ARGPTR
name|ap
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|expflag
init|=
operator|(
name|is_option
argument_list|(
name|NOGLOB
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|char
modifier|*
name|seps
init|=
operator|(
name|macflg
condition|?
name|qvalup
argument_list|(
name|IFSNOD
argument_list|)
else|:
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|seps
operator|==
name|NULL
operator|||
operator|*
name|seps
operator|==
literal|0
condition|)
name|seps
operator|=
name|sptbnl
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|trapnote
operator|&
name|SIGSET
condition|)
name|exitsh
argument_list|(
name|SIGFAIL
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|(
name|ARGPTR
operator|)
name|locstak
argument_list|()
expr_stmt|;
name|argp
operator|=
name|ap
operator|->
name|argval
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|ESCAPE
condition|)
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'/'
condition|)
operator|*
name|argp
operator|++
operator|=
name|ESCAPE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|seps
argument_list|,
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
name|argp
operator|>=
name|brkend
condition|)
name|setbrk
argument_list|(
name|BRKINCR
argument_list|)
expr_stmt|;
operator|*
name|argp
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* This allows contiguous visible delimiters to count as delimiters */
if|if
condition|(
name|argp
operator|==
name|ap
operator|->
name|argval
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
name|count
operator|)
return|;
if|if
condition|(
name|macflg
operator|==
literal|0
operator|||
name|strchr
argument_list|(
name|sptbnl
argument_list|,
name|c
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|s
operator|--
expr_stmt|;
block|}
comment|/* file name generation */
name|endstak
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|argflag
operator|&=
operator|~
operator|(
name|A_RAW
operator||
name|A_MAKE
operator|)
expr_stmt|;
if|if
condition|(
name|expflag
operator|&&
operator|(
name|c
operator|=
name|expand
argument_list|(
name|ap
operator|->
name|argval
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|count
operator|+=
name|c
expr_stmt|;
else|else
block|{
name|count
operator|++
expr_stmt|;
name|ap
operator|->
name|argchn
operator|=
name|gchain
expr_stmt|;
name|gchain
operator|=
name|ap
expr_stmt|;
block|}
name|gchain
operator|->
name|argflag
operator||=
name|A_MAKE
expr_stmt|;
block|}
block|}
end_function

end_unit

