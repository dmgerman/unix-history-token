begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|Notice
index|[]
init|=
literal|"Copyright (c) 1985 Adobe Systems Incorporated"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ORCSID
init|=
literal|"$Header: pscomm.bsd,v 2.1 85/11/24 11:50:16 shore Rel $"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSID
init|=
literal|"$Header: pscomm.c,v 1.4 87/10/31 20:42:02 cuong Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pscomm.c  *  * Copyright (C) 1985 Adobe Systems Incorporated  *  * 4.2BSD lpr/lpd communications filter for PostScript printers  * (formerly "psif" in TranScript release 1.0)  *  * pscomm is the general communications filter for  * sending files to a PostScript printer (e.g., an Apple LaserWriter,  * QMS PostScript printer, or Linotype PostScript typesetter)  * via RS232 lines.  It does page accounting, error handling/reporting,  * job logging, banner page printing, etc.  * It observes (parts of) the PostScript file structuring conventions.  * In particular, it distinguishes between PostScript files (beginning  * with the "%!" magic number) -- which are shipped to the printer --  * and text files (no magic number) which are formatted and listed  * on the printer.  Files which begin with "%!PS-Adobe-" may be  * page-reversed if the target printer has that option specified.  *  * depending on the values of BANNERFIRST and BANNERLAST,   * pscomm looks for a file named ".banner", (created by the "of" filter)  * in the current working directory and ships it to the printer also.  *  * pscomm gets called with:  *	stdin	== the file to print (may be a pipe!)  *	stdout	== the printer  *	stderr	== the printer log file  *	cwd	== the spool directory  *	argv	== set up by interface shell script:  *	  filtername	-P printer  *			-p filtername  *			[-r]		(don't ever reverse)  *			-n login  *			-h host  *			[accntfile]  *  *	environ	== various environment variable effect behavior  *		VERBOSELOG	- do verbose log file output  *		BANNERFIRST	- print .banner before job  *		BANNERLAST	- print .banner after job  *		REVERSE		- page reversal filter program  *				  (no reversal if null or missing)  *		PSLIBDIR	- transcript library directory  *		PSTEXT		- simple text formatting filter  *		JOBOUTPUT	- file for actual printer stream  *				  output (if defined)  *  * pscomm depends on certain additional features of the 4.2BSD spooling  * architecture.  In particular it assumes that the printer status file  * has the default name (./status) and it uses this file to communicate  * printer error status information to the user -- the contents of the  * status file gets incorporated in "lpq" and "lpc status" messages.  *  * Edit History:  * Andrew Shore: Sat Nov 16 11:59:58 1985  * End Edit History.  *  * RCSLOG:  * $Log:	pscomm.c,v $  * Revision 1.4  87/10/31  20:42:02  cuong  * Two changes:  *     1. Make sender wait for listener's signal when requesting initial  *        pagecount.  The problem is with short jobs& fast machines;  *        the sender will merrily finish the job and send an asynchronous  *        status request the response to which will clobber the listener's  *        input stream.  *     2. Make sender sleep(1) just after sending the job-finish EOF to give  *        the LaserWriter a chance to update its status.  *   * Revision 1.3  87/10/03  16:42:47  cuong  * Takes care of improper handling of abnormal exits when  * accounting is turned on.  Pagecount information was again  * waited on abortively.  Now, it's fixed, no?  *   * Revision 1.2  87/09/20  19:03:25  cuong  * Fixed bug:  * Symptom: pagecount accounting turned on, then pscomms will hang.  * Reason: old pscomm listener assumed the final pagecount information  *         will come after the ctrl-d; this is not true.  Hence it  * 	hangs waiting after the ctrl-d is received.  * Fix:    while waiting for ctrl-d, the pscomm listener must also  *         scan for the pattern %%[ pagecount: %d ]%%, and save  *         this in the pbuf[] array if found.    * Cuong  *   * Revision 1.1  87/06/13  19:26:31  cuong  * Initial revision  *   * Revision 2.1  85/11/24  11:50:16  shore  * Product Release 2.0  *   * Revision 1.1  85/11/20  00:35:21  shore  * Initial revision  *   * Revision 1.2  85/05/14  11:25:29  shore  * better support for BANNERLAST, still buggy though  *   *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"transcript.h"
end_include

begin_include
include|#
directive|include
file|"psspool.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BDEBUG
end_ifdef

begin_define
define|#
directive|define
name|debugp
parameter_list|(
name|x
parameter_list|)
define|\
value|{ \    fprintf(stderr, "(pid %d) ", getpid()); \    fprintf x; \    (void) fflush(stderr); \ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debugp
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
endif|BDEBUG
end_endif

begin_comment
comment|/*  * the following string is sent to the printer when we want it to  * report its current pagecount (for accounting)  */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|getpages
init|=
literal|"\n(%%%%[ pagecount: )print \ statusdict/pagecount get exec(                )cvs print( ]%%%%)= flush\n%s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|jmp_buf
name|waitonreverse
decl_stmt|,
name|startstatus
decl_stmt|,
name|dwait
decl_stmt|,
name|sendint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* invoking program name */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user login name */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host name */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|pname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* printer name */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|accountingfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file for printer accounting */
end_comment

begin_decl_stmt
name|private
name|int
name|doactng
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we can do accounting */
end_comment

begin_decl_stmt
name|private
name|int
name|progress
decl_stmt|,
name|oldprogress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* finite progress counts */
end_comment

begin_decl_stmt
name|private
name|int
name|getstatus
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|revdone
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reverse done, send new */
end_comment

begin_decl_stmt
name|private
name|int
name|goahead
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* got initial status back */
end_comment

begin_decl_stmt
name|private
name|int
name|gotemt
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* got ^D ack from listener */
end_comment

begin_decl_stmt
name|private
name|int
name|sendend
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* send an ^D */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|reverse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|BannerFirst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|BannerLast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|VerboseLog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|fpid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* formatter pid */
end_comment

begin_decl_stmt
name|private
name|int
name|cpid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* listener pid */
end_comment

begin_decl_stmt
name|private
name|int
name|intrup
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interrupt flag */
end_comment

begin_decl_stmt
name|private
name|char
name|abortbuf
index|[]
init|=
block|{
name|PS_INT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^C abort */
end_comment

begin_decl_stmt
name|private
name|char
name|statusbuf
index|[]
init|=
block|{
name|PS_STATUS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^T status */
end_comment

begin_decl_stmt
name|private
name|char
name|eofbuf
index|[]
init|=
block|{
name|PS_EOF
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^D end of file */
end_comment

begin_decl_stmt
name|private
name|char
name|EOFerr
index|[]
init|=
literal|"%s: unexpected EOF from printer (%s)!\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global file descriptors (avoid stdio buffering!) */
end_comment

begin_decl_stmt
name|private
name|int
name|fdsend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to printer (from stdout) */
end_comment

begin_decl_stmt
name|private
name|int
name|fdlisten
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from printer (same tty line) */
end_comment

begin_decl_stmt
name|private
name|int
name|fdinput
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file to print (from stdin) */
end_comment

begin_decl_stmt
name|private
name|FILE
modifier|*
name|jobout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* special printer output log */
end_comment

begin_decl_stmt
name|private
name|int
name|flg
init|=
name|FREAD
operator||
name|FWRITE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioctl FLUSH arg */
end_comment

begin_function_decl
name|private
name|VOID
name|intinit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|VOID
name|intsend
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|VOID
name|intwait
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|VOID
name|salarm
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|VOID
name|walarm
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|VOID
name|falarm
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|VOID
name|reverseready
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|VOID
name|readynow
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|VOID
name|emtdead
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|VOID
name|emtdone
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|char
modifier|*
name|FindPattern
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SENDALARM
value|90
end_define

begin_define
define|#
directive|define
name|WAITALARM
value|30
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
decl_stmt|,
name|wc
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|mbp
decl_stmt|;
name|long
name|clock
decl_stmt|;
comment|/* for log timestamp */
name|char
name|magic
index|[
literal|11
index|]
decl_stmt|;
comment|/* first few bytes of stdin ?magic number and type */
name|int
name|reversing
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|streamin
decl_stmt|;
name|char
name|mybuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|wpid
decl_stmt|;
name|union
name|wait
name|status
decl_stmt|;
name|int
name|fdpipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|format
init|=
literal|0
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intinit
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|intinit
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|intinit
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|intinit
argument_list|)
decl_stmt|;
comment|/* parse command-line arguments */
comment|/* the argv (see header comments) comes from the spooler daemon */
comment|/* itself, so it should be canonical, but at least one 4.2-based */
comment|/* system uses -nlogin -hhost (insead of -n login -h host) so I */
comment|/* check for both */
name|BannerFirst
operator|=
operator|(
name|cp
operator|=
name|envget
argument_list|(
literal|"BANNERFIRST"
argument_list|)
operator|)
operator|!=
name|NULL
condition|?
name|atoi
argument_list|(
name|cp
argument_list|)
else|:
literal|0
expr_stmt|;
name|BannerLast
operator|=
operator|(
name|cp
operator|=
name|envget
argument_list|(
literal|"BANNERLAST"
argument_list|)
operator|)
operator|!=
name|NULL
condition|?
name|atoi
argument_list|(
name|cp
argument_list|)
else|:
literal|0
expr_stmt|;
name|VerboseLog
operator|=
operator|(
name|cp
operator|=
name|envget
argument_list|(
literal|"VERBOSELOG"
argument_list|)
operator|)
operator|!=
name|NULL
condition|?
name|atoi
argument_list|(
name|cp
argument_list|)
else|:
literal|1
expr_stmt|;
name|reverse
operator|=
name|envget
argument_list|(
literal|"REVERSE"
argument_list|)
expr_stmt|;
comment|/* name of the filter itself */
name|prog
operator|=
operator|*
name|argv
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|argv
condition|)
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'P'
case|:
comment|/* printer name */
name|argc
operator|--
expr_stmt|;
name|pname
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* user name */
name|argc
operator|--
expr_stmt|;
name|name
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* host */
name|argc
operator|--
expr_stmt|;
name|host
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* prog */
name|argc
operator|--
expr_stmt|;
name|prog
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* never reverse */
name|argc
operator|--
expr_stmt|;
name|reverse
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
comment|/* unknown */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown option: %s\n"
argument_list|,
name|prog
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|accountingfile
operator|=
operator|*
name|argv
expr_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"args: %s %s %s %s\n"
operator|,
name|prog
operator|,
name|host
operator|,
name|name
operator|,
name|accountingfile
operator|)
argument_list|)
expr_stmt|;
comment|/* do printer-specific options processing */
if|if
condition|(
name|VerboseLog
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s:%s %s start - %s"
argument_list|,
name|prog
argument_list|,
name|host
argument_list|,
name|name
argument_list|,
name|pname
argument_list|,
operator|(
name|VOIDC
name|time
argument_list|(
operator|&
name|clock
argument_list|)
operator|,
name|ctime
argument_list|(
operator|&
name|clock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
block|}
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: pid %d ppid %d\n"
operator|,
name|prog
operator|,
name|getpid
argument_list|()
operator|,
name|getppid
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: options BF %d BL %d VL %d R %s\n"
operator|,
name|prog
operator|,
name|BannerFirst
operator|,
name|BannerLast
operator|,
name|VerboseLog
operator|,
name|reverse
operator|==
name|NULL
condition|?
literal|"norev"
else|:
name|reverse
operator|)
argument_list|)
expr_stmt|;
comment|/* IMPORTANT: in the case of cascaded filters, */
comment|/* stdin may be a pipe! (and hence we cannot seek!) */
switch|switch
condition|(
name|cnt
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|magic
argument_list|,
literal|11
argument_list|)
condition|)
block|{
case|case
literal|11
case|:
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: magic number is %11.11s\n"
operator|,
name|prog
operator|,
name|magic
operator|)
argument_list|)
expr_stmt|;
name|streamin
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
literal|"%!PS-Adobe-"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|go_ahead
goto|;
default|default:
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
literal|"%!"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|reverse
operator|=
name|NULL
expr_stmt|;
goto|goto
name|go_ahead
goto|;
block|}
break|break;
case|case
literal|0
case|:
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: EOF reading magic number\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: empty file\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
goto|goto
name|badfile
goto|;
case|case
operator|-
literal|1
case|:
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: error reading magic number\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: error reading magic number\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|badfile
label|:
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
name|exit
argument_list|(
name|THROW_AWAY
argument_list|)
expr_stmt|;
block|}
comment|/*      * here is where you might test for other file type      * e.g., PRESS, imPRESS, DVI, Mac-generated, etc.      */
comment|/*      * final sanity check on the text file, to guard      * against arbitrary binary data      */
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|magic
index|[
name|cnt
index|]
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
name|magic
index|[
name|cnt
index|]
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
name|magic
index|[
name|cnt
index|]
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: spooled binary file rejected\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|mybuf
argument_list|,
literal|"%s/bogusmsg.ps"
argument_list|,
name|envget
argument_list|(
literal|"PSLIBDIR"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|streamin
operator|=
name|freopen
argument_list|(
name|mybuf
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
name|THROW_AWAY
argument_list|)
expr_stmt|;
name|format
operator|=
literal|1
expr_stmt|;
goto|goto
name|lastchance
goto|;
block|}
comment|/* exec dumb formatter to make a listing */
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"formatting\n"
operator|)
argument_list|)
expr_stmt|;
name|format
operator|=
literal|1
expr_stmt|;
name|VOIDC
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fdpipe
argument_list|)
operator|<
literal|0
condition|)
name|pexit2
argument_list|(
name|prog
argument_list|,
literal|"format pipe"
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fpid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|pexit2
argument_list|(
name|prog
argument_list|,
literal|"format fork"
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpid
operator|==
literal|0
condition|)
block|{
comment|/* child */
comment|/* set up child stdout to feed parent stdin */
if|if
condition|(
name|close
argument_list|(
literal|1
argument_list|)
operator|<
literal|0
operator|||
name|dup
argument_list|(
name|fdpipe
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|1
operator|||
name|close
argument_list|(
name|fdpipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|fdpipe
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|pexit2
argument_list|(
name|prog
argument_list|,
literal|"format child"
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|envget
argument_list|(
literal|"PSTEXT"
argument_list|)
argument_list|,
literal|"pstext"
argument_list|,
name|pname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pexit2
argument_list|(
name|prog
argument_list|,
literal|"format exec"
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
block|}
comment|/* parent continues, set up stdin to be pipe */
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|dup
argument_list|(
name|fdpipe
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
operator|||
name|close
argument_list|(
name|fdpipe
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|fdpipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|pexit2
argument_list|(
name|prog
argument_list|,
literal|"format parent"
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
comment|/* fall through to spooler with new stdin */
comment|/* can't seek here but we should be at the right place */
name|streamin
operator|=
name|fdopen
argument_list|(
literal|0
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|go_ahead
label|:
comment|/* do page reversal if specified */
if|if
condition|(
name|reversing
operator|=
name|reverse
operator|!=
name|NULL
condition|)
block|{
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"reversing\n"
operator|)
argument_list|)
expr_stmt|;
name|VOIDC
name|setjmp
argument_list|(
name|waitonreverse
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|revdone
condition|)
block|{
name|VOIDC
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|reverseready
argument_list|)
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fdpipe
argument_list|)
operator|<
literal|0
condition|)
name|pexit2
argument_list|(
name|prog
argument_list|,
literal|"reverse pipe"
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fpid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|pexit2
argument_list|(
name|prog
argument_list|,
literal|"reverse fork"
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpid
operator|==
literal|0
condition|)
block|{
comment|/* child */
comment|/* set up child stdout to feed parent stdin */
if|if
condition|(
name|close
argument_list|(
literal|1
argument_list|)
operator|<
literal|0
operator|||
name|dup
argument_list|(
name|fdpipe
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|1
operator|||
name|close
argument_list|(
name|fdpipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|fdpipe
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|pexit2
argument_list|(
name|prog
argument_list|,
literal|"reverse child"
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|reverse
argument_list|,
literal|"psrv"
argument_list|,
name|pname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pexit2
argument_list|(
name|prog
argument_list|,
literal|"reverse exec"
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
block|}
comment|/* parent continues */
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|dup
argument_list|(
name|fdpipe
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
operator|||
name|close
argument_list|(
name|fdpipe
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|fdpipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|pexit2
argument_list|(
name|prog
argument_list|,
literal|"reverse parent"
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
comment|/* fall through to spooler with new stdin */
name|streamin
operator|=
name|fdopen
argument_list|(
literal|0
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|revdone
condition|)
name|pause
argument_list|()
expr_stmt|;
block|}
name|VOIDC
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: reverse feeding\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
block|}
name|lastchance
label|:
comment|/*      * establish an input stream from the printer --      * the printcap entry specifies "rw" and we get      * invoked with stdout == the device, so we      * dup stdout, and reopen it for reading;      * this seems to work fine...      */
name|fdinput
operator|=
name|fileno
argument_list|(
name|streamin
argument_list|)
expr_stmt|;
comment|/* the file to print */
name|fdsend
operator|=
name|fileno
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* the printer (write) */
if|if
condition|(
operator|(
name|fdlisten
operator|=
name|dup
argument_list|(
name|fdsend
argument_list|)
operator|)
operator|<
literal|0
condition|)
comment|/* the printer (read) */
name|pexit
argument_list|(
name|prog
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
name|doactng
operator|=
name|name
operator|&&
name|accountingfile
operator|&&
name|access
argument_list|(
name|accountingfile
argument_list|,
name|W_OK
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/*      * get control of the "status" message file.      * we copy the current one to ".status" so we can restore it      * on exit (to be clean).      * Our ability to use this is publicized nowhere in the      * 4.2 lpr documentation, so things might go bad for us.      * We will use it to report that printer errors condition      * has been detected, and the printer should be checked.      * Unfortunately, this notice may persist through      * the end of the print job, but this is no big deal.      */
name|BackupStatus
argument_list|(
literal|".status"
argument_list|,
literal|"status"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|pexit
argument_list|(
name|prog
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpid
condition|)
block|{
comment|/* parent - sender */
name|VOIDC
name|setjmp
argument_list|(
name|sendint
argument_list|)
decl_stmt|;
if|if
condition|(
name|intrup
condition|)
block|{
comment|/* we only get here if there was an interrupt */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: abort (sending)\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
comment|/* flush and restart output to printer, 	     * send an abort (^C) request and wait for the job to end 	     */
if|if
condition|(
name|ioctl
argument_list|(
name|fdsend
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|flg
argument_list|)
operator|||
name|ioctl
argument_list|(
name|fdsend
argument_list|,
name|TIOCSTART
argument_list|,
operator|&
name|flg
argument_list|)
operator|||
operator|(
name|write
argument_list|(
name|fdsend
argument_list|,
name|abortbuf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|)
condition|)
block|{
name|RestoreStatus
argument_list|()
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
block|}
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: sent interrupt - waiting\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|intrup
operator|=
literal|0
expr_stmt|;
goto|goto
name|donefile
goto|;
comment|/* sorry ewd! */
block|}
name|VOIDC
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intsend
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|intsend
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|intsend
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|intsend
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|readynow
argument_list|)
decl_stmt|;
name|progress
operator|=
name|oldprogress
operator|=
literal|0
expr_stmt|;
comment|/* finite progress on sender */
name|getstatus
operator|=
name|FALSE
expr_stmt|;
comment|/* prime the pump for fun FALSE; */
name|VOIDC
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|salarm
argument_list|)
decl_stmt|;
comment|/* sending phase alarm */
name|VOIDC
name|alarm
argument_list|(
name|SENDALARM
argument_list|)
decl_stmt|;
comment|/* schedule an alarm/timeout */
comment|/* loop, trying to send a ^T to get printer status 	 * We will hang here (and post a message) if the printer 	 * is unreachable.  Eventually, we will succeed, the listener 	 * will see the status report, signal us, and we will proceed 	 */
name|cnt
operator|=
literal|1
expr_stmt|;
name|VOIDC
name|setjmp
argument_list|(
name|startstatus
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|goahead
condition|)
block|{
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: get start status\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|VOIDC
name|write
argument_list|(
name|fdsend
argument_list|,
name|statusbuf
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|pause
argument_list|()
expr_stmt|;
if|if
condition|(
name|goahead
condition|)
break|break;
comment|/* if we get here, we got an alarm */
name|ioctl
argument_list|(
name|fdsend
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|flg
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fdsend
argument_list|,
name|TIOCSTART
argument_list|,
operator|&
name|flg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|mybuf
argument_list|,
literal|"not responding for %d minutes"
argument_list|,
operator|(
name|cnt
operator|*
name|SENDALARM
operator|+
literal|30
operator|)
operator|/
literal|60
argument_list|)
expr_stmt|;
name|Status
argument_list|(
name|mybuf
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|SENDALARM
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|VOIDC
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|emtdead
argument_list|)
decl_stmt|;
comment|/* now EMTs mean printer died */
name|RestoreStatus
argument_list|()
expr_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: printer responding\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
comment|/* initial page accounting (BEFORE break page) */
if|if
condition|(
name|doactng
condition|)
block|{
name|sprintf
argument_list|(
name|mybuf
argument_list|,
name|getpages
argument_list|,
name|eofbuf
argument_list|)
expr_stmt|;
name|VOIDC
name|write
argument_list|(
name|fdsend
argument_list|,
name|mybuf
argument_list|,
name|strlen
argument_list|(
name|mybuf
argument_list|)
argument_list|)
decl_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: sent pagecount request\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|progress
operator|++
expr_stmt|;
comment|/* Sat Oct 31 17:51:45 PST 1987              * loop, waiting for the listener to signal initial pagecount is              * received.  The problem is with fast machines and short jobs;              * if we don't loop here, we may finish the job and send another              * CTRL-T before the initial pagecount ever came back.  The way              * the laserwriter behaves, this may result in a mix of pagecount              * data and status information like this:              * %%[ pagecount: %%[ status: busy; source: serial 25 ]%% 24418 ]%%              *              * That is really silly - Cuong              */
name|VOIDC
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intsend
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|intsend
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|intsend
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|intsend
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|readynow
argument_list|)
decl_stmt|;
name|progress
operator|=
name|oldprogress
operator|=
literal|0
expr_stmt|;
comment|/* finite progress on sender */
name|getstatus
operator|=
name|FALSE
expr_stmt|;
comment|/* prime the pump for fun FALSE; */
name|VOIDC
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|salarm
argument_list|)
decl_stmt|;
comment|/* sending phase alarm */
name|VOIDC
name|alarm
argument_list|(
name|SENDALARM
argument_list|)
decl_stmt|;
comment|/* schedule an alarm/timeout */
name|cnt
operator|=
literal|1
expr_stmt|;
name|goahead
operator|=
name|FALSE
expr_stmt|;
name|VOIDC
name|setjmp
argument_list|(
name|startstatus
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|goahead
condition|)
block|{
name|pause
argument_list|()
expr_stmt|;
if|if
condition|(
name|goahead
condition|)
break|break;
comment|/* if we get here, we got an alarm */
name|ioctl
argument_list|(
name|fdsend
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|flg
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fdsend
argument_list|,
name|TIOCSTART
argument_list|,
operator|&
name|flg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|mybuf
argument_list|,
literal|"not responding for %d minutes"
argument_list|,
operator|(
name|cnt
operator|*
name|SENDALARM
operator|+
literal|30
operator|)
operator|/
literal|60
argument_list|)
expr_stmt|;
name|Status
argument_list|(
name|mybuf
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|SENDALARM
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|VOIDC
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|emtdead
argument_list|)
decl_stmt|;
comment|/* now EMTs mean printer died */
name|RestoreStatus
argument_list|()
expr_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: sender received EMT (goahead) from listener\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* if (doactng) */
comment|/* initial break page ? */
if|if
condition|(
name|BannerFirst
condition|)
block|{
name|SendBanner
argument_list|()
expr_stmt|;
name|progress
operator|++
expr_stmt|;
block|}
comment|/* ship the magic number! */
if|if
condition|(
operator|!
name|format
operator|&&
operator|!
name|reversing
condition|)
block|{
name|VOIDC
name|write
argument_list|(
name|fdsend
argument_list|,
name|magic
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|progress
operator|++
expr_stmt|;
block|}
comment|/* now ship the rest of the file */
name|VOIDC
name|alarm
argument_list|(
name|SENDALARM
argument_list|)
decl_stmt|;
comment|/* schedule an alarm */
while|while
condition|(
operator|(
name|cnt
operator|=
name|read
argument_list|(
name|fdinput
argument_list|,
name|mybuf
argument_list|,
sizeof|sizeof
name|mybuf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* VOIDC alarm(SENDALARM);	/* we made progress, reset alarm */
if|if
condition|(
name|intrup
operator|==
name|TRUE
condition|)
break|break;
comment|/* get status every other time */
if|if
condition|(
name|getstatus
condition|)
block|{
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: get periodic status\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|VOIDC
name|write
argument_list|(
name|fdsend
argument_list|,
name|statusbuf
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|getstatus
operator|=
name|FALSE
expr_stmt|;
name|progress
operator|++
expr_stmt|;
block|}
name|mbp
operator|=
name|mybuf
expr_stmt|;
while|while
condition|(
operator|(
name|cnt
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|wc
operator|=
name|write
argument_list|(
name|fdsend
argument_list|,
name|mbp
argument_list|,
name|cnt
argument_list|)
operator|)
operator|!=
name|cnt
operator|)
condition|)
block|{
comment|/* this seems necessary but not sure why */
if|if
condition|(
name|wc
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: error writing to printer:\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|RestoreStatus
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|TRY_AGAIN
argument_list|)
expr_stmt|;
block|}
name|mbp
operator|+=
name|wc
expr_stmt|;
name|cnt
operator|-=
name|wc
expr_stmt|;
name|progress
operator|++
expr_stmt|;
block|}
name|progress
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: error reading from stdin: \n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|RestoreStatus
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|TRY_AGAIN
argument_list|)
expr_stmt|;
comment|/* kill the listener? */
block|}
comment|/* final break page ? */
if|if
condition|(
name|BannerLast
condition|)
block|{
name|SendBanner
argument_list|()
expr_stmt|;
name|progress
operator|++
expr_stmt|;
block|}
name|donefile
label|:
empty_stmt|;
name|sendend
operator|=
literal|1
expr_stmt|;
name|VOIDC
name|setjmp
argument_list|(
name|dwait
argument_list|)
decl_stmt|;
if|if
condition|(
name|sendend
operator|&&
operator|!
name|gotemt
condition|)
block|{
name|VOIDC
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|emtdone
argument_list|)
decl_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: done sending\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
comment|/* now send the PostScript EOF character */
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: sending PostScript EOF\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|VOIDC
name|write
argument_list|(
name|fdsend
argument_list|,
name|eofbuf
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|sendend
operator|=
literal|0
expr_stmt|;
name|progress
operator|++
expr_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intwait
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|intwait
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|intwait
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|intwait
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|walarm
argument_list|)
decl_stmt|;
name|VOIDC
name|alarm
argument_list|(
name|WAITALARM
argument_list|)
decl_stmt|;
name|getstatus
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* for very short jobs and very fast machines, 	 * we've experienced that the whole job is sent 	 * before the LaserWriter has a chance to update 	 * its status.  Hence we may get a false idle 	 * status if we immediately send the statusbuf. 	 * 	 * Keep in mind that the LaserWriter status response 	 * is asynchronous to the datastream. 	 */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* wait to sync with listener EMT signal 	 * to indicate it got an EOF from the printer 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|gotemt
condition|)
break|break;
if|if
condition|(
name|getstatus
condition|)
block|{
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: get final status\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|VOIDC
name|write
argument_list|(
name|fdsend
argument_list|,
name|statusbuf
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|getstatus
operator|=
name|FALSE
expr_stmt|;
block|}
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"waiting e%d i%d %d %d\n"
operator|,
name|gotemt
operator|,
name|intrup
operator|,
name|wpid
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
name|wpid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpid
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
comment|/* final page accounting */
if|if
condition|(
name|doactng
condition|)
block|{
name|sprintf
argument_list|(
name|mybuf
argument_list|,
name|getpages
argument_list|,
name|eofbuf
argument_list|)
expr_stmt|;
name|VOIDC
name|write
argument_list|(
name|fdsend
argument_list|,
name|mybuf
argument_list|,
name|strlen
argument_list|(
name|mybuf
argument_list|)
argument_list|)
decl_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: sent pagecount request\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|progress
operator|++
expr_stmt|;
block|}
comment|/* wait for listener to die */
name|VOIDC
name|setjmp
argument_list|(
name|dwait
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|wpid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|>
literal|0
condition|)
empty_stmt|;
name|VOIDC
name|alarm
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"w2: s%lo p%d = p%d\n"
operator|,
name|status
operator|,
name|wpid
operator|,
name|cpid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VerboseLog
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: end - %s"
argument_list|,
name|prog
argument_list|,
operator|(
name|time
argument_list|(
operator|&
name|clock
argument_list|)
operator|,
name|ctime
argument_list|(
operator|&
name|clock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
block|}
name|RestoreStatus
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* child - listener */
specifier|register
name|FILE
modifier|*
name|psin
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
name|char
name|pbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* buffer for pagecount info */
name|char
modifier|*
name|pb
decl_stmt|;
comment|/* pointer for above */
name|int
name|pc1
decl_stmt|,
name|pc2
decl_stmt|;
comment|/* page counts before and after job */
name|int
name|sc
decl_stmt|;
comment|/* pattern match count for sscanf */
name|int
name|ppid
decl_stmt|;
comment|/* parent process id */
name|VOIDC
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|ppid
operator|=
name|getppid
argument_list|()
expr_stmt|;
comment|/* get jobout from environment if there, otherwise use stderr */
if|if
condition|(
operator|(
name|cp
operator|=
name|envget
argument_list|(
literal|"JOBOUTPUT"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|jobout
operator|=
name|fopen
argument_list|(
name|cp
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|jobout
operator|=
name|stderr
expr_stmt|;
name|pc1
operator|=
name|pc2
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* bogus initial values */
if|if
condition|(
operator|(
name|psin
operator|=
name|fdopen
argument_list|(
name|fdlisten
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|RestoreStatus
argument_list|()
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
name|THROW_AWAY
argument_list|)
expr_stmt|;
block|}
comment|/* listen for first status (idle?) */
for|for
control|(
name|pb
operator|=
name|pbuf
init|;
condition|;
control|)
block|{
name|r
operator|=
name|getc
argument_list|(
name|psin
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|EOF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|EOFerr
argument_list|,
name|prog
argument_list|,
literal|"startup"
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
name|sleep
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* printer may be coming up */
continue|continue;
comment|/* RestoreStatus(); */
comment|/* exit(TRY_AGAIN); */
block|}
if|if
condition|(
operator|(
name|r
operator|&
literal|0377
operator|)
operator|==
literal|'\n'
condition|)
break|break;
operator|*
name|pb
operator|++
operator|=
name|r
expr_stmt|;
block|}
operator|*
name|pb
operator|=
literal|0
expr_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: initial status - %s\n"
operator|,
name|prog
operator|,
name|pbuf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pbuf
argument_list|,
literal|"%%[ status: idle ]%%\r"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: initial status - %s\n"
argument_list|,
name|prog
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
block|}
comment|/* flush input state and signal sender that we heard something */
name|ioctl
argument_list|(
name|fdlisten
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|flg
argument_list|)
expr_stmt|;
name|VOIDC
name|kill
argument_list|(
name|ppid
argument_list|,
name|SIGEMT
argument_list|)
decl_stmt|;
comment|/* listen for first pagecount */
if|if
condition|(
name|doactng
condition|)
block|{
name|pb
operator|=
name|pbuf
expr_stmt|;
operator|*
name|pb
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|r
operator|=
name|getc
argument_list|(
name|psin
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|EOF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|EOFerr
argument_list|,
name|prog
argument_list|,
literal|"accounting1"
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
name|RestoreStatus
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* give interface a chance */
name|exit
argument_list|(
name|TRY_AGAIN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r
operator|&
literal|0377
operator|)
operator|==
name|PS_EOF
condition|)
break|break;
operator|*
name|pb
operator|++
operator|=
name|r
expr_stmt|;
block|}
operator|*
name|pb
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|pb
operator|=
name|FindPattern
argument_list|(
name|pb
argument_list|,
name|pbuf
argument_list|,
literal|"%%[ pagecount: "
argument_list|)
condition|)
block|{
name|sc
operator|=
name|sscanf
argument_list|(
name|pb
argument_list|,
literal|"%%%%[ pagecount: %d ]%%%%\r"
argument_list|,
operator|&
name|pc1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|!=
literal|1
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: accounting error 1 (%s)\n"
argument_list|,
name|prog
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
block|}
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: accounting 1 (%s)\n"
operator|,
name|prog
operator|,
name|pbuf
operator|)
argument_list|)
expr_stmt|;
comment|/* flush input state and signal sender that we heard something */
name|ioctl
argument_list|(
name|fdlisten
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|flg
argument_list|)
expr_stmt|;
name|VOIDC
name|kill
argument_list|(
name|ppid
argument_list|,
name|SIGEMT
argument_list|)
decl_stmt|;
comment|/* 	    Sun Sep 20 18:32:28 PDT 1987 	    The previous bug was that it was assumed the ctrl-d comes 	    before the final pagecount.  This doesn't happen, and the 	    listener waits forever after a ctrl-d for a pagecount. 	    The fix is to clear out the pbuf[] buffer, then check for it 	    when we get to looking for the final pagecount.  If it is 	    non-empty, we know we *already* read the final pagecount 	    *before* the ctrl-d, and use it, without waiting for 	    anything to come back from the printer. 	*/
name|pbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* listen for the user job */
while|while
condition|(
name|TRUE
condition|)
block|{
name|r
operator|=
name|getc
argument_list|(
name|psin
argument_list|)
expr_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: listener got character \\%o '%c'\n"
operator|,
name|prog
operator|,
name|r
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
literal|0377
operator|)
operator|==
name|PS_EOF
condition|)
break|break;
if|if
condition|(
name|r
operator|==
name|EOF
condition|)
block|{
name|VOIDC
name|fclose
argument_list|(
name|psin
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|EOFerr
argument_list|,
name|prog
argument_list|,
literal|"job"
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
name|RestoreStatus
argument_list|()
expr_stmt|;
name|VOIDC
name|kill
argument_list|(
name|ppid
argument_list|,
name|SIGEMT
argument_list|)
decl_stmt|;
name|exit
argument_list|(
name|THROW_AWAY
argument_list|)
expr_stmt|;
block|}
comment|/*     Sun Sep 20 18:37:01 PDT 1987     GotChar() takes an addition argument: the pointer to the     pbuf[] buffer, and fills it with the final pagecount     information if that is received from the printer. */
name|GotChar
argument_list|(
name|r
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
block|}
comment|/* let sender know we saw the end of the job */
comment|/* sync - wait for sender to restart us */
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: listener saw eof, signaling\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|VOIDC
name|kill
argument_list|(
name|ppid
argument_list|,
name|SIGEMT
argument_list|)
decl_stmt|;
comment|/* now get final page count */
if|if
condition|(
name|doactng
condition|)
block|{
comment|/*     Sun Sep 20 18:48:35 PDT 1987     We attempt to wait for the final pagecount only if it has *not*     been sent by the printer.  It is the case that the final pagecount     is sent before the ctrl-d above, hence if we wait, it'll be forever.     Final pagecount information 'prematurely' received has already     been stored in pbuf[] iff pbuf[0] is non-null. */
if|if
condition|(
name|pbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: waiting for pagecount\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|pb
operator|=
name|pbuf
expr_stmt|;
operator|*
name|pb
operator|=
literal|'\0'
expr_stmt|;
comment|/* ignore the previous pagecount */
while|while
condition|(
name|TRUE
condition|)
block|{
name|r
operator|=
name|getc
argument_list|(
name|psin
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|EOF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|EOFerr
argument_list|,
name|prog
argument_list|,
literal|"accounting2"
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
name|RestoreStatus
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|THROW_AWAY
argument_list|)
expr_stmt|;
comment|/* what else to do? */
block|}
if|if
condition|(
operator|(
name|r
operator|&
literal|0377
operator|)
operator|==
name|PS_EOF
condition|)
break|break;
operator|*
name|pb
operator|++
operator|=
name|r
expr_stmt|;
block|}
operator|*
name|pb
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|pb
operator|=
name|pbuf
operator|+
name|strlen
argument_list|(
name|pbuf
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: accounting 2 (%s)\n"
operator|,
name|prog
operator|,
name|pbuf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|=
name|FindPattern
argument_list|(
name|pb
argument_list|,
name|pbuf
argument_list|,
literal|"%%[ pagecount: "
argument_list|)
condition|)
block|{
name|sc
operator|=
name|sscanf
argument_list|(
name|pb
argument_list|,
literal|"%%%%[ pagecount: %d ]%%%%\r"
argument_list|,
operator|&
name|pc2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|!=
literal|1
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: accounting error 2 (%s)\n"
argument_list|,
name|prog
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pc2
operator|<
name|pc1
operator|)
operator|||
operator|(
name|pc1
operator|<
literal|0
operator|)
operator|||
operator|(
name|pc2
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: accounting error 3 %d %d\n"
argument_list|,
name|prog
argument_list|,
name|pc1
argument_list|,
name|pc2
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
block|}
elseif|else
if|if
condition|(
name|freopen
argument_list|(
name|accountingfile
argument_list|,
literal|"a"
argument_list|,
name|stdout
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%7.2f\t%s:%s\n"
argument_list|,
call|(
name|float
call|)
argument_list|(
name|pc2
operator|-
name|pc1
argument_list|)
argument_list|,
name|host
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|VOIDC
name|fclose
argument_list|(
name|stdout
argument_list|)
decl_stmt|;
comment|/*     Sun Sep 20 18:55:32 PDT 1987     File append failure report added for future use. */
block|}
else|else
block|{
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: can't append accounting file\n"
operator|,
name|prog
operator|)
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|accountingfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* all done -- let sender know */
comment|/* no need to close files */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* send the file ".banner" */
end_comment

begin_function
name|private
name|SendBanner
parameter_list|()
block|{
specifier|register
name|int
name|banner
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|banner
operator|=
name|open
argument_list|(
literal|".banner"
argument_list|,
name|O_RDONLY
operator||
name|O_NDELAY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
while|while
condition|(
operator|(
name|cnt
operator|=
name|read
argument_list|(
name|banner
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|VOIDC
name|write
argument_list|(
name|fdsend
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
decl_stmt|;
name|VOIDC
name|close
argument_list|(
name|banner
argument_list|)
decl_stmt|;
name|VOIDC
name|unlink
argument_list|(
literal|".banner"
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/* search backwards from p in start for patt */
end_comment

begin_function
name|private
name|char
modifier|*
name|FindPattern
parameter_list|(
name|p
parameter_list|,
name|start
parameter_list|,
name|patt
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|patt
decl_stmt|;
block|{
name|int
name|patlen
decl_stmt|;
name|patlen
operator|=
name|strlen
argument_list|(
name|patt
argument_list|)
expr_stmt|;
name|p
operator|-=
name|patlen
expr_stmt|;
for|for
control|(
init|;
name|p
operator|>=
name|start
condition|;
name|p
operator|--
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|patt
argument_list|,
name|patlen
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|private
name|GotChar
parameter_list|(
name|c
parameter_list|,
name|pbuf
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|pbuf
decl_stmt|;
block|{
specifier|static
name|char
name|linebuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|cp
init|=
name|linebuf
decl_stmt|;
specifier|static
enum|enum
name|State
block|{
name|normal
block|,
name|onep
block|,
name|twop
block|,
name|inmessage
block|,
name|close1
block|,
name|close2
block|,
name|close3
block|,
name|close4
block|}
name|st
init|=
name|normal
enum|;
name|char
modifier|*
name|match
decl_stmt|,
modifier|*
name|last
decl_stmt|;
switch|switch
condition|(
name|st
condition|)
block|{
case|case
name|normal
case|:
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|st
operator|=
name|onep
expr_stmt|;
name|cp
operator|=
name|linebuf
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|jobout
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|jobout
argument_list|)
decl_stmt|;
break|break;
case|case
name|onep
case|:
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|st
operator|=
name|twop
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
literal|'%'
argument_list|,
name|jobout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|jobout
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|jobout
argument_list|)
decl_stmt|;
name|st
operator|=
name|normal
expr_stmt|;
break|break;
case|case
name|twop
case|:
if|if
condition|(
name|c
operator|==
literal|'\['
condition|)
block|{
name|st
operator|=
name|inmessage
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\%'
condition|)
block|{
name|putc
argument_list|(
literal|'%'
argument_list|,
name|jobout
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|jobout
argument_list|)
decl_stmt|;
comment|/* don't do anything to cp */
break|break;
block|}
name|putc
argument_list|(
literal|'%'
argument_list|,
name|jobout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'%'
argument_list|,
name|jobout
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|jobout
argument_list|)
decl_stmt|;
name|st
operator|=
name|normal
expr_stmt|;
break|break;
case|case
name|inmessage
case|:
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\]'
condition|)
name|st
operator|=
name|close1
expr_stmt|;
break|break;
case|case
name|close1
case|:
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'%'
case|:
name|st
operator|=
name|close2
expr_stmt|;
break|break;
case|case
literal|'\]'
case|:
name|st
operator|=
name|close1
expr_stmt|;
break|break;
default|default:
name|st
operator|=
name|inmessage
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|close2
case|:
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'%'
case|:
name|st
operator|=
name|close3
expr_stmt|;
break|break;
case|case
literal|'\]'
case|:
name|st
operator|=
name|close1
expr_stmt|;
break|break;
default|default:
name|st
operator|=
name|inmessage
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|close3
case|:
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\r'
case|:
name|st
operator|=
name|close4
expr_stmt|;
break|break;
case|case
literal|'\]'
case|:
name|st
operator|=
name|close1
expr_stmt|;
break|break;
default|default:
name|st
operator|=
name|inmessage
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|close4
case|:
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|st
operator|=
name|normal
expr_stmt|;
break|break;
case|case
literal|'\]'
case|:
name|st
operator|=
name|close1
expr_stmt|;
break|break;
default|default:
name|st
operator|=
name|inmessage
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|st
operator|==
name|normal
condition|)
block|{
comment|/* parse complete message */
name|last
operator|=
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|">>%s"
operator|,
name|linebuf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|=
name|FindPattern
argument_list|(
name|cp
argument_list|,
name|linebuf
argument_list|,
literal|" PrinterError: "
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|match
operator|-
literal|1
operator|)
operator|!=
literal|':'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
operator|*
operator|(
name|last
operator|-
literal|6
operator|)
operator|=
literal|0
expr_stmt|;
name|Status
argument_list|(
name|match
operator|+
literal|15
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|index
argument_list|(
name|match
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
operator|*
name|last
operator|=
literal|0
expr_stmt|;
name|Status
argument_list|(
name|match
operator|+
literal|15
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|match
operator|=
name|FindPattern
argument_list|(
name|cp
argument_list|,
name|linebuf
argument_list|,
literal|" status: "
argument_list|)
condition|)
block|{
name|match
operator|+=
literal|9
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|match
argument_list|,
literal|"idle"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* we are hopelessly lost, get everyone to quit */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ERROR: printer is idle, giving up!\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
name|VOIDC
name|kill
argument_list|(
name|getppid
argument_list|()
argument_list|,
name|SIGKILL
argument_list|)
decl_stmt|;
comment|/* will this work */
name|exit
argument_list|(
name|THROW_AWAY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* one of: busy, waiting, printing, initializing */
comment|/* clear status message */
name|RestoreStatus
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*     Sun Sep 20 18:39:40 PDT 1987     Additional else necessary: if we get the final pagecount     information here from the printer, store it in the given     array pbuf[]. */
elseif|else
if|if
condition|(
name|match
operator|=
name|FindPattern
argument_list|(
name|cp
argument_list|,
name|linebuf
argument_list|,
literal|"%%[ pagecount: "
argument_list|)
condition|)
block|{
comment|/* fill pbuf */
name|strcpy
argument_list|(
name|pbuf
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: 'premature' final pagecount read = '%s'\n"
operator|,
name|prog
operator|,
name|pbuf
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* message not for us */
name|fprintf
argument_list|(
name|jobout
argument_list|,
literal|"%s"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|jobout
argument_list|)
decl_stmt|;
name|st
operator|=
name|normal
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad case;\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* backup "status" message file in ".status",  * in case there is a PrinterError  */
end_comment

begin_function
name|private
name|BackupStatus
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
name|char
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|VOIDC
name|umask
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|fd1
operator|=
name|open
argument_list|(
name|file1
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0664
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd1
operator|<
literal|0
operator|)
operator|||
operator|(
name|flock
argument_list|(
name|fd1
argument_list|,
name|LOCK_EX
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|VOIDC
name|unlink
parameter_list|(
name|file1
parameter_list|)
function_decl|;
name|VOIDC
name|flock
parameter_list|(
name|fd1
parameter_list|,
name|LOCK_UN
parameter_list|)
function_decl|;
name|VOIDC
name|close
parameter_list|(
name|fd1
parameter_list|)
function_decl|;
name|fd1
operator|=
name|open
argument_list|(
name|file1
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0664
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd1
operator|<
literal|0
operator|)
operator|||
operator|(
name|flock
argument_list|(
name|fd1
argument_list|,
name|LOCK_EX
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: writing %s:\n"
argument_list|,
name|prog
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|VOIDC
name|close
parameter_list|(
name|fd1
parameter_list|)
function_decl|;
return|return;
block|}
name|VOIDC
name|ftruncate
argument_list|(
name|fd1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fd2
operator|=
name|open
argument_list|(
name|file2
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: error reading %s:\n"
argument_list|,
name|prog
argument_list|,
name|file2
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|VOIDC
name|close
parameter_list|(
name|fd1
parameter_list|)
function_decl|;
return|return;
block|}
name|cnt
operator|=
name|read
argument_list|(
name|fd2
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|VOIDC
name|write
parameter_list|(
name|fd1
parameter_list|,
name|buf
parameter_list|,
name|cnt
parameter_list|)
function_decl|;
name|VOIDC
name|flock
parameter_list|(
name|fd1
parameter_list|,
name|LOCK_UN
parameter_list|)
function_decl|;
name|VOIDC
name|close
parameter_list|(
name|fd1
parameter_list|)
function_decl|;
name|VOIDC
name|close
parameter_list|(
name|fd2
parameter_list|)
function_decl|;
block|}
end_block

begin_comment
comment|/* restore the "status" message from the backed-up ".status" copy */
end_comment

begin_function
name|private
name|RestoreStatus
parameter_list|()
block|{
name|BackupStatus
argument_list|(
literal|"status"
argument_list|,
literal|".status"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* report PrinterError via "status" message file */
end_comment

begin_function
name|private
name|Status
parameter_list|(
name|msg
parameter_list|)
specifier|register
name|char
modifier|*
name|msg
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|char
name|msgbuf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"status"
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0664
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
name|VOIDC
name|ftruncate
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Printer Error: may need attention! (%s)\n\0"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|VOIDC
name|write
argument_list|(
name|fd
argument_list|,
name|msgbuf
argument_list|,
name|strlen
argument_list|(
name|msgbuf
argument_list|)
argument_list|)
decl_stmt|;
name|VOIDC
name|close
argument_list|(
name|fd
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/* sending phase alarm handler for sender */
end_comment

begin_function
name|private
name|VOID
name|salarm
parameter_list|()
block|{
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: AS %d %d %d\n"
operator|,
name|prog
operator|,
name|oldprogress
operator|,
name|progress
operator|,
name|getstatus
operator|)
argument_list|)
expr_stmt|;
comment|/* if progress != oldprogress, we made some progress (sent something)      * else, we had two alarms without sending anything...      * It may be that a PrinterError has us stopped, or we are computing      * for a long time (forever?) -- printer jobtimeout may help here      * in any case, all we do is set the flag to get status...      * this will help us clear printererror notification      */
name|oldprogress
operator|=
name|progress
expr_stmt|;
name|getstatus
operator|=
name|TRUE
expr_stmt|;
comment|/* reset the alarm and return */
name|VOIDC
name|alarm
argument_list|(
name|SENDALARM
argument_list|)
decl_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* waiting phase alarm handler for sender */
end_comment

begin_function
name|private
name|VOID
name|walarm
parameter_list|()
block|{
specifier|static
name|int
name|acount
init|=
literal|0
decl_stmt|;
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: WA %d %d %d %d\n"
operator|,
name|prog
operator|,
name|acount
operator|,
name|oldprogress
operator|,
name|progress
operator|,
name|getstatus
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldprogress
operator|!=
name|progress
operator|)
operator|||
operator|(
name|acount
operator|==
literal|4
operator|)
condition|)
block|{
name|getstatus
operator|=
name|TRUE
expr_stmt|;
name|acount
operator|=
literal|0
expr_stmt|;
name|oldprogress
operator|=
name|progress
expr_stmt|;
block|}
else|else
name|acount
operator|++
expr_stmt|;
comment|/* reset alarm */
name|VOIDC
name|alarm
argument_list|(
name|WAITALARM
argument_list|)
decl_stmt|;
comment|/* return to wait loop */
name|longjmp
argument_list|(
name|dwait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* final phase alarm handler for sender */
end_comment

begin_function
name|private
name|VOID
name|falarm
parameter_list|()
block|{
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: FA %d %d %d\n"
operator|,
name|prog
operator|,
name|oldprogress
operator|,
name|progress
operator|,
name|getstatus
operator|)
argument_list|)
expr_stmt|;
comment|/* no reason to count progress, just get status */
if|if
condition|(
operator|!
name|intrup
condition|)
block|{
name|VOIDC
name|write
argument_list|(
name|fdsend
argument_list|,
name|statusbuf
argument_list|,
literal|1
argument_list|)
decl_stmt|;
block|}
name|getstatus
operator|=
name|FALSE
expr_stmt|;
comment|/* reset alarm */
name|VOIDC
name|alarm
argument_list|(
name|WAITALARM
argument_list|)
decl_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* initial interrupt handler - before communications begin, so  * nothing to be sent to printer  */
end_comment

begin_function
name|private
name|VOID
name|intinit
parameter_list|()
block|{
name|long
name|clock
decl_stmt|;
comment|/* get rid of banner file */
name|VOIDC
name|unlink
argument_list|(
literal|".banner"
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: abort (during setup)\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
comment|/* these next two may be too cautious */
name|VOIDC
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGINT
argument_list|)
decl_stmt|;
while|while
condition|(
name|wait
argument_list|(
operator|(
expr|union
name|wait
operator|*
operator|)
literal|0
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|VerboseLog
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: end - %s"
argument_list|,
name|prog
argument_list|,
operator|(
name|time
argument_list|(
operator|&
name|clock
argument_list|)
operator|,
name|ctime
argument_list|(
operator|&
name|clock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
block|}
name|exit
argument_list|(
name|THROW_AWAY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* interrupt during sending phase to sender process */
end_comment

begin_function
name|private
name|VOID
name|intsend
parameter_list|()
block|{
comment|/* set flag */
name|intrup
operator|=
name|TRUE
expr_stmt|;
name|longjmp
argument_list|(
name|sendint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* interrupt during waiting phase to sender process */
end_comment

begin_function
name|private
name|VOID
name|intwait
parameter_list|()
block|{
name|intrup
operator|=
name|TRUE
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: abort (waiting)\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|VOIDC
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fdsend
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|flg
argument_list|)
operator|||
name|ioctl
argument_list|(
name|fdsend
argument_list|,
name|TIOCSTART
argument_list|,
operator|&
name|flg
argument_list|)
operator|||
operator|(
name|write
argument_list|(
name|fdsend
argument_list|,
name|abortbuf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: error in ioctl(fdsend):\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|prog
argument_list|)
expr_stmt|;
block|}
comment|/* VOIDC alarm(2); /* force an alarm soon to get us out of wait! ? */
name|longjmp
argument_list|(
name|dwait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EMT for reverse filter, avoid printer timeout at the expense  * of performance (sigh)  */
end_comment

begin_function
name|private
name|VOID
name|reverseready
parameter_list|()
block|{
name|revdone
operator|=
name|TRUE
expr_stmt|;
name|longjmp
argument_list|(
name|waitonreverse
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EMT on startup to sender -- signalled by listener after first status  * message received  */
end_comment

begin_function
name|private
name|VOID
name|readynow
parameter_list|()
block|{
name|goahead
operator|=
name|TRUE
expr_stmt|;
name|longjmp
argument_list|(
name|startstatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EMT on sending phase, hard EOF printer died! */
end_comment

begin_function
name|private
name|VOID
name|emtdead
parameter_list|()
block|{
name|VOIDC
name|alarm
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|exit
argument_list|(
name|THROW_AWAY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EMT during waiting phase -- listener saw an EOF (^D) from printer */
end_comment

begin_function
name|private
name|VOID
name|emtdone
parameter_list|()
block|{
name|VOIDC
name|alarm
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|gotemt
operator|=
name|TRUE
expr_stmt|;
name|longjmp
argument_list|(
name|dwait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

