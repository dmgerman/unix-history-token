begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)n8.c	2.1 (CWI) 85/07/18"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"tdef.h"
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|"ext.h"
end_include

begin_define
define|#
directive|define
name|HY_BIT
value|0200
end_define

begin_comment
comment|/* stuff in here only works for ascii */
end_comment

begin_comment
comment|/*  * troff8.c  *   * hyphenation  */
end_comment

begin_decl_stmt
name|char
name|hbuf
index|[
name|NHEX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|nexth
init|=
name|hbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tchar
modifier|*
name|hyend
decl_stmt|;
end_decl_stmt

begin_macro
name|hyphen
argument_list|(
argument|wp
argument_list|)
end_macro

begin_decl_stmt
name|tchar
modifier|*
name|wp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|j
expr_stmt|;
specifier|register
name|tchar
modifier|*
name|i
decl_stmt|;
name|i
operator|=
name|wp
expr_stmt|;
while|while
condition|(
name|punct
argument_list|(
name|cbits
argument_list|(
operator|*
name|i
operator|++
argument_list|)
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|alph
argument_list|(
name|cbits
argument_list|(
operator|*
operator|--
name|i
argument_list|)
argument_list|)
condition|)
return|return;
name|wdstart
operator|=
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|alph
argument_list|(
name|cbits
argument_list|(
operator|*
name|i
operator|++
argument_list|)
argument_list|)
condition|)
empty_stmt|;
name|hyend
operator|=
name|wdend
operator|=
operator|--
name|i
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|punct
argument_list|(
name|cbits
argument_list|(
operator|*
name|i
operator|++
argument_list|)
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|*
operator|--
name|i
condition|)
return|return;
if|if
condition|(
operator|(
name|wdend
operator|-
name|wdstart
operator|-
literal|4
operator|)
operator|<
literal|0
condition|)
return|return;
name|hyp
operator|=
name|hyptr
expr_stmt|;
operator|*
name|hyp
operator|=
literal|0
expr_stmt|;
name|hyoff
operator|=
literal|2
expr_stmt|;
comment|/* 	if (!exword()&& !suffix()) 		digram(); */
if|if
condition|(
operator|!
name|exword
argument_list|()
condition|)
block|{
if|if
condition|(
name|hyalg
operator|==
name|ORIGINAL
operator|&&
operator|!
name|suffix
argument_list|()
condition|)
name|digram
argument_list|()
expr_stmt|;
if|if
condition|(
name|hyalg
operator|==
name|DUTCH
condition|)
name|split
argument_list|(
name|wdstart
argument_list|,
name|wdend
argument_list|)
expr_stmt|;
block|}
operator|*
name|hyp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|hyptr
condition|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
condition|;
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|hyp
operator|=
name|hyptr
operator|+
literal|1
init|;
operator|*
name|hyp
operator|!=
literal|0
condition|;
name|hyp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|hyp
operator|-
literal|1
operator|)
operator|>
operator|*
name|hyp
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|i
operator|=
operator|*
name|hyp
expr_stmt|;
operator|*
name|hyp
operator|=
operator|*
operator|(
name|hyp
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|hyp
operator|-
literal|1
operator|)
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|punct
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|i
operator|||
name|alph
argument_list|(
name|i
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|alph
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|i
operator|>=
literal|'a'
operator|&&
name|i
operator|<=
literal|'z'
operator|||
name|i
operator|>=
literal|'A'
operator|&&
name|i
operator|<=
literal|'Z'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * set the hyphenation algorithm  *  * jna  */
end_comment

begin_macro
name|caseha
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
condition|)
name|i
operator|=
name|hyalg1
expr_stmt|;
else|else
block|{
name|noscale
operator|++
expr_stmt|;
name|noscale
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|max
argument_list|(
name|atoi
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonumb
condition|)
return|return;
if|if
condition|(
name|i
operator|>
name|MAXDIALECTS
condition|)
block|{
name|errprint
argument_list|(
literal|"Unknown dialect %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|hyalg1
operator|=
name|hyalg
expr_stmt|;
name|hyalg
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|hyalg
operator|==
name|DUTCH
condition|)
name|thresh
operator|=
name|DUTCH_THRESH
expr_stmt|;
block|}
end_block

begin_macro
name|caseht
argument_list|()
end_macro

begin_block
block|{
switch|switch
condition|(
name|hyalg
condition|)
block|{
case|case
name|ORIGINAL
case|:
name|thresh
operator|=
name|THRESH
expr_stmt|;
break|break;
case|case
name|DUTCH
case|:
name|thresh
operator|=
name|DUTCH_THRESH
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|skip
argument_list|()
condition|)
return|return;
name|noscale
operator|++
expr_stmt|;
if|if
condition|(
name|hyalg
operator|==
name|DUTCH
condition|)
name|thresh
operator|=
name|max
argument_list|(
name|atoi
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|thresh
operator|=
name|atoi
argument_list|()
expr_stmt|;
name|noscale
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|casehw
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|k
expr_stmt|;
specifier|register
name|char
modifier|*
name|j
decl_stmt|;
name|tchar
name|t
decl_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|skip
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|nexth
operator|)
operator|>=
operator|(
name|hbuf
operator|+
name|NHEX
operator|-
literal|2
operator|)
condition|)
goto|goto
name|full
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ismot
argument_list|(
name|t
operator|=
name|getch
argument_list|()
argument_list|)
condition|)
continue|continue;
name|i
operator|=
name|cbits
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|' '
operator|||
name|i
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|j
operator|++
operator|=
literal|0
expr_stmt|;
name|nexth
operator|=
name|j
expr_stmt|;
operator|*
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|' '
condition|)
break|break;
else|else
return|return;
block|}
if|if
condition|(
name|i
operator|==
literal|'-'
condition|)
block|{
name|k
operator|=
name|HY_BIT
expr_stmt|;
continue|continue;
block|}
operator|*
name|j
operator|++
operator|=
name|maplow
argument_list|(
name|i
argument_list|)
operator||
name|k
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|>=
operator|(
name|hbuf
operator|+
name|NHEX
operator|-
literal|2
operator|)
condition|)
goto|goto
name|full
goto|;
block|}
block|}
return|return;
name|full
label|:
name|errprint
argument_list|(
literal|"exception word list full."
argument_list|)
expr_stmt|;
operator|*
name|nexth
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|exword
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|tchar
modifier|*
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
name|e
operator|=
name|hbuf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|save
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|*
name|e
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|w
operator|=
name|wdstart
expr_stmt|;
while|while
condition|(
operator|*
name|e
operator|&&
name|w
operator|<=
name|hyend
operator|&&
operator|(
operator|*
name|e
operator|&
literal|0177
operator|)
operator|==
name|maplow
argument_list|(
name|cbits
argument_list|(
operator|*
name|w
argument_list|)
argument_list|)
condition|)
block|{
name|e
operator|++
expr_stmt|;
name|w
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|e
condition|)
block|{
if|if
condition|(
name|w
operator|-
literal|1
operator|==
name|hyend
operator|||
operator|(
name|hyalg
operator|==
name|ORIGINAL
comment|/* s-extension only in original */
operator|&&
operator|(
name|w
operator|==
name|wdend
operator|&&
name|maplow
argument_list|(
name|cbits
argument_list|(
operator|*
name|w
argument_list|)
argument_list|)
operator|==
literal|'s'
operator|)
operator|)
condition|)
block|{
name|w
operator|=
name|wdstart
expr_stmt|;
for|for
control|(
name|e
operator|=
name|save
init|;
operator|*
name|e
condition|;
name|e
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|e
operator|&
name|HY_BIT
condition|)
operator|*
name|hyp
operator|++
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|hyp
operator|>
operator|(
name|hyptr
operator|+
name|NHYP
operator|-
literal|1
operator|)
condition|)
name|hyp
operator|=
name|hyptr
operator|+
name|NHYP
operator|-
literal|1
expr_stmt|;
name|w
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|e
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
else|else
while|while
condition|(
operator|*
name|e
operator|++
condition|)
empty_stmt|;
block|}
block|}
end_block

begin_macro
name|suffix
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|tchar
modifier|*
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s0
decl_stmt|;
name|tchar
name|i
decl_stmt|;
specifier|extern
name|char
modifier|*
name|suftab
index|[]
decl_stmt|;
specifier|extern
name|tchar
modifier|*
name|chkvow
parameter_list|()
function_decl|;
name|again
label|:
if|if
condition|(
operator|!
name|alph
argument_list|(
name|cbits
argument_list|(
name|i
operator|=
name|cbits
argument_list|(
operator|*
name|hyend
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|i
operator|<
literal|'a'
condition|)
name|i
operator|-=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
operator|(
name|s0
operator|=
name|suftab
index|[
name|i
operator|-
literal|'a'
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
operator|*
name|s0
operator|&
literal|017
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
name|s0
operator|+
name|i
operator|-
literal|1
expr_stmt|;
name|w
operator|=
name|hyend
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|>
name|s0
operator|&&
name|w
operator|>=
name|wdstart
operator|&&
operator|(
operator|*
name|s
operator|&
literal|0177
operator|)
operator|==
name|maplow
argument_list|(
name|cbits
argument_list|(
operator|*
name|w
argument_list|)
argument_list|)
condition|)
block|{
name|s
operator|--
expr_stmt|;
name|w
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|s0
condition|)
break|break;
name|s0
operator|+=
name|i
expr_stmt|;
block|}
name|s
operator|=
name|s0
operator|+
name|i
operator|-
literal|1
expr_stmt|;
name|w
operator|=
name|hyend
expr_stmt|;
if|if
condition|(
operator|*
name|s0
operator|&
name|HY_BIT
condition|)
goto|goto
name|mark
goto|;
while|while
condition|(
name|s
operator|>
name|s0
condition|)
block|{
name|w
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|--
operator|&
name|HY_BIT
condition|)
block|{
name|mark
label|:
name|hyend
operator|=
name|w
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s0
operator|&
literal|0100
condition|)
continue|continue;
if|if
condition|(
operator|!
name|chkvow
argument_list|(
name|w
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|hyp
operator|++
operator|=
name|w
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|s0
operator|&
literal|040
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|exword
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|again
goto|;
block|}
end_block

begin_expr_stmt
name|maplow
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|isupper
argument_list|(
name|i
argument_list|)
condition|)
name|i
operator|=
name|tolower
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|vowel
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|maplow
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'e'
case|:
case|case
literal|'i'
case|:
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
case|case
literal|'y'
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_function
name|tchar
modifier|*
name|chkvow
parameter_list|(
name|w
parameter_list|)
name|tchar
modifier|*
name|w
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|w
operator|>=
name|wdstart
condition|)
if|if
condition|(
name|vowel
argument_list|(
name|cbits
argument_list|(
operator|*
name|w
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|w
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|digram
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|tchar
modifier|*
name|w
decl_stmt|;
specifier|register
name|val
expr_stmt|;
name|tchar
modifier|*
name|nhyend
decl_stmt|,
modifier|*
name|maxw
decl_stmt|;
name|int
name|maxval
decl_stmt|;
specifier|extern
name|char
name|bxh
index|[
literal|26
index|]
index|[
literal|13
index|]
decl_stmt|,
name|bxxh
index|[
literal|26
index|]
index|[
literal|13
index|]
decl_stmt|,
name|xxh
index|[
literal|26
index|]
index|[
literal|13
index|]
decl_stmt|,
name|xhx
index|[
literal|26
index|]
index|[
literal|13
index|]
decl_stmt|,
name|hxx
index|[
literal|26
index|]
index|[
literal|13
index|]
decl_stmt|;
name|again
label|:
if|if
condition|(
operator|!
operator|(
name|w
operator|=
name|chkvow
argument_list|(
name|hyend
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return;
name|hyend
operator|=
name|w
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|w
operator|=
name|chkvow
argument_list|(
name|hyend
argument_list|)
operator|)
condition|)
return|return;
name|nhyend
operator|=
name|w
expr_stmt|;
name|maxval
operator|=
literal|0
expr_stmt|;
name|w
operator|--
expr_stmt|;
while|while
condition|(
operator|(
operator|++
name|w
operator|<
name|hyend
operator|)
operator|&&
operator|(
name|w
operator|<
operator|(
name|wdend
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|wdstart
condition|)
name|val
operator|*=
name|dilook
argument_list|(
literal|'a'
argument_list|,
name|cbits
argument_list|(
operator|*
name|w
argument_list|)
argument_list|,
name|bxh
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|w
operator|==
name|wdstart
operator|+
literal|1
condition|)
name|val
operator|*=
name|dilook
argument_list|(
name|cbits
argument_list|(
operator|*
operator|(
name|w
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
name|cbits
argument_list|(
operator|*
name|w
argument_list|)
argument_list|,
name|bxxh
argument_list|)
expr_stmt|;
else|else
name|val
operator|*=
name|dilook
argument_list|(
name|cbits
argument_list|(
operator|*
operator|(
name|w
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
name|cbits
argument_list|(
operator|*
name|w
argument_list|)
argument_list|,
name|xxh
argument_list|)
expr_stmt|;
name|val
operator|*=
name|dilook
argument_list|(
name|cbits
argument_list|(
operator|*
name|w
argument_list|)
argument_list|,
name|cbits
argument_list|(
operator|*
operator|(
name|w
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|xhx
argument_list|)
expr_stmt|;
name|val
operator|*=
name|dilook
argument_list|(
name|cbits
argument_list|(
operator|*
operator|(
name|w
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|cbits
argument_list|(
operator|*
operator|(
name|w
operator|+
literal|2
operator|)
argument_list|)
argument_list|,
name|hxx
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|maxval
condition|)
block|{
name|maxval
operator|=
name|val
expr_stmt|;
name|maxw
operator|=
name|w
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|hyend
operator|=
name|nhyend
expr_stmt|;
if|if
condition|(
name|maxval
operator|>
name|thresh
condition|)
operator|*
name|hyp
operator|++
operator|=
name|maxw
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_block

begin_macro
name|dilook
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|t
index|[
literal|26
index|]
index|[
literal|13
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|i
operator|=
name|t
index|[
name|maplow
argument_list|(
name|a
argument_list|)
operator|-
literal|'a'
index|]
index|[
operator|(
name|j
operator|=
name|maplow
argument_list|(
name|b
argument_list|)
operator|-
literal|'a'
operator|)
operator|/
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|j
operator|&
literal|01
operator|)
condition|)
name|i
operator|>>=
literal|4
expr_stmt|;
return|return
operator|(
name|i
operator|&
literal|017
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * All these jazz is to have the dialect dutch being hyphenated  * It first appeared in the dutch version of troff (nltroff), due to  * teus hagen.  * The original program has converted from Algol60 to C by, I think  * bert ijsselstein.  * It's a mess, anyway.  *  * Planted in this version of troff by jaap akkerhuis (jna).  *  * Note that this is licensed software!  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXLETT
value|50
end_define

begin_comment
comment|/* at most the first MAXLETT characters of a word                        will be processed */
end_comment

begin_define
define|#
directive|define
name|MAXSYLL
value|20
end_define

begin_comment
comment|/* at most the first MAXSYLL syllables of a word 		       will be processed */
end_comment

begin_define
define|#
directive|define
name|LETTEREE
value|27
end_define

begin_define
define|#
directive|define
name|LETTERJ
value|41
end_define

begin_define
define|#
directive|define
name|LETTERV
value|55
end_define

begin_define
define|#
directive|define
name|LETTERX
value|57
end_define

begin_define
define|#
directive|define
name|LETTERZ
value|58
end_define

begin_comment
comment|/*  * split(..) needs to be cleaned up, could install hjt's version...  */
end_comment

begin_expr_stmt
name|split
argument_list|(
name|aword
argument_list|,
name|anend
argument_list|)
specifier|register
name|tchar
operator|*
name|aword
operator|,
operator|*
name|anend
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|tchar
modifier|*
name|place
decl_stmt|;
specifier|extern
name|tchar
modifier|*
name|bestsplit1
parameter_list|()
function_decl|;
name|place
operator|=
name|bestsplit1
argument_list|(
name|aword
argument_list|,
name|anend
argument_list|)
expr_stmt|;
if|if
condition|(
name|place
operator|!=
operator|(
name|tchar
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|hyp
operator|++
operator|=
name|place
expr_stmt|;
if|if
condition|(
name|place
operator|-
name|aword
operator|>
name|thresh
operator|&&
name|anend
operator|-
name|place
operator|>
name|thresh
condition|)
name|split
argument_list|(
name|aword
argument_list|,
name|place
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|anend
operator|-
name|place
operator|>
name|thresh
operator|&&
name|place
operator|-
name|aword
operator|>
name|thresh
condition|)
name|split
argument_list|(
name|place
argument_list|,
name|anend
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|tchar
modifier|*
name|bestsplit1
parameter_list|(
name|tosplit
parameter_list|,
name|aend
parameter_list|)
name|tchar
modifier|*
name|tosplit
decl_stmt|,
decl|*
name|aend
decl_stmt|;
end_function

begin_block
block|{
comment|/* This function determines the "best" place to split into two parts the  * Dutch word contained in a string of<size> characters which starts at  * the address<tosplit> .  * The input characters should be in ASCII code .  * The function returns as value the number of characters of the first  * of the two parts .  * If the returned value exceeds the character count of the line the  * user may try to invoke bestsplit1 again but now with<size> equal to  * the returned value plus one .  * The algorithm is adapted from the Mathematical Centre report NR 28/72,  * "BESTESPLITS1, EEN PROCEDURE VOOR HET AUTOMATISCH AFBREKEN VAN NEDER-  * LANDSE WOORDEN" , which has been written by J.C. VAN VLIET.  */
specifier|extern
name|char
name|translate
index|[]
decl_stmt|,
name|comprimation
index|[]
index|[
literal|14
index|]
decl_stmt|,
name|consonant
index|[]
index|[
literal|23
index|]
decl_stmt|,
name|prefix
index|[]
index|[
literal|3
index|]
decl_stmt|;
name|short
name|woord
index|[
name|MAXLETT
operator|+
literal|1
index|]
decl_stmt|,
name|reference
index|[
name|MAXLETT
operator|+
literal|1
index|]
decl_stmt|,
name|vowel
index|[
name|MAXSYLL
index|]
decl_stmt|,
name|turn
index|[
name|MAXSYLL
index|]
decl_stmt|,
name|letter
decl_stmt|,
name|nextlett
decl_stmt|,
name|vowel1
decl_stmt|,
name|vowel2
decl_stmt|,
name|l0
decl_stmt|,
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|short
name|numlett
decl_stmt|,
name|numsyll
decl_stmt|,
name|turnindex
decl_stmt|,
name|differ
decl_stmt|,
name|start1
decl_stmt|,
name|start2
decl_stmt|,
name|stop
decl_stmt|,
name|level
decl_stmt|,
name|bp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|help
decl_stmt|;
name|short
name|size
init|=
name|aend
operator|-
name|tosplit
operator|+
literal|1
decl_stmt|;
comment|/* translate into bestsplit code : */
name|woord
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|help
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
operator|++
name|help
operator|<
name|size
operator|)
operator|&&
operator|(
name|i
operator|<
name|MAXLETT
operator|)
condition|)
block|{
name|reference
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|woord
index|[
name|i
operator|++
index|]
operator|=
name|translate
index|[
name|maplow
argument_list|(
name|cbits
argument_list|(
name|tosplit
index|[
name|help
index|]
argument_list|)
argument_list|)
operator|-
literal|'a'
index|]
expr_stmt|;
block|}
comment|/* end of translation : */
name|numlett
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|numlett
operator|<
literal|4
condition|)
goto|goto
name|nosplit
goto|;
name|i
operator|=
name|j
operator|=
literal|1
expr_stmt|;
name|help
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|numlett
condition|)
block|{
name|letter
operator|=
name|woord
index|[
name|i
index|]
expr_stmt|;
comment|/* comprimation of vowels : */
if|if
condition|(
operator|(
literal|25
operator|<
name|letter
operator|)
operator|&&
operator|(
name|letter
operator|<
literal|41
operator|)
condition|)
block|{
name|nextlett
operator|=
name|woord
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
literal|28
operator|<
name|nextlett
operator|)
operator|&&
operator|(
name|nextlett
operator|<
literal|43
operator|)
condition|)
block|{
name|letter
operator|=
name|comprimation
index|[
name|letter
operator|-
literal|26
index|]
index|[
name|nextlett
operator|-
literal|29
index|]
expr_stmt|;
if|if
condition|(
name|letter
operator|>
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|help
operator|++
expr_stmt|;
name|woord
index|[
name|i
index|]
operator|=
name|letter
expr_stmt|;
continue|continue ;
block|}
block|}
block|}
comment|/* end of comprimation */
name|woord
index|[
name|j
index|]
operator|=
name|woord
index|[
name|i
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|reference
index|[
name|j
index|]
operator|+=
name|help
expr_stmt|;
block|}
name|woord
index|[
name|j
index|]
operator|=
name|woord
index|[
name|numlett
index|]
expr_stmt|;
name|numlett
operator|=
name|j
expr_stmt|;
comment|/* determination of the number of syllables */
name|j
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|++
name|i
operator|<=
name|numlett
operator|)
operator|&&
operator|(
name|j
operator|<
name|MAXSYLL
operator|)
condition|)
block|{
if|if
condition|(
name|woord
index|[
name|i
index|]
operator|<
literal|39
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|vowel
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
name|numsyll
operator|=
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|numsyll
operator|<
literal|2
condition|)
goto|goto
name|nosplit
goto|;
name|turnindex
operator|=
literal|0
expr_stmt|;
name|differ
operator|=
literal|1
expr_stmt|;
name|start1
operator|=
literal|0
expr_stmt|;
name|start2
operator|=
name|numsyll
operator|-
literal|1
expr_stmt|;
name|stop
operator|=
name|start2
expr_stmt|;
while|while
condition|(
name|turnindex
operator|<
name|stop
condition|)
block|{
name|vowel1
operator|=
name|vowel
index|[
name|stop
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|stop
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|vowel2
operator|=
name|vowel
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vowel1
operator|-
name|vowel2
operator|==
name|differ
condition|)
block|{
name|turn
index|[
name|turnindex
index|]
operator|=
name|i
expr_stmt|;
name|turnindex
operator|++
expr_stmt|;
block|}
name|vowel1
operator|=
name|vowel2
expr_stmt|;
block|}
if|if
condition|(
name|differ
operator|==
literal|1
condition|)
name|start1
operator|=
name|turnindex
expr_stmt|;
elseif|else
if|if
condition|(
name|differ
operator|==
literal|2
condition|)
name|start2
operator|=
name|turnindex
expr_stmt|;
name|differ
operator|++
expr_stmt|;
block|}
name|turnindex
operator|=
name|start2
operator|-
literal|1
expr_stmt|;
name|stop
operator|=
name|numsyll
operator|-
literal|1
expr_stmt|;
name|level
operator|=
literal|1
expr_stmt|;
name|next
label|:
name|turnindex
operator|++
expr_stmt|;
if|if
condition|(
name|turnindex
operator|>=
name|stop
condition|)
block|{
if|if
condition|(
name|level
operator|==
literal|1
condition|)
name|turnindex
operator|=
name|start2
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
literal|2
condition|)
block|{
name|turnindex
operator|=
name|start1
expr_stmt|;
name|stop
operator|=
name|start2
expr_stmt|;
block|}
else|else
goto|goto
name|nosplit
goto|;
name|level
operator|++
expr_stmt|;
if|if
condition|(
name|turnindex
operator|>=
name|stop
condition|)
goto|goto
name|next
goto|;
block|}
name|j
operator|=
name|turn
index|[
name|turnindex
index|]
expr_stmt|;
name|vowel1
operator|=
name|vowel
index|[
name|j
index|]
expr_stmt|;
name|vowel2
operator|=
name|vowel
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
literal|1
case|:
for|for
control|(
name|j
operator|=
name|vowel2
operator|-
literal|2
init|;
name|j
operator|>=
name|vowel1
operator|+
literal|1
condition|;
name|j
operator|--
control|)
block|{
name|help
operator|=
name|consonant
index|[
name|woord
index|[
name|j
index|]
operator|-
literal|39
index|]
index|[
name|woord
index|[
name|j
operator|+
literal|1
index|]
operator|-
literal|39
index|]
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|help
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|splitafterj
goto|;
if|if
condition|(
name|help
operator|<
literal|0
condition|)
goto|goto
name|next
goto|;
block|}
break|break ;
comment|/* end of first phase */
case|case
literal|2
case|:
for|for
control|(
name|i
operator|=
name|vowel2
operator|-
literal|2
init|;
name|i
operator|>=
name|vowel1
operator|+
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|help
operator|=
name|consonant
index|[
name|woord
index|[
name|i
index|]
operator|-
literal|39
index|]
index|[
name|woord
index|[
name|i
operator|+
literal|1
index|]
operator|-
literal|39
index|]
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|help
argument_list|)
operator|==
literal|2
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
goto|goto
name|splitafterj
goto|;
block|}
if|if
condition|(
name|abs
argument_list|(
name|help
argument_list|)
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|vowel1
operator|+
literal|1
condition|)
block|{
name|j
operator|=
name|vowel1
expr_stmt|;
goto|goto
name|splitafterj
goto|;
block|}
name|help
operator|=
name|abs
argument_list|(
name|consonant
index|[
name|woord
index|[
name|i
operator|-
literal|1
index|]
operator|-
literal|39
index|]
index|[
name|woord
index|[
name|i
index|]
operator|-
literal|39
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|help
operator|==
literal|2
condition|)
block|{
name|j
operator|=
name|i
operator|-
literal|1
expr_stmt|;
goto|goto
name|splitafterj
goto|;
block|}
if|if
condition|(
name|help
operator|==
literal|3
condition|)
block|{
name|j
operator|=
name|i
operator|-
literal|2
expr_stmt|;
goto|goto
name|splitafterj
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|abs
argument_list|(
name|help
argument_list|)
operator|==
literal|4
operator|)
operator|&&
operator|(
name|i
operator|==
name|vowel2
operator|-
literal|2
operator|)
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
goto|goto
name|splitafterj
goto|;
block|}
if|if
condition|(
name|help
operator|<
literal|0
condition|)
goto|goto
name|next
goto|;
block|}
break|break ;
comment|/* end of second phase */
case|case
literal|3
case|:
name|j
operator|=
name|vowel1
expr_stmt|;
name|help
operator|=
name|woord
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|help
operator|==
name|LETTERJ
operator|)
operator|||
operator|(
name|help
operator|==
name|LETTERV
operator|)
operator|||
operator|(
name|help
operator|==
name|LETTERZ
operator|)
condition|)
goto|goto
name|splitafterj
goto|;
if|if
condition|(
name|help
operator|==
name|LETTERX
condition|)
goto|goto
name|next
goto|;
name|l1
operator|=
name|woord
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|l1
operator|==
name|LETTEREE
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
operator|(
name|l1
operator|>
literal|24
operator|)
operator|&&
operator|(
name|l1
operator|<
literal|29
operator|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
goto|goto
name|splitafterj
goto|;
block|}
name|l0
operator|=
name|woord
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|l2
operator|=
name|woord
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|l0
operator|==
name|prefix
index|[
name|i
index|]
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|l1
operator|==
name|prefix
index|[
name|i
index|]
index|[
literal|1
index|]
operator|)
operator|&&
operator|(
name|l2
operator|==
name|prefix
index|[
name|i
index|]
index|[
literal|2
index|]
operator|)
condition|)
goto|goto
name|next
goto|;
goto|goto
name|splitafterj
goto|;
break|break ;
comment|/* end of third phase */
block|}
goto|goto
name|next
goto|;
name|splitafterj
label|:
name|bp
operator|=
name|reference
index|[
name|j
operator|+
literal|1
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|<
name|size
operator|-
literal|1
operator|)
operator|&&
operator|(
name|bp
operator|>
literal|0
operator|)
condition|)
goto|goto
name|away
goto|;
else|else
goto|goto
name|next
goto|;
name|nosplit
label|:
name|bp
operator|=
literal|0
expr_stmt|;
name|level
operator|=
literal|4
expr_stmt|;
name|away
label|:
return|return
operator|(
name|bp
operator|==
literal|0
condition|?
operator|(
name|tchar
operator|*
operator|)
name|NULL
else|:
name|tosplit
operator|+
name|bp
operator|)
return|;
block|}
end_block

end_unit

