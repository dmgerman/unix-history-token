begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"exprn.c	(CWI)	1.1	85/03/01"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ideal.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_function
name|void
name|nonlinerr
parameter_list|(
name|funcname
parameter_list|)
name|char
modifier|*
name|funcname
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: %s() of unknown\n>>>Returning 1.0\n"
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|DEPPTR
name|depvarlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|incon_warn
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|nl_warn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|nl_fail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EQNPTR
name|nl_eqns
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|INTLPTR
name|expreval
parameter_list|(
name|exprn
parameter_list|,
name|givennoad
parameter_list|)
name|EXPR
name|exprn
decl_stmt|;
name|NOADPTR
name|givennoad
decl_stmt|;
block|{
comment|/* This routine returns an INTLPTR whose operator 	   is ';'--a promoted commanode containing the 	   dependency list representing the real part in 	   its left field, the imag part in its right */
specifier|register
name|INTLPTR
name|intl
decl_stmt|;
specifier|register
name|EXTLPTR
name|extl
decl_stmt|;
if|if
condition|(
operator|!
name|exprn
condition|)
return|return
operator|(
name|commagen
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|EXTLPTR
operator|)
name|exprn
operator|)
operator|->
name|leaf
condition|)
block|{
name|extl
operator|=
operator|(
name|EXTLPTR
operator|)
name|exprn
expr_stmt|;
name|dprintf
literal|"At a leaf of kind %d\n"
operator|,
name|extl
operator|->
name|kind
block|)
empty_stmt|;
switch|switch
condition|(
name|extl
operator|->
name|kind
condition|)
block|{
case|case
name|PATH
case|:
return|return
operator|(
name|pathfind
argument_list|(
name|extl
operator|->
name|info
operator|.
name|path
argument_list|,
name|givennoad
argument_list|)
operator|)
return|;
break|break;
case|case
name|CONST
case|:
return|return
operator|(
name|commagen
argument_list|(
name|extl
operator|->
name|info
operator|.
expr|const
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
break|break;
block|}
block|}
end_function

begin_expr_stmt
name|intl
operator|=
operator|(
name|INTLPTR
operator|)
name|exprn
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|intl
operator|->
name|oper
operator|==
name|NAME
condition|)
block|{
name|dprintf
literal|"Looking for a function named %s\n"
operator|,
name|idprint
argument_list|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
argument_list|)
block|)
empty_stmt|;
end_if

begin_block
unit|} else
block|{
name|dprintf
literal|"At an internal node with operator %c\n"
operator|,
name|intl
operator|->
name|oper
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|} 	switch
operator|(
name|intl
operator|->
name|oper
operator|)
block|{
name|INTLPTR
name|lefttemp
block|,
name|righttemp
block|,
name|temp
block|,
name|temp2
block|;
name|DEPPTR
name|drek
block|,
name|drek2
block|;
name|float
name|repart
block|,
name|impart
block|,
name|modulus
block|;
case|case
name|NAME
case|:
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
operator|)
operator|==
name|lookup
argument_list|(
literal|"re"
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expreval
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|intl
operator|->
name|right
operator|)
operator|->
name|expr
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
name|depfree
argument_list|(
operator|(
name|DEPPTR
operator|)
name|temp
operator|->
name|right
argument_list|)
expr_stmt|;
name|temp
operator|->
name|right
operator|=
operator|(
name|EXPR
operator|)
name|depgen
argument_list|(
operator|(
name|VARPTR
operator|)
name|NULL
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
operator|)
operator|==
name|lookup
argument_list|(
literal|"im"
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expreval
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|intl
operator|->
name|right
operator|)
operator|->
name|expr
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
name|depfree
argument_list|(
operator|(
name|DEPPTR
operator|)
name|temp
operator|->
name|left
argument_list|)
expr_stmt|;
name|temp
operator|->
name|left
operator|=
name|temp
operator|->
name|right
expr_stmt|;
name|temp
operator|->
name|right
operator|=
operator|(
name|EXPR
operator|)
name|depgen
argument_list|(
operator|(
name|VARPTR
operator|)
name|NULL
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
operator|)
operator|==
name|lookup
argument_list|(
literal|"conj"
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expreval
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|intl
operator|->
name|right
operator|)
operator|->
name|expr
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
name|temp2
operator|=
name|intlgen
argument_list|(
literal|';'
argument_list|,
operator|(
name|EXPR
operator|)
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|NULL
argument_list|,
literal|0.0
argument_list|,
operator|(
name|DEPPTR
operator|)
name|temp
operator|->
name|left
argument_list|,
literal|1.0
argument_list|)
argument_list|,
operator|(
name|EXPR
operator|)
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|NULL
argument_list|,
literal|0.0
argument_list|,
operator|(
name|DEPPTR
operator|)
name|temp
operator|->
name|right
argument_list|,
operator|-
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp2
operator|)
return|;
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
operator|)
operator|==
name|lookup
argument_list|(
literal|"abs"
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expreval
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|intl
operator|->
name|right
operator|)
operator|->
name|expr
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|known
argument_list|(
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|nl_warn
condition|)
name|nonlinerr
argument_list|(
literal|"abs"
argument_list|)
expr_stmt|;
name|nl_fail
operator|=
operator|!
name|nl_warn
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|repart
operator|=
name|Re
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|impart
operator|=
name|Im
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
name|hypot
argument_list|(
name|repart
argument_list|,
name|impart
argument_list|)
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
operator|)
operator|==
name|lookup
argument_list|(
literal|"cis"
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expreval
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|intl
operator|->
name|right
operator|)
operator|->
name|expr
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|known
argument_list|(
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|nl_warn
condition|)
name|nonlinerr
argument_list|(
literal|"cis"
argument_list|)
expr_stmt|;
name|nl_fail
operator|=
operator|!
name|nl_warn
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|repart
operator|=
name|Re
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|impart
operator|=
name|Im
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radflag
condition|)
block|{
name|dtor
argument_list|(
name|repart
argument_list|)
expr_stmt|;
name|dtor
argument_list|(
name|impart
argument_list|)
expr_stmt|;
block|}
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|impart
operator|>
name|EPSILON
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: cis of complex value\n>>>Ignoring imaginary part\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
name|cos
argument_list|(
name|repart
argument_list|)
argument_list|,
name|sin
argument_list|(
name|repart
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
operator|)
operator|==
name|lookup
argument_list|(
literal|"int"
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expreval
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|intl
operator|->
name|right
operator|)
operator|->
name|expr
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|known
argument_list|(
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|nl_warn
condition|)
name|nonlinerr
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
name|nl_fail
operator|=
operator|!
name|nl_warn
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|double
name|intpart
decl_stmt|;
name|repart
operator|=
name|Re
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|impart
operator|=
name|Im
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|impart
operator|>
name|EPSILON
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: int of complex value\n>>>Ignoring imaginary part\n"
argument_list|)
expr_stmt|;
name|modf
argument_list|(
name|repart
argument_list|,
operator|&
name|intpart
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
operator|(
name|float
operator|)
name|intpart
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
operator|)
operator|==
name|lookup
argument_list|(
literal|"atan2"
argument_list|)
operator|||
operator|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
operator|)
operator|==
name|lookup
argument_list|(
literal|"angle"
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expreval
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|intl
operator|->
name|right
operator|)
operator|->
name|expr
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|known
argument_list|(
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|nl_warn
condition|)
name|nonlinerr
argument_list|(
literal|"angle"
argument_list|)
expr_stmt|;
name|nl_fail
operator|=
operator|!
name|nl_warn
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|repart
operator|=
name|Re
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|impart
operator|=
name|Im
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|repart
operator|=
name|atan2
argument_list|(
name|impart
argument_list|,
name|repart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radflag
condition|)
name|rtod
argument_list|(
name|repart
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
name|repart
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
operator|)
operator|==
name|lookup
argument_list|(
literal|"E"
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expreval
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|intl
operator|->
name|right
operator|)
operator|->
name|expr
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|known
argument_list|(
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|nl_warn
condition|)
name|nonlinerr
argument_list|(
literal|"E"
argument_list|)
expr_stmt|;
name|nl_fail
operator|=
operator|!
name|nl_warn
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|repart
operator|=
name|Re
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|impart
operator|=
name|Im
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|impart
operator|>
name|EPSILON
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: E of complex value\n>>>Ignoring imaginary part\n"
argument_list|)
expr_stmt|;
name|repart
operator|*=
literal|2
operator|*
name|PI
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
name|cos
argument_list|(
name|repart
argument_list|)
argument_list|,
name|sin
argument_list|(
name|repart
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
operator|)
operator|==
name|lookup
argument_list|(
literal|"unit"
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expreval
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|intl
operator|->
name|right
operator|)
operator|->
name|expr
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|known
argument_list|(
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|nl_warn
condition|)
name|nonlinerr
argument_list|(
literal|"unit"
argument_list|)
expr_stmt|;
name|nl_fail
operator|=
operator|!
name|nl_warn
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|repart
operator|=
name|Re
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|impart
operator|=
name|Im
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|modulus
operator|=
name|hypot
argument_list|(
name|repart
argument_list|,
name|impart
argument_list|)
operator|)
operator|<
name|EPSILON
condition|)
return|return
operator|(
name|commagen
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|commagen
argument_list|(
name|repart
operator|/
name|modulus
argument_list|,
name|impart
operator|/
name|modulus
argument_list|)
operator|)
return|;
block|}
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
operator|)
operator|==
name|lookup
argument_list|(
literal|"sqrt"
argument_list|)
condition|)
block|{
name|temp
operator|=
name|expreval
argument_list|(
operator|(
operator|(
name|EXPRPTR
operator|)
name|intl
operator|->
name|right
operator|)
operator|->
name|expr
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|known
argument_list|(
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|nl_warn
condition|)
name|nonlinerr
argument_list|(
literal|"sqrt"
argument_list|)
expr_stmt|;
name|nl_fail
operator|=
operator|!
name|nl_warn
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|repart
operator|=
name|Re
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|impart
operator|=
name|Im
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|modulus
operator|=
name|hypot
argument_list|(
name|repart
argument_list|,
name|impart
argument_list|)
operator|)
operator|<
name|EPSILON
condition|)
return|return
operator|(
name|commagen
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
else|else
block|{
name|float
name|theta
decl_stmt|;
name|modulus
operator|=
name|sqrt
argument_list|(
name|modulus
argument_list|)
expr_stmt|;
name|theta
operator|=
literal|0.5
operator|*
name|atan2
argument_list|(
name|impart
argument_list|,
name|repart
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
name|modulus
operator|*
name|cos
argument_list|(
name|theta
argument_list|)
argument_list|,
name|modulus
operator|*
name|sin
argument_list|(
name|theta
argument_list|)
argument_list|)
operator|)
return|;
block|}
empty_stmt|;
block|}
block|}
end_elseif

begin_else
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: unknown function name:  %s\n>>>Returning 1.0\n"
argument_list|,
name|idprint
argument_list|(
operator|(
name|int
operator|)
name|intl
operator|->
name|left
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
end_else

begin_break
break|break;
end_break

begin_case
case|case
literal|'~'
case|:
end_case

begin_expr_stmt
name|incon_warn
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* FALL THROUGH TO '=' case */
end_comment

begin_case
case|case
literal|'='
case|:
end_case

begin_block
block|{
name|DEPPTR
name|depvarwalk
decl_stmt|;
name|lefttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|left
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
name|righttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|right
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl_fail
condition|)
block|{
name|dprintf
literal|"Non-linear equation: failure\n"
block|)
empty_stmt|;
name|intlfree
argument_list|(
name|lefttemp
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|righttemp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
end_block

begin_for
for|for
control|(
name|depvarwalk
operator|=
name|depvarlist
init|;
name|depvarwalk
condition|;
name|depvarwalk
operator|=
name|depvarwalk
operator|->
name|next
control|)
block|{
name|lefttemp
operator|->
name|left
operator|=
operator|(
name|EXPR
operator|)
name|depsubst
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|left
argument_list|,
operator|(
name|DEPPTR
operator|)
name|depvarwalk
operator|->
name|var
operator|->
name|deplist
argument_list|,
name|depvarwalk
operator|->
name|var
argument_list|)
expr_stmt|;
name|lefttemp
operator|->
name|right
operator|=
operator|(
name|EXPR
operator|)
name|depsubst
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|right
argument_list|,
operator|(
name|DEPPTR
operator|)
name|depvarwalk
operator|->
name|var
operator|->
name|deplist
argument_list|,
name|depvarwalk
operator|->
name|var
argument_list|)
expr_stmt|;
name|righttemp
operator|->
name|left
operator|=
operator|(
name|EXPR
operator|)
name|depsubst
argument_list|(
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|left
argument_list|,
operator|(
name|DEPPTR
operator|)
name|depvarwalk
operator|->
name|var
operator|->
name|deplist
argument_list|,
name|depvarwalk
operator|->
name|var
argument_list|)
expr_stmt|;
name|righttemp
operator|->
name|right
operator|=
operator|(
name|EXPR
operator|)
name|depsubst
argument_list|(
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|right
argument_list|,
operator|(
name|DEPPTR
operator|)
name|depvarwalk
operator|->
name|var
operator|->
name|deplist
argument_list|,
name|depvarwalk
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|dprintf
literal|"equating real parts...\n"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|drek
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|left
argument_list|,
literal|1.0
argument_list|,
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|left
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|eqndo
argument_list|(
name|drek
argument_list|,
name|exprn
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|depfree
argument_list|(
name|drek
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|depvarlist
condition|)
block|{
comment|/* trick: at most one variable became 			/* dependent by the above processing, 			/* so only it must be replaced in the 			/* equation on the imaginary parts */
name|lefttemp
operator|->
name|right
operator|=
operator|(
name|EXPR
operator|)
name|depsubst
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|right
argument_list|,
operator|(
name|DEPPTR
operator|)
name|depvarlist
operator|->
name|var
operator|->
name|deplist
argument_list|,
name|depvarlist
operator|->
name|var
argument_list|)
expr_stmt|;
name|righttemp
operator|->
name|right
operator|=
operator|(
name|EXPR
operator|)
name|depsubst
argument_list|(
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|right
argument_list|,
operator|(
name|DEPPTR
operator|)
name|depvarlist
operator|->
name|var
operator|->
name|deplist
argument_list|,
name|depvarlist
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|dprintf
literal|"equating imag parts...\n"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|drek
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|right
argument_list|,
literal|1.0
argument_list|,
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|right
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|eqndo
argument_list|(
name|drek
argument_list|,
name|exprn
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|depfree
argument_list|(
name|drek
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|intlfree
argument_list|(
name|lefttemp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|righttemp
operator|)
return|;
end_return

begin_empty_stmt
unit|} 		break
empty_stmt|;
end_empty_stmt

begin_case
case|case
literal|'+'
case|:
end_case

begin_expr_stmt
name|lefttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|left
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|righttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|right
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|drek
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|left
argument_list|,
literal|1.0
argument_list|,
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|left
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|drek2
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|right
argument_list|,
literal|1.0
argument_list|,
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|right
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|intlfree
argument_list|(
name|lefttemp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|intlfree
argument_list|(
name|righttemp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|intlgen
argument_list|(
literal|';'
argument_list|,
operator|(
name|EXPR
operator|)
name|drek
argument_list|,
operator|(
name|EXPR
operator|)
name|drek2
argument_list|)
operator|)
return|;
end_return

begin_break
break|break;
end_break

begin_case
case|case
literal|'-'
case|:
end_case

begin_expr_stmt
name|lefttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|left
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|righttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|right
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|drek
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|left
argument_list|,
literal|1.0
argument_list|,
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|left
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|drek2
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|right
argument_list|,
literal|1.0
argument_list|,
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|right
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|intlfree
argument_list|(
name|lefttemp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|intlfree
argument_list|(
name|righttemp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|intlgen
argument_list|(
literal|';'
argument_list|,
operator|(
name|EXPR
operator|)
name|drek
argument_list|,
operator|(
name|EXPR
operator|)
name|drek2
argument_list|)
operator|)
return|;
end_return

begin_break
break|break;
end_break

begin_case
case|case
literal|'*'
case|:
end_case

begin_expr_stmt
name|lefttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|left
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|righttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|right
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|known
argument_list|(
name|lefttemp
argument_list|)
condition|)
block|{
name|repart
operator|=
operator|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|left
operator|)
operator|->
name|coeff
expr_stmt|;
name|impart
operator|=
operator|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|right
operator|)
operator|->
name|coeff
expr_stmt|;
name|intlfree
argument_list|(
name|lefttemp
argument_list|)
expr_stmt|;
name|drek
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|left
argument_list|,
name|repart
argument_list|,
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|right
argument_list|,
operator|-
name|impart
argument_list|)
expr_stmt|;
name|drek2
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|left
argument_list|,
name|impart
argument_list|,
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|right
argument_list|,
name|repart
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|righttemp
argument_list|)
expr_stmt|;
return|return
operator|(
name|intlgen
argument_list|(
literal|';'
argument_list|,
operator|(
name|EXPR
operator|)
name|drek
argument_list|,
operator|(
name|EXPR
operator|)
name|drek2
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|known
argument_list|(
name|righttemp
argument_list|)
condition|)
block|{
name|repart
operator|=
operator|(
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|left
operator|)
operator|->
name|coeff
expr_stmt|;
name|impart
operator|=
operator|(
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|right
operator|)
operator|->
name|coeff
expr_stmt|;
name|intlfree
argument_list|(
name|righttemp
argument_list|)
expr_stmt|;
name|drek
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|left
argument_list|,
name|repart
argument_list|,
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|right
argument_list|,
operator|-
name|impart
argument_list|)
expr_stmt|;
name|drek2
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|left
argument_list|,
name|impart
argument_list|,
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|right
argument_list|,
name|repart
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|lefttemp
argument_list|)
expr_stmt|;
return|return
operator|(
name|intlgen
argument_list|(
literal|';'
argument_list|,
operator|(
name|EXPR
operator|)
name|drek
argument_list|,
operator|(
name|EXPR
operator|)
name|drek2
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|nl_warn
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: multiplication of two unknowns\n>>>Returning 1.0\n"
argument_list|)
expr_stmt|;
name|nl_fail
operator|=
operator|!
name|nl_warn
expr_stmt|;
name|intlfree
argument_list|(
name|lefttemp
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|righttemp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
end_if

begin_break
break|break;
end_break

begin_case
case|case
literal|'/'
case|:
end_case

begin_expr_stmt
name|lefttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|left
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|righttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|right
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|known
argument_list|(
name|righttemp
argument_list|)
condition|)
block|{
if|if
condition|(
name|nl_warn
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: division by an unknown\n>>>Returning 1.0\n"
argument_list|)
expr_stmt|;
name|nl_fail
operator|=
operator|!
name|nl_warn
expr_stmt|;
name|intlfree
argument_list|(
name|lefttemp
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|righttemp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|repart
operator|=
operator|(
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|left
operator|)
operator|->
name|coeff
expr_stmt|;
name|impart
operator|=
operator|-
operator|(
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|right
operator|)
operator|->
name|coeff
expr_stmt|;
name|modulus
operator|=
name|repart
operator|*
name|repart
operator|+
name|impart
operator|*
name|impart
expr_stmt|;
name|intlfree
argument_list|(
name|righttemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|modulus
operator|<
name|EPSILON
operator|*
name|EPSILON
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: division by zero\n>>>Returning 1.0\n"
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|lefttemp
argument_list|)
expr_stmt|;
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|drek
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|left
argument_list|,
name|repart
operator|/
name|modulus
argument_list|,
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|right
argument_list|,
operator|-
name|impart
operator|/
name|modulus
argument_list|)
expr_stmt|;
name|drek2
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|left
argument_list|,
name|impart
operator|/
name|modulus
argument_list|,
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|right
argument_list|,
name|repart
operator|/
name|modulus
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|lefttemp
argument_list|)
expr_stmt|;
return|return
operator|(
name|intlgen
argument_list|(
literal|';'
argument_list|,
operator|(
name|EXPR
operator|)
name|drek
argument_list|,
operator|(
name|EXPR
operator|)
name|drek2
argument_list|)
operator|)
return|;
block|}
block|}
end_if

begin_break
break|break;
end_break

begin_case
case|case
literal|','
case|:
end_case

begin_expr_stmt
name|lefttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|left
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|righttemp
operator|=
name|expreval
argument_list|(
name|intl
operator|->
name|right
argument_list|,
name|givennoad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|depfree
argument_list|(
operator|(
name|DEPPTR
operator|)
name|lefttemp
operator|->
name|right
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|depfree
argument_list|(
operator|(
name|DEPPTR
operator|)
name|righttemp
operator|->
name|right
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|temp
operator|=
name|intlgen
argument_list|(
literal|';'
argument_list|,
operator|(
name|EXPR
operator|)
name|lefttemp
operator|->
name|left
argument_list|,
operator|(
name|EXPR
operator|)
name|righttemp
operator|->
name|left
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tryfree
argument_list|(
name|lefttemp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tryfree
argument_list|(
name|righttemp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|temp
operator|)
return|;
end_return

begin_break
break|break;
end_break

begin_case
case|case
literal|';'
case|:
end_case

begin_expr_stmt
name|drek
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|intl
operator|->
name|left
argument_list|,
literal|1.0
argument_list|,
operator|(
name|DEPPTR
operator|)
name|NULL
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|drek2
operator|=
name|depadd
argument_list|(
operator|(
name|DEPPTR
operator|)
name|intl
operator|->
name|right
argument_list|,
literal|1.0
argument_list|,
operator|(
name|DEPPTR
operator|)
name|NULL
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|intlgen
argument_list|(
literal|';'
argument_list|,
operator|(
name|EXPR
operator|)
name|drek
argument_list|,
operator|(
name|EXPR
operator|)
name|drek2
argument_list|)
operator|)
return|;
end_return

begin_case
case|case
literal|'^'
case|:
end_case

begin_return
return|return
operator|(
name|expreval
argument_list|(
name|intl
operator|->
name|right
argument_list|,
name|givennoad
argument_list|)
operator|)
return|;
end_return

begin_default
default|default:
end_default

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: unknown operator: %c\n>>>Returning 1.0\n"
argument_list|,
name|intl
operator|->
name|oper
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|commagen
argument_list|(
literal|1.0
argument_list|,
literal|0.0
argument_list|)
operator|)
return|;
end_return

begin_break
break|break;
end_break

begin_function
unit|} }
name|void
name|eqndo
parameter_list|(
name|deplist
parameter_list|,
name|eqn
parameter_list|,
name|givennoad
parameter_list|)
name|DEPPTR
name|deplist
decl_stmt|;
name|EXPR
name|eqn
decl_stmt|;
name|NOADPTR
name|givennoad
decl_stmt|;
block|{
comment|/* when called, equation system says deplist == 0 */
if|if
condition|(
operator|!
name|deplist
operator|->
name|next
operator|&&
operator|!
name|deplist
operator|->
name|var
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|deplist
operator|->
name|coeff
argument_list|)
operator|>
name|EPSILON
condition|)
block|{
if|if
condition|(
name|incon_warn
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: inconsistent equation in %s named %s\n"
argument_list|,
name|idprint
argument_list|(
name|givennoad
operator|->
name|defnode
operator|->
name|parm
operator|->
name|name
argument_list|)
argument_list|,
name|idprint
argument_list|(
name|givennoad
operator|->
name|defnode
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|exprprint
argument_list|(
operator|(
operator|(
name|INTLPTR
operator|)
name|eqn
operator|)
operator|->
name|left
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|exprprint
argument_list|(
name|eqn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|dprintf
literal|"Inconsistent equation\n"
block|)
empty_stmt|;
block|}
else|else
name|dprintf
literal|"Redundant equation\n"
block|)
function|;
end_function

begin_block
unit|} 	else
block|{
name|DEPPTR
name|curmax
decl_stmt|;
name|float
name|maxcoeff
decl_stmt|;
name|DEPPTR
name|depvarwalk
decl_stmt|;
name|DEPPTR
name|listwalk
decl_stmt|;
name|maxcoeff
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* find variable whose coefficient is largest in absolute value */
for|for
control|(
name|listwalk
operator|=
name|deplist
init|;
name|listwalk
condition|;
name|listwalk
operator|=
name|listwalk
operator|->
name|next
control|)
if|if
condition|(
name|listwalk
operator|->
name|var
operator|&&
operator|(
name|maxcoeff
operator|<
name|fabs
argument_list|(
name|listwalk
operator|->
name|coeff
argument_list|)
operator|)
condition|)
block|{
name|maxcoeff
operator|=
name|fabs
argument_list|(
name|listwalk
operator|->
name|coeff
argument_list|)
expr_stmt|;
name|curmax
operator|=
name|listwalk
expr_stmt|;
block|}
comment|/* get that variable represented in terms of the others */
name|listwalk
operator|=
name|depadd
argument_list|(
name|curmax
operator|->
name|var
operator|->
name|deplist
argument_list|,
literal|1.0
argument_list|,
name|deplist
argument_list|,
operator|-
literal|1.0
operator|/
name|curmax
operator|->
name|coeff
argument_list|)
expr_stmt|;
name|depfree
argument_list|(
name|curmax
operator|->
name|var
operator|->
name|deplist
argument_list|)
expr_stmt|;
name|curmax
operator|->
name|var
operator|->
name|deplist
operator|=
name|listwalk
expr_stmt|;
comment|/* put it on a list of dependent variables 		/* replace occurrences of it in other dependent variables */
if|if
condition|(
operator|!
name|depvarlist
condition|)
block|{
name|depvarlist
operator|=
name|depgen
argument_list|(
name|curmax
operator|->
name|var
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEPPTR
name|newhead
decl_stmt|;
for|for
control|(
name|depvarwalk
operator|=
name|depvarlist
init|;
name|depvarwalk
condition|;
name|depvarwalk
operator|=
name|depvarwalk
operator|->
name|next
control|)
block|{
name|depvarwalk
operator|->
name|var
operator|->
name|deplist
operator|=
name|depsubst
argument_list|(
name|depvarwalk
operator|->
name|var
operator|->
name|deplist
argument_list|,
name|curmax
operator|->
name|var
operator|->
name|deplist
argument_list|,
name|curmax
operator|->
name|var
argument_list|)
expr_stmt|;
block|}
name|newhead
operator|=
name|depgen
argument_list|(
name|curmax
operator|->
name|var
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|newhead
operator|->
name|next
operator|=
name|depvarlist
expr_stmt|;
name|depvarlist
operator|=
name|newhead
expr_stmt|;
block|}
block|}
end_block

begin_macro
unit|}  void
name|depvarclean
argument_list|()
end_macro

begin_block
block|{
comment|/* clean known variables out of the dependent variable list */
name|DEPPTR
name|prevdep
decl_stmt|,
name|depvarwalk
decl_stmt|;
name|DEPNODE
name|nuhead
decl_stmt|;
name|prevdep
operator|=
operator|&
name|nuhead
expr_stmt|;
name|prevdep
operator|->
name|next
operator|=
name|depvarwalk
operator|=
name|depvarlist
expr_stmt|;
while|while
condition|(
name|depvarwalk
condition|)
block|{
if|if
condition|(
operator|!
name|depvarwalk
operator|->
name|var
operator|->
name|deplist
operator|->
name|var
condition|)
block|{
name|dprintf
literal|"Removing %s(%s) = %f from dependent variable list\n"
operator|,
name|ISREAL
argument_list|(
name|depvarwalk
operator|->
name|var
argument_list|)
condition|?
literal|"re"
else|:
literal|"im"
operator|,
name|idprint
argument_list|(
name|THENAME
argument_list|(
name|depvarwalk
operator|->
name|var
argument_list|)
argument_list|)
operator|,
name|depvarwalk
operator|->
name|var
operator|->
name|deplist
operator|->
name|coeff
block|)
empty_stmt|;
name|prevdep
operator|->
name|next
operator|=
name|depvarwalk
operator|->
name|next
expr_stmt|;
name|tryfree
argument_list|(
name|depvarwalk
argument_list|)
expr_stmt|;
name|depvarwalk
operator|=
name|prevdep
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|prevdep
operator|=
name|depvarwalk
expr_stmt|;
name|depvarwalk
operator|=
name|depvarwalk
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|depvarlist
operator|=
name|nuhead
operator|.
name|next
expr_stmt|;
end_expr_stmt

begin_macro
unit|}  void
name|reqneval
argument_list|(
argument|noadtree
argument_list|)
end_macro

begin_decl_stmt
name|NOADPTR
name|noadtree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|STMTPTR
name|slist
index|[
literal|2
index|]
decl_stmt|;
name|STMTPTR
name|eqnwalk
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|noadtree
condition|)
return|return;
name|nl_warn
operator|=
name|FALSE
expr_stmt|;
name|slist
index|[
literal|0
index|]
operator|=
name|noadtree
operator|->
name|defnode
operator|->
name|parm
operator|->
name|stmtlist
expr_stmt|;
name|slist
index|[
literal|1
index|]
operator|=
name|findbox
argument_list|(
name|noadtree
operator|->
name|defnode
operator|->
name|parm
operator|->
name|name
argument_list|,
name|FALSE
argument_list|)
operator|->
name|stmtlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
for|for
control|(
name|eqnwalk
operator|=
name|nextstmt
argument_list|(
literal|'='
argument_list|,
name|slist
index|[
name|i
index|]
argument_list|)
init|;
name|eqnwalk
condition|;
name|eqnwalk
operator|=
name|nextstmt
argument_list|(
literal|'='
argument_list|,
name|eqnwalk
operator|->
name|next
argument_list|)
control|)
block|{
name|INTLPTR
name|junk
decl_stmt|;
name|nl_fail
operator|=
name|FALSE
expr_stmt|;
name|junk
operator|=
name|expreval
argument_list|(
operator|(
name|EXPR
operator|)
name|eqnwalk
operator|->
name|stmt
argument_list|,
name|noadtree
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl_fail
condition|)
block|{
name|EQNPTR
name|nueqn
decl_stmt|;
name|nueqn
operator|=
name|eqngen
argument_list|(
operator|(
name|EXPR
operator|)
name|eqnwalk
operator|->
name|stmt
argument_list|,
name|noadtree
argument_list|)
expr_stmt|;
name|nueqn
operator|->
name|next
operator|=
name|nl_eqns
expr_stmt|;
name|nl_eqns
operator|=
name|nueqn
expr_stmt|;
name|nl_fail
operator|=
name|FALSE
expr_stmt|;
block|}
name|depvarclean
argument_list|()
expr_stmt|;
name|incon_warn
operator|=
name|TRUE
expr_stmt|;
block|}
name|reqneval
argument_list|(
name|noadtree
operator|->
name|son
argument_list|)
expr_stmt|;
name|reqneval
argument_list|(
name|noadtree
operator|->
name|brother
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|eqneval
parameter_list|(
name|noadtree
parameter_list|)
name|NOADPTR
name|noadtree
decl_stmt|;
block|{
if|if
condition|(
name|when_bug
operator|&
literal|04
condition|)
name|bug_on
expr_stmt|;
name|reqneval
argument_list|(
name|noadtree
argument_list|)
expr_stmt|;
name|bug_off
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nl_eval
parameter_list|()
block|{
specifier|static
name|boolean
name|nl_succ
decl_stmt|;
name|INTLPTR
name|junk
decl_stmt|;
block|{
name|EQNPTR
name|nl_prev
decl_stmt|,
name|nl_curr
decl_stmt|,
name|nl_temp
decl_stmt|;
if|if
condition|(
name|when_bug
operator|&
literal|010
condition|)
name|bug_on
expr_stmt|;
name|nl_prev
operator|=
name|nl_curr
operator|=
name|nl_eqns
expr_stmt|;
name|nl_temp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|nl_curr
condition|)
block|{
name|nl_curr
operator|=
name|nl_prev
operator|->
name|next
expr_stmt|;
name|nl_prev
operator|->
name|next
operator|=
name|nl_temp
expr_stmt|;
name|nl_temp
operator|=
name|nl_prev
expr_stmt|;
name|nl_prev
operator|=
name|nl_curr
expr_stmt|;
block|}
name|nl_eqns
operator|=
name|nl_temp
expr_stmt|;
name|nl_succ
operator|=
name|TRUE
expr_stmt|;
block|}
while|while
condition|(
name|nl_eqns
operator|&&
name|nl_succ
condition|)
block|{
name|EQNPTR
name|prev_eqn
decl_stmt|,
name|nl_walk
decl_stmt|;
name|EQNNODE
name|dummy_eqn
decl_stmt|;
name|dprintf
literal|"Retrying nonlinear equations\n"
block|)
empty_stmt|;
name|prev_eqn
operator|=
operator|&
name|dummy_eqn
expr_stmt|;
name|prev_eqn
operator|->
name|next
operator|=
name|nl_walk
operator|=
name|nl_eqns
expr_stmt|;
name|nl_succ
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|nl_walk
condition|)
block|{
name|nl_fail
operator|=
name|FALSE
expr_stmt|;
name|junk
operator|=
name|expreval
argument_list|(
name|nl_walk
operator|->
name|eqn
argument_list|,
name|nl_walk
operator|->
name|noad
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|junk
argument_list|)
expr_stmt|;
name|depvarclean
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nl_fail
condition|)
block|{
name|prev_eqn
operator|->
name|next
operator|=
name|nl_walk
operator|->
name|next
expr_stmt|;
name|tryfree
argument_list|(
name|nl_walk
argument_list|)
expr_stmt|;
name|nl_walk
operator|=
name|prev_eqn
operator|->
name|next
expr_stmt|;
name|nl_succ
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|prev_eqn
operator|=
name|nl_walk
expr_stmt|;
name|nl_walk
operator|=
name|nl_walk
operator|->
name|next
expr_stmt|;
block|}
block|}
name|nl_eqns
operator|=
name|dummy_eqn
operator|.
name|next
expr_stmt|;
block|}
end_function

begin_if
if|if
condition|(
name|nl_eqns
condition|)
block|{
name|EQNPTR
name|nl_walk
decl_stmt|,
name|nl_next
decl_stmt|;
name|dprintf
literal|"Nonlinear failure\n"
block|)
empty_stmt|;
end_if

begin_expr_stmt
name|nl_warn
operator|=
name|TRUE
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|nl_walk
operator|=
name|nl_eqns
init|;
name|nl_walk
condition|;
name|nl_walk
operator|=
name|nl_next
control|)
block|{
name|junk
operator|=
name|expreval
argument_list|(
name|nl_walk
operator|->
name|eqn
argument_list|,
name|nl_walk
operator|->
name|noad
argument_list|)
expr_stmt|;
name|intlfree
argument_list|(
name|junk
argument_list|)
expr_stmt|;
name|depvarclean
argument_list|()
expr_stmt|;
name|nl_next
operator|=
name|nl_walk
operator|->
name|next
expr_stmt|;
name|tryfree
argument_list|(
name|nl_walk
argument_list|)
expr_stmt|;
block|}
end_for

begin_empty_stmt
unit|} 	bug_off
empty_stmt|;
end_empty_stmt

begin_macro
unit|}  void
name|depvarkill
argument_list|()
end_macro

begin_block
block|{
comment|/* remove all unknown variables from depvarlist ... 	   no chance for them to be determined now  */
if|if
condition|(
operator|!
name|depvarlist
condition|)
return|return;
if|if
condition|(
name|when_bug
operator|&
literal|020
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"killing depvarlist\n"
argument_list|)
expr_stmt|;
name|depfree
argument_list|(
name|depvarlist
argument_list|)
expr_stmt|;
name|depvarlist
operator|=
name|NULL
expr_stmt|;
block|}
end_block

end_unit

