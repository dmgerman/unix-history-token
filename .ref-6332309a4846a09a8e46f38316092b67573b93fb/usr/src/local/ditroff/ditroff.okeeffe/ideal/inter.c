begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"inter.c	(CWI)	1.1	85/03/01"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ideal.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_function
name|boolean
name|llinter
parameter_list|(
name|x1
parameter_list|,
name|y1
parameter_list|,
name|x2
parameter_list|,
name|y2
parameter_list|,
name|z1
parameter_list|,
name|w1
parameter_list|,
name|z2
parameter_list|,
name|w2
parameter_list|,
name|alpha
parameter_list|,
name|beta
parameter_list|,
name|collinear
parameter_list|)
comment|/* if this function returns TRUE, 	/* then alpha[(x1,y1),(x2,y2)] = beta[(z1,w1),(z2,w2)] */
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|z1
decl_stmt|,
name|w1
decl_stmt|,
name|z2
decl_stmt|,
name|w2
decl_stmt|;
name|float
modifier|*
name|alpha
decl_stmt|;
name|float
modifier|*
name|beta
decl_stmt|;
name|boolean
modifier|*
name|collinear
decl_stmt|;
block|{
name|float
name|A1
decl_stmt|,
name|B1
decl_stmt|,
name|C1
decl_stmt|,
name|A2
decl_stmt|,
name|B2
decl_stmt|,
name|C2
decl_stmt|,
name|D
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|dprintf
literal|"(%f,%f) -- (%f,%f)\n"
operator|,
name|x1
operator|,
name|y1
operator|,
name|x2
operator|,
name|y2
block|)
function|;
end_function

begin_expr_stmt
name|dprintf
literal|"(%f,%f) -- (%f,%f)\n"
operator|,
name|z1
operator|,
name|w1
operator|,
name|z2
operator|,
name|w2
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|A1
operator|=
name|y1
operator|-
name|y2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|B1
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|C1
operator|=
operator|-
name|B1
operator|*
name|y1
operator|-
name|A1
operator|*
name|x1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|A2
operator|=
name|w1
operator|-
name|w2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|B2
operator|=
name|z2
operator|-
name|z1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|C2
operator|=
operator|-
name|B2
operator|*
name|w1
operator|-
name|A2
operator|*
name|z1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|D
operator|=
name|A1
operator|*
name|B2
operator|-
name|A2
operator|*
name|B1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|fabs
argument_list|(
name|D
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
operator|*
name|collinear
operator|=
name|arecollinear
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|z1
argument_list|,
name|w1
argument_list|)
expr_stmt|;
name|dprintf
literal|"%s\n"
operator|,
operator|(
operator|*
name|collinear
operator|)
condition|?
literal|"coincident"
else|:
literal|"disjoint"
block|)
empty_stmt|;
end_if

begin_return
return|return
operator|(
name|FALSE
operator|)
return|;
end_return

begin_expr_stmt
unit|} 	*
name|collinear
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x
operator|=
operator|(
name|B1
operator|*
name|C2
operator|-
name|B2
operator|*
name|C1
operator|)
operator|/
name|D
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|y
operator|=
operator|(
name|A2
operator|*
name|C1
operator|-
name|A1
operator|*
name|C2
operator|)
operator|/
name|D
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|fabs
argument_list|(
name|x2
operator|-
name|x1
argument_list|)
operator|>
name|EPSILON
condition|)
block|{
operator|*
name|alpha
operator|=
operator|(
name|x
operator|-
name|x1
operator|)
operator|/
operator|(
name|x2
operator|-
name|x1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|y2
operator|-
name|y1
argument_list|)
operator|>
name|EPSILON
condition|)
block|{
operator|*
name|alpha
operator|=
operator|(
name|y
operator|-
name|y1
operator|)
operator|/
operator|(
name|y2
operator|-
name|y1
operator|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: llinter: can't happen\n"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|fabs
argument_list|(
name|z2
operator|-
name|z1
argument_list|)
operator|>
name|EPSILON
condition|)
block|{
operator|*
name|beta
operator|=
operator|(
name|x
operator|-
name|z1
operator|)
operator|/
operator|(
name|z2
operator|-
name|z1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|w2
operator|-
name|w1
argument_list|)
operator|>
name|EPSILON
condition|)
block|{
operator|*
name|beta
operator|=
operator|(
name|y
operator|-
name|w1
operator|)
operator|/
operator|(
name|w2
operator|-
name|w1
operator|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ideal: llinter: can't happen\n"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|dprintf
literal|"intersection alpha = %f; beta = %f\n"
operator|,
operator|*
name|alpha
operator|,
operator|*
name|beta
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_return
return|return
operator|(
name|TRUE
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* llinter */
end_comment

begin_macro
unit|boolean
name|lcinter
argument_list|(
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|r
argument_list|,
argument|alpha1
argument_list|,
argument|theta1
argument_list|,
argument|alpha2
argument_list|,
argument|theta2
argument_list|)
end_macro

begin_comment
comment|/* if this function returns TRUE, 	/* then alpha1[(x1,y1),(x2,y2)] = (x0,y0) + r*cis(theta1) 	/* and alpha2[(x1,y1),(x2,y2)] = (x0,y0) + r*cis(theta2) */
end_comment

begin_decl_stmt
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|r
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
modifier|*
name|alpha1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
modifier|*
name|theta1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
modifier|*
name|alpha2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
modifier|*
name|theta2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|dx1
decl_stmt|,
name|dx2
decl_stmt|,
name|dy1
decl_stmt|,
name|dy2
decl_stmt|;
name|float
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|,
name|D
decl_stmt|;
name|dprintf
literal|"intersection parameters:\n"
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|dprintf
literal|"%f, %f -- %f, %f\n"
operator|,
name|x1
operator|,
name|y1
operator|,
name|x2
operator|,
name|y2
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|dprintf
literal|"%f, %f (%f)\n"
operator|,
name|x0
operator|,
name|y0
operator|,
name|r
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|r
operator|=
name|fabs
argument_list|(
name|r
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dx1
operator|=
name|x1
operator|-
name|x0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dx2
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dy1
operator|=
name|y1
operator|-
name|y0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dy2
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|A
operator|=
name|dx2
operator|*
name|dx2
operator|+
name|dy2
operator|*
name|dy2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dprintf
literal|"A=%f\n"
operator|,
name|A
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|A
operator|<
name|EPSILON
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|hypot
argument_list|(
name|dx1
argument_list|,
name|dy1
argument_list|)
operator|-
name|r
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
operator|*
name|alpha1
operator|=
operator|*
name|alpha2
operator|=
literal|0.0
expr_stmt|;
operator|*
name|theta1
operator|=
name|atan2
argument_list|(
name|dy1
argument_list|,
name|dx1
argument_list|)
expr_stmt|;
operator|*
name|theta2
operator|=
operator|*
name|theta1
operator|=
name|rprin
argument_list|(
operator|*
name|theta1
argument_list|)
expr_stmt|;
name|dprintf
literal|"alpha1 = alpha2 = %f theta1 = theta2 = %f\n"
operator|,
operator|*
name|alpha1
operator|,
operator|*
name|theta1
block|)
empty_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
end_if

begin_expr_stmt
unit|} 	B
operator|=
literal|2
operator|*
operator|(
name|dx1
operator|*
name|dx2
operator|+
name|dy1
operator|*
name|dy2
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|C
operator|=
name|dx1
operator|*
name|dx1
operator|+
name|dy1
operator|*
name|dy1
operator|-
name|r
operator|*
name|r
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|D
operator|=
name|B
operator|*
name|B
operator|-
literal|4
operator|*
name|A
operator|*
name|C
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dprintf
literal|"B=%f C=%f D=%f\n"
operator|,
name|B
operator|,
name|C
operator|,
name|D
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|D
operator|<
operator|-
name|EPSILON
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
end_if

begin_if
if|if
condition|(
name|fabs
argument_list|(
name|D
argument_list|)
operator|<
name|EPSILON
condition|)
name|D
operator|=
literal|0.0
expr_stmt|;
end_if

begin_expr_stmt
name|D
operator|=
name|sqrt
argument_list|(
name|D
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|alpha1
operator|=
operator|(
operator|-
name|B
operator|+
name|D
operator|)
operator|/
operator|(
literal|2.0
operator|*
name|A
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|theta1
operator|=
name|rprin
argument_list|(
name|atan2
argument_list|(
name|dy1
operator|+
operator|*
name|alpha1
operator|*
name|dy2
argument_list|,
name|dx1
operator|+
operator|*
name|alpha1
operator|*
name|dx2
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|alpha2
operator|=
operator|(
operator|-
name|B
operator|-
name|D
operator|)
operator|/
operator|(
literal|2.0
operator|*
name|A
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|theta2
operator|=
name|rprin
argument_list|(
name|atan2
argument_list|(
name|dy1
operator|+
operator|*
name|alpha2
operator|*
name|dy2
argument_list|,
name|dx1
operator|+
operator|*
name|alpha2
operator|*
name|dx2
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dprintf
literal|"intersection alpha1 = %f, theta1 = %f\n"
operator|,
operator|*
name|alpha1
operator|,
operator|*
name|theta1
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|dprintf
literal|"intersection alpha2 = %f, theta2 = %f\n"
operator|,
operator|*
name|alpha2
operator|,
operator|*
name|theta2
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_return
return|return
operator|(
name|TRUE
operator|)
return|;
end_return

begin_macro
unit|}  boolean
name|ccinter
argument_list|(
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|r0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|r1
argument_list|,
argument|theta1
argument_list|,
argument|phi1
argument_list|,
argument|theta2
argument_list|,
argument|phi2
argument_list|)
end_macro

begin_comment
comment|/* if this function returns TRUE, 	/* then (x0,y0) + r0*cis(theta1) = (x1,y1) + r1*cis(phi1) 	/* and (x0,y0) + r0*cis(theta2) = (x1,y1) + r1*cis(phi2) */
end_comment

begin_decl_stmt
name|float
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|r0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|r1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
modifier|*
name|theta1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
modifier|*
name|phi1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
modifier|*
name|theta2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
modifier|*
name|phi2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|xcoeff
decl_stmt|,
name|ycoeff
decl_stmt|, const;
name|float
name|u1
decl_stmt|,
name|v1
decl_stmt|,
name|u2
decl_stmt|,
name|v2
decl_stmt|;
name|boolean
name|lncrc
decl_stmt|;
name|dprintf
literal|"intersection parameters\n"
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|dprintf
literal|"%f %f (%f)\n"
operator|,
name|x0
operator|,
name|y0
operator|,
name|r0
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|dprintf
literal|"%f %f (%f)\n"
operator|,
name|x1
operator|,
name|y1
operator|,
name|r1
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|r0
operator|=
name|fabs
argument_list|(
name|r0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|r1
operator|=
name|fabs
argument_list|(
name|r1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xcoeff
operator|=
literal|2
operator|*
operator|(
name|x1
operator|-
name|x0
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ycoeff
operator|=
literal|2
operator|*
operator|(
name|y1
operator|-
name|y0
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
operator|=
name|r0
operator|*
name|r0
operator|-
name|x0
operator|*
name|x0
operator|-
name|y0
operator|*
name|y0
operator|-
name|r1
operator|*
name|r1
operator|+
name|x1
operator|*
name|x1
operator|+
name|y1
operator|*
name|y1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|fabs
argument_list|(
name|xcoeff
argument_list|)
operator|<
name|EPSILON
operator|&&
name|fabs
argument_list|(
name|ycoeff
argument_list|)
operator|<
name|EPSILON
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
end_if

begin_if
if|if
condition|(
name|fabs
argument_list|(
name|xcoeff
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|u1
operator|=
literal|0.0
expr_stmt|;
name|u2
operator|=
literal|1.0
expr_stmt|;
name|v1
operator|=
name|v2
operator|=
specifier|const
operator|/
name|ycoeff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|ycoeff
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|v1
operator|=
literal|0.0
expr_stmt|;
name|v2
operator|=
literal|1.0
expr_stmt|;
name|u1
operator|=
name|u2
operator|=
specifier|const
operator|/
name|xcoeff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
specifier|const
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|u1
operator|=
literal|0.0
expr_stmt|;
name|v1
operator|=
literal|0.0
expr_stmt|;
name|u2
operator|=
literal|1.0
expr_stmt|;
name|v2
operator|=
operator|(
specifier|const
operator|-
literal|1.0
operator|/
name|xcoeff
operator|)
operator|/
name|ycoeff
expr_stmt|;
block|}
else|else
block|{
name|u1
operator|=
literal|0.0
expr_stmt|;
name|v1
operator|=
specifier|const
operator|/
name|ycoeff
expr_stmt|;
name|u2
operator|=
specifier|const
operator|/
name|xcoeff
expr_stmt|;
name|v2
operator|=
literal|0.0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|lncrc
operator|=
name|lcinter
argument_list|(
name|u1
argument_list|,
name|v1
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|r1
argument_list|,
name|theta1
argument_list|,
name|phi1
argument_list|,
name|theta2
argument_list|,
name|phi2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|lncrc
condition|)
block|{
operator|*
name|phi1
operator|=
name|rprin
argument_list|(
operator|*
name|phi1
argument_list|)
expr_stmt|;
operator|*
name|phi2
operator|=
name|rprin
argument_list|(
operator|*
name|phi2
argument_list|)
expr_stmt|;
operator|*
name|theta1
operator|=
name|atan2
argument_list|(
name|y1
operator|+
name|r1
operator|*
name|sin
argument_list|(
operator|*
name|phi1
argument_list|)
operator|-
name|y0
argument_list|,
name|x1
operator|+
name|r1
operator|*
name|cos
argument_list|(
operator|*
name|phi1
argument_list|)
operator|-
name|x0
argument_list|)
expr_stmt|;
operator|*
name|theta2
operator|=
name|atan2
argument_list|(
name|y1
operator|+
name|r1
operator|*
name|sin
argument_list|(
operator|*
name|phi2
argument_list|)
operator|-
name|y0
argument_list|,
name|x1
operator|+
name|r1
operator|*
name|cos
argument_list|(
operator|*
name|phi2
argument_list|)
operator|-
name|x0
argument_list|)
expr_stmt|;
operator|*
name|theta1
operator|=
name|rprin
argument_list|(
operator|*
name|theta1
argument_list|)
expr_stmt|;
operator|*
name|theta2
operator|=
name|rprin
argument_list|(
operator|*
name|theta2
argument_list|)
expr_stmt|;
name|dprintf
literal|"intersection theta1 = %f phi1 = %f\n"
operator|,
operator|*
name|theta1
operator|,
operator|*
name|phi1
block|)
empty_stmt|;
end_if

begin_expr_stmt
name|dprintf
literal|"intersection theta2 = %f phi2 = %f\n"
operator|,
operator|*
name|theta2
operator|,
operator|*
name|phi2
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_return
return|return
operator|(
name|TRUE
operator|)
return|;
end_return

begin_return
unit|} else
return|return
operator|(
name|FALSE
operator|)
return|;
end_return

unit|}
end_unit

