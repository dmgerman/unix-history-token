begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * @(#)startup.c	1.1	%G%  *  * Startup file processing for the SUN Gremlin picture editor.  *  * Mark Opperman (opcode@monet.BERKELEY)  *  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|<vfont.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* imports from C */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports from path.c */
end_comment

begin_extern
extern|extern PSetPath(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from graphics files */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|font_types
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* normally "R", "I", "B", "S" */
end_comment

begin_extern
extern|extern font_sizes[];
end_extern

begin_comment
comment|/* normally 7, 10, 14, 24 */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|fontdir
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* font directory */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|stippledir
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stipple directory */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|stippletype
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stipple font type ("ug" or "cf") */
end_comment

begin_extern
extern|extern stipple_index[];
end_extern

begin_comment
comment|/* stipple font numbers */
end_comment

begin_comment
comment|/* imports from main.c */
end_comment

begin_extern
extern|extern Artmode;
end_extern

begin_comment
comment|/* point display size */
end_comment

begin_extern
extern|extern CBRUSH;
end_extern

begin_comment
comment|/* current brush */
end_comment

begin_extern
extern|extern CFONT;
end_extern

begin_comment
comment|/* current font */
end_comment

begin_extern
extern|extern CJUST;
end_extern

begin_comment
comment|/* current text justification */
end_comment

begin_extern
extern|extern CSIZE;
end_extern

begin_comment
comment|/* current size */
end_comment

begin_extern
extern|extern CSTIPPLE;
end_extern

begin_comment
comment|/* current stipple pattern */
end_comment

begin_extern
extern|extern Alignment;
end_extern

begin_comment
comment|/* point alignment indicator */
end_comment

begin_extern
extern|extern Adjustment;
end_extern

begin_comment
comment|/* point adjustment mode */
end_comment

begin_extern
extern|extern GravityOn;
end_extern

begin_comment
comment|/* gravity mode flag */
end_comment

begin_extern
extern|extern Gridon;
end_extern

begin_comment
comment|/* grid mode indicator */
end_comment

begin_extern
extern|extern SymbolicLines;
end_extern

begin_comment
comment|/* pr_vector OK for all lines */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|timeon_s
decl_stmt|,
name|timeon_ms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current set flash on rate */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|timeoff_s
decl_stmt|,
name|timeoff_ms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current set flash off rate */
end_comment

begin_comment
comment|/* locally defined variables */
end_comment

begin_define
define|#
directive|define
name|STon
parameter_list|(
name|s
parameter_list|)
value|(strncmp(s, "on", 2) == 0)
end_define

begin_decl_stmt
name|int
name|STERROR
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates error on startup */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lines
index|[]
init|=
block|{
literal|"broken"
block|,
literal|"dashed"
block|,
literal|"dotted"
block|,
literal|"medium"
block|,
literal|"narrow"
block|,
literal|"thick"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|lnum
index|[]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|1
block|,
literal|6
block|,
literal|5
block|,
literal|3
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|textpos
index|[
name|JUSTMODES
index|]
init|=
block|{
literal|"tl"
block|,
literal|"tc"
block|,
literal|"tr"
block|,
literal|"cl"
block|,
literal|"cc"
block|,
literal|"cr"
block|,
literal|"bl"
block|,
literal|"bc"
block|,
literal|"br"
block|,
literal|"lt"
block|,
literal|"ct"
block|,
literal|"rt"
block|,
literal|"lc"
block|,
literal|"rc"
block|,
literal|"lb"
block|,
literal|"cb"
block|,
literal|"rb"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|textmode
index|[
name|JUSTMODES
index|]
operator|=
block|{
name|TOPLEFT
block|,
name|TOPCENT
block|,
name|TOPRIGHT
block|,
name|CENTLEFT
block|,
name|CENTCENT
block|,
name|CENTRIGHT
block|,
name|BOTLEFT
block|,
name|BOTCENT
block|,
name|BOTRIGHT
block|,
name|TOPLEFT
block|,
name|TOPCENT
block|,
name|TOPRIGHT
block|,
name|CENTLEFT
block|,
name|CENTRIGHT
block|,
name|BOTLEFT
block|,
name|BOTCENT
block|,
name|BOTRIGHT
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fonts
index|[]
init|=
block|{
literal|"bold"
block|,
literal|"italics"
block|,
literal|"roman"
block|,
literal|"special"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|fnum
index|[]
operator|=
block|{
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|4
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The following are defined to allow creation of the command lookup table. */
end_comment

begin_extern
extern|extern ST1(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|ST2
argument_list|()
operator|,
name|ST3
argument_list|()
operator|,
name|ST4
argument_list|()
operator|,
name|STB
argument_list|()
operator|,
name|STI
argument_list|()
operator|,
name|STR
argument_list|()
operator|,
name|STS
argument_list|()
operator|,
name|STalign
argument_list|()
operator|,
name|STbrush
argument_list|()
operator|,
name|STflashoff
argument_list|()
operator|,
name|STflashon
argument_list|()
operator|,
name|STfont
argument_list|()
operator|,
name|STfontdir
argument_list|()
operator|,
name|STgravity
argument_list|()
operator|,
name|STgrid
argument_list|()
operator|,
name|SThadjust
argument_list|()
operator|,
name|STjustify
argument_list|()
operator|,
name|STlittlepoint
argument_list|()
operator|,
name|STmadjust
argument_list|()
operator|,
name|STpath
argument_list|()
operator|,
name|STsize
argument_list|()
operator|,
name|STstipple
argument_list|()
operator|,
name|STstipple1
argument_list|()
operator|,
name|STstipple2
argument_list|()
operator|,
name|STstipple3
argument_list|()
operator|,
name|STstipple4
argument_list|()
operator|,
name|STstipple5
argument_list|()
operator|,
name|STstipple6
argument_list|()
operator|,
name|STstipple7
argument_list|()
operator|,
name|STstipple8
argument_list|()
operator|,
name|STstippledir
argument_list|()
operator|,
name|STstippletype
argument_list|()
operator|,
name|STsymboliclines
argument_list|()
operator|,
name|STvadjust
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The following two arrays define the startup commands and the routines    that process them. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|startupcmds
index|[]
init|=
block|{
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"B"
block|,
literal|"I"
block|,
literal|"R"
block|,
literal|"S"
block|,
literal|"align"
block|,
literal|"brush"
block|,
literal|"flashoff"
block|,
literal|"flashon"
block|,
literal|"font"
block|,
literal|"fontdir"
block|,
literal|"gravity"
block|,
literal|"grid"
block|,
literal|"hadjust"
block|,
literal|"justify"
block|,
literal|"l1"
block|,
literal|"l2"
block|,
literal|"l3"
block|,
literal|"l4"
block|,
literal|"l5"
block|,
literal|"l6"
block|,
literal|"l7"
block|,
literal|"l8"
block|,
literal|"littlepoint"
block|,
literal|"madjust"
block|,
literal|"path"
block|,
literal|"size"
block|,
literal|"stipple"
block|,
literal|"stipple1"
block|,
literal|"stipple2"
block|,
literal|"stipple3"
block|,
literal|"stipple4"
block|,
literal|"stipple5"
block|,
literal|"stipple6"
block|,
literal|"stipple7"
block|,
literal|"stipple8"
block|,
literal|"stippledir"
block|,
literal|"stippletype"
block|,
literal|"symboliclines"
block|,
literal|"vadjust"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
operator|(
operator|*
operator|(
name|strtns
index|[]
operator|)
operator|)
operator|(
operator|)
operator|=
block|{
name|ST1
block|,
comment|/* set size 1 point size */
name|ST2
block|,
comment|/* set size 2 point size */
name|ST3
block|,
comment|/* set size 3 point size */
name|ST4
block|,
comment|/* set size 4 point size */
name|STB
block|,
comment|/* set B font type */
name|STI
block|,
comment|/* set I font type */
name|STR
block|,
comment|/* set R font type */
name|STS
block|,
comment|/* set S font type */
name|STalign
block|,
comment|/* set point alignment */
name|STbrush
block|,
comment|/* set brush */
name|STflashoff
block|,
comment|/* set current set flash off time */
name|STflashon
block|,
comment|/* set current set flash on time */
name|STfont
block|,
comment|/* set font */
name|STfontdir
block|,
comment|/* font directory */
name|STgravity
block|,
comment|/* toggle gravity */
name|STgrid
block|,
comment|/* toggle grid display */
name|SThadjust
block|,
comment|/* horizontal adjust */
name|STjustify
block|,
comment|/* text justification */
name|STstipple1
block|,
comment|/* set stipple #1 index equivalent */
name|STstipple2
block|,
comment|/* set stipple #2 index equivalent */
name|STstipple3
block|,
comment|/* set stipple #3 index equivalent */
name|STstipple4
block|,
comment|/* set stipple #4 index equivalent */
name|STstipple5
block|,
comment|/* set stipple #5 index equivalent */
name|STstipple6
block|,
comment|/* set stipple #6 index equivalent */
name|STstipple7
block|,
comment|/* set stipple #7 index equivalent */
name|STstipple8
block|,
comment|/* set stipple #8 index equivalent */
name|STlittlepoint
block|,
comment|/* point size */
name|STmadjust
block|,
comment|/* manhattan adjust */
name|STpath
block|,
comment|/* set path or toggle search mode */
name|STsize
block|,
comment|/* character size */
name|STstipple
block|,
comment|/* set stipple pattern */
name|STstipple1
block|,
comment|/* set stipple #1 index */
name|STstipple2
block|,
comment|/* set stipple #2 index */
name|STstipple3
block|,
comment|/* set stipple #3 index */
name|STstipple4
block|,
comment|/* set stipple #4 index */
name|STstipple5
block|,
comment|/* set stipple #5 index */
name|STstipple6
block|,
comment|/* set stipple #6 index */
name|STstipple7
block|,
comment|/* set stipple #7 index */
name|STstipple8
block|,
comment|/* set stipple #8 index */
name|STstippledir
block|,
comment|/* stipple directory */
name|STstippletype
block|,
comment|/* stipple font file name */
name|STsymboliclines
block|,
comment|/* toggle symbolic lines */
name|STvadjust
comment|/* vertical adjust */
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *  Check for .gremlinrc file(s) and process if found.  *  The only globally accessible routine in this file.  */
end_comment

begin_macro
name|STgremlinrc
argument_list|(
argument|altfile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|altfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alternate startup file */
end_comment

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|ino_t
name|home_inode
decl_stmt|,
name|cwd_inode
decl_stmt|;
name|char
name|home
index|[
literal|128
index|]
decl_stmt|;
comment|/* look in home directory */
name|sprintf
argument_list|(
name|home
argument_list|,
literal|"%s/.gremlinrc"
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|home
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|home_inode
operator|=
name|buf
operator|.
name|st_ino
expr_stmt|;
name|STstartup
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|home_inode
operator|=
literal|0
expr_stmt|;
comment|/* look in current directory */
name|fp
operator|=
name|fopen
argument_list|(
literal|".gremlinrc"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|cwd_inode
operator|=
name|buf
operator|.
name|st_ino
expr_stmt|;
if|if
condition|(
name|cwd_inode
operator|!=
name|home_inode
condition|)
comment|/* not in home directory */
name|STstartup
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* check for alternate startup file */
if|if
condition|(
operator|*
name|altfile
operator|!=
literal|'\0'
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|altfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|.
name|st_ino
operator|!=
name|home_inode
operator|)
operator|&&
operator|(
name|buf
operator|.
name|st_ino
operator|!=
name|cwd_inode
operator|)
condition|)
name|STstartup
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* end STgremlinrc */
end_comment

begin_expr_stmt
specifier|static
name|STerror
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|msg
index|[
literal|256
index|]
decl_stmt|;
name|STERROR
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"startup: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|TxPutMsg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end STerror */
end_comment

begin_comment
comment|/*  *  Do startup processing on open file referenced by fp.  */
end_comment

begin_expr_stmt
specifier|static
name|STstartup
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|s
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|,
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|buf
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|>
literal|255
condition|)
break|break;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|STcommand
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|s
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
literal|400
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end STstartup */
end_comment

begin_comment
comment|/*  *  Make a string lower case.  */
end_comment

begin_expr_stmt
name|STtolower
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
name|int
operator|)
operator|*
name|s
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
operator|*
name|s
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *  STlookup searches a table of strings to find one that matches a  *  given string.  *  *  If str is an unambiguous abbreviation for one of the entries  *  in table, then the index of the matching entry is returned.  *  If str is an abbreviation for more than one entry in table,  *  then -1 is returned.  If str doesn't match any entry, then  *  -2 is returned.  *  *  The search is carried out by using two pointers, one which moves  *  forward through table from its start, and one which moves backward  *  through table from its end.  The two pointers mark the range of  *  strings that match the portion of str that we have scanned.  When  *  all of the characters of str have been scanned, then the two  *  pointers better be identical.  */
end_comment

begin_expr_stmt
specifier|static
name|STlookup
argument_list|(
argument|str
argument_list|,
argument|table
argument_list|,
argument|next
argument_list|)
name|char
name|str
index|[]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Pointer to a string to be looked up */
end_comment

begin_expr_stmt
name|char
argument_list|*
operator|(
name|table
index|[]
operator|)
argument_list|;
comment|/* Pointer to an array of string pointers 				   which are the valid commands.  The strings 				   must be ordered monotonically (i.e. all 				   strings whose first characters are identical 				   must be adjacent in the table). */
name|int
operator|*
name|next
argument_list|;
comment|/* Index to delimiter after search */
block|{
name|char
modifier|*
modifier|*
name|bot
decl_stmt|,
modifier|*
modifier|*
name|top
decl_stmt|;
name|int
name|match
decl_stmt|,
name|index
decl_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
name|bot
operator|=
name|table
expr_stmt|;
for|for
control|(
name|top
operator|=
name|table
init|;
operator|*
name|top
operator|!=
name|NULL
condition|;
name|top
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|top
operator|==
name|bot
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|top
operator|--
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
condition|;
name|index
operator|++
control|)
block|{
operator|*
name|next
operator|=
name|index
expr_stmt|;
comment|/* Check for the end of string */
if|if
condition|(
name|Delimiter
argument_list|(
name|str
index|[
name|index
index|]
argument_list|)
condition|)
return|return
operator|(
operator|(
operator|(
name|bot
operator|==
name|top
operator|)
operator|||
name|Delimiter
argument_list|(
operator|(
operator|*
name|bot
operator|)
index|[
name|index
index|]
argument_list|)
operator|)
condition|?
name|match
else|:
operator|-
literal|1
operator|)
return|;
comment|/*  	 * Move bot up until the string it points to matches str  	 * in the index'th position.   	 * Make match refer to the index of bot in table. 	 */
while|while
condition|(
operator|(
operator|*
name|bot
operator|)
index|[
name|index
index|]
operator|!=
name|str
index|[
name|index
index|]
condition|)
block|{
if|if
condition|(
name|bot
operator|==
name|top
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|bot
operator|++
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
comment|/* Move top down until it matches */
while|while
condition|(
operator|(
operator|*
name|top
operator|)
index|[
name|index
index|]
operator|!=
name|str
index|[
name|index
index|]
condition|)
block|{
if|if
condition|(
name|bot
operator|==
name|top
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|top
operator|--
expr_stmt|;
block|}
block|}
block|}
end_expr_stmt

begin_comment
comment|/* end STlookup */
end_comment

begin_comment
comment|/*  *  This routine looks up and executes a startup command.  */
end_comment

begin_expr_stmt
specifier|static
name|STcommand
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|index
expr_stmt|;
specifier|register
name|char
modifier|*
name|save
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|next
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|line
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|line
operator|==
literal|'#'
operator|)
condition|)
return|return;
name|index
operator|=
name|STlookup
argument_list|(
name|save
operator|=
name|line
argument_list|,
name|startupcmds
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|line
operator|=
name|line
operator|+
name|next
expr_stmt|;
comment|/* skip to first non-blank */
while|while
condition|(
operator|(
operator|*
name|line
operator|==
literal|'\t'
operator|)
operator|||
operator|(
operator|*
name|line
operator|==
literal|' '
operator|)
condition|)
name|line
operator|++
expr_stmt|;
operator|(
operator|*
operator|(
name|strtns
index|[
name|index
index|]
operator|)
operator|)
operator|(
name|line
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ambigous command: %s"
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|STerror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
operator|==
operator|-
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unknown command: %s"
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|STerror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end STcommand */
end_comment

begin_comment
comment|/*  * This routine interprets the string starting at line  * as a positive integral numeric parameter.  The function  * returns the numeric equivalent or -1 it there is some  * error in interpreting the string.  * NOTE: expects line with at least one non-space character.  */
end_comment

begin_expr_stmt
specifier|static
name|STgetnum
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|char
name|num
index|[
literal|128
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|Delimiter
argument_list|(
operator|*
name|line
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|num
index|[
name|i
index|]
operator|=
operator|*
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|num
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|num
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end STgetnum */
end_comment

begin_expr_stmt
specifier|static
name|ST1
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|size
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|size
operator|=
name|STgetnum
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
operator|-
literal|1
condition|)
name|font_sizes
index|[
literal|0
index|]
operator|=
name|size
expr_stmt|;
else|else
name|STerror
argument_list|(
literal|"bad size 1"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|ST2
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|size
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|size
operator|=
name|STgetnum
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
operator|-
literal|1
condition|)
name|font_sizes
index|[
literal|1
index|]
operator|=
name|size
expr_stmt|;
else|else
name|STerror
argument_list|(
literal|"bad size 2"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|ST3
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|size
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|size
operator|=
name|STgetnum
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
operator|-
literal|1
condition|)
name|font_sizes
index|[
literal|2
index|]
operator|=
name|size
expr_stmt|;
else|else
name|STerror
argument_list|(
literal|"bad size 3"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|ST4
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|size
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|size
operator|=
name|STgetnum
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
operator|-
literal|1
condition|)
name|font_sizes
index|[
literal|3
index|]
operator|=
name|size
expr_stmt|;
else|else
name|STerror
argument_list|(
literal|"bad size 4"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STB
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
specifier|register
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|f
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|!
name|Delimiter
argument_list|(
operator|*
name|f
argument_list|)
condition|)
name|f
operator|++
operator|,
name|i
operator|++
expr_stmt|;
name|f
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|f
argument_list|,
name|line
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|font_types
index|[
name|BFONT
index|]
operator|=
name|f
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STI
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
specifier|register
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|f
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|!
name|Delimiter
argument_list|(
operator|*
name|f
argument_list|)
condition|)
name|f
operator|++
operator|,
name|i
operator|++
expr_stmt|;
name|f
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|f
argument_list|,
name|line
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|font_types
index|[
name|IFONT
index|]
operator|=
name|f
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STR
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
specifier|register
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|f
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|!
name|Delimiter
argument_list|(
operator|*
name|f
argument_list|)
condition|)
name|f
operator|++
operator|,
name|i
operator|++
expr_stmt|;
name|f
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|f
argument_list|,
name|line
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|font_types
index|[
name|RFONT
index|]
operator|=
name|f
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STS
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
specifier|register
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|f
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|!
name|Delimiter
argument_list|(
operator|*
name|f
argument_list|)
condition|)
name|f
operator|++
operator|,
name|i
operator|++
expr_stmt|;
name|f
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|f
argument_list|,
name|line
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|font_types
index|[
name|SFONT
index|]
operator|=
name|f
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STalign
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|a
expr_stmt|;
specifier|register
name|align
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|a
operator|=
name|STgetnum
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|<=
literal|0
condition|)
name|STerror
argument_list|(
literal|"bad alignment"
argument_list|)
expr_stmt|;
else|else
block|{
name|a
operator|>>=
literal|1
expr_stmt|;
while|while
condition|(
name|a
operator|!=
literal|0
condition|)
block|{
name|align
operator|<<=
literal|1
expr_stmt|;
name|a
operator|>>=
literal|1
expr_stmt|;
block|}
name|Alignment
operator|=
operator|(
name|align
operator|>
literal|512
operator|)
condition|?
literal|512
else|:
name|align
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|STbrush
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|newbrush
expr_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|STtolower
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* force argument to lower case */
if|if
condition|(
operator|(
name|newbrush
operator|=
name|STlookup
argument_list|(
name|line
argument_list|,
name|lines
argument_list|,
operator|&
name|index
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|CBRUSH
operator|=
name|lnum
index|[
name|newbrush
index|]
expr_stmt|;
else|else
name|STerror
argument_list|(
literal|"bad brush name"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STflashoff
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|flashoff
expr_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|flashoff
operator|=
name|STgetnum
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|flashoff
operator|==
operator|-
literal|1
condition|)
name|STerror
argument_list|(
literal|"bad flash off time"
argument_list|)
expr_stmt|;
else|else
block|{
name|timeoff_s
operator|=
name|flashoff
operator|/
literal|1000
expr_stmt|;
name|timeoff_ms
operator|=
name|flashoff
operator|%
literal|1000
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|STflashon
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|flashon
expr_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|flashon
operator|=
name|STgetnum
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|flashon
operator|==
operator|-
literal|1
condition|)
name|STerror
argument_list|(
literal|"bad flash on time"
argument_list|)
expr_stmt|;
else|else
block|{
name|timeon_s
operator|=
name|flashon
operator|/
literal|1000
expr_stmt|;
name|timeon_ms
operator|=
name|flashon
operator|%
literal|1000
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|STfont
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|font
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|STtolower
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* force argument to lower case */
if|if
condition|(
operator|(
name|font
operator|=
name|STlookup
argument_list|(
name|line
argument_list|,
name|fonts
argument_list|,
operator|&
name|index
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|CFONT
operator|=
name|fnum
index|[
name|font
index|]
expr_stmt|;
else|else
name|STerror
argument_list|(
literal|"bad font number"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STfontdir
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|!
name|Delimiter
argument_list|(
operator|*
name|line
argument_list|)
condition|)
name|fontdir
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|fontdir
index|[
operator|--
name|i
index|]
operator|!=
literal|'/'
condition|)
name|fontdir
index|[
operator|++
name|i
index|]
operator|=
literal|'/'
expr_stmt|;
name|fontdir
index|[
operator|++
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STgravity
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STtolower
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|GravityOn
operator|=
name|STon
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STgrid
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STtolower
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|Gridon
operator|=
name|STon
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|SThadjust
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STtolower
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|STon
argument_list|(
name|line
argument_list|)
condition|)
name|Adjustment
operator|=
name|HORZ
expr_stmt|;
elseif|else
if|if
condition|(
name|Adjustment
operator|==
name|HORZ
condition|)
name|Adjustment
operator|=
name|NOADJ
expr_stmt|;
comment|/*     Adjustment = (Adjustment == HORZ) ? NOADJ : HORZ;     */
block|}
end_block

begin_expr_stmt
specifier|static
name|STjustify
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|new
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|STtolower
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* force argument to lower case */
for|for
control|(
name|new
operator|=
literal|0
init|;
operator|(
name|strcmp
argument_list|(
name|line
argument_list|,
name|textpos
index|[
name|new
index|]
argument_list|)
operator|!=
literal|0
operator|)
condition|;
operator|++
name|new
control|)
block|{
if|if
condition|(
name|new
operator|>=
name|JUSTMODES
condition|)
block|{
name|STerror
argument_list|(
literal|"bad justification mode"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|CJUST
operator|=
name|textmode
index|[
name|new
index|]
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STlittlepoint
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*     Artmode = !Artmode;     */
name|STtolower
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|Artmode
operator|=
name|STon
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STmadjust
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STtolower
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* force argument to lower case */
if|if
condition|(
name|STon
argument_list|(
name|line
argument_list|)
condition|)
name|Adjustment
operator|=
name|MAN
expr_stmt|;
elseif|else
if|if
condition|(
name|Adjustment
operator|==
name|MAN
condition|)
name|Adjustment
operator|=
name|NOADJ
expr_stmt|;
comment|/*     Adjustment = (Adjustment == MAN) ? NOADJ : MAN;     */
block|}
end_block

begin_expr_stmt
specifier|static
name|STpath
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|PSetPath
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STsize
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|new
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|new
operator|=
name|STgetnum
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|new
operator|>
name|NSIZES
operator|)
condition|)
name|STerror
argument_list|(
literal|"bad font size"
argument_list|)
expr_stmt|;
else|else
name|CSIZE
operator|=
name|new
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstipple
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|newstipple
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|newstipple
operator|=
name|STgetnum
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newstipple
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|newstipple
operator|>
name|NSTIPPLES
operator|)
condition|)
name|STerror
argument_list|(
literal|"bad stipple number"
argument_list|)
expr_stmt|;
else|else
name|CSTIPPLE
operator|=
name|newstipple
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstipplenum
argument_list|(
name|line
argument_list|,
name|num
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|index
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
name|index
operator|=
name|STgetnum
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|index
operator|>=
name|NUM_DISPATCH
operator|)
condition|)
name|STerror
argument_list|(
literal|"bad stipple font index"
argument_list|)
expr_stmt|;
else|else
name|stipple_index
index|[
name|num
operator|-
literal|1
index|]
operator|=
name|index
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstipple1
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STstipplenum
argument_list|(
name|line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstipple2
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STstipplenum
argument_list|(
name|line
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstipple3
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STstipplenum
argument_list|(
name|line
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstipple4
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STstipplenum
argument_list|(
name|line
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstipple5
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STstipplenum
argument_list|(
name|line
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstipple6
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STstipplenum
argument_list|(
name|line
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstipple7
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STstipplenum
argument_list|(
name|line
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstipple8
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STstipplenum
argument_list|(
name|line
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstippledir
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|!
name|Delimiter
argument_list|(
operator|*
name|line
argument_list|)
condition|)
name|stippledir
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|stippledir
index|[
operator|--
name|i
index|]
operator|!=
literal|'/'
condition|)
name|stippledir
index|[
operator|++
name|i
index|]
operator|=
literal|'/'
expr_stmt|;
name|stippledir
index|[
operator|++
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STstippletype
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|!
name|Delimiter
argument_list|(
operator|*
name|line
argument_list|)
condition|)
name|stippletype
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|line
operator|++
expr_stmt|;
name|stippletype
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STsymboliclines
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*     SymbolicLines = !SymbolicLines;     */
name|STtolower
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|SymbolicLines
operator|=
name|STon
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|STvadjust
argument_list|(
name|line
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STtolower
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|STon
argument_list|(
name|line
argument_list|)
condition|)
name|Adjustment
operator|=
name|VERT
expr_stmt|;
elseif|else
if|if
condition|(
name|Adjustment
operator|==
name|VERT
condition|)
name|Adjustment
operator|=
name|NOADJ
expr_stmt|;
comment|/*     Adjustment = (Adjustment == VERT) ? NOADJ : VERT;     */
block|}
end_block

end_unit

