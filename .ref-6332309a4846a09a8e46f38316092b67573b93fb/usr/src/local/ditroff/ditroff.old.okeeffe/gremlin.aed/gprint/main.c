begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c	1.8	83/07/06  *  * Copyright -C- 1982 Barry S. Roitblat  *  *	This file contains the main and file system dependent routines  * for producing hard copy from gremlin files.  It is extensively modified  * from the vplot source.  */
end_comment

begin_include
include|#
directive|include
file|"gprint.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<vfont.h>
end_include

begin_define
define|#
directive|define
name|LPR
value|"/usr/ucb/lpr"
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports */
end_comment

begin_extern
extern|extern HGtline(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|HGArc
argument_list|()
operator|,
name|HGPutText
argument_list|()
operator|,
name|HGMove
argument_list|()
operator|,
name|HGSetFont
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern HGSetBrush(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|HGInitFont
argument_list|()
operator|,
name|HGPrintElt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|int
name|style
index|[]
decl_stmt|,
name|thick
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tfont
index|[]
decl_stmt|,
modifier|*
name|tsize
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* database imports */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|DBInit
argument_list|()
decl_stmt|,
modifier|*
name|DBRead
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|POINT
modifier|*
name|PTInit
argument_list|()
decl_stmt|,
modifier|*
name|PTMakePoint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linethickness
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* brush styles */
end_comment

begin_decl_stmt
name|int
name|linmod
init|=
name|SOLID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|obuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output buffer NumOfLin x DevRange/8 */
end_comment

begin_decl_stmt
name|int
name|bufsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output buffer size */
end_comment

begin_decl_stmt
name|int
name|lastx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lasty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|angle
decl_stmt|,
name|startx
decl_stmt|,
name|starty
decl_stmt|,
name|endx
decl_stmt|,
name|endy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|scale
init|=
literal|4.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables used to map gremlin screen */
end_comment

begin_decl_stmt
name|double
name|orgx
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* x and y origin of gremlin picture */
end_comment

begin_decl_stmt
name|double
name|orgy
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|pfp
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor of current picture */
end_comment

begin_decl_stmt
name|char
name|picture
index|[]
init|=
literal|"/usr/tmp/rastAXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|run
init|=
literal|13
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of 'a' in picture[] */
end_comment

begin_decl_stmt
name|int
name|DevRange
init|=
name|Vxlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* plot dimensions in pixels */
end_comment

begin_decl_stmt
name|int
name|DevRange8
init|=
name|Vxlen
operator|/
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|BytPrLin
init|=
name|Vbytperlin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bytes per raster line. (not DevRange8) */
end_comment

begin_decl_stmt
name|int
name|NumOfLin
init|=
name|Vylen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lparg
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index into lpargs */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lpargs
index|[
literal|50
index|]
init|=
block|{
literal|"lpr"
block|,
literal|"-Pvarian"
block|,
literal|"-v"
block|,
literal|"-s"
block|,
literal|"-r"
block|,
literal|"-J"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Orientation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variables used to print from font file */
end_comment

begin_decl_stmt
name|int
name|cfont
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|csize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|header
name|header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dispatch
name|dispatch
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bits
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fontdir
init|=
literal|"/usr/lib/vfont/"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fopen
argument_list|()
decl_stmt|;
name|ELT
modifier|*
name|PICTURE
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|POINT
modifier|*
name|p1
decl_stmt|,
name|pos
decl_stmt|;
name|char
modifier|*
name|file
index|[
literal|50
index|]
decl_stmt|,
name|string
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|char
name|c
decl_stmt|,
name|string1
index|[
literal|50
index|]
decl_stmt|,
name|string2
index|[
literal|50
index|]
decl_stmt|,
name|string3
index|[
literal|50
index|]
decl_stmt|,
name|string4
index|[
literal|50
index|]
decl_stmt|,
name|string5
index|[
literal|50
index|]
decl_stmt|,
name|string6
index|[
literal|50
index|]
decl_stmt|,
name|string7
index|[
literal|50
index|]
decl_stmt|,
name|string8
index|[
literal|50
index|]
decl_stmt|;
specifier|extern
name|int
name|cleanup
parameter_list|()
function_decl|;
name|float
name|mult
decl_stmt|;
name|int
name|WriteRaster
init|=
name|FALSE
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|brsh
decl_stmt|,
name|gfil
init|=
literal|0
decl_stmt|;
comment|/* Parse the command line. */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|--
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|arg
operator|=
operator|*
name|argv
operator|++
operator|)
operator|!=
literal|'-'
condition|)
name|file
index|[
name|gfil
operator|++
index|]
operator|=
name|arg
expr_stmt|;
else|else
switch|switch
condition|(
operator|*
operator|++
name|arg
condition|)
block|{
case|case
literal|'W'
case|:
comment|/* Print to wide (versatec) device */
name|DevRange
operator|=
name|Wxlen
expr_stmt|;
name|DevRange8
operator|=
name|Wxlen
operator|/
literal|8
expr_stmt|;
name|BytPrLin
operator|=
name|Wbytperlin
expr_stmt|;
name|NumOfLin
operator|=
name|Wylen
expr_stmt|;
name|lpargs
index|[
literal|1
index|]
operator|=
literal|"-Pversatec"
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* Print to narrow (varian) device */
name|DevRange
operator|=
name|Vxlen
expr_stmt|;
name|DevRange8
operator|=
name|Vxlen
operator|/
literal|8
expr_stmt|;
name|BytPrLin
operator|=
name|Vbytperlin
expr_stmt|;
name|NumOfLin
operator|=
name|Vylen
expr_stmt|;
name|lpargs
index|[
literal|1
index|]
operator|=
literal|"-Pvarian"
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* select size 1 */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tsize
index|[
literal|0
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
comment|/* select size 2 */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tsize
index|[
literal|1
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
comment|/* select size 3 */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tsize
index|[
literal|2
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
comment|/* select size 4 */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tsize
index|[
literal|3
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* select Roman font */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tfont
index|[
literal|0
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* select italics font */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tfont
index|[
literal|1
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* select bold font */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tfont
index|[
literal|2
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* select special font */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tfont
index|[
literal|3
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* select narrow brush width */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|0
index|]
operator|=
name|thick
index|[
literal|1
index|]
operator|=
name|thick
index|[
literal|3
index|]
operator|=
name|thick
index|[
literal|4
index|]
operator|=
name|brsh
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* select thick brush width */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|2
index|]
operator|=
name|brsh
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* select medium brush width */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|5
index|]
operator|=
name|brsh
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* send raster to standard output */
name|WriteRaster
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* select scale */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
operator|&&
name|argc
operator|--
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%f"
argument_list|,
operator|&
name|mult
argument_list|)
expr_stmt|;
name|scale
operator|*=
name|mult
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* prompt for font and size parameters */
name|printf
argument_list|(
literal|"Roman font name? (%s): "
argument_list|,
name|tfont
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string1
operator|!=
literal|'\0'
condition|)
name|tfont
index|[
literal|0
index|]
operator|=
name|string1
expr_stmt|;
name|printf
argument_list|(
literal|"Italic font name? (%s): "
argument_list|,
name|tfont
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string2
operator|!=
literal|'\0'
condition|)
name|tfont
index|[
literal|1
index|]
operator|=
name|string2
expr_stmt|;
name|printf
argument_list|(
literal|"Bold font name? (%s): "
argument_list|,
name|tfont
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string3
operator|!=
literal|'\0'
condition|)
name|tfont
index|[
literal|2
index|]
operator|=
name|string3
expr_stmt|;
name|printf
argument_list|(
literal|"Special font name? (%s): "
argument_list|,
name|tfont
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string4
operator|!=
literal|'\0'
condition|)
name|tfont
index|[
literal|3
index|]
operator|=
name|string4
expr_stmt|;
name|printf
argument_list|(
literal|"font size 1? (%s): "
argument_list|,
name|tsize
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string5
operator|!=
literal|'\0'
condition|)
name|tsize
index|[
literal|0
index|]
operator|=
name|string5
expr_stmt|;
name|printf
argument_list|(
literal|"font size 2? (%s): "
argument_list|,
name|tsize
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string6
operator|!=
literal|'\0'
condition|)
name|tsize
index|[
literal|1
index|]
operator|=
name|string6
expr_stmt|;
name|printf
argument_list|(
literal|"font size 3? (%s): "
argument_list|,
name|tsize
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string7
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string7
operator|!=
literal|'\0'
condition|)
name|tsize
index|[
literal|2
index|]
operator|=
name|string7
expr_stmt|;
name|printf
argument_list|(
literal|"font size 4? (%s): "
argument_list|,
name|tsize
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string8
operator|!=
literal|'\0'
condition|)
name|tsize
index|[
literal|3
index|]
operator|=
name|string8
expr_stmt|;
name|printf
argument_list|(
literal|"narrow brush size? (%d): "
argument_list|,
name|thick
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|0
index|]
operator|=
name|thick
index|[
literal|1
index|]
operator|=
name|thick
index|[
literal|3
index|]
operator|=
name|thick
index|[
literal|4
index|]
operator|=
name|brsh
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"medium brush size? (%d): "
argument_list|,
name|thick
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|5
index|]
operator|=
name|brsh
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"thick brush size? (%d): "
argument_list|,
name|thick
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|2
index|]
operator|=
name|brsh
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown switch: %c\n"
argument_list|,
operator|*
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|WriteRaster
condition|)
block|{
comment|/* over-ride dimension settings */
name|DevRange
operator|=
name|Vxlen
expr_stmt|;
comment|/* if printing to file to be gdumped */
name|DevRange8
operator|=
name|Vxlen
operator|/
literal|8
expr_stmt|;
name|BytPrLin
operator|=
name|DevRange8
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|picture
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obuf
operator|=
name|malloc
argument_list|(
name|bufsize
operator|=
name|NumOfLin
operator|*
name|DevRange8
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gprint: ran out of memory for output buffer\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gfil
operator|==
literal|0
condition|)
block|{
comment|/* no filename, use standard input */
name|file
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|gfil
operator|++
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|gfil
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|file
index|[
name|k
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
index|[
name|k
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gprint: can't open %s\n"
argument_list|,
name|file
index|[
name|k
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|k
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|arg
operator|=
name|rindex
argument_list|(
name|file
index|[
name|k
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|arg
operator|=
name|file
index|[
name|k
index|]
expr_stmt|;
else|else
name|arg
operator|++
expr_stmt|;
name|lpargs
index|[
name|lparg
operator|++
index|]
operator|=
name|arg
expr_stmt|;
block|}
block|}
else|else
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
name|lpargs
index|[
name|lparg
operator|++
index|]
operator|=
literal|"gremlin"
expr_stmt|;
block|}
comment|/* read picture file */
name|PICTURE
operator|=
name|DBRead
argument_list|(
name|fp
argument_list|,
operator|&
name|Orientation
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|PICTURE
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|WriteRaster
condition|)
block|{
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pfp
operator|=
name|fopen
argument_list|(
name|picture
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gprint: can't create %s\n"
argument_list|,
name|picture
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
name|i
operator|=
name|strlen
argument_list|(
name|picture
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|malloc
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gprint: ran out of memory\n"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|arg
argument_list|,
name|picture
argument_list|)
expr_stmt|;
name|lpargs
index|[
name|lparg
operator|++
index|]
operator|=
name|arg
expr_stmt|;
name|picture
index|[
name|run
index|]
operator|++
expr_stmt|;
name|cp2
operator|=
operator|&
name|obuf
index|[
name|bufsize
index|]
expr_stmt|;
for|for
control|(
name|cp1
operator|=
name|obuf
init|;
name|cp1
operator|<
name|cp2
condition|;
control|)
operator|*
name|cp1
operator|++
operator|=
literal|0
expr_stmt|;
name|e
operator|=
name|PICTURE
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|HGPrintElt
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* traverse picture;  print elements */
name|e
operator|=
name|DBNextElt
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WriteRaster
condition|)
comment|/* if -t then cut image length */
while|while
condition|(
operator|!
operator|*
operator|--
name|cp2
condition|)
empty_stmt|;
for|for
control|(
name|cp1
operator|=
name|obuf
init|;
name|cp1
operator|<
name|cp2
condition|;
control|)
block|{
comment|/* write file */
for|for
control|(
name|i
operator|=
name|DevRange8
init|;
name|i
operator|--
condition|;
name|cp1
operator|++
control|)
name|putc
argument_list|(
operator|*
name|cp1
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BytPrLin
operator|-
name|DevRange8
init|;
name|i
operator|--
condition|;
control|)
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|WriteRaster
condition|)
name|fclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|WriteRaster
condition|)
block|{
name|lpargs
index|[
name|lparg
index|]
operator|=
literal|0
expr_stmt|;
name|execv
argument_list|(
name|LPR
argument_list|,
name|lpargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gprint: can't exec %s\n"
argument_list|,
name|LPR
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{
do|do
name|unlink
argument_list|(
name|picture
argument_list|)
expr_stmt|;
do|while
condition|(
name|picture
index|[
name|run
index|]
operator|--
operator|!=
literal|'A'
condition|)
do|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Points should be in the range 0<= x< DevRange, 0<= y< NumOfLin.  * The origin is the top left-hand corner with increasing x towards the  * right and increasing y going down.  * The output array is NumOfLin x DevRange/8 pixels.  */
end_comment

begin_expr_stmt
name|point
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
specifier|register
name|int
name|x
operator|,
name|y
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|byte
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|x
operator|<
name|DevRange
operator|&&
operator|(
name|unsigned
operator|)
name|y
operator|<
name|NumOfLin
condition|)
block|{
name|byte
operator|=
name|y
operator|*
name|DevRange8
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
expr_stmt|;
name|obuf
index|[
name|byte
index|]
operator||=
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|07
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_block

end_unit

