begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)const.c	5.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree_ty.h"
end_include

begin_comment
comment|/*  * Const enters the definitions  * of the constant declaration  * part into the namelist.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PI1
end_ifndef

begin_macro
name|constbeg
argument_list|(
argument|lineofyconst
argument_list|,
argument|linenum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lineofyconst
decl_stmt|,
name|linenum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|bool
name|const_order
init|=
name|FALSE
decl_stmt|;
specifier|static
name|bool
name|const_seen
init|=
name|FALSE
decl_stmt|;
comment|/*  * this allows for multiple declaration  * parts, unless the "standard" option  * has been specified.  * If a routine segment is being compiled,  * do level one processing.  */
if|if
condition|(
operator|!
name|progseen
condition|)
name|level1
argument_list|()
expr_stmt|;
name|line
operator|=
name|lineofyconst
expr_stmt|;
if|if
condition|(
name|parts
index|[
name|cbn
index|]
operator|&
operator|(
name|TPRT
operator||
name|VPRT
operator||
name|RPRT
operator|)
condition|)
block|{
if|if
condition|(
name|opt
argument_list|(
literal|'s'
argument_list|)
condition|)
block|{
name|standard
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Constant declarations should precede type, var and routine declarations"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|const_order
condition|)
block|{
name|const_order
operator|=
name|TRUE
expr_stmt|;
name|warning
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Constant declarations should precede type, var and routine declarations"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|parts
index|[
name|cbn
index|]
operator|&
name|CPRT
condition|)
block|{
if|if
condition|(
name|opt
argument_list|(
literal|'s'
argument_list|)
condition|)
block|{
name|standard
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"All constants should be declared in one const part"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|const_seen
condition|)
block|{
name|const_seen
operator|=
name|TRUE
expr_stmt|;
name|warning
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"All constants should be declared in one const part"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|parts
index|[
name|cbn
index|]
operator||=
name|CPRT
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PI1
end_endif

begin_macro
name|constant
argument_list|(
argument|cline
argument_list|,
argument|cid
argument_list|,
argument|cdecl
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|cid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|tnode
modifier|*
name|cdecl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
ifdef|#
directive|ifdef
name|PI0
name|send
argument_list|(
name|REVCNST
argument_list|,
name|cline
argument_list|,
name|cid
argument_list|,
name|cdecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|line
operator|=
name|cline
expr_stmt|;
name|gconst
argument_list|(
name|cdecl
argument_list|)
expr_stmt|;
name|np
operator|=
name|enter
argument_list|(
name|defnl
argument_list|(
name|cid
argument_list|,
name|CONST
argument_list|,
name|con
operator|.
name|ctype
argument_list|,
name|con
operator|.
name|cival
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
name|np
operator|->
name|nl_flags
operator||=
name|NMOD
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PC
if|if
condition|(
name|cbn
operator|==
literal|1
condition|)
block|{
name|stabgconst
argument_list|(
name|cid
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|PC
ifdef|#
directive|ifdef
name|PTREE
block|{
name|pPointer
name|Const
init|=
name|ConstDecl
argument_list|(
name|cid
argument_list|,
name|cdecl
argument_list|)
decl_stmt|;
name|pPointer
modifier|*
name|Consts
decl_stmt|;
name|pSeize
argument_list|(
name|PorFHeader
index|[
name|nesting
index|]
argument_list|)
expr_stmt|;
name|Consts
operator|=
operator|&
operator|(
name|pDEF
argument_list|(
name|PorFHeader
index|[
name|nesting
index|]
argument_list|)
operator|.
name|PorFConsts
operator|)
expr_stmt|;
operator|*
name|Consts
operator|=
name|ListAppend
argument_list|(
operator|*
name|Consts
argument_list|,
name|Const
argument_list|)
expr_stmt|;
name|pRelease
argument_list|(
name|PorFHeader
index|[
name|nesting
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|con
operator|.
name|ctype
operator|==
name|NIL
condition|)
return|return;
if|if
condition|(
name|con
operator|.
name|ctype
operator|==
name|nl
operator|+
name|TSTR
condition|)
name|np
operator|->
name|ptr
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|nl
operator|*
operator|)
name|con
operator|.
name|cpval
expr_stmt|;
if|if
condition|(
name|isa
argument_list|(
name|con
operator|.
name|ctype
argument_list|,
literal|"i"
argument_list|)
condition|)
name|np
operator|->
name|range
index|[
literal|0
index|]
operator|=
name|con
operator|.
name|crval
expr_stmt|;
elseif|else
if|if
condition|(
name|isa
argument_list|(
name|con
operator|.
name|ctype
argument_list|,
literal|"d"
argument_list|)
condition|)
name|np
operator|->
name|real
operator|=
name|con
operator|.
name|crval
expr_stmt|;
ifdef|#
directive|ifdef
name|PC
if|if
condition|(
name|cbn
operator|==
literal|1
operator|&&
name|con
operator|.
name|ctype
operator|!=
name|NIL
condition|)
block|{
name|stabconst
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PI0
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|PI1
end_ifndef

begin_macro
name|constend
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Gconst extracts  * a constant declaration  * from the tree for it.  * only types of constants  * are integer, reals, strings  * and scalars, the first two  * being possibly signed.  */
end_comment

begin_macro
name|gconst
argument_list|(
argument|c_node
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|c_node
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|cn
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|negd
decl_stmt|,
name|sgnd
decl_stmt|;
name|long
name|ci
decl_stmt|;
name|con
operator|.
name|ctype
operator|=
name|NIL
expr_stmt|;
name|cn
operator|=
name|c_node
expr_stmt|;
name|negd
operator|=
name|sgnd
operator|=
literal|0
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|cn
operator|==
name|TR_NIL
operator|||
name|cn
operator|->
name|sign_const
operator|.
name|number
operator|==
name|TR_NIL
condition|)
return|return;
switch|switch
condition|(
name|cn
operator|->
name|tag
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"gconst"
argument_list|)
expr_stmt|;
case|case
name|T_MINUSC
case|:
name|negd
operator|=
literal|1
operator|-
name|negd
expr_stmt|;
case|case
name|T_PLUSC
case|:
name|sgnd
operator|++
expr_stmt|;
name|cn
operator|=
name|cn
operator|->
name|sign_const
operator|.
name|number
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|T_ID
case|:
name|np
operator|=
name|lookup
argument_list|(
name|cn
operator|->
name|char_const
operator|.
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NLNIL
condition|)
return|return;
if|if
condition|(
name|np
operator|->
name|class
operator|!=
name|CONST
condition|)
block|{
name|derror
argument_list|(
literal|"%s is a %s, not a constant as required"
argument_list|,
name|cn
operator|->
name|char_const
operator|.
name|cptr
argument_list|,
name|classes
index|[
name|np
operator|->
name|class
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|con
operator|.
name|ctype
operator|=
name|np
operator|->
name|type
expr_stmt|;
switch|switch
condition|(
name|classify
argument_list|(
name|np
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|TINT
case|:
name|con
operator|.
name|crval
operator|=
name|np
operator|->
name|range
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|TDOUBLE
case|:
name|con
operator|.
name|crval
operator|=
name|np
operator|->
name|real
expr_stmt|;
break|break;
case|case
name|TBOOL
case|:
case|case
name|TCHAR
case|:
case|case
name|TSCAL
case|:
name|con
operator|.
name|cival
operator|=
name|np
operator|->
name|value
index|[
literal|0
index|]
expr_stmt|;
name|con
operator|.
name|crval
operator|=
name|con
operator|.
name|cival
expr_stmt|;
break|break;
case|case
name|TSTR
case|:
name|con
operator|.
name|cpval
operator|=
operator|(
name|char
operator|*
operator|)
name|np
operator|->
name|ptr
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|NIL
case|:
name|con
operator|.
name|ctype
operator|=
name|NIL
expr_stmt|;
return|return;
default|default:
name|panic
argument_list|(
literal|"gconst2"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_CBINT
case|:
name|con
operator|.
name|crval
operator|=
name|a8tol
argument_list|(
name|cn
operator|->
name|char_const
operator|.
name|cptr
argument_list|)
expr_stmt|;
goto|goto
name|restcon
goto|;
case|case
name|T_CINT
case|:
name|con
operator|.
name|crval
operator|=
name|atof
argument_list|(
name|cn
operator|->
name|char_const
operator|.
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|con
operator|.
name|crval
operator|>
name|MAXINT
operator|||
name|con
operator|.
name|crval
operator|<
name|MININT
condition|)
block|{
name|derror
argument_list|(
literal|"Constant too large for this implementation"
argument_list|)
expr_stmt|;
name|con
operator|.
name|crval
operator|=
literal|0
expr_stmt|;
block|}
name|restcon
label|:
name|ci
operator|=
name|con
operator|.
name|crval
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
if|if
condition|(
name|bytes
argument_list|(
name|ci
argument_list|,
name|ci
argument_list|)
operator|<=
literal|2
condition|)
name|con
operator|.
name|ctype
operator|=
name|nl
operator|+
name|T2INT
expr_stmt|;
else|else
endif|#
directive|endif
name|con
operator|.
name|ctype
operator|=
name|nl
operator|+
name|T4INT
expr_stmt|;
break|break;
case|case
name|T_CFINT
case|:
name|con
operator|.
name|ctype
operator|=
name|nl
operator|+
name|TDOUBLE
expr_stmt|;
name|con
operator|.
name|crval
operator|=
name|atof
argument_list|(
name|cn
operator|->
name|char_const
operator|.
name|cptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CSTRNG
case|:
name|cp
operator|=
name|cn
operator|->
name|char_const
operator|.
name|cptr
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|con
operator|.
name|ctype
operator|=
name|nl
operator|+
name|T1CHAR
expr_stmt|;
name|con
operator|.
name|cival
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|con
operator|.
name|crval
operator|=
name|con
operator|.
name|cival
expr_stmt|;
break|break;
block|}
name|con
operator|.
name|ctype
operator|=
name|nl
operator|+
name|TSTR
expr_stmt|;
name|con
operator|.
name|cpval
operator|=
name|savestr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sgnd
condition|)
block|{
if|if
condition|(
name|isnta
argument_list|(
operator|(
expr|struct
name|nl
operator|*
operator|)
name|con
operator|.
name|ctype
argument_list|,
literal|"id"
argument_list|)
condition|)
name|derror
argument_list|(
literal|"%s constants cannot be signed"
argument_list|,
name|nameof
argument_list|(
operator|(
expr|struct
name|nl
operator|*
operator|)
name|con
operator|.
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|negd
condition|)
name|con
operator|.
name|crval
operator|=
operator|-
name|con
operator|.
name|crval
expr_stmt|;
name|ci
operator|=
name|con
operator|.
name|crval
expr_stmt|;
block|}
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PI0
end_ifndef

begin_expr_stmt
name|isconst
argument_list|(
name|cn
argument_list|)
specifier|register
expr|struct
name|tnode
operator|*
name|cn
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|cn
operator|==
name|TR_NIL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|cn
operator|->
name|tag
condition|)
block|{
case|case
name|T_MINUS
case|:
name|cn
operator|->
name|tag
operator|=
name|T_MINUSC
expr_stmt|;
name|cn
operator|->
name|sign_const
operator|.
name|number
operator|=
name|cn
operator|->
name|un_expr
operator|.
name|expr
expr_stmt|;
return|return
operator|(
name|isconst
argument_list|(
name|cn
operator|->
name|sign_const
operator|.
name|number
argument_list|)
operator|)
return|;
case|case
name|T_PLUS
case|:
name|cn
operator|->
name|tag
operator|=
name|T_PLUSC
expr_stmt|;
name|cn
operator|->
name|sign_const
operator|.
name|number
operator|=
name|cn
operator|->
name|un_expr
operator|.
name|expr
expr_stmt|;
return|return
operator|(
name|isconst
argument_list|(
name|cn
operator|->
name|sign_const
operator|.
name|number
argument_list|)
operator|)
return|;
case|case
name|T_VAR
case|:
if|if
condition|(
name|cn
operator|->
name|var_node
operator|.
name|qual
operator|!=
name|TR_NIL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cn
operator|->
name|tag
operator|=
name|T_ID
expr_stmt|;
name|cn
operator|->
name|char_const
operator|.
name|cptr
operator|=
name|cn
operator|->
name|var_node
operator|.
name|cptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_BINT
case|:
name|cn
operator|->
name|tag
operator|=
name|T_CBINT
expr_stmt|;
name|cn
operator|->
name|char_const
operator|.
name|cptr
operator|=
name|cn
operator|->
name|const_node
operator|.
name|cptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_INT
case|:
name|cn
operator|->
name|tag
operator|=
name|T_CINT
expr_stmt|;
name|cn
operator|->
name|char_const
operator|.
name|cptr
operator|=
name|cn
operator|->
name|const_node
operator|.
name|cptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_FINT
case|:
name|cn
operator|->
name|tag
operator|=
name|T_CFINT
expr_stmt|;
name|cn
operator|->
name|char_const
operator|.
name|cptr
operator|=
name|cn
operator|->
name|const_node
operator|.
name|cptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_STRNG
case|:
name|cn
operator|->
name|tag
operator|=
name|T_CSTRNG
expr_stmt|;
name|cn
operator|->
name|char_const
operator|.
name|cptr
operator|=
name|cn
operator|->
name|const_node
operator|.
name|cptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

