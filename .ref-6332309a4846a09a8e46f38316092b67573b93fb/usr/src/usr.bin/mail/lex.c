begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)lex.c	5.16 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"rcv.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/*  * Mail -- a mail program  *  * Lexical processing of commands.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prompt
init|=
literal|"& "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set up editing on the given file name.  * If isedit is true, we are considered to be editing the file,  * otherwise we are reading our mail which has signficance for  * mbox and so forth.  */
end_comment

begin_macro
name|setfile
argument_list|(
argument|name
argument_list|,
argument|isedit
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|ibuf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
specifier|static
name|int
name|shudclob
decl_stmt|;
specifier|extern
name|char
name|tempMesg
index|[]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
operator|(
name|ibuf
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|ibuf
argument_list|)
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFDIR
case|:
name|fclose
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EISDIR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|S_IFREG
case|:
break|break;
default|default:
name|fclose
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|edit
operator|&&
name|stb
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Looks like all will be well.  We must now relinquish our 	 * hold on the current set of stuff.  Must hold signals 	 * while we are reading the new file, else we will ruin 	 * the message[] data structure. 	 */
name|holdsigs
argument_list|()
expr_stmt|;
if|if
condition|(
name|shudclob
condition|)
block|{
if|if
condition|(
name|edit
condition|)
name|edstop
argument_list|()
expr_stmt|;
else|else
name|quit
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Copy the messages into /tmp 	 * and set pointers. 	 */
name|readonly
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|readonly
operator|++
expr_stmt|;
else|else
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|shudclob
condition|)
block|{
name|fclose
argument_list|(
name|itf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|otf
argument_list|)
expr_stmt|;
block|}
name|shudclob
operator|=
literal|1
expr_stmt|;
name|edit
operator|=
name|isedit
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|mailname
condition|)
name|strcpy
argument_list|(
name|mailname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|mailsize
operator|=
name|fsize
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|otf
operator|=
name|fopen
argument_list|(
name|tempMesg
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|tempMesg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|itf
operator|=
name|fopen
argument_list|(
name|tempMesg
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|tempMesg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|remove
argument_list|(
name|tempMesg
argument_list|)
expr_stmt|;
name|setptr
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|setmsize
argument_list|(
name|msgCount
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|relsesigs
argument_list|()
expr_stmt|;
name|sawcom
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interpret user commands one by one.  If standard input is not a tty,  * print no prompt.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|msgvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|commjmp
decl_stmt|;
end_decl_stmt

begin_macro
name|commands
argument_list|()
end_macro

begin_block
block|{
name|int
name|eofloop
decl_stmt|,
name|stop
argument_list|()
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
name|linebuf
index|[
name|LINESIZE
index|]
decl_stmt|;
name|int
name|hangup
argument_list|()
decl_stmt|,
name|contin
argument_list|()
decl_stmt|;
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcvmode
operator|&&
operator|!
name|sourcing
condition|)
block|{
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|stop
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hangup
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|setexit
argument_list|()
expr_stmt|;
comment|/* 		 * Print the prompt, if needed.  Clear out 		 * string space, and flush the output. 		 */
if|if
condition|(
operator|!
name|rcvmode
operator|&&
operator|!
name|sourcing
condition|)
return|return;
name|eofloop
operator|=
literal|0
expr_stmt|;
name|top
label|:
if|if
condition|(
operator|!
name|sourcing
operator|&&
name|value
argument_list|(
literal|"interactive"
argument_list|)
operator|!=
name|NOSTR
condition|)
block|{
name|setjmp
argument_list|(
name|commjmp
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|contin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sreset
argument_list|()
expr_stmt|;
comment|/* 		 * Read a line of commands from the current input 		 * and handle end of file specially. 		 */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|readline
argument_list|(
name|input
argument_list|,
operator|&
name|linebuf
index|[
name|n
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|loading
condition|)
return|return;
if|if
condition|(
name|sourcing
condition|)
block|{
name|unstack
argument_list|()
expr_stmt|;
goto|goto
name|more
goto|;
block|}
if|if
condition|(
name|value
argument_list|(
literal|"interactive"
argument_list|)
operator|!=
name|NOSTR
operator|&&
name|value
argument_list|(
literal|"ignoreeof"
argument_list|)
operator|!=
name|NOSTR
condition|)
block|{
if|if
condition|(
operator|++
name|eofloop
operator|<
literal|25
condition|)
block|{
name|printf
argument_list|(
literal|"Use \"quit\" to quit.\n"
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
block|}
if|if
condition|(
name|edit
condition|)
name|edstop
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
name|n
index|]
operator|!=
literal|'\\'
condition|)
break|break;
name|linebuf
index|[
name|n
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|execute
argument_list|(
name|linebuf
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|more
label|:
empty_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Execute a single command.  If the command executed  * is "quit," then return non-zero so that the caller  * will know to return back to main, if he cares.  * Contxt is non-zero if called while composing mail.  */
end_comment

begin_macro
name|execute
argument_list|(
argument|linebuf
argument_list|,
argument|contxt
argument_list|)
end_macro

begin_decl_stmt
name|char
name|linebuf
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|word
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|arglist
index|[
name|MAXARGC
index|]
decl_stmt|;
name|struct
name|cmd
modifier|*
name|com
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|muvec
index|[
literal|2
index|]
decl_stmt|;
name|int
name|edstop
argument_list|()
decl_stmt|,
name|e
decl_stmt|;
comment|/* 	 * Strip the white space away from the beginning 	 * of the command, then scan out a word, which 	 * consists of anything except digits and white space. 	 * 	 * Handle ! escapes differently to get the correct 	 * lexical conventions. 	 */
for|for
control|(
name|cp
operator|=
name|linebuf
init|;
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|sourcing
condition|)
block|{
name|printf
argument_list|(
literal|"Can't \"!\" while sourcing\n"
argument_list|)
expr_stmt|;
name|unstack
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|shell
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cp2
operator|=
name|word
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
name|index
argument_list|(
literal|" \t0123456789$^.:/-+*'\""
argument_list|,
operator|*
name|cp
argument_list|)
operator|==
name|NOSTR
condition|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Look up the command; if not found, bitch. 	 * Normally, a blank command would map to the 	 * first command in the table; while sourcing, 	 * however, we ignore blank lines to eliminate 	 * confusion. 	 */
if|if
condition|(
name|sourcing
operator|&&
operator|*
name|word
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|com
operator|=
name|lex
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NONE
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown command: \"%s\"\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|loading
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sourcing
condition|)
name|unstack
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * See if we should execute the command -- if a conditional 	 * we always execute it, otherwise, check the state of cond. 	 */
if|if
condition|(
operator|(
name|com
operator|->
name|c_argtype
operator|&
name|F
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|cond
operator|==
name|CRCV
operator|&&
operator|!
name|rcvmode
operator|||
name|cond
operator|==
name|CSEND
operator|&&
name|rcvmode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Special case so that quit causes a return to 	 * main, who will call the quit code directly. 	 * If we are in a source file, just unstack. 	 */
if|if
condition|(
name|com
operator|->
name|c_func
operator|==
name|edstop
operator|&&
name|sourcing
condition|)
block|{
if|if
condition|(
name|loading
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|unstack
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|edit
operator|&&
name|com
operator|->
name|c_func
operator|==
name|edstop
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Process the arguments to the command, depending 	 * on the type he expects.  Default to an error. 	 * If we are sourcing an interactive command, it's 	 * an error. 	 */
if|if
condition|(
operator|!
name|rcvmode
operator|&&
operator|(
name|com
operator|->
name|c_argtype
operator|&
name|M
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"May not execute \"%s\" while sending\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|loading
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sourcing
condition|)
name|unstack
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sourcing
operator|&&
name|com
operator|->
name|c_argtype
operator|&
name|I
condition|)
block|{
name|printf
argument_list|(
literal|"May not execute \"%s\" while sourcing\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|loading
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|unstack
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|readonly
operator|&&
name|com
operator|->
name|c_argtype
operator|&
name|W
condition|)
block|{
name|printf
argument_list|(
literal|"May not execute \"%s\" -- message file is read only\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|loading
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sourcing
condition|)
name|unstack
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|contxt
operator|&&
name|com
operator|->
name|c_argtype
operator|&
name|R
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot recursively invoke \"%s\"\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|e
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|com
operator|->
name|c_argtype
operator|&
operator|~
operator|(
name|F
operator||
name|P
operator||
name|I
operator||
name|M
operator||
name|T
operator||
name|W
operator||
name|R
operator|)
condition|)
block|{
case|case
name|MSGLIST
case|:
comment|/* 		 * A message list defaulting to nearest forward 		 * legal message. 		 */
if|if
condition|(
name|msgvec
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Illegal use of \"message list\"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|getmsglist
argument_list|(
name|cp
argument_list|,
name|msgvec
argument_list|,
name|com
operator|->
name|c_msgflag
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
operator|*
name|msgvec
operator|=
name|first
argument_list|(
name|com
operator|->
name|c_msgflag
argument_list|,
name|com
operator|->
name|c_msgmask
argument_list|)
expr_stmt|;
name|msgvec
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|msgvec
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No applicable messages\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|e
operator|=
call|(
modifier|*
name|com
operator|->
name|c_func
call|)
argument_list|(
name|msgvec
argument_list|)
expr_stmt|;
break|break;
case|case
name|NDMLIST
case|:
comment|/* 		 * A message list with no defaults, but no error 		 * if none exist. 		 */
if|if
condition|(
name|msgvec
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Illegal use of \"message list\"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|getmsglist
argument_list|(
name|cp
argument_list|,
name|msgvec
argument_list|,
name|com
operator|->
name|c_msgflag
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|e
operator|=
call|(
modifier|*
name|com
operator|->
name|c_func
call|)
argument_list|(
name|msgvec
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRLIST
case|:
comment|/* 		 * Just the straight string, with 		 * leading blanks removed. 		 */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
name|e
operator|=
call|(
modifier|*
name|com
operator|->
name|c_func
call|)
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAWLIST
case|:
comment|/* 		 * A vector of strings, in shell style. 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getrawlist
argument_list|(
name|cp
argument_list|,
name|arglist
argument_list|,
sizeof|sizeof
name|arglist
operator|/
sizeof|sizeof
expr|*
name|arglist
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|<
name|com
operator|->
name|c_minargs
condition|)
block|{
name|printf
argument_list|(
literal|"%s requires at least %d arg(s)\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|,
name|com
operator|->
name|c_minargs
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|>
name|com
operator|->
name|c_maxargs
condition|)
block|{
name|printf
argument_list|(
literal|"%s takes no more than %d arg(s)\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|,
name|com
operator|->
name|c_maxargs
argument_list|)
expr_stmt|;
break|break;
block|}
name|e
operator|=
call|(
modifier|*
name|com
operator|->
name|c_func
call|)
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOLIST
case|:
comment|/* 		 * Just the constant zero, for exiting, 		 * eg. 		 */
name|e
operator|=
call|(
modifier|*
name|com
operator|->
name|c_func
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown argtype"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Exit the current source file on 	 * error. 	 */
if|if
condition|(
name|e
operator|&&
name|loading
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|e
operator|&&
name|sourcing
condition|)
name|unstack
argument_list|()
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|c_func
operator|==
name|edstop
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|value
argument_list|(
literal|"autoprint"
argument_list|)
operator|!=
name|NOSTR
operator|&&
name|com
operator|->
name|c_argtype
operator|&
name|P
condition|)
if|if
condition|(
operator|(
name|dot
operator|->
name|m_flag
operator|&
name|MDELETED
operator|)
operator|==
literal|0
condition|)
block|{
name|muvec
index|[
literal|0
index|]
operator|=
name|dot
operator|-
operator|&
name|message
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|muvec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|type
argument_list|(
name|muvec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sourcing
operator|&&
operator|(
name|com
operator|->
name|c_argtype
operator|&
name|T
operator|)
operator|==
literal|0
condition|)
name|sawcom
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * When we wake up after ^Z, reprint the prompt.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|contin
argument_list|(
argument|s
argument_list|)
end_macro

begin_block
block|{
name|longjmp
argument_list|(
name|commjmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Branch here on hangup signal and simulate "exit".  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|hangup
argument_list|(
argument|s
argument_list|)
end_macro

begin_block
block|{
comment|/* nothing to do? */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set the size of the message vector used to construct argument  * lists to message list functions.  */
end_comment

begin_macro
name|setmsize
argument_list|(
argument|sz
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|msgvec
operator|!=
literal|0
condition|)
name|cfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msgvec
argument_list|)
expr_stmt|;
name|msgvec
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|sz
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|msgvec
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Find the correct command in the command table corresponding  * to the passed command "word"  */
end_comment

begin_function
name|struct
name|cmd
modifier|*
name|lex
parameter_list|(
name|word
parameter_list|)
name|char
name|word
index|[]
decl_stmt|;
block|{
specifier|register
name|struct
name|cmd
modifier|*
name|cp
decl_stmt|;
specifier|extern
name|struct
name|cmd
name|cmdtab
index|[]
decl_stmt|;
for|for
control|(
name|cp
operator|=
operator|&
name|cmdtab
index|[
literal|0
index|]
init|;
name|cp
operator|->
name|c_name
operator|!=
name|NOSTR
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isprefix
argument_list|(
name|word
argument_list|,
name|cp
operator|->
name|c_name
argument_list|)
condition|)
return|return
operator|(
name|cp
operator|)
return|;
return|return
operator|(
name|NONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if as1 is a valid prefix of as2.  * Return true if yep.  */
end_comment

begin_macro
name|isprefix
argument_list|(
argument|as1
argument_list|,
argument|as2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|as1
decl_stmt|,
modifier|*
name|as2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|s1
operator|=
name|as1
expr_stmt|;
name|s2
operator|=
name|as2
expr_stmt|;
while|while
condition|(
operator|*
name|s1
operator|++
operator|==
operator|*
name|s2
condition|)
if|if
condition|(
operator|*
name|s2
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
operator|*
operator|--
name|s1
operator|==
literal|'\0'
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The following gets called on receipt of an interrupt.  This is  * to abort printout of a command, mainly.  * Dispatching here when command() is inactive crashes rcv.  * Close all open files except 0, 1, 2, and the temporary.  * Also, unstack all source files.  */
end_comment

begin_decl_stmt
name|int
name|inithdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* am printing startup headers */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_NFILE
end_ifdef

begin_expr_stmt
specifier|static
name|_fwalk
argument_list|(
name|function
argument_list|)
specifier|register
name|int
argument_list|(
operator|*
name|function
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|iop
decl_stmt|;
for|for
control|(
name|iop
operator|=
name|_iob
init|;
name|iop
operator|<
name|_iob
operator|+
name|_NFILE
condition|;
name|iop
operator|++
control|)
call|(
modifier|*
name|function
call|)
argument_list|(
name|iop
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|xclose
argument_list|(
name|iop
argument_list|)
specifier|register
name|FILE
operator|*
name|iop
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|iop
operator|==
name|stdin
operator|||
name|iop
operator|==
name|stdout
operator|||
name|iop
operator|==
name|stderr
operator|||
name|iop
operator|==
name|itf
operator|||
name|iop
operator|==
name|otf
condition|)
return|return;
if|if
condition|(
name|iop
operator|!=
name|pipef
condition|)
name|fclose
argument_list|(
name|iop
argument_list|)
expr_stmt|;
else|else
block|{
name|pclose
argument_list|(
name|pipef
argument_list|)
expr_stmt|;
name|pipef
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|stop
argument_list|(
argument|s
argument_list|)
end_macro

begin_block
block|{
name|noreset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|inithdr
condition|)
name|sawcom
operator|++
expr_stmt|;
name|inithdr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sourcing
condition|)
name|unstack
argument_list|()
expr_stmt|;
comment|/* 	 * Walk through all the open FILEs, applying xclose() to them 	 */
name|_fwalk
argument_list|(
name|xclose
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Interrupt\n"
argument_list|)
expr_stmt|;
name|reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Announce the presence of the current Mail version,  * give the message count, and print a header listing.  */
end_comment

begin_macro
name|announce
argument_list|()
end_macro

begin_block
block|{
name|int
name|vec
index|[
literal|2
index|]
decl_stmt|,
name|mdot
decl_stmt|;
name|mdot
operator|=
name|newfileinfo
argument_list|()
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
name|mdot
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dot
operator|=
operator|&
name|message
index|[
name|mdot
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|msgCount
operator|>
literal|0
operator|&&
name|value
argument_list|(
literal|"noheader"
argument_list|)
operator|==
name|NOSTR
condition|)
block|{
name|inithdr
operator|++
expr_stmt|;
name|headers
argument_list|(
name|vec
argument_list|)
expr_stmt|;
name|inithdr
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Announce information about the file we are editing.  * Return a likely place to set dot.  */
end_comment

begin_macro
name|newfileinfo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|message
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|u
decl_stmt|,
name|n
decl_stmt|,
name|mdot
decl_stmt|,
name|d
decl_stmt|,
name|s
decl_stmt|;
name|char
name|fname
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|zname
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|ename
decl_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|message
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|message
index|[
name|msgCount
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_flag
operator|&
name|MNEW
condition|)
break|break;
if|if
condition|(
name|mp
operator|>=
operator|&
name|message
index|[
name|msgCount
index|]
condition|)
for|for
control|(
name|mp
operator|=
operator|&
name|message
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|message
index|[
name|msgCount
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
operator|(
name|mp
operator|->
name|m_flag
operator|&
name|MREAD
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|mp
operator|<
operator|&
name|message
index|[
name|msgCount
index|]
condition|)
name|mdot
operator|=
name|mp
operator|-
operator|&
name|message
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
else|else
name|mdot
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|d
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|message
index|[
literal|0
index|]
operator|,
name|n
operator|=
literal|0
operator|,
name|u
operator|=
literal|0
init|;
name|mp
operator|<
operator|&
name|message
index|[
name|msgCount
index|]
condition|;
name|mp
operator|++
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_flag
operator|&
name|MNEW
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|m_flag
operator|&
name|MREAD
operator|)
operator|==
literal|0
condition|)
name|u
operator|++
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_flag
operator|&
name|MDELETED
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_flag
operator|&
name|MSAVED
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|ename
operator|=
name|mailname
expr_stmt|;
if|if
condition|(
name|getfold
argument_list|(
name|fname
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|fname
argument_list|,
name|mailname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|zname
argument_list|,
literal|"+%s"
argument_list|,
name|mailname
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|ename
operator|=
name|zname
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\"%s\": "
argument_list|,
name|ename
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgCount
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"1 message"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d messages"
argument_list|,
name|msgCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d new"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|-
name|n
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d unread"
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d deleted"
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d saved"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|readonly
condition|)
name|printf
argument_list|(
literal|" [Read only]"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|mdot
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Print the current version number.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|pversion
argument_list|(
argument|e
argument_list|)
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|version
decl_stmt|;
name|printf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Load a file of user definitions.  */
end_comment

begin_macro
name|load
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|oldin
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|oldin
operator|=
name|input
expr_stmt|;
name|input
operator|=
name|in
expr_stmt|;
name|loading
operator|=
literal|1
expr_stmt|;
name|sourcing
operator|=
literal|1
expr_stmt|;
name|commands
argument_list|()
expr_stmt|;
name|loading
operator|=
literal|0
expr_stmt|;
name|sourcing
operator|=
literal|0
expr_stmt|;
name|input
operator|=
name|oldin
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

