begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)refer5.c	4.9 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"refer..c"
end_include

begin_define
define|#
directive|define
name|SAME
value|0
end_define

begin_define
define|#
directive|define
name|NFLAB
value|3000
end_define

begin_comment
comment|/* number of bytes to record all labels */
end_comment

begin_define
define|#
directive|define
name|NLABC
value|1000
end_define

begin_comment
comment|/* max number of labels */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sig
index|[
name|MXSIG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|bflab
index|[
name|NFLAB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|labtab
index|[
name|NLABC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lbp
init|=
name|bflab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|labc
index|[
name|NLABC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|stbuff
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prevsig
decl_stmt|;
end_decl_stmt

begin_macro
name|putsig
argument_list|(
argument|nf
argument_list|,
argument|flds
argument_list|,
argument|nref
argument_list|,
argument|nstline
argument_list|,
argument|endline
argument_list|,
argument|toindex
argument_list|)
end_macro

begin_comment
comment|/* choose signal style */
end_comment

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|,
modifier|*
name|nstline
decl_stmt|,
modifier|*
name|endline
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|t
index|[
literal|100
index|]
decl_stmt|,
name|t1
index|[
name|MXSIG
index|]
decl_stmt|,
name|t2
index|[
literal|100
index|]
decl_stmt|,
name|format
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|sd
decl_stmt|,
modifier|*
name|stline
decl_stmt|;
name|int
name|addon
decl_stmt|,
name|another
init|=
literal|0
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|fhide
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|tag
decl_stmt|;
if|if
condition|(
name|labels
condition|)
block|{
if|if
condition|(
name|nf
operator|==
literal|0
condition|)
comment|/* old */
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%s%c"
argument_list|,
name|labtab
index|[
name|nref
index|]
argument_list|,
name|labc
index|[
name|nref
index|]
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keywant
condition|)
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%s"
argument_list|,
name|fpar
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|t1
argument_list|,
name|keywant
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|science
operator|&&
name|t
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|sd
operator|=
name|fpar
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|t2
argument_list|,
literal|'D'
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%s, %s"
argument_list|,
name|fpar
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|t1
argument_list|,
literal|'A'
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|format
argument_list|,
name|nmlen
operator|>
literal|0
condition|?
literal|"%%.%ds%%s"
else|:
literal|"%%s%%s"
argument_list|,
name|nmlen
argument_list|)
expr_stmt|;
comment|/* format is %s%s for default labels */
comment|/* or %.3s%s eg if wanted */
name|sd
operator|=
name|fpar
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|t2
argument_list|,
literal|'D'
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtlen
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|sdb
decl_stmt|;
for|for
control|(
name|sdb
operator|=
name|sd
init|;
operator|*
name|sd
condition|;
name|sd
operator|++
control|)
empty_stmt|;
name|sd
operator|=
name|sd
operator|-
name|dtlen
expr_stmt|;
if|if
condition|(
name|sd
operator|<
name|sdb
condition|)
name|sd
operator|=
name|sdb
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|t
argument_list|,
name|format
argument_list|,
name|fpar
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|t1
argument_list|,
literal|'A'
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keywant
condition|)
block|{
name|addon
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sd
operator|=
name|t
init|;
operator|*
name|sd
condition|;
name|sd
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
operator|--
name|sd
operator|==
literal|'-'
condition|)
block|{
name|addon
operator|=
literal|1
expr_stmt|;
operator|*
name|sd
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|keywant
operator|||
name|addon
operator|)
operator|&&
operator|!
name|science
condition|)
block|{
name|addch
argument_list|(
name|t
argument_list|,
name|keylet
argument_list|(
name|t
argument_list|,
name|nref
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tokeytab
argument_list|(
name|t
argument_list|,
name|nref
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%c%d%c"
argument_list|,
name|FLAG
argument_list|,
name|nref
argument_list|,
name|FLAG
argument_list|)
expr_stmt|;
block|}
name|another
operator|=
name|prefix
argument_list|(
literal|".["
argument_list|,
name|sd
operator|=
name|lookat
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|another
operator|&&
operator|(
name|strcmp
argument_list|(
literal|".[\n"
argument_list|,
name|sd
argument_list|)
operator|!=
name|SAME
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File %s line %d: punctuation ignored from: %s"
argument_list|,
name|Ifile
argument_list|,
name|Iline
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|sig
argument_list|)
operator|+
name|strlen
argument_list|(
name|t
argument_list|)
operator|)
operator|>
name|MXSIG
condition|)
name|err
argument_list|(
literal|"sig overflow (%d)"
argument_list|,
name|MXSIG
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|sig
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
name|EBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sig is now %s leng %d\n"
argument_list|,
name|sig
argument_list|,
name|strlen
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|trimnl
argument_list|(
name|nstline
argument_list|)
expr_stmt|;
name|trimnl
argument_list|(
name|endline
argument_list|)
expr_stmt|;
name|stline
operator|=
name|stbuff
expr_stmt|;
if|if
condition|(
name|prevsig
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|stline
argument_list|,
name|nstline
argument_list|)
expr_stmt|;
name|prevsig
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stline
index|[
literal|2
index|]
operator|||
name|endline
index|[
literal|2
index|]
condition|)
block|{
name|stline
operator|+=
literal|2
expr_stmt|;
name|endline
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|stline
operator|=
literal|"\\*([."
expr_stmt|;
name|endline
operator|=
literal|"\\*(.]"
expr_stmt|;
block|}
if|if
condition|(
name|science
condition|)
block|{
name|stline
operator|=
literal|" ("
expr_stmt|;
name|endline
operator|=
literal|")"
expr_stmt|;
block|}
if|if
condition|(
name|bare
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|another
condition|)
block|{
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"%s%s%s\n"
argument_list|,
name|stline
argument_list|,
name|sig
argument_list|,
name|endline
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|t1
argument_list|)
operator|>
name|MXSIG
condition|)
name|err
argument_list|(
literal|"t1 overflow (%d)"
argument_list|,
name|MXSIG
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|flout
argument_list|()
expr_stmt|;
name|sig
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|prevsig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fo
operator|==
name|fhide
condition|)
block|{
name|int
name|ch
decl_stmt|;
name|fclose
argument_list|(
name|fhide
argument_list|)
expr_stmt|;
name|fhide
operator|=
name|fopen
argument_list|(
name|hidenam
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fo
operator|=
name|ftemp
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fhide
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|fo
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fhide
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|hidenam
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|labels
condition|)
block|{
name|strcat
argument_list|(
name|sig
argument_list|,
literal|",\\|"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Seperate reference numbers with AFLAG 				 * for later sorting and condensing. 				 */
name|t1
index|[
literal|0
index|]
operator|=
name|AFLAG
expr_stmt|;
name|t1
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|sig
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fo
operator|==
name|ftemp
condition|)
block|{
comment|/* hide if need be */
name|sprintf
argument_list|(
name|hidenam
argument_list|,
literal|"/tmp/rj%dc"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|EBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hiding in %s\n"
argument_list|,
name|hidenam
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fhide
operator|=
name|fopen
argument_list|(
name|hidenam
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fhide
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|"Can't get scratch file %s"
argument_list|,
name|hidenam
argument_list|)
expr_stmt|;
name|fo
operator|=
name|fhide
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bare
operator|<
literal|2
condition|)
if|if
condition|(
name|nf
operator|>
literal|0
operator|&&
name|toindex
condition|)
name|fprintf
argument_list|(
name|fo
argument_list|,
literal|".ds [F %s%c"
argument_list|,
name|t
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|bare
operator|>
literal|0
condition|)
name|flout
argument_list|()
expr_stmt|;
if|#
directive|if
name|EBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sig is now %s\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
name|char
modifier|*
name|fpar
parameter_list|(
name|nf
parameter_list|,
name|flds
parameter_list|,
name|out
parameter_list|,
name|c
parameter_list|,
name|seq
parameter_list|,
name|prepend
parameter_list|)
name|char
modifier|*
name|flds
index|[]
decl_stmt|,
decl|*
name|out
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fnd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nf
condition|;
name|i
operator|++
control|)
comment|/* following if statement modified to cope with Q authors */
if|if
condition|(
operator|(
name|flds
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
name|c
operator|||
operator|(
name|c
operator|==
literal|'A'
operator|&&
name|flds
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'Q'
operator|)
operator|)
operator|&&
operator|++
name|fnd
operator|>=
name|seq
condition|)
block|{
name|c
operator|=
name|flds
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
comment|/* for titles use first word otherwise last */
if|if
condition|(
name|c
operator|==
literal|'T'
operator|||
name|c
operator|==
literal|'J'
operator|||
name|c
operator|==
literal|'Q'
condition|)
block|{
name|p
operator|=
name|flds
index|[
name|i
index|]
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|prefix
argument_list|(
literal|"A "
argument_list|,
name|p
argument_list|)
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|prefix
argument_list|(
literal|"An "
argument_list|,
name|p
argument_list|)
condition|)
name|p
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|prefix
argument_list|(
literal|"The "
argument_list|,
name|p
argument_list|)
condition|)
name|p
operator|+=
literal|4
expr_stmt|;
name|mycpy2
argument_list|(
name|out
argument_list|,
name|p
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
comment|/* if its not 'L' then use just the last word */
name|s
operator|=
name|p
operator|=
name|flds
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'L'
condition|)
block|{
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
empty_stmt|;
while|while
condition|(
name|p
operator|>
name|s
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|--
expr_stmt|;
block|}
comment|/* special wart for authors */
if|if
condition|(
name|c
operator|==
literal|'A'
operator|&&
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|','
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'('
operator|)
condition|)
block|{
name|p
operator|--
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|s
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|--
expr_stmt|;
name|mycpy
argument_list|(
name|out
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|out
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'A'
operator|&&
name|prepend
condition|)
name|initadd
argument_list|(
name|out
argument_list|,
name|flds
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|putkey
argument_list|(
argument|nf
argument_list|,
argument|flds
argument_list|,
argument|nref
argument_list|,
argument|keystr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|,
modifier|*
name|keystr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|t1
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|sf
decl_stmt|;
name|int
name|ctype
decl_stmt|,
name|i
decl_stmt|,
name|count
decl_stmt|;
name|fprintf
argument_list|(
name|fo
argument_list|,
literal|".\\\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|<=
literal|0
condition|)
name|fprintf
argument_list|(
name|fo
argument_list|,
literal|"%s%c%c"
argument_list|,
name|labtab
index|[
name|nref
index|]
argument_list|,
name|labc
index|[
name|nref
index|]
argument_list|,
name|sep
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|ctype
operator|=
operator|*
name|keystr
operator|++
condition|)
block|{
name|count
operator|=
name|atoi
argument_list|(
name|keystr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|keystr
operator|==
literal|'+'
condition|)
name|count
operator|=
literal|999
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sf
operator|=
name|fpar
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|t1
argument_list|,
name|ctype
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
literal|0
condition|)
break|break;
name|sf
operator|=
name|artskp
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fo
argument_list|,
literal|"%s%c"
argument_list|,
name|sf
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|fo
argument_list|,
literal|"%c%d%c%c"
argument_list|,
name|FLAG
argument_list|,
name|nref
argument_list|,
name|FLAG
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|tokeytab
argument_list|(
argument|t
argument_list|,
argument|nref
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|strcpy
argument_list|(
name|labtab
index|[
name|nref
index|]
operator|=
name|lbp
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|lbp
operator|++
condition|)
empty_stmt|;
block|}
end_block

begin_macro
name|keylet
argument_list|(
argument|t
argument_list|,
argument|nref
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|x
init|=
literal|'a'
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nref
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|labtab
index|[
name|i
index|]
argument_list|,
name|t
argument_list|)
operator|==
literal|0
condition|)
name|x
operator|=
name|labc
index|[
name|i
index|]
expr_stmt|;
block|}
name|tokeytab
argument_list|(
name|t
argument_list|,
name|nref
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbp
operator|-
name|bflab
operator|>
name|NFLAB
condition|)
name|err
argument_list|(
literal|"bflab overflow (%d)"
argument_list|,
name|NFLAB
argument_list|)
expr_stmt|;
if|if
condition|(
name|nref
operator|>
name|NLABC
condition|)
name|err
argument_list|(
literal|"nref in labc overflow (%d)"
argument_list|,
name|NLABC
argument_list|)
expr_stmt|;
if|#
directive|if
name|EBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lbp up to %d of %d\n"
argument_list|,
name|lbp
operator|-
name|bflab
argument_list|,
name|NFLAB
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|labc
index|[
name|nref
index|]
operator|=
name|x
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|mycpy
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|t
operator|&&
operator|*
name|t
operator|!=
literal|','
operator|&&
operator|*
name|t
operator|!=
literal|' '
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|mycpy2
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|&&
operator|(
name|c
operator|=
operator|*
name|t
operator|++
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
literal|'-'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|initadd
argument_list|(
argument|to
argument_list|,
argument|from
argument_list|,
argument|stop
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|,
modifier|*
name|stop
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|nalph
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|to
condition|)
name|to
operator|++
expr_stmt|;
while|while
condition|(
name|from
operator|<
name|stop
condition|)
block|{
name|c
operator|=
operator|*
name|from
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|nalph
condition|)
operator|*
name|to
operator|++
operator|=
literal|'.'
expr_stmt|;
name|nalph
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nalph
operator|++
operator|==
literal|0
condition|)
operator|*
name|to
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|to
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
modifier|*
name|articles
index|[]
init|=
block|{
literal|"the "
block|,
literal|"an "
block|,
literal|"a "
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|artskp
parameter_list|(
name|s
parameter_list|)
comment|/* skips over initial "a ", "an ", "the " in s */
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|r1
decl_stmt|,
modifier|*
name|r2
decl_stmt|;
for|for
control|(
name|p
operator|=
name|articles
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|r2
operator|=
name|s
expr_stmt|;
for|for
control|(
name|r1
operator|=
operator|*
name|p
init|;
operator|(
operator|(
operator|*
name|r1
operator|^
operator|*
name|r2
operator|)
operator|&
operator|~
literal|040
operator|)
operator|==
literal|0
condition|;
name|r1
operator|++
control|)
name|r2
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|r1
operator|==
literal|0
operator|&&
operator|*
name|r2
operator|!=
literal|0
condition|)
return|return
operator|(
name|r2
operator|)
return|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

end_unit

