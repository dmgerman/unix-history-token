begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/* **  TSET -- set terminal modes ** **	This program does sophisticated terminal initialization. **	I recommend that you include it in your .start_up or .login **	file to initialize whatever terminal you are on. ** **	There are several features: ** **	A special file or sequence (as controlled by the ttycap file) **	is sent to the terminal. ** **	Mode bits are set on a per-terminal_type basis (much better **	than UNIX itself).  This allows special delays, automatic **	tabs, etc. ** **	Erase and Kill characters can be set to whatever you want. **	Default is to change erase to control-H on a terminal which **	can overstrike, and leave it alone on anything else.  Kill **	is always left alone unless specifically requested.  These **	characters can be represented as "^X" meaning control-X; **	X is any character. ** **	Terminals which are dialups or plugboard types can be aliased **	to whatever type you may have in your home or office.  Thus, **	if you know that when you dial up you will always be on a **	TI 733, you can specify that fact to tset.  You can represent **	a type as "?type".  This will ask you what type you want it **	to be -- if you reply with just a newline, it will default **	to the type given. ** **	The htmp file, used by ex, etc., can be updated. ** **	The current terminal type can be queried. ** **	Usage: **		tset [-] [-EC] [-eC] [-kC] [-s] [-h] [-u]  **			[-d type] [-p type] [-b type] [-a type] **			[-Q] [-I] [type] ** **		In systems with environments, use: **			`tset -s ...` **		Actually, this doesn't work because of a shell bug. **		Instead, use: **			tset -s ...> tset.tmp **			source tset.tmp **			rm tset.tmp ** **	Positional Parameters: **		type -- the terminal type to force.  If this is **			specified, initialization is for this **			terminal type. ** **	Flags: **		- -- report terminal type.  Whatever type is **			decided on is reported.  If no other flags **			are stated, the only affect is to write **			the terminal type on the standard output. **		-EC -- set the erase character to C on all terminals **			except those which cannot backspace (e.g., **			a TTY 33).  C defaults to control-H. **		-eC -- set the erase character to C on all terminals. **			C defaults to control-H.  If neither -E or -e **			are specified, the erase character is set to **			control-H if the terminal can both backspace **			and not overstrike (e.g., a CRT).  If the erase **			character is NULL (zero byte), it will be reset **			to '#' if nothing else is specified. **		-kC -- set the kill character to C on all terminals. **			Default for C is control-X.  If not specified, **			the kill character is untouched; however, if **			not specified and the kill character is NULL **			(zero byte), the kill character is set to '@'. **		-iC -- reserved for setable interrupt character. **		-qC -- reserved for setable quit character. **		-d type -- set the dialup type to be type.  If the **			terminal type seems to be dialup, make it **			'type' instead.  There need not be a space **			between 'd' and 'type'. **		-p type -- ditto for a plugboard. **		-b type -- ditto for a bussiplexor. **		-a type -- ditto for an arpanet link. **		-h -- don't read htmp file.  Normally the terminal type **			is determined by reading the htmp file (unless **			-d or -p are specified).  This forces a read **			of the ttytype file -- useful when htmp is **			somehow wrong. **		-u -- don't update htmp.  It seemed like this should **			be put in.  Note that htmp is never actually **			written if there are no changes, so don't bother **			bother using this for efficiency reasons alone. **		-s -- output setenv commands for TERM.  This can be **			used with **				`tset -s ...` **			and is to be prefered to: **				setenv TERM `tset - ...` **			because -s sets the TERMCAP variable also. **		-Q -- be quiet.  don't output 'Erase set to' etc. **		-I -- don't do terminal initialization (is& if **			strings). ** **	Files: **		/etc/ttytype **			contains a terminal id -> terminal type **			mapping; used when -h, -d, or -p is used. **		/etc/termcap **			a terminal_type -> terminal_capabilities **			mapping. ** **	Return Codes: **		-1 -- couldn't open ttycap. **		1 -- bad terminal type, or standard output not tty. **		0 -- ok. ** **	Defined Constants: **		DIALUP -- the type code for a dialup port **		PLUGBOARD -- the code for a plugboard port. **		BUSSIPLEXER -- the code for a bussiplexer port. **		ARPANET -- the code for an arpanet port. **		BACKSPACE -- control-H, the default for -e. **		CONTROLX -- control-X, the default for -k. **		OLDERASE -- the system default erase character. **		OLDKILL -- the system default kill character. **		FILEDES -- the file descriptor to do the operation **			on, nominally 1 or 2. **		STDOUT -- the standard output file descriptor. **		UIDMASK -- the bit pattern to mask with the getuid() **			call to get just the user id. ** **	Requires: **		Routines to handle htmp, ttytype, and ttycap. ** **	Compilation Flags: **		PLUGBOARD -- if defined, accept the -p flag. **		BUSSIPLEXER -- if defined, accept the -b flag. **		FULLLOGIN -- if defined, login sets the ttytype from **			/etc/ttytype file. **		V6 -- if clear, use environments, not htmp. **			also use TIOCSETN rather than stty to avoid flushing **		GTTYN -- if set, uses generalized tty names. ** **	Trace Flags: **		none ** **	Diagnostics: **		Bad flag **			An incorrect option was specified. **		Cannot open ... **			The specified file could not be openned. **		Type ... unknown **			An unknown terminal type was specified. **		Cannot update htmp **			Cannot update htmp file when the standard **			output is not a terminal. **		Erase set to ... **			Telling that the erase character has been **			set to the specified character. **		Kill set to ... **			Ditto for kill **		Erase is ...    Kill is ... **			Tells that the erase/kill characters were **			wierd before, but they are being left as-is. **		Not a terminal **			Set if FILEDES is not a terminal. ** **	Compilation Instructions: **		cc -n -O tset.c -lX **		mv a.out tset **		chown bin tset **		chmod 4755 tset ** **		where 'bin' should be whoever owns the 'htmp' file. **		If 'htmp' is 666, then tset need not be setuid. ** **	Author: **		Eric Allman **		Electronics Research Labs **		U.C. Berkeley ** **	History: **		10/79 -- '-s' option extended to handle TERMCAP **			variable, set noglob, quote the entry, **			and know about the Bourne shell.  Terminal **			initialization moved to before any information **			output so screen clears would not screw you. **			'-Q' option added. **		8/79 -- '-' option alone changed to only output **			type.  '-s' option added.  'VERSION7' **			changed to 'V6' for compatibility. **		12/78 -- modified for eventual migration to VAX/UNIX, **			so the '-' option is changed to output only **			the terminal type to STDOUT instead of **			FILEDES.  FULLLOGIN flag added. **		9/78 -- '-' and '-p' options added (now fully **			compatible with ttytype!), and spaces are **			permitted between the -d and the type. **		8/78 -- The sense of -h and -u were reversed, and the **			-f flag is dropped -- same effect is available **			by just stating the terminal type. **		10/77 -- Written. */
end_comment

begin_comment
comment|/* # define	FULLLOGIN	1 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|V6
end_ifndef

begin_define
define|#
directive|define
name|GTTYN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|BACKSPACE
value|('H'& 037)
end_define

begin_define
define|#
directive|define
name|CONTROLX
value|('X'& 037)
end_define

begin_define
define|#
directive|define
name|OLDERASE
value|'#'
end_define

begin_define
define|#
directive|define
name|OLDKILL
value|'@'
end_define

begin_define
define|#
directive|define
name|FILEDES
value|2
end_define

begin_define
define|#
directive|define
name|STDOUT
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_define
define|#
directive|define
name|UIDMASK
value|0377
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UIDMASK
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DIALUP
value|"sd"
end_define

begin_define
define|#
directive|define
name|PLUGBOARD
value|"sp"
end_define

begin_define
define|#
directive|define
name|BUSSIPLEXER
value|"sb"
end_define

begin_define
define|#
directive|define
name|ARPANET
value|"sa"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|GTTYN
end_ifdef

begin_typedef
typedef|typedef
name|char
modifier|*
name|ttyid_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NOTTY
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|char
name|ttyid_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NOTTY
value|'x'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|Erase_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new erase character */
end_comment

begin_decl_stmt
name|char
name|Kill_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new kill character */
end_comment

begin_decl_stmt
name|char
name|Specialerase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set => Erase_char only on terminals with backspace */
end_comment

begin_decl_stmt
name|ttyid_t
name|Ttyid
init|=
name|NOTTY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal identifier */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TtyType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of terminal */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DefType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default type if none other computed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DialType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* override type if dialup port */
end_comment

begin_decl_stmt
name|char
modifier|*
name|PlugType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* override type if plugboard port */
end_comment

begin_decl_stmt
name|char
modifier|*
name|BxType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* override type if bussiplexer port */
end_comment

begin_decl_stmt
name|char
modifier|*
name|AnType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* override type if arpanet port */
end_comment

begin_decl_stmt
name|int
name|Dash_u
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't update htmp */
end_comment

begin_decl_stmt
name|int
name|Dash_h
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't read htmp */
end_comment

begin_decl_stmt
name|int
name|DoSetenv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output setenv commands */
end_comment

begin_decl_stmt
name|int
name|BeQuiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* be quiet */
end_comment

begin_decl_stmt
name|int
name|NoInit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't output initialization string */
end_comment

begin_decl_stmt
name|int
name|Report
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report current type */
end_comment

begin_decl_stmt
name|int
name|Ureport
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report to user */
end_comment

begin_decl_stmt
name|int
name|RepOnly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report only */
end_comment

begin_decl_stmt
name|char
name|Usage
index|[]
init|=
literal|"usage: tset [-] [-r] [-s] [-eC] [-kC] [-d T] [-p T] [-b T] [-a T]\n\t[-Q] [-I] [-h] [-u] [type]\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Capbuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line from /etc/termcap for this TtyType */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Ttycap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* termcap line from termcap or environ */
end_comment

begin_struct
struct|struct
name|delay
block|{
name|int
name|d_delay
decl_stmt|;
name|int
name|d_bits
decl_stmt|;
block|}
struct|;
end_struct

begin_include
include|#
directive|include
file|"tset.delays.h"
end_include

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|sgttyb
name|mode
decl_stmt|;
name|struct
name|sgttyb
name|oldmode
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|auto
name|char
modifier|*
name|bufp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
specifier|extern
name|char
modifier|*
name|stypeof
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|V6
specifier|extern
name|char
modifier|*
name|hsgettype
parameter_list|()
function_decl|;
else|#
directive|else
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GTTYN
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
endif|#
directive|endif
name|char
name|bs_char
decl_stmt|;
name|int
name|csh
decl_stmt|;
comment|/* scan argument list and collect flags */
name|error
operator|=
literal|0
expr_stmt|;
name|command
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|RepOnly
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>=
literal|0
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* report current terminal type */
name|Report
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
comment|/* report to user */
name|Ureport
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'E'
case|:
comment|/* special erase: operate on all but TTY33 */
name|Specialerase
operator|++
expr_stmt|;
comment|/* explicit fall-through to -e case */
case|case
literal|'e'
case|:
comment|/* erase character */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|Erase_char
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'^'
operator|&&
name|p
index|[
literal|3
index|]
operator|!=
literal|'\0'
condition|)
name|Erase_char
operator|=
name|p
index|[
literal|3
index|]
operator|&
literal|037
expr_stmt|;
else|else
name|Erase_char
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
continue|continue;
case|case
literal|'k'
case|:
comment|/* kill character */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|Kill_char
operator|=
name|CONTROLX
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'^'
operator|&&
name|p
index|[
literal|3
index|]
operator|!=
literal|'\0'
condition|)
name|Kill_char
operator|=
name|p
index|[
literal|3
index|]
operator|&
literal|037
expr_stmt|;
else|else
name|Kill_char
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
comment|/* dialup type */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|DialType
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|argc
operator|<
literal|0
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|error
operator|++
expr_stmt|;
else|else
name|DialType
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
continue|continue;
ifdef|#
directive|ifdef
name|PLUGBOARD
case|case
literal|'p'
case|:
comment|/* plugboard type */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|PlugType
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|argc
operator|<
literal|0
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|error
operator|++
expr_stmt|;
else|else
name|PlugType
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUSSIPLEXER
case|case
literal|'b'
case|:
comment|/* bussiplexer type */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|BxType
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|argc
operator|<
literal|0
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|error
operator|++
expr_stmt|;
else|else
name|BxType
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARPANET
case|case
literal|'a'
case|:
comment|/* arpanet type */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|AnType
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|--
name|argc
operator|<
literal|0
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|error
operator|++
expr_stmt|;
else|else
name|AnType
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
endif|#
directive|endif
case|case
literal|'h'
case|:
comment|/* don't get type from htmp or env */
name|Dash_h
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
comment|/* don't update htmp */
name|Dash_u
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
comment|/* output setenv commands */
name|DoSetenv
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'Q'
case|:
comment|/* be quiet */
name|BeQuiet
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'I'
case|:
comment|/* no initialization */
name|NoInit
operator|++
expr_stmt|;
continue|continue;
default|default:
name|prs
argument_list|(
literal|"Bad flag "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* terminal type */
name|DefType
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|prs
argument_list|(
name|Usage
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* if dialup is specified, check ttytype not htmp */
if|if
condition|(
name|DialType
operator|==
literal|0
operator|&&
name|PlugType
operator|==
literal|0
operator|&&
name|BxType
operator|==
literal|0
operator|&&
name|AnType
operator|==
literal|0
condition|)
name|TtyType
operator|=
name|DefType
expr_stmt|;
ifndef|#
directive|ifndef
name|FULLLOGIN
else|else
name|Dash_h
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* if report only, say that we won't update htmp */
if|if
condition|(
name|RepOnly
condition|)
name|Dash_u
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|V6
comment|/* get current idea of terminal type from environment */
if|if
condition|(
operator|!
name|Dash_h
operator|&&
name|TtyType
operator|==
literal|0
condition|)
name|TtyType
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* determine terminal id if needed */
ifdef|#
directive|ifdef
name|V6
if|if
condition|(
name|Ttyid
operator|==
name|NOTTY
operator|&&
operator|(
name|TtyType
operator|==
literal|0
operator|||
operator|!
name|Dash_h
operator|||
operator|!
name|Dash_u
operator|)
condition|)
name|Ttyid
operator|=
name|ttyn
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|RepOnly
operator|&&
name|Ttyid
operator|==
name|NOTTY
operator|&&
operator|(
name|TtyType
operator|==
literal|0
operator|||
operator|!
name|Dash_h
operator|)
condition|)
name|Ttyid
operator|=
name|ttyname
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|V6
comment|/* get htmp if ever used */
if|if
condition|(
operator|!
name|Dash_u
operator|||
operator|(
name|TtyType
operator|==
literal|0
operator|&&
operator|!
name|Dash_h
operator|)
condition|)
block|{
comment|/* get htmp entry -- if error or wrong user use ttytype */
if|if
condition|(
name|Ttyid
operator|==
name|NOTTY
operator|||
name|hget
argument_list|(
name|Ttyid
argument_list|)
operator|<
literal|0
operator|||
name|hgettype
argument_list|()
operator|==
literal|0
operator|||
name|hgetuid
argument_list|()
operator|!=
operator|(
name|getuid
argument_list|()
operator|&
name|UIDMASK
operator|)
condition|)
name|Dash_h
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* find terminal type (if not already known) */
if|if
condition|(
name|TtyType
operator|==
literal|0
condition|)
block|{
comment|/* get type from /etc/ttytype or /etc/htmp */
if|if
condition|(
operator|!
name|Dash_h
condition|)
block|{
ifdef|#
directive|ifdef
name|V6
name|TtyType
operator|=
name|hsgettype
argument_list|()
expr_stmt|;
else|#
directive|else
name|TtyType
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|TtyType
operator|==
literal|0
condition|)
block|{
name|TtyType
operator|=
name|stypeof
argument_list|(
name|Ttyid
argument_list|)
expr_stmt|;
block|}
comment|/* check for dialup or plugboard override */
if|if
condition|(
name|DialType
operator|!=
literal|0
operator|&&
name|bequal
argument_list|(
name|TtyType
argument_list|,
name|DIALUP
argument_list|,
literal|2
argument_list|)
condition|)
name|TtyType
operator|=
name|DialType
expr_stmt|;
ifdef|#
directive|ifdef
name|PLUGBOARD
elseif|else
if|if
condition|(
name|PlugType
operator|!=
literal|0
operator|&&
name|bequal
argument_list|(
name|TtyType
argument_list|,
name|PLUGBOARD
argument_list|,
literal|2
argument_list|)
condition|)
name|TtyType
operator|=
name|PlugType
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUSSIPLEXER
elseif|else
if|if
condition|(
name|BxType
operator|!=
literal|0
operator|&&
name|bequal
argument_list|(
name|TtyType
argument_list|,
name|BUSSIPLEXER
argument_list|,
literal|2
argument_list|)
condition|)
name|TtyType
operator|=
name|BxType
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARPANET
elseif|else
if|if
condition|(
name|AnType
operator|!=
literal|0
operator|&&
name|bequal
argument_list|(
name|TtyType
argument_list|,
name|ARPANET
argument_list|,
literal|2
argument_list|)
condition|)
name|TtyType
operator|=
name|AnType
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|DefType
operator|!=
literal|0
condition|)
name|TtyType
operator|=
name|DefType
expr_stmt|;
block|}
comment|/* TtyType now contains a pointer to the type of the terminal */
comment|/* If the first character is '?', ask the user */
if|if
condition|(
name|TtyType
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|TtyType
operator|==
literal|'\0'
condition|)
name|TtyType
operator|=
literal|"dumb"
expr_stmt|;
name|prs
argument_list|(
literal|"TERM = ("
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
comment|/* read the terminal.  If not empty, set type */
name|i
operator|=
name|read
argument_list|(
literal|2
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|i
operator|--
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|TtyType
operator|=
name|buf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Ttycap
operator|==
literal|0
condition|)
block|{
comment|/* get terminal capabilities */
switch|switch
condition|(
name|tgetent
argument_list|(
name|Capbuf
argument_list|,
name|TtyType
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|prs
argument_list|(
literal|"Cannot open termcap file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|prs
argument_list|(
literal|"Type "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|" unknown\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Ttycap
operator|=
name|Capbuf
expr_stmt|;
block|}
comment|/* output startup string */
if|if
condition|(
operator|!
name|RepOnly
operator|&&
operator|!
name|NoInit
condition|)
block|{
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"is"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
name|prs
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"if"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
name|cat
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* let terminal settle down */
block|}
comment|/* set up environment for the shell we are using */
comment|/* (this code is rather heuristic) */
name|csh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DoSetenv
condition|)
block|{
ifndef|#
directive|ifndef
name|V6
if|if
condition|(
name|bequal
argument_list|(
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
argument_list|,
literal|"/bin/csh"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
endif|#
directive|endif
comment|/* running csh */
name|csh
operator|++
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"set noglob;\n"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|V6
block|}
else|else
block|{
comment|/* running system shell */
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"export TERMCAP TERM;\n"
argument_list|,
literal|21
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* report type if appropriate */
if|if
condition|(
name|DoSetenv
operator|||
name|Report
operator|||
name|Ureport
condition|)
block|{
comment|/* find first alias (if any) */
for|for
control|(
name|p
operator|=
name|Ttycap
init|;
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'|'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|':'
condition|)
name|p
operator|=
name|Ttycap
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|bufp
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'|'
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
name|i
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|DoSetenv
condition|)
block|{
if|if
condition|(
name|csh
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"setenv TERM "
argument_list|,
literal|12
argument_list|)
expr_stmt|;
else|else
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"TERM="
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Report
operator|||
name|DoSetenv
condition|)
block|{
name|write
argument_list|(
name|STDOUT
argument_list|,
name|bufp
argument_list|,
name|p
operator|-
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DoSetenv
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ureport
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|prs
argument_list|(
literal|"Terminal type is "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|DoSetenv
condition|)
block|{
for|for
control|(
name|p
operator|=
name|Ttycap
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
name|csh
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"setenv TERMCAP '"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"TERMCAP='"
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
name|Ttycap
argument_list|,
name|p
operator|-
name|Ttycap
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"';\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* reset noglob */
if|if
condition|(
name|csh
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"unset noglob;\n"
argument_list|,
literal|14
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* exit if report only mode */
if|if
condition|(
name|RepOnly
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtty
argument_list|(
name|FILEDES
argument_list|,
operator|&
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|prs
argument_list|(
literal|"Not a terminal\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bmove
argument_list|(
operator|&
name|mode
argument_list|,
operator|&
name|oldmode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
expr_stmt|;
comment|/* determine erase and kill characters */
if|if
condition|(
name|Specialerase
operator|&&
operator|!
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
name|Erase_char
operator|=
literal|0
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
name|p
operator|=
name|tgetstr
argument_list|(
literal|"bc"
argument_list|,
operator|&
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|bs_char
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
name|bs_char
operator|=
name|BACKSPACE
expr_stmt|;
else|else
name|bs_char
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Erase_char
operator|==
literal|0
operator|&&
operator|!
name|tgetflag
argument_list|(
literal|"os"
argument_list|)
condition|)
block|{
if|if
condition|(
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
operator|||
name|bs_char
operator|!=
literal|0
condition|)
name|Erase_char
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Erase_char
operator|<
literal|0
condition|)
name|Erase_char
operator|=
operator|(
name|bs_char
operator|!=
literal|0
operator|)
condition|?
name|bs_char
else|:
name|BACKSPACE
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|sg_erase
operator|==
literal|0
condition|)
name|mode
operator|.
name|sg_erase
operator|=
name|OLDERASE
expr_stmt|;
if|if
condition|(
name|Erase_char
operator|!=
literal|0
condition|)
name|mode
operator|.
name|sg_erase
operator|=
name|Erase_char
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|sg_kill
operator|==
literal|0
condition|)
name|mode
operator|.
name|sg_kill
operator|=
name|OLDKILL
expr_stmt|;
if|if
condition|(
name|Kill_char
operator|!=
literal|0
condition|)
name|mode
operator|.
name|sg_kill
operator|=
name|Kill_char
expr_stmt|;
comment|/* set modes */
name|setdelay
argument_list|(
literal|"dC"
argument_list|,
name|CRdelay
argument_list|,
name|CRbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dN"
argument_list|,
name|NLdelay
argument_list|,
name|NLbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dB"
argument_list|,
name|BSdelay
argument_list|,
name|BSbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dF"
argument_list|,
name|FFdelay
argument_list|,
name|FFbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dT"
argument_list|,
name|TBdelay
argument_list|,
name|TBbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"UC"
argument_list|)
operator|||
name|command
index|[
literal|0
index|]
operator|==
literal|'T'
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|LCASE
expr_stmt|;
elseif|else
if|if
condition|(
name|tgetflag
argument_list|(
literal|"LC"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|LCASE
expr_stmt|;
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|EVENP
operator||
name|ODDP
operator||
name|RAW
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|V6
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|CBREAK
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tgetflag
argument_list|(
literal|"EP"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|EVENP
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"OP"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|ODDP
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|.
name|sg_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
literal|0
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|EVENP
operator||
name|ODDP
expr_stmt|;
name|mode
operator|.
name|sg_flags
operator||=
name|CRMOD
operator||
name|ECHO
operator||
name|XTABS
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"NL"
argument_list|)
condition|)
comment|/* new line, not line feed */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|CRMOD
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"HD"
argument_list|)
condition|)
comment|/* half duplex */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"pt"
argument_list|)
condition|)
comment|/* print tabs */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|XTABS
expr_stmt|;
if|if
condition|(
operator|!
name|bequal
argument_list|(
operator|&
name|mode
argument_list|,
operator|&
name|oldmode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
condition|)
ifndef|#
directive|ifndef
name|V6
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
name|stty
argument_list|(
name|FILEDES
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* tell about changing erase and kill characters */
name|reportek
argument_list|(
literal|"Erase"
argument_list|,
name|mode
operator|.
name|sg_erase
argument_list|,
name|oldmode
operator|.
name|sg_erase
argument_list|,
name|OLDERASE
argument_list|)
expr_stmt|;
name|reportek
argument_list|(
literal|"Kill"
argument_list|,
name|mode
operator|.
name|sg_kill
argument_list|,
name|oldmode
operator|.
name|sg_kill
argument_list|,
name|OLDKILL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|V6
comment|/* update htmp */
if|if
condition|(
operator|!
name|Dash_u
condition|)
block|{
if|if
condition|(
name|Ttyid
operator|==
literal|0
condition|)
name|Ttyid
operator|=
name|ttyn
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ttyid
operator|==
literal|'x'
condition|)
name|prs
argument_list|(
literal|"Cannot update htmp\n"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* update htmp file only if changed */
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|Capbuf
argument_list|,
name|hsgettype
argument_list|()
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|hsettype
argument_list|(
name|Capbuf
index|[
literal|0
index|]
operator||
operator|(
name|Capbuf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|hput
argument_list|(
name|Ttyid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|reportek
argument_list|(
argument|name
argument_list|,
argument|new
argument_list|,
argument|old
argument_list|,
argument|def
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|old
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|new
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|def
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|o
decl_stmt|;
specifier|register
name|char
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|BeQuiet
condition|)
return|return;
name|o
operator|=
name|old
expr_stmt|;
name|n
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|n
operator|&&
name|n
operator|==
name|def
condition|)
return|return;
name|prs
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|n
condition|)
name|prs
argument_list|(
literal|" is "
argument_list|)
expr_stmt|;
else|else
name|prs
argument_list|(
literal|" set to "
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|040
condition|)
block|{
name|prs
argument_list|(
literal|"control-"
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|&
literal|037
operator|)
operator||
literal|0100
expr_stmt|;
block|}
name|p
operator|=
literal|"x\n"
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|prs
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setdelay
argument_list|(
argument|cap
argument_list|,
argument|dtab
argument_list|,
argument|bits
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delay
name|dtab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|delay
modifier|*
name|p
decl_stmt|;
comment|/* see if this capability exists at all */
name|i
operator|=
name|tgetnum
argument_list|(
name|cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* clear out the bits, replace with new ones */
operator|*
name|flags
operator|&=
operator|~
name|bits
expr_stmt|;
comment|/* scan dtab for first entry with adequate delay */
for|for
control|(
name|p
operator|=
name|dtab
init|;
name|p
operator|->
name|d_delay
operator|>=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|d_delay
operator|>=
name|i
condition|)
block|{
name|p
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* use last entry if none will do */
operator|*
name|flags
operator||=
operator|(
operator|--
name|p
operator|)
operator|->
name|d_bits
expr_stmt|;
block|}
end_block

begin_macro
name|prs
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|p
operator|=
name|q
operator|=
name|s
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|++
operator|!=
literal|0
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|write
argument_list|(
name|FILEDES
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cat
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|prs
argument_list|(
literal|"Cannot open "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|FILEDES
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bmove
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|length
expr_stmt|;
name|p
operator|=
name|from
expr_stmt|;
name|q
operator|=
name|to
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|bequal
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|a
expr_stmt|;
name|q
operator|=
name|b
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|q
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|GTTYN
end_ifdef

begin_function
name|char
modifier|*
name|stypeof
parameter_list|(
name|ttyid
parameter_list|)
name|char
modifier|*
name|ttyid
decl_stmt|;
block|{
specifier|static
name|char
name|typebuf
index|[
literal|3
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|ttyid
operator|==
name|NOTTY
condition|)
return|return
operator|(
literal|"un"
operator|)
return|;
name|f
operator|=
name|fopen
argument_list|(
literal|"/etc/ttytype"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"un"
operator|)
return|;
comment|/* split off end of name */
for|for
control|(
name|p
operator|=
name|q
operator|=
name|ttyid
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* scan the file */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|p
operator|=
name|q
operator|,
name|t
operator|=
operator|&
name|buf
index|[
literal|3
index|]
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
operator|,
name|t
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
operator|*
name|t
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'\n'
operator|||
operator|*
name|t
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|typebuf
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|typebuf
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|typebuf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|typebuf
operator|)
return|;
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|"un"
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

