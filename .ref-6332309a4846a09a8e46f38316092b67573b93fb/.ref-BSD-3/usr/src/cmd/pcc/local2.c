begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"mfile2"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_comment
comment|/* a lot of the machine dependent parts of the second pass */
end_comment

begin_define
define|#
directive|define
name|BITMASK
parameter_list|(
name|n
parameter_list|)
value|((1L<<n)-1)
end_define

begin_macro
name|where
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, line %d: "
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lineid
argument_list|(
argument|l
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* identify line l and file fn */
name|printf
argument_list|(
literal|"#	line %d, file %s\n"
argument_list|,
name|l
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|eobl2
argument_list|()
end_macro

begin_block
block|{
name|OFFSZ
name|spoff
decl_stmt|;
comment|/* offset from stack pointer */
ifdef|#
directive|ifdef
name|FORT
name|spoff
operator|=
name|maxoff
expr_stmt|;
if|if
condition|(
name|spoff
operator|>=
name|AUTOINIT
condition|)
name|spoff
operator|-=
name|AUTOINIT
expr_stmt|;
name|spoff
operator|/=
name|SZCHAR
expr_stmt|;
name|SETOFF
argument_list|(
name|spoff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	.set	.F%d,%ld\n"
argument_list|,
name|ftnno
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|extern
name|int
name|ftlab1
decl_stmt|,
name|ftlab2
decl_stmt|;
name|spoff
operator|=
name|maxoff
expr_stmt|;
if|if
condition|(
name|spoff
operator|>=
name|AUTOINIT
condition|)
name|spoff
operator|-=
name|AUTOINIT
expr_stmt|;
name|spoff
operator|/=
name|SZCHAR
expr_stmt|;
name|SETOFF
argument_list|(
name|spoff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|ftlab1
argument_list|)
expr_stmt|;
if|if
condition|(
name|spoff
operator|!=
literal|0
condition|)
if|if
condition|(
name|spoff
operator|<
literal|64
condition|)
name|printf
argument_list|(
literal|"	subl2	$%ld,sp\n"
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"	movab	-%ld(sp),sp\n"
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	jbr 	L%d\n"
argument_list|,
name|ftlab2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maxargs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|hoptab
block|{
name|int
name|opmask
decl_stmt|;
name|char
modifier|*
name|opstring
decl_stmt|;
block|}
name|ioptab
index|[]
init|=
block|{
name|ASG
name|PLUS
block|,
literal|"add"
block|,
name|ASG
name|MINUS
block|,
literal|"sub"
block|,
name|ASG
name|MUL
block|,
literal|"mul"
block|,
name|ASG
name|DIV
block|,
literal|"div"
block|,
name|ASG
name|OR
block|,
literal|"bis"
block|,
name|ASG
name|ER
block|,
literal|"xor"
block|,
name|ASG
name|AND
block|,
literal|"bic"
block|,
name|PLUS
block|,
literal|"add"
block|,
name|MINUS
block|,
literal|"sub"
block|,
name|MUL
block|,
literal|"mul"
block|,
name|DIV
block|,
literal|"div"
block|,
name|OR
block|,
literal|"bis"
block|,
name|ER
block|,
literal|"xor"
block|,
name|AND
block|,
literal|"bic"
block|,
operator|-
literal|1
block|,
literal|""
block|}
struct|;
end_struct

begin_macro
name|hopcode
argument_list|(
argument|f
argument_list|,
argument|o
argument_list|)
end_macro

begin_block
block|{
comment|/* output the appropriate string from the above table */
specifier|register
name|struct
name|hoptab
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|ioptab
init|;
name|q
operator|->
name|opmask
operator|>=
literal|0
condition|;
operator|++
name|q
control|)
block|{
if|if
condition|(
name|q
operator|->
name|opmask
operator|==
name|o
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|q
operator|->
name|opstring
argument_list|)
expr_stmt|;
comment|/* tbl 			if( f == 'F' ) printf( "e" ); 			else if( f == 'D' ) printf( "d" );    tbl */
comment|/* tbl */
switch|switch
condition|(
name|f
condition|)
block|{
case|case
literal|'L'
case|:
case|case
literal|'W'
case|:
case|case
literal|'B'
case|:
case|case
literal|'D'
case|:
case|case
literal|'F'
case|:
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|tolower
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* tbl */
return|return;
block|}
block|}
name|cerror
argument_list|(
literal|"no hoptab for %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|rnames
index|[]
init|=
block|{
comment|/* keyed to register number tokens */
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"ap"
block|,
literal|"fp"
block|,
literal|"sp"
block|,
literal|"pc"
block|,  	}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rstatus
index|[]
init|=
block|{
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,  	}
decl_stmt|;
end_decl_stmt

begin_macro
name|tlen
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
name|DOUBLE
case|:
return|return
operator|(
literal|8
operator|)
return|;
default|default:
return|return
operator|(
literal|4
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|mixtypes
argument_list|(
argument|p
argument_list|,
argument|q
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|tp
operator|,
name|tq
expr_stmt|;
name|tp
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|tq
operator|=
name|q
operator|->
name|type
expr_stmt|;
return|return
operator|(
operator|(
name|tp
operator|==
name|FLOAT
operator|||
name|tp
operator|==
name|DOUBLE
operator|)
operator|!=
operator|(
name|tq
operator|==
name|FLOAT
operator|||
name|tq
operator|==
name|DOUBLE
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|prtype
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|DOUBLE
case|:
name|printf
argument_list|(
literal|"d"
argument_list|)
expr_stmt|;
return|return;
case|case
name|FLOAT
case|:
name|printf
argument_list|(
literal|"f"
argument_list|)
expr_stmt|;
return|return;
case|case
name|LONG
case|:
case|case
name|ULONG
case|:
case|case
name|INT
case|:
case|case
name|UNSIGNED
case|:
name|printf
argument_list|(
literal|"l"
argument_list|)
expr_stmt|;
return|return;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
name|printf
argument_list|(
literal|"w"
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
name|printf
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|n
operator|->
name|type
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"zzzcode- bad type"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"l"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|zzzcode
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|m
expr_stmt|;
name|CONSZ
name|val
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'N'
case|:
comment|/* logical ops, turned into 0-1 */
comment|/* use register given by register 1 */
name|cbgen
argument_list|(
literal|0
argument_list|,
name|m
operator|=
name|getlab
argument_list|()
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|p
operator|->
name|label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	clrl	%s\n"
argument_list|,
name|rnames
index|[
name|getlr
argument_list|(
name|p
argument_list|,
literal|'1'
argument_list|)
operator|->
name|rval
index|]
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
case|case
literal|'P'
case|:
name|cbgen
argument_list|(
name|p
operator|->
name|op
argument_list|,
name|p
operator|->
name|label
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|eprint
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|r
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype
argument_list|(
name|p
operator|->
name|op
argument_list|)
operator|==
name|LTYPE
operator|||
name|p
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|l
operator|=
name|resc
expr_stmt|;
name|l
operator|->
name|type
operator|=
operator|(
name|r
operator|->
name|type
operator|==
name|FLOAT
operator|||
name|r
operator|->
name|type
operator|==
name|DOUBLE
condition|?
name|DOUBLE
else|:
name|INT
operator|)
expr_stmt|;
block|}
else|else
name|l
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|lval
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"clr"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r
operator|->
name|lval
operator|<
literal|0
operator|&&
name|r
operator|->
name|lval
operator|>=
operator|-
literal|63
condition|)
block|{
name|printf
argument_list|(
literal|"mneg"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|r
operator|->
name|lval
operator|=
operator|-
name|r
operator|->
name|lval
expr_stmt|;
goto|goto
name|ops
goto|;
block|}
name|r
operator|->
name|type
operator|=
operator|(
name|r
operator|->
name|lval
operator|<
literal|0
condition|?
operator|(
name|r
operator|->
name|lval
operator|>=
operator|-
literal|128
condition|?
name|CHAR
else|:
operator|(
name|r
operator|->
name|lval
operator|>=
operator|-
literal|32768
condition|?
name|SHORT
else|:
name|INT
operator|)
operator|)
else|:
name|r
operator|->
name|type
operator|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
operator|(
name|r
operator|->
name|lval
operator|>=
literal|0
condition|?
operator|(
name|r
operator|->
name|lval
operator|<=
literal|63
condition|?
name|INT
else|:
operator|(
name|r
operator|->
name|lval
operator|<=
literal|127
condition|?
name|CHAR
else|:
operator|(
name|r
operator|->
name|lval
operator|<=
literal|255
condition|?
name|UCHAR
else|:
operator|(
name|r
operator|->
name|lval
operator|<=
literal|32767
condition|?
name|SHORT
else|:
operator|(
name|r
operator|->
name|lval
operator|<=
literal|65535
condition|?
name|USHORT
else|:
name|INT
operator|)
operator|)
operator|)
operator|)
operator|)
else|:
name|r
operator|->
name|type
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|->
name|op
operator|==
name|REG
operator|&&
name|l
operator|->
name|type
operator|!=
name|FLOAT
operator|&&
name|l
operator|->
name|type
operator|!=
name|DOUBLE
condition|)
name|l
operator|->
name|type
operator|=
name|INT
expr_stmt|;
if|if
condition|(
operator|!
name|mixtypes
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|==
name|tlen
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"mov"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
goto|goto
name|ops
goto|;
block|}
elseif|else
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|>
name|tlen
argument_list|(
name|r
argument_list|)
operator|&&
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|type
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"movz"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
block|}
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ops
label|:
name|printf
argument_list|(
literal|"	"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'C'
case|:
comment|/* num words pushed on arg stack */
block|{
specifier|extern
name|int
name|gc_numbytes
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|gc_numbytes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"$%d"
argument_list|,
name|gc_numbytes
operator|/
operator|(
name|SZLONG
operator|/
name|SZCHAR
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'D'
case|:
comment|/* INCR and DECR */
name|zzzcode
argument_list|(
name|p
operator|->
name|left
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n	"
argument_list|)
expr_stmt|;
case|case
literal|'E'
case|:
comment|/* INCR and DECR, FOREFF */
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|lval
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|(
name|p
operator|->
name|op
operator|==
name|INCR
condition|?
literal|"inc"
else|:
literal|"dec"
operator|)
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|(
name|p
operator|->
name|op
operator|==
name|INCR
condition|?
literal|"add"
else|:
literal|"sub"
operator|)
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"2	"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
comment|/* register type of right operand */
block|{
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
specifier|register
name|int
name|ty
decl_stmt|;
name|n
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
name|ty
operator|=
name|n
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|ty
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|DOUBLE
condition|)
name|printf
argument_list|(
literal|"d"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ty
operator|==
name|FLOAT
condition|)
name|printf
argument_list|(
literal|"f"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"l"
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'L'
case|:
comment|/* type of left operand */
case|case
literal|'R'
case|:
comment|/* type of right operand */
block|{
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
name|n
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|n
operator|->
name|type
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'Z'
case|:
comment|/* complement mask for bit instr */
name|printf
argument_list|(
literal|"$%ld"
argument_list|,
operator|~
name|p
operator|->
name|right
operator|->
name|lval
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'U'
case|:
comment|/* 32 - n, for unsigned right shifts */
name|printf
argument_list|(
literal|"$%d"
argument_list|,
literal|32
operator|-
name|p
operator|->
name|right
operator|->
name|lval
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
comment|/* rounded structure length for arguments */
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|p
operator|->
name|stsize
expr_stmt|;
name|SETOFF
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"$%d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'S'
case|:
comment|/* structure assignment */
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|size
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STASG
condition|)
block|{
name|l
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STARG
condition|)
block|{
comment|/* store an arg into a temporary */
name|l
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
else|else
name|cerror
argument_list|(
literal|"STASG bad"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|ICON
condition|)
name|r
operator|->
name|op
operator|=
name|NAME
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|REG
condition|)
name|r
operator|->
name|op
operator|=
name|OREG
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|op
operator|!=
name|OREG
condition|)
name|cerror
argument_list|(
literal|"STASG-r"
argument_list|)
expr_stmt|;
name|size
operator|=
name|p
operator|->
name|stsize
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
literal|65535
condition|)
name|cerror
argument_list|(
literal|"structure size<0=0 or>65535"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"	movb	"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"	movw	"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|"	movl	"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|printf
argument_list|(
literal|"	movq	"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"	movc3	$%d,"
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|NAME
condition|)
name|r
operator|->
name|op
operator|=
name|ICON
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|OREG
condition|)
name|r
operator|->
name|op
operator|=
name|REG
expr_stmt|;
block|}
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal zzzcode"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rmove
argument_list|(
argument|rt
argument_list|,
argument|rs
argument_list|,
argument|t
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"	%s	%s,%s\n"
argument_list|,
operator|(
name|t
operator|==
name|FLOAT
condition|?
literal|"movf"
else|:
operator|(
name|t
operator|==
name|DOUBLE
condition|?
literal|"movd"
else|:
literal|"movl"
operator|)
operator|)
argument_list|,
name|rnames
index|[
name|rs
index|]
argument_list|,
name|rnames
index|[
name|rt
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|struct
name|respref
name|respref
index|[]
init|=
block|{
name|INTAREG
operator||
name|INTBREG
block|,
name|INTAREG
operator||
name|INTBREG
block|,
name|INAREG
operator||
name|INBREG
block|,
name|INAREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
operator||
name|SNAME
operator||
name|SCON
block|,
name|INTEMP
block|,
name|INTEMP
block|,
name|FORARG
block|,
name|FORARG
block|,
name|INTEMP
block|,
name|INTAREG
operator||
name|INAREG
operator||
name|INTBREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|setregs
argument_list|()
end_macro

begin_block
block|{
comment|/* set up temporary registers */
name|fregs
operator|=
literal|6
expr_stmt|;
comment|/* tbl- 6 free regs on VAX (0-5) */
empty_stmt|;
block|}
end_block

begin_macro
name|szty
argument_list|(
argument|t
argument_list|)
end_macro

begin_block
block|{
comment|/* size, in registers, needed to hold thing of type t */
return|return
operator|(
operator|(
name|t
operator|==
name|DOUBLE
operator|||
name|t
operator|==
name|FLOAT
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|rewfld
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|callreg
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|R0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|base
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|==
name|ICON
operator|&&
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
return|return
operator|(
literal|100
operator|)
return|;
comment|/* ie no base reg */
if|if
condition|(
name|o
operator|==
name|REG
condition|)
return|return
operator|(
name|p
operator|->
name|rval
operator|)
return|;
if|if
condition|(
operator|(
name|o
operator|==
name|PLUS
operator|||
name|o
operator|==
name|MINUS
operator|)
operator|&&
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
condition|)
return|return
operator|(
name|p
operator|->
name|left
operator|->
name|rval
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|OREG
operator|&&
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|rval
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|type
operator|==
name|UNSIGNED
operator|||
name|ISPTR
argument_list|(
name|p
operator|->
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|rval
operator|+
literal|0200
operator|*
literal|1
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|INCR
operator|&&
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|REG
condition|)
return|return
operator|(
name|p
operator|->
name|left
operator|->
name|rval
operator|+
literal|0200
operator|*
literal|2
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|ASG
name|MINUS
operator|&&
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|REG
condition|)
return|return
operator|(
name|p
operator|->
name|left
operator|->
name|rval
operator|+
literal|0200
operator|*
literal|4
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|INCR
operator|&&
name|p
operator|->
name|left
operator|->
name|left
operator|->
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|type
operator|==
name|UNSIGNED
operator|||
name|ISPTR
argument_list|(
name|p
operator|->
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|left
operator|->
name|left
operator|->
name|rval
operator|+
literal|0200
operator|*
operator|(
literal|1
operator|+
literal|2
operator|)
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|offset
argument_list|(
name|p
argument_list|,
name|tyl
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|tyl
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|tyl
operator|==
literal|1
operator|&&
name|p
operator|->
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|type
operator|==
name|UNSIGNED
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|rval
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|->
name|op
operator|==
name|LS
operator|&&
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|left
operator|->
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|left
operator|->
name|type
operator|==
name|UNSIGNED
operator|)
operator|&&
operator|(
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|right
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
literal|1
operator|<<
name|p
operator|->
name|right
operator|->
name|lval
operator|)
operator|==
name|tyl
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|left
operator|->
name|rval
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|makeor2
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|b
argument_list|,
name|o
argument_list|)
specifier|register
name|NODE
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|b
decl_stmt|,
name|o
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|NODE
modifier|*
name|f
decl_stmt|;
name|p
operator|->
name|op
operator|=
name|OREG
expr_stmt|;
name|f
operator|=
name|p
operator|->
name|left
expr_stmt|;
comment|/* have to free this subtree later */
comment|/* init base */
switch|switch
condition|(
name|q
operator|->
name|op
condition|)
block|{
case|case
name|ICON
case|:
case|case
name|REG
case|:
case|case
name|OREG
case|:
name|t
operator|=
name|q
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|q
operator|->
name|right
operator|->
name|lval
operator|=
operator|-
name|q
operator|->
name|right
operator|->
name|lval
expr_stmt|;
case|case
name|PLUS
case|:
name|t
operator|=
name|q
operator|->
name|right
expr_stmt|;
break|break;
case|case
name|INCR
case|:
case|case
name|ASG
name|MINUS
case|:
name|t
operator|=
name|q
operator|->
name|left
expr_stmt|;
break|break;
case|case
name|UNARY
name|MUL
case|:
name|t
operator|=
name|q
operator|->
name|left
operator|->
name|left
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal makeor2"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|lval
operator|=
name|t
operator|->
name|lval
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHNAM
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|name
index|[
name|i
index|]
operator|=
name|t
operator|->
name|name
index|[
name|i
index|]
expr_stmt|;
comment|/* init offset */
name|p
operator|->
name|rval
operator|=
name|R2PACK
argument_list|(
operator|(
name|b
operator|&
literal|0177
operator|)
argument_list|,
name|o
argument_list|,
operator|(
name|b
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|canaddr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|op
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
operator|||
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|left
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shltype
argument_list|(
name|o
argument_list|,
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
operator|||
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|left
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|flshape
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|p
operator|->
name|op
operator|==
name|REG
operator|||
name|p
operator|->
name|op
operator|==
name|NAME
operator|||
name|p
operator|->
name|op
operator|==
name|ICON
operator|||
operator|(
name|p
operator|->
name|op
operator|==
name|OREG
operator|&&
operator|(
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|rval
argument_list|)
operator|||
name|tlen
argument_list|(
name|p
argument_list|)
operator|==
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shtemp
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STARG
condition|)
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|op
operator|==
name|NAME
operator|||
name|p
operator|->
name|op
operator|==
name|ICON
operator|||
name|p
operator|->
name|op
operator|==
name|OREG
operator|||
operator|(
name|p
operator|->
name|op
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|left
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shumul
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|o
expr_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
block|{
name|printf
argument_list|(
literal|"\nshumul:op=%d,lop=%d,rop=%d"
argument_list|,
name|p
operator|->
name|op
argument_list|,
name|p
operator|->
name|left
operator|->
name|op
argument_list|,
name|p
operator|->
name|right
operator|->
name|op
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" prname=%s,plty=%d, prlval=%D\n"
argument_list|,
name|p
operator|->
name|right
operator|->
name|name
argument_list|,
name|p
operator|->
name|left
operator|->
name|type
argument_list|,
name|p
operator|->
name|right
operator|->
name|lval
argument_list|)
expr_stmt|;
block|}
name|o
operator|=
name|p
operator|->
name|op
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
operator|(
name|o
operator|==
name|OREG
operator|&&
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|rval
argument_list|)
operator|)
operator|||
name|o
operator|==
name|ICON
condition|)
return|return
operator|(
name|STARNM
operator|)
return|;
if|if
condition|(
operator|(
name|o
operator|==
name|INCR
operator|||
name|o
operator|==
name|ASG
name|MINUS
operator|)
operator|&&
operator|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
operator|)
operator|&&
name|p
operator|->
name|right
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|left
operator|->
name|type
condition|)
block|{
case|case
name|CHAR
operator||
name|PTR
case|:
case|case
name|UCHAR
operator||
name|PTR
case|:
name|o
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SHORT
operator||
name|PTR
case|:
case|case
name|USHORT
operator||
name|PTR
case|:
name|o
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|INT
operator||
name|PTR
case|:
case|case
name|UNSIGNED
operator||
name|PTR
case|:
case|case
name|LONG
operator||
name|PTR
case|:
case|case
name|ULONG
operator||
name|PTR
case|:
case|case
name|FLOAT
operator||
name|PTR
case|:
name|o
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|DOUBLE
operator||
name|PTR
case|:
name|o
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISPTR
argument_list|(
name|p
operator|->
name|left
operator|->
name|type
argument_list|)
condition|)
block|{
name|o
operator|=
literal|4
expr_stmt|;
break|break;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|->
name|right
operator|->
name|lval
operator|==
name|o
condition|?
name|STARREG
else|:
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|adrcon
argument_list|(
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|CONSZ
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|conput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|ICON
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal conput"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|insput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cerror
argument_list|(
literal|"insput"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|upput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cerror
argument_list|(
literal|"upput"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|adrput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|r
decl_stmt|;
comment|/* output an address, with offsets, from p */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|FLD
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|NAME
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|ICON
case|:
comment|/* addressable value of the constant */
name|printf
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|OREG
case|:
name|r
operator|=
name|p
operator|->
name|rval
expr_stmt|;
if|if
condition|(
name|R2TEST
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* double indexing */
specifier|register
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|R2UPK3
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|4
condition|)
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
operator|!=
literal|100
condition|)
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rnames
index|[
name|R2UPK1
argument_list|(
name|r
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%s]"
argument_list|,
name|rnames
index|[
name|R2UPK2
argument_list|(
name|r
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r
operator|==
name|AP
condition|)
block|{
comment|/* in the argument region */
if|if
condition|(
name|p
operator|->
name|lval
operator|<=
literal|0
operator|||
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|werror
argument_list|(
literal|"bad arg temp"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|lval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(ap)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNARY
name|MUL
case|:
comment|/* STARNM or STARREG found */
if|if
condition|(
name|tshape
argument_list|(
name|p
argument_list|,
name|STARNM
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* STARREG - really auto inc or dec */
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
comment|/* tbl 			p = p->left; 			p->left->op = OREG; 			if( p->op == INCR ) { 				adrput( p->left ); 				printf( "+" ); 				} 			else { 				printf( "-" ); 				adrput( p->left ); 				}    tbl */
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|!=
name|INCR
condition|)
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|left
operator|->
name|left
operator|->
name|rval
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|INCR
condition|)
name|printf
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|OREG
expr_stmt|;
name|p
operator|->
name|rval
operator|=
name|p
operator|->
name|left
operator|->
name|left
operator|->
name|rval
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|lval
operator|=
operator|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|INCR
condition|?
operator|-
name|p
operator|->
name|left
operator|->
name|right
operator|->
name|lval
else|:
literal|0
operator|)
expr_stmt|;
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal address"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|acon
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* print out a constant */
if|if
condition|(
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|lval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|lval
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%.8s"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%.8s+"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|lval
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* aacon( p ) register NODE *p; { /* print out a constant */
end_comment

begin_comment
comment|/*  	if( p->name[0] == '\0' ){ 		printf( CONFMT, p->lval); 		return( 0 ); 		} 	else if( p->lval == 0 ) { 		printf( "$%.8s", p->name ); 		return( 1 ); 		} 	else { 		printf( "$(" ); 		printf( CONFMT, p->lval ); 		printf( "+" ); 		printf( "%.8s)", p->name ); 		return(1); 		} 	}  */
end_comment

begin_expr_stmt
name|genscall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* structure valued call */
return|return
operator|(
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* tbl */
end_comment

begin_decl_stmt
name|int
name|gc_numbytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbl */
end_comment

begin_expr_stmt
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* generate the call given by p */
specifier|register
name|NODE
modifier|*
name|p1
decl_stmt|,
modifier|*
name|ptemp
decl_stmt|;
specifier|register
name|temp
operator|,
name|temp1
expr_stmt|;
specifier|register
name|m
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
condition|)
name|temp
operator|=
name|argsize
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STCALL
operator|||
name|p
operator|->
name|op
operator|==
name|UNARY
name|STCALL
condition|)
block|{
comment|/* set aside room for structure return */
if|if
condition|(
name|p
operator|->
name|stsize
operator|>
name|temp
condition|)
name|temp1
operator|=
name|p
operator|->
name|stsize
expr_stmt|;
else|else
name|temp1
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|>
name|maxargs
condition|)
name|maxargs
operator|=
name|temp
expr_stmt|;
name|SETOFF
argument_list|(
name|temp1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
condition|)
block|{
comment|/* make temp node, put offset in, and generate args */
name|ptemp
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|ptemp
operator|->
name|op
operator|=
name|OREG
expr_stmt|;
name|ptemp
operator|->
name|lval
operator|=
operator|-
literal|1
expr_stmt|;
name|ptemp
operator|->
name|rval
operator|=
name|SP
expr_stmt|;
name|ptemp
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ptemp
operator|->
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|ptemp
operator|->
name|su
operator|=
literal|0
expr_stmt|;
name|genargs
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|ptemp
argument_list|)
expr_stmt|;
name|ptemp
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
name|p1
operator|=
name|p
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|!=
name|ICON
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|op
operator|!=
name|REG
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|op
operator|!=
name|OREG
operator|||
name|R2TEST
argument_list|(
name|p1
operator|->
name|rval
argument_list|)
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|op
operator|!=
name|NAME
condition|)
block|{
name|order
argument_list|(
name|p1
argument_list|,
name|INAREG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	if( p1->op == REG&& p->rval == R5 ){ 		cerror( "call register overwrite" ); 		}  */
comment|/* tbl 	setup gc_numbytes so reference to ZC works */
name|gc_numbytes
operator|=
name|temp
expr_stmt|;
comment|/* tbl */
name|p
operator|->
name|op
operator|=
name|UNARY
name|CALL
expr_stmt|;
name|m
operator|=
name|match
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
comment|/* tbl 	switch( temp ) { 	case 0: 		break; 	case 2: 		printf( "	tst	(sp)+\n" ); 		break; 	case 4: 		printf( "	cmp	(sp)+,(sp)+\n" ); 		break; 	default: 		printf( "	add	$%d,sp\n", temp); 		}    tbl */
return|return
operator|(
name|m
operator|!=
name|MDONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* tbl */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ccbranches
index|[]
init|=
block|{
literal|"	jeql	L%d\n"
block|,
literal|"	jneq	L%d\n"
block|,
literal|"	jleq	L%d\n"
block|,
literal|"	jlss	L%d\n"
block|,
literal|"	jgeq	L%d\n"
block|,
literal|"	jgtr	L%d\n"
block|,
literal|"	jlequ	L%d\n"
block|,
literal|"	jlssu	L%d\n"
block|,
literal|"	jgequ	L%d\n"
block|,
literal|"	jgtru	L%d\n"
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbl */
end_comment

begin_macro
name|cbgen
argument_list|(
argument|o
argument_list|,
argument|lab
argument_list|,
argument|mode
argument_list|)
end_macro

begin_block
block|{
comment|/*   printf conditional and unconditional branches */
comment|/* tbl */
if|if
condition|(
name|o
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"	jbr     L%d\n"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
comment|/* tbl */
else|else
block|{
if|if
condition|(
name|o
operator|>
name|UGT
condition|)
name|cerror
argument_list|(
literal|"bad conditional branch: %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|ccbranches
index|[
name|o
operator|-
name|EQ
index|]
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|nextcook
argument_list|(
argument|p
argument_list|,
argument|cookie
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* we have failed to match p with cookie; try another */
if|if
condition|(
name|cookie
operator|==
name|FORREW
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hopeless! */
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
operator|)
condition|)
return|return
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
name|INTEMP
operator|)
operator|&&
name|asgop
argument_list|(
name|p
operator|->
name|op
argument_list|)
condition|)
return|return
operator|(
name|INTEMP
operator||
name|INAREG
operator||
name|INTAREG
operator||
name|INTBREG
operator||
name|INBREG
operator|)
return|;
return|return
operator|(
name|FORREW
operator|)
return|;
block|}
end_block

begin_macro
name|lastchance
argument_list|(
argument|p
argument_list|,
argument|cook
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* forget it! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|optim2
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* do local tree transformations and optimizations */
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|AND
case|:
comment|/* commute L and R to eliminate compliments and constants */
if|if
condition|(
operator|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|left
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|||
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|COMPL
condition|)
block|{
name|r
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|right
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|r
expr_stmt|;
block|}
case|case
name|ASG
name|AND
case|:
comment|/* change meaning of AND to ~R&L - bic on pdp11 */
name|r
operator|=
name|p
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* compliment constant */
name|r
operator|->
name|lval
operator|=
operator|~
name|r
operator|->
name|lval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|op
operator|==
name|COMPL
condition|)
block|{
comment|/* ~~A => A */
name|r
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|r
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
comment|/* insert complement node */
name|p
operator|->
name|right
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|op
operator|=
name|COMPL
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|type
operator|=
name|r
operator|->
name|type
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|left
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
return|return
operator|(
name|mainp2
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

