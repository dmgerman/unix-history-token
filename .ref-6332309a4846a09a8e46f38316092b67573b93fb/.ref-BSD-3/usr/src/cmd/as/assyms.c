begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"assyms.h"
end_include

begin_decl_stmt
name|struct
name|allocbox
modifier|*
name|allochead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|allocbox
modifier|*
name|alloctail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|nextsym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|allocbox
modifier|*
name|newbox
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|namebuffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symsleft
decl_stmt|;
end_decl_stmt

begin_macro
name|symtabinit
argument_list|()
end_macro

begin_block
block|{
name|allochead
operator|=
literal|0
expr_stmt|;
name|alloctail
operator|=
literal|0
expr_stmt|;
name|nextsym
operator|=
literal|0
expr_stmt|;
name|symsleft
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Install all known instructions in the symbol table  */
end_comment

begin_macro
name|syminstall
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|instab
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|instab
init|;
name|ip
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|0
condition|;
name|ip
operator|++
control|)
block|{
name|p1
operator|=
name|ip
operator|->
name|name
expr_stmt|;
name|p2
operator|=
name|yytext
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
name|hp
operator|=
name|lookup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 0 => don't install this*/
if|if
condition|(
operator|*
name|hp
operator|==
name|NULL
condition|)
block|{
operator|*
name|hp
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|ip
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|tag
operator|!=
name|INSTn
operator|)
operator|&&
operator|(
name|ip
operator|->
name|tag
operator|!=
name|INST0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|tag
operator|!=
literal|0
operator|)
condition|)
continue|continue;
comment|/* was pseudo-op */
name|itab
index|[
name|ip
operator|->
name|opcode
operator|&
literal|0xFF
index|]
operator|=
name|ip
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*end of syminstall*/
end_comment

begin_comment
comment|/*  *	Assign final values to symbols,  *	and overwrite the index field with its relative position in  *	the symbol table we give to the loader.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|hdr
name|hdr
decl_stmt|;
end_decl_stmt

begin_macro
name|freezesymtab
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
name|long
name|bs
decl_stmt|;
specifier|register
name|int
name|relpos
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SORTEDOUTPUT
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|cosp
decl_stmt|;
else|#
directive|else
specifier|register
name|struct
name|symtab
modifier|*
name|ubsp
decl_stmt|;
specifier|register
name|struct
name|allocbox
modifier|*
name|allocwalk
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SORTEDOUTPUT
name|SYMITERATE
argument_list|(
argument|cosp
argument_list|,
argument|sp
argument_list|)
else|#
directive|else
name|DECLITERATE
argument_list|(
argument|allocwalk
argument_list|,
argument|sp
argument_list|,
argument|ubsp
argument_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|sp
operator|->
name|tag
operator|>=
name|IGNOREBOUND
condition|)
continue|continue;
comment|/*totally ignore jxxx entries */
comment|/* 		 *	Ignore stabs, but give them a symbol table index 		 */
if|if
condition|(
name|sp
operator|->
name|type
operator|&
name|STABFLAG
condition|)
goto|goto
name|assignindex
goto|;
if|if
condition|(
operator|(
name|sp
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEF
condition|)
name|sp
operator|->
name|type
operator|=
name|XXTRN
operator|+
name|XUNDEF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|XDATA
condition|)
name|sp
operator|->
name|value
operator|+=
name|usedot
index|[
name|sp
operator|->
name|index
index|]
operator|.
name|xvalue
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|XTEXT
condition|)
name|sp
operator|->
name|value
operator|+=
name|usedot
index|[
name|sp
operator|->
name|index
index|]
operator|.
name|xvalue
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|XBSS
condition|)
block|{
name|bs
operator|=
name|sp
operator|->
name|value
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|hdr
operator|.
name|bsize
operator|+
name|datbase
expr_stmt|;
name|hdr
operator|.
name|bsize
operator|+=
name|bs
expr_stmt|;
block|}
name|assignindex
label|:
if|if
condition|(
operator|(
name|sp
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|)
operator|||
operator|(
name|sp
operator|->
name|tag
operator|!=
name|LABELID
operator|)
operator|||
name|savelabels
condition|)
comment|/*then, we will write it later on*/
name|sp
operator|->
name|index
operator|=
name|relpos
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	For all of the stabs that had their final value undefined during pass 1  *	and during pass 2 assign a final value.  *	We have already given stab entrys a initial approximation  *	when we constsructed the sorted symbol table.  *	Iteration order doesn't matter.  */
end_comment

begin_macro
name|stabfix
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|,
modifier|*
modifier|*
name|cosp
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
name|SYMITERATE
argument_list|(
argument|cosp
argument_list|,
argument|sp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|ptype
operator|&&
operator|(
name|sp
operator|->
name|type
operator|&
name|STABFLAG
operator|)
condition|)
block|{
name|p
operator|=
name|sp
operator|->
name|dest
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|p
operator|->
name|value
expr_stmt|;
name|sp
operator|->
name|index
operator|=
name|p
operator|->
name|index
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|p
operator|->
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|DSTAB
name|printf
argument_list|(
literal|"STABFIX: %s (old %s) to %d offsets %d %d\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|sp
operator|->
name|value
argument_list|,
name|sp
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|Calloc
parameter_list|(
name|number
parameter_list|,
name|size
parameter_list|)
name|int
name|number
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|newstuff
decl_stmt|;
name|newstuff
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
name|number
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|newstuff
operator|==
operator|-
literal|1
condition|)
block|{
name|yyerror
argument_list|(
literal|"Ran out of Memory"
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|newstuff
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|symtab
modifier|*
name|symalloc
parameter_list|()
block|{
if|if
condition|(
name|symsleft
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|;
name|newbox
operator|=
operator|(
expr|struct
name|allocbox
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
name|ALLOCQTY
argument_list|)
expr_stmt|;
name|symsleft
operator|=
name|SYMDALLOP
expr_stmt|;
name|nextsym
operator|=
operator|&
name|newbox
operator|->
name|symslots
index|[
literal|0
index|]
expr_stmt|;
name|namebuffer
operator|=
operator|&
name|newbox
operator|->
name|symnames
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|newbox
operator|->
name|symnames
index|[
name|SYMDALLOP
operator|*
name|NCPS
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|>
operator|(
name|int
operator|*
operator|)
name|newbox
condition|)
block|{
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|alloctail
operator|==
literal|0
condition|)
block|{
name|allochead
operator|=
name|alloctail
operator|=
name|newbox
expr_stmt|;
block|}
else|else
block|{
name|alloctail
operator|->
name|nextalloc
operator|=
name|newbox
expr_stmt|;
name|alloctail
operator|=
name|newbox
expr_stmt|;
block|}
block|}
operator|--
name|symsleft
expr_stmt|;
operator|++
name|nsyms
expr_stmt|;
name|nextsym
operator|->
name|name
operator|=
name|namebuffer
expr_stmt|;
name|namebuffer
operator|+=
name|NCPS
expr_stmt|;
return|return
operator|(
name|nextsym
operator|++
operator|)
return|;
block|}
end_function

begin_macro
name|symcmp
argument_list|(
argument|pptr
argument_list|,
argument|qptr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symtab
modifier|*
modifier|*
name|pptr
decl_stmt|,
modifier|*
modifier|*
name|qptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|p
init|=
operator|*
name|pptr
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|q
init|=
operator|*
name|qptr
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|index
operator|<
name|q
operator|->
name|index
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|index
operator|>
name|q
operator|->
name|index
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|value
operator|<
name|q
operator|->
name|value
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|value
operator|>
name|q
operator|->
name|value
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 *	Force jxxx entries to virtually preceed labels defined 	 *	to follow the jxxxx instruction, so that bumping the 	 *	jxxx instruction correctly fixes up the following labels 	 */
if|if
condition|(
name|p
operator|->
name|tag
operator|>=
name|IGNOREBOUND
condition|)
comment|/*p points to a jxxx*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|q
operator|->
name|tag
operator|>=
name|IGNOREBOUND
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 *	both are now just plain labels; the relative order doesn't 	 *	matter.  Both can't be jxxxes, as they would have different 	 *	values. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*end of symcmp*/
end_comment

begin_comment
comment|/*  *	We construct the auxiliary table of pointers, symptrs and  *	symdelim  *	We also assign preliminary values to stab entries that did not yet  *	have an absolute value (because they initially referred to  *	forward references). We don't worry about .stabds, as they  *	already have an estimated final value  */
end_comment

begin_macro
name|sortsymtab
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|cowalk
decl_stmt|;
specifier|register
name|struct
name|allocbox
modifier|*
name|allocwalk
decl_stmt|;
name|struct
name|symtab
modifier|*
name|ubsp
decl_stmt|;
name|int
name|segno
decl_stmt|;
name|int
name|slotno
decl_stmt|;
name|int
name|symsin
decl_stmt|;
comment|/*number put into symptrs*/
name|symptrs
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|Calloc
argument_list|(
name|nsyms
operator|+
literal|2
argument_list|,
sizeof|sizeof
expr|*
name|symptrs
argument_list|)
expr_stmt|;
comment|/* 	 *	Allocate one word at the beginning of the symptr array 	 *	so that backwards scans through the symptr array will 	 *	work correctly while scanning through the zeroth segment 	 */
operator|*
name|symptrs
operator|++
operator|=
literal|0
expr_stmt|;
name|cowalk
operator|=
name|symptrs
expr_stmt|;
name|symsin
operator|=
literal|0
expr_stmt|;
name|DECLITERATE
argument_list|(
argument|allocwalk
argument_list|,
argument|sp
argument_list|,
argument|ubsp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|ptype
operator|&&
operator|(
name|sp
operator|->
name|type
operator|&
name|STABFLAG
operator|)
condition|)
block|{
name|sp
operator|->
name|value
operator|=
name|sp
operator|->
name|dest
operator|->
name|value
expr_stmt|;
name|sp
operator|->
name|index
operator|=
name|sp
operator|->
name|dest
operator|->
name|index
expr_stmt|;
block|}
if|if
condition|(
name|symsin
operator|>=
name|nsyms
condition|)
name|yyerror
argument_list|(
literal|"INTERNAL ERROR: overfilled symbol table indirection table"
argument_list|)
expr_stmt|;
operator|*
name|cowalk
operator|++
operator|=
name|sp
expr_stmt|;
name|symsin
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|symsin
operator|!=
name|nsyms
condition|)
name|yyerror
argument_list|(
literal|"INTERNAL ERROR: installed %d syms, should have installed %d"
argument_list|,
name|symsin
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
name|symptrub
operator|=
operator|&
name|symptrs
index|[
name|nsyms
index|]
expr_stmt|;
name|qsort
argument_list|(
name|symptrs
argument_list|,
name|nsyms
argument_list|,
sizeof|sizeof
expr|*
name|symptrs
argument_list|,
name|symcmp
argument_list|)
expr_stmt|;
name|symdelim
index|[
literal|0
index|]
operator|=
name|symptrs
expr_stmt|;
for|for
control|(
name|cowalk
operator|=
name|symptrs
operator|,
name|sp
operator|=
operator|*
name|cowalk
operator|,
name|segno
operator|=
literal|0
operator|,
name|slotno
operator|=
literal|1
init|;
name|segno
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|segno
operator|++
operator|,
name|slotno
operator|++
control|)
block|{
for|for
control|(
init|;
name|sp
operator|&&
name|sp
operator|->
name|index
operator|==
name|segno
condition|;
name|sp
operator|=
operator|*
operator|++
name|cowalk
control|)
empty_stmt|;
name|symdelim
index|[
name|slotno
index|]
operator|=
name|cowalk
expr_stmt|;
comment|/*forms the ub delimeter*/
block|}
block|}
end_block

begin_comment
comment|/*end of sortsymtab*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|dumpsymtab
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|segno
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|,
modifier|*
modifier|*
name|cosp
decl_stmt|,
modifier|*
name|ub
decl_stmt|;
name|char
modifier|*
name|tagstring
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"Symbol Table dump:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|segno
operator|=
literal|0
init|;
name|segno
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|segno
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"Segment number: %d\n"
argument_list|,
name|segno
argument_list|)
expr_stmt|;
name|SEGITERATE
argument_list|(
argument|segno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|cosp
argument_list|,
argument|sp
argument_list|,
argument|ub
argument_list|,
argument|++
argument_list|)
block|{
name|printf
argument_list|(
literal|"\tSeg: %d \"%8.8s\" value: %d index: %d tag %s\n"
argument_list|,
name|segno
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|sp
operator|->
name|value
argument_list|,
name|sp
operator|->
name|index
argument_list|,
name|tagstring
argument_list|(
name|sp
operator|->
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\ttype: %d jxbump %d jxfear: %d\n"
argument_list|,
name|sp
operator|->
name|type
argument_list|,
name|sp
operator|->
name|jxbump
argument_list|,
name|sp
operator|->
name|jxfear
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|tagbuff
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|tagstring
parameter_list|(
name|tag
parameter_list|)
name|unsigned
name|char
name|tag
decl_stmt|;
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|JXACTIVE
case|:
return|return
operator|(
literal|"active"
operator|)
return|;
case|case
name|JXNOTYET
case|:
return|return
operator|(
literal|"notyet"
operator|)
return|;
case|case
name|JXALIGN
case|:
return|return
operator|(
literal|"align"
operator|)
return|;
case|case
name|JXQUESTIONABLE
case|:
return|return
operator|(
literal|"jxquestionable"
operator|)
return|;
case|case
name|JXINACTIVE
case|:
return|return
operator|(
literal|"inactive"
operator|)
return|;
case|case
name|JXTUNNEL
case|:
return|return
operator|(
literal|"tunnel"
operator|)
return|;
case|case
name|OBSOLETE
case|:
return|return
operator|(
literal|"obsolete"
operator|)
return|;
case|case
name|IGNOREBOUND
case|:
return|return
operator|(
literal|"ignorebound"
operator|)
return|;
case|case
name|STABFLOATING
case|:
return|return
operator|(
literal|"stabfloating"
operator|)
return|;
case|case
name|STABFIXED
case|:
return|return
operator|(
literal|"stabfixed"
operator|)
return|;
case|case
name|LABELID
case|:
return|return
operator|(
literal|"labelid"
operator|)
return|;
case|case
name|OKTOBUMP
case|:
return|return
operator|(
literal|"oktobump"
operator|)
return|;
case|case
name|ISET
case|:
return|return
operator|(
literal|"iset"
operator|)
return|;
case|case
name|ILSYM
case|:
return|return
operator|(
literal|"ilsym"
operator|)
return|;
default|default:
name|sprintf
argument_list|(
name|tagbuff
argument_list|,
literal|"%d"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|tagbuff
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HASHCLOGGED
value|(NHASH * 3 ) / 4
end_define

begin_function
name|struct
name|symtab
modifier|*
modifier|*
name|lookup
parameter_list|(
name|instflg
parameter_list|)
name|int
name|instflg
decl_stmt|;
comment|/* 0: don't install */
block|{
specifier|register
name|int
name|ihash
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|METRIC
name|nhashed
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *	All strings passed in in yytext had better have 	 *	a trailing null.  Strings are placed in yytext for 	 *	hashing by syminstall() and yylex() 	 */
for|for
control|(
name|ihash
operator|=
literal|0
operator|,
name|p1
operator|=
name|yytext
init|;
operator|*
name|p1
condition|;
name|ihash
operator|<<=
literal|2
operator|,
name|ihash
operator|+=
operator|*
name|p1
operator|++
control|)
empty_stmt|;
name|ihash
operator|+=
name|p1
index|[
operator|-
literal|1
index|]
operator|<<
literal|5
expr_stmt|;
name|ihash
operator|%=
name|NHASH
expr_stmt|;
if|if
condition|(
name|ihash
operator|<
literal|0
condition|)
name|ihash
operator|+=
name|NHASH
expr_stmt|;
name|hp
operator|=
operator|&
name|hshtab
index|[
name|ihash
index|]
expr_stmt|;
name|ihash
operator|=
literal|1
expr_stmt|;
comment|/*now, it counts the number of times we rehash*/
while|while
condition|(
operator|*
name|hp
condition|)
block|{
name|p1
operator|=
name|yytext
expr_stmt|;
name|p2
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|NCPS
operator|)
operator|&&
operator|*
name|p1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
goto|goto
name|no
goto|;
if|if
condition|(
name|i
operator|>=
name|NCPS
condition|)
comment|/*both symbols are maximal length*/
return|return
operator|(
name|hp
operator|)
return|;
if|if
condition|(
operator|*
name|p2
operator|==
literal|0
condition|)
comment|/*assert *p1 == 0*/
return|return
operator|(
name|hp
operator|)
return|;
name|no
label|:
ifdef|#
directive|ifdef
name|METRIC
name|nhcollisions
operator|++
expr_stmt|;
endif|#
directive|endif
name|hp
operator|+=
name|ihash
expr_stmt|;
name|ihash
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|hp
operator|>=
operator|&
name|hshtab
index|[
name|NHASH
index|]
condition|)
name|hp
operator|-=
name|NHASH
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|hshused
operator|>=
name|HASHCLOGGED
condition|)
block|{
name|yyerror
argument_list|(
literal|"Symbol table overflow"
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|instflg
condition|)
block|{
ifdef|#
directive|ifdef
name|METRIC
name|nentered
operator|++
expr_stmt|;
endif|#
directive|endif
operator|*
name|hp
operator|=
name|symalloc
argument_list|()
expr_stmt|;
name|p1
operator|=
name|yytext
expr_stmt|;
name|p2
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
block|}
return|return
operator|(
name|hp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*end of symlook*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_define
define|#
directive|define
name|writel
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|,
name|f
parameter_list|)
value|fwrite((long)p, sizeof (long), n, f)
end_define

begin_else
else|#
directive|else
end_else

begin_macro
name|writel
argument_list|(
argument|p
argument_list|,
argument|n
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|fwrite
argument_list|(
operator|&
operator|(
operator|*
name|p
operator|)
operator|.
name|loword
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
operator|(
operator|*
name|p
operator|)
operator|.
name|hiword
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|reflen
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Save the relocation information  */
end_comment

begin_macro
name|outrel
argument_list|(
argument|pval
argument_list|,
argument|reftype
argument_list|,
argument|reltype
argument_list|,
argument|xsym
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|pval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|reftype
decl_stmt|,
name|reltype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|xsym
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*  *	reftype: PCREL or not, plus length LEN1, LEN2, LEN4, LEN8  *	reltype: csect ("segment") number (XTEXT, XDATA, ...) associated with 'val'  * 	xsym: symbol table pointer  */
name|long
name|ts
decl_stmt|;
name|char
name|tc
decl_stmt|;
name|long
name|tl
decl_stmt|;
name|short
name|t
decl_stmt|;
if|if
condition|(
name|passno
operator|!=
literal|2
condition|)
block|{
name|dotp
operator|->
name|xvalue
operator|+=
name|reflen
index|[
name|reftype
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bitoff
operator|&
literal|07
condition|)
name|yyerror
argument_list|(
literal|"Padding error"
argument_list|)
expr_stmt|;
name|reltype
operator|&=
operator|~
name|XFORW
expr_stmt|;
if|if
condition|(
name|reltype
operator|==
name|XUNDEF
condition|)
name|yyerror
argument_list|(
literal|"Undefined reference"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reltype
operator|!=
name|XABS
operator|||
name|reftype
operator|&
name|PCREL
condition|)
block|{
comment|/* write the address portion of a relocation datum */
if|if
condition|(
name|dotp
operator|>=
operator|&
name|usedot
index|[
name|NLOC
index|]
condition|)
block|{
name|hdr
operator|.
name|drsize
operator|+=
sizeof|sizeof
argument_list|(
name|dotp
operator|->
name|xvalue
argument_list|)
operator|+
literal|3
operator|+
sizeof|sizeof
name|tc
expr_stmt|;
name|tl
operator|=
name|dotp
operator|->
name|xvalue
operator|-
name|datbase
expr_stmt|;
name|writel
argument_list|(
operator|&
name|tl
argument_list|,
literal|1
argument_list|,
name|relfil
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|.
name|trsize
operator|+=
sizeof|sizeof
argument_list|(
name|dotp
operator|->
name|xvalue
argument_list|)
operator|+
literal|3
operator|+
sizeof|sizeof
name|tc
expr_stmt|;
name|writel
argument_list|(
operator|&
name|dotp
operator|->
name|xvalue
argument_list|,
literal|1
argument_list|,
name|relfil
argument_list|)
expr_stmt|;
block|}
comment|/* write the properties portion of a relocation datum */
if|if
condition|(
name|reltype
operator|==
name|XXTRN
operator|+
name|XUNDEF
condition|)
block|{
name|ts
operator|=
operator|(
name|xsym
operator|->
name|index
operator|)
expr_stmt|;
name|tc
operator|=
operator|(
name|XXTRN
operator|<<
literal|3
operator|)
operator||
operator|(
name|reftype
operator|-
name|LEN1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|reltype
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEFO
condition|)
block|{
name|ts
operator|=
operator|(
name|xsym
operator|->
name|index
operator|)
expr_stmt|;
name|tc
operator|=
operator|(
operator|(
name|XXTRN
operator|+
literal|2
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
name|reftype
operator|-
name|LEN1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ts
operator|=
operator|(
name|reltype
operator|)
expr_stmt|;
name|tc
operator|=
operator|(
name|reftype
operator|-
name|LEN1
operator|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ts
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|relfil
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|tc
argument_list|,
sizeof|sizeof
argument_list|(
name|tc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|relfil
argument_list|)
expr_stmt|;
block|}
comment|/* write the raw ("unrelocated") value to the text file */
name|t
operator|=
name|reflen
index|[
name|reftype
index|]
expr_stmt|;
name|dotp
operator|->
name|xvalue
operator|+=
name|t
expr_stmt|;
if|if
condition|(
name|reftype
operator|&
name|PCREL
condition|)
operator|*
name|pval
operator|-=
name|dotp
operator|->
name|xvalue
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
name|fwrite
argument_list|(
name|pval
argument_list|,
literal|1
argument_list|,
name|t
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|t
operator|>
literal|2
condition|)
block|{
name|fwrite
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|pval
operator|)
operator|.
name|loword
operator|)
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|pval
operator|)
operator|.
name|hiword
operator|)
argument_list|,
literal|1
argument_list|,
name|t
operator|-
literal|2
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
block|}
else|else
name|fwrite
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|pval
operator|)
operator|.
name|loword
operator|)
argument_list|,
literal|1
argument_list|,
name|t
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  *	Write out n symbols to file f, beginning at p  *	ignoring symbols that are obsolete, jxxx instructions, and  *	possibly, labels  */
end_comment

begin_function
name|int
name|sizesymtab
parameter_list|()
block|{
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
define|#
directive|define
name|NOUTSYMS
value|(nsyms - njxxx - nforgotten - (savelabels ? 0 : nlabels))
return|return
operator|(
operator|(
name|NCPS
operator|+
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|ptype
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|other
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|desc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|value
argument_list|)
operator|)
operator|*
name|NOUTSYMS
operator|)
return|;
block|}
end_function

begin_macro
name|symwrite
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|symsout
decl_stmt|;
comment|/*those actually written*/
name|int
name|symsdesired
init|=
name|NOUTSYMS
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ub
decl_stmt|;
ifdef|#
directive|ifdef
name|SORTEDOUTPUT
name|int
name|segno
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|copointer
decl_stmt|;
else|#
directive|else
specifier|register
name|struct
name|allocbox
modifier|*
name|allocwalk
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SORTEDOUTPUT
for|for
control|(
name|segno
operator|=
literal|0
operator|,
name|symsout
operator|=
literal|0
init|;
name|segno
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|segno
operator|++
control|)
name|SEGITERATE
argument_list|(
argument|segno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|copointer
argument_list|,
argument|sp
argument_list|,
argument|ub
argument_list|,
argument|++
argument_list|)
else|#
directive|else
name|symsout
operator|=
literal|0
expr_stmt|;
name|DECLITERATE
argument_list|(
argument|allocwalk
argument_list|,
argument|sp
argument_list|,
argument|ub
argument_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|sp
operator|->
name|tag
operator|>=
name|IGNOREBOUND
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|)
operator|&&
operator|(
name|sp
operator|->
name|tag
operator|==
name|LABELID
operator|)
operator|&&
operator|!
name|savelabels
condition|)
continue|continue;
name|symsout
operator|++
expr_stmt|;
name|fwrite
argument_list|(
name|sp
operator|->
name|name
argument_list|,
name|NCPS
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|&=
operator|~
name|XFORW
expr_stmt|;
name|fwrite
argument_list|(
operator|(
name|sp
operator|->
name|ptype
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
operator|(
name|sp
operator|->
name|ptype
operator|)
operator|)
else|:
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
operator|(
name|sp
operator|->
name|type
operator|)
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* 	 *	WATCH OUT.  THIS DEPENDS THAT THE ALLOCATION OF 	 *	the four fields ptype, other, desc and value are 	 *	contiguous.  This may have to be changed! 	 *	This is safe (as of 2-Nov-79). 	 */
name|fwrite
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|other
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|other
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|desc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|value
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|fooie
ifdef|#
directive|ifdef
name|vax
name|fwrite
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|name
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|sp
operator|->
name|ptype
condition|?
operator|&
operator|(
name|sp
operator|->
name|ptype
operator|)
else|:
operator|&
operator|(
name|sp
operator|->
name|type
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|other
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|other
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|desc
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|desc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|value
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|value
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|#
directive|else
name|writel
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
name|symsout
operator|!=
name|symsdesired
condition|)
name|yyerror
argument_list|(
literal|"INTERNAL ERROR: Wrote %d symbols, wanted to write %d symbols\n"
argument_list|,
name|symsout
argument_list|,
name|symsdesired
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|Flushfield
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|outb
argument_list|(
name|bitfield
argument_list|)
expr_stmt|;
name|bitfield
operator|>>=
literal|8
expr_stmt|;
name|n
operator|-=
literal|8
expr_stmt|;
block|}
name|bitoff
operator|=
literal|0
expr_stmt|;
name|bitfield
operator|=
literal|0
expr_stmt|;
block|}
end_block

end_unit

