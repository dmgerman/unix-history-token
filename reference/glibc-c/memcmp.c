begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991,1993,1995,1997,1998,2003,2004,2012    Free Software Foundation, Inc.    This file is part of the GNU C Library.    Contributed by Torbjorn Granlund (tege@sics.se).     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Lesser General Public    License as published by the Free Software Foundation; either    version 2.1 of the License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Lesser General Public License for more details.     You should have received a copy of the GNU Lesser General Public    License along with the GNU C Library; if not, see<http://www.gnu.org/licenses/>.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|__ptr_t
end_undef

begin_define
define|#
directive|define
name|__ptr_t
value|void *
end_define

begin_if
if|#
directive|if
name|defined
name|HAVE_STRING_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|memcmp
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<memcopy.h>
end_include

begin_include
include|#
directive|include
file|<endian.h>
end_include

begin_if
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|WORDS_BIGENDIAN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Not in the GNU C library.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* Type to use for aligned memory operations.    This should normally be the biggest type supported by a single load    and store.  Must be an unsigned type.  */
end_comment

begin_define
define|#
directive|define
name|op_t
value|unsigned long int
end_define

begin_define
define|#
directive|define
name|OPSIZ
value|(sizeof(op_t))
end_define

begin_comment
comment|/* Threshold value for when to enter the unrolled loops.  */
end_comment

begin_define
define|#
directive|define
name|OP_T_THRES
value|16
end_define

begin_comment
comment|/* Type to use for unaligned operations.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|char
name|byte
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|WORDS_BIGENDIAN
end_ifndef

begin_define
define|#
directive|define
name|MERGE
parameter_list|(
name|w0
parameter_list|,
name|sh_1
parameter_list|,
name|w1
parameter_list|,
name|sh_2
parameter_list|)
value|(((w0)>> (sh_1)) | ((w1)<< (sh_2)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MERGE
parameter_list|(
name|w0
parameter_list|,
name|sh_1
parameter_list|,
name|w1
parameter_list|,
name|sh_2
parameter_list|)
value|(((w0)<< (sh_1)) | ((w1)>> (sh_2)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In the GNU C library.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WORDS_BIGENDIAN
end_ifdef

begin_define
define|#
directive|define
name|CMP_LT_OR_GT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? 1 : -1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CMP_LT_OR_GT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|memcmp_bytes ((a), (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BE VERY CAREFUL IF YOU CHANGE THIS CODE!  */
end_comment

begin_comment
comment|/* The strategy of this memcmp is:     1. Compare bytes until one of the block pointers is aligned.     2. Compare using memcmp_common_alignment or       memcmp_not_common_alignment, regarding the alignment of the other       block after the initial byte operations.  The maximum number of       full words (of type op_t) are compared in this way.     3. Compare the few remaining bytes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WORDS_BIGENDIAN
end_ifndef

begin_comment
comment|/* memcmp_bytes -- Compare A and B bytewise in the byte order of the machine.    A and B are known to be different.    This is needed only on little-endian machines.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|memcmp_bytes
argument_list|(
name|op_t
argument_list|,
name|op_t
argument_list|)
name|__THROW
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
endif|#
directive|endif
specifier|static
name|int
name|memcmp_bytes
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|op_t
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|long
name|int
name|srcp1
init|=
operator|(
name|long
name|int
operator|)
operator|&
name|a
decl_stmt|;
name|long
name|int
name|srcp2
init|=
operator|(
name|long
name|int
operator|)
operator|&
name|b
decl_stmt|;
name|op_t
name|a0
decl_stmt|,
name|b0
decl_stmt|;
do|do
block|{
name|a0
operator|=
operator|(
operator|(
name|byte
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|b0
operator|=
operator|(
operator|(
name|byte
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|srcp1
operator|+=
literal|1
expr_stmt|;
name|srcp2
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|a0
operator|==
name|b0
condition|)
do|;
return|return
name|a0
operator|-
name|b0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|memcmp_common_alignment
argument_list|(
name|long
argument_list|,
name|long
argument_list|,
name|size_t
argument_list|)
name|__THROW
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* memcmp_common_alignment -- Compare blocks at SRCP1 and SRCP2 with LEN `op_t'    objects (not LEN bytes!).  Both SRCP1 and SRCP2 should be aligned for    memory operations on `op_t's.  */
end_comment

begin_function
specifier|static
name|int
name|memcmp_common_alignment
parameter_list|(
name|srcp1
parameter_list|,
name|srcp2
parameter_list|,
name|len
parameter_list|)
name|long
name|int
name|srcp1
decl_stmt|;
name|long
name|int
name|srcp2
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|op_t
name|a0
decl_stmt|,
name|a1
decl_stmt|;
name|op_t
name|b0
decl_stmt|,
name|b1
decl_stmt|;
switch|switch
condition|(
name|len
operator|%
literal|4
condition|)
block|{
default|default:
comment|/* Avoid warning about uninitialized local variables.  */
case|case
literal|2
case|:
name|a0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|b0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|srcp1
operator|-=
literal|2
operator|*
name|OPSIZ
expr_stmt|;
name|srcp2
operator|-=
literal|2
operator|*
name|OPSIZ
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
goto|goto
name|do1
goto|;
case|case
literal|3
case|:
name|a1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|b1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|srcp1
operator|-=
name|OPSIZ
expr_stmt|;
name|srcp2
operator|-=
name|OPSIZ
expr_stmt|;
name|len
operator|+=
literal|1
expr_stmt|;
goto|goto
name|do2
goto|;
case|case
literal|0
case|:
if|if
condition|(
name|OP_T_THRES
operator|<=
literal|3
operator|*
name|OPSIZ
operator|&&
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|a0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|b0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
goto|goto
name|do3
goto|;
case|case
literal|1
case|:
name|a1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|b1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|srcp1
operator|+=
name|OPSIZ
expr_stmt|;
name|srcp2
operator|+=
name|OPSIZ
expr_stmt|;
name|len
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|OP_T_THRES
operator|<=
literal|3
operator|*
name|OPSIZ
operator|&&
name|len
operator|==
literal|0
condition|)
goto|goto
name|do0
goto|;
comment|/* Fall through.  */
block|}
do|do
block|{
name|a0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|b0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|a1
operator|!=
name|b1
condition|)
return|return
name|CMP_LT_OR_GT
argument_list|(
name|a1
argument_list|,
name|b1
argument_list|)
return|;
name|do3
label|:
name|a1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|a0
operator|!=
name|b0
condition|)
return|return
name|CMP_LT_OR_GT
argument_list|(
name|a0
argument_list|,
name|b0
argument_list|)
return|;
name|do2
label|:
name|a0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|2
index|]
expr_stmt|;
name|b0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|a1
operator|!=
name|b1
condition|)
return|return
name|CMP_LT_OR_GT
argument_list|(
name|a1
argument_list|,
name|b1
argument_list|)
return|;
name|do1
label|:
name|a1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|3
index|]
expr_stmt|;
name|b1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|a0
operator|!=
name|b0
condition|)
return|return
name|CMP_LT_OR_GT
argument_list|(
name|a0
argument_list|,
name|b0
argument_list|)
return|;
name|srcp1
operator|+=
literal|4
operator|*
name|OPSIZ
expr_stmt|;
name|srcp2
operator|+=
literal|4
operator|*
name|OPSIZ
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|!=
literal|0
condition|)
do|;
comment|/* This is the right position for do0.  Please don't move      it into the loop.  */
name|do0
label|:
if|if
condition|(
name|a1
operator|!=
name|b1
condition|)
return|return
name|CMP_LT_OR_GT
argument_list|(
name|a1
argument_list|,
name|b1
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|memcmp_not_common_alignment
argument_list|(
name|long
argument_list|,
name|long
argument_list|,
name|size_t
argument_list|)
name|__THROW
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* memcmp_not_common_alignment -- Compare blocks at SRCP1 and SRCP2 with LEN    `op_t' objects (not LEN bytes!).  SRCP2 should be aligned for memory    operations on `op_t', but SRCP1 *should be unaligned*.  */
end_comment

begin_function
specifier|static
name|int
name|memcmp_not_common_alignment
parameter_list|(
name|srcp1
parameter_list|,
name|srcp2
parameter_list|,
name|len
parameter_list|)
name|long
name|int
name|srcp1
decl_stmt|;
name|long
name|int
name|srcp2
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|op_t
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|;
name|op_t
name|b0
decl_stmt|,
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|b3
decl_stmt|;
name|op_t
name|x
decl_stmt|;
name|int
name|shl
decl_stmt|,
name|shr
decl_stmt|;
comment|/* Calculate how to shift a word read at the memory operation      aligned srcp1 to make it aligned for comparison.  */
name|shl
operator|=
literal|8
operator|*
operator|(
name|srcp1
operator|%
name|OPSIZ
operator|)
expr_stmt|;
name|shr
operator|=
literal|8
operator|*
name|OPSIZ
operator|-
name|shl
expr_stmt|;
comment|/* Make SRCP1 aligned by rounding it down to the beginning of the `op_t'      it points in the middle of.  */
name|srcp1
operator|&=
operator|-
name|OPSIZ
expr_stmt|;
switch|switch
condition|(
name|len
operator|%
literal|4
condition|)
block|{
default|default:
comment|/* Avoid warning about uninitialized local variables.  */
case|case
literal|2
case|:
name|a1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|a2
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|b2
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|srcp1
operator|-=
literal|1
operator|*
name|OPSIZ
expr_stmt|;
name|srcp2
operator|-=
literal|2
operator|*
name|OPSIZ
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
goto|goto
name|do1
goto|;
case|case
literal|3
case|:
name|a0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|a1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|srcp2
operator|-=
literal|1
operator|*
name|OPSIZ
expr_stmt|;
name|len
operator|+=
literal|1
expr_stmt|;
goto|goto
name|do2
goto|;
case|case
literal|0
case|:
if|if
condition|(
name|OP_T_THRES
operator|<=
literal|3
operator|*
name|OPSIZ
operator|&&
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|a3
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|a0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|b0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|srcp1
operator|+=
literal|1
operator|*
name|OPSIZ
expr_stmt|;
goto|goto
name|do3
goto|;
case|case
literal|1
case|:
name|a2
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|a3
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|b3
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|srcp1
operator|+=
literal|2
operator|*
name|OPSIZ
expr_stmt|;
name|srcp2
operator|+=
literal|1
operator|*
name|OPSIZ
expr_stmt|;
name|len
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|OP_T_THRES
operator|<=
literal|3
operator|*
name|OPSIZ
operator|&&
name|len
operator|==
literal|0
condition|)
goto|goto
name|do0
goto|;
comment|/* Fall through.  */
block|}
do|do
block|{
name|a0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|b0
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|x
operator|=
name|MERGE
argument_list|(
name|a2
argument_list|,
name|shl
argument_list|,
name|a3
argument_list|,
name|shr
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|b3
condition|)
return|return
name|CMP_LT_OR_GT
argument_list|(
name|x
argument_list|,
name|b3
argument_list|)
return|;
name|do3
label|:
name|a1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|b1
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|x
operator|=
name|MERGE
argument_list|(
name|a3
argument_list|,
name|shl
argument_list|,
name|a0
argument_list|,
name|shr
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|b0
condition|)
return|return
name|CMP_LT_OR_GT
argument_list|(
name|x
argument_list|,
name|b0
argument_list|)
return|;
name|do2
label|:
name|a2
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|2
index|]
expr_stmt|;
name|b2
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|2
index|]
expr_stmt|;
name|x
operator|=
name|MERGE
argument_list|(
name|a0
argument_list|,
name|shl
argument_list|,
name|a1
argument_list|,
name|shr
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|b1
condition|)
return|return
name|CMP_LT_OR_GT
argument_list|(
name|x
argument_list|,
name|b1
argument_list|)
return|;
name|do1
label|:
name|a3
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|3
index|]
expr_stmt|;
name|b3
operator|=
operator|(
operator|(
name|op_t
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|3
index|]
expr_stmt|;
name|x
operator|=
name|MERGE
argument_list|(
name|a1
argument_list|,
name|shl
argument_list|,
name|a2
argument_list|,
name|shr
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|b2
condition|)
return|return
name|CMP_LT_OR_GT
argument_list|(
name|x
argument_list|,
name|b2
argument_list|)
return|;
name|srcp1
operator|+=
literal|4
operator|*
name|OPSIZ
expr_stmt|;
name|srcp2
operator|+=
literal|4
operator|*
name|OPSIZ
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|!=
literal|0
condition|)
do|;
comment|/* This is the right position for do0.  Please don't move      it into the loop.  */
name|do0
label|:
name|x
operator|=
name|MERGE
argument_list|(
name|a2
argument_list|,
name|shl
argument_list|,
name|a3
argument_list|,
name|shr
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|b3
condition|)
return|return
name|CMP_LT_OR_GT
argument_list|(
name|x
argument_list|,
name|b3
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|memcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|)
specifier|const
name|__ptr_t
name|s1
decl_stmt|;
specifier|const
name|__ptr_t
name|s2
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|op_t
name|a0
decl_stmt|;
name|op_t
name|b0
decl_stmt|;
name|long
name|int
name|srcp1
init|=
operator|(
name|long
name|int
operator|)
name|s1
decl_stmt|;
name|long
name|int
name|srcp2
init|=
operator|(
name|long
name|int
operator|)
name|s2
decl_stmt|;
name|op_t
name|res
decl_stmt|;
if|if
condition|(
name|len
operator|>=
name|OP_T_THRES
condition|)
block|{
comment|/* There are at least some bytes to compare.  No need to test 	 for LEN == 0 in this alignment loop.  */
while|while
condition|(
name|srcp2
operator|%
name|OPSIZ
operator|!=
literal|0
condition|)
block|{
name|a0
operator|=
operator|(
operator|(
name|byte
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|b0
operator|=
operator|(
operator|(
name|byte
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|srcp1
operator|+=
literal|1
expr_stmt|;
name|srcp2
operator|+=
literal|1
expr_stmt|;
name|res
operator|=
name|a0
operator|-
name|b0
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
name|res
return|;
name|len
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* SRCP2 is now aligned for memory operations on `op_t'. 	 SRCP1 alignment determines if we can do a simple, 	 aligned compare or need to shuffle bits.  */
if|if
condition|(
name|srcp1
operator|%
name|OPSIZ
operator|==
literal|0
condition|)
name|res
operator|=
name|memcmp_common_alignment
argument_list|(
name|srcp1
argument_list|,
name|srcp2
argument_list|,
name|len
operator|/
name|OPSIZ
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|memcmp_not_common_alignment
argument_list|(
name|srcp1
argument_list|,
name|srcp2
argument_list|,
name|len
operator|/
name|OPSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
name|res
return|;
comment|/* Number of bytes remaining in the interval [0..OPSIZ-1].  */
name|srcp1
operator|+=
name|len
operator|&
operator|-
name|OPSIZ
expr_stmt|;
name|srcp2
operator|+=
name|len
operator|&
operator|-
name|OPSIZ
expr_stmt|;
name|len
operator|%=
name|OPSIZ
expr_stmt|;
block|}
comment|/* There are just a few bytes to compare.  Use byte memory operations.  */
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|a0
operator|=
operator|(
operator|(
name|byte
operator|*
operator|)
name|srcp1
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|b0
operator|=
operator|(
operator|(
name|byte
operator|*
operator|)
name|srcp2
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|srcp1
operator|+=
literal|1
expr_stmt|;
name|srcp2
operator|+=
literal|1
expr_stmt|;
name|res
operator|=
name|a0
operator|-
name|b0
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
name|res
return|;
name|len
operator|-=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

