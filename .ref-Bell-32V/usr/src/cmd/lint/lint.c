begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"mfile1"
end_include

begin_include
include|#
directive|include
file|"lmanifest"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|VAL
value|0
end_define

begin_define
define|#
directive|define
name|EFF
value|1
end_define

begin_comment
comment|/* these are appropriate for the -p flag */
end_comment

begin_decl_stmt
name|int
name|SZCHAR
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SZINT
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SZFLOAT
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SZDOUBLE
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SZLONG
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SZSHORT
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SZPOINT
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ALCHAR
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ALINT
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ALFLOAT
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ALDOUBLE
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ALLONG
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ALSHORT
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ALPOINT
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ALSTRUCT
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vflag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tell about unused argments */
end_comment

begin_decl_stmt
name|int
name|xflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tell about unused externals */
end_comment

begin_decl_stmt
name|int
name|argflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to turn off complaints about arguments */
end_comment

begin_decl_stmt
name|int
name|libflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to generate library descriptions */
end_comment

begin_decl_stmt
name|int
name|vaflag
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to signal functions with a variable number of args */
end_comment

begin_decl_stmt
name|int
name|aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used th check precision of assignments */
end_comment

begin_decl_stmt
name|char
modifier|*
name|flabel
init|=
literal|"xxx"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LNAMES
value|100
end_define

begin_struct
struct|struct
name|lnm
block|{
name|short
name|lid
decl_stmt|,
name|flgs
decl_stmt|;
block|}
name|lnames
index|[
name|LNAMES
index|]
struct|,
modifier|*
name|lnp
struct|;
end_struct

begin_expr_stmt
name|contx
argument_list|(
name|p
argument_list|,
name|down
argument_list|,
name|pl
argument_list|,
name|pr
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
operator|*
name|pl
operator|,
operator|*
name|pr
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|*
name|pl
operator|=
operator|*
name|pr
operator|=
name|VAL
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
case|case
name|QUEST
case|:
operator|*
name|pr
operator|=
name|down
expr_stmt|;
break|break;
case|case
name|SCONV
case|:
case|case
name|PCONV
case|:
case|case
name|COLON
case|:
operator|*
name|pr
operator|=
operator|*
name|pl
operator|=
name|down
expr_stmt|;
break|break;
case|case
name|COMOP
case|:
operator|*
name|pl
operator|=
name|EFF
expr_stmt|;
operator|*
name|pr
operator|=
name|down
expr_stmt|;
case|case
name|FORCE
case|:
case|case
name|INIT
case|:
case|case
name|UNARY
name|CALL
case|:
case|case
name|STCALL
case|:
case|case
name|UNARY
name|STCALL
case|:
case|case
name|CALL
case|:
case|case
name|UNARY
name|FORTCALL
case|:
case|case
name|FORTCALL
case|:
case|case
name|CBRANCH
case|:
break|break;
default|default:
if|if
condition|(
name|asgop
argument_list|(
name|p
operator|->
name|op
argument_list|)
condition|)
break|break;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|UNARY
name|MUL
operator|&&
operator|(
name|p
operator|->
name|type
operator|==
name|STRTY
operator|||
name|p
operator|->
name|type
operator|==
name|UNIONTY
operator|)
condition|)
block|{
break|break;
comment|/* the compiler does this... */
block|}
if|if
condition|(
name|down
operator|==
name|EFF
operator|&&
name|hflag
condition|)
name|werror
argument_list|(
literal|"null effect"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ecode
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* compile code for p */
name|fwalk
argument_list|(
name|p
argument_list|,
name|contx
argument_list|,
name|EFF
argument_list|)
expr_stmt|;
name|lnp
operator|=
name|lnames
expr_stmt|;
name|lprt
argument_list|(
name|p
argument_list|,
name|EFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ejobcode
argument_list|(
argument|flag
argument_list|)
end_macro

begin_block
block|{
comment|/* called after processing each job */
comment|/* flag is nonzero if errors were detected */
specifier|register
name|k
expr_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|stab
init|;
name|p
operator|<
operator|&
name|stab
index|[
name|SYMTSZ
index|]
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|p
operator|->
name|stype
operator|!=
name|TNULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|stype
operator|==
name|STRTY
operator|||
name|p
operator|->
name|stype
operator|==
name|UNIONTY
condition|)
block|{
if|if
condition|(
name|dimtab
index|[
name|p
operator|->
name|sizoff
operator|+
literal|1
index|]
operator|<
literal|0
condition|)
block|{
comment|/* never defined */
if|if
condition|(
name|hflag
condition|)
name|werror
argument_list|(
literal|"struct/union %.7s never defined"
argument_list|,
name|p
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|p
operator|->
name|sclass
condition|)
block|{
case|case
name|STATIC
case|:
if|if
condition|(
name|p
operator|->
name|suse
operator|>
literal|0
condition|)
block|{
name|k
operator|=
name|lineno
expr_stmt|;
name|lineno
operator|=
name|p
operator|->
name|suse
expr_stmt|;
name|uerror
argument_list|(
literal|"static variable %s unused"
argument_list|,
name|p
operator|->
name|sname
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|k
expr_stmt|;
break|break;
block|}
case|case
name|EXTERN
case|:
case|case
name|USTATIC
case|:
comment|/* with the xflag, worry about externs not used */
comment|/* the filename may be wrong here... */
if|if
condition|(
name|xflag
operator|&&
name|p
operator|->
name|suse
operator|>=
literal|0
operator|&&
operator|!
name|libflag
condition|)
block|{
name|printf
argument_list|(
literal|"%.7s\t%03d\t%o\t%d\t"
argument_list|,
name|p
operator|->
name|sname
argument_list|,
name|LDX
argument_list|,
name|p
operator|->
name|stype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we don't really know the file number; we know only the line  						number, so we put only that out */
name|printf
argument_list|(
literal|"\"???\"\t%d\t%s\n"
argument_list|,
name|p
operator|->
name|suse
argument_list|,
name|flabel
argument_list|)
expr_stmt|;
block|}
case|case
name|EXTDEF
case|:
if|if
condition|(
name|p
operator|->
name|suse
operator|<
literal|0
condition|)
block|{
comment|/* used */
name|printf
argument_list|(
literal|"%.7s\t%03d\t%o\t%d\t"
argument_list|,
name|exname
argument_list|(
name|p
operator|->
name|sname
argument_list|)
argument_list|,
name|LUM
argument_list|,
name|p
operator|->
name|stype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fident
argument_list|(
operator|-
name|p
operator|->
name|suse
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fident
argument_list|(
argument|line
argument_list|)
end_macro

begin_block
block|{
comment|/* like ident, but lineno = line */
specifier|register
name|temp
expr_stmt|;
name|temp
operator|=
name|lineno
expr_stmt|;
name|lineno
operator|=
name|line
expr_stmt|;
name|ident
argument_list|()
expr_stmt|;
name|lineno
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_macro
name|ident
argument_list|()
end_macro

begin_block
block|{
comment|/* write out file and line identification  */
name|printf
argument_list|(
literal|"%s\t%d\t%s\n"
argument_list|,
name|ftitle
argument_list|,
name|lineno
argument_list|,
name|flabel
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bfcode
argument_list|(
argument|a
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* code for the beginning of a function; a is an array of 		indices in stab for the arguments; n is the number */
comment|/* this must also set retlab */
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|cfp
decl_stmt|;
specifier|register
name|unsigned
name|t
decl_stmt|;
name|retlab
operator|=
literal|1
expr_stmt|;
name|cfp
operator|=
operator|&
name|stab
index|[
name|curftn
index|]
expr_stmt|;
comment|/* if variable number of arguments, only print the ones which will be checked */
if|if
condition|(
name|vaflag
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
name|vaflag
condition|)
name|werror
argument_list|(
literal|"declare the VARARGS arguments you want checked!"
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|vaflag
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%.7s\t%03d\t%o\t%d\t"
argument_list|,
name|exname
argument_list|(
name|cfp
operator|->
name|sname
argument_list|)
argument_list|,
name|libflag
condition|?
name|LIB
else|:
name|LDI
argument_list|,
name|cfp
operator|->
name|stype
argument_list|,
name|vaflag
operator|>=
literal|0
condition|?
operator|-
name|n
else|:
name|n
argument_list|)
expr_stmt|;
name|vaflag
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|t
operator|=
name|stab
index|[
name|a
index|[
name|i
index|]
index|]
operator|.
name|stype
condition|)
block|{
case|case
name|ULONG
case|:
break|break;
case|case
name|CHAR
case|:
case|case
name|SHORT
case|:
name|t
operator|=
name|INT
expr_stmt|;
break|break;
case|case
name|UCHAR
case|:
case|case
name|USHORT
case|:
case|case
name|UNSIGNED
case|:
name|t
operator|=
name|UNSIGNED
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%o\t"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|ident
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ctargs
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* count arguments; p points to at least one */
comment|/* the arguemnts are a tower of commasto the left */
specifier|register
name|c
expr_stmt|;
name|c
operator|=
literal|1
expr_stmt|;
comment|/* count the rhs */
while|while
condition|(
name|p
operator|->
name|op
operator|==
name|CM
condition|)
block|{
operator|++
name|c
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_macro
name|lpta
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TWORD
name|t
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CM
condition|)
block|{
name|lpta
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
block|}
switch|switch
condition|(
name|t
operator|=
name|p
operator|->
name|type
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|SHORT
case|:
name|t
operator|=
name|INT
expr_stmt|;
case|case
name|LONG
case|:
case|case
name|ULONG
case|:
case|case
name|INT
case|:
case|case
name|UNSIGNED
case|:
break|break;
case|case
name|UCHAR
case|:
case|case
name|USHORT
case|:
name|t
operator|=
name|UNSIGNED
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|printf
argument_list|(
literal|"%o\t"
argument_list|,
name|DOUBLE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|printf
argument_list|(
literal|"%o\t"
argument_list|,
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ICON
condition|)
name|printf
argument_list|(
literal|"%o<1\t"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%o\t"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|VALSET
value|1
end_define

begin_define
define|#
directive|define
name|VALUSED
value|2
end_define

begin_define
define|#
directive|define
name|VALASGOP
value|4
end_define

begin_define
define|#
directive|define
name|VALADDR
value|8
end_define

begin_expr_stmt
name|lprt
argument_list|(
name|p
argument_list|,
name|down
argument_list|,
name|uses
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|q
decl_stmt|;
specifier|register
name|id
expr_stmt|;
specifier|register
name|acount
expr_stmt|;
specifier|register
name|down1
operator|,
name|down2
expr_stmt|;
specifier|register
name|use1
operator|,
name|use2
expr_stmt|;
specifier|register
name|struct
name|lnm
modifier|*
name|np1
decl_stmt|,
modifier|*
name|np2
decl_stmt|;
comment|/* first, set variables which are set... */
name|use1
operator|=
name|use2
operator|=
name|VALUSED
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ASSIGN
condition|)
name|use1
operator|=
name|VALSET
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|UNARY
name|AND
condition|)
name|use1
operator|=
name|VALADDR
expr_stmt|;
elseif|else
if|if
condition|(
name|asgop
argument_list|(
name|p
operator|->
name|op
argument_list|)
condition|)
block|{
comment|/* =ops */
name|use1
operator|=
name|VALUSED
operator||
name|VALSET
expr_stmt|;
if|if
condition|(
name|down
operator|==
name|EFF
condition|)
name|use1
operator||=
name|VALASGOP
expr_stmt|;
block|}
comment|/* print the lines for lint */
name|down2
operator|=
name|down1
operator|=
name|VAL
expr_stmt|;
name|acount
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|type
operator|==
name|CHAR
operator|&&
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|right
operator|->
name|lval
operator|<
literal|0
condition|)
block|{
name|werror
argument_list|(
literal|"nonportable character comparison"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|->
name|op
operator|==
name|EQ
operator|||
name|p
operator|->
name|op
operator|==
name|NE
operator|)
operator|&&
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|left
operator|->
name|type
argument_list|)
operator|&&
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|lval
operator|<
literal|0
operator|&&
name|p
operator|->
name|right
operator|->
name|rval
operator|==
name|NONAME
operator|&&
operator|!
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|right
operator|->
name|type
argument_list|)
condition|)
block|{
name|werror
argument_list|(
literal|"comparison of unsigned with negative constant"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|UGE
case|:
case|case
name|ULT
case|:
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|right
operator|->
name|lval
operator|==
literal|0
operator|&&
name|p
operator|->
name|right
operator|->
name|rval
operator|==
name|NONAME
condition|)
block|{
name|werror
argument_list|(
literal|"unsigned comparison with 0?"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UGT
case|:
case|case
name|ULE
case|:
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|right
operator|->
name|lval
operator|<=
literal|0
operator|&&
operator|!
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|right
operator|->
name|type
argument_list|)
operator|&&
name|p
operator|->
name|right
operator|->
name|rval
operator|==
name|NONAME
condition|)
block|{
name|werror
argument_list|(
literal|"degenerate unsigned comparison"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COMOP
case|:
name|down1
operator|=
name|EFF
expr_stmt|;
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
case|case
name|QUEST
case|:
name|down2
operator|=
name|down
expr_stmt|;
comment|/* go recursively left, then right  */
name|np1
operator|=
name|lnp
expr_stmt|;
name|lprt
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|down1
argument_list|,
name|use1
argument_list|)
expr_stmt|;
name|np2
operator|=
name|lnp
expr_stmt|;
name|lprt
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|down2
argument_list|,
name|use2
argument_list|)
expr_stmt|;
name|lmerge
argument_list|(
name|np1
argument_list|,
name|np2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCONV
case|:
case|case
name|PCONV
case|:
case|case
name|COLON
case|:
name|down1
operator|=
name|down2
operator|=
name|down
expr_stmt|;
break|break;
case|case
name|CALL
case|:
case|case
name|STCALL
case|:
case|case
name|FORTCALL
case|:
name|acount
operator|=
name|ctargs
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
case|case
name|UNARY
name|CALL
case|:
case|case
name|UNARY
name|STCALL
case|:
case|case
name|UNARY
name|FORTCALL
case|:
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|ICON
operator|&&
operator|(
name|id
operator|=
name|p
operator|->
name|left
operator|->
name|rval
operator|)
operator|!=
name|NONAME
condition|)
block|{
comment|/* used to be&name */
name|printf
argument_list|(
literal|"%.7s\t%03d\t%o\t%d\t"
argument_list|,
name|exname
argument_list|(
name|stab
index|[
name|id
index|]
operator|.
name|sname
argument_list|)
argument_list|,
name|down
operator|==
name|EFF
condition|?
name|LUE
else|:
name|LUV
argument_list|,
name|DECREF
argument_list|(
name|p
operator|->
name|left
operator|->
name|type
argument_list|)
argument_list|,
name|acount
argument_list|)
expr_stmt|;
if|if
condition|(
name|acount
condition|)
name|lpta
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
name|ident
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|ICON
case|:
comment|/* look for&name case */
if|if
condition|(
operator|(
name|id
operator|=
name|p
operator|->
name|rval
operator|)
operator|>=
literal|0
operator|&&
name|id
operator|!=
name|NONAME
condition|)
block|{
name|q
operator|=
operator|&
name|stab
index|[
name|id
index|]
expr_stmt|;
name|q
operator|->
name|sflags
operator||=
operator|(
name|SREF
operator||
name|SSET
operator|)
expr_stmt|;
block|}
return|return;
case|case
name|NAME
case|:
if|if
condition|(
operator|(
name|id
operator|=
name|p
operator|->
name|rval
operator|)
operator|>=
literal|0
operator|&&
name|id
operator|!=
name|NONAME
condition|)
block|{
name|q
operator|=
operator|&
name|stab
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|uses
operator|&
name|VALUSED
operator|)
operator|&&
operator|!
operator|(
name|q
operator|->
name|sflags
operator|&
name|SSET
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|sclass
operator|==
name|AUTO
operator|||
name|q
operator|->
name|sclass
operator|==
name|REGISTER
condition|)
block|{
if|if
condition|(
operator|!
name|ISARY
argument_list|(
name|q
operator|->
name|stype
argument_list|)
operator|&&
operator|!
name|ISFTN
argument_list|(
name|q
operator|->
name|stype
argument_list|)
operator|&&
name|q
operator|->
name|stype
operator|!=
name|STRTY
condition|)
block|{
name|werror
argument_list|(
literal|"%.7s may be used before set"
argument_list|,
name|q
operator|->
name|sname
argument_list|)
expr_stmt|;
name|q
operator|->
name|sflags
operator||=
name|SSET
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|uses
operator|&
name|VALASGOP
condition|)
break|break;
comment|/* not a real use */
if|if
condition|(
name|uses
operator|&
name|VALSET
condition|)
name|q
operator|->
name|sflags
operator||=
name|SSET
expr_stmt|;
if|if
condition|(
name|uses
operator|&
name|VALUSED
condition|)
name|q
operator|->
name|sflags
operator||=
name|SREF
expr_stmt|;
if|if
condition|(
name|uses
operator|&
name|VALADDR
condition|)
name|q
operator|->
name|sflags
operator||=
operator|(
name|SREF
operator||
name|SSET
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lval
operator|==
literal|0
condition|)
block|{
name|lnp
operator|->
name|lid
operator|=
name|id
expr_stmt|;
name|lnp
operator|->
name|flgs
operator|=
operator|(
name|uses
operator|&
name|VALADDR
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|uses
operator|&
name|VALSET
operator|)
condition|?
name|VALSET
else|:
name|VALUSED
operator|)
expr_stmt|;
if|if
condition|(
operator|++
name|lnp
operator|>=
operator|&
name|lnames
index|[
name|LNAMES
index|]
condition|)
operator|--
name|lnp
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* recurse, going down the right side first if we can */
switch|switch
condition|(
name|optype
argument_list|(
name|p
operator|->
name|op
argument_list|)
condition|)
block|{
case|case
name|BITYPE
case|:
name|np1
operator|=
name|lnp
expr_stmt|;
name|lprt
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|down2
argument_list|,
name|use2
argument_list|)
expr_stmt|;
case|case
name|UTYPE
case|:
name|np2
operator|=
name|lnp
expr_stmt|;
name|lprt
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|down1
argument_list|,
name|use1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optype
argument_list|(
name|p
operator|->
name|op
argument_list|)
operator|==
name|BITYPE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ASSIGN
operator|&&
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|NAME
condition|)
block|{
comment|/* special case for a =  .. a .. */
name|lmerge
argument_list|(
name|np1
argument_list|,
name|np2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|lmerge
argument_list|(
name|np1
argument_list|,
name|np2
argument_list|,
name|p
operator|->
name|op
operator|!=
name|COLON
argument_list|)
expr_stmt|;
comment|/* look for assignments to fields, and complain */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ASSIGN
operator|&&
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|FLD
operator|&&
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
condition|)
name|fldcon
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|lmerge
argument_list|(
argument|np1
argument_list|,
argument|np2
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|lnm
modifier|*
name|np1
decl_stmt|,
modifier|*
name|np2
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* np1 and np2 point to lists of lnm members, for the two sides 	 * of a binary operator 	 * flag is 1 if commutation is possible, 0 otherwise 	 * lmerge returns a merged list, starting at np1, resetting lnp 	 * it also complains, if appropriate, about side effects 	 */
specifier|register
name|struct
name|lnm
modifier|*
name|npx
decl_stmt|,
modifier|*
name|npy
decl_stmt|;
for|for
control|(
name|npx
operator|=
name|np2
init|;
name|npx
operator|<
name|lnp
condition|;
operator|++
name|npx
control|)
block|{
comment|/* is it already there? */
for|for
control|(
name|npy
operator|=
name|np1
init|;
name|npy
operator|<
name|np2
condition|;
operator|++
name|npy
control|)
block|{
if|if
condition|(
name|npx
operator|->
name|lid
operator|==
name|npy
operator|->
name|lid
condition|)
block|{
comment|/* yes */
if|if
condition|(
name|npx
operator|->
name|flgs
operator|==
literal|0
operator|||
name|npx
operator|->
name|flgs
operator|==
operator|(
name|VALSET
operator||
name|VALUSED
operator|)
condition|)
empty_stmt|;
comment|/* do nothing */
elseif|else
if|if
condition|(
operator|(
name|npx
operator|->
name|flgs
operator||
name|npy
operator|->
name|flgs
operator|)
operator|==
operator|(
name|VALSET
operator||
name|VALUSED
operator|)
operator|||
operator|(
name|npx
operator|->
name|flgs
operator|&
name|npy
operator|->
name|flgs
operator|&
name|VALSET
operator|)
condition|)
block|{
if|if
condition|(
name|flag
condition|)
name|werror
argument_list|(
literal|"%.8s evaluation order undefined"
argument_list|,
name|stab
index|[
name|npy
operator|->
name|lid
index|]
operator|.
name|sname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npy
operator|->
name|flgs
operator|==
literal|0
condition|)
name|npx
operator|->
name|flgs
operator|=
literal|0
expr_stmt|;
else|else
name|npy
operator|->
name|flgs
operator||=
name|npx
operator|->
name|flgs
expr_stmt|;
goto|goto
name|foundit
goto|;
block|}
block|}
comment|/* not there: update entry */
name|np2
operator|->
name|lid
operator|=
name|npx
operator|->
name|lid
expr_stmt|;
name|np2
operator|->
name|flgs
operator|=
name|npx
operator|->
name|flgs
expr_stmt|;
operator|++
name|np2
expr_stmt|;
name|foundit
label|:
empty_stmt|;
block|}
comment|/* all finished: merged list is at np1 */
name|lnp
operator|=
name|np2
expr_stmt|;
block|}
end_block

begin_macro
name|efcode
argument_list|()
end_macro

begin_block
block|{
comment|/* code for the end of a function */
specifier|register
name|struct
name|symtab
modifier|*
name|cfp
decl_stmt|;
name|cfp
operator|=
operator|&
name|stab
index|[
name|curftn
index|]
expr_stmt|;
if|if
condition|(
name|retstat
operator|&
name|RETVAL
condition|)
block|{
name|printf
argument_list|(
literal|"%.7s\t%03d\t%o\t%d\t"
argument_list|,
name|exname
argument_list|(
name|cfp
operator|->
name|sname
argument_list|)
argument_list|,
name|LRV
argument_list|,
name|DECREF
argument_list|(
name|cfp
operator|->
name|stype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ident
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vflag
condition|)
block|{
name|vflag
operator|=
name|argflag
expr_stmt|;
name|argflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|retstat
operator|==
name|RETVAL
operator|+
name|NRETVAL
condition|)
name|werror
argument_list|(
literal|"function %.8s has return(e); and return;"
argument_list|,
name|cfp
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|aocode
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* called when automatic p removed from stab */
specifier|register
name|struct
name|symtab
modifier|*
name|cfs
decl_stmt|;
name|cfs
operator|=
operator|&
name|stab
index|[
name|curftn
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|suse
operator|>
literal|0
operator|&&
operator|!
operator|(
name|p
operator|->
name|sflags
operator|&
name|SMOS
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|sclass
operator|==
name|PARAM
condition|)
block|{
if|if
condition|(
name|vflag
condition|)
name|werror
argument_list|(
literal|"argument %.7s unused in function %.7s"
argument_list|,
name|p
operator|->
name|sname
argument_list|,
name|cfs
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|sclass
operator|!=
name|TYPEDEF
condition|)
name|werror
argument_list|(
literal|"%.7s unused in function %.7s"
argument_list|,
name|p
operator|->
name|sname
argument_list|,
name|cfs
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|suse
operator|<
literal|0
operator|&&
operator|(
name|p
operator|->
name|sflags
operator|&
operator|(
name|SSET
operator||
name|SREF
operator||
name|SMOS
operator|)
operator|)
operator|==
name|SSET
operator|&&
operator|!
name|ISARY
argument_list|(
name|p
operator|->
name|stype
argument_list|)
operator|&&
operator|!
name|ISFTN
argument_list|(
name|p
operator|->
name|stype
argument_list|)
condition|)
block|{
name|werror
argument_list|(
literal|"%.7s set but not used in function %.7s"
argument_list|,
name|p
operator|->
name|sname
argument_list|,
name|cfs
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|stype
operator|==
name|STRTY
operator|||
name|p
operator|->
name|stype
operator|==
name|UNIONTY
operator|||
name|p
operator|->
name|stype
operator|==
name|ENUMTY
condition|)
block|{
if|if
condition|(
name|dimtab
index|[
name|p
operator|->
name|sizoff
operator|+
literal|1
index|]
operator|<
literal|0
condition|)
name|werror
argument_list|(
literal|"structure %.7s never defined"
argument_list|,
name|p
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|defnam
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* define the current location as the name p->sname */
if|if
condition|(
name|p
operator|->
name|sclass
operator|==
name|STATIC
operator|&&
name|p
operator|->
name|slevel
operator|>
literal|1
condition|)
return|return;
if|if
condition|(
operator|!
name|ISFTN
argument_list|(
name|p
operator|->
name|stype
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%.7s\t%03d\t%o\t%d\t"
argument_list|,
name|exname
argument_list|(
name|p
operator|->
name|sname
argument_list|)
argument_list|,
name|libflag
condition|?
name|LIB
else|:
name|LDI
argument_list|,
name|p
operator|->
name|stype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ident
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|zecode
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* n integer words of zeros */
name|OFFSZ
name|temp
decl_stmt|;
name|temp
operator|=
name|n
expr_stmt|;
name|inoff
operator|+=
name|temp
operator|*
name|SZINT
expr_stmt|;
empty_stmt|;
block|}
end_block

begin_macro
name|andable
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* p is a NAME node; can it accept& ? */
specifier|register
name|r
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|NAME
condition|)
name|cerror
argument_list|(
literal|"andable error"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|p
operator|->
name|rval
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* labels are andable */
if|if
condition|(
name|stab
index|[
name|r
index|]
operator|.
name|sclass
operator|==
name|AUTO
operator|||
name|stab
index|[
name|r
index|]
operator|.
name|sclass
operator|==
name|PARAM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|NODE
modifier|*
name|clocal
parameter_list|(
name|p
parameter_list|)
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* this is called to do local transformations on 	   an expression tree preparitory to its being 	   written out in intermediate code. 	*/
comment|/* the major essential job is rewriting the 	   automatic variables and arguments in terms of 	   REG and OREG nodes */
comment|/* conversion ops which are not necessary are also clobbered here */
comment|/* in addition, any special features (such as rewriting 	   exclusive or) are easily handled here as well */
specifier|register
name|o
expr_stmt|;
specifier|register
name|unsigned
name|t
decl_stmt|,
name|tl
decl_stmt|;
switch|switch
condition|(
name|o
operator|=
name|p
operator|->
name|op
condition|)
block|{
case|case
name|SCONV
case|:
case|case
name|PCONV
case|:
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|type
operator|==
name|ENUMTY
condition|)
block|{
name|p
operator|->
name|left
operator|=
name|pconvert
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
comment|/* assume conversion takes place; type is inherited */
name|t
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|tl
operator|=
name|p
operator|->
name|left
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|aflag
operator|&&
operator|(
name|tl
operator|==
name|LONG
operator|||
name|tl
operator|==
name|ULONG
operator|)
operator|&&
operator|(
name|t
operator|!=
name|LONG
operator|&&
name|t
operator|!=
name|ULONG
operator|)
condition|)
block|{
name|werror
argument_list|(
literal|"long assignment may lose accuracy"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISPTR
argument_list|(
name|tl
argument_list|)
operator|&&
name|ISPTR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tl
operator|=
name|DECREF
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|t
operator|=
name|DECREF
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ISFTN
argument_list|(
name|t
argument_list|)
operator|+
name|ISFTN
argument_list|(
name|tl
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* neither is a function pointer */
if|if
condition|(
name|talign
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|csiz
argument_list|)
operator|>
name|talign
argument_list|(
name|tl
argument_list|,
name|p
operator|->
name|left
operator|->
name|csiz
argument_list|)
condition|)
block|{
if|if
condition|(
name|hflag
operator|||
name|pflag
condition|)
name|werror
argument_list|(
literal|"possible pointer alignment problem"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|werror
argument_list|(
literal|"questionable conversion of function pointer"
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
empty_stmt|;
block|}
block|}
name|p
operator|->
name|left
operator|->
name|type
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|p
operator|->
name|left
operator|->
name|cdim
operator|=
name|p
operator|->
name|cdim
expr_stmt|;
name|p
operator|->
name|left
operator|->
name|csiz
operator|=
name|p
operator|->
name|csiz
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|left
operator|)
return|;
case|case
name|PVCONV
case|:
case|case
name|PMCONV
case|:
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|!=
name|ICON
condition|)
name|cerror
argument_list|(
literal|"bad conversion"
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
return|return
operator|(
name|buildtree
argument_list|(
name|o
operator|==
name|PMCONV
condition|?
name|MUL
else|:
name|DIV
argument_list|,
name|p
operator|->
name|left
argument_list|,
name|p
operator|->
name|right
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|offcon
parameter_list|(
name|off
parameter_list|,
name|t
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
name|OFFSZ
name|off
decl_stmt|;
name|TWORD
name|t
decl_stmt|;
block|{
comment|/* make a structure offset node */
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|bcon
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|lval
operator|=
name|off
operator|/
name|SZCHAR
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|noinit
argument_list|()
end_macro

begin_block
block|{
comment|/* storage class for such as "int a;" */
return|return
operator|(
name|pflag
condition|?
name|EXTDEF
else|:
name|EXTERN
operator|)
return|;
block|}
end_block

begin_macro
name|cinit
argument_list|(
argument|p
argument_list|,
argument|sz
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* initialize p into size sz */
name|inoff
operator|+=
name|sz
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|INIT
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|ICON
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|NAME
operator|&&
name|p
operator|->
name|left
operator|->
name|type
operator|==
name|MOE
condition|)
return|return;
block|}
name|uerror
argument_list|(
literal|"illegal initialization"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|exname
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
comment|/* make a name look like an external name in the local machine */
specifier|static
name|char
name|aa
index|[
literal|8
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|pflag
condition|)
return|return
operator|(
name|p
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|aa
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
name|aa
index|[
name|i
index|]
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|++
name|p
expr_stmt|;
block|}
name|aa
index|[
literal|6
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|aa
operator|)
return|;
block|}
end_function

begin_macro
name|where
argument_list|(
argument|f
argument_list|)
end_macro

begin_block
block|{
comment|/* print true location of error */
if|if
condition|(
name|f
operator|==
literal|'u'
operator|&&
name|nerrors
operator|>
literal|1
condition|)
operator|--
name|nerrors
expr_stmt|;
comment|/* don't get "too many errors" */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, line %d: "
argument_list|,
name|ftitle
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* a number of dummy routines, unneeded by lint */
end_comment

begin_macro
name|branch
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_macro
name|defalign
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_macro
name|deflab
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_macro
name|bycode
argument_list|(
argument|t
argument_list|,
argument|i
argument_list|)
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_macro
name|cisreg
argument_list|(
argument|t
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* everyting is a register variable! */
end_comment

begin_macro
name|fldty
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
empty_stmt|;
comment|/* all types are OK here... */
block|}
end_block

begin_macro
name|fldal
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* field alignment... */
if|if
condition|(
name|t
operator|==
name|ENUMTY
condition|)
return|return
operator|(
name|ALCHAR
operator|)
return|;
comment|/* this should be thought through better... */
if|if
condition|(
name|ISPTR
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* really for the benefit of honeywell (and someday IBM) */
if|if
condition|(
name|pflag
condition|)
name|uerror
argument_list|(
literal|"nonportable field type"
argument_list|)
expr_stmt|;
block|}
else|else
name|uerror
argument_list|(
literal|"illegal field type"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ALINT
operator|)
return|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* handle options */
for|for
control|(
name|p
operator|=
name|argv
index|[
literal|1
index|]
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'-'
case|:
continue|continue;
case|case
literal|'L'
case|:
comment|/* produced by driver program */
name|flabel
operator|=
name|p
expr_stmt|;
goto|goto
name|break2
goto|;
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'b'
case|:
name|brkflag
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
name|pflag
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|cflag
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
comment|/* for the moment, -s triggers -h */
case|case
literal|'h'
case|:
name|hflag
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'v'
case|:
name|vflag
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
name|xflag
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
name|aflag
operator|=
literal|1
expr_stmt|;
case|case
literal|'u'
case|:
comment|/* done in second pass */
case|case
literal|'n'
case|:
comment|/* done in shell script */
continue|continue;
case|case
literal|'t'
case|:
name|werror
argument_list|(
literal|"option %c now default: see `man 6 lint'"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|uerror
argument_list|(
literal|"illegal option: %c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|break2
label|:
if|if
condition|(
operator|!
name|pflag
condition|)
block|{
comment|/* set sizes to sizes of target machine */
ifdef|#
directive|ifdef
name|gcos
name|SZCHAR
operator|=
name|ALCHAR
operator|=
literal|9
expr_stmt|;
else|#
directive|else
name|SZCHAR
operator|=
name|ALCHAR
operator|=
literal|8
expr_stmt|;
endif|#
directive|endif
name|SZINT
operator|=
name|ALINT
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|SZCHAR
expr_stmt|;
name|SZFLOAT
operator|=
name|ALFLOAT
operator|=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
operator|*
name|SZCHAR
expr_stmt|;
name|SZDOUBLE
operator|=
name|ALDOUBLE
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
name|SZCHAR
expr_stmt|;
name|SZLONG
operator|=
name|ALLONG
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|SZCHAR
expr_stmt|;
name|SZSHORT
operator|=
name|ALSHORT
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
name|SZCHAR
expr_stmt|;
name|SZPOINT
operator|=
name|ALPOINT
operator|=
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|*
name|SZCHAR
expr_stmt|;
name|ALSTRUCT
operator|=
name|ALINT
expr_stmt|;
comment|/* now, fix some things up for various machines (I wish we had "alignof") */
ifdef|#
directive|ifdef
name|pdp11
name|ALLONG
operator|=
name|ALDOUBLE
operator|=
name|ALFLOAT
operator|=
name|ALINT
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ibm
name|ALSTRUCT
operator|=
name|ALCHAR
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|mainp1
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|ctype
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* are there any funny types? */
return|return
operator|(
name|type
operator|)
return|;
block|}
end_block

begin_macro
name|commdec
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
comment|/* put out a common declaration */
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|&
name|stab
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%.7s\t%03d\t%o\t%d\t"
argument_list|,
name|exname
argument_list|(
name|p
operator|->
name|sname
argument_list|)
argument_list|,
name|libflag
condition|?
name|LIB
else|:
name|LDC
argument_list|,
name|p
operator|->
name|stype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ident
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|isitfloat
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* s is a character string; 	   if floating point is implemented, set dcon to the value of s */
comment|/* lint version 	*/
name|dcon
operator|=
name|atof
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|FCON
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|fldcon
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* p is an assignment of a constant to a field */
comment|/* check to see if the assignment is going to overflow, or otherwise cause trouble */
specifier|register
name|s
expr_stmt|;
name|CONSZ
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|hflag
operator|&
operator|!
name|pflag
condition|)
return|return;
name|s
operator|=
name|UPKFSZ
argument_list|(
name|p
operator|->
name|left
operator|->
name|rval
argument_list|)
expr_stmt|;
name|v
operator|=
name|p
operator|->
name|right
operator|->
name|lval
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|left
operator|->
name|type
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|INT
case|:
case|case
name|SHORT
case|:
case|case
name|LONG
case|:
case|case
name|ENUMTY
case|:
if|if
condition|(
name|v
operator|>=
literal|0
operator|&&
operator|(
name|v
operator|>>
operator|(
name|s
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|werror
argument_list|(
literal|"precision lost in assignment to (possibly sign-extended) field"
argument_list|)
expr_stmt|;
default|default:
return|return;
case|case
name|UNSIGNED
case|:
case|case
name|UCHAR
case|:
case|case
name|USHORT
case|:
case|case
name|ULONG
case|:
if|if
condition|(
name|v
operator|<
literal|0
operator|||
operator|(
name|v
operator|>>
name|s
operator|)
operator|!=
literal|0
condition|)
name|werror
argument_list|(
literal|"precision lost in field assignment"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

end_unit

