begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|NI
value|16
end_define

begin_define
define|#
directive|define
name|NB
value|10
end_define

begin_define
define|#
directive|define
name|BITS
value|8
end_define

begin_define
define|#
directive|define
name|MAXFN
value|500
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|STANDALONE
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/inode.h>
end_include

begin_include
include|#
directive|include
file|<sys/ino.h>
end_include

begin_include
include|#
directive|include
file|<sys/fblk.h>
end_include

begin_include
include|#
directive|include
file|<sys/filsys.h>
end_include

begin_decl_stmt
name|struct
name|filsys
name|sblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dinode
name|itab
index|[
name|INOPB
operator|*
name|NI
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|iaddr
index|[
name|NADDR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|blist
index|[
name|NB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|ino
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|nrfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|ndfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|nbfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|ncfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|ndirect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|nindir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|niindir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|niiindir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|nfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|ndup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nerror
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|atol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|daddr_t
name|alloc
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|STANDALONE
end_ifndef

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
name|long
name|n
decl_stmt|;
name|blist
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|STANDALONE
while|while
condition|(
operator|--
name|argc
condition|)
block|{
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
name|dflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'m'
case|:
name|mflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|sflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NB
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
name|blist
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
name|blist
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
default|default:
name|printf
argument_list|(
literal|"Bad flag\n"
argument_list|)
expr_stmt|;
block|}
name|check
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|{
specifier|static
name|char
name|fname
index|[
literal|0
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"File: "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|nerror
operator|)
return|;
block|}
end_function

begin_macro
name|check
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|ino_t
name|mino
decl_stmt|;
name|daddr_t
name|d
decl_stmt|;
name|long
name|n
decl_stmt|;
name|fi
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|sflg
condition|?
literal|2
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cannot open %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|nerror
operator||=
literal|04
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|nrfile
operator|=
literal|0
expr_stmt|;
name|ndfile
operator|=
literal|0
expr_stmt|;
name|ncfile
operator|=
literal|0
expr_stmt|;
name|nbfile
operator|=
literal|0
expr_stmt|;
name|ndirect
operator|=
literal|0
expr_stmt|;
name|nindir
operator|=
literal|0
expr_stmt|;
name|niindir
operator|=
literal|0
expr_stmt|;
name|niiindir
operator|=
literal|0
expr_stmt|;
name|ndup
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|STANDALONE
name|sync
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|bread
argument_list|(
operator|(
name|daddr_t
operator|)
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|,
sizeof|sizeof
argument_list|(
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
name|mino
operator|=
operator|(
name|sblock
operator|.
name|s_isize
operator|-
literal|2
operator|)
operator|*
name|INOPB
expr_stmt|;
name|ino
operator|=
literal|0
expr_stmt|;
name|n
operator|=
operator|(
name|sblock
operator|.
name|s_fsize
operator|-
name|sblock
operator|.
name|s_isize
operator|+
name|BITS
operator|-
literal|1
operator|)
operator|/
name|BITS
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|(
name|unsigned
operator|)
name|n
condition|)
block|{
name|printf
argument_list|(
literal|"Check fsize and isize: %ld, %u\n"
argument_list|,
name|sblock
operator|.
name|s_fsize
argument_list|,
name|sblock
operator|.
name|s_isize
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STANDALONE
name|bmap
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|bmap
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bmap
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Not enough core; duplicates unchecked\n"
argument_list|)
expr_stmt|;
name|dflg
operator|++
expr_stmt|;
name|sflg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dflg
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|n
condition|;
name|i
operator|++
control|)
name|bmap
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
condition|;
name|i
operator|+=
name|NI
control|)
block|{
if|if
condition|(
name|ino
operator|>=
name|mino
condition|)
break|break;
name|bread
argument_list|(
operator|(
name|daddr_t
operator|)
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
name|itab
argument_list|,
sizeof|sizeof
argument_list|(
name|itab
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|INOPB
operator|*
name|NI
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ino
operator|>=
name|mino
condition|)
break|break;
name|ino
operator|++
expr_stmt|;
name|pass1
argument_list|(
operator|&
name|itab
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|ino
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|STANDALONE
name|sync
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|bread
argument_list|(
operator|(
name|daddr_t
operator|)
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|,
sizeof|sizeof
argument_list|(
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflg
condition|)
block|{
name|makefree
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|fi
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STANDALONE
if|if
condition|(
name|bmap
condition|)
name|free
argument_list|(
name|bmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|nfree
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|=
name|alloc
argument_list|()
condition|)
block|{
if|if
condition|(
name|chk
argument_list|(
name|n
argument_list|,
literal|"free"
argument_list|)
condition|)
break|break;
name|nfree
operator|++
expr_stmt|;
block|}
name|close
argument_list|(
name|fi
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STANDALONE
if|if
condition|(
name|bmap
condition|)
name|free
argument_list|(
name|bmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|nrfile
operator|+
name|ndfile
operator|+
name|ncfile
operator|+
name|nbfile
expr_stmt|;
ifndef|#
directive|ifndef
name|STANDALONE
name|printf
argument_list|(
literal|"files %6u (r=%u,d=%u,b=%u,c=%u)\n"
argument_list|,
name|i
argument_list|,
name|nrfile
argument_list|,
name|ndfile
argument_list|,
name|nbfile
argument_list|,
name|ncfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"files %u (r=%u,d=%u,b=%u,c=%u)\n"
argument_list|,
name|i
argument_list|,
name|nrfile
argument_list|,
name|ndfile
argument_list|,
name|nbfile
argument_list|,
name|ncfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|ndirect
operator|+
name|nindir
operator|+
name|niindir
operator|+
name|niindir
expr_stmt|;
ifdef|#
directive|ifdef
name|STANDALONE
name|printf
argument_list|(
literal|"used %ld (i=%ld,ii=%ld,iii=%ld,d=%ld)\n"
argument_list|,
name|n
argument_list|,
name|nindir
argument_list|,
name|niindir
argument_list|,
name|niiindir
argument_list|,
name|ndirect
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"free %ld\n"
argument_list|,
name|nfree
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"used %7ld (i=%ld,ii=%ld,iii=%ld,d=%ld)\n"
argument_list|,
name|n
argument_list|,
name|nindir
argument_list|,
name|niindir
argument_list|,
name|niiindir
argument_list|,
name|ndirect
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"free %7ld\n"
argument_list|,
name|nfree
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|dflg
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|d
operator|=
name|sblock
operator|.
name|s_isize
init|;
name|d
operator|<
name|sblock
operator|.
name|s_fsize
condition|;
name|d
operator|++
control|)
if|if
condition|(
operator|!
name|duped
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|mflg
condition|)
name|printf
argument_list|(
literal|"%ld missing\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"missing%5ld\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|pass1
argument_list|(
name|ip
argument_list|)
specifier|register
expr|struct
name|dinode
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|daddr_t
name|ind1
index|[
name|NINDIR
index|]
decl_stmt|;
name|daddr_t
name|ind2
index|[
name|NINDIR
index|]
decl_stmt|;
name|daddr_t
name|ind3
index|[
name|NINDIR
index|]
decl_stmt|;
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|int
name|k
decl_stmt|,
name|l
decl_stmt|;
name|i
operator|=
name|ip
operator|->
name|di_mode
operator|&
name|IFMT
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|sblock
operator|.
name|s_tinode
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|==
name|IFCHR
condition|)
block|{
name|ncfile
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|==
name|IFBLK
condition|)
block|{
name|nbfile
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|==
name|IFDIR
condition|)
name|ndfile
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|IFREG
condition|)
name|nrfile
operator|++
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"bad mode %u\n"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
return|return;
block|}
name|l3tol
argument_list|(
name|iaddr
argument_list|,
name|ip
operator|->
name|di_addr
argument_list|,
name|NADDR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NADDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iaddr
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<
name|NADDR
operator|-
literal|3
condition|)
block|{
name|ndirect
operator|++
expr_stmt|;
name|chk
argument_list|(
name|iaddr
index|[
name|i
index|]
argument_list|,
literal|"data (small)"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nindir
operator|++
expr_stmt|;
if|if
condition|(
name|chk
argument_list|(
name|iaddr
index|[
name|i
index|]
argument_list|,
literal|"1st indirect"
argument_list|)
condition|)
continue|continue;
name|bread
argument_list|(
name|iaddr
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ind1
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NINDIR
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ind1
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
name|NADDR
operator|-
literal|3
condition|)
block|{
name|ndirect
operator|++
expr_stmt|;
name|chk
argument_list|(
name|ind1
index|[
name|j
index|]
argument_list|,
literal|"data (large)"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|niindir
operator|++
expr_stmt|;
if|if
condition|(
name|chk
argument_list|(
name|ind1
index|[
name|j
index|]
argument_list|,
literal|"2nd indirect"
argument_list|)
condition|)
continue|continue;
name|bread
argument_list|(
name|ind1
index|[
name|j
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ind2
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NINDIR
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|ind2
index|[
name|k
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
name|NADDR
operator|-
literal|2
condition|)
block|{
name|ndirect
operator|++
expr_stmt|;
name|chk
argument_list|(
name|ind2
index|[
name|k
index|]
argument_list|,
literal|"data (huge)"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|niiindir
operator|++
expr_stmt|;
if|if
condition|(
name|chk
argument_list|(
name|ind2
index|[
name|k
index|]
argument_list|,
literal|"3rd indirect"
argument_list|)
condition|)
continue|continue;
name|bread
argument_list|(
name|ind2
index|[
name|k
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ind3
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|NINDIR
condition|;
name|l
operator|++
control|)
if|if
condition|(
name|ind3
index|[
name|l
index|]
condition|)
block|{
name|ndirect
operator|++
expr_stmt|;
name|chk
argument_list|(
name|ind3
index|[
name|l
index|]
argument_list|,
literal|"data (garg)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

begin_macro
name|chk
argument_list|(
argument|bno
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|bno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
if|if
condition|(
name|bno
operator|<
name|sblock
operator|.
name|s_isize
operator|||
name|bno
operator|>=
name|sblock
operator|.
name|s_fsize
condition|)
block|{
name|printf
argument_list|(
literal|"%ld bad; inode=%u, class=%s\n"
argument_list|,
name|bno
argument_list|,
name|ino
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|duped
argument_list|(
name|bno
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%ld dup; inode=%u, class=%s\n"
argument_list|,
name|bno
argument_list|,
name|ino
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ndup
operator|++
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|blist
index|[
name|n
index|]
operator|!=
operator|-
literal|1
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|bno
operator|==
name|blist
index|[
name|n
index|]
condition|)
name|printf
argument_list|(
literal|"%ld arg; inode=%u, class=%s\n"
argument_list|,
name|bno
argument_list|,
name|ino
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|duped
argument_list|(
argument|bno
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|bno
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|daddr_t
name|d
decl_stmt|;
specifier|register
name|m
operator|,
name|n
expr_stmt|;
if|if
condition|(
name|dflg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|d
operator|=
name|bno
operator|-
name|sblock
operator|.
name|s_isize
expr_stmt|;
name|m
operator|=
literal|1
operator|<<
operator|(
name|d
operator|%
name|BITS
operator|)
expr_stmt|;
name|n
operator|=
operator|(
name|d
operator|/
name|BITS
operator|)
expr_stmt|;
if|if
condition|(
name|bmap
index|[
name|n
index|]
operator|&
name|m
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|bmap
index|[
name|n
index|]
operator||=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|daddr_t
name|alloc
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|daddr_t
name|bno
decl_stmt|;
union|union
block|{
name|char
name|data
index|[
name|BSIZE
index|]
decl_stmt|;
name|struct
name|fblk
name|fb
decl_stmt|;
block|}
name|buf
union|;
name|sblock
operator|.
name|s_tfree
operator|--
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|s_nfree
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sblock
operator|.
name|s_nfree
operator|>
name|NICFREE
condition|)
block|{
name|printf
argument_list|(
literal|"Bad free list, s.b. count = %d\n"
argument_list|,
name|sblock
operator|.
name|s_nfree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bno
operator|=
name|sblock
operator|.
name|s_free
index|[
operator|--
name|sblock
operator|.
name|s_nfree
index|]
expr_stmt|;
name|sblock
operator|.
name|s_free
index|[
name|sblock
operator|.
name|s_nfree
index|]
operator|=
operator|(
name|daddr_t
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|bno
operator|==
literal|0
condition|)
return|return
operator|(
name|bno
operator|)
return|;
if|if
condition|(
name|sblock
operator|.
name|s_nfree
operator|<=
literal|0
condition|)
block|{
name|bread
argument_list|(
name|bno
argument_list|,
name|buf
operator|.
name|data
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|s_nfree
operator|=
name|buf
operator|.
name|df_nfree
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|s_nfree
operator|<
literal|0
operator|||
name|sblock
operator|.
name|s_nfree
operator|>
name|NICFREE
condition|)
block|{
name|printf
argument_list|(
literal|"Bad free list, entry count of block %ld = %d\n"
argument_list|,
name|bno
argument_list|,
name|sblock
operator|.
name|s_nfree
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|s_nfree
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NICFREE
condition|;
name|i
operator|++
control|)
name|sblock
operator|.
name|s_free
index|[
name|i
index|]
operator|=
name|buf
operator|.
name|df_free
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|bno
operator|)
return|;
block|}
end_function

begin_macro
name|bfree
argument_list|(
argument|bno
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|bno
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
block|{
name|char
name|data
index|[
name|BSIZE
index|]
decl_stmt|;
name|struct
name|fblk
name|fb
decl_stmt|;
block|}
name|buf
union|;
name|int
name|i
decl_stmt|;
name|sblock
operator|.
name|s_tfree
operator|++
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|s_nfree
operator|>=
name|NICFREE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BSIZE
condition|;
name|i
operator|++
control|)
name|buf
operator|.
name|data
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|df_nfree
operator|=
name|sblock
operator|.
name|s_nfree
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NICFREE
condition|;
name|i
operator|++
control|)
name|buf
operator|.
name|df_free
index|[
name|i
index|]
operator|=
name|sblock
operator|.
name|s_free
index|[
name|i
index|]
expr_stmt|;
name|bwrite
argument_list|(
name|bno
argument_list|,
name|buf
operator|.
name|data
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|s_nfree
operator|=
literal|0
expr_stmt|;
block|}
name|sblock
operator|.
name|s_free
index|[
name|sblock
operator|.
name|s_nfree
index|]
operator|=
name|bno
expr_stmt|;
name|sblock
operator|.
name|s_nfree
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|bread
argument_list|(
argument|bno
argument_list|,
argument|buf
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|bno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|lseek
argument_list|(
name|fi
argument_list|,
name|bno
operator|*
name|BSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fi
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
operator|!=
name|cnt
condition|)
block|{
name|printf
argument_list|(
literal|"read error %ld\n"
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflg
condition|)
block|{
name|printf
argument_list|(
literal|"No update\n"
argument_list|)
expr_stmt|;
name|sflg
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BSIZE
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|bwrite
argument_list|(
argument|bno
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|bno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lseek
argument_list|(
name|fi
argument_list|,
name|bno
operator|*
name|BSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fi
argument_list|,
name|buf
argument_list|,
name|BSIZE
argument_list|)
operator|!=
name|BSIZE
condition|)
name|printf
argument_list|(
literal|"write error %ld\n"
argument_list|,
name|bno
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|makefree
argument_list|()
end_macro

begin_block
block|{
name|char
name|flg
index|[
name|MAXFN
index|]
decl_stmt|;
name|int
name|adr
index|[
name|MAXFN
index|]
decl_stmt|;
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|daddr_t
name|f
decl_stmt|,
name|d
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|sblock
operator|.
name|s_n
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
name|n
operator|>
name|MAXFN
condition|)
name|n
operator|=
name|MAXFN
expr_stmt|;
name|sblock
operator|.
name|s_n
operator|=
name|n
expr_stmt|;
name|m
operator|=
name|sblock
operator|.
name|s_m
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
operator|||
name|m
operator|>
name|sblock
operator|.
name|s_n
condition|)
name|m
operator|=
literal|3
expr_stmt|;
name|sblock
operator|.
name|s_m
operator|=
name|m
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|flg
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
while|while
condition|(
name|flg
index|[
name|i
index|]
condition|)
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|n
expr_stmt|;
name|adr
index|[
name|j
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|flg
index|[
name|i
index|]
operator|++
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
name|m
operator|)
operator|%
name|n
expr_stmt|;
block|}
name|sblock
operator|.
name|s_nfree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|s_ninode
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|s_flock
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|s_ilock
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|s_fmod
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|s_ronly
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|STANDALONE
name|time
argument_list|(
operator|&
name|sblock
operator|.
name|s_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sblock
operator|.
name|s_tfree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|s_tinode
operator|=
literal|0
expr_stmt|;
name|bfree
argument_list|(
operator|(
name|daddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|d
operator|=
name|sblock
operator|.
name|s_fsize
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|d
operator|%
name|sblock
operator|.
name|s_n
condition|)
name|d
operator|++
expr_stmt|;
for|for
control|(
init|;
name|d
operator|>
literal|0
condition|;
name|d
operator|-=
name|sblock
operator|.
name|s_n
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|s_n
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|d
operator|-
name|adr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|<
name|sblock
operator|.
name|s_fsize
operator|&&
name|f
operator|>=
name|sblock
operator|.
name|s_isize
condition|)
if|if
condition|(
operator|!
name|duped
argument_list|(
name|f
argument_list|)
condition|)
name|bfree
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|bwrite
argument_list|(
operator|(
name|daddr_t
operator|)
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STANDALONE
name|sync
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_block

end_unit

