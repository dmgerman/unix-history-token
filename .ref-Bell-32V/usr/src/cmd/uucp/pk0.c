begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|USER
value|1
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/pk.p>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/pk.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_comment
comment|/*  * packet driver  */
end_comment

begin_decl_stmt
name|char
name|next
index|[
literal|8
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packet sequence numbers */
end_comment

begin_decl_stmt
name|char
name|mask
index|[
literal|8
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|010
block|,
literal|020
block|,
literal|040
block|,
literal|0100
block|,
literal|0200
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pack
modifier|*
name|pklines
index|[
name|NPLINES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * receive control messages  */
end_comment

begin_expr_stmt
name|pkcntl
argument_list|(
name|c
argument_list|,
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|cntl
operator|,
name|val
expr_stmt|;
name|val
operator|=
name|c
operator|&
name|MOD8
expr_stmt|;
name|cntl
operator|=
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
name|MOD8
expr_stmt|;
if|if
condition|(
operator|!
name|ISCNTL
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not cntl\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pk
operator|->
name|p_mode
operator|&
literal|02
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%o "
argument_list|,
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cntl
condition|)
block|{
case|case
name|INITB
case|:
name|val
operator|++
expr_stmt|;
name|pk
operator|->
name|p_xsize
operator|=
name|pksizes
index|[
name|val
index|]
expr_stmt|;
name|pk
operator|->
name|p_lpsize
operator|=
name|val
expr_stmt|;
name|pk
operator|->
name|p_bits
operator|=
name|DTOM
argument_list|(
name|pk
operator|->
name|p_xsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|LIVE
condition|)
block|{
name|pk
operator|->
name|p_msg
operator||=
name|M_INITC
expr_stmt|;
break|break;
block|}
name|pk
operator|->
name|p_state
operator||=
name|INITb
expr_stmt|;
if|if
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|INITa
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|pk
operator|->
name|p_rmsg
operator|&=
operator|~
name|M_INITA
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|M_INITC
expr_stmt|;
break|break;
case|case
name|INITC
case|:
if|if
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|INITab
operator|)
operator|==
name|INITab
condition|)
block|{
name|pk
operator|->
name|p_state
operator|=
name|LIVE
expr_stmt|;
name|WAKEUP
argument_list|(
operator|&
name|pk
operator|->
name|p_state
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_rmsg
operator|&=
operator|~
name|M_INITB
expr_stmt|;
block|}
else|else
name|pk
operator|->
name|p_msg
operator||=
name|M_INITB
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|pk
operator|->
name|p_swindow
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|INITA
case|:
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|pk
operator|->
name|p_state
operator|&
name|LIVE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"alloc change not implemented\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|val
condition|)
block|{
name|pk
operator|->
name|p_state
operator||=
name|INITa
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|M_INITB
expr_stmt|;
name|pk
operator|->
name|p_rmsg
operator||=
name|M_INITB
expr_stmt|;
name|pk
operator|->
name|p_swindow
operator|=
name|val
expr_stmt|;
block|}
break|break;
case|case
name|RJ
case|:
name|pk
operator|->
name|p_state
operator||=
name|RXMIT
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|M_RR
expr_stmt|;
case|case
name|RR
case|:
name|pk
operator|->
name|p_rpr
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|pksack
argument_list|(
name|pk
argument_list|)
operator|==
literal|0
condition|)
block|{
name|WAKEUP
argument_list|(
operator|&
name|pk
operator|->
name|p_ps
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SRJ
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"srj not implemented\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOSE
case|:
name|pk
operator|->
name|p_state
operator|=
name|DOWN
operator|+
name|RCLOSE
expr_stmt|;
name|SIGNAL
expr_stmt|;
name|WAKEUP
argument_list|(
operator|&
name|pk
operator|->
name|p_pr
argument_list|)
expr_stmt|;
name|WAKEUP
argument_list|(
operator|&
name|pk
operator|->
name|p_ps
argument_list|)
expr_stmt|;
name|WAKEUP
argument_list|(
operator|&
name|pk
operator|->
name|p_state
argument_list|)
expr_stmt|;
return|return;
block|}
name|out
label|:
if|if
condition|(
name|pk
operator|->
name|p_msg
condition|)
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|pkaccept
argument_list|(
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|x
operator|,
name|seq
expr_stmt|;
name|char
name|m
decl_stmt|,
name|cntl
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|imask
decl_stmt|,
modifier|*
modifier|*
name|bp
decl_stmt|;
name|int
name|bad
decl_stmt|,
name|accept
decl_stmt|,
name|skip
decl_stmt|,
name|s
decl_stmt|,
name|t
decl_stmt|,
name|h
decl_stmt|,
name|cc
decl_stmt|;
name|unsigned
name|short
name|sum
decl_stmt|;
name|bad
operator|=
name|accept
operator|=
name|skip
operator|=
literal|0
expr_stmt|;
comment|/* 	 * wait for input 	 */
name|LOCK
expr_stmt|;
name|x
operator|=
name|next
index|[
name|pk
operator|->
name|p_pr
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|imask
operator|=
name|pk
operator|->
name|p_imap
operator|)
operator|==
literal|0
operator|&&
name|pk
operator|->
name|p_rcount
operator|==
literal|0
condition|)
block|{
name|PKGETPKT
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|SLEEP
argument_list|(
operator|&
name|pk
operator|->
name|p_pr
argument_list|,
name|PKIPRI
argument_list|)
expr_stmt|;
block|}
name|pk
operator|->
name|p_imap
operator|=
literal|0
expr_stmt|;
name|UNLOCK
expr_stmt|;
comment|/* 	 * determine input window in m. 	 */
name|t
operator|=
operator|(
operator|~
operator|(
operator|-
literal|1
operator|<<
name|pk
operator|->
name|p_rwindow
operator|)
operator|)
operator|<<
name|x
expr_stmt|;
name|m
operator|=
name|t
expr_stmt|;
name|m
operator||=
name|t
operator|>>
literal|8
expr_stmt|;
comment|/* 	 * mark newly accepted input buffers 	 */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|imask
operator|&
name|mask
index|[
name|x
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|cntl
operator|=
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|)
operator|&
literal|0200
operator|)
operator|==
literal|0
condition|)
block|{
name|bad
operator|++
expr_stmt|;
name|free
label|:
name|bp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
expr_stmt|;
name|LOCK
expr_stmt|;
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
name|UNLOCK
expr_stmt|;
continue|continue;
block|}
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
operator|~
operator|(
name|B_COPY
operator|+
name|B_MARK
operator|)
expr_stmt|;
name|sum
operator|=
operator|(
name|unsigned
operator|)
name|chksum
argument_list|(
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
argument_list|,
name|pk
operator|->
name|p_rsize
argument_list|)
operator|^
call|(
name|unsigned
call|)
argument_list|(
name|cntl
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|pk
operator|->
name|p_isum
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|==
name|CHECK
condition|)
block|{
name|seq
operator|=
operator|(
name|cntl
operator|>>
literal|3
operator|)
operator|&
name|MOD8
expr_stmt|;
if|if
condition|(
name|m
operator|&
name|mask
index|[
name|seq
index|]
condition|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_is
index|[
name|seq
index|]
operator|&
operator|(
name|B_COPY
operator||
name|B_MARK
operator|)
condition|)
block|{
name|dup
label|:
name|pk
operator|->
name|p_msg
operator||=
name|M_RR
expr_stmt|;
name|skip
operator|++
expr_stmt|;
goto|goto
name|free
goto|;
block|}
if|if
condition|(
name|x
operator|!=
name|seq
condition|)
block|{
name|LOCK
expr_stmt|;
name|p
operator|=
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
expr_stmt|;
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
operator|=
name|pk
operator|->
name|p_ib
index|[
name|seq
index|]
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
name|pk
operator|->
name|p_is
index|[
name|seq
index|]
expr_stmt|;
name|pk
operator|->
name|p_ib
index|[
name|seq
index|]
operator|=
name|p
expr_stmt|;
name|UNLOCK
expr_stmt|;
block|}
name|pk
operator|->
name|p_is
index|[
name|seq
index|]
operator|=
name|B_MARK
expr_stmt|;
name|accept
operator|++
expr_stmt|;
name|cc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cntl
operator|&
name|B_SHORT
condition|)
block|{
name|pk
operator|->
name|p_is
index|[
name|seq
index|]
operator|=
name|B_MARK
operator|+
name|B_SHORT
expr_stmt|;
name|p
operator|=
name|pk
operator|->
name|p_ib
index|[
name|seq
index|]
expr_stmt|;
name|cc
operator|=
operator|(
name|unsigned
operator|)
operator|*
name|p
operator|++
operator|&
literal|0377
expr_stmt|;
if|if
condition|(
name|cc
operator|&
literal|0200
condition|)
block|{
name|cc
operator|&=
literal|0177
expr_stmt|;
name|cc
operator||=
operator|*
name|p
operator|<<
literal|7
expr_stmt|;
block|}
block|}
name|pk
operator|->
name|p_isum
index|[
name|seq
index|]
operator|=
name|pk
operator|->
name|p_rsize
operator|-
name|cc
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|dup
goto|;
block|}
block|}
else|else
block|{
name|bad
operator|++
expr_stmt|;
goto|goto
name|free
goto|;
block|}
block|}
comment|/* 	 * scan window again turning marked buffers into 	 * COPY buffers and looking for missing sequence 	 * numbers. 	 */
name|accept
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|next
index|[
name|pk
operator|->
name|p_pr
index|]
operator|,
name|t
operator|=
name|h
operator|=
operator|-
literal|1
init|;
name|m
operator|&
name|mask
index|[
name|x
index|]
condition|;
name|x
operator|=
name|next
index|[
name|x
index|]
control|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|&
name|B_MARK
condition|)
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator||=
name|B_COPY
expr_stmt|;
comment|/*  hole code  		if (pk->p_is[x]& B_COPY) { 			if (h<0&& t>=0) 				h = x; 		} else { 			if (t<0) 				t = x; 		} 	*/
if|if
condition|(
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|&
name|B_COPY
condition|)
block|{
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
name|bp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
expr_stmt|;
name|LOCK
expr_stmt|;
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
name|UNLOCK
expr_stmt|;
name|skip
operator|++
expr_stmt|;
block|}
else|else
name|accept
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|t
operator|=
name|x
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bad
condition|)
block|{
name|pk
operator|->
name|p_msg
operator||=
name|M_RJ
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
block|{
name|pk
operator|->
name|p_msg
operator||=
name|M_RR
expr_stmt|;
block|}
name|pk
operator|->
name|p_rcount
operator|=
name|accept
expr_stmt|;
return|return
operator|(
name|accept
operator|)
return|;
block|}
end_block

begin_macro
name|pkread
argument_list|(
argument|S
argument_list|)
end_macro

begin_expr_stmt
name|SDEF
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
specifier|register
name|x
operator|,
name|s
expr_stmt|;
name|int
name|is
decl_stmt|,
name|cc
decl_stmt|,
name|xfr
decl_stmt|,
name|count
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|bp
decl_stmt|;
name|pk
operator|=
name|PADDR
expr_stmt|;
name|xfr
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pkaccept
argument_list|(
name|pk
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
while|while
condition|(
name|UCOUNT
condition|)
block|{
name|x
operator|=
name|next
index|[
name|pk
operator|->
name|p_pr
index|]
expr_stmt|;
name|is
operator|=
name|pk
operator|->
name|p_is
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|is
operator|&
name|B_COPY
condition|)
block|{
name|cc
operator|=
name|MIN
argument_list|(
name|pk
operator|->
name|p_isum
index|[
name|x
index|]
argument_list|,
name|UCOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
operator|&&
name|xfr
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|is
operator|&
name|B_RESID
condition|)
name|cp
operator|=
name|pk
operator|->
name|p_rptr
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|is
operator|&
name|B_SHORT
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|++
operator|&
literal|0200
condition|)
operator|*
name|cp
operator|++
expr_stmt|;
block|}
block|}
name|IOMOVE
argument_list|(
name|cp
argument_list|,
name|cc
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
name|count
operator|+=
name|cc
expr_stmt|;
name|xfr
operator|++
expr_stmt|;
name|pk
operator|->
name|p_isum
index|[
name|x
index|]
operator|-=
name|cc
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_isum
index|[
name|x
index|]
operator|==
literal|0
condition|)
block|{
name|pk
operator|->
name|p_pr
operator|=
name|x
expr_stmt|;
name|bp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
expr_stmt|;
name|LOCK
expr_stmt|;
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
name|pk
operator|->
name|p_rcount
operator|--
expr_stmt|;
name|UNLOCK
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|M_RR
expr_stmt|;
block|}
else|else
block|{
name|pk
operator|->
name|p_rptr
operator|=
name|cp
operator|+
name|cc
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator||=
name|B_RESID
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
break|break;
block|}
else|else
break|break;
block|}
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_macro
name|pkwrite
argument_list|(
argument|S
argument_list|)
end_macro

begin_expr_stmt
name|SDEF
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
specifier|register
name|x
expr_stmt|;
name|int
name|partial
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|s
decl_stmt|,
name|fc
decl_stmt|,
name|count
decl_stmt|;
name|int
name|pktimeout
parameter_list|()
function_decl|;
name|pk
operator|=
name|PADDR
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|DOWN
operator|||
operator|!
name|pk
operator|->
name|p_state
operator|&
name|LIVE
condition|)
block|{
name|SETERROR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|count
operator|=
name|UCOUNT
expr_stmt|;
do|do
block|{
name|LOCK
expr_stmt|;
while|while
condition|(
name|pk
operator|->
name|p_xcount
operator|>=
name|pk
operator|->
name|p_swindow
condition|)
block|{
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|PKGETPKT
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|SLEEP
argument_list|(
operator|&
name|pk
operator|->
name|p_ps
argument_list|,
name|PKOPRI
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|next
index|[
name|pk
operator|->
name|p_pscopy
index|]
expr_stmt|;
while|while
condition|(
name|pk
operator|->
name|p_os
index|[
name|x
index|]
operator|!=
name|B_NULL
condition|)
block|{
name|PKGETPKT
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|SLEEP
argument_list|(
operator|&
name|pk
operator|->
name|p_ps
argument_list|,
name|PKOPRI
argument_list|)
expr_stmt|;
block|}
name|pk
operator|->
name|p_os
index|[
name|x
index|]
operator|=
name|B_MARK
expr_stmt|;
name|pk
operator|->
name|p_pscopy
operator|=
name|x
expr_stmt|;
name|pk
operator|->
name|p_xcount
operator|++
expr_stmt|;
name|UNLOCK
expr_stmt|;
name|cp
operator|=
name|pk
operator|->
name|p_ob
index|[
name|x
index|]
operator|=
name|GETEPACK
expr_stmt|;
name|partial
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|UCOUNT
operator|<
name|pk
operator|->
name|p_xsize
condition|)
block|{
name|cc
operator|=
name|UCOUNT
expr_stmt|;
name|fc
operator|=
name|pk
operator|->
name|p_xsize
operator|-
name|cc
expr_stmt|;
operator|*
name|cp
operator|=
name|fc
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|fc
operator|>
literal|127
condition|)
block|{
operator|*
name|cp
operator|++
operator||=
literal|0200
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|fc
operator|>>
literal|7
expr_stmt|;
block|}
else|else
name|cp
operator|++
expr_stmt|;
name|partial
operator|=
name|B_SHORT
expr_stmt|;
block|}
else|else
name|cc
operator|=
name|pk
operator|->
name|p_xsize
expr_stmt|;
name|IOMOVE
argument_list|(
name|cp
argument_list|,
name|cc
argument_list|,
name|B_WRITE
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_osum
index|[
name|x
index|]
operator|=
name|chksum
argument_list|(
name|pk
operator|->
name|p_ob
index|[
name|x
index|]
argument_list|,
name|pk
operator|->
name|p_xsize
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_os
index|[
name|x
index|]
operator|=
name|B_READY
operator|+
name|partial
expr_stmt|;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|UCOUNT
condition|)
do|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|pksack
argument_list|(
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|x
operator|,
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|pk
operator|->
name|p_ps
init|;
name|x
operator|!=
name|pk
operator|->
name|p_rpr
condition|;
control|)
block|{
name|x
operator|=
name|next
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_os
index|[
name|x
index|]
operator|&
name|B_SENT
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|pk
operator|->
name|p_os
index|[
name|x
index|]
operator|=
name|B_NULL
expr_stmt|;
name|pk
operator|->
name|p_state
operator|&=
operator|~
name|WAITO
expr_stmt|;
name|pk
operator|->
name|p_xcount
operator|--
expr_stmt|;
name|FREEPACK
argument_list|(
name|pk
operator|->
name|p_ob
index|[
name|x
index|]
argument_list|,
name|pk
operator|->
name|p_bits
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_ps
operator|=
name|x
expr_stmt|;
name|WAKEUP
argument_list|(
operator|&
name|pk
operator|->
name|p_ps
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|pkoutput
argument_list|(
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|x
operator|,
name|rx
expr_stmt|;
name|int
name|s
decl_stmt|;
name|char
name|bstate
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SDEF
expr_stmt|;
name|int
name|flag
decl_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
name|ISYSTEM
expr_stmt|;
name|LOCK
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_obusy
operator|++
operator|||
name|OBUSY
condition|)
block|{
name|pk
operator|->
name|p_obusy
operator|--
expr_stmt|;
name|UNLOCK
expr_stmt|;
return|return;
block|}
name|UNLOCK
expr_stmt|;
comment|/* 	 * find seq number and buffer state 	 * of next output packet 	 */
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|RXMIT
condition|)
block|{
name|pk
operator|->
name|p_nxtps
operator|=
name|next
index|[
name|pk
operator|->
name|p_rpr
index|]
expr_stmt|;
name|flag
operator|++
expr_stmt|;
block|}
name|x
operator|=
name|pk
operator|->
name|p_nxtps
expr_stmt|;
name|bstate
operator|=
name|pk
operator|->
name|p_os
index|[
name|x
index|]
expr_stmt|;
comment|/* 	 * Send control packet if indicated 	 */
if|if
condition|(
name|pk
operator|->
name|p_msg
condition|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_msg
operator|&
operator|~
name|M_RR
operator|||
operator|!
operator|(
name|bstate
operator|&
name|B_READY
operator|)
condition|)
block|{
name|x
operator|=
name|pk
operator|->
name|p_msg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|x
operator|&
literal|1
condition|)
break|break;
else|else
name|x
operator|>>=
literal|1
expr_stmt|;
name|x
operator|=
name|i
expr_stmt|;
name|x
operator|<<=
literal|3
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|CLOSE
case|:
break|break;
case|case
name|RJ
case|:
case|case
name|RR
case|:
name|x
operator|+=
name|pk
operator|->
name|p_pr
expr_stmt|;
break|break;
case|case
name|SRJ
case|:
break|break;
case|case
name|INITB
case|:
name|x
operator|+=
name|pksize
argument_list|(
name|pk
operator|->
name|p_rsize
argument_list|)
expr_stmt|;
break|break;
case|case
name|INITC
case|:
name|x
operator|+=
name|pk
operator|->
name|p_rwindow
expr_stmt|;
break|break;
case|case
name|INITA
case|:
name|x
operator|+=
name|pk
operator|->
name|p_rwindow
expr_stmt|;
break|break;
block|}
name|pk
operator|->
name|p_msg
operator|&=
operator|~
name|mask
index|[
name|i
index|]
expr_stmt|;
name|pkxstart
argument_list|(
name|pk
argument_list|,
name|x
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Don't send data packets if line is marked dead. 	 */
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|DOWN
condition|)
block|{
name|WAKEUP
argument_list|(
operator|&
name|pk
operator|->
name|p_ps
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Start transmission (or retransmission) of data packets. 	 */
if|if
condition|(
name|bstate
operator|&
operator|(
name|B_READY
operator||
name|B_SENT
operator|)
condition|)
block|{
name|char
name|seq
decl_stmt|;
name|bstate
operator||=
name|B_SENT
expr_stmt|;
name|seq
operator|=
name|x
expr_stmt|;
name|pk
operator|->
name|p_nxtps
operator|=
name|next
index|[
name|x
index|]
expr_stmt|;
name|x
operator|=
literal|0200
operator|+
name|pk
operator|->
name|p_pr
operator|+
operator|(
name|seq
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|bstate
operator|&
name|B_SHORT
condition|)
name|x
operator||=
literal|0100
expr_stmt|;
name|pkxstart
argument_list|(
name|pk
argument_list|,
name|x
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_os
index|[
name|seq
index|]
operator|=
name|bstate
expr_stmt|;
name|pk
operator|->
name|p_state
operator|&=
operator|~
name|RXMIT
expr_stmt|;
name|pk
operator|->
name|p_nout
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * enable timeout if there's nothing to send 	 * and transmission buffers are languishing 	 */
if|if
condition|(
name|pk
operator|->
name|p_xcount
condition|)
block|{
name|pk
operator|->
name|p_timer
operator|=
literal|2
expr_stmt|;
name|pk
operator|->
name|p_state
operator||=
name|WAITO
expr_stmt|;
block|}
else|else
name|pk
operator|->
name|p_state
operator|&=
operator|~
name|WAITO
expr_stmt|;
name|WAKEUP
argument_list|(
operator|&
name|pk
operator|->
name|p_ps
argument_list|)
expr_stmt|;
name|out
label|:
name|pk
operator|->
name|p_obusy
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * shut down line by  *	ignoring new input  *	letting output drain  *	releasing space and turning off line discipline  */
end_comment

begin_macro
name|pkclose
argument_list|(
argument|S
argument_list|)
end_macro

begin_expr_stmt
name|SDEF
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
specifier|register
name|i
operator|,
name|s
operator|,
name|rbits
expr_stmt|;
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
name|int
name|rcheck
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|pk
operator|=
name|PADDR
expr_stmt|;
name|pk
operator|->
name|p_state
operator||=
name|DRAINO
expr_stmt|;
comment|/* 	 * try to flush output 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|LOCK
expr_stmt|;
name|pk
operator|->
name|p_timer
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|pk
operator|->
name|p_xcount
operator|&&
name|pk
operator|->
name|p_state
operator|&
name|LIVE
condition|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
operator|(
name|RCLOSE
operator|+
name|DOWN
operator|)
operator|||
operator|++
name|i
operator|>
literal|2
condition|)
break|break;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|SLEEP
argument_list|(
operator|&
name|pk
operator|->
name|p_ps
argument_list|,
name|PKOPRI
argument_list|)
expr_stmt|;
block|}
name|pk
operator|->
name|p_timer
operator|=
literal|0
expr_stmt|;
name|pk
operator|->
name|p_state
operator||=
name|DOWN
expr_stmt|;
name|UNLOCK
expr_stmt|;
comment|/* 	 * try to exchange CLOSE messages 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|RCLOSE
operator|)
operator|==
literal|0
operator|&&
name|i
operator|<
literal|2
condition|)
block|{
name|pk
operator|->
name|p_msg
operator|=
name|M_CLOSE
expr_stmt|;
name|pk
operator|->
name|p_timer
operator|=
literal|2
expr_stmt|;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|SLEEP
argument_list|(
operator|&
name|pk
operator|->
name|p_ps
argument_list|,
name|PKOPRI
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPLINES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pklines
index|[
name|i
index|]
operator|==
name|pk
condition|)
block|{
name|pklines
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|TURNOFF
expr_stmt|;
comment|/* 	 * free space 	 */
name|rbits
operator|=
name|DTOM
argument_list|(
name|pk
operator|->
name|p_rsize
argument_list|)
expr_stmt|;
name|rcheck
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_os
index|[
name|i
index|]
operator|!=
name|B_NULL
condition|)
block|{
name|FREEPACK
argument_list|(
name|pk
operator|->
name|p_ob
index|[
name|i
index|]
argument_list|,
name|pk
operator|->
name|p_bits
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_xcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pk
operator|->
name|p_is
index|[
name|i
index|]
operator|!=
name|B_NULL
condition|)
block|{
name|FREEPACK
argument_list|(
name|pk
operator|->
name|p_ib
index|[
name|i
index|]
argument_list|,
name|rbits
argument_list|)
expr_stmt|;
name|rcheck
operator|++
expr_stmt|;
block|}
block|}
name|LOCK
expr_stmt|;
while|while
condition|(
name|pk
operator|->
name|p_ipool
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|=
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|*
name|bp
expr_stmt|;
name|rcheck
operator|++
expr_stmt|;
name|FREEPACK
argument_list|(
name|bp
argument_list|,
name|rbits
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
expr_stmt|;
if|if
condition|(
name|rcheck
operator|!=
name|pk
operator|->
name|p_rwindow
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"r short %d want %d\n"
argument_list|,
name|rcheck
argument_list|,
name|pk
operator|->
name|p_rwindow
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rcount = %d\n"
argument_list|,
name|pk
operator|->
name|p_rcount
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"xcount = %d\n"
argument_list|,
name|pk
operator|->
name|p_xcount
argument_list|)
expr_stmt|;
block|}
name|FREEPACK
argument_list|(
operator|(
name|caddr_t
operator|)
name|pk
argument_list|,
name|npbits
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|pkreset
argument_list|(
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|pk
operator|->
name|p_ps
operator|=
name|pk
operator|->
name|p_pr
operator|=
name|pk
operator|->
name|p_rpr
operator|=
literal|0
expr_stmt|;
name|pk
operator|->
name|p_nxtps
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|chksum
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|short
name|sum
decl_stmt|;
specifier|register
name|unsigned
name|short
name|t
decl_stmt|;
specifier|register
name|short
name|x
decl_stmt|;
name|sum
operator|=
operator|-
literal|1
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|sum
operator|<
literal|0
condition|)
block|{
name|sum
operator|<<=
literal|1
expr_stmt|;
name|sum
operator|++
expr_stmt|;
block|}
else|else
name|sum
operator|<<=
literal|1
expr_stmt|;
name|t
operator|=
name|sum
expr_stmt|;
name|sum
operator|+=
operator|(
name|unsigned
operator|)
operator|*
name|s
operator|++
operator|&
literal|0377
expr_stmt|;
name|x
operator|+=
name|sum
operator|^
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|sum
operator|<=
name|t
condition|)
block|{
name|sum
operator|^=
name|x
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
do|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|pkline
argument_list|(
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPLINES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pklines
index|[
name|i
index|]
operator|==
name|pk
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
name|i
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|pkzero
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|pksize
argument_list|(
name|n
argument_list|)
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|k
expr_stmt|;
name|n
operator|>>=
literal|5
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|n
operator|>>=
literal|1
condition|;
name|k
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

end_unit

