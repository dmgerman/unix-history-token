begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_decl_stmt
name|char
name|C20
index|[]
init|=
block|{
literal|"@(#)c20.c 1.27 78/10/23 14:06:38"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sccs ident */
end_comment

begin_comment
comment|/*  *	 C object code improver  */
end_comment

begin_include
include|#
directive|include
file|"c2.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
name|char
name|_sibuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|_sobuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ioflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|isn
init|=
literal|20000
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|optab
modifier|*
name|oplook
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|optab
modifier|*
name|getline
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|struct
name|node
modifier|*
name|alloc
parameter_list|(
name|an
parameter_list|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|n
operator|=
name|an
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|n
operator|&=
operator|~
literal|01
expr_stmt|;
if|if
condition|(
name|lasta
operator|+
name|n
operator|>=
name|lastr
condition|)
block|{
if|if
condition|(
name|sbrk
argument_list|(
literal|2000
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Optimizer: out of space\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|lastr
operator|+=
literal|2000
expr_stmt|;
block|}
name|p
operator|=
name|lasta
expr_stmt|;
name|lasta
operator|+=
name|n
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|niter
decl_stmt|,
name|maxiter
decl_stmt|,
name|isend
decl_stmt|;
name|int
name|nflag
decl_stmt|,
name|infound
decl_stmt|;
name|nflag
operator|=
literal|0
expr_stmt|;
name|infound
operator|=
literal|0
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
comment|/* get flags */
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'+'
condition|)
name|debug
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
operator|==
literal|'i'
condition|)
name|ioflag
operator|++
expr_stmt|;
else|else
name|nflag
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|infound
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|freopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"C2: can't find %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|_sibuf
argument_list|)
expr_stmt|;
operator|++
name|infound
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"C2: can't create %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|_sobuf
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|lasta
operator|=
name|lastr
operator|=
name|sbrk
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|opsetup
argument_list|()
expr_stmt|;
name|lasta
operator|=
name|firstr
operator|=
name|lastr
operator|=
name|alloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|maxiter
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|isend
operator|=
name|input
argument_list|()
expr_stmt|;
name|niter
operator|=
literal|0
expr_stmt|;
name|bmove
argument_list|()
expr_stmt|;
do|do
block|{
name|refcount
argument_list|()
expr_stmt|;
do|do
block|{
name|iterate
argument_list|()
expr_stmt|;
name|clearreg
argument_list|()
expr_stmt|;
name|niter
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|nchange
condition|)
do|;
name|comjump
argument_list|()
expr_stmt|;
name|rmove
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|nchange
operator|||
name|jumpsw
argument_list|()
condition|)
do|;
name|addsob
argument_list|()
expr_stmt|;
name|output
argument_list|()
expr_stmt|;
if|if
condition|(
name|niter
operator|>
name|maxiter
condition|)
name|maxiter
operator|=
name|niter
expr_stmt|;
name|lasta
operator|=
name|firstr
expr_stmt|;
block|}
do|while
condition|(
name|isend
condition|)
do|;
if|if
condition|(
name|nflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d iterations\n"
argument_list|,
name|maxiter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d jumps to jumps\n"
argument_list|,
name|nbrbr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d inst. after jumps\n"
argument_list|,
name|iaftbr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d jumps to .+1\n"
argument_list|,
name|njp1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d redundant labels\n"
argument_list|,
name|nrlab
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d cross-jumps\n"
argument_list|,
name|nxjump
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d code motions\n"
argument_list|,
name|ncmot
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d branches reversed\n"
argument_list|,
name|nrevbr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d redundant moves\n"
argument_list|,
name|redunm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d simplified addresses\n"
argument_list|,
name|nsaddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d loops inverted\n"
argument_list|,
name|loopiv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d redundant jumps\n"
argument_list|,
name|nredunj
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d common seqs before jmp's\n"
argument_list|,
name|ncomj
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d skips over jumps\n"
argument_list|,
name|nskip
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d sob's added\n"
argument_list|,
name|nsob
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d redundant tst's\n"
argument_list|,
name|nrtst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d jump on bit\n"
argument_list|,
name|nbj
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d field operations\n"
argument_list|,
name|nfield
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%dK core\n"
argument_list|,
operator|(
operator|(
name|unsigned
operator|)
name|lastr
operator|+
literal|01777
operator|)
operator|>>
literal|10
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|input
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastp
decl_stmt|;
name|struct
name|optab
modifier|*
name|op
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|;
specifier|static
name|struct
name|optab
name|F77JSW
init|=
block|{
literal|".long"
block|,
name|T
argument_list|(
argument|JSW
argument_list|,
literal|1
argument_list|)
block|}
decl_stmt|;
name|lastp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|top
label|:
name|op
operator|=
name|getline
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug
operator|&&
name|op
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"? %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|opcode
operator|&
literal|0377
condition|)
block|{
case|case
name|LABEL
case|:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
block|{
name|p
operator|->
name|combop
operator|=
name|LABEL
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isn
operator|<=
name|p
operator|->
name|labno
condition|)
name|isn
operator|=
literal|1
operator|+
name|p
operator|->
name|labno
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|combop
operator|=
name|DLABEL
expr_stmt|;
name|p
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LGEN
case|:
if|if
condition|(
operator|*
name|curlp
operator|!=
literal|'L'
condition|)
goto|goto
name|std
goto|;
name|op
operator|=
operator|&
name|F77JSW
expr_stmt|;
case|case
name|JBR
case|:
if|if
condition|(
name|op
operator|->
name|opcode
operator|==
name|T
argument_list|(
name|JBR
argument_list|,
name|RET
argument_list|)
condition|)
goto|goto
name|std
goto|;
case|case
name|CBR
case|:
case|case
name|JMP
case|:
case|case
name|JSW
case|:
case|case
name|SOBGEQ
case|:
case|case
name|SOBGTR
case|:
case|case
name|AOBLEQ
case|:
case|case
name|AOBLSS
case|:
case|case
name|ACB
case|:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p
operator|->
name|combop
operator|=
name|op
operator|->
name|opcode
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|cp1
operator|=
name|curlp
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|!=
literal|'L'
operator|||
literal|0
operator|==
operator|(
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|cp1
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
comment|/* jbs, etc.? */
while|while
condition|(
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
while|while
condition|(
operator|*
operator|--
name|cp1
operator|!=
literal|','
operator|&&
name|cp1
operator|!=
name|curlp
condition|)
empty_stmt|;
if|if
condition|(
name|cp1
operator|==
name|curlp
operator|||
operator|*
operator|++
name|cp1
operator|!=
literal|'L'
operator|||
literal|0
operator|==
operator|(
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|cp1
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|p
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
else|else
operator|*
operator|--
name|cp1
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|curlp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isn
operator|<=
name|p
operator|->
name|labno
condition|)
name|isn
operator|=
literal|1
operator|+
name|p
operator|->
name|labno
expr_stmt|;
break|break;
case|case
name|MOVA
case|:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p
operator|->
name|combop
operator|=
name|op
operator|->
name|opcode
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|cp1
operator|=
name|curlp
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|==
literal|'L'
condition|)
block|{
while|while
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
operator|*
operator|--
name|cp1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|curlp
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|cp1
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|cp1
operator|=
literal|','
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|curlp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
operator|--
name|cp1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|BSS
case|:
case|case
name|DATA
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|line
argument_list|,
operator|(
name|op
operator|->
name|opcode
operator|==
name|LABEL
condition|?
literal|':'
else|:
literal|'\n'
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|opcode
operator|==
name|TEXT
condition|)
goto|goto
name|top
goto|;
if|if
condition|(
name|END
operator|==
operator|(
name|op
operator|=
name|getline
argument_list|()
operator|)
operator|->
name|opcode
condition|)
block|{
comment|/* dangling .data is bad for you */
name|printf
argument_list|(
literal|".text\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|std
label|:
default|default:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p
operator|->
name|combop
operator|=
name|op
operator|->
name|opcode
expr_stmt|;
name|p
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|curlp
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|forw
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|back
operator|=
name|lastp
expr_stmt|;
name|p
operator|->
name|pop
operator|=
name|op
expr_stmt|;
name|lastp
operator|->
name|forw
operator|=
name|p
expr_stmt|;
name|lastp
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CASE
condition|)
block|{
name|char
modifier|*
name|lp
decl_stmt|;
name|int
name|ncase
decl_stmt|;
name|lp
operator|=
name|curlp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
condition|)
empty_stmt|;
while|while
condition|(
operator|*
operator|--
name|lp
operator|!=
literal|'$'
condition|)
empty_stmt|;
name|ncase
operator|=
name|getnum
argument_list|(
name|lp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL
operator|!=
operator|(
name|getline
argument_list|()
operator|)
operator|->
name|opcode
condition|)
name|abort
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|WGEN
operator|!=
operator|(
name|getline
argument_list|()
operator|)
operator|->
name|opcode
condition|)
name|abort
argument_list|(
operator|-
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p
operator|->
name|combop
operator|=
name|JSW
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|curlp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|!=
literal|'-'
condition|)
empty_stmt|;
operator|*
operator|--
name|lp
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|curlp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isn
operator|<=
name|p
operator|->
name|labno
condition|)
name|isn
operator|=
literal|1
operator|+
name|p
operator|->
name|labno
expr_stmt|;
name|p
operator|->
name|forw
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|back
operator|=
name|lastp
expr_stmt|;
name|lastp
operator|->
name|forw
operator|=
name|p
expr_stmt|;
name|lastp
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ncase
operator|>=
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|op
operator|->
name|opcode
operator|==
name|EROU
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|op
operator|->
name|opcode
operator|==
name|END
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_function
name|struct
name|optab
modifier|*
name|getline
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
specifier|static
name|struct
name|optab
name|OPLABEL
init|=
block|{
literal|""
block|,
name|LABEL
block|}
decl_stmt|;
specifier|static
name|struct
name|optab
name|OPEND
init|=
block|{
literal|""
block|,
name|END
block|}
decl_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|EOF
operator|!=
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
empty_stmt|;
while|while
condition|(
name|EOF
operator|!=
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|OPLABEL
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|oplook
argument_list|()
operator|)
return|;
block|}
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|OPEND
operator|)
return|;
block|}
end_function

begin_function
name|long
name|getnum
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|c
expr_stmt|;
name|int
name|neg
decl_stmt|;
specifier|register
name|long
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
operator|++
name|neg
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
operator|*
name|p
operator|++
argument_list|)
condition|)
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
name|n
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|n
operator|-=
name|c
expr_stmt|;
else|else
name|n
operator|+=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|--
name|p
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_macro
name|output
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|t
decl_stmt|;
name|int
name|casebas
decl_stmt|;
name|t
operator|=
operator|&
name|first
expr_stmt|;
while|while
condition|(
name|t
operator|=
name|t
operator|->
name|forw
condition|)
switch|switch
condition|(
name|t
operator|->
name|op
condition|)
block|{
case|case
name|END
case|:
return|return;
case|case
name|LABEL
case|:
name|printf
argument_list|(
literal|"L%d:"
argument_list|,
name|t
operator|->
name|labno
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DLABEL
case|:
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|t
operator|->
name|code
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|CASE
case|:
name|casebas
operator|=
literal|0
expr_stmt|;
default|default:
name|std
label|:
if|if
condition|(
name|t
operator|->
name|pop
operator|==
literal|0
condition|)
block|{
comment|/* must find it */
specifier|register
name|struct
name|optab
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|optab
init|;
name|p
operator|->
name|opstring
index|[
literal|0
index|]
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|->
name|opcode
operator|==
name|t
operator|->
name|combop
condition|)
block|{
name|t
operator|->
name|pop
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|t
operator|->
name|pop
operator|->
name|opstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|code
condition|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|t
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|labno
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%cL%d\n"
argument_list|,
operator|(
name|t
operator|->
name|code
condition|?
literal|','
else|:
literal|'\t'
operator|)
argument_list|,
name|t
operator|->
name|labno
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MOVA
case|:
if|if
condition|(
name|t
operator|->
name|labno
operator|==
literal|0
condition|)
goto|goto
name|std
goto|;
name|printf
argument_list|(
literal|"mova%c\tL%d,%s\n"
argument_list|,
literal|"bwlq"
index|[
name|t
operator|->
name|subop
operator|-
name|BYTE
index|]
argument_list|,
name|t
operator|->
name|labno
argument_list|,
name|t
operator|->
name|code
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|JSW
case|:
if|if
condition|(
name|t
operator|->
name|subop
operator|!=
literal|0
condition|)
block|{
comment|/* F77JSW */
name|printf
argument_list|(
literal|".long\tL%d\n"
argument_list|,
name|t
operator|->
name|labno
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|casebas
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|casebas
operator|=
name|isn
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".word	L%d-L%d\n"
argument_list|,
name|t
operator|->
name|labno
argument_list|,
name|casebas
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|copy
parameter_list|(
name|ap
parameter_list|)
name|char
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|onp
decl_stmt|;
specifier|register
name|n
expr_stmt|;
name|int
name|na
decl_stmt|;
name|na
operator|=
name|nargs
argument_list|()
expr_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
do|do
name|n
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|p
operator|++
condition|)
do|;
if|if
condition|(
name|na
operator|>
literal|1
condition|)
block|{
name|p
operator|=
operator|(
operator|&
name|ap
operator|)
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
name|n
operator|++
expr_stmt|;
block|}
name|onp
operator|=
name|np
operator|=
name|alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
while|while
condition|(
operator|*
name|np
operator|++
operator|=
operator|*
name|p
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|na
operator|>
literal|1
condition|)
block|{
name|p
operator|=
operator|(
operator|&
name|ap
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|np
operator|--
expr_stmt|;
while|while
condition|(
operator|*
name|np
operator|++
operator|=
operator|*
name|p
operator|++
condition|)
empty_stmt|;
block|}
return|return
operator|(
name|onp
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OPHS
value|560
end_define

begin_decl_stmt
name|struct
name|optab
modifier|*
name|ophash
index|[
name|OPHS
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|opsetup
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|optab
modifier|*
name|optp
decl_stmt|,
modifier|*
modifier|*
name|ophp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|t
decl_stmt|;
for|for
control|(
name|i
operator|=
name|NREG
operator|+
literal|5
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|regs
index|[
name|i
index|]
operator|=
name|alloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
for|for
control|(
name|optp
operator|=
name|optab
init|;
name|optp
operator|->
name|opstring
index|[
literal|0
index|]
condition|;
name|optp
operator|++
control|)
block|{
name|t
operator|=
literal|7
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|t
operator|>=
literal|0
condition|)
name|i
operator|+=
name|i
operator|+
name|optp
operator|->
name|opstring
index|[
name|t
index|]
expr_stmt|;
name|ophp
operator|=
operator|&
name|ophash
index|[
name|i
operator|%
name|OPHS
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|ophp
operator|++
condition|)
block|{
comment|/*			fprintf(stderr,"\ncollision: %d %s %s", /*				ophp-1-ophash,optp->opstring,(*(ophp-1))->opstring); */
if|if
condition|(
name|ophp
operator|>
operator|&
name|ophash
index|[
name|OPHS
index|]
condition|)
name|ophp
operator|=
name|ophash
expr_stmt|;
block|}
operator|*
operator|--
name|ophp
operator|=
name|optp
expr_stmt|;
block|}
block|}
end_block

begin_function
name|struct
name|optab
modifier|*
name|oplook
parameter_list|()
block|{
specifier|register
name|struct
name|optab
modifier|*
name|optp
decl_stmt|,
modifier|*
modifier|*
name|ophp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|char
name|tempop
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|struct
name|optab
name|OPNULL
init|=
block|{
literal|""
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|p
operator|=
name|line
operator|,
name|p2
operator|=
name|tempop
init|;
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|*
name|p2
operator|++
operator|=
operator|*
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p2
operator|=
literal|0
expr_stmt|;
name|p2
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p2
argument_list|)
condition|)
operator|++
name|p2
expr_stmt|;
name|curlp
operator|=
name|p2
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
name|line
condition|)
name|t
operator|+=
name|t
operator|+
operator|*
name|p
expr_stmt|;
name|ophp
operator|=
operator|&
name|ophash
index|[
name|t
operator|%
name|OPHS
index|]
expr_stmt|;
while|while
condition|(
name|optp
operator|=
operator|*
name|ophp
condition|)
block|{
if|if
condition|(
name|equstr
argument_list|(
name|tempop
argument_list|,
name|optp
operator|->
name|opstring
argument_list|)
condition|)
return|return
operator|(
name|optp
operator|)
return|;
if|if
condition|(
operator|(
operator|++
name|ophp
operator|)
operator|>=
operator|&
name|ophash
index|[
name|OPHS
index|]
condition|)
name|ophp
operator|=
name|ophash
expr_stmt|;
block|}
name|curlp
operator|=
name|line
expr_stmt|;
return|return
operator|(
operator|&
name|OPNULL
operator|)
return|;
block|}
end_function

begin_macro
name|refcount
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|struct
name|node
modifier|*
name|labhash
index|[
name|LABHS
index|]
decl_stmt|;
specifier|register
name|struct
name|node
modifier|*
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|labhash
init|;
name|hp
operator|<
operator|&
name|labhash
index|[
name|LABHS
index|]
condition|;
control|)
operator|*
name|hp
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
name|labhash
index|[
name|p
operator|->
name|labno
operator|%
name|LABHS
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|refc
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|JBR
operator|||
name|p
operator|->
name|op
operator|==
name|CBR
operator|||
name|p
operator|->
name|op
operator|==
name|JSW
operator|||
name|p
operator|->
name|op
operator|==
name|SOBGEQ
operator|||
name|p
operator|->
name|op
operator|==
name|SOBGTR
operator|||
name|p
operator|->
name|op
operator|==
name|AOBLEQ
operator|||
name|p
operator|->
name|op
operator|==
name|AOBLSS
operator|||
name|p
operator|->
name|op
operator|==
name|ACB
operator|||
operator|(
name|p
operator|->
name|op
operator|==
name|MOVA
operator|&&
name|p
operator|->
name|labno
operator|!=
literal|0
operator|)
condition|)
block|{
name|p
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|labhash
index|[
name|p
operator|->
name|labno
operator|%
name|LABHS
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
operator|||
name|p
operator|->
name|labno
operator|!=
name|lp
operator|->
name|labno
condition|)
for|for
control|(
name|lp
operator|=
name|first
operator|.
name|forw
init|;
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|op
operator|==
name|LABEL
operator|&&
name|p
operator|->
name|labno
operator|==
name|lp
operator|->
name|labno
condition|)
break|break;
block|}
if|if
condition|(
name|lp
condition|)
block|{
name|hp
operator|=
name|nonlab
argument_list|(
name|lp
argument_list|)
operator|->
name|back
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|lp
condition|)
block|{
name|p
operator|->
name|labno
operator|=
name|hp
operator|->
name|labno
expr_stmt|;
name|lp
operator|=
name|hp
expr_stmt|;
block|}
name|p
operator|->
name|ref
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|refc
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|LABEL
operator|&&
name|p
operator|->
name|refc
operator|==
literal|0
operator|&&
operator|(
name|lp
operator|=
name|nonlab
argument_list|(
name|p
argument_list|)
operator|)
operator|->
name|op
operator|&&
name|lp
operator|->
name|op
operator|!=
name|JSW
condition|)
name|decref
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|iterate
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|rp
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|nchange
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|op
operator|==
name|JBR
operator|||
name|p
operator|->
name|op
operator|==
name|CBR
operator|||
name|p
operator|->
name|op
operator|==
name|JSW
operator|)
operator|&&
name|p
operator|->
name|ref
condition|)
block|{
name|rp
operator|=
name|nonlab
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|op
operator|==
name|JBR
operator|&&
name|rp
operator|->
name|labno
operator|&&
name|p
operator|->
name|labno
operator|!=
name|rp
operator|->
name|labno
condition|)
block|{
name|nbrbr
operator|++
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|rp
operator|->
name|labno
expr_stmt|;
name|decref
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
name|rp
operator|->
name|ref
operator|->
name|refc
operator|++
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|rp
operator|->
name|ref
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CBR
operator|&&
operator|(
name|p1
operator|=
name|p
operator|->
name|forw
operator|)
operator|->
name|combop
operator|==
name|JBR
condition|)
block|{
comment|/* combop: RET problems */
name|rp
operator|=
name|p
operator|->
name|ref
expr_stmt|;
do|do
name|rp
operator|=
name|rp
operator|->
name|back
expr_stmt|;
do|while
condition|(
name|rp
operator|->
name|op
operator|==
name|LABEL
condition|)
do|;
if|if
condition|(
name|rp
operator|==
name|p1
condition|)
block|{
name|decref
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|p1
operator|->
name|ref
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|p1
operator|->
name|labno
expr_stmt|;
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|forw
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|revbr
index|[
name|p
operator|->
name|subop
index|]
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|nskip
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|JBR
operator|||
name|p
operator|->
name|op
operator|==
name|JMP
condition|)
block|{
while|while
condition|(
name|p
operator|->
name|forw
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|LABEL
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|DLABEL
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|EROU
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|END
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|ALIGN
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
literal|0
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|DATA
condition|)
block|{
name|nchange
operator|++
expr_stmt|;
name|iaftbr
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|ref
condition|)
name|decref
argument_list|(
name|p
operator|->
name|forw
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p
operator|->
name|forw
operator|=
name|p
operator|->
name|forw
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|back
operator|=
name|p
expr_stmt|;
block|}
name|rp
operator|=
name|p
operator|->
name|forw
expr_stmt|;
while|while
condition|(
name|rp
operator|&&
name|rp
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ref
operator|==
name|rp
condition|)
block|{
name|p
operator|->
name|back
operator|->
name|forw
operator|=
name|p
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|back
operator|=
name|p
operator|->
name|back
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|back
expr_stmt|;
name|decref
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|njp1
operator|++
expr_stmt|;
break|break;
block|}
name|rp
operator|=
name|rp
operator|->
name|forw
expr_stmt|;
block|}
name|xjump
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|codemove
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|xjump
argument_list|(
name|p1
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p1
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
name|int
name|nxj
decl_stmt|;
name|nxj
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p2
operator|=
name|p1
operator|->
name|ref
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|p1
operator|=
name|p1
operator|->
name|back
operator|)
operator|&&
name|p1
operator|->
name|op
operator|==
name|LABEL
condition|)
empty_stmt|;
while|while
condition|(
operator|(
name|p2
operator|=
name|p2
operator|->
name|back
operator|)
operator|&&
name|p2
operator|->
name|op
operator|==
name|LABEL
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|equop
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|||
name|p1
operator|==
name|p2
condition|)
return|return
operator|(
name|nxj
operator|)
return|;
name|p3
operator|=
name|insertl
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|p1
operator|->
name|combop
operator|=
name|JBR
expr_stmt|;
name|p1
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p1
operator|->
name|ref
operator|=
name|p3
expr_stmt|;
name|p1
operator|->
name|labno
operator|=
name|p3
operator|->
name|labno
expr_stmt|;
name|p1
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|nxj
operator|++
expr_stmt|;
name|nxjump
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_function
name|struct
name|node
modifier|*
name|insertl
parameter_list|(
name|op
parameter_list|)
specifier|register
name|struct
name|node
modifier|*
name|op
decl_stmt|;
block|{
specifier|register
name|struct
name|node
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|op
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
name|op
operator|->
name|refc
operator|++
expr_stmt|;
return|return
operator|(
name|op
operator|)
return|;
block|}
if|if
condition|(
name|op
operator|->
name|back
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
name|op
operator|=
name|op
operator|->
name|back
expr_stmt|;
name|op
operator|->
name|refc
operator|++
expr_stmt|;
return|return
operator|(
name|op
operator|)
return|;
block|}
name|lp
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|lp
operator|->
name|combop
operator|=
name|LABEL
expr_stmt|;
name|lp
operator|->
name|labno
operator|=
name|isn
operator|++
expr_stmt|;
name|lp
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|refc
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|back
operator|=
name|op
operator|->
name|back
expr_stmt|;
name|lp
operator|->
name|forw
operator|=
name|op
expr_stmt|;
name|op
operator|->
name|back
operator|->
name|forw
operator|=
name|lp
expr_stmt|;
name|op
operator|->
name|back
operator|=
name|lp
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|node
modifier|*
name|codemove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|node
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
name|struct
name|node
modifier|*
name|t
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|int
name|n
decl_stmt|;
name|p1
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|!=
name|JBR
operator|||
operator|(
name|p2
operator|=
name|p1
operator|->
name|ref
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p1
operator|)
return|;
while|while
condition|(
name|p2
operator|->
name|op
operator|==
name|LABEL
condition|)
if|if
condition|(
operator|(
name|p2
operator|=
name|p2
operator|->
name|back
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p1
operator|)
return|;
if|if
condition|(
name|p2
operator|->
name|op
operator|!=
name|JBR
operator|&&
name|p2
operator|->
name|op
operator|!=
name|JMP
condition|)
goto|goto
name|ivloop
goto|;
name|p2
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|p3
operator|=
name|p1
operator|->
name|ref
expr_stmt|;
while|while
condition|(
name|p3
condition|)
block|{
if|if
condition|(
name|p3
operator|->
name|op
operator|==
name|JBR
operator|||
name|p3
operator|->
name|op
operator|==
name|JMP
condition|)
block|{
if|if
condition|(
name|p1
operator|==
name|p3
condition|)
return|return
operator|(
name|p1
operator|)
return|;
name|ncmot
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|p1
operator|->
name|back
operator|->
name|forw
operator|=
name|p2
expr_stmt|;
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p3
expr_stmt|;
name|p2
operator|->
name|back
operator|->
name|forw
operator|=
name|p3
operator|->
name|forw
expr_stmt|;
name|p3
operator|->
name|forw
operator|->
name|back
operator|=
name|p2
operator|->
name|back
expr_stmt|;
name|p2
operator|->
name|back
operator|=
name|p1
operator|->
name|back
expr_stmt|;
name|p3
operator|->
name|forw
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|decref
argument_list|(
name|p1
operator|->
name|ref
argument_list|)
expr_stmt|;
return|return
operator|(
name|p2
operator|)
return|;
block|}
else|else
name|p3
operator|=
name|p3
operator|->
name|forw
expr_stmt|;
block|}
return|return
operator|(
name|p1
operator|)
return|;
name|ivloop
label|:
if|if
condition|(
name|p1
operator|->
name|forw
operator|->
name|op
operator|!=
name|LABEL
condition|)
return|return
operator|(
name|p1
operator|)
return|;
name|p3
operator|=
name|p2
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|n
operator|=
literal|16
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|p3
operator|=
name|p3
operator|->
name|forw
operator|)
operator|==
literal|0
operator|||
name|p3
operator|==
name|p1
operator|||
operator|--
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|p1
operator|)
return|;
block|}
do|while
condition|(
name|p3
operator|->
name|op
operator|!=
name|CBR
operator|||
name|p3
operator|->
name|labno
operator|!=
name|p1
operator|->
name|forw
operator|->
name|labno
condition|)
do|;
do|do
if|if
condition|(
operator|(
name|p1
operator|=
name|p1
operator|->
name|back
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ap
operator|)
return|;
do|while
condition|(
name|p1
operator|!=
name|p3
condition|)
do|;
name|p1
operator|=
name|ap
expr_stmt|;
name|tl
operator|=
name|insertl
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p3
operator|->
name|subop
operator|=
name|revbr
index|[
name|p3
operator|->
name|subop
index|]
expr_stmt|;
name|p3
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|decref
argument_list|(
name|p3
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p2
operator|->
name|back
operator|->
name|forw
operator|=
name|p1
expr_stmt|;
name|p3
operator|->
name|forw
operator|->
name|back
operator|=
name|p1
expr_stmt|;
name|p1
operator|->
name|back
operator|->
name|forw
operator|=
name|p2
expr_stmt|;
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p3
expr_stmt|;
name|t
operator|=
name|p1
operator|->
name|back
expr_stmt|;
name|p1
operator|->
name|back
operator|=
name|p2
operator|->
name|back
expr_stmt|;
name|p2
operator|->
name|back
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|p1
operator|->
name|forw
operator|=
name|p3
operator|->
name|forw
expr_stmt|;
name|p3
operator|->
name|forw
operator|=
name|t
expr_stmt|;
name|p2
operator|=
name|insertl
argument_list|(
name|p1
operator|->
name|forw
argument_list|)
expr_stmt|;
name|p3
operator|->
name|labno
operator|=
name|p2
operator|->
name|labno
expr_stmt|;
name|p3
operator|->
name|ref
operator|=
name|p2
expr_stmt|;
name|decref
argument_list|(
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl
operator|->
name|refc
operator|<=
literal|0
condition|)
name|nrlab
operator|--
expr_stmt|;
name|loopiv
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
return|return
operator|(
name|p3
operator|)
return|;
block|}
end_function

begin_macro
name|comjump
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|first
operator|.
name|forw
init|;
name|p1
operator|!=
literal|0
condition|;
name|p1
operator|=
name|p1
operator|->
name|forw
control|)
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|JBR
operator|&&
operator|(
operator|(
name|p2
operator|=
name|p1
operator|->
name|ref
operator|)
operator|&&
name|p2
operator|->
name|refc
operator|>
literal|1
operator|||
name|p1
operator|->
name|subop
operator|==
name|RET
operator|)
condition|)
for|for
control|(
name|p3
operator|=
name|p1
operator|->
name|forw
init|;
name|p3
operator|!=
literal|0
condition|;
name|p3
operator|=
name|p3
operator|->
name|forw
control|)
if|if
condition|(
name|p3
operator|->
name|op
operator|==
name|JBR
operator|&&
name|p3
operator|->
name|ref
operator|==
name|p2
condition|)
name|backjmp
argument_list|(
name|p1
argument_list|,
name|p3
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|backjmp
argument_list|(
argument|ap1
argument_list|,
argument|ap2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|ap1
decl_stmt|,
modifier|*
name|ap2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
name|p1
operator|=
name|ap1
expr_stmt|;
name|p2
operator|=
name|ap2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|p1
operator|=
name|p1
operator|->
name|back
operator|)
operator|&&
name|p1
operator|->
name|op
operator|==
name|LABEL
condition|)
empty_stmt|;
name|p2
operator|=
name|p2
operator|->
name|back
expr_stmt|;
if|if
condition|(
name|equop
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|p3
operator|=
name|insertl
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p2
operator|->
name|back
operator|->
name|forw
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|p2
operator|->
name|forw
operator|->
name|back
operator|=
name|p2
operator|->
name|back
expr_stmt|;
name|p2
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|decref
argument_list|(
name|p2
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p2
operator|->
name|combop
operator|=
name|JBR
expr_stmt|;
comment|/* to handle RET */
name|p2
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p2
operator|->
name|labno
operator|=
name|p3
operator|->
name|labno
expr_stmt|;
name|p2
operator|->
name|ref
operator|=
name|p3
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|ncomj
operator|++
expr_stmt|;
block|}
else|else
return|return;
block|}
block|}
end_block

end_unit

