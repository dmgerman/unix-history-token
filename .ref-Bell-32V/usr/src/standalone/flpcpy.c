begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"CON.h"
end_include

begin_include
include|#
directive|include
file|"FL.h"
end_include

begin_comment
comment|/*		*/
end_comment

begin_define
define|#
directive|define
name|BLKSIZ
value|512
end_define

begin_comment
comment|/*  tape block size */
end_comment

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|sector
decl_stmt|,
name|isector
decl_stmt|,
name|icount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bufptr
decl_stmt|,
name|input
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|ibufptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*		*/
end_comment

begin_function
name|main
parameter_list|()
block|{
comment|/* *  Stand-alone program to copy VAX LSI RX11 floppy diskette to *  memory and back to floppy. *  Floppy sector no.'s start at 1 for controller - start at 0 *	for user input. *  Floppy track no.'s start at 0. */
specifier|register
name|int
name|kk
decl_stmt|;
name|putlin
argument_list|(
literal|"flpcpy : Floppy-to-Memory-to-Floppy Copy"
argument_list|)
expr_stmt|;
name|putnl
argument_list|()
expr_stmt|;
name|doff
label|:
name|putstr
argument_list|(
literal|"floppy sector offset : "
argument_list|)
expr_stmt|;
name|getcon
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|sector
operator|=
name|a2l
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sector
operator|<
literal|0
operator|)
operator|||
operator|(
name|sector
operator|>=
name|MAXSEC
operator|)
condition|)
goto|goto
name|doff
goto|;
name|gknt
label|:
name|putstr
argument_list|(
literal|"no. of input sectors : "
argument_list|)
expr_stmt|;
name|getcon
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|count
operator|=
name|a2l
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
goto|goto
name|gknt
goto|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|count
operator|=
name|MAXSEC
expr_stmt|;
if|if
condition|(
name|init
argument_list|()
condition|)
block|{
name|putlin
argument_list|(
literal|"init error"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|isector
operator|=
name|sector
expr_stmt|;
name|icount
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|wo
condition|)
goto|goto
name|wflop
goto|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|count
operator|%
literal|100
operator|)
operator|==
literal|0
condition|)
block|{
name|kk
operator|=
name|count
operator|/
literal|100
expr_stmt|;
name|l2a
argument_list|(
name|kk
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flio
argument_list|(
name|FL_RS
argument_list|)
condition|)
block|{
comment|/* read */
name|putlin
argument_list|(
literal|"floppy input error"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|putnl
argument_list|()
expr_stmt|;
name|putlin
argument_list|(
literal|"floppy read complete"
argument_list|)
expr_stmt|;
name|wflop
label|:
name|putlin
argument_list|(
literal|"mount new floppy - type any key when ready"
argument_list|)
expr_stmt|;
name|getcon
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|count
operator|=
name|icount
expr_stmt|;
name|sector
operator|=
name|isector
expr_stmt|;
name|bufptr
operator|=
name|ibufptr
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|count
operator|%
literal|100
operator|)
operator|==
literal|0
condition|)
block|{
name|kk
operator|=
name|count
operator|/
literal|100
expr_stmt|;
name|l2a
argument_list|(
name|kk
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flio
argument_list|(
name|FL_WS
argument_list|)
condition|)
block|{
name|putlin
argument_list|(
literal|"floppy output error"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|putnl
argument_list|()
expr_stmt|;
name|putlin
argument_list|(
literal|"floppy write complete"
argument_list|)
expr_stmt|;
name|end
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*		*/
end_comment

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Initialization. */
specifier|extern
name|char
modifier|*
name|end
decl_stmt|;
name|ibufptr
operator|=
name|bufptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
operator|&
name|end
operator|+
literal|511
operator|)
operator|&
literal|017777777000
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|flio
argument_list|(
argument|func
argument_list|)
end_macro

begin_decl_stmt
name|int
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* *  Function to read/write 1 sector from floppy disc. *  'sector' is sector no.-1 to read into 'input[]'. *  Return (-1) for error, else return (0) . */
specifier|register
name|int
name|j
decl_stmt|,
name|s
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
comment|/* compute start track& sector from current sector 'sector'. */
name|t
operator|=
name|sector
operator|/
name|RXSTRK
expr_stmt|;
comment|/* track no. */
name|s
operator|=
name|sector
operator|%
name|RXSTRK
operator|+
literal|1
expr_stmt|;
comment|/* sector */
name|sector
operator|++
expr_stmt|;
name|fltwait
argument_list|()
expr_stmt|;
name|mtpr
argument_list|(
name|TXDB
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* Floppy Read/Write Sector command */
name|fltwait
argument_list|()
expr_stmt|;
name|mtpr
argument_list|(
name|TXDB
argument_list|,
name|s
operator||
name|FL_DATA
argument_list|)
expr_stmt|;
comment|/* supply sector no. to floppy interface */
name|fltwait
argument_list|()
expr_stmt|;
name|mtpr
argument_list|(
name|TXDB
argument_list|,
name|t
operator||
name|FL_DATA
argument_list|)
expr_stmt|;
comment|/* track no. */
if|if
condition|(
name|func
operator|==
name|FL_RS
condition|)
block|{
comment|/* Read Sector */
comment|/* wait for read to complete */
if|if
condition|(
name|fldone
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* loop to read sector bytes from interface */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|RXBYSEC
condition|;
name|j
operator|++
control|)
block|{
name|flrwait
argument_list|()
expr_stmt|;
comment|/* wait till ready */
operator|(
operator|*
name|bufptr
operator|++
operator|)
operator|=
name|mfpr
argument_list|(
name|RXDB
argument_list|)
expr_stmt|;
comment|/*get data byte-assume from floppy*/
block|}
block|}
else|else
block|{
if|if
condition|(
name|func
operator|==
name|FL_WS
condition|)
block|{
comment|/* Write Sector */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|RXBYSEC
condition|;
name|j
operator|++
control|)
block|{
comment|/* send byte over interface */
name|fltwait
argument_list|()
expr_stmt|;
name|c
operator|=
operator|(
operator|*
name|bufptr
operator|++
operator|)
operator|&
literal|0xff
expr_stmt|;
name|mtpr
argument_list|(
name|TXDB
argument_list|,
operator|(
name|c
operator||
name|FL_DATA
operator|)
argument_list|)
expr_stmt|;
block|}
name|fltwait
argument_list|()
expr_stmt|;
if|if
condition|(
name|fldone
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|count
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

