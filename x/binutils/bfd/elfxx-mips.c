begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MIPS-specific support for ELF    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,    2003 Free Software Foundation, Inc.     Most of the information added by Ian Lance Taylor, Cygnus Support,<ian@cygnus.com>.    N32/64 ABI support added by Mark Mitchell, CodeSourcery, LLC.<mark@codesourcery.com>    Traditional MIPS targets support added by Koundinya.K, Dansk Data    Elektronik& Operations Research Group.<kk@ddeorg.soft.net>     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file handles functionality common to the different MIPS ABI's.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elfxx-mips.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_comment
comment|/* Get the ECOFF swapping routines.  */
end_comment

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"coff/mips.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* This structure is used to hold .got entries while estimating got    sizes.  */
end_comment

begin_struct
struct|struct
name|mips_got_entry
block|{
comment|/* The input bfd in which the symbol is defined.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* The index of the symbol, as stored in the relocation r_info, if      we have a local symbol; -1 otherwise.  */
name|long
name|symndx
decl_stmt|;
union|union
block|{
comment|/* If abfd == NULL, an address that must be stored in the got.  */
name|bfd_vma
name|address
decl_stmt|;
comment|/* If abfd != NULL&& symndx != -1, the addend of the relocation        that should be added to the symbol value.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* If abfd != NULL&& symndx == -1, the hash table entry        corresponding to a global symbol in the got (or, local, if        h->forced_local).  */
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|}
name|d
union|;
comment|/* The offset from the beginning of the .got section to the entry      corresponding to this symbol+addend.  If it's a global symbol      whose offset is yet to be decided, it's going to be -1.  */
name|long
name|gotidx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to hold .got information when linking.  */
end_comment

begin_struct
struct|struct
name|mips_got_info
block|{
comment|/* The global symbol in the GOT with the lowest index in the dynamic      symbol table.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|global_gotsym
decl_stmt|;
comment|/* The number of global .got entries.  */
name|unsigned
name|int
name|global_gotno
decl_stmt|;
comment|/* The number of local .got entries.  */
name|unsigned
name|int
name|local_gotno
decl_stmt|;
comment|/* The number of local .got entries we have used.  */
name|unsigned
name|int
name|assigned_gotno
decl_stmt|;
comment|/* A hash table holding members of the got.  */
name|struct
name|htab
modifier|*
name|got_entries
decl_stmt|;
comment|/* A hash table mapping input bfds to other mips_got_info.  NULL      unless multi-got was necessary.  */
name|struct
name|htab
modifier|*
name|bfd2got
decl_stmt|;
comment|/* In multi-got links, a pointer to the next got (err, rather, most      of the time, it points to the previous got).  */
name|struct
name|mips_got_info
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Map an input bfd to a got in a multi-got link.  */
end_comment

begin_struct
struct|struct
name|mips_elf_bfd2got_hash
block|{
name|bfd
modifier|*
name|bfd
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure passed when traversing the bfd2got hash table, used to    create and merge bfd's gots.  */
end_comment

begin_struct
struct|struct
name|mips_elf_got_per_bfd_arg
block|{
comment|/* A hashtable that maps bfds to gots.  */
name|htab_t
name|bfd2got
decl_stmt|;
comment|/* The output bfd.  */
name|bfd
modifier|*
name|obfd
decl_stmt|;
comment|/* The link information.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* A pointer to the primary got, i.e., the one that's going to get      the implicit relocations from DT_MIPS_LOCAL_GOTNO and      DT_MIPS_GOTSYM.  */
name|struct
name|mips_got_info
modifier|*
name|primary
decl_stmt|;
comment|/* A non-primary got we're trying to merge with other input bfd's      gots.  */
name|struct
name|mips_got_info
modifier|*
name|current
decl_stmt|;
comment|/* The maximum number of got entries that can be addressed with a      16-bit offset.  */
name|unsigned
name|int
name|max_count
decl_stmt|;
comment|/* The number of local and global entries in the primary got.  */
name|unsigned
name|int
name|primary_count
decl_stmt|;
comment|/* The number of local and global entries in the current got.  */
name|unsigned
name|int
name|current_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Another structure used to pass arguments for got entries traversal.  */
end_comment

begin_struct
struct|struct
name|mips_elf_set_global_got_offset_arg
block|{
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|int
name|value
decl_stmt|;
name|unsigned
name|int
name|needed_relocs
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_mips_elf_section_data
block|{
name|struct
name|bfd_elf_section_data
name|elf
decl_stmt|;
union|union
block|{
name|struct
name|mips_got_info
modifier|*
name|got_info
decl_stmt|;
name|bfd_byte
modifier|*
name|tdata
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|mips_elf_section_data
parameter_list|(
name|sec
parameter_list|)
define|\
value|((struct _mips_elf_section_data *) elf_section_data (sec))
end_define

begin_comment
comment|/* This structure is passed to mips_elf_sort_hash_table_f when sorting    the dynamic symbols.  */
end_comment

begin_struct
struct|struct
name|mips_elf_hash_sort_data
block|{
comment|/* The symbol in the global GOT with the lowest dynamic symbol table      index.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|low
decl_stmt|;
comment|/* The least dynamic symbol table index corresponding to a symbol      with a GOT entry.  */
name|long
name|min_got_dynindx
decl_stmt|;
comment|/* The greatest dynamic symbol table index corresponding to a symbol      with a GOT entry that is not referenced (e.g., a dynamic symbol      with dynamic relocations pointing to it from non-primary GOTs).  */
name|long
name|max_unref_got_dynindx
decl_stmt|;
comment|/* The greatest dynamic symbol table index not corresponding to a      symbol without a GOT entry.  */
name|long
name|max_non_got_dynindx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The MIPS ELF linker needs additional information for each symbol in    the global hash table.  */
end_comment

begin_struct
struct|struct
name|mips_elf_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* External symbol information.  */
name|EXTR
name|esym
decl_stmt|;
comment|/* Number of R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 relocs against      this symbol.  */
name|unsigned
name|int
name|possibly_dynamic_relocs
decl_stmt|;
comment|/* If the R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 reloc is against      a readonly section.  */
name|bfd_boolean
name|readonly_reloc
decl_stmt|;
comment|/* We must not create a stub for a symbol that has relocations      related to taking the function's address, i.e. any but      R_MIPS_CALL*16 ones -- see "MIPS ABI Supplement, 3rd Edition",      p. 4-20.  */
name|bfd_boolean
name|no_fn_stub
decl_stmt|;
comment|/* If there is a stub that 32 bit functions should use to call this      16 bit function, this points to the section containing the stub.  */
name|asection
modifier|*
name|fn_stub
decl_stmt|;
comment|/* Whether we need the fn_stub; this is set if this symbol appears      in any relocs other than a 16 bit call.  */
name|bfd_boolean
name|need_fn_stub
decl_stmt|;
comment|/* If there is a stub that 16 bit functions should use to call this      32 bit function, this points to the section containing the stub.  */
name|asection
modifier|*
name|call_stub
decl_stmt|;
comment|/* This is like the call_stub field, but it is used if the function      being called returns a floating point value.  */
name|asection
modifier|*
name|call_fp_stub
decl_stmt|;
comment|/* Are we forced local?  .*/
name|bfd_boolean
name|forced_local
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* MIPS ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|mips_elf_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
if|#
directive|if
literal|0
comment|/* We no longer use this.  */
comment|/* String section indices for the dynamic section symbols.  */
block|bfd_size_type dynsym_sec_strindex[SIZEOF_MIPS_DYNSYM_SECNAMES];
endif|#
directive|endif
comment|/* The number of .rtproc entries.  */
name|bfd_size_type
name|procedure_count
decl_stmt|;
comment|/* The size of the .compact_rel section (if SGI_COMPAT).  */
name|bfd_size_type
name|compact_rel_size
decl_stmt|;
comment|/* This flag indicates that the value of DT_MIPS_RLD_MAP dynamic      entry is set to the address of __rld_obj_head as in IRIX5.  */
name|bfd_boolean
name|use_rld_obj_head
decl_stmt|;
comment|/* This is the value of the __rld_map or __rld_obj_head symbol.  */
name|bfd_vma
name|rld_value
decl_stmt|;
comment|/* This is set if we see any mips16 stub sections.  */
name|bfd_boolean
name|mips16_stubs_seen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure used to pass information to mips_elf_output_extsym.  */
end_comment

begin_struct
struct|struct
name|extsym_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|bfd_boolean
name|failed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The names of the runtime procedure table symbols used on IRIX5.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_elf_dynsym_rtproc_names
index|[]
init|=
block|{
literal|"_procedure_table"
block|,
literal|"_procedure_string_table"
block|,
literal|"_procedure_table_size"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These structures are used to generate the .compact_rel section on    IRIX5.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|id1
decl_stmt|;
comment|/* Always one?  */
name|unsigned
name|long
name|num
decl_stmt|;
comment|/* Number of compact relocation entries.  */
name|unsigned
name|long
name|id2
decl_stmt|;
comment|/* Always two?  */
name|unsigned
name|long
name|offset
decl_stmt|;
comment|/* The file offset of the first relocation.  */
name|unsigned
name|long
name|reserved0
decl_stmt|;
comment|/* Zero?  */
name|unsigned
name|long
name|reserved1
decl_stmt|;
comment|/* Zero?  */
block|}
name|Elf32_compact_rel
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|id1
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|num
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|id2
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|offset
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|reserved0
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|reserved1
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_compact_rel
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|ctype
range|:
literal|1
decl_stmt|;
comment|/* 1: long 0: short format. See below.  */
name|unsigned
name|int
name|rtype
range|:
literal|4
decl_stmt|;
comment|/* Relocation types. See below.  */
name|unsigned
name|int
name|dist2to
range|:
literal|8
decl_stmt|;
name|unsigned
name|int
name|relvaddr
range|:
literal|19
decl_stmt|;
comment|/* (VADDR - vaddr of the previous entry)/ 4 */
name|unsigned
name|long
name|konst
decl_stmt|;
comment|/* KONST field. See below.  */
name|unsigned
name|long
name|vaddr
decl_stmt|;
comment|/* VADDR to be relocated.  */
block|}
name|Elf32_crinfo
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|ctype
range|:
literal|1
decl_stmt|;
comment|/* 1: long 0: short format. See below.  */
name|unsigned
name|int
name|rtype
range|:
literal|4
decl_stmt|;
comment|/* Relocation types. See below.  */
name|unsigned
name|int
name|dist2to
range|:
literal|8
decl_stmt|;
name|unsigned
name|int
name|relvaddr
range|:
literal|19
decl_stmt|;
comment|/* (VADDR - vaddr of the previous entry)/ 4 */
name|unsigned
name|long
name|konst
decl_stmt|;
comment|/* KONST field. See below.  */
block|}
name|Elf32_crinfo2
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|info
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|konst
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|vaddr
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_crinfo
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|info
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|konst
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_crinfo2
typedef|;
end_typedef

begin_comment
comment|/* These are the constants used to swap the bitfields in a crinfo.  */
end_comment

begin_define
define|#
directive|define
name|CRINFO_CTYPE
value|(0x1)
end_define

begin_define
define|#
directive|define
name|CRINFO_CTYPE_SH
value|(31)
end_define

begin_define
define|#
directive|define
name|CRINFO_RTYPE
value|(0xf)
end_define

begin_define
define|#
directive|define
name|CRINFO_RTYPE_SH
value|(27)
end_define

begin_define
define|#
directive|define
name|CRINFO_DIST2TO
value|(0xff)
end_define

begin_define
define|#
directive|define
name|CRINFO_DIST2TO_SH
value|(19)
end_define

begin_define
define|#
directive|define
name|CRINFO_RELVADDR
value|(0x7ffff)
end_define

begin_define
define|#
directive|define
name|CRINFO_RELVADDR_SH
value|(0)
end_define

begin_comment
comment|/* A compact relocation info has long (3 words) or short (2 words)    formats.  A short format doesn't have VADDR field and relvaddr    fields contains ((VADDR - vaddr of the previous entry)>> 2).  */
end_comment

begin_define
define|#
directive|define
name|CRF_MIPS_LONG
value|1
end_define

begin_define
define|#
directive|define
name|CRF_MIPS_SHORT
value|0
end_define

begin_comment
comment|/* There are 4 types of compact relocation at least. The value KONST    has different meaning for each type:     (type)		(konst)    CT_MIPS_REL32	Address in data    CT_MIPS_WORD		Address in word (XXX)    CT_MIPS_GPHI_LO	GP - vaddr    CT_MIPS_JMPAD	Address to jump    */
end_comment

begin_define
define|#
directive|define
name|CRT_MIPS_REL32
value|0xa
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_WORD
value|0xb
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_GPHI_LO
value|0xc
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_JMPAD
value|0xd
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_format
parameter_list|(
name|x
parameter_list|,
name|format
parameter_list|)
value|((x).ctype = (format))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_type
parameter_list|(
name|x
parameter_list|,
name|type
parameter_list|)
value|((x).rtype = (type))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_dist2to
parameter_list|(
name|x
parameter_list|,
name|v
parameter_list|)
value|((x).dist2to = (v))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_relvaddr
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
value|((x).relvaddr = (d)<<2)
end_define

begin_escape
end_escape

begin_comment
comment|/* The structure of the runtime procedure descriptor created by the    loader for use by the static exception system.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|runtime_pdr
block|{
name|bfd_vma
name|adr
decl_stmt|;
comment|/* Memory address of start of procedure.  */
name|long
name|regmask
decl_stmt|;
comment|/* Save register mask.  */
name|long
name|regoffset
decl_stmt|;
comment|/* Save register offset.  */
name|long
name|fregmask
decl_stmt|;
comment|/* Save floating point register mask.  */
name|long
name|fregoffset
decl_stmt|;
comment|/* Save floating point register offset.  */
name|long
name|frameoffset
decl_stmt|;
comment|/* Frame size.  */
name|short
name|framereg
decl_stmt|;
comment|/* Frame pointer register.  */
name|short
name|pcreg
decl_stmt|;
comment|/* Offset or reg of return pc.  */
name|long
name|irpss
decl_stmt|;
comment|/* Index into the runtime string table.  */
name|long
name|reserved
decl_stmt|;
name|struct
name|exception_info
modifier|*
name|exception_info
decl_stmt|;
comment|/* Pointer to exception array.  */
block|}
name|RPDR
operator|,
typedef|*
name|pRPDR
typedef|;
end_typedef

begin_define
define|#
directive|define
name|cbRPDR
value|sizeof (RPDR)
end_define

begin_define
define|#
directive|define
name|rpdNil
value|((pRPDR) 0)
end_define

begin_escape
end_escape

begin_function_decl
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|mips_elf_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ecoff_swap_rpdr_out
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|RPDR
modifier|*
parameter_list|,
name|struct
name|rpdr_ext
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_create_procedure_table
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|ecoff_debug_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_check_mips16_stubs
parameter_list|(
name|struct
name|mips_elf_link_hash_entry
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_in
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|Elf32_External_gptab
modifier|*
parameter_list|,
name|Elf32_gptab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_out
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|Elf32_gptab
modifier|*
parameter_list|,
name|Elf32_External_gptab
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bfd_elf32_swap_compact_rel_out
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|Elf32_compact_rel
modifier|*
parameter_list|,
name|Elf32_External_compact_rel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bfd_elf32_swap_crinfo_out
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|Elf32_crinfo
modifier|*
parameter_list|,
name|Elf32_External_crinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sort_dynamic_relocs
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sort_dynamic_relocs_64
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_output_extsym
parameter_list|(
name|struct
name|mips_elf_link_hash_entry
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gptab_compare
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|asection
modifier|*
name|mips_elf_rel_dyn_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|asection
modifier|*
name|mips_elf_got_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mips_got_info
modifier|*
name|mips_elf_got_info
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|mips_elf_get_global_gotsym_index
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_local_got_index
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_global_got_index
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_got_page
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_got16_entry
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_got_offset_from_index
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mips_got_entry
modifier|*
name|mips_elf_create_local_got_entry
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|struct
name|mips_got_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_sort_hash_table
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_sort_hash_table_f
parameter_list|(
name|struct
name|mips_elf_link_hash_entry
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_record_local_got_symbol
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|long
parameter_list|,
name|bfd_vma
parameter_list|,
name|struct
name|mips_got_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_record_global_got_symbol
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|mips_got_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|Elf_Internal_Rela
modifier|*
name|mips_elf_next_relocation
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_local_relocation_p
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|asection
modifier|*
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_overflow_p
parameter_list|(
name|bfd_vma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_high
parameter_list|(
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_higher
parameter_list|(
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_highest
parameter_list|(
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_create_compact_rel_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_create_got_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|mips_elf_calculate_relocation
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|reloc_howto_type
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_obtain_contents
parameter_list|(
name|reloc_howto_type
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_perform_relocation
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|reloc_howto_type
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_stub_section_p
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_elf_allocate_dynamic_relocations
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_create_dynamic_relocation
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|struct
name|mips_elf_link_hash_entry
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_set_isa_flags
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|char
modifier|*
name|elf_mips_abi_name
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_elf_irix6_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_mach_extends_p
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_32bit_flags_p
parameter_list|(
name|flagword
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|hashval_t
name|mips_elf_hash_bfd_vma
parameter_list|(
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|mips_elf_got_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_elf_got_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_multi_got
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|mips_got_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|mips_elf_multi_got_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_elf_multi_got_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|mips_elf_bfd2got_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_elf_bfd2got_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_elf_make_got_per_bfd
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_elf_merge_gots
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_elf_set_global_got_offset
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_elf_set_no_stub
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_elf_resolve_final_got_entry
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_elf_resolve_final_got_entries
parameter_list|(
name|struct
name|mips_got_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_adjust_gp
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|mips_got_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mips_got_info
modifier|*
name|mips_elf_got_for_ibfd
parameter_list|(
name|struct
name|mips_got_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This will be used when we sort the dynamic relocation records.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|reldyn_sorting_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if ABFD is using the N32 ABI.  */
end_comment

begin_define
define|#
directive|define
name|ABI_N32_P
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((elf_elfheader (abfd)->e_flags& EF_MIPS_ABI2) != 0)
end_define

begin_comment
comment|/* Nonzero if ABFD is using the N64 ABI.  */
end_comment

begin_define
define|#
directive|define
name|ABI_64_P
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->elfclass == ELFCLASS64)
end_define

begin_comment
comment|/* Nonzero if ABFD is using NewABI conventions.  */
end_comment

begin_define
define|#
directive|define
name|NEWABI_P
parameter_list|(
name|abfd
parameter_list|)
value|(ABI_N32_P (abfd) || ABI_64_P (abfd))
end_define

begin_comment
comment|/* The IRIX compatibility level we are striving for.  */
end_comment

begin_define
define|#
directive|define
name|IRIX_COMPAT
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->elf_backend_mips_irix_compat (abfd))
end_define

begin_comment
comment|/* Whether we are trying to be compatible with IRIX at all.  */
end_comment

begin_define
define|#
directive|define
name|SGI_COMPAT
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(IRIX_COMPAT (abfd) != ict_none)
end_define

begin_comment
comment|/* The name of the options section.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_OPTIONS_SECTION_NAME
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(NEWABI_P (abfd) ? ".MIPS.options" : ".options")
end_define

begin_comment
comment|/* The name of the stub section.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_STUB_SECTION_NAME
parameter_list|(
name|abfd
parameter_list|)
value|".MIPS.stubs"
end_define

begin_comment
comment|/* The size of an external REL relocation.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_REL_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_rel)
end_define

begin_comment
comment|/* The size of an external dynamic table entry.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_DYN_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_dyn)
end_define

begin_comment
comment|/* The size of a GOT entry.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_GOT_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->arch_size / 8)
end_define

begin_comment
comment|/* The size of a symbol-table entry.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_SYM_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_sym)
end_define

begin_comment
comment|/* The default alignment for sections, as a power of two.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_LOG_FILE_ALIGN
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->log_file_align)
end_define

begin_comment
comment|/* Get word-sized data.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_GET_WORD
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
define|\
value|(ABI_64_P (abfd) ? bfd_get_64 (abfd, ptr) : bfd_get_32 (abfd, ptr))
end_define

begin_comment
comment|/* Put out word-sized data.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_PUT_WORD
parameter_list|(
name|abfd
parameter_list|,
name|val
parameter_list|,
name|ptr
parameter_list|)
define|\
value|(ABI_64_P (abfd) 				\    ? bfd_put_64 (abfd, val, ptr) 		\    : bfd_put_32 (abfd, val, ptr))
end_define

begin_comment
comment|/* Add a dynamic symbol table-entry.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
parameter_list|(
name|info
parameter_list|,
name|tag
parameter_list|,
name|val
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, tag, val)
end_define

begin_define
define|#
directive|define
name|MIPS_ELF_RTYPE_TO_HOWTO
parameter_list|(
name|abfd
parameter_list|,
name|rtype
parameter_list|,
name|rela
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->elf_backend_mips_rtype_to_howto (rtype, rela))
end_define

begin_comment
comment|/* Determine whether the internal relocation of index REL_IDX is REL    (zero) or RELA (non-zero).  The assumption is that, if there are    two relocation sections for this section, one of them is REL and    the other is RELA.  If the index of the relocation we're testing is    in range for the first relocation section, check that the external    relocation size is that for RELA.  It is also assumed that, if    rel_idx is not in range for the first section, and this first    section contains REL relocs, then the relocation is in the second    section, that is RELA.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_RELOC_RELA_P
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel_idx
parameter_list|)
define|\
value|((NUM_SHDR_ENTRIES (&elf_section_data (sec)->rel_hdr)			\     * get_elf_backend_data (abfd)->s->int_rels_per_ext_rel		\> (bfd_vma)(rel_idx))						\    == (elf_section_data (sec)->rel_hdr.sh_entsize			\        == (ABI_64_P (abfd) ? sizeof (Elf64_External_Rela)		\ 	   : sizeof (Elf32_External_Rela))))
end_define

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value    from smaller values.  Start with zero, widen, *then* decrement.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma)0) - 1)
end_define

begin_comment
comment|/* The number of local .got entries we reserve.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_RESERVED_GOTNO
value|(2)
end_define

begin_comment
comment|/* The offset of $gp from the beginning of the .got section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MIPS_GP_OFFSET
parameter_list|(
name|abfd
parameter_list|)
value|(0x7ff0)
end_define

begin_comment
comment|/* The maximum size of the GOT for it to be addressable using 16-bit    offsets from $gp.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_GOT_MAX_SIZE
parameter_list|(
name|abfd
parameter_list|)
value|(ELF_MIPS_GP_OFFSET(abfd) + 0x7fff)
end_define

begin_comment
comment|/* Instructions which appear in a stub.  */
end_comment

begin_define
define|#
directive|define
name|STUB_LW
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((ABI_64_P (abfd)  						\     ? 0xdf998010
comment|/* ld t9,0x8010(gp) */
value|\     : 0x8f998010))
end_define

begin_comment
comment|/* lw t9,0x8010(gp) */
end_comment

begin_define
define|#
directive|define
name|STUB_MOVE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((ABI_64_P (abfd)						\      ? 0x03e0782d
comment|/* daddu t7,ra */
value|\      : 0x03e07821))
end_define

begin_comment
comment|/* addu t7,ra */
end_comment

begin_define
define|#
directive|define
name|STUB_JALR
value|0x0320f809
end_define

begin_comment
comment|/* jalr t9,ra */
end_comment

begin_define
define|#
directive|define
name|STUB_LI16
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((ABI_64_P (abfd)						\    ? 0x64180000
comment|/* daddiu t8,zero,0 */
value|\    : 0x24180000))
end_define

begin_comment
comment|/* addiu t8,zero,0 */
end_comment

begin_define
define|#
directive|define
name|MIPS_FUNCTION_STUB_SIZE
value|(16)
end_define

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(ABI_N32_P (abfd) ? "/usr/lib32/libc.so.1" 	\     : ABI_64_P (abfd) ? "/usr/lib64/libc.so.1" 	\     : "/usr/lib/libc.so.1")
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_define
define|#
directive|define
name|MNAME
parameter_list|(
name|bfd
parameter_list|,
name|pre
parameter_list|,
name|pos
parameter_list|)
define|\
value|(ABI_64_P (bfd) ? CONCAT4 (pre,64,_,pos) : CONCAT4 (pre,32,_,pos))
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|bfd
parameter_list|,
name|i
parameter_list|)
define|\
value|(ABI_64_P (bfd) ? ELF64_R_SYM (i) : ELF32_R_SYM (i))
end_define

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|bfd
parameter_list|,
name|i
parameter_list|)
define|\
value|(ABI_64_P (bfd) ? ELF64_MIPS_R_TYPE (i) : ELF32_R_TYPE (i))
end_define

begin_define
define|#
directive|define
name|ELF_R_INFO
parameter_list|(
name|bfd
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|)
define|\
value|(ABI_64_P (bfd) ? ELF64_R_INFO (s, t) : ELF32_R_INFO (s, t))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MNAME
parameter_list|(
name|bfd
parameter_list|,
name|pre
parameter_list|,
name|pos
parameter_list|)
value|CONCAT4 (pre,32,_,pos)
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|bfd
parameter_list|,
name|i
parameter_list|)
define|\
value|(ELF32_R_SYM (i))
end_define

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|bfd
parameter_list|,
name|i
parameter_list|)
define|\
value|(ELF32_R_TYPE (i))
end_define

begin_define
define|#
directive|define
name|ELF_R_INFO
parameter_list|(
name|bfd
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|)
define|\
value|(ELF32_R_INFO (s, t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The mips16 compiler uses a couple of special sections to handle      floating point arguments.       Section names that look like .mips16.fn.FNNAME contain stubs that      copy floating point arguments from the fp regs to the gp regs and      then jump to FNNAME.  If any 32 bit function calls FNNAME, the      call should be redirected to the stub instead.  If no 32 bit      function calls FNNAME, the stub should be discarded.  We need to      consider any reference to the function, not just a call, because      if the address of the function is taken we will need the stub,      since the address might be passed to a 32 bit function.       Section names that look like .mips16.call.FNNAME contain stubs      that copy floating point arguments from the gp regs to the fp      regs and then jump to FNNAME.  If FNNAME is a 32 bit function,      then any 16 bit function that calls FNNAME should be redirected      to the stub instead.  If FNNAME is not a 32 bit function, the      stub should be discarded.       .mips16.call.fp.FNNAME sections are similar, but contain stubs      which call FNNAME and then copy the return value from the fp regs      to the gp regs.  These stubs store the return value in $18 while      calling FNNAME; any function which might call one of these stubs      must arrange to save $18 around the call.  (This case is not      needed for 32 bit functions that call 16 bit functions, because      16 bit functions always return floating point values in both      $f0/$f1 and $2/$3.)       Note that in all cases FNNAME might be defined statically.      Therefore, FNNAME is not used literally.  Instead, the relocation      information will indicate which symbol the section is for.       We record any stubs that we find in the symbol table.  */
end_comment

begin_define
define|#
directive|define
name|FN_STUB
value|".mips16.fn."
end_define

begin_define
define|#
directive|define
name|CALL_STUB
value|".mips16.call."
end_define

begin_define
define|#
directive|define
name|CALL_FP_STUB
value|".mips16.call.fp."
end_define

begin_escape
end_escape

begin_comment
comment|/* Look up an entry in a MIPS ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct mips_elf_link_hash_entry *)					\    elf_link_hash_lookup (&(table)->root, (string), (create),		\ 			 (copy), (follow)))
end_define

begin_comment
comment|/* Traverse a MIPS ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the MIPS ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct mips_elf_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Create an entry in a MIPS ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|mips_elf_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|memset
argument_list|(
operator|&
name|ret
operator|->
name|esym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use -2 as a marker to indicate that the information has 	 not been set.  -1 means there is no associated ifd.  */
name|ret
operator|->
name|esym
operator|.
name|ifd
operator|=
operator|-
literal|2
expr_stmt|;
name|ret
operator|->
name|possibly_dynamic_relocs
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|readonly_reloc
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|no_fn_stub
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|fn_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|need_fn_stub
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|call_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|call_fp_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|forced_local
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_mips_elf_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|_mips_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
decl_stmt|;
name|sdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|sdata
expr_stmt|;
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read ECOFF debugging information from a .mdebug section into a    ecoff_debug_info structure.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_read_ecoff_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|struct
name|ecoff_debug_info
modifier|*
name|debug
parameter_list|)
block|{
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|char
modifier|*
name|ext_hdr
decl_stmt|;
name|swap
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
name|memset
argument_list|(
name|debug
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|debug
argument_list|)
argument_list|)
expr_stmt|;
name|ext_hdr
operator|=
name|bfd_malloc
argument_list|(
name|swap
operator|->
name|external_hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_hdr
operator|==
name|NULL
operator|&&
name|swap
operator|->
name|external_hdr_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|ext_hdr
argument_list|,
literal|0
argument_list|,
name|swap
operator|->
name|external_hdr_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|symhdr
operator|=
operator|&
name|debug
operator|->
name|symbolic_header
expr_stmt|;
call|(
modifier|*
name|swap
operator|->
name|swap_hdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ext_hdr
argument_list|,
name|symhdr
argument_list|)
expr_stmt|;
comment|/* The symbolic header contains absolute file offsets and sizes to      read.  */
define|#
directive|define
name|READ
parameter_list|(
name|ptr
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|,
name|type
parameter_list|)
define|\
value|if (symhdr->count == 0)						\     debug->ptr = NULL;							\   else									\     {									\       bfd_size_type amt = (bfd_size_type) size * symhdr->count;		\       debug->ptr = bfd_malloc (amt);					\       if (debug->ptr == NULL)						\ 	goto error_return;						\       if (bfd_seek (abfd, symhdr->offset, SEEK_SET) != 0		\ 	  || bfd_bread (debug->ptr, amt, abfd) != amt)			\ 	goto error_return;						\     }
name|READ
argument_list|(
argument|line
argument_list|,
argument|cbLineOffset
argument_list|,
argument|cbLine
argument_list|,
argument|sizeof (unsigned char)
argument_list|,
argument|unsigned char *
argument_list|)
empty_stmt|;
name|READ
argument_list|(
name|external_dnr
argument_list|,
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_pdr
argument_list|,
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_sym
argument_list|,
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_opt
argument_list|,
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_aux
argument_list|,
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ss
argument_list|,
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ssext
argument_list|,
name|cbSsExtOffset
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_fdr
argument_list|,
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_rfd
argument_list|,
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_ext
argument_list|,
name|cbExtOffset
argument_list|,
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|READ
name|debug
operator|->
name|fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|->
name|adjust
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|ext_hdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ext_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_dnr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_dnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_pdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_pdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_sym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_opt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_aux
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ssext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ssext
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_fdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_fdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_rfd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_ext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_ext
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Swap RPDR (runtime procedure table entry) for output.  */
end_comment

begin_function
specifier|static
name|void
name|ecoff_swap_rpdr_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|RPDR
modifier|*
name|in
parameter_list|,
name|struct
name|rpdr_ext
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_S32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|adr
argument_list|,
name|ex
operator|->
name|p_adr
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|regmask
argument_list|,
name|ex
operator|->
name|p_regmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|regoffset
argument_list|,
name|ex
operator|->
name|p_regoffset
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|fregmask
argument_list|,
name|ex
operator|->
name|p_fregmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|fregoffset
argument_list|,
name|ex
operator|->
name|p_fregoffset
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|frameoffset
argument_list|,
name|ex
operator|->
name|p_frameoffset
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|framereg
argument_list|,
name|ex
operator|->
name|p_framereg
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|pcreg
argument_list|,
name|ex
operator|->
name|p_pcreg
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|irpss
argument_list|,
name|ex
operator|->
name|p_irpss
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME */
block|H_PUT_S32 (abfd, in->exception_info, ex->p_exception_info);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Create a runtime procedure table from the .mdebug section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_create_procedure_table
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
name|struct
name|ecoff_debug_info
modifier|*
name|debug
parameter_list|)
block|{
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|HDRR
modifier|*
name|hdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|RPDR
modifier|*
name|rpdr
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|struct
name|rpdr_ext
modifier|*
name|erp
decl_stmt|;
name|void
modifier|*
name|rtproc
decl_stmt|;
name|struct
name|pdr_ext
modifier|*
name|epdr
decl_stmt|;
name|struct
name|sym_ext
modifier|*
name|esym
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|,
modifier|*
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|unsigned
name|long
name|sindex
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|PDR
name|pdr
decl_stmt|;
name|SYMR
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|no_name_func
init|=
name|_
argument_list|(
literal|"static procedure (no name)"
argument_list|)
decl_stmt|;
name|epdr
operator|=
name|NULL
expr_stmt|;
name|rpdr
operator|=
name|NULL
expr_stmt|;
name|esym
operator|=
name|NULL
expr_stmt|;
name|ss
operator|=
name|NULL
expr_stmt|;
name|sv
operator|=
name|NULL
expr_stmt|;
name|swap
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
name|sindex
operator|=
name|strlen
argument_list|(
name|no_name_func
argument_list|)
operator|+
literal|1
expr_stmt|;
name|count
operator|=
name|hdr
operator|->
name|ipdMax
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|size
operator|=
name|swap
operator|->
name|external_pdr_size
expr_stmt|;
name|epdr
operator|=
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|epdr
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_pdr
argument_list|(
name|handle
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|epdr
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|RPDR
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rpdr
operator|=
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|sv
operator|=
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|isymMax
expr_stmt|;
name|size
operator|=
name|swap
operator|->
name|external_sym_size
expr_stmt|;
name|esym
operator|=
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_sym
argument_list|(
name|handle
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|esym
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|issMax
expr_stmt|;
name|ss
operator|=
name|bfd_malloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_ss
argument_list|(
name|handle
argument_list|,
name|ss
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|ipdMax
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
name|long
operator|)
name|count
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
control|)
block|{
call|(
modifier|*
name|swap
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|epdr
operator|+
name|i
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|esym
index|[
name|pdr
operator|.
name|isym
index|]
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|rp
operator|->
name|adr
operator|=
name|sym
operator|.
name|value
expr_stmt|;
name|rp
operator|->
name|regmask
operator|=
name|pdr
operator|.
name|regmask
expr_stmt|;
name|rp
operator|->
name|regoffset
operator|=
name|pdr
operator|.
name|regoffset
expr_stmt|;
name|rp
operator|->
name|fregmask
operator|=
name|pdr
operator|.
name|fregmask
expr_stmt|;
name|rp
operator|->
name|fregoffset
operator|=
name|pdr
operator|.
name|fregoffset
expr_stmt|;
name|rp
operator|->
name|frameoffset
operator|=
name|pdr
operator|.
name|frameoffset
expr_stmt|;
name|rp
operator|->
name|framereg
operator|=
name|pdr
operator|.
name|framereg
expr_stmt|;
name|rp
operator|->
name|pcreg
operator|=
name|pdr
operator|.
name|pcreg
expr_stmt|;
name|rp
operator|->
name|irpss
operator|=
name|sindex
expr_stmt|;
name|sv
index|[
name|i
index|]
operator|=
name|ss
operator|+
name|sym
operator|.
name|iss
expr_stmt|;
name|sindex
operator|+=
name|strlen
argument_list|(
name|sv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
operator|*
operator|(
name|count
operator|+
literal|2
operator|)
operator|+
name|sindex
expr_stmt|;
name|size
operator|=
name|BFD_ALIGN
argument_list|(
name|size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|rtproc
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc
operator|==
name|NULL
condition|)
block|{
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
operator|=
literal|0
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
operator|=
name|count
operator|+
literal|2
expr_stmt|;
name|erp
operator|=
name|rtproc
expr_stmt|;
name|memset
argument_list|(
name|erp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
argument_list|)
expr_stmt|;
name|erp
operator|++
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|rtproc
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
operator|*
operator|(
name|count
operator|+
literal|2
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|no_name_func
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|no_name_func
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ecoff_swap_rpdr_out
argument_list|(
name|abfd
argument_list|,
name|rpdr
operator|+
name|i
argument_list|,
name|erp
operator|+
name|i
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|sv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|sv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|H_PUT_S32
argument_list|(
name|abfd
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|erp
operator|+
name|count
operator|)
operator|->
name|p_adr
argument_list|)
expr_stmt|;
comment|/* Set the size and contents of .rtproc section.  */
name|s
operator|->
name|_raw_size
operator|=
name|size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|rtproc
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently      matters, but someday it might).  */
name|s
operator|->
name|link_order_head
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|epdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|epdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rpdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|esym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|epdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|epdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rpdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|esym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Check the mips16 stubs for a particular symbol, and see if we can    discard them.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_check_mips16_stubs
parameter_list|(
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|fn_stub
operator|!=
name|NULL
operator|&&
operator|!
name|h
operator|->
name|need_fn_stub
condition|)
block|{
comment|/* We don't need the fn_stub; the only references to this symbol          are 16 bit calls.  Clobber the size to 0 to prevent it from          being included in the link.  */
name|h
operator|->
name|fn_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
comment|/* We don't need the call_stub; this is a 16 bit function, so          calls from other 16 bit functions are OK.  Clobber the size          to 0 to prevent it from being included in the link.  */
name|h
operator|->
name|call_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
comment|/* We don't need the call_stub; this is a 16 bit function, so          calls from other 16 bit functions are OK.  Clobber the size          to 0 to prevent it from being included in the link.  */
name|h
operator|->
name|call_fp_stub
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_gprel16_with_gp
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bfd_vma
name|gp
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_signed_vma
name|val
decl_stmt|;
name|bfd_reloc_status_type
name|status
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Set val to the offset into the section or symbol.  */
name|val
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|_bfd_mips_elf_sign_extend
argument_list|(
name|val
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Adjust val for the final section location and GP value.  If we      are producing relocatable output, we don't want to do this for      an external symbol.  */
if|if
condition|(
operator|!
name|relocatable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
name|relocation
operator|-
name|gp
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
condition|)
block|{
name|status
operator|=
name|_bfd_relocate_contents
argument_list|(
name|reloc_entry
operator|->
name|howto
argument_list|,
name|abfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|status
return|;
block|}
else|else
name|reloc_entry
operator|->
name|addend
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|relocatable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Used to store a REL high-part relocation such as R_MIPS_HI16 or    R_MIPS_GOT16.  REL is the relocation, INPUT_SECTION is the section    that contains the relocation field and DATA points to the start of    INPUT_SECTION.  */
end_comment

begin_struct
struct|struct
name|mips_hi16
block|{
name|struct
name|mips_hi16
modifier|*
name|next
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|arelent
name|rel
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FIXME: This should not be a static variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_hi16
modifier|*
name|mips_hi16_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A howto special_function for REL *HI16 relocations.  We can only    calculate the correct value once we've seen the partnering    *LO16 relocation, so just save the information for later.     The ABI requires that the *LO16 immediately follow the *HI16.    However, as a GNU extension, we permit an arbitrary number of    *HI16s to be associated with a single *LO16.  This significantly    simplies the relocation handling in gcc.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_hi16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|mips_hi16
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|n
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|n
operator|->
name|next
operator|=
name|mips_hi16_list
expr_stmt|;
name|n
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|n
operator|->
name|input_section
operator|=
name|input_section
expr_stmt|;
name|n
operator|->
name|rel
operator|=
operator|*
name|reloc_entry
expr_stmt|;
name|mips_hi16_list
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* A howto special_function for REL R_MIPS_GOT16 relocations.  This is just    like any other 16-bit relocation when applied to global symbols, but is    treated in the same as R_MIPS_HI16 when applied to local symbols.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_got16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
if|if
condition|(
operator|(
name|symbol
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
comment|/* The relocation is against a global symbol.  */
return|return
name|_bfd_mips_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
return|return
name|_bfd_mips_elf_hi16_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A howto special_function for REL *LO16 relocations.  The *LO16 itself    is a straightforward 16 bit inplace relocation, but we must deal with    any partnering high-part relocations as well.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_lo16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_vma
name|vallo
decl_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|vallo
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
while|while
condition|(
name|mips_hi16_list
operator|!=
name|NULL
condition|)
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|struct
name|mips_hi16
modifier|*
name|hi
decl_stmt|;
name|hi
operator|=
name|mips_hi16_list
expr_stmt|;
comment|/* R_MIPS_GOT16 relocations are something of a special case.  We 	 want to install the addend in the same way as for a R_MIPS_HI16 	 relocation (with a rightshift of 16).  However, since GOT16 	 relocations can also be used with global symbols, their howto 	 has a rightshift of 0.  */
if|if
condition|(
name|hi
operator|->
name|rel
operator|.
name|howto
operator|->
name|type
operator|==
name|R_MIPS_GOT16
condition|)
name|hi
operator|->
name|rel
operator|.
name|howto
operator|=
name|MIPS_ELF_RTYPE_TO_HOWTO
argument_list|(
name|abfd
argument_list|,
name|R_MIPS_HI16
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* VALLO is a signed 16-bit number.  Bias it by 0x8000 so that any 	 carry or borrow will induce a change of +1 or -1 in the high part.  */
name|hi
operator|->
name|rel
operator|.
name|addend
operator|+=
operator|(
name|vallo
operator|+
literal|0x8000
operator|)
operator|&
literal|0xffff
expr_stmt|;
comment|/* R_MIPS_GNU_REL_HI16 relocations are relative to the address of the 	 lo16 relocation, not their own address.  If we're calculating the 	 final value, and hence subtracting the "PC", subtract the offset 	 of the lo16 relocation from here.  */
if|if
condition|(
name|output_bfd
operator|==
name|NULL
operator|&&
name|hi
operator|->
name|rel
operator|.
name|howto
operator|->
name|type
operator|==
name|R_MIPS_GNU_REL_HI16
condition|)
name|hi
operator|->
name|rel
operator|.
name|addend
operator|-=
name|reloc_entry
operator|->
name|address
operator|-
name|hi
operator|->
name|rel
operator|.
name|address
expr_stmt|;
name|ret
operator|=
name|_bfd_mips_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
operator|&
name|hi
operator|->
name|rel
argument_list|,
name|symbol
argument_list|,
name|hi
operator|->
name|data
argument_list|,
name|hi
operator|->
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
name|mips_hi16_list
operator|=
name|hi
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
return|return
name|_bfd_mips_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A generic howto special_function.  This calculates and installs the    relocation itself, thus avoiding the oft-discussed problems in    bfd_perform_relocation and bfd_install_relocation.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_generic_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_signed_vma
name|val
decl_stmt|;
name|bfd_reloc_status_type
name|status
decl_stmt|;
name|bfd_boolean
name|relocatable
decl_stmt|;
name|relocatable
operator|=
operator|(
name|output_bfd
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Build up the field adjustment in VAL.  */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Either we're calculating the final field value or we have a 	 relocation against a section symbol.  Add in the section's 	 offset or address.  */
name|val
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|val
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|relocatable
condition|)
block|{
comment|/* We're calculating the final field value.  Add in the symbol's value 	 and, if pc-relative, subtract the address of the field itself.  */
name|val
operator|+=
name|symbol
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|val
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|val
operator|-=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|val
operator|-=
name|reloc_entry
operator|->
name|address
expr_stmt|;
block|}
block|}
comment|/* VAL is now the final adjustment.  If we're keeping this relocation      in the output file, and if the relocation uses a separate addend,      we just need to add VAL to that addend.  Otherwise we need to add      VAL to the relocation field itself.  */
if|if
condition|(
name|relocatable
operator|&&
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
condition|)
name|reloc_entry
operator|->
name|addend
operator|+=
name|val
expr_stmt|;
else|else
block|{
comment|/* Add in the separate addend, if any.  */
name|val
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Add VAL to the relocation field.  */
name|status
operator|=
name|_bfd_relocate_contents
argument_list|(
name|reloc_entry
operator|->
name|howto
argument_list|,
name|abfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|status
return|;
block|}
if|if
condition|(
name|relocatable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Swap an entry in a .gptab section.  Note that these routines rely    on the equivalence of the two elements of the union.  */
end_comment

begin_function
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_External_gptab
modifier|*
name|ex
parameter_list|,
name|Elf32_gptab
modifier|*
name|in
parameter_list|)
block|{
name|in
operator|->
name|gt_entry
operator|.
name|gt_g_value
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|)
expr_stmt|;
name|in
operator|->
name|gt_entry
operator|.
name|gt_bytes
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_gptab
modifier|*
name|in
parameter_list|,
name|Elf32_External_gptab
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_elf32_swap_compact_rel_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_compact_rel
modifier|*
name|in
parameter_list|,
name|Elf32_External_compact_rel
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|id1
argument_list|,
name|ex
operator|->
name|id1
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|num
argument_list|,
name|ex
operator|->
name|num
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|id2
argument_list|,
name|ex
operator|->
name|id2
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|offset
argument_list|,
name|ex
operator|->
name|offset
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|reserved0
argument_list|,
name|ex
operator|->
name|reserved0
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|reserved1
argument_list|,
name|ex
operator|->
name|reserved1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_elf32_swap_crinfo_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_crinfo
modifier|*
name|in
parameter_list|,
name|Elf32_External_crinfo
modifier|*
name|ex
parameter_list|)
block|{
name|unsigned
name|long
name|l
decl_stmt|;
name|l
operator|=
operator|(
operator|(
operator|(
name|in
operator|->
name|ctype
operator|&
name|CRINFO_CTYPE
operator|)
operator|<<
name|CRINFO_CTYPE_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|rtype
operator|&
name|CRINFO_RTYPE
operator|)
operator|<<
name|CRINFO_RTYPE_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|dist2to
operator|&
name|CRINFO_DIST2TO
operator|)
operator|<<
name|CRINFO_DIST2TO_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|relvaddr
operator|&
name|CRINFO_RELVADDR
operator|)
operator|<<
name|CRINFO_RELVADDR_SH
operator|)
operator|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|l
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|konst
argument_list|,
name|ex
operator|->
name|konst
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|vaddr
argument_list|,
name|ex
operator|->
name|vaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A .reginfo section holds a single Elf32_RegInfo structure.  These    routines swap this structure in and out.  They are used outside of    BFD, so they are globally visible.  */
end_comment

begin_function
name|void
name|bfd_mips_elf32_swap_reginfo_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_External_RegInfo
modifier|*
name|ex
parameter_list|,
name|Elf32_RegInfo
modifier|*
name|in
parameter_list|)
block|{
name|in
operator|->
name|ri_gprmask
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_gp_value
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_mips_elf32_swap_reginfo_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_RegInfo
modifier|*
name|in
parameter_list|,
name|Elf32_External_RegInfo
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gprmask
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gp_value
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In the 64 bit ABI, the .MIPS.options section holds register    information in an Elf64_Reginfo structure.  These routines swap    them in and out.  They are globally visible because they are used    outside of BFD.  These routines are here so that gas can call them    without worrying about whether the 64 bit ABI has been included.  */
end_comment

begin_function
name|void
name|bfd_mips_elf64_swap_reginfo_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf64_External_RegInfo
modifier|*
name|ex
parameter_list|,
name|Elf64_Internal_RegInfo
modifier|*
name|in
parameter_list|)
block|{
name|in
operator|->
name|ri_gprmask
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_pad
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_pad
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_gp_value
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_mips_elf64_swap_reginfo_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf64_Internal_RegInfo
modifier|*
name|in
parameter_list|,
name|Elf64_External_RegInfo
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gprmask
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_pad
argument_list|,
name|ex
operator|->
name|ri_pad
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|H_PUT_64
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gp_value
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in an options header.  */
end_comment

begin_function
name|void
name|bfd_mips_elf_swap_options_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_External_Options
modifier|*
name|ex
parameter_list|,
name|Elf_Internal_Options
modifier|*
name|in
parameter_list|)
block|{
name|in
operator|->
name|kind
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|kind
argument_list|)
expr_stmt|;
name|in
operator|->
name|size
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|size
argument_list|)
expr_stmt|;
name|in
operator|->
name|section
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|section
argument_list|)
expr_stmt|;
name|in
operator|->
name|info
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out an options header.  */
end_comment

begin_function
name|void
name|bfd_mips_elf_swap_options_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Options
modifier|*
name|in
parameter_list|,
name|Elf_External_Options
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|kind
argument_list|,
name|ex
operator|->
name|kind
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|size
argument_list|,
name|ex
operator|->
name|size
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|section
argument_list|,
name|ex
operator|->
name|section
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|info
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called via qsort() to sort the dynamic relocation    entries by increasing r_symndx value.  */
end_comment

begin_function
specifier|static
name|int
name|sort_dynamic_relocs
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|Elf_Internal_Rela
name|int_reloc1
decl_stmt|;
name|Elf_Internal_Rela
name|int_reloc2
decl_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|reldyn_sorting_bfd
argument_list|,
name|arg1
argument_list|,
operator|&
name|int_reloc1
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|reldyn_sorting_bfd
argument_list|,
name|arg2
argument_list|,
operator|&
name|int_reloc2
argument_list|)
expr_stmt|;
return|return
name|ELF32_R_SYM
argument_list|(
name|int_reloc1
operator|.
name|r_info
argument_list|)
operator|-
name|ELF32_R_SYM
argument_list|(
name|int_reloc2
operator|.
name|r_info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like sort_dynamic_relocs, but used for elf64 relocations.  */
end_comment

begin_function
specifier|static
name|int
name|sort_dynamic_relocs_64
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|Elf_Internal_Rela
name|int_reloc1
index|[
literal|3
index|]
decl_stmt|;
name|Elf_Internal_Rela
name|int_reloc2
index|[
literal|3
index|]
decl_stmt|;
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|reldyn_sorting_bfd
argument_list|)
operator|->
name|s
operator|->
name|swap_reloc_in
operator|)
operator|(
name|reldyn_sorting_bfd
operator|,
name|arg1
operator|,
name|int_reloc1
operator|)
expr_stmt|;
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|reldyn_sorting_bfd
argument_list|)
operator|->
name|s
operator|->
name|swap_reloc_in
operator|)
operator|(
name|reldyn_sorting_bfd
operator|,
name|arg2
operator|,
name|int_reloc2
operator|)
expr_stmt|;
return|return
operator|(
name|ELF64_R_SYM
argument_list|(
name|int_reloc1
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
operator|-
name|ELF64_R_SYM
argument_list|(
name|int_reloc2
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This routine is used to write out ECOFF debugging external symbol    information.  It is called via mips_elf_link_hash_traverse.  The    ECOFF external symbol information must match the ELF external    symbol information.  Unfortunately, at this point we don't know    whether a symbol is required by reloc information, so the two    tables may wind up being different.  We must sort out the external    symbol information before we can set the final size of the .mdebug    section, and we must set the size of the .mdebug section before we    can relocate any sections, and we can't know which symbols are    required by relocation until we relocate the sections.    Fortunately, it is relatively unlikely that any symbol will be    stripped but required by a reloc.  In particular, it can not happen    when generating a final executable.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_output_extsym
parameter_list|(
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|extsym_info
modifier|*
name|einfo
init|=
name|data
decl_stmt|;
name|bfd_boolean
name|strip
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|output_section
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|indx
operator|==
operator|-
literal|2
condition|)
name|strip
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|einfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|strip
operator|=
name|TRUE
expr_stmt|;
else|else
name|strip
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strip
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|ifd
operator|==
operator|-
literal|2
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stGlobal
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Use undefined class.  Also, set class and type for some              special symbols.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|mips_elf_hash_table
argument_list|(
name|einfo
operator|->
name|info
argument_list|)
operator|->
name|procedure_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|)
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|elf_gp
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
comment|/* When making a shared library and symbol h is the one from 	     the another shared library, OUTPUT_SECTION may be null.  */
if|if
condition|(
name|output_section
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_section_name
argument_list|(
name|output_section
operator|->
name|owner
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scText
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rodata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scRData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scInit
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scFini
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
block|}
block|}
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hd
init|=
name|h
decl_stmt|;
name|bfd_boolean
name|no_fn_stub
init|=
name|h
operator|->
name|no_fn_stub
decl_stmt|;
while|while
condition|(
name|hd
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
name|hd
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|no_fn_stub
operator|=
name|no_fn_stub
operator|||
name|hd
operator|->
name|no_fn_stub
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_fn_stub
condition|)
block|{
comment|/* Set type and value for a symbol with a function stub.  */
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stProc
expr_stmt|;
name|sec
operator|=
name|hd
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|hd
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* FIXME?  */
block|h->esym.ifd = 0;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|,
name|einfo
operator|->
name|debug
argument_list|,
name|einfo
operator|->
name|swap
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|h
operator|->
name|esym
argument_list|)
condition|)
block|{
name|einfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A comparison routine used to sort .gptab entries.  */
end_comment

begin_function
specifier|static
name|int
name|gptab_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|Elf32_gptab
modifier|*
name|a1
init|=
name|p1
decl_stmt|;
specifier|const
name|Elf32_gptab
modifier|*
name|a2
init|=
name|p2
decl_stmt|;
return|return
name|a1
operator|->
name|gt_entry
operator|.
name|gt_g_value
operator|-
name|a2
operator|->
name|gt_entry
operator|.
name|gt_g_value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to manage the got entry hash table.  */
end_comment

begin_comment
comment|/* Use all 64 bits of a bfd_vma for the computation of a 32-bit    hash number.  */
end_comment

begin_function
specifier|static
name|INLINE
name|hashval_t
name|mips_elf_hash_bfd_vma
parameter_list|(
name|bfd_vma
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
return|return
name|addr
operator|+
operator|(
name|addr
operator|>>
literal|32
operator|)
return|;
else|#
directive|else
return|return
name|addr
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* got_entries only match if they're identical, except for gotidx, so    use all fields to compute the hash, and compare the appropriate    union members.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|mips_elf_got_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|entry_
parameter_list|)
block|{
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry_
decl_stmt|;
return|return
name|entry
operator|->
name|symndx
operator|+
operator|(
operator|!
name|entry
operator|->
name|abfd
condition|?
name|mips_elf_hash_bfd_vma
argument_list|(
name|entry
operator|->
name|d
operator|.
name|address
argument_list|)
else|:
name|entry
operator|->
name|abfd
operator|->
name|id
operator|+
operator|(
name|entry
operator|->
name|symndx
operator|>=
literal|0
condition|?
name|mips_elf_hash_bfd_vma
argument_list|(
name|entry
operator|->
name|d
operator|.
name|addend
argument_list|)
else|:
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|hash
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mips_elf_got_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|entry1
parameter_list|,
specifier|const
name|void
modifier|*
name|entry2
parameter_list|)
block|{
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|e1
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry1
decl_stmt|;
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|e2
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry2
decl_stmt|;
return|return
name|e1
operator|->
name|abfd
operator|==
name|e2
operator|->
name|abfd
operator|&&
name|e1
operator|->
name|symndx
operator|==
name|e2
operator|->
name|symndx
operator|&&
operator|(
operator|!
name|e1
operator|->
name|abfd
condition|?
name|e1
operator|->
name|d
operator|.
name|address
operator|==
name|e2
operator|->
name|d
operator|.
name|address
else|:
name|e1
operator|->
name|symndx
operator|>=
literal|0
condition|?
name|e1
operator|->
name|d
operator|.
name|addend
operator|==
name|e2
operator|->
name|d
operator|.
name|addend
else|:
name|e1
operator|->
name|d
operator|.
name|h
operator|==
name|e2
operator|->
name|d
operator|.
name|h
operator|)
return|;
block|}
end_function

begin_comment
comment|/* multi_got_entries are still a match in the case of global objects,    even if the input bfd in which they're referenced differs, so the    hash computation and compare functions are adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|mips_elf_multi_got_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|entry_
parameter_list|)
block|{
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry_
decl_stmt|;
return|return
name|entry
operator|->
name|symndx
operator|+
operator|(
operator|!
name|entry
operator|->
name|abfd
condition|?
name|mips_elf_hash_bfd_vma
argument_list|(
name|entry
operator|->
name|d
operator|.
name|address
argument_list|)
else|:
name|entry
operator|->
name|symndx
operator|>=
literal|0
condition|?
operator|(
name|entry
operator|->
name|abfd
operator|->
name|id
operator|+
name|mips_elf_hash_bfd_vma
argument_list|(
name|entry
operator|->
name|d
operator|.
name|addend
argument_list|)
operator|)
else|:
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|hash
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mips_elf_multi_got_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|entry1
parameter_list|,
specifier|const
name|void
modifier|*
name|entry2
parameter_list|)
block|{
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|e1
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry1
decl_stmt|;
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|e2
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry2
decl_stmt|;
return|return
name|e1
operator|->
name|symndx
operator|==
name|e2
operator|->
name|symndx
operator|&&
operator|(
name|e1
operator|->
name|symndx
operator|>=
literal|0
condition|?
name|e1
operator|->
name|abfd
operator|==
name|e2
operator|->
name|abfd
operator|&&
name|e1
operator|->
name|d
operator|.
name|addend
operator|==
name|e2
operator|->
name|d
operator|.
name|addend
else|:
name|e1
operator|->
name|abfd
operator|==
name|NULL
operator|||
name|e2
operator|->
name|abfd
operator|==
name|NULL
condition|?
name|e1
operator|->
name|abfd
operator|==
name|e2
operator|->
name|abfd
operator|&&
name|e1
operator|->
name|d
operator|.
name|address
operator|==
name|e2
operator|->
name|d
operator|.
name|address
else|:
name|e1
operator|->
name|d
operator|.
name|h
operator|==
name|e2
operator|->
name|d
operator|.
name|h
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the dynamic relocation section for DYNOBJ.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mips_elf_rel_dyn_section
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|bfd_boolean
name|create_p
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|dname
index|[]
init|=
literal|".rel.dyn"
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|&&
name|create_p
condition|)
block|{
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|dynobj
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|sreloc
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT section for ABFD.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mips_elf_got_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|maybe_excluded
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
operator|||
operator|(
operator|!
name|maybe_excluded
operator|&&
operator|(
name|sgot
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|sgot
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT information associated with the link indicated by    INFO.  If SGOTP is non-NULL, it is filled in with the GOT    section.  */
end_comment

begin_function
specifier|static
name|struct
name|mips_got_info
modifier|*
name|mips_elf_got_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
modifier|*
name|sgotp
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|abfd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgotp
condition|)
operator|*
name|sgotp
operator|=
operator|(
name|sgot
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|==
literal|0
condition|?
name|sgot
else|:
name|NULL
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* Obtain the lowest dynamic index of a symbol that was assigned a    global GOT entry.  */
end_comment

begin_function
specifier|static
name|long
name|mips_elf_get_global_gotsym_index
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|abfd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
operator|||
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
operator|||
name|g
operator|->
name|global_gotsym
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT offset at which the indicated address can be found.    If there is not yet a GOT entry for this value, create one.  Returns    -1 if no satisfactory GOT offset can be found.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_local_got_index
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_got_entry
modifier|*
name|entry
decl_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
name|entry
operator|=
name|mips_elf_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|ibfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
return|return
name|entry
operator|->
name|gotidx
return|;
else|else
return|return
name|MINUS_ONE
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT index for the global symbol indicated by H.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_global_got_index
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd_vma
name|index
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|,
modifier|*
name|gg
decl_stmt|;
name|long
name|global_got_dynindx
init|=
literal|0
decl_stmt|;
name|gg
operator|=
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|abfd
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|bfd2got
operator|&&
name|ibfd
condition|)
block|{
name|struct
name|mips_got_entry
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_got_for_ibfd
argument_list|(
name|g
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|next
operator|!=
name|gg
condition|)
block|{
name|e
operator|.
name|abfd
operator|=
name|ibfd
expr_stmt|;
name|e
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|.
name|d
operator|.
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|p
operator|=
name|htab_find
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|gotidx
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|p
operator|->
name|gotidx
return|;
block|}
block|}
if|if
condition|(
name|gg
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|global_got_dynindx
operator|=
name|gg
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
comment|/* Once we determine the global GOT entry with the lowest dynamic      symbol table index, we must put all dynamic symbols with greater      indices into the GOT.  That makes it easy to calculate the GOT      offset.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|>=
name|global_got_dynindx
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
operator|(
name|h
operator|->
name|dynindx
operator|-
name|global_got_dynindx
operator|+
name|g
operator|->
name|local_gotno
operator|)
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|index
operator|<
name|sgot
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Find a GOT entry that is within 32KB of the VALUE.  These entries    are supposed to be placed at small offsets in the GOT, i.e.,    within 32KB of GP.  Return the index into the GOT for this page,    and store the offset from this entry to the desired address in    OFFSETP, if it is non-NULL.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_got_page
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|bfd_vma
modifier|*
name|offsetp
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_vma
name|index
decl_stmt|;
name|struct
name|mips_got_entry
modifier|*
name|entry
decl_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
name|entry
operator|=
name|mips_elf_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|ibfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
operator|(
name|value
operator|+
literal|0x8000
operator|)
operator|&
operator|(
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffff
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return
name|MINUS_ONE
return|;
name|index
operator|=
name|entry
operator|->
name|gotidx
expr_stmt|;
if|if
condition|(
name|offsetp
condition|)
operator|*
name|offsetp
operator|=
name|value
operator|-
name|entry
operator|->
name|d
operator|.
name|address
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Find a GOT entry whose higher-order 16 bits are the same as those    for value.  Return the index into the GOT for this entry.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_got16_entry
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|bfd_boolean
name|external
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_got_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|external
condition|)
block|{
comment|/* Although the ABI says that it is "the high-order 16 bits" that we 	 want, it is really the %high value.  The complete value is 	 calculated with a `addiu' of a LO16 relocation, just as with a 	 HI16/LO16 pair.  */
name|value
operator|=
name|mips_elf_high
argument_list|(
name|value
argument_list|)
operator|<<
literal|16
expr_stmt|;
block|}
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
name|entry
operator|=
name|mips_elf_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|ibfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
return|return
name|entry
operator|->
name|gotidx
return|;
else|else
return|return
name|MINUS_ONE
return|;
block|}
end_function

begin_comment
comment|/* Returns the offset for the entry at the INDEXth position    in the GOT.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_got_offset_from_index
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd_vma
name|index
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|mips_elf_adjust_gp
argument_list|(
name|output_bfd
argument_list|,
name|g
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
return|return
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|index
operator|-
name|gp
return|;
block|}
end_function

begin_comment
comment|/* Create a local GOT entry for VALUE.  Return the index of the entry,    or -1 if it could not be created.  */
end_comment

begin_function
specifier|static
name|struct
name|mips_got_entry
modifier|*
name|mips_elf_create_local_got_entry
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|mips_got_info
modifier|*
name|gg
parameter_list|,
name|asection
modifier|*
name|sgot
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
name|struct
name|mips_got_entry
name|entry
decl_stmt|,
modifier|*
modifier|*
name|loc
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|entry
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|entry
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|address
operator|=
name|value
expr_stmt|;
name|g
operator|=
name|mips_elf_got_for_ibfd
argument_list|(
name|gg
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|g
operator|=
name|mips_elf_got_for_ibfd
argument_list|(
name|gg
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|loc
condition|)
return|return
operator|*
name|loc
return|;
name|entry
operator|.
name|gotidx
operator|=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|*
name|g
operator|->
name|assigned_gotno
operator|++
expr_stmt|;
operator|*
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
operator|*
name|loc
argument_list|,
operator|&
name|entry
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|assigned_gotno
operator|>=
name|g
operator|->
name|local_gotno
condition|)
block|{
operator|(
operator|*
name|loc
operator|)
operator|->
name|gotidx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We didn't allocate enough space in the GOT.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"not enough GOT space for local GOT entries"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|MIPS_ELF_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
operator|(
name|sgot
operator|->
name|contents
operator|+
name|entry
operator|.
name|gotidx
operator|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|loc
return|;
block|}
end_function

begin_comment
comment|/* Sort the dynamic symbol table so that symbols that need GOT entries    appear towards the end.  This reduces the amount of GOT space    required.  MAX_LOCAL is used to set the number of local symbols    known to be in the dynamic symbol table.  During    _bfd_mips_elf_size_dynamic_sections, this value is 1.  Afterward, the    section symbols are added and the count is higher.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_sort_hash_table
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|long
name|max_local
parameter_list|)
block|{
name|struct
name|mips_elf_hash_sort_data
name|hsd
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hsd
operator|.
name|low
operator|=
name|NULL
expr_stmt|;
name|hsd
operator|.
name|max_unref_got_dynindx
operator|=
name|hsd
operator|.
name|min_got_dynindx
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
comment|/* In the multi-got case, assigned_gotno of the master got_info        indicate the number of entries that aren't referenced in the        primary GOT, but that must have entries because there are        dynamic relocations that reference it.  Since they aren't        referenced, we move them to the end of the GOT, so that they        don't prevent other entries that are referenced from getting        too large offsets.  */
operator|-
operator|(
name|g
operator|->
name|next
condition|?
name|g
operator|->
name|assigned_gotno
else|:
literal|0
operator|)
expr_stmt|;
name|hsd
operator|.
name|max_non_got_dynindx
operator|=
name|max_local
expr_stmt|;
name|mips_elf_link_hash_traverse
argument_list|(
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_table
operator|*
operator|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|)
argument_list|,
name|mips_elf_sort_hash_table_f
argument_list|,
operator|&
name|hsd
argument_list|)
expr_stmt|;
comment|/* There should have been enough room in the symbol table to      accommodate both the GOT and non-GOT symbols.  */
name|BFD_ASSERT
argument_list|(
name|hsd
operator|.
name|max_non_got_dynindx
operator|<=
name|hsd
operator|.
name|min_got_dynindx
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|hsd
operator|.
name|max_unref_got_dynindx
operator|<=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
argument_list|)
expr_stmt|;
comment|/* Now we know which dynamic symbol has the lowest dynamic symbol      table index in the GOT.  */
name|g
operator|->
name|global_gotsym
operator|=
name|hsd
operator|.
name|low
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* If H needs a GOT entry, assign it the highest available dynamic    index.  Otherwise, assign it the lowest available dynamic    index.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_sort_hash_table_f
parameter_list|(
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mips_elf_hash_sort_data
modifier|*
name|hsd
init|=
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Symbols without dynamic symbol table entries aren't interesting      at all.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* Global symbols that need GOT entries that are not explicitly      referenced are marked with got offset 2.  Those that are      referenced get a 1, and those that don't need GOT entries get      -1.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|hsd
operator|->
name|max_unref_got_dynindx
operator|==
name|hsd
operator|->
name|min_got_dynindx
condition|)
name|hsd
operator|->
name|low
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
name|hsd
operator|->
name|max_unref_got_dynindx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|!=
literal|1
condition|)
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
name|hsd
operator|->
name|max_non_got_dynindx
operator|++
expr_stmt|;
else|else
block|{
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
operator|--
name|hsd
operator|->
name|min_got_dynindx
expr_stmt|;
name|hsd
operator|->
name|low
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* If H is a symbol that needs a global GOT entry, but has a dynamic    symbol table index lower than any we've seen to date, record it for    posterity.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_record_global_got_symbol
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|)
block|{
name|struct
name|mips_got_entry
name|entry
decl_stmt|,
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* A global symbol in the GOT must also be in the dynamic symbol      table.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_INTERNAL
case|:
case|case
name|STV_HIDDEN
case|:
name|_bfd_mips_elf_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|entry
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|entry
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* If we've already marked this entry as needing GOT space, we don't      need to do it again.  */
if|if
condition|(
operator|*
name|loc
condition|)
return|return
name|TRUE
return|;
operator|*
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
name|FALSE
return|;
name|entry
operator|.
name|gotidx
operator|=
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|loc
argument_list|,
operator|&
name|entry
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
name|MINUS_ONE
condition|)
return|return
name|TRUE
return|;
comment|/* By setting this to a value other than -1, we are indicating that      there needs to be a GOT entry for H.  Avoid using zero, as the      generic ELF copy_indirect_symbol tests for<= 0.  */
name|h
operator|->
name|got
operator|.
name|offset
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Reserve space in G for a GOT entry containing the value of symbol    SYMNDX in input bfd ABDF, plus ADDEND.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_record_local_got_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|long
name|symndx
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|)
block|{
name|struct
name|mips_got_entry
name|entry
decl_stmt|,
modifier|*
modifier|*
name|loc
decl_stmt|;
name|entry
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|entry
operator|.
name|symndx
operator|=
name|symndx
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|addend
operator|=
name|addend
expr_stmt|;
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|loc
condition|)
return|return
name|TRUE
return|;
name|entry
operator|.
name|gotidx
operator|=
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
operator|*
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
operator|*
name|loc
argument_list|,
operator|&
name|entry
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the hash value of the bfd in a bfd2got hash entry.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|mips_elf_bfd2got_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|entry_
parameter_list|)
block|{
specifier|const
name|struct
name|mips_elf_bfd2got_hash
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
name|entry_
decl_stmt|;
return|return
name|entry
operator|->
name|bfd
operator|->
name|id
return|;
block|}
end_function

begin_comment
comment|/* Check whether two hash entries have the same bfd.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_bfd2got_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|entry1
parameter_list|,
specifier|const
name|void
modifier|*
name|entry2
parameter_list|)
block|{
specifier|const
name|struct
name|mips_elf_bfd2got_hash
modifier|*
name|e1
init|=
operator|(
specifier|const
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
name|entry1
decl_stmt|;
specifier|const
name|struct
name|mips_elf_bfd2got_hash
modifier|*
name|e2
init|=
operator|(
specifier|const
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
name|entry2
decl_stmt|;
return|return
name|e1
operator|->
name|bfd
operator|==
name|e2
operator|->
name|bfd
return|;
block|}
end_function

begin_comment
comment|/* In a multi-got link, determine the GOT to be used for IBDF.  G must    be the master GOT data.  */
end_comment

begin_function
specifier|static
name|struct
name|mips_got_info
modifier|*
name|mips_elf_got_for_ibfd
parameter_list|(
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|)
block|{
name|struct
name|mips_elf_bfd2got_hash
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|g
operator|->
name|bfd2got
condition|)
return|return
name|g
return|;
name|e
operator|.
name|bfd
operator|=
name|ibfd
expr_stmt|;
name|p
operator|=
name|htab_find
argument_list|(
name|g
operator|->
name|bfd2got
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
return|return
name|p
condition|?
name|p
operator|->
name|g
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create one separate got for each bfd that has entries in the global    got, such that we can tell how many local and global entries each    bfd requires.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_make_got_per_bfd
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
operator|*
name|entryp
decl_stmt|;
name|struct
name|mips_elf_got_per_bfd_arg
modifier|*
name|arg
init|=
operator|(
expr|struct
name|mips_elf_got_per_bfd_arg
operator|*
operator|)
name|p
decl_stmt|;
name|htab_t
name|bfd2got
init|=
name|arg
operator|->
name|bfd2got
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_elf_bfd2got_hash
name|bfdgot_entry
decl_stmt|,
modifier|*
name|bfdgot
decl_stmt|;
name|void
modifier|*
modifier|*
name|bfdgotp
decl_stmt|;
comment|/* Find the got_info for this GOT entry's input bfd.  Create one if      none exists.  */
name|bfdgot_entry
operator|.
name|bfd
operator|=
name|entry
operator|->
name|abfd
expr_stmt|;
name|bfdgotp
operator|=
name|htab_find_slot
argument_list|(
name|bfd2got
argument_list|,
operator|&
name|bfdgot_entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|bfdgot
operator|=
operator|(
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
operator|*
name|bfdgotp
expr_stmt|;
if|if
condition|(
name|bfdgot
operator|!=
name|NULL
condition|)
name|g
operator|=
name|bfdgot
operator|->
name|g
expr_stmt|;
else|else
block|{
name|bfdgot
operator|=
operator|(
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|arg
operator|->
name|obfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_bfd2got_hash
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfdgot
operator|==
name|NULL
condition|)
block|{
name|arg
operator|->
name|obfd
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|bfdgotp
operator|=
name|bfdgot
expr_stmt|;
name|bfdgot
operator|->
name|bfd
operator|=
name|entry
operator|->
name|abfd
expr_stmt|;
name|bfdgot
operator|->
name|g
operator|=
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|arg
operator|->
name|obfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_got_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|arg
operator|->
name|obfd
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|g
operator|->
name|global_gotsym
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
operator|-
literal|1
expr_stmt|;
name|g
operator|->
name|got_entries
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|mips_elf_multi_got_entry_hash
argument_list|,
name|mips_elf_multi_got_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|got_entries
operator|==
name|NULL
condition|)
block|{
name|arg
operator|->
name|obfd
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|g
operator|->
name|bfd2got
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Insert the GOT entry in the bfd's got entry hash table.  */
name|entryp
operator|=
name|htab_find_slot
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entryp
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
operator|*
name|entryp
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|>=
literal|0
operator|||
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|forced_local
condition|)
operator|++
name|g
operator|->
name|local_gotno
expr_stmt|;
else|else
operator|++
name|g
operator|->
name|global_gotno
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Attempt to merge gots of different input bfds.  Try to use as much    as possible of the primary got, since it doesn't require explicit    dynamic relocations, but don't use bfds that would reference global    symbols out of the addressable range.  Failing the primary got,    attempt to merge with the current got, or finish the current got    and then make make the new got current.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_merge_gots
parameter_list|(
name|void
modifier|*
modifier|*
name|bfd2got_
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|mips_elf_bfd2got_hash
modifier|*
name|bfd2got
init|=
operator|(
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
operator|*
name|bfd2got_
decl_stmt|;
name|struct
name|mips_elf_got_per_bfd_arg
modifier|*
name|arg
init|=
operator|(
expr|struct
name|mips_elf_got_per_bfd_arg
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|lcount
init|=
name|bfd2got
operator|->
name|g
operator|->
name|local_gotno
decl_stmt|;
name|unsigned
name|int
name|gcount
init|=
name|bfd2got
operator|->
name|g
operator|->
name|global_gotno
decl_stmt|;
name|unsigned
name|int
name|maxcnt
init|=
name|arg
operator|->
name|max_count
decl_stmt|;
comment|/* If we don't have a primary GOT and this is not too big, use it as      a starting point for the primary GOT.  */
if|if
condition|(
operator|!
name|arg
operator|->
name|primary
operator|&&
name|lcount
operator|+
name|gcount
operator|<=
name|maxcnt
condition|)
block|{
name|arg
operator|->
name|primary
operator|=
name|bfd2got
operator|->
name|g
expr_stmt|;
name|arg
operator|->
name|primary_count
operator|=
name|lcount
operator|+
name|gcount
expr_stmt|;
block|}
comment|/* If it looks like we can merge this bfd's entries with those of      the primary, merge them.  The heuristics is conservative, but we      don't have to squeeze it too hard.  */
elseif|else
if|if
condition|(
name|arg
operator|->
name|primary
operator|&&
operator|(
name|arg
operator|->
name|primary_count
operator|+
name|lcount
operator|+
name|gcount
operator|)
operator|<=
name|maxcnt
condition|)
block|{
name|struct
name|mips_got_info
modifier|*
name|g
init|=
name|bfd2got
operator|->
name|g
decl_stmt|;
name|int
name|old_lcount
init|=
name|arg
operator|->
name|primary
operator|->
name|local_gotno
decl_stmt|;
name|int
name|old_gcount
init|=
name|arg
operator|->
name|primary
operator|->
name|global_gotno
decl_stmt|;
name|bfd2got
operator|->
name|g
operator|=
name|arg
operator|->
name|primary
expr_stmt|;
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_make_got_per_bfd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|obfd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|htab_delete
argument_list|(
name|g
operator|->
name|got_entries
argument_list|)
expr_stmt|;
comment|/* We don't have to worry about releasing memory of the actual 	 got entries, since they're all in the master got_entries hash 	 table anyway.  */
name|BFD_ASSERT
argument_list|(
name|old_lcount
operator|+
name|lcount
operator|>=
name|arg
operator|->
name|primary
operator|->
name|local_gotno
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|old_gcount
operator|+
name|gcount
operator|>=
name|arg
operator|->
name|primary
operator|->
name|global_gotno
argument_list|)
expr_stmt|;
name|arg
operator|->
name|primary_count
operator|=
name|arg
operator|->
name|primary
operator|->
name|local_gotno
operator|+
name|arg
operator|->
name|primary
operator|->
name|global_gotno
expr_stmt|;
block|}
comment|/* If we can merge with the last-created got, do it.  */
elseif|else
if|if
condition|(
name|arg
operator|->
name|current
operator|&&
name|arg
operator|->
name|current_count
operator|+
name|lcount
operator|+
name|gcount
operator|<=
name|maxcnt
condition|)
block|{
name|struct
name|mips_got_info
modifier|*
name|g
init|=
name|bfd2got
operator|->
name|g
decl_stmt|;
name|int
name|old_lcount
init|=
name|arg
operator|->
name|current
operator|->
name|local_gotno
decl_stmt|;
name|int
name|old_gcount
init|=
name|arg
operator|->
name|current
operator|->
name|global_gotno
decl_stmt|;
name|bfd2got
operator|->
name|g
operator|=
name|arg
operator|->
name|current
expr_stmt|;
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_make_got_per_bfd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|obfd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|htab_delete
argument_list|(
name|g
operator|->
name|got_entries
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|old_lcount
operator|+
name|lcount
operator|>=
name|arg
operator|->
name|current
operator|->
name|local_gotno
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|old_gcount
operator|+
name|gcount
operator|>=
name|arg
operator|->
name|current
operator|->
name|global_gotno
argument_list|)
expr_stmt|;
name|arg
operator|->
name|current_count
operator|=
name|arg
operator|->
name|current
operator|->
name|local_gotno
operator|+
name|arg
operator|->
name|current
operator|->
name|global_gotno
expr_stmt|;
block|}
comment|/* Well, we couldn't merge, so create a new GOT.  Don't check if it      fits; if it turns out that it doesn't, we'll get relocation      overflows anyway.  */
else|else
block|{
name|bfd2got
operator|->
name|g
operator|->
name|next
operator|=
name|arg
operator|->
name|current
expr_stmt|;
name|arg
operator|->
name|current
operator|=
name|bfd2got
operator|->
name|g
expr_stmt|;
name|arg
operator|->
name|current_count
operator|=
name|lcount
operator|+
name|gcount
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If passed a NULL mips_got_info in the argument, set the marker used    to tell whether a global symbol needs a got entry (in the primary    got) to the given VALUE.     If passed a pointer G to a mips_got_info in the argument (it must    not be the primary GOT), compute the offset from the beginning of    the (primary) GOT section to the entry in G corresponding to the    global symbol.  G's assigned_gotno must contain the index of the    first available global GOT entry in G.  VALUE must contain the size    of a GOT entry in bytes.  For each global GOT entry that requires a    dynamic relocation, NEEDED_RELOCS is incremented, and the symbol is    marked as not eligible for lazy resolution through a function    stub.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_set_global_got_offset
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
operator|*
name|entryp
decl_stmt|;
name|struct
name|mips_elf_set_global_got_offset_arg
modifier|*
name|arg
init|=
operator|(
expr|struct
name|mips_elf_set_global_got_offset_arg
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
init|=
name|arg
operator|->
name|g
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|abfd
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|g
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|global_gotsym
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|entry
operator|->
name|gotidx
operator|=
name|arg
operator|->
name|value
operator|*
operator|(
name|long
operator|)
name|g
operator|->
name|assigned_gotno
operator|++
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|info
operator|->
name|shared
operator|||
operator|(
name|elf_hash_table
argument_list|(
name|arg
operator|->
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
operator|(
operator|(
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
operator|++
name|arg
operator|->
name|needed_relocs
expr_stmt|;
block|}
else|else
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|=
name|arg
operator|->
name|value
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Mark any global symbols referenced in the GOT we are iterating over    as inelligible for lazy resolution stubs.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_set_no_stub
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
operator|*
name|entryp
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|abfd
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|no_fn_stub
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Follow indirect and warning hash entries so that each got entry    points to the final symbol definition.  P must point to a pointer    to the hash table we're traversing.  Since this traversal may    modify the hash table, we set this pointer to NULL to indicate    we've made a potentially-destructive change to the hash table, so    the traversal must be restarted.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_resolve_final_got_entry
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
operator|*
name|entryp
decl_stmt|;
name|htab_t
name|got_entries
init|=
operator|*
operator|(
name|htab_t
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|abfd
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
init|=
name|entry
operator|->
name|d
operator|.
name|h
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d
operator|.
name|h
operator|==
name|h
condition|)
return|return
literal|1
return|;
name|entry
operator|->
name|d
operator|.
name|h
operator|=
name|h
expr_stmt|;
comment|/* If we can't find this entry with the new bfd hash, re-insert 	 it, and get the traversal restarted.  */
if|if
condition|(
operator|!
name|htab_find
argument_list|(
name|got_entries
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|htab_clear_slot
argument_list|(
name|got_entries
argument_list|,
name|entryp
argument_list|)
expr_stmt|;
name|entryp
operator|=
name|htab_find_slot
argument_list|(
name|got_entries
argument_list|,
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|entryp
condition|)
operator|*
name|entryp
operator|=
name|entry
expr_stmt|;
comment|/* Abort the traversal, since the whole table may have 	     moved, and leave it up to the parent to restart the 	     process.  */
operator|*
operator|(
name|htab_t
operator|*
operator|)
name|p
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We might want to decrement the global_gotno count, but it's 	 either too early or too late for that at this point.  */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Turn indirect got entries in a got_entries table into their final    locations.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_resolve_final_got_entries
parameter_list|(
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|)
block|{
name|htab_t
name|got_entries
decl_stmt|;
do|do
block|{
name|got_entries
operator|=
name|g
operator|->
name|got_entries
expr_stmt|;
name|htab_traverse
argument_list|(
name|got_entries
argument_list|,
name|mips_elf_resolve_final_got_entry
argument_list|,
operator|&
name|got_entries
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|got_entries
operator|==
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Return the offset of an input bfd IBFD's GOT from the beginning of    the primary GOT.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_adjust_gp
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|)
block|{
if|if
condition|(
name|g
operator|->
name|bfd2got
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|g
operator|=
name|mips_elf_got_for_ibfd
argument_list|(
name|g
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g
condition|)
return|return
literal|0
return|;
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|next
argument_list|)
expr_stmt|;
name|g
operator|=
name|g
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|g
operator|->
name|local_gotno
operator|+
name|g
operator|->
name|global_gotno
operator|)
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Turn a single GOT that is too big for 16-bit addressing into    a sequence of GOTs, each one 16-bit addressable.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_multi_got
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|,
name|asection
modifier|*
name|got
parameter_list|,
name|bfd_size_type
name|pages
parameter_list|)
block|{
name|struct
name|mips_elf_got_per_bfd_arg
name|got_per_bfd_arg
decl_stmt|;
name|struct
name|mips_elf_set_global_got_offset_arg
name|set_got_offset_arg
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|gg
decl_stmt|;
name|unsigned
name|int
name|assign
decl_stmt|;
name|g
operator|->
name|bfd2got
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|mips_elf_bfd2got_entry_hash
argument_list|,
name|mips_elf_bfd2got_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|bfd2got
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|got_per_bfd_arg
operator|.
name|bfd2got
operator|=
name|g
operator|->
name|bfd2got
expr_stmt|;
name|got_per_bfd_arg
operator|.
name|obfd
operator|=
name|abfd
expr_stmt|;
name|got_per_bfd_arg
operator|.
name|info
operator|=
name|info
expr_stmt|;
comment|/* Count how many GOT entries each input bfd requires, creating a      map from bfd to got info while at that.  */
name|mips_elf_resolve_final_got_entries
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_make_got_per_bfd
argument_list|,
operator|&
name|got_per_bfd_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_per_bfd_arg
operator|.
name|obfd
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|got_per_bfd_arg
operator|.
name|current
operator|=
name|NULL
expr_stmt|;
name|got_per_bfd_arg
operator|.
name|primary
operator|=
name|NULL
expr_stmt|;
comment|/* Taking out PAGES entries is a worst-case estimate.  We could      compute the maximum number of pages that each separate input bfd      uses, but it's probably not worth it.  */
name|got_per_bfd_arg
operator|.
name|max_count
operator|=
operator|(
operator|(
name|MIPS_ELF_GOT_MAX_SIZE
argument_list|(
name|abfd
argument_list|)
operator|/
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|)
operator|-
name|MIPS_RESERVED_GOTNO
operator|-
name|pages
operator|)
expr_stmt|;
comment|/* Try to merge the GOTs of input bfds together, as long as they      don't seem to exceed the maximum GOT size, choosing one of them      to be the primary GOT.  */
name|htab_traverse
argument_list|(
name|g
operator|->
name|bfd2got
argument_list|,
name|mips_elf_merge_gots
argument_list|,
operator|&
name|got_per_bfd_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_per_bfd_arg
operator|.
name|obfd
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* If we find any suitable primary GOT, create an empty one.  */
if|if
condition|(
name|got_per_bfd_arg
operator|.
name|primary
operator|==
name|NULL
condition|)
block|{
name|g
operator|->
name|next
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_got_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|next
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|g
operator|->
name|next
operator|->
name|global_gotsym
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|global_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|local_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|assigned_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|got_entries
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|mips_elf_multi_got_entry_hash
argument_list|,
name|mips_elf_multi_got_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|next
operator|->
name|got_entries
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|g
operator|->
name|next
operator|->
name|bfd2got
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|g
operator|->
name|next
operator|=
name|got_per_bfd_arg
operator|.
name|primary
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|next
operator|=
name|got_per_bfd_arg
operator|.
name|current
expr_stmt|;
comment|/* GG is now the master GOT, and G is the primary GOT.  */
name|gg
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|g
operator|->
name|next
expr_stmt|;
comment|/* Map the output bfd to the primary got.  That's what we're going      to use for bfds that use GOT16 or GOT_PAGE relocations that we      didn't mark in check_relocs, and we want a quick way to find it.      We can't just use gg->next because we're going to reverse the      list.  */
block|{
name|struct
name|mips_elf_bfd2got_hash
modifier|*
name|bfdgot
decl_stmt|;
name|void
modifier|*
modifier|*
name|bfdgotp
decl_stmt|;
name|bfdgot
operator|=
operator|(
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_bfd2got_hash
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfdgot
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|bfdgot
operator|->
name|bfd
operator|=
name|abfd
expr_stmt|;
name|bfdgot
operator|->
name|g
operator|=
name|g
expr_stmt|;
name|bfdgotp
operator|=
name|htab_find_slot
argument_list|(
name|gg
operator|->
name|bfd2got
argument_list|,
name|bfdgot
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|*
name|bfdgotp
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|bfdgotp
operator|=
name|bfdgot
expr_stmt|;
block|}
comment|/* The IRIX dynamic linker requires every symbol that is referenced      in a dynamic relocation to be present in the primary GOT, so      arrange for them to appear after those that are actually      referenced.       GNU/Linux could very well do without it, but it would slow down      the dynamic linker, since it would have to resolve every dynamic      symbol referenced in other GOTs more than once, without help from      the cache.  Also, knowing that every external symbol has a GOT      helps speed up the resolution of local symbols too, so GNU/Linux      follows IRIX's practice.       The number 2 is used by mips_elf_sort_hash_table_f to count      global GOT symbols that are unreferenced in the primary GOT, with      an initial dynamic index computed from gg->assigned_gotno, where      the number of unreferenced global entries in the primary GOT is      preserved.  */
if|if
condition|(
literal|1
condition|)
block|{
name|gg
operator|->
name|assigned_gotno
operator|=
name|gg
operator|->
name|global_gotno
operator|-
name|g
operator|->
name|global_gotno
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
name|gg
operator|->
name|global_gotno
expr_stmt|;
name|set_got_offset_arg
operator|.
name|value
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* This could be used for dynamic linkers that don't optimize 	 symbol resolution while applying relocations so as to use 	 primary GOT entries or assuming the symbol is locally-defined. 	 With this code, we assign lower dynamic indices to global 	 symbols that are not referenced in the primary GOT, so that 	 their entries can be omitted.  */
name|gg
operator|->
name|assigned_gotno
operator|=
literal|0
expr_stmt|;
name|set_got_offset_arg
operator|.
name|value
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Reorder dynamic symbols as described above (which behavior      depends on the setting of VALUE).  */
name|set_got_offset_arg
operator|.
name|g
operator|=
name|NULL
expr_stmt|;
name|htab_traverse
argument_list|(
name|gg
operator|->
name|got_entries
argument_list|,
name|mips_elf_set_global_got_offset
argument_list|,
operator|&
name|set_got_offset_arg
argument_list|)
expr_stmt|;
name|set_got_offset_arg
operator|.
name|value
operator|=
literal|1
expr_stmt|;
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_set_global_got_offset
argument_list|,
operator|&
name|set_got_offset_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_sort_hash_table
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Now go through the GOTs assigning them offset ranges.      [assigned_gotno, local_gotno[ will be set to the range of local      entries in each GOT.  We can then compute the end of a GOT by      adding local_gotno to global_gotno.  We reverse the list and make      it circular since then we'll be able to quickly compute the      beginning of a GOT, by computing the end of its predecessor.  To      avoid special cases for the primary GOT, while still preserving      assertions that are valid for both single- and multi-got links,      we arrange for the main got struct to have the right number of      global entries, but set its local_gotno such that the initial      offset of the primary GOT is zero.  Remember that the primary GOT      will become the last item in the circular linked list, so it      points back to the master GOT.  */
name|gg
operator|->
name|local_gotno
operator|=
operator|-
name|g
operator|->
name|global_gotno
expr_stmt|;
name|gg
operator|->
name|global_gotno
operator|=
name|g
operator|->
name|global_gotno
expr_stmt|;
name|assign
operator|=
literal|0
expr_stmt|;
name|gg
operator|->
name|next
operator|=
name|gg
expr_stmt|;
do|do
block|{
name|struct
name|mips_got_info
modifier|*
name|gn
decl_stmt|;
name|assign
operator|+=
name|MIPS_RESERVED_GOTNO
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|assign
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|+=
name|assign
operator|+
name|pages
expr_stmt|;
name|assign
operator|=
name|g
operator|->
name|local_gotno
operator|+
name|g
operator|->
name|global_gotno
expr_stmt|;
comment|/* Take g out of the direct list, and push it onto the reversed 	 list that gg points to.  */
name|gn
operator|=
name|g
operator|->
name|next
expr_stmt|;
name|g
operator|->
name|next
operator|=
name|gg
operator|->
name|next
expr_stmt|;
name|gg
operator|->
name|next
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|gn
expr_stmt|;
comment|/* Mark global symbols in every non-primary GOT as ineligible for 	 stubs.  */
if|if
condition|(
name|g
condition|)
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_set_no_stub
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|g
condition|)
do|;
name|got
operator|->
name|_raw_size
operator|=
operator|(
name|gg
operator|->
name|next
operator|->
name|local_gotno
operator|+
name|gg
operator|->
name|next
operator|->
name|global_gotno
operator|)
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the first relocation of type r_type found, beginning with    RELOCATION.  RELEND is one-past-the-end of the relocation table.  */
end_comment

begin_function
specifier|static
specifier|const
name|Elf_Internal_Rela
modifier|*
name|mips_elf_next_relocation
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|r_type
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
parameter_list|)
block|{
comment|/* According to the MIPS ELF ABI, the R_MIPS_LO16 relocation must be      immediately following.  However, for the IRIX6 ABI, the next      relocation may be a composed relocation consisting of several      relocations for the same address.  In that case, the R_MIPS_LO16      relocation may occur as one of these.  We permit a similar      extension in general, as that is useful for GCC.  */
while|while
condition|(
name|relocation
operator|<
name|relend
condition|)
block|{
if|if
condition|(
name|ELF_R_TYPE
argument_list|(
name|abfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
operator|==
name|r_type
condition|)
return|return
name|relocation
return|;
operator|++
name|relocation
expr_stmt|;
block|}
comment|/* We didn't find it.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return whether a relocation is against a local symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_local_relocation_p
parameter_list|(
name|bfd
modifier|*
name|input_bfd
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|,
name|bfd_boolean
name|check_forced
parameter_list|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|input_bfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|local_sections
index|[
name|r_symndx
index|]
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|check_forced
condition|)
block|{
comment|/* Look up the hash table to check whether the symbol  	 was forced local.  */
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* Find the real hash-table entry for this symbol.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sign-extend VALUE, which has the indicated number of BITS.  */
end_comment

begin_function
name|bfd_vma
name|_bfd_mips_elf_sign_extend
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
if|if
condition|(
name|value
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|)
comment|/* VALUE is negative.  */
name|value
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bits
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the indicated VALUE has overflowed the maximum    range expressible by a signed number with the indicated number of    BITS.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_overflow_p
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|bfd_signed_vma
name|svalue
init|=
operator|(
name|bfd_signed_vma
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|svalue
operator|>
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
condition|)
comment|/* The value is too big.  */
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
name|svalue
operator|<
operator|-
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|)
comment|/* The value is too small.  */
return|return
name|TRUE
return|;
comment|/* All is well.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Calculate the %high function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_high
parameter_list|(
name|bfd_vma
name|value
parameter_list|)
block|{
return|return
operator|(
operator|(
name|value
operator|+
operator|(
name|bfd_vma
operator|)
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/* Calculate the %higher function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_higher
parameter_list|(
name|bfd_vma
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
return|return
operator|(
operator|(
name|value
operator|+
operator|(
name|bfd_vma
operator|)
literal|0x80008000
operator|)
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Calculate the %highest function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_highest
parameter_list|(
name|bfd_vma
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
return|return
operator|(
operator|(
name|value
operator|+
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|0x8000
operator|<<
literal|32
operator|)
operator||
literal|0x80008000
operator|)
operator|)
operator|>>
literal|48
operator|)
operator|&
literal|0xffff
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the .compact_rel section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_create_compact_rel_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".compact_rel"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".compact_rel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create the .got section to hold the global offset table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_create_got_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|maybe_exclude
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* This function may be called more than once.  */
name|s
operator|=
name|mips_elf_got_section
argument_list|(
name|abfd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|maybe_exclude
condition|)
name|s
operator|->
name|flags
operator|&=
operator|~
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
name|maybe_exclude
condition|)
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
comment|/* We have to use an alignment of 2**4 here because this is hardcoded      in the function stub generation and in the linker script.  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the      linker script because we don't want to define the symbol if we      are not creating a global offset table.  */
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mips_got_info
argument_list|)
expr_stmt|;
name|g
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|g
operator|->
name|global_gotsym
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|=
name|MIPS_RESERVED_GOTNO
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|MIPS_RESERVED_GOTNO
expr_stmt|;
name|g
operator|->
name|bfd2got
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|got_entries
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|mips_elf_got_entry_hash
argument_list|,
name|mips_elf_got_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|got_entries
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|mips_elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|u
operator|.
name|got_info
operator|=
name|g
expr_stmt|;
name|mips_elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|elf
operator|.
name|this_hdr
operator|.
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the value produced by the RELOCATION (which comes from    the INPUT_BFD).  The ADDEND is the addend to use for this    RELOCATION; RELOCATION->R_ADDEND is ignored.     The result of the relocation calculation is stored in VALUEP.    REQUIRE_JALXP indicates whether or not the opcode used with this    relocation must be JALX.     This function returns bfd_reloc_continue if the caller need take no    further action regarding this relocation, bfd_reloc_notsupported if    something goes dramatically wrong, bfd_reloc_overflow if an    overflow occurs, and bfd_reloc_ok to indicate success.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_elf_calculate_relocation
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|,
name|bfd_vma
modifier|*
name|valuep
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|bfd_boolean
modifier|*
name|require_jalxp
parameter_list|,
name|bfd_boolean
name|save_addend
parameter_list|)
block|{
comment|/* The eventual value we will return.  */
name|bfd_vma
name|value
decl_stmt|;
comment|/* The address of the symbol against which the relocation is      occurring.  */
name|bfd_vma
name|symbol
init|=
literal|0
decl_stmt|;
comment|/* The final GP value to be used for the relocatable, executable, or      shared object file being produced.  */
name|bfd_vma
name|gp
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* The place (section offset or address) of the storage unit being      relocated.  */
name|bfd_vma
name|p
decl_stmt|;
comment|/* The value of GP used to create the relocatable object.  */
name|bfd_vma
name|gp0
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* The offset into the global offset table at which the address of      the relocation entry symbol, adjusted by the addend, resides      during execution.  */
name|bfd_vma
name|g
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* The section in which the symbol referenced by the relocation is      located.  */
name|asection
modifier|*
name|sec
init|=
name|NULL
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
comment|/* TRUE if the symbol referred to by this relocation is a local      symbol.  */
name|bfd_boolean
name|local_p
decl_stmt|,
name|was_local_p
decl_stmt|;
comment|/* TRUE if the symbol referred to by this relocation is "_gp_disp".  */
name|bfd_boolean
name|gp_disp_p
init|=
name|FALSE
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|int
name|r_type
decl_stmt|;
comment|/* TRUE if overflow occurred during the calculation of the      relocation value.  */
name|bfd_boolean
name|overflowed_p
decl_stmt|;
comment|/* TRUE if this relocation refers to a MIPS16 function.  */
name|bfd_boolean
name|target_is_16_bit_code_p
init|=
name|FALSE
decl_stmt|;
comment|/* Parse the relocation.  */
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|input_bfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF_R_TYPE
argument_list|(
name|input_bfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|relocation
operator|->
name|r_offset
operator|)
expr_stmt|;
comment|/* Assume that there will be no overflow.  */
name|overflowed_p
operator|=
name|FALSE
expr_stmt|;
comment|/* Figure out whether or not the symbol is local, and get the offset      used in the array of hash table entries.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|local_p
operator|=
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|was_local_p
operator|=
name|local_p
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
else|else
block|{
comment|/* The symbol table does not follow the rule that local symbols 	 must come before globals.  */
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Figure out the value of the symbol.  */
if|if
condition|(
name|local_p
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
condition|)
name|symbol
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|addend
operator|=
name|_bfd_elf_rel_local_sym
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|addend
operator|-=
name|symbol
expr_stmt|;
name|addend
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* MIPS16 text labels should be treated as odd.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
operator|++
name|symbol
expr_stmt|;
comment|/* Record the name of this symbol, for our caller.  */
operator|*
name|namep
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|namep
operator|==
literal|'\0'
condition|)
operator|*
name|namep
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|target_is_16_bit_code_p
operator|=
operator|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Could we use RELOC_FOR_GLOBAL_SYMBOL here ?  */
comment|/* For global symbols we look up the symbol in the hash-table.  */
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* Find the real hash-table entry for this symbol.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Record the name of this symbol, for our caller.  */
operator|*
name|namep
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
comment|/* See if this is the special _gp_disp symbol.  Note that such a 	 symbol must always be a global symbol.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Relocations against _gp_disp are permitted only with 	     R_MIPS_HI16 and R_MIPS_LO16 relocations.  */
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS_HI16
operator|&&
name|r_type
operator|!=
name|R_MIPS_LO16
condition|)
return|return
name|bfd_reloc_notsupported
return|;
name|gp_disp_p
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If this symbol is defined, calculate its address.  Note that 	 _gp_disp is a magic symbol, always implicitly defined by the 	 linker, so it's inappropriate to check to see whether or not 	 its defined.  */
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
condition|)
name|symbol
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
name|symbol
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
comment|/* We allow relocations against undefined weak symbols, giving 	   it the value zero, so that you can undefined weak functions 	   and check to see if they exist by looking at their 	   addresses.  */
name|symbol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_IGNORE
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|symbol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"_DYNAMIC_LINKING"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If this is a dynamic link, we should have created a 	     _DYNAMIC_LINK symbol or _DYNAMIC_LINKING(for normal mips) symbol 	     in in _bfd_mips_elf_create_dynamic_sections. 	     Otherwise, we should define the symbol with a value of 0. 	     FIXME: It should probably get into the symbol table 	     somehow as well.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|symbol
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|relocation
operator|->
name|r_offset
argument_list|,
operator|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_ERROR
operator|)
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
name|symbol
operator|=
literal|0
expr_stmt|;
block|}
name|target_is_16_bit_code_p
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
operator|)
expr_stmt|;
block|}
comment|/* If this is a 32- or 64-bit call to a 16-bit function with a stub, we      need to redirect the call to the stub, unless we're already *in*      a stub.  */
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS16_26
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|(
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|fn_stub
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|local_p
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
operator|!=
name|NULL
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|!
name|mips_elf_stub_section_p
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
condition|)
block|{
comment|/* This is a 32- or 64-bit call to a 16-bit function.  We should 	 have already noticed that we were going to need the 	 stub.  */
if|if
condition|(
name|local_p
condition|)
name|sec
operator|=
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|need_fn_stub
argument_list|)
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|fn_stub
expr_stmt|;
block|}
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* If this is a 16-bit call to a 32- or 64-bit function with a stub, we      need to redirect the call to the stub.  */
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|||
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|target_is_16_bit_code_p
condition|)
block|{
comment|/* If both call_stub and call_fp_stub are defined, we can figure 	 out which one to use by seeing which one appears in the input 	 file.  */
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|call_fp_stub
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|sec
operator|=
name|h
operator|->
name|call_stub
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
condition|)
name|sec
operator|=
name|h
operator|->
name|call_stub
expr_stmt|;
else|else
name|sec
operator|=
name|h
operator|->
name|call_fp_stub
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|->
name|_raw_size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* Calls from 16-bit code to 32-bit code and vice versa require the      special jalx instruction.  */
operator|*
name|require_jalxp
operator|=
operator|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|(
operator|(
operator|(
name|r_type
operator|==
name|R_MIPS16_26
operator|)
operator|&&
operator|!
name|target_is_16_bit_code_p
operator|)
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_MIPS_26
operator|)
operator|&&
name|target_is_16_bit_code_p
operator|)
operator|)
operator|)
expr_stmt|;
name|local_p
operator|=
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* If we haven't already determined the GOT offset, or the GP value,      and we're going to need it, get it now.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_GOT_PAGE
case|:
case|case
name|R_MIPS_GOT_OFST
case|:
comment|/* We need to decay to GOT_DISP/addend if the symbol doesn't 	 bind locally.  */
name|local_p
operator|=
name|local_p
operator|||
name|_bfd_elf_symbol_refs_local_p
argument_list|(
operator|&
name|h
operator|->
name|root
argument_list|,
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_p
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_OFST
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
comment|/* Find the index into the GOT where this value is located.  */
if|if
condition|(
operator|!
name|local_p
condition|)
block|{
comment|/* GOT_PAGE may take a non-zero addend, that is ignored in a 	     GOT_PAGE relocation that decays to GOT_DISP because the 	     symbol turns out to be global.  The addend is then added 	     as GOT_OFST.  */
name|BFD_ASSERT
argument_list|(
name|addend
operator|==
literal|0
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_PAGE
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_global_got_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|input_bfd
argument_list|,
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is a static link or a -Bsymbolic link.  The 		 symbol is defined locally, or was forced to be local. 		 We must initialize this entry in the GOT.  */
name|bfd
modifier|*
name|tmpbfd
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
init|=
name|mips_elf_got_section
argument_list|(
name|tmpbfd
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|tmpbfd
argument_list|,
name|symbol
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|g
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_GOT16
operator|||
name|r_type
operator|==
name|R_MIPS_CALL16
condition|)
comment|/* There's no need to create a local GOT entry here; the 	   calculation for a local GOT16 entry does not involve G.  */
break|break;
else|else
block|{
name|g
operator|=
name|mips_elf_local_got_index
argument_list|(
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|MINUS_ONE
condition|)
return|return
name|bfd_reloc_outofrange
return|;
block|}
comment|/* Convert GOT indices to actual offsets.  */
name|g
operator|=
name|mips_elf_got_offset_from_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|g
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_HI16
case|:
case|case
name|R_MIPS_LO16
case|:
case|case
name|R_MIPS16_GPREL
case|:
case|case
name|R_MIPS_GPREL16
case|:
case|case
name|R_MIPS_GPREL32
case|:
case|case
name|R_MIPS_LITERAL
case|:
name|gp0
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
condition|)
name|gp
operator|+=
name|mips_elf_adjust_gp
argument_list|(
name|abfd
argument_list|,
name|mips_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Figure out what kind of relocation is being performed.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_NONE
case|:
return|return
name|bfd_reloc_continue
return|;
case|case
name|R_MIPS_16
case|:
name|value
operator|=
name|symbol
operator|+
name|_bfd_mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If we're creating a shared library, or this relocation is 	     against a symbol in a shared library, then we can't know 	     where the symbol will end up.  So, we create a relocation 	     record in the output, and leave the job up to the dynamic 	     linker.  */
name|value
operator|=
name|addend
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_create_dynamic_relocation
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|relocation
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|symbol
argument_list|,
operator|&
name|value
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
block|}
else|else
block|{
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS_REL32
condition|)
name|value
operator|=
name|symbol
operator|+
name|addend
expr_stmt|;
else|else
name|value
operator|=
name|addend
expr_stmt|;
block|}
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_PC32
case|:
case|case
name|R_MIPS_PC64
case|:
case|case
name|R_MIPS_GNU_REL_LO16
case|:
name|value
operator|=
name|symbol
operator|+
name|addend
operator|-
name|p
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GNU_REL16_S2
case|:
name|value
operator|=
name|symbol
operator|+
name|_bfd_mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|18
argument_list|)
operator|-
name|p
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|>>
literal|2
operator|)
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GNU_REL_HI16
case|:
comment|/* Instead of subtracting 'p' here, we should be subtracting the 	 equivalent value for the LO part of the reloc, since the value 	 here is relative to that address.  Because that's not easy to do, 	 we adjust 'addend' in _bfd_mips_elf_relocate_section().  See also 	 the comment there for more information.  */
name|value
operator|=
name|mips_elf_high
argument_list|(
name|addend
operator|+
name|symbol
operator|-
name|p
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS16_26
case|:
comment|/* The calculation for R_MIPS16_26 is just the same as for an 	 R_MIPS_26.  It's only the storage of the relocated field into 	 the output file that's different.  That's handled in 	 mips_elf_perform_relocation.  So, we just fall through to the 	 R_MIPS_26 case here.  */
case|case
name|R_MIPS_26
case|:
if|if
condition|(
name|local_p
condition|)
name|value
operator|=
operator|(
operator|(
name|addend
operator||
operator|(
operator|(
name|p
operator|+
literal|4
operator|)
operator|&
literal|0xf0000000
operator|)
operator|)
operator|+
name|symbol
operator|)
operator|>>
literal|2
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|_bfd_mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|28
argument_list|)
operator|+
name|symbol
operator|)
operator|>>
literal|2
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HI16
case|:
if|if
condition|(
operator|!
name|gp_disp_p
condition|)
block|{
name|value
operator|=
name|mips_elf_high
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|mips_elf_high
argument_list|(
name|addend
operator|+
name|gp
operator|-
name|p
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_MIPS_LO16
case|:
if|if
condition|(
operator|!
name|gp_disp_p
condition|)
name|value
operator|=
operator|(
name|symbol
operator|+
name|addend
operator|)
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
else|else
block|{
name|value
operator|=
name|addend
operator|+
name|gp
operator|-
name|p
operator|+
literal|4
expr_stmt|;
comment|/* The MIPS ABI requires checking the R_MIPS_LO16 relocation 	     for overflow.  But, on, say, IRIX5, relocations against 	     _gp_disp are normally generated from the .cpload 	     pseudo-op.  It generates code that normally looks like 	     this:  	       lui    $gp,%hi(_gp_disp) 	       addiu  $gp,$gp,%lo(_gp_disp) 	       addu   $gp,$gp,$t9  	     Here $t9 holds the address of the function being called, 	     as required by the MIPS ELF ABI.  The R_MIPS_LO16 	     relocation can easily overflow in this situation, but the 	     R_MIPS_HI16 relocation will handle the overflow. 	     Therefore, we consider this a bug in the MIPS ABI, and do 	     not check for overflow here.  */
block|}
break|break;
case|case
name|R_MIPS_LITERAL
case|:
comment|/* Because we don't merge literal sections, we can handle this 	 just like R_MIPS_GPREL16.  In the long run, we should merge 	 shared literals, and then we will need to additional work 	 here.  */
comment|/* Fall through.  */
case|case
name|R_MIPS16_GPREL
case|:
comment|/* The R_MIPS16_GPREL performs the same calculation as 	 R_MIPS_GPREL16, but stores the relocated bits in a different 	 order.  We don't need to do anything special here; the 	 differences are handled in mips_elf_perform_relocation.  */
case|case
name|R_MIPS_GPREL16
case|:
comment|/* Only sign-extend the addend if it was extracted from the 	 instruction.  If the addend was separate, leave it alone, 	 otherwise we may lose significant bits.  */
if|if
condition|(
name|howto
operator|->
name|partial_inplace
condition|)
name|addend
operator|=
name|_bfd_mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|value
operator|=
name|symbol
operator|+
name|addend
operator|-
name|gp
expr_stmt|;
comment|/* If the symbol was local, any earlier relocatable links will 	 have adjusted its addend with the gp offset, so compensate 	 for that now.  Don't do it for symbols forced local in this 	 link, though, since they won't have had the gp offset applied 	 to them before.  */
if|if
condition|(
name|was_local_p
condition|)
name|value
operator|+=
name|gp0
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_CALL16
case|:
if|if
condition|(
name|local_p
condition|)
block|{
name|bfd_boolean
name|forced
decl_stmt|;
comment|/* The special case is when the symbol is forced to be local.  We 	     need the full address in the GOT since no R_MIPS_LO16 relocation 	     follows.  */
name|forced
operator|=
operator|!
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|value
operator|=
name|mips_elf_got16_entry
argument_list|(
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|forced
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|MINUS_ONE
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|value
operator|=
name|mips_elf_got_offset_from_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|R_MIPS_GOT_DISP
case|:
name|got_disp
label|:
name|value
operator|=
name|g
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GPREL32
case|:
name|value
operator|=
operator|(
name|addend
operator|+
name|symbol
operator|+
name|gp0
operator|-
name|gp
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|save_addend
condition|)
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_PC16
case|:
name|value
operator|=
name|_bfd_mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
operator|+
name|symbol
operator|-
name|p
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
comment|/* We're allowed to handle these two relocations identically. 	 The dynamic linker is allowed to handle the CALL relocations 	 differently by creating a lazy evaluation stub.  */
name|value
operator|=
name|g
expr_stmt|;
name|value
operator|=
name|mips_elf_high
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
name|value
operator|=
name|g
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_PAGE
case|:
comment|/* GOT_PAGE relocations that reference non-local symbols decay 	 to GOT_DISP.  The corresponding GOT_OFST relocation decays to 	 0.  */
if|if
condition|(
operator|!
name|local_p
condition|)
goto|goto
name|got_disp
goto|;
name|value
operator|=
name|mips_elf_got_page
argument_list|(
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|MINUS_ONE
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|value
operator|=
name|mips_elf_got_offset_from_index
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_OFST
case|:
if|if
condition|(
name|local_p
condition|)
name|mips_elf_got_page
argument_list|(
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|addend
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_SUB
case|:
name|value
operator|=
name|symbol
operator|-
name|addend
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HIGHER
case|:
name|value
operator|=
name|mips_elf_higher
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HIGHEST
case|:
name|value
operator|=
name|mips_elf_highest
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_SCN_DISP
case|:
name|value
operator|=
name|symbol
operator|+
name|addend
operator|-
name|sec
operator|->
name|output_offset
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_PJUMP
case|:
case|case
name|R_MIPS_JALR
case|:
comment|/* Both of these may be ignored.  R_MIPS_JALR is an optimization 	 hint; we could improve performance by honoring that hint.  */
return|return
name|bfd_reloc_continue
return|;
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
case|case
name|R_MIPS_GNU_VTENTRY
case|:
comment|/* We don't do anything with these at present.  */
return|return
name|bfd_reloc_continue
return|;
default|default:
comment|/* An unrecognized relocation type.  */
return|return
name|bfd_reloc_notsupported
return|;
block|}
comment|/* Store the VALUE for our caller.  */
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
return|return
name|overflowed_p
condition|?
name|bfd_reloc_overflow
else|:
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Obtain the field relocated by RELOCATION.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_obtain_contents
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|bfd_byte
modifier|*
name|location
init|=
name|contents
operator|+
name|relocation
operator|->
name|r_offset
decl_stmt|;
comment|/* Obtain the bytes.  */
name|x
operator|=
name|bfd_get
argument_list|(
operator|(
literal|8
operator|*
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
operator|)
argument_list|,
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ELF_R_TYPE
argument_list|(
name|input_bfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
operator|==
name|R_MIPS16_26
operator|||
name|ELF_R_TYPE
argument_list|(
name|input_bfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
operator|==
name|R_MIPS16_GPREL
operator|)
operator|&&
name|bfd_little_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
comment|/* The two 16-bit words will be reversed on a little-endian system.        See mips_elf_perform_relocation for more details.  */
name|x
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* It has been determined that the result of the RELOCATION is the    VALUE.  Use HOWTO to place VALUE into the output file at the    appropriate position.  The SECTION is the section to which the    relocation applies.  If REQUIRE_JALX is TRUE, then the opcode used    for the relocation must be either JAL or JALX, and it is    unconditionally converted to JALX.     Returns FALSE if anything goes wrong.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_perform_relocation
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_boolean
name|require_jalx
parameter_list|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|bfd_byte
modifier|*
name|location
decl_stmt|;
name|int
name|r_type
init|=
name|ELF_R_TYPE
argument_list|(
name|input_bfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
decl_stmt|;
comment|/* Figure out where the relocation is occurring.  */
name|location
operator|=
name|contents
operator|+
name|relocation
operator|->
name|r_offset
expr_stmt|;
comment|/* Obtain the current value.  */
name|x
operator|=
name|mips_elf_obtain_contents
argument_list|(
name|howto
argument_list|,
name|relocation
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
comment|/* Clear the field we are setting.  */
name|x
operator|&=
operator|~
name|howto
operator|->
name|dst_mask
expr_stmt|;
comment|/* If this is the R_MIPS16_26 relocation, we must store the      value in a funny way.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
block|{
comment|/* R_MIPS16_26 is used for the mips16 jal and jalx instructions. 	 Most mips16 instructions are 16 bits, but these instructions 	 are 32 bits.  	 The format of these instructions is:  	 +--------------+--------------------------------+ 	 !     JALX     ! X!   Imm 20:16  !   Imm 25:21  ! 	 +--------------+--------------------------------+ 	 !	  	  Immediate  15:0		    ! 	 +-----------------------------------------------+  	 JALX is the 5-bit value 00011.  X is 0 for jal, 1 for jalx. 	 Note that the immediate value in the first word is swapped.  	 When producing a relocatable object file, R_MIPS16_26 is 	 handled mostly like R_MIPS_26.  In particular, the addend is 	 stored as a straight 26-bit value in a 32-bit instruction. 	 (gas makes life simpler for itself by never adjusting a 	 R_MIPS16_26 reloc to be against a section, so the addend is 	 always zero).  However, the 32 bit instruction is stored as 2 	 16-bit values, rather than a single 32-bit value.  In a 	 big-endian file, the result is the same; in a little-endian 	 file, the two 16-bit halves of the 32 bit value are swapped. 	 This is so that a disassembler can recognize the jal 	 instruction.  	 When doing a final link, R_MIPS16_26 is treated as a 32 bit 	 instruction stored as two 16-bit values.  The addend A is the 	 contents of the targ26 field.  The calculation is the same as 	 R_MIPS_26.  When storing the calculated value, reorder the 	 immediate value as shown above, and don't forget to store the 	 value as two 16-bit values.  	 To put it in MIPS ABI terms, the relocation field is T-targ26-16, 	 defined as  	 big-endian: 	 +--------+----------------------+ 	 |        |                      | 	 |        |    targ26-16         | 	 |31    26|25                   0| 	 +--------+----------------------+  	 little-endian: 	 +----------+------+-------------+ 	 |          |      |             | 	 |  sub1    |      |     sub2    | 	 |0        9|10  15|16         31| 	 +----------+--------------------+ 	 where targ26-16 is sub1 followed by sub2 (i.e., the addend field A is 	 ((sub1<< 16) | sub2)).  	 When producing a relocatable object file, the calculation is 	 (((A< 2) | ((P + 4)& 0xf0000000) + S)>> 2) 	 When producing a fully linked file, the calculation is 	 let R = (((A< 2) | ((P + 4)& 0xf0000000) + S)>> 2) 	 ((R& 0x1f0000)<< 5) | ((R& 0x3e00000)>> 5) | (R& 0xffff)  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
comment|/* Shuffle the bits according to the formula above.  */
name|value
operator|=
operator|(
operator|(
operator|(
name|value
operator|&
literal|0x1f0000
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0x3e00000
operator|)
operator|>>
literal|5
operator|)
operator||
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_GPREL
condition|)
block|{
comment|/* R_MIPS16_GPREL is used for GP-relative addressing in mips16 	 mode.  A typical instruction will have a format like this:  	 +--------------+--------------------------------+ 	 !    EXTEND    !     Imm 10:5    !   Imm 15:11  ! 	 +--------------+--------------------------------+ 	 !    Major     !   rx   !   ry   !   Imm  4:0   ! 	 +--------------+--------------------------------+  	 EXTEND is the five bit value 11110.  Major is the instruction 	 opcode.  	 This is handled exactly like R_MIPS_GPREL16, except that the 	 addend is retrieved and stored as shown in this diagram; that 	 is, the Imm fields above replace the V-rel16 field.           All we need to do here is shuffle the bits appropriately.  As 	 above, the two 16-bit halves must be swapped on a 	 little-endian system.  */
name|value
operator|=
operator|(
operator|(
operator|(
name|value
operator|&
literal|0x7e0
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0xf800
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|value
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Set the field.  */
name|x
operator||=
operator|(
name|value
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
comment|/* If required, turn JAL into JALX.  */
if|if
condition|(
name|require_jalx
condition|)
block|{
name|bfd_boolean
name|ok
decl_stmt|;
name|bfd_vma
name|opcode
init|=
name|x
operator|>>
literal|26
decl_stmt|;
name|bfd_vma
name|jalx_opcode
decl_stmt|;
comment|/* Check to see if the opcode is already JAL or JALX.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
block|{
name|ok
operator|=
operator|(
operator|(
name|opcode
operator|==
literal|0x6
operator|)
operator|||
operator|(
name|opcode
operator|==
literal|0x7
operator|)
operator|)
expr_stmt|;
name|jalx_opcode
operator|=
literal|0x7
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
operator|(
operator|(
name|opcode
operator|==
literal|0x3
operator|)
operator|||
operator|(
name|opcode
operator|==
literal|0x1d
operator|)
operator|)
expr_stmt|;
name|jalx_opcode
operator|=
literal|0x1d
expr_stmt|;
block|}
comment|/* If the opcode is not JAL or JALX, there's a problem.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: %s+0x%lx: jump to stub routine which is not jal"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Make this the JALX opcode.  */
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator|)
operator||
operator|(
name|jalx_opcode
operator|<<
literal|26
operator|)
expr_stmt|;
block|}
comment|/* Swap the high- and low-order 16 bits on little-endian systems      when doing a MIPS16 relocation.  */
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_MIPS16_GPREL
operator|||
name|r_type
operator|==
name|R_MIPS16_26
operator|)
operator|&&
name|bfd_little_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|x
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
comment|/* Put the value into the output.  */
name|bfd_put
argument_list|(
literal|8
operator|*
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if SECTION is a MIPS16 stub section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_stub_section_p
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
decl_stmt|;
return|return
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add room for N relocations to the .rel.dyn section in ABFD.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_allocate_dynamic_relocations
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|abfd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* Make room for a null element.  */
name|s
operator|->
name|_raw_size
operator|+=
name|MIPS_ELF_REL_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
name|s
operator|->
name|_raw_size
operator|+=
name|n
operator|*
name|MIPS_ELF_REL_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL    is the original relocation, which is now being transformed into a    dynamic relocation.  The ADDENDP is adjusted if necessary; the    caller should store the result in place of the original addend.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_create_dynamic_relocation
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|symbol
parameter_list|,
name|bfd_vma
modifier|*
name|addendp
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|)
block|{
name|Elf_Internal_Rela
name|outrel
index|[
literal|3
index|]
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF_R_TYPE
argument_list|(
name|output_bfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|->
name|reloc_count
operator|*
name|MIPS_ELF_REL_SIZE
argument_list|(
name|output_bfd
argument_list|)
operator|<
name|sreloc
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|skip
operator|=
name|FALSE
expr_stmt|;
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
index|[
literal|0
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|outrel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
index|[
literal|2
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We begin by assuming that the offset for the dynamic relocation      is the same as for the original relocation.  We'll adjust this      later to reflect the correct output offsets.  */
block|if (input_section->sec_info_type != ELF_INFO_TYPE_STABS)     {       outrel[1].r_offset = rel[1].r_offset;       outrel[2].r_offset = rel[2].r_offset;     }   else     {
comment|/* Except that in a stab section things are more complex. 	 Because we compress stab information, the offset given in the 	 relocation may not be the one we want; we must let the stabs 	 machinery tell us the offset.  */
block|outrel[1].r_offset = outrel[0].r_offset;       outrel[2].r_offset = outrel[0].r_offset;
comment|/* If we didn't need the relocation at all, this value will be 	 -1.  */
block|if (outrel[0].r_offset == (bfd_vma) -1) 	skip = TRUE;     }
endif|#
directive|endif
if|if
condition|(
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
comment|/* The relocation field has been deleted.  */
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
block|{
comment|/* The relocation field has been converted into a relative value of 	 some sort.  Functions like _bfd_elf_write_section_eh_frame expect 	 the field to be fully relocated, so add in the symbol's value.  */
name|skip
operator|=
name|TRUE
expr_stmt|;
operator|*
name|addendp
operator|+=
name|symbol
expr_stmt|;
block|}
comment|/* If we've decided to skip this relocation, just output an empty      record.  Note that R_MIPS_NONE == 0, so that this call to memset      is a way of setting R_TYPE to R_MIPS_NONE.  */
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
operator|*
literal|3
argument_list|)
expr_stmt|;
else|else
block|{
name|long
name|indx
decl_stmt|;
name|bfd_boolean
name|defined_p
decl_stmt|;
comment|/* We must now calculate the dynamic symbol table index to use 	 in the relocation.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
comment|/* h->root.dynindx may be -1 if this symbol was marked to 	     become local.  */
operator|&&
name|h
operator|->
name|root
operator|.
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|indx
operator|=
name|h
operator|->
name|root
operator|.
name|dynindx
expr_stmt|;
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|defined_p
operator|=
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
else|else
comment|/* ??? glibc's ld.so just adds the final GOT entry to the 	       relocation field.  It therefore treats relocs against 	       defined symbols in the same way as relocs against 	       undefined symbols.  */
name|defined_p
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|indx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Instead of generating a relocation using the section 	     symbol, we may as well make it a fully relative 	     relocation.  We want to avoid generating relocations to 	     local symbols because we used to generate them 	     incorrectly, without adding the original symbol value, 	     which is mandated by the ABI for section symbols.  In 	     order to give dynamic loaders and applications time to 	     phase out the incorrect use, we refrain from emitting 	     section-relative relocations.  It's not like they're 	     useful, after all.  This should be a bit more efficient 	     as well.  */
comment|/* ??? Although this behavior is compatible with glibc's ld.so, 	     the ABI says that relocations against STN_UNDEF should have 	     a symbol value of 0.  Irix rld honors this, so relocations 	     against STN_UNDEF have no effect.  */
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
name|defined_p
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If the relocation was previously an absolute relocation and 	 this symbol will not be referred to by the relocation, we must 	 adjust it by the value we give it in the dynamic symbol table. 	 Otherwise leave the job up to the dynamic linker.  */
if|if
condition|(
name|defined_p
operator|&&
name|r_type
operator|!=
name|R_MIPS_REL32
condition|)
operator|*
name|addendp
operator|+=
name|symbol
expr_stmt|;
comment|/* The relocation is always an REL32 relocation because we don't 	 know where the shared library will wind up at load-time.  */
name|outrel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|indx
argument_list|,
name|R_MIPS_REL32
argument_list|)
expr_stmt|;
comment|/* For strict adherence to the ABI specification, we should 	 generate a R_MIPS_64 relocation record by itself before the 	 _REL32/_64 record as well, such that the addend is read in as 	 a 64-bit value (REL32 is a 32-bit relocation, after all). 	 However, since none of the existing ELF64 MIPS dynamic 	 loaders seems to care, we don't waste space with these 	 artificial relocations.  If this turns out to not be true, 	 mips_elf_allocate_dynamic_relocation() should be tweaked so 	 as to make room for a pair of dynamic relocations per 	 invocation if ABI_64_P, and here we should generate an 	 additional relocation record with R_MIPS_64 by itself for a 	 NULL symbol before this relocation record.  */
name|outrel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|R_MIPS_64
else|:
name|R_MIPS_NONE
argument_list|)
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|R_MIPS_NONE
argument_list|)
expr_stmt|;
comment|/* Adjust the output offset of the relocation to reference the 	 correct location in the output file.  */
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* Put the relocation back out.  We have to use the special      relocation outputter in the 64-bit case since the 64-bit      relocation format is non-standard.  */
if|if
condition|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|s
operator|->
name|swap_reloc_out
operator|)
operator|(
name|output_bfd
operator|,
operator|&
name|outrel
index|[
literal|0
index|]
operator|,
operator|(
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
index|[
literal|0
index|]
argument_list|,
operator|(
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* We've now added another relocation.  */
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* Make sure the output section is writable.  The dynamic linker      will be writing to it.  */
name|elf_section_data
argument_list|(
name|input_section
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator||=
name|SHF_WRITE
expr_stmt|;
comment|/* On IRIX5, make an entry of compact relocation info.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_irix5
condition|)
block|{
name|asection
modifier|*
name|scpt
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".compact_rel"
argument_list|)
decl_stmt|;
name|bfd_byte
modifier|*
name|cr
decl_stmt|;
if|if
condition|(
name|scpt
condition|)
block|{
name|Elf32_crinfo
name|cptrel
decl_stmt|;
name|mips_elf_set_cr_format
argument_list|(
name|cptrel
argument_list|,
name|CRF_MIPS_LONG
argument_list|)
expr_stmt|;
name|cptrel
operator|.
name|vaddr
operator|=
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_REL32
condition|)
name|mips_elf_set_cr_type
argument_list|(
name|cptrel
argument_list|,
name|CRT_MIPS_REL32
argument_list|)
expr_stmt|;
else|else
name|mips_elf_set_cr_type
argument_list|(
name|cptrel
argument_list|,
name|CRT_MIPS_WORD
argument_list|)
expr_stmt|;
name|mips_elf_set_cr_dist2to
argument_list|(
name|cptrel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cptrel
operator|.
name|konst
operator|=
operator|*
name|addendp
expr_stmt|;
name|cr
operator|=
operator|(
name|scpt
operator|->
name|contents
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_crinfo_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|cptrel
argument_list|,
operator|(
operator|(
name|Elf32_External_crinfo
operator|*
operator|)
name|cr
operator|+
name|scpt
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|scpt
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the MACH for a MIPS e_flags value.  */
end_comment

begin_function
name|unsigned
name|long
name|_bfd_elf_mips_mach
parameter_list|(
name|flagword
name|flags
parameter_list|)
block|{
switch|switch
condition|(
name|flags
operator|&
name|EF_MIPS_MACH
condition|)
block|{
case|case
name|E_MIPS_MACH_3900
case|:
return|return
name|bfd_mach_mips3900
return|;
case|case
name|E_MIPS_MACH_4010
case|:
return|return
name|bfd_mach_mips4010
return|;
case|case
name|E_MIPS_MACH_4100
case|:
return|return
name|bfd_mach_mips4100
return|;
case|case
name|E_MIPS_MACH_4111
case|:
return|return
name|bfd_mach_mips4111
return|;
case|case
name|E_MIPS_MACH_4120
case|:
return|return
name|bfd_mach_mips4120
return|;
case|case
name|E_MIPS_MACH_4650
case|:
return|return
name|bfd_mach_mips4650
return|;
case|case
name|E_MIPS_MACH_5400
case|:
return|return
name|bfd_mach_mips5400
return|;
case|case
name|E_MIPS_MACH_5500
case|:
return|return
name|bfd_mach_mips5500
return|;
case|case
name|E_MIPS_MACH_SB1
case|:
return|return
name|bfd_mach_mips_sb1
return|;
default|default:
switch|switch
condition|(
name|flags
operator|&
name|EF_MIPS_ARCH
condition|)
block|{
default|default:
case|case
name|E_MIPS_ARCH_1
case|:
return|return
name|bfd_mach_mips3000
return|;
break|break;
case|case
name|E_MIPS_ARCH_2
case|:
return|return
name|bfd_mach_mips6000
return|;
break|break;
case|case
name|E_MIPS_ARCH_3
case|:
return|return
name|bfd_mach_mips4000
return|;
break|break;
case|case
name|E_MIPS_ARCH_4
case|:
return|return
name|bfd_mach_mips8000
return|;
break|break;
case|case
name|E_MIPS_ARCH_5
case|:
return|return
name|bfd_mach_mips5
return|;
break|break;
case|case
name|E_MIPS_ARCH_32
case|:
return|return
name|bfd_mach_mipsisa32
return|;
break|break;
case|case
name|E_MIPS_ARCH_64
case|:
return|return
name|bfd_mach_mipsisa64
return|;
break|break;
case|case
name|E_MIPS_ARCH_32R2
case|:
return|return
name|bfd_mach_mipsisa32r2
return|;
break|break;
case|case
name|E_MIPS_ARCH_64R2
case|:
return|return
name|bfd_mach_mipsisa64r2
return|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return printable name for ABI.  */
end_comment

begin_function
specifier|static
name|INLINE
name|char
modifier|*
name|elf_mips_abi_name
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|EF_MIPS_ABI
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|ABI_N32_P
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|"N32"
return|;
elseif|else
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|"64"
return|;
else|else
return|return
literal|"none"
return|;
case|case
name|E_MIPS_ABI_O32
case|:
return|return
literal|"O32"
return|;
case|case
name|E_MIPS_ABI_O64
case|:
return|return
literal|"O64"
return|;
case|case
name|E_MIPS_ABI_EABI32
case|:
return|return
literal|"EABI32"
return|;
case|case
name|E_MIPS_ABI_EABI64
case|:
return|return
literal|"EABI64"
return|;
default|default:
return|return
literal|"unknown abi"
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* MIPS ELF uses two common sections.  One is the usual one, and the    other is for small objects.  All the small objects are kept    together, and then referenced via the gp pointer, which yields    faster assembler code.  This is what we use for the small common    section.  This approach is copied from ecoff.c.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|mips_elf_scom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|mips_elf_scom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|mips_elf_scom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MIPS ELF also uses an acommon section, which represents an    allocated common symbol which may be overridden by a    definition in a shared library.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|mips_elf_acom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|mips_elf_acom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|mips_elf_acom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the special MIPS section numbers that a symbol may use.    This is used for both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|void
name|_bfd_mips_elf_symbol_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
name|asym
parameter_list|)
block|{
name|elf_symbol_type
modifier|*
name|elfsym
decl_stmt|;
name|elfsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
expr_stmt|;
switch|switch
condition|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
condition|)
block|{
case|case
name|SHN_MIPS_ACOMMON
case|:
comment|/* This section is used in a dynamically linked executable file. 	 It is an allocated common section.  The dynamic linker can 	 either resolve these symbols to something in a shared 	 library, or it can just leave them here.  For our purposes, 	 we can consider these symbols to be in a new section.  */
if|if
condition|(
name|mips_elf_acom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the acommon section.  */
name|mips_elf_acom_section
operator|.
name|name
operator|=
literal|".acommon"
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|output_section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|symbol
operator|=
operator|&
name|mips_elf_acom_symbol
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|mips_elf_acom_symbol_ptr
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|name
operator|=
literal|".acommon"
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
name|mips_elf_acom_symbol_ptr
operator|=
operator|&
name|mips_elf_acom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
break|break;
case|case
name|SHN_COMMON
case|:
comment|/* Common symbols less than the GP size are automatically 	 treated as SHN_MIPS_SCOMMON symbols on IRIX5.  */
if|if
condition|(
name|asym
operator|->
name|value
operator|>
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
operator|||
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|SHN_MIPS_SCOMMON
case|:
if|if
condition|(
name|mips_elf_scom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the small common section.  */
name|mips_elf_scom_section
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|output_section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|symbol
operator|=
operator|&
name|mips_elf_scom_symbol
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|mips_elf_scom_symbol_ptr
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|mips_elf_scom_symbol_ptr
operator|=
operator|&
name|mips_elf_scom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_SUNDEFINED
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* for SGI_COMPAT */
block|case SHN_MIPS_TEXT:       asym->section = mips_elf_text_section_ptr;       break;      case SHN_MIPS_DATA:       asym->section = mips_elf_data_section_ptr;       break;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* There appears to be a bug in the MIPSpro linker that causes GOT_DISP    relocations against two unnamed section symbols to resolve to the    same address.  For example, if we have code like:  	lw	$4,%got_disp(.data)($gp) 	lw	$25,%got_disp(.text)($gp) 	jalr	$25     then the linker will resolve both relocations to .data and the program    will jump there rather than to .text.     We can work around this problem by giving names to local section symbols.    This is also what the MIPSpro tools do.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_name_local_section_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
return|return
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Work over a section just before writing it out.  This routine is    used by both the 32-bit and the 64-bit ABI.  FIXME: We recognize    sections that need the SHF_MIPS_GPREL flag by name; there has to be    a better way.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_section_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|)
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_REGINFO
operator|&&
name|hdr
operator|->
name|sh_size
operator|>
literal|0
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|sh_size
operator|==
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|contents
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
operator|-
literal|4
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|elf_gp
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_OPTIONS
operator|&&
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
operator|&&
name|mips_elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|!=
name|NULL
operator|&&
name|mips_elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|!=
name|NULL
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|lend
decl_stmt|;
comment|/* We stored the section contents in the tdata field in the 	 set_section_contents routine.  We save the section contents 	 so that we don't have to read them again. 	 At this point we know that elf_gp is set, so we can look 	 through the section contents to see if there is an 	 ODK_REGINFO structure.  */
name|contents
operator|=
name|mips_elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|->
name|u
operator|.
name|tdata
expr_stmt|;
name|l
operator|=
name|contents
expr_stmt|;
name|lend
operator|=
name|contents
operator|+
name|hdr
operator|->
name|sh_size
expr_stmt|;
while|while
condition|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|<=
name|lend
condition|)
block|{
name|Elf_Internal_Options
name|intopt
decl_stmt|;
name|bfd_mips_elf_swap_options_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Options
operator|*
operator|)
name|l
argument_list|,
operator|&
name|intopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
operator|&&
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|hdr
operator|->
name|sh_offset
operator|+
operator|(
name|l
operator|-
name|contents
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
operator|-
literal|8
operator|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|H_PUT_64
argument_list|(
name|abfd
argument_list|,
name|elf_gp
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|hdr
operator|->
name|sh_offset
operator|+
operator|(
name|l
operator|-
name|contents
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
operator|-
literal|4
operator|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|elf_gp
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|FALSE
return|;
block|}
name|l
operator|+=
name|intopt
operator|.
name|size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_NOBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".srdata"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".compact_rel"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rtproc"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_addralign
operator|!=
literal|0
operator|&&
name|hdr
operator|->
name|sh_entsize
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|adjust
decl_stmt|;
name|adjust
operator|=
name|hdr
operator|->
name|sh_size
operator|%
name|hdr
operator|->
name|sh_addralign
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_size
operator|+=
name|hdr
operator|->
name|sh_addralign
operator|-
name|adjust
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Handle a MIPS specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.    This routine supports both the 32-bit and 64-bit ELF ABI.     FIXME: We need to handle the SHF_MIPS_GPREL flag, but I'm not sure    how to.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_section_from_shdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|flagword
name|flags
init|=
literal|0
decl_stmt|;
comment|/* There ought to be a place to keep ELF backend specific flags, but      at the moment there isn't one.  We just keep track of the      sections by their name, instead.  Fortunately, the ABI gives      suggested names for all the MIPS specific sections, so we will      probably get away with this.  */
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_MIPS_LIBLIST
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".liblist"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_MSYM
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".msym"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_CONFLICT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".conflict"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_GPTAB
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_UCODE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ucode"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_DEBUG
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|flags
operator|=
name|SEC_DEBUGGING
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_REGINFO
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|!=
literal|0
operator|||
name|hdr
operator|->
name|sh_size
operator|!=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|flags
operator|=
operator|(
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_SAME_SIZE
operator|)
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_IFACE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.interfaces"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_CONTENT
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|,
sizeof|sizeof
expr|".MIPS.content"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_OPTIONS
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_DWARF
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".debug_"
argument_list|,
sizeof|sizeof
expr|".debug_"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.symlib"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_EVENTS
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|,
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|,
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|flags
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
operator||
name|flags
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* FIXME: We should record sh_info for a .gptab section.  */
comment|/* For a .reginfo section, set the gp value in the tdata information      from the contents of this section.  We need the gp value while      processing relocs, so we just get it now.  The .reginfo section      is not used in the 64-bit MIPS ELF ABI.  */
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_REGINFO
condition|)
block|{
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|Elf32_RegInfo
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
operator|&
name|ext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|ext
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|s
operator|.
name|ri_gp_value
expr_stmt|;
block|}
comment|/* For a SHT_MIPS_OPTIONS section, look for a ODK_REGINFO entry, and      set the gp value based on what we find.  We may see both      SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS/ODK_REGINFO; in that case,      they should agree.  */
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_OPTIONS
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|lend
decl_stmt|;
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|l
operator|=
name|contents
expr_stmt|;
name|lend
operator|=
name|contents
operator|+
name|hdr
operator|->
name|sh_size
expr_stmt|;
while|while
condition|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|<=
name|lend
condition|)
block|{
name|Elf_Internal_Options
name|intopt
decl_stmt|;
name|bfd_mips_elf_swap_options_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Options
operator|*
operator|)
name|l
argument_list|,
operator|&
name|intopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
operator|&&
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|Elf64_Internal_RegInfo
name|intreg
decl_stmt|;
name|bfd_mips_elf64_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|Elf64_External_RegInfo
operator|*
operator|)
operator|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|intreg
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|intreg
operator|.
name|ri_gp_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|Elf32_RegInfo
name|intreg
decl_stmt|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|Elf32_External_RegInfo
operator|*
operator|)
operator|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|intreg
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|intreg
operator|.
name|ri_gp_value
expr_stmt|;
block|}
name|l
operator|+=
name|intopt
operator|.
name|size
expr_stmt|;
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the correct type for a MIPS ELF section.  We do this by the    section name, which is a hack, but ought to work.  This routine is    used by both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".liblist"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_LIBLIST
expr_stmt|;
name|hdr
operator|->
name|sh_info
operator|=
name|sec
operator|->
name|_raw_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_Lib
argument_list|)
expr_stmt|;
comment|/* The sh_link field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".conflict"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_CONFLICT
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_GPTAB
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
comment|/* The sh_info field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ucode"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_UCODE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_DEBUG
expr_stmt|;
comment|/* In a shared object on IRIX 5.3, the .mdebug section has an          entsize of 0.  FIXME: Does this matter?  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_REGINFO
expr_stmt|;
comment|/* In a shared object on IRIX 5.3, the .reginfo section has an          entsize of 0x18.  FIXME: Does this matter?  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".hash"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynstr"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This isn't how the IRIX6 linker behaves.  */
block|hdr->sh_info = SIZEOF_MIPS_DYNSYM_SECNAMES;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".srdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_GPREL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.interfaces"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_IFACE
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|,
name|strlen
argument_list|(
literal|".MIPS.content"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_CONTENT
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
comment|/* The sh_info field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_OPTIONS
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".debug_"
argument_list|,
sizeof|sizeof
expr|".debug_"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_DWARF
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.symlib"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_SYMBOL_LIB
expr_stmt|;
comment|/* The sh_link and sh_info fields are set in          final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|,
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|,
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_EVENTS
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
comment|/* The sh_link field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".msym"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_MSYM
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
literal|8
expr_stmt|;
block|}
comment|/* The generic elf_fake_sections will set up REL_HDR using the default    kind of relocations.  We used to set up a second header for the    non-default kind of relocations here, but only NewABI would use    these, and the IRIX ld doesn't like resulting empty RELA sections.    Thus we create those header only on demand now.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Given a BFD section, try to locate the corresponding ELF section    index.  This is used by both the 32-bit and the 64-bit ABI.    Actually, it's not clear to me that the 64-bit ABI supports these,    but for non-PIC objects we will certainly want support for at least    the .scommon section.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_section_from_bfd_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_MIPS_SCOMMON
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".acommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_MIPS_ACOMMON
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We must handle the special MIPS section numbers here.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
parameter_list|,
name|bfd_vma
modifier|*
name|valp
parameter_list|)
block|{
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"_rld_new_interface"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Skip IRIX5 rld entry name.  */
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
switch|switch
condition|(
name|sym
operator|->
name|st_shndx
condition|)
block|{
case|case
name|SHN_COMMON
case|:
comment|/* Common symbols less than the GP size are automatically 	 treated as SHN_MIPS_SCOMMON symbols.  */
if|if
condition|(
name|sym
operator|->
name|st_size
operator|>
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
operator|||
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|SHN_MIPS_SCOMMON
case|:
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_TEXT
case|:
comment|/* This section is used in a shared object.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_section
operator|==
name|NULL
condition|)
block|{
name|asymbol
modifier|*
name|elf_text_symbol
decl_stmt|;
name|asection
modifier|*
name|elf_text_section
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
decl_stmt|;
name|elf_text_section
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_text_section
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
expr_stmt|;
name|elf_text_symbol
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_text_symbol
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Initialize the section.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_section
operator|=
name|elf_text_section
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_symbol
operator|=
name|elf_text_symbol
expr_stmt|;
name|elf_text_section
operator|->
name|symbol
operator|=
name|elf_text_symbol
expr_stmt|;
name|elf_text_section
operator|->
name|symbol_ptr_ptr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_symbol
expr_stmt|;
name|elf_text_section
operator|->
name|name
operator|=
literal|".text"
expr_stmt|;
name|elf_text_section
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|elf_text_section
operator|->
name|output_section
operator|=
name|NULL
expr_stmt|;
name|elf_text_section
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
name|elf_text_symbol
operator|->
name|name
operator|=
literal|".text"
expr_stmt|;
name|elf_text_symbol
operator|->
name|flags
operator|=
name|BSF_SECTION_SYM
operator||
name|BSF_DYNAMIC
expr_stmt|;
name|elf_text_symbol
operator|->
name|section
operator|=
name|elf_text_section
expr_stmt|;
block|}
comment|/* This code used to do *secp = bfd_und_section_ptr if          info->shared.  I don't know why, and that doesn't make sense,          so I took it out.  */
operator|*
name|secp
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_section
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_ACOMMON
case|:
comment|/* Fall through. XXX Can we treat this as allocated data?  */
case|case
name|SHN_MIPS_DATA
case|:
comment|/* This section is used in a shared object.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_section
operator|==
name|NULL
condition|)
block|{
name|asymbol
modifier|*
name|elf_data_symbol
decl_stmt|;
name|asection
modifier|*
name|elf_data_section
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
decl_stmt|;
name|elf_data_section
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_data_section
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
expr_stmt|;
name|elf_data_symbol
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_data_symbol
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Initialize the section.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_section
operator|=
name|elf_data_section
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_symbol
operator|=
name|elf_data_symbol
expr_stmt|;
name|elf_data_section
operator|->
name|symbol
operator|=
name|elf_data_symbol
expr_stmt|;
name|elf_data_section
operator|->
name|symbol_ptr_ptr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_symbol
expr_stmt|;
name|elf_data_section
operator|->
name|name
operator|=
literal|".data"
expr_stmt|;
name|elf_data_section
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|elf_data_section
operator|->
name|output_section
operator|=
name|NULL
expr_stmt|;
name|elf_data_section
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
name|elf_data_symbol
operator|->
name|name
operator|=
literal|".data"
expr_stmt|;
name|elf_data_symbol
operator|->
name|flags
operator|=
name|BSF_SECTION_SYM
operator||
name|BSF_DYNAMIC
expr_stmt|;
name|elf_data_symbol
operator|->
name|section
operator|=
name|elf_data_section
expr_stmt|;
block|}
comment|/* This code used to do *secp = bfd_und_section_ptr if          info->shared.  I don't know why, and that doesn't make sense,          so I took it out.  */
operator|*
name|secp
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_section
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_SUNDEFINED
case|:
operator|*
name|secp
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
operator|&&
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"__rld_obj_head"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
comment|/* Mark __rld_obj_head as dynamic.  */
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
operator|*
name|namep
argument_list|,
name|BSF_GLOBAL
argument_list|,
operator|*
name|secp
argument_list|,
operator|*
name|valp
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If this is a mips16 text symbol, add 1 to the value to make it      odd.  This will cause something like .word SYM to come up with      the right value when it is loaded into the PC.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
operator|++
operator|*
name|valp
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This hook function is called before the linker writes out a global    symbol.  We mark symbols as small common if appropriate.  This is    also where we undo the increment of the value for a mips16 symbol.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_link_output_symbol_hook
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
name|input_sec
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If we see a common symbol, which implies a relocatable link, then      if a symbol was small common in an input file, mark it as small      common in the output file.  */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
name|strcmp
argument_list|(
name|input_sec
operator|->
name|name
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_SCOMMON
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
operator|&&
operator|(
name|sym
operator|->
name|st_value
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|sym
operator|->
name|st_value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for the dynamic linker.  */
end_comment

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|namep
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
comment|/* Mips ABI requests the .dynamic section to be read only.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* We need to create .got section.  */
if|if
condition|(
operator|!
name|mips_elf_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|mips_elf_rel_dyn_section
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create .stub section.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_CODE
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
operator|||
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_none
operator|)
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator|&
operator|~
operator|(
name|flagword
operator|)
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* On IRIX5, we adjust add some additional symbols and change the      alignments of several sections.  There is no ABI documentation      indicating that this is necessary on IRIX6, nor any evidence that      the linker takes such action.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
condition|)
block|{
for|for
control|(
name|namep
operator|=
name|mips_elf_dynsym_rtproc_names
init|;
operator|*
name|namep
operator|!=
name|NULL
condition|;
name|namep
operator|++
control|)
block|{
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
operator|*
name|namep
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_und_section_ptr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_SECTION
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* We need to create a .compact_rel section.  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|mips_elf_create_compact_rel_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Change alignments of some sections.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|?
literal|"_DYNAMIC_LINK"
else|:
literal|"_DYNAMIC_LINKING"
expr_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_SECTION
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
condition|)
block|{
comment|/* __rld_map is a four byte word located in the .data section 	     and is filled in by the rtld to contain a pointer to 	     the _r_debug structure. Its symbol value will be set in 	     _bfd_mips_elf_finish_dynamic_symbol.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|?
literal|"__rld_map"
else|:
literal|"__RLD_MAP"
expr_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
comment|/* Check for the mips16 stub sections.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
comment|/* Look at the relocation information to figure out which symbol          this is for.  */
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|relocs
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
comment|/* This stub is for a local symbol.  This stub will only be              needed if there is some relocation in this BFD, other              than a 16 bit function call, which refers to this symbol.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|sec_relocs
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|r
decl_stmt|,
modifier|*
name|rend
decl_stmt|;
comment|/* We can ignore stub sections when looking for relocs.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|sec_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|rend
operator|=
name|sec_relocs
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|r
operator|=
name|sec_relocs
init|;
name|r
operator|<
name|rend
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|r
operator|->
name|r_info
argument_list|)
operator|==
name|r_symndx
operator|&&
name|ELF_R_TYPE
argument_list|(
name|abfd
argument_list|,
name|r
operator|->
name|r_info
argument_list|)
operator|!=
name|R_MIPS16_26
condition|)
break|break;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
operator|!=
name|sec_relocs
condition|)
name|free
argument_list|(
name|sec_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|rend
condition|)
break|break;
block|}
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
block|{
comment|/* There is no non-call reloc for this stub, so we do                  not need it.  Since this function is called before                  the linker maps input sections to output sections, we                  can easily discard it by setting the SEC_EXCLUDE                  flag.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Record this stub in an array of local symbol stubs for              this BFD.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|long
name|symcount
decl_stmt|;
name|asection
modifier|*
modifier|*
name|n
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|symcount
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
expr_stmt|;
else|else
name|symcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|n
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
operator|=
name|n
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
operator|=
name|sec
expr_stmt|;
comment|/* We don't need to set mips16_stubs_seen in this case.              That flag is used to see whether we need to look through              the global symbol table for stubs.  We don't need to set              it here, because we just have a local stub.  */
block|}
else|else
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* H is the symbol this stub is for.  */
name|h
operator|->
name|fn_stub
operator|=
name|sec
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* Look at the relocation information to figure out which symbol          this is for.  */
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|relocs
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* This stub was actually built for a static symbol defined 	     in the same file.  We assume that all static symbols in 	     mips16 code are themselves mips16, so we can simply 	     discard this stub.  Since this function is called before 	     the linker maps input sections to output sections, we can 	     easily discard it by setting the SEC_EXCLUDE flag.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* H is the symbol this stub is for.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|loc
operator|=
operator|&
name|h
operator|->
name|call_fp_stub
expr_stmt|;
else|else
name|loc
operator|=
operator|&
name|h
operator|->
name|call_stub
expr_stmt|;
comment|/* If we already have an appropriate stub for this function, we 	 don't need another one, so we can discard this one.  Since 	 this function is called before the linker maps input sections 	 to output sections, we can easily discard it by setting the 	 SEC_EXCLUDE flag.  We can also discard this section if we 	 happen to already know that this is a mips16 function; it is 	 not necessary to check this here, as it is checked later, but 	 it is slightly faster to check now.  */
if|if
condition|(
operator|*
name|loc
operator|!=
name|NULL
operator|||
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|*
name|loc
operator|=
name|sec
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|NULL
expr_stmt|;
name|g
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
operator|++
name|rel
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF_R_TYPE
argument_list|(
name|abfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|r_symndx
operator|>=
name|extsymoff
operator|+
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Malformed reloc detected for section %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* This may be an indirect symbol created because of a version.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
block|}
comment|/* Some relocs require a global offset table.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|||
name|sgot
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_GOT_PAGE
case|:
case|case
name|R_MIPS_GOT_OFST
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|h
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|h
operator|&&
operator|(
name|r_type
operator|==
name|R_MIPS_CALL_LO16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_LO16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_DISP
operator|)
condition|)
block|{
comment|/* We may need a local GOT entry for this relocation.  We 	     don't count R_MIPS_GOT_PAGE because we can estimate the 	     maximum number of pages needed by looking at the size of 	     the segment.  Similar comments apply to R_MIPS_GOT16 and 	     R_MIPS_CALL16.  We don't count R_MIPS_GOT_HI16, or 	     R_MIPS_CALL_HI16 because these are always followed by an 	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.  */
if|if
condition|(
operator|!
name|mips_elf_record_local_got_symbol
argument_list|(
name|abfd
argument_list|,
name|r_symndx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_CALL16
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: CALL16 reloc at 0x%lx not against global symbol"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Fall through.  */
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
operator|!
name|mips_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We need a stub, not a plt entry for the undefined 		 function.  But we record it as if it needs plt.  See 		 _bfd_elf_adjust_dynamic_symbol.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
block|}
break|break;
case|case
name|R_MIPS_GOT_PAGE
case|:
comment|/* If this is a global, overridable symbol, GOT_PAGE will 	     decay to GOT_DISP, so we'll need a GOT entry for it.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
else|else
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
init|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
decl_stmt|;
while|while
condition|(
name|hmips
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hmips
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|hmips
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|hmips
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|&&
operator|!
operator|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|symbolic
operator|&&
operator|!
operator|(
name|hmips
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
condition|)
break|break;
block|}
comment|/* Fall through.  */
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|h
operator|&&
operator|!
name|mips_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|h
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|dynobj
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
define|#
directive|define
name|MIPS_READONLY_SECTION
value|(SEC_ALLOC | SEC_LOAD | SEC_READONLY)
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* When creating a shared object, we must copy these 		     reloc types into the output file as R_MIPS_REL32 		     relocs.  We make room for this reloc in the 		     .rel.dyn reloc section.  */
name|mips_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|MIPS_READONLY_SECTION
operator|)
operator|==
name|MIPS_READONLY_SECTION
condition|)
comment|/* We tell the dynamic linker that there are 		       relocations against the text segment.  */
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
decl_stmt|;
comment|/* We only need to copy this reloc if the symbol is                      defined in a dynamic object.  */
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
operator|++
name|hmips
operator|->
name|possibly_dynamic_relocs
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|MIPS_READONLY_SECTION
operator|)
operator|==
name|MIPS_READONLY_SECTION
condition|)
comment|/* We need it to tell the dynamic linker if there 		       are relocations against the text segment.  */
name|hmips
operator|->
name|readonly_reloc
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Even though we don't directly need a GOT entry for 		 this symbol, a symbol must have a dynamic symbol 		 table index greater that DT_MIPS_GOTSYM if there are 		 dynamic relocations against it.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_crinfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_26
case|:
case|case
name|R_MIPS_GPREL16
case|:
case|case
name|R_MIPS_LITERAL
case|:
case|case
name|R_MIPS_GPREL32
case|:
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_crinfo
argument_list|)
expr_stmt|;
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_MIPS_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
break|break;
block|}
comment|/* We must not create a stub for a symbol that has relocations          related to taking the function's address.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|mh
decl_stmt|;
name|mh
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|mh
operator|->
name|no_fn_stub
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
case|case
name|R_MIPS_JALR
case|:
break|break;
block|}
comment|/* If this reloc is not a 16 bit call, and it has a global          symbol, then we will need the fn_stub if there is one.          References from a stub section do not count.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|r_type
operator|!=
name|R_MIPS16_26
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|FN_STUB
argument_list|,
sizeof|sizeof
name|FN_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|CALL_STUB
argument_list|,
sizeof|sizeof
name|CALL_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|CALL_FP_STUB
argument_list|,
sizeof|sizeof
name|CALL_FP_STUB
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|mh
decl_stmt|;
name|mh
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|mh
operator|->
name|need_fn_stub
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|bfd_boolean
name|_bfd_mips_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|free_contents
init|=
name|NULL
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|bfd_boolean
name|changed_contents
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|sec_start
init|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* We are not currently changing any sizes, so only one pass.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|link_info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
operator|*
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
name|bfd_signed_vma
name|sym_offset
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|unsigned
name|long
name|instruction
decl_stmt|;
comment|/* Turn jalr into bgezal, and jr into beq, if they're marked 	 with a JALR relocation, that indicate where they jump to. 	 This saves some pipeline bubbles.  */
name|r_type
operator|=
name|ELF_R_TYPE
argument_list|(
name|abfd
argument_list|,
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS_JALR
condition|)
continue|continue;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Compute the address of the jump target.  */
if|if
condition|(
name|r_symndx
operator|>=
name|extsymoff
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
init|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If a symbol is undefined, or if it may be overridden, 	     skip it.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|)
operator|||
operator|(
name|link_info
operator|->
name|shared
operator|&&
operator|!
name|link_info
operator|->
name|symbolic
operator|&&
operator|!
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
condition|)
continue|continue;
name|sym_sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|->
name|output_section
condition|)
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
name|symval
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
comment|/* Read this BFD's symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|relax_return
goto|;
block|}
name|isym
operator|=
name|isymbuf
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
name|isym
operator|->
name|st_value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* Compute branch offset, from delay slot of the jump to the 	 branch target.  */
name|sym_offset
operator|=
operator|(
name|symval
operator|+
name|irel
operator|->
name|r_addend
operator|)
operator|-
operator|(
name|sec_start
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|4
operator|)
expr_stmt|;
comment|/* Branch offset must be properly aligned.  */
if|if
condition|(
operator|(
name|sym_offset
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|sym_offset
operator|>>=
literal|2
expr_stmt|;
comment|/* Check that it's in range.  */
if|if
condition|(
name|sym_offset
operator|<
operator|-
literal|0x8000
operator|||
name|sym_offset
operator|>=
literal|0x8000
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|relax_return
goto|;
name|free_contents
operator|=
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|relax_return
goto|;
block|}
block|}
name|instruction
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* If it was jalr<reg>, turn it into bgezal $zero,<target>.  */
if|if
condition|(
operator|(
name|instruction
operator|&
literal|0xfc1fffff
operator|)
operator|==
literal|0x0000f809
condition|)
name|instruction
operator|=
literal|0x04110000
expr_stmt|;
comment|/* If it was jr<reg>, turn it into b<target>.  */
elseif|else
if|if
condition|(
operator|(
name|instruction
operator|&
literal|0xfc1fffff
operator|)
operator|==
literal|0x00000008
condition|)
name|instruction
operator|=
literal|0x10000000
expr_stmt|;
else|else
continue|continue;
name|instruction
operator||=
operator|(
name|sym_offset
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|instruction
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|changed_contents
operator|&&
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
name|relax_return
label|:
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|||
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this symbol is defined in a dynamic object, we need to copy      any R_MIPS_32 or R_MIPS_REL32 relocs against it into the output      file.  */
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|hmips
operator|->
name|possibly_dynamic_relocs
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|mips_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
name|hmips
operator|->
name|possibly_dynamic_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmips
operator|->
name|readonly_reloc
condition|)
comment|/* We tell the dynamic linker that there are relocations 	   against the text segment.  */
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
comment|/* For a function, create a stub, if allowed.  */
if|if
condition|(
operator|!
name|hmips
operator|->
name|no_fn_stub
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|TRUE
return|;
comment|/* If this symbol is not defined in a regular file, then set 	 the symbol to the stub location.  This is required to make 	 function pointers compare as equal between the normal 	 executable and the shared library.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We need .stub section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* XXX Write this stub address somewhere.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Make room for this stub code.  */
name|s
operator|->
name|_raw_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
comment|/* The last half word of the stub will be filled with the index 	     of this symbol in .dynsym section.  */
return|return
name|TRUE
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* This will set the entry for this symbol in the GOT to 0, and          the dynamic linker will take care of this.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called after all the input files have been read,    and the input sections have been assigned to output sections.  We    check for any mips16 stub sections that we can discard.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_always_size_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|ri
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|loadable_size
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|local_gotno
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
comment|/* The .reginfo section has a fixed size.  */
name|ri
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ri
operator|!=
name|NULL
condition|)
name|bfd_set_section_size
argument_list|(
name|output_bfd
argument_list|,
name|ri
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|info
operator|->
name|relocatable
operator|||
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|)
condition|)
name|mips_elf_link_hash_traverse
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_check_mips16_stubs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
comment|/* Relocatable links don't have it.  */
return|return
name|TRUE
return|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Calculate the total loadable size of the output.  That      will give us the maximum number of GOT_PAGE entries      required.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
for|for
control|(
name|subsection
operator|=
name|sub
operator|->
name|sections
init|;
name|subsection
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|loadable_size
operator|+=
operator|(
operator|(
name|subsection
operator|->
name|_raw_size
operator|+
literal|0xf
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|0xf
operator|)
expr_stmt|;
block|}
block|}
comment|/* There has to be a global GOT entry for every symbol with      a dynamic symbol table index of DT_MIPS_GOTSYM or      higher.  Therefore, it make sense to put those symbols      that need GOT entries at the end of the symbol table.  We      do that here.  */
if|if
condition|(
operator|!
name|mips_elf_sort_hash_table
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|i
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|-
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
else|else
comment|/* If there are no global symbols, or none requiring        relocations, then GLOBAL_GOTSYM will be NULL.  */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* In the worst case, we'll get one stub per dynamic symbol, plus      one to account for the dummy entry at the end required by IRIX      rld.  */
name|loadable_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Assume there are two loadable segments consisting of      contiguous sections.  Is 5 enough?  */
name|local_gotno
operator|=
operator|(
name|loadable_size
operator|>>
literal|16
operator|)
operator|+
literal|5
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|+=
name|local_gotno
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|g
operator|->
name|local_gotno
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|i
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|>
name|MIPS_ELF_GOT_MAX_SIZE
argument_list|(
name|output_bfd
argument_list|)
operator|&&
operator|!
name|mips_elf_multi_got
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|,
name|s
argument_list|,
name|local_gotno
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|reltext
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|strlen
argument_list|(
name|ELF_DYNAMIC_INTERPRETER
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|reltext
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_boolean
name|strip
decl_stmt|;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|strip
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* We only strip the section if the output section name                  has the same name.  Otherwise, there might be several                  input sections for this output section.  FIXME: This                  code is probably not needed these days anyhow, since                  the linker now does not create empty output sections.  */
if|if
condition|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|bfd_get_section_name
argument_list|(
name|s
operator|->
name|output_section
operator|->
name|owner
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|strip
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|asection
modifier|*
name|target
decl_stmt|;
comment|/* If this relocation section applies to a read only                  section, then we probably need a DT_TEXTREL entry.                  If the relocation section is .rel.dyn, we always                  assert a DT_TEXTREL entry rather than testing whether                  there exists a relocation to a read only section or                  not.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|outname
argument_list|,
literal|".rel.dyn"
argument_list|)
operator|==
literal|0
condition|)
name|reltext
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rel.dyn"
argument_list|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
comment|/* If combreloc is enabled, elf_link_sort_relocs() will 		 sort relocations, but in a different way than we do, 		 and before we're done creating relocations.  Also, it 		 will move them around between input sections' 		 relocation's contents, so our sorting would be 		 broken, so don't let it run.  */
name|info
operator|->
name|combreloc
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* _bfd_mips_elf_always_size_sections() has already done 	     most of the work, but some symbols may have been mapped 	     to versions that we must now resolve in the got_entries 	     hash tables.  */
name|struct
name|mips_got_info
modifier|*
name|gg
init|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
init|=
name|gg
decl_stmt|;
name|struct
name|mips_elf_set_global_got_offset_arg
name|set_got_offset_arg
decl_stmt|;
name|unsigned
name|int
name|needed_relocs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|gg
operator|->
name|next
condition|)
block|{
name|set_got_offset_arg
operator|.
name|value
operator|=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|set_got_offset_arg
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|mips_elf_resolve_final_got_entries
argument_list|(
name|gg
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|gg
operator|->
name|next
init|;
name|g
operator|&&
name|g
operator|->
name|next
operator|!=
name|gg
condition|;
name|g
operator|=
name|g
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|save_assign
decl_stmt|;
name|mips_elf_resolve_final_got_entries
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* Assign offsets to global GOT entries.  */
name|save_assign
operator|=
name|g
operator|->
name|assigned_gotno
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|g
operator|->
name|local_gotno
expr_stmt|;
name|set_got_offset_arg
operator|.
name|g
operator|=
name|g
expr_stmt|;
name|set_got_offset_arg
operator|.
name|needed_relocs
operator|=
literal|0
expr_stmt|;
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_set_global_got_offset
argument_list|,
operator|&
name|set_got_offset_arg
argument_list|)
expr_stmt|;
name|needed_relocs
operator|+=
name|set_got_offset_arg
operator|.
name|needed_relocs
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|assigned_gotno
operator|-
name|g
operator|->
name|local_gotno
operator|<=
name|g
operator|->
name|global_gotno
argument_list|)
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|save_assign
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|needed_relocs
operator|+=
name|g
operator|->
name|local_gotno
operator|-
name|g
operator|->
name|assigned_gotno
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|assigned_gotno
operator|==
name|g
operator|->
name|next
operator|->
name|local_gotno
operator|+
name|g
operator|->
name|next
operator|->
name|global_gotno
operator|+
name|MIPS_RESERVED_GOTNO
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needed_relocs
condition|)
name|mips_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
name|needed_relocs
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* IRIX rld assumes that the function stub isn't at the end 	     of .text section. So put a dummy. XXX  */
name|s
operator|->
name|_raw_size
operator|+=
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rld_map"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We add a room for __rld_map. It will be filled in by the 	     rtld to contain a pointer to the _r_debug structure.  */
name|s
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".compact_rel"
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in _bfd_mips_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* SGI object has the equivalence of DT_DEBUG in the 	     DT_MIPS_RLD_MAP entry.  */
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_RLD_MAP
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
comment|/* Shared libraries on traditional mips have DT_DEBUG.  */
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|reltext
operator|&&
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|mips_elf_rel_dyn_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_REL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_RELENT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_RLD_VERSION
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_FLAGS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
literal|0
comment|/* Time stamps in executable files are a bad idea.  */
block|if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_TIME_STAMP, 0)) 	return FALSE;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* FIXME  */
block|if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_ICHECKSUM, 0)) 	return FALSE;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* FIXME  */
block|if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_IVERSION, 0)) 	return FALSE;
endif|#
directive|endif
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_BASE_ADDRESS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_LOCAL_GOTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_SYMTABNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_UNREFEXTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_GOTSYM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|dynobj
argument_list|)
operator|==
name|ict_irix5
operator|&&
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_HIPAGENO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|dynobj
argument_list|)
operator|==
name|ict_irix6
operator|&&
operator|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_OPTIONS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate a MIPS ELF section.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|bfd_vma
name|addend
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|use_saved_addend_p
init|=
name|FALSE
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd_boolean
name|require_jalx
decl_stmt|;
comment|/* TRUE if the relocation is a RELA relocation, rather than a          REL relocation.  */
name|bfd_boolean
name|rela_relocation_p
init|=
name|TRUE
decl_stmt|;
name|unsigned
name|int
name|r_type
init|=
name|ELF_R_TYPE
argument_list|(
name|output_bfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* Find the relocation howto for this relocation.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Some 32-bit code uses R_MIPS_64.  In particular, people use 	     64-bit code, but make sure all their addresses are in the 	     lowermost or uppermost 32-bit section of the 64-bit address 	     space.  Thus, when they use an R_MIPS_64 they mean what is 	     usually meant by R_MIPS_32, with the exception that the 	     stored value is sign-extended to 64 bits.  */
name|howto
operator|=
name|MIPS_ELF_RTYPE_TO_HOWTO
argument_list|(
name|input_bfd
argument_list|,
name|R_MIPS_32
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* On big-endian systems, we need to lie about the position 	     of the reloc.  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|rel
operator|->
name|r_offset
operator|+=
literal|4
expr_stmt|;
block|}
else|else
comment|/* NewABI defaults to RELA relocations.  */
name|howto
operator|=
name|MIPS_ELF_RTYPE_TO_HOWTO
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|,
name|NEWABI_P
argument_list|(
name|input_bfd
argument_list|)
operator|&&
operator|(
name|MIPS_RELOC_RELA_P
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|-
name|relocs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_saved_addend_p
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
comment|/* If these relocations were originally of the REL variety, 	     we must pull the addend out of the field that will be 	     relocated.  Otherwise, we simply use the contents of the 	     RELA relocation.  To determine which flavor or relocation 	     this is, we depend on the fact that the INPUT_SECTION's 	     REL_HDR is read before its REL_HDR2.  */
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|rel
operator|-
name|relocs
argument_list|)
operator|>=
operator|(
name|NUM_SHDR_ENTRIES
argument_list|(
name|rel_hdr
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|)
condition|)
name|rel_hdr
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr2
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
name|MIPS_ELF_REL_SIZE
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Note that this is a REL relocation.  */
name|rela_relocation_p
operator|=
name|FALSE
expr_stmt|;
comment|/* Get the addend, which is stored in the input file.  */
name|addend
operator|=
name|mips_elf_obtain_contents
argument_list|(
name|howto
argument_list|,
name|rel
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|addend
operator|&=
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* For some kinds of relocations, the ADDEND is a 		 combination of the addend stored in two different 		 relocations.   */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HI16
operator|||
name|r_type
operator|==
name|R_MIPS_GNU_REL_HI16
operator|||
operator|(
name|r_type
operator|==
name|R_MIPS_GOT16
operator|&&
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|local_sections
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
name|bfd_vma
name|l
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|lo16_relocation
decl_stmt|;
name|reloc_howto_type
modifier|*
name|lo16_howto
decl_stmt|;
name|unsigned
name|int
name|lo
decl_stmt|;
comment|/* The combined value is the sum of the HI16 addend, 		     left-shifted by sixteen bits, and the LO16 		     addend, sign extended.  (Usually, the code does 		     a `lui' of the HI16 value, and then an `addiu' of 		     the LO16 value.)  		     Scan ahead to find a matching LO16 relocation.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_GNU_REL_HI16
condition|)
name|lo
operator|=
name|R_MIPS_GNU_REL_LO16
expr_stmt|;
else|else
name|lo
operator|=
name|R_MIPS_LO16
expr_stmt|;
name|lo16_relocation
operator|=
name|mips_elf_next_relocation
argument_list|(
name|input_bfd
argument_list|,
name|lo
argument_list|,
name|rel
argument_list|,
name|relend
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo16_relocation
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Obtain the addend kept there.  */
name|lo16_howto
operator|=
name|MIPS_ELF_RTYPE_TO_HOWTO
argument_list|(
name|input_bfd
argument_list|,
name|lo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|l
operator|=
name|mips_elf_obtain_contents
argument_list|(
name|lo16_howto
argument_list|,
name|lo16_relocation
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|l
operator|&=
name|lo16_howto
operator|->
name|src_mask
expr_stmt|;
name|l
operator|<<=
name|lo16_howto
operator|->
name|rightshift
expr_stmt|;
name|l
operator|=
name|_bfd_mips_elf_sign_extend
argument_list|(
name|l
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|addend
operator|<<=
literal|16
expr_stmt|;
comment|/* Compute the combined addend.  */
name|addend
operator|+=
name|l
expr_stmt|;
comment|/* If PC-relative, subtract the difference between the 		     address of the LO part of the reloc and the address of 		     the HI part.  The relocation is relative to the LO 		     part, but mips_elf_calculate_relocation() doesn't 		     know its address or the difference from the HI part, so 		     we subtract that difference here.  See also the 		     comment in mips_elf_calculate_relocation().  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_GNU_REL_HI16
condition|)
name|addend
operator|-=
operator|(
name|lo16_relocation
operator|->
name|r_offset
operator|-
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_GPREL
condition|)
block|{
comment|/* The addend is scrambled in the object file.  See 		     mips_elf_perform_relocation for details on the 		     format.  */
name|addend
operator|=
operator|(
operator|(
operator|(
name|addend
operator|&
literal|0x1f0000
operator|)
operator|>>
literal|5
operator|)
operator||
operator|(
operator|(
name|addend
operator|&
literal|0x7e00000
operator|)
operator|>>
literal|16
operator|)
operator||
operator|(
name|addend
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|addend
operator|<<=
name|howto
operator|->
name|rightshift
expr_stmt|;
block|}
else|else
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|rel
operator|->
name|r_offset
operator|-=
literal|4
expr_stmt|;
comment|/* Since we're just relocating, all we need to do is copy 	     the relocations back out to the object file, unless 	     they're against a section symbol, in which case we need 	     to adjust by the section offset, or unless they're GP 	     relative in which case we need to adjust by the amount 	     that we're adjusting GP in this relocatable object.  */
if|if
condition|(
operator|!
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|local_sections
argument_list|,
name|FALSE
argument_list|)
condition|)
comment|/* There's nothing to do for non-local relocations.  */
continue|continue;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_GPREL
operator|||
name|r_type
operator|==
name|R_MIPS_GPREL16
operator|||
name|r_type
operator|==
name|R_MIPS_GPREL32
operator|||
name|r_type
operator|==
name|R_MIPS_LITERAL
condition|)
name|addend
operator|-=
operator|(
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
operator|-
name|_bfd_get_gp_value
argument_list|(
name|input_bfd
argument_list|)
operator|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|output_bfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
comment|/* Adjust the addend appropriately.  */
name|addend
operator|+=
name|local_sections
index|[
name|r_symndx
index|]
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|rela_relocation_p
condition|)
comment|/* If this is a RELA relocation, just update the addend.  */
name|rel
operator|->
name|r_addend
operator|=
name|addend
expr_stmt|;
else|else
block|{
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HI16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT16
operator|||
name|r_type
operator|==
name|R_MIPS_GNU_REL_HI16
condition|)
name|addend
operator|=
name|mips_elf_high
argument_list|(
name|addend
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HIGHER
condition|)
name|addend
operator|=
name|mips_elf_higher
argument_list|(
name|addend
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HIGHEST
condition|)
name|addend
operator|=
name|mips_elf_highest
argument_list|(
name|addend
argument_list|)
expr_stmt|;
else|else
name|addend
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* We use the source mask, rather than the destination 		 mask because the place to which we are writing will be 		 source of the addend in the final link.  */
name|addend
operator|&=
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
comment|/* See the comment above about using R_MIPS_64 in the 32-bit 		   ABI.  Here, we need to update the addend.  It would be 		   possible to get away with just using the R_MIPS_32 reloc 		   but for endianness.  */
block|{
name|bfd_vma
name|sign_bits
decl_stmt|;
name|bfd_vma
name|low_bits
decl_stmt|;
name|bfd_vma
name|high_bits
decl_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|)
ifdef|#
directive|ifdef
name|BFD64
name|sign_bits
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|32
operator|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|sign_bits
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
else|else
name|sign_bits
operator|=
literal|0
expr_stmt|;
comment|/* If we don't know that we have a 64-bit type, 		     do two separate stores.  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Store the sign-bits (which are most significant) 			 first.  */
name|low_bits
operator|=
name|sign_bits
expr_stmt|;
name|high_bits
operator|=
name|addend
expr_stmt|;
block|}
else|else
block|{
name|low_bits
operator|=
name|addend
expr_stmt|;
name|high_bits
operator|=
name|sign_bits
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|low_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|high_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|mips_elf_perform_relocation
argument_list|(
name|info
argument_list|,
name|howto
argument_list|,
name|rel
argument_list|,
name|addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Go on to the next relocation.  */
continue|continue;
block|}
comment|/* In the N32 and 64-bit ABIs there may be multiple consecutive 	 relocations for the same offset.  In that case we are 	 supposed to treat the output of each relocation as the addend 	 for the next.  */
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
name|rel
operator|->
name|r_offset
operator|==
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|&&
name|ELF_R_TYPE
argument_list|(
name|input_bfd
argument_list|,
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|!=
name|R_MIPS_NONE
condition|)
name|use_saved_addend_p
operator|=
name|TRUE
expr_stmt|;
else|else
name|use_saved_addend_p
operator|=
name|FALSE
expr_stmt|;
comment|/* Figure out what value we are supposed to relocate.  */
switch|switch
condition|(
name|mips_elf_calculate_relocation
argument_list|(
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|addend
argument_list|,
name|howto
argument_list|,
name|local_syms
argument_list|,
name|local_sections
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|require_jalx
argument_list|,
name|use_saved_addend_p
argument_list|)
condition|)
block|{
case|case
name|bfd_reloc_continue
case|:
comment|/* There's nothing to do.  */
continue|continue;
case|case
name|bfd_reloc_undefined
case|:
comment|/* mips_elf_calculate_relocation already called the 	     undefined_symbol callback.  There's no real point in 	     trying to perform the relocation at this point, so we 	     just skip ahead to the next relocation.  */
continue|continue;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
name|use_saved_addend_p
condition|)
comment|/* Ignore overflow until we reach the last relocation for 	       a given location.  */
empty_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* If we've got another relocation for the address, keep going 	 until we reach the last one.  */
if|if
condition|(
name|use_saved_addend_p
condition|)
block|{
name|addend
operator|=
name|value
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
comment|/* See the comment above about using R_MIPS_64 in the 32-bit 	   ABI.  Until now, we've been using the HOWTO for R_MIPS_32; 	   that calculated the right value.  Now, however, we 	   sign-extend the 32-bit result to 64-bits, and store it as a 	   64-bit value.  We are especially generous here in that we 	   go to extreme lengths to support this usage on systems with 	   only a 32-bit VMA.  */
block|{
name|bfd_vma
name|sign_bits
decl_stmt|;
name|bfd_vma
name|low_bits
decl_stmt|;
name|bfd_vma
name|high_bits
decl_stmt|;
if|if
condition|(
name|value
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|)
ifdef|#
directive|ifdef
name|BFD64
name|sign_bits
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|32
operator|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|sign_bits
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
else|else
name|sign_bits
operator|=
literal|0
expr_stmt|;
comment|/* If we don't know that we have a 64-bit type, 	     do two separate stores.  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Undo what we did above.  */
name|rel
operator|->
name|r_offset
operator|-=
literal|4
expr_stmt|;
comment|/* Store the sign-bits (which are most significant) 		 first.  */
name|low_bits
operator|=
name|sign_bits
expr_stmt|;
name|high_bits
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|low_bits
operator|=
name|value
expr_stmt|;
name|high_bits
operator|=
name|sign_bits
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|low_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|high_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Actually perform the relocation.  */
if|if
condition|(
operator|!
name|mips_elf_perform_relocation
argument_list|(
name|info
argument_list|,
name|howto
argument_list|,
name|rel
argument_list|,
name|value
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|require_jalx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If NAME is one of the special IRIX6 symbols defined by the linker,    adjust it appropriately now.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_irix6_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
comment|/* The linker script takes care of providing names and values for      these, but we must place them into the right sections.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|text_section_symbols
index|[]
init|=
block|{
literal|"_ftext"
block|,
literal|"_etext"
block|,
literal|"__dso_displacement"
block|,
literal|"__elf_header"
block|,
literal|"__program_header_table"
block|,
name|NULL
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|data_section_symbols
index|[]
init|=
block|{
literal|"_fdata"
block|,
literal|"_edata"
block|,
literal|"_end"
block|,
literal|"_fbss"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
for|for
control|(
name|p
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|text_section_symbols
else|:
name|data_section_symbols
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* All of these symbols are given type STT_SECTION by the 	     IRIX6 linker.  */
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
name|STO_PROTECTED
expr_stmt|;
comment|/* The IRIX linker puts these symbols in special sections.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_TEXT
expr_stmt|;
else|else
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
name|gval
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|,
modifier|*
name|gg
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|gval
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
name|stub
index|[
name|MIPS_FUNCTION_STUB_SIZE
index|]
decl_stmt|;
comment|/* This symbol has a stub.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME: Can h->dynindex be more than 64K?  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|&
literal|0xffff0000
condition|)
return|return
name|FALSE
return|;
comment|/* Fill the stub.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LW
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|stub
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_MOVE
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|stub
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_JALR
argument_list|,
name|stub
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LI16
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|h
operator|->
name|dynindx
argument_list|,
name|stub
operator|+
literal|12
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|<=
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|stub
argument_list|,
name|MIPS_FUNCTION_STUB_SIZE
argument_list|)
expr_stmt|;
comment|/* Mark the symbol as undefined.  plt.offset != -1 occurs 	 only for the referenced symbol.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* The run-time linker uses the st_value field of the symbol 	 to reset the global offset table entry for this external 	 to its stub address when unlinking a shared object.  */
name|gval
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|gval
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Run through the global symbol table, creating GOT entries for all      the symbols that need them.  */
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|>=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
condition|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|offset
operator|=
name|mips_elf_global_got_index
argument_list|(
name|dynobj
argument_list|,
name|output_bfd
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|->
name|next
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|mips_got_entry
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|bfd_vma
name|entry
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|gg
operator|=
name|g
expr_stmt|;
name|e
operator|.
name|abfd
operator|=
name|output_bfd
expr_stmt|;
name|e
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|.
name|d
operator|.
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|g
operator|=
name|g
operator|->
name|next
init|;
name|g
operator|->
name|next
operator|!=
name|gg
condition|;
name|g
operator|=
name|g
operator|->
name|next
control|)
block|{
if|if
condition|(
name|g
operator|->
name|got_entries
operator|&&
operator|(
name|p
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|htab_find
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|e
argument_list|)
operator|)
condition|)
block|{
name|offset
operator|=
name|p
operator|->
name|gotidx
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
name|p
operator|->
name|d
operator|.
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|p
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|p
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Create an R_MIPS_REL32 relocation for this entry.  Due to 		     the various compatibility problems, it's easier to mock 		     up an R_MIPS_32 or R_MIPS_64 relocation and leave 		     mips_elf_create_dynamic_relocation to calculate the 		     appropriate addend.  */
name|Elf_Internal_Rela
name|rel
index|[
literal|3
index|]
decl_stmt|;
name|memset
argument_list|(
name|rel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|rel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|R_MIPS_64
argument_list|)
expr_stmt|;
else|else
name|rel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|R_MIPS_32
argument_list|)
expr_stmt|;
name|rel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|entry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mips_elf_create_dynamic_relocation
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|e
operator|.
name|d
operator|.
name|h
argument_list|,
name|NULL
argument_list|,
name|sym
operator|->
name|st_value
argument_list|,
operator|&
name|entry
argument_list|,
name|sgot
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
name|entry
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|entry
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC_LINKING"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
name|STO_PROTECTED
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
name|STO_PROTECTED
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_ABS
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_OBJECT
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
block|}
block|}
comment|/* Handle the IRIX6-specific symbols.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_irix6
condition|)
name|mips_elf_irix6_finish_dynamic_symbol
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__rld_map"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__RLD_MAP"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rld_map"
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|==
literal|0
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__rld_obj_head"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* IRIX6 does not use a .rld_map section.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_irix5
operator|||
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_none
condition|)
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rld_map"
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
comment|/* If this is a mips16 symbol, force the value to be even.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
operator|&&
operator|(
name|sym
operator|->
name|st_value
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|--
name|sym
operator|->
name|st_value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|gg
decl_stmt|,
modifier|*
name|g
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|gg
operator|=
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gg
operator|=
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_got_for_ibfd
argument_list|(
name|gg
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd_byte
modifier|*
name|b
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|sdyn
operator|->
name|contents
init|;
name|b
operator|<
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
condition|;
name|b
operator|+=
name|MIPS_ELF_DYN_SIZE
argument_list|(
name|dynobj
argument_list|)
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|elemsize
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|swap_out_p
decl_stmt|;
comment|/* Read in the current dynamic entry.  */
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_in
operator|)
operator|(
name|dynobj
operator|,
name|b
operator|,
operator|&
name|dyn
operator|)
expr_stmt|;
comment|/* Assume that we're going to modify it and write it out.  */
name|swap_out_p
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_RELENT
case|:
name|s
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|MIPS_ELF_REL_SIZE
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_STRSZ
case|:
comment|/* Rewrite DT_STRSZ.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_MIPS_RLD_VERSION
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|DT_MIPS_FLAGS
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|RHF_NOTPOT
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|DT_MIPS_TIME_STAMP
case|:
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_ICHECKSUM
case|:
comment|/* XXX FIXME: */
name|swap_out_p
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DT_MIPS_IVERSION
case|:
comment|/* XXX FIXME: */
name|swap_out_p
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DT_MIPS_BASE_ADDRESS
case|:
name|s
operator|=
name|output_bfd
operator|->
name|sections
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffff
expr_stmt|;
break|break;
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
expr_stmt|;
break|break;
case|case
name|DT_MIPS_UNREFEXTNO
case|:
comment|/* The index into the dynamic symbol table which is the 		 entry of the first external symbol that is not 		 referenced within the same object.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|bfd_count_sections
argument_list|(
name|output_bfd
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|DT_MIPS_GOTSYM
case|:
if|if
condition|(
name|gg
operator|->
name|global_gotsym
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|gg
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
break|break;
block|}
comment|/* In case if we don't have global got symbols we default 		 to setting DT_MIPS_GOTSYM to the same value as 		 DT_MIPS_SYMTABNO, so we just fall through.  */
case|case
name|DT_MIPS_SYMTABNO
case|:
name|name
operator|=
literal|".dynsym"
expr_stmt|;
name|elemsize
operator|=
name|MIPS_ELF_SYM_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
operator|/
name|elemsize
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
operator|/
name|elemsize
expr_stmt|;
break|break;
case|case
name|DT_MIPS_HIPAGENO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
operator|-
name|MIPS_RESERVED_GOTNO
expr_stmt|;
break|break;
case|case
name|DT_MIPS_RLD_MAP
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
expr_stmt|;
break|break;
case|case
name|DT_MIPS_OPTIONS
case|:
name|s
operator|=
operator|(
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_RELSZ
case|:
comment|/* Reduce DT_RELSZ to account for any relocations we 		 decided not to make.  This is for the n64 irix rld, 		 which doesn't seem to apply any relocations if there 		 are trailing null entries.  */
name|s
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
operator|(
name|s
operator|->
name|reloc_count
operator|*
operator|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|swap_out_p
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|swap_out_p
condition|)
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_out
operator|)
operator|(
name|dynobj
operator|,
operator|&
name|dyn
operator|,
name|b
operator|)
expr_stmt|;
block|}
block|}
comment|/* The first entry of the global offset table will be filled at      runtime. The second entry will be used by some runtime loaders.      This isn't the case of IRIX rld.  */
if|if
condition|(
name|sgot
operator|!=
name|NULL
operator|&&
name|sgot
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
literal|0x80000000
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sgot
operator|!=
name|NULL
condition|)
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* Generate dynamic relocations for the non-primary gots.  */
if|if
condition|(
name|gg
operator|!=
name|NULL
operator|&&
name|gg
operator|->
name|next
condition|)
block|{
name|Elf_Internal_Rela
name|rel
index|[
literal|3
index|]
decl_stmt|;
name|bfd_vma
name|addend
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|rel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|rel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|R_MIPS_REL32
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|gg
operator|->
name|next
init|;
name|g
operator|->
name|next
operator|!=
name|gg
condition|;
name|g
operator|=
name|g
operator|->
name|next
control|)
block|{
name|bfd_vma
name|index
init|=
name|g
operator|->
name|next
operator|->
name|local_gotno
operator|+
name|g
operator|->
name|next
operator|->
name|global_gotno
decl_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|index
operator|++
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
literal|0x80000000
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|index
operator|++
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
continue|continue;
while|while
condition|(
name|index
operator|<
name|g
operator|->
name|assigned_gotno
condition|)
block|{
name|rel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|index
operator|++
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mips_elf_create_dynamic_relocation
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|NULL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
literal|0
argument_list|,
operator|&
name|addend
argument_list|,
name|sgot
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|addend
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf32_compact_rel
name|cpt
decl_stmt|;
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
comment|/* Write .compact_rel section out.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".compact_rel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|cpt
operator|.
name|id1
operator|=
literal|1
expr_stmt|;
name|cpt
operator|.
name|num
operator|=
name|s
operator|->
name|reloc_count
expr_stmt|;
name|cpt
operator|.
name|id2
operator|=
literal|2
expr_stmt|;
name|cpt
operator|.
name|offset
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|filepos
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
operator|)
expr_stmt|;
name|cpt
operator|.
name|reserved0
operator|=
literal|0
expr_stmt|;
name|cpt
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_compact_rel_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|cpt
argument_list|,
operator|(
operator|(
name|Elf32_External_compact_rel
operator|*
operator|)
name|s
operator|->
name|contents
operator|)
argument_list|)
expr_stmt|;
comment|/* Clean up a dummy stub function entry in .text.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|file_ptr
name|dummy_offset
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|_raw_size
operator|>=
name|MIPS_FUNCTION_STUB_SIZE
argument_list|)
expr_stmt|;
name|dummy_offset
operator|=
name|s
operator|->
name|_raw_size
operator|-
name|MIPS_FUNCTION_STUB_SIZE
expr_stmt|;
name|memset
argument_list|(
name|s
operator|->
name|contents
operator|+
name|dummy_offset
argument_list|,
literal|0
argument_list|,
name|MIPS_FUNCTION_STUB_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* We need to sort the entries of the dynamic relocation section.  */
name|s
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|>
operator|(
name|bfd_vma
operator|)
literal|2
operator|*
name|MIPS_ELF_REL_SIZE
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|reldyn_sorting_bfd
operator|=
name|output_bfd
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|qsort
argument_list|(
operator|(
name|Elf64_External_Rel
operator|*
operator|)
name|s
operator|->
name|contents
operator|+
literal|1
argument_list|,
name|s
operator|->
name|reloc_count
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
argument_list|,
name|sort_dynamic_relocs_64
argument_list|)
expr_stmt|;
else|else
name|qsort
argument_list|(
operator|(
name|Elf32_External_Rel
operator|*
operator|)
name|s
operator|->
name|contents
operator|+
literal|1
argument_list|,
name|s
operator|->
name|reloc_count
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|,
name|sort_dynamic_relocs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set ABFD's EF_MIPS_ARCH and EF_MIPS_MACH flags.  */
end_comment

begin_function
specifier|static
name|void
name|mips_set_isa_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|flagword
name|val
decl_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
name|bfd_mach_mips3000
case|:
name|val
operator|=
name|E_MIPS_ARCH_1
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips3900
case|:
name|val
operator|=
name|E_MIPS_ARCH_1
operator||
name|E_MIPS_MACH_3900
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips6000
case|:
name|val
operator|=
name|E_MIPS_ARCH_2
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4000
case|:
case|case
name|bfd_mach_mips4300
case|:
case|case
name|bfd_mach_mips4400
case|:
case|case
name|bfd_mach_mips4600
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4010
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4010
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4100
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4100
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4111
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4111
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4120
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4120
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4650
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4650
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips5400
case|:
name|val
operator|=
name|E_MIPS_ARCH_4
operator||
name|E_MIPS_MACH_5400
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips5500
case|:
name|val
operator|=
name|E_MIPS_ARCH_4
operator||
name|E_MIPS_MACH_5500
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips5000
case|:
case|case
name|bfd_mach_mips7000
case|:
case|case
name|bfd_mach_mips8000
case|:
case|case
name|bfd_mach_mips10000
case|:
case|case
name|bfd_mach_mips12000
case|:
name|val
operator|=
name|E_MIPS_ARCH_4
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips5
case|:
name|val
operator|=
name|E_MIPS_ARCH_5
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips_sb1
case|:
name|val
operator|=
name|E_MIPS_ARCH_64
operator||
name|E_MIPS_MACH_SB1
expr_stmt|;
break|break;
case|case
name|bfd_mach_mipsisa32
case|:
name|val
operator|=
name|E_MIPS_ARCH_32
expr_stmt|;
break|break;
case|case
name|bfd_mach_mipsisa64
case|:
name|val
operator|=
name|E_MIPS_ARCH_64
expr_stmt|;
break|break;
case|case
name|bfd_mach_mipsisa32r2
case|:
name|val
operator|=
name|E_MIPS_ARCH_32R2
expr_stmt|;
break|break;
case|case
name|bfd_mach_mipsisa64r2
case|:
name|val
operator|=
name|E_MIPS_ARCH_64R2
expr_stmt|;
break|break;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out a MIPS ELF object    file.  This gets the MIPS architecture right based on the machine    number.  This is used by both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|void
name|_bfd_mips_elf_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Keep the existing EF_MIPS_MACH and EF_MIPS_ARCH flags if the former      is nonzero.  This is for compatibility with old objects, which used      a combination of a 32-bit EF_MIPS_ARCH and a 64-bit EF_MIPS_MACH.  */
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_MACH
operator|)
operator|==
literal|0
condition|)
name|mips_set_isa_flags
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Set the sh_info field for .gptab sections and other appropriate      info for each special section.  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_MIPS_MSYM
case|:
case|case
name|SHT_MIPS_LIBLIST
case|:
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_GPTAB
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_CONTENT
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|,
sizeof|sizeof
expr|".MIPS.content"
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".MIPS.content"
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".liblist"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_EVENTS
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|,
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|,
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
operator|(
name|name
operator|+
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When creating an IRIX5 executable, we need REGINFO and RTPROC    segments.  */
end_comment

begin_function
name|int
name|_bfd_mips_elf_additional_program_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* See if we need a PT_MIPS_REGINFO segment.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
operator|++
name|ret
expr_stmt|;
comment|/* See if we need a PT_MIPS_OPTIONS segment.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
operator|++
name|ret
expr_stmt|;
comment|/* See if we need a PT_MIPS_RTPROC segment.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
condition|)
operator|++
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Modify the segment map for an IRIX5 executable.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_modify_segment_map
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|pm
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* If there is a .reginfo section, we need a PT_MIPS_REGINFO      segment.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_MIPS_REGINFO
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
expr|*
name|m
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_MIPS_REGINFO
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
comment|/* We want to put it after the PHDR and INTERP segments.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_PHDR
operator|||
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_INTERP
operator|)
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
comment|/* For IRIX 6, we don't have .mdebug sections, nor does anything but      .dynamic end up in PT_DYNAMIC.  However, we do have to insert a      PT_MIPS_OPTIONS segment immediately following the program header      table.  */
if|if
condition|(
name|NEWABI_P
argument_list|(
name|abfd
argument_list|)
comment|/* On non-IRIX6 new abi, we'll have already created a segment 	 for this section, so don't create another.  I'm not sure this 	 is not also the case for IRIX 6, but I can't test it right 	 now.  */
operator|&&
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
condition|)
block|{
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_MIPS_OPTIONS
condition|)
break|break;
if|if
condition|(
name|s
condition|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|options_segment
decl_stmt|;
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_PHDR
operator|||
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_INTERP
operator|)
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|options_segment
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|options_segment
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
name|options_segment
operator|->
name|p_type
operator|=
name|PT_MIPS_OPTIONS
expr_stmt|;
name|options_segment
operator|->
name|p_flags
operator|=
name|PF_R
expr_stmt|;
name|options_segment
operator|->
name|p_flags_valid
operator|=
name|TRUE
expr_stmt|;
name|options_segment
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|options_segment
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
operator|*
name|pm
operator|=
name|options_segment
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
condition|)
block|{
comment|/* If there are .dynamic and .mdebug sections, we make a room 	     for the RTPROC header.  FIXME: Rewrite without section names.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
operator|==
name|NULL
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|!=
name|NULL
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_MIPS_RTPROC
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
expr|*
name|m
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_MIPS_RTPROC
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
block|}
comment|/* We want to put it after the DYNAMIC segment.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|!=
name|PT_DYNAMIC
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|pm
operator|!=
name|NULL
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
block|}
comment|/* On IRIX5, the PT_DYNAMIC segment includes the .dynamic, 	 .dynstr, .dynsym, and .hash sections, and everything in 	 between.  */
for|for
control|(
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
operator|*
name|pm
operator|!=
name|NULL
condition|;
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_DYNAMIC
condition|)
break|break;
name|m
operator|=
operator|*
name|pm
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_none
condition|)
block|{
comment|/* For a normal mips executable the permissions for the PT_DYNAMIC 	     segment are read, write and execute. We do that here since 	     the code in elf.c sets only the read permission. This matters 	     sometimes for the dynamic linker.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|p_flags
operator|=
name|PF_R
operator||
name|PF_W
operator||
name|PF_X
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|count
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|sec_names
index|[]
init|=
block|{
literal|".dynamic"
block|,
literal|".dynstr"
block|,
literal|".dynsym"
block|,
literal|".hash"
block|}
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|n
decl_stmt|;
name|low
operator|=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|sec_names
operator|/
sizeof|sizeof
name|sec_names
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sec_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
if|if
condition|(
name|low
operator|>
name|s
operator|->
name|vma
condition|)
name|low
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|sz
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
name|sz
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|high
operator|<
name|s
operator|->
name|vma
operator|+
name|sz
condition|)
name|high
operator|=
name|s
operator|->
name|vma
operator|+
name|sz
expr_stmt|;
block|}
block|}
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|vma
operator|>=
name|low
operator|&&
operator|(
operator|(
name|s
operator|->
name|vma
operator|+
operator|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
operator|)
operator|<=
name|high
operator|)
condition|)
operator|++
name|c
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
expr|*
name|n
operator|+
call|(
name|bfd_size_type
call|)
argument_list|(
name|c
operator|-
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|n
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
operator|*
name|n
operator|=
operator|*
name|m
expr_stmt|;
name|n
operator|->
name|count
operator|=
name|c
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|vma
operator|>=
name|low
operator|&&
operator|(
operator|(
name|s
operator|->
name|vma
operator|+
operator|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
operator|)
operator|<=
name|high
operator|)
condition|)
block|{
name|n
operator|->
name|sections
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
operator|*
name|pm
operator|=
name|n
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
name|asection
modifier|*
name|_bfd_mips_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
comment|/* ??? Do mips16 stub sections need to be handled special?  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF_R_TYPE
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
case|case
name|R_MIPS_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
literal|0
block|Elf_Internal_Shdr *symtab_hdr;   struct elf_link_hash_entry **sym_hashes;   bfd_signed_vma *local_got_refcounts;   const Elf_Internal_Rela *rel, *relend;   unsigned long r_symndx;   struct elf_link_hash_entry *h;    symtab_hdr =&elf_tdata (abfd)->symtab_hdr;   sym_hashes = elf_sym_hashes (abfd);   local_got_refcounts = elf_local_got_refcounts (abfd);    relend = relocs + sec->reloc_count;   for (rel = relocs; rel< relend; rel++)     switch (ELF_R_TYPE (abfd, rel->r_info))       {       case R_MIPS_GOT16:       case R_MIPS_CALL16:       case R_MIPS_CALL_HI16:       case R_MIPS_CALL_LO16:       case R_MIPS_GOT_HI16:       case R_MIPS_GOT_LO16:       case R_MIPS_GOT_DISP:       case R_MIPS_GOT_PAGE:       case R_MIPS_GOT_OFST:
comment|/* ??? It would seem that the existing MIPS code does no sort 	   of reference counting or whatnot on its GOT and PLT entries, 	   so it is not possible to garbage collect them at this time.  */
block|break;        default: 	break;       }
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy data from a MIPS ELF indirect symbol to its direct symbol,    hiding the old indirect symbol.  Process additional relocation    information.  Also called for weakdefs, in which case we just let    _bfd_elf_link_hash_copy_indirect copy the flags for us.  */
end_comment

begin_function
name|void
name|_bfd_mips_elf_copy_indirect_symbol
parameter_list|(
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|dirmips
decl_stmt|,
modifier|*
name|indmips
decl_stmt|;
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|bed
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
condition|)
return|return;
name|dirmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|indmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
name|dirmips
operator|->
name|possibly_dynamic_relocs
operator|+=
name|indmips
operator|->
name|possibly_dynamic_relocs
expr_stmt|;
if|if
condition|(
name|indmips
operator|->
name|readonly_reloc
condition|)
name|dirmips
operator|->
name|readonly_reloc
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|indmips
operator|->
name|no_fn_stub
condition|)
name|dirmips
operator|->
name|no_fn_stub
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_bfd_mips_elf_hide_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|entry
parameter_list|,
name|bfd_boolean
name|force_local
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|got
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|forced_local
condition|)
return|return;
name|h
operator|->
name|forced_local
operator|=
name|force_local
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|!=
name|NULL
operator|&&
name|force_local
condition|)
block|{
name|got
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|got
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|next
condition|)
block|{
name|struct
name|mips_got_entry
name|e
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|gg
init|=
name|g
decl_stmt|;
comment|/* Since we're turning what used to be a global symbol into a 	     local one, bump up the number of local entries of each GOT 	     that had an entry for it.  This will automatically decrease 	     the number of global entries, since global_gotno is actually 	     the upper limit of global entries.  */
name|e
operator|.
name|abfd
operator|=
name|dynobj
expr_stmt|;
name|e
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|.
name|d
operator|.
name|h
operator|=
name|h
expr_stmt|;
for|for
control|(
name|g
operator|=
name|g
operator|->
name|next
init|;
name|g
operator|!=
name|gg
condition|;
name|g
operator|=
name|g
operator|->
name|next
control|)
if|if
condition|(
name|htab_find
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|e
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|global_gotno
operator|>
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|--
expr_stmt|;
block|}
comment|/* If this was a global symbol forced into the primary GOT, we 	     no longer need an entry for it.  We can't release the entry 	     at this point, but we must at least stop counting it as one 	     of the symbols that required a forced got entry.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|==
literal|2
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|gg
operator|->
name|assigned_gotno
operator|>
literal|0
argument_list|)
expr_stmt|;
name|gg
operator|->
name|assigned_gotno
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|global_gotno
operator|==
literal|0
operator|&&
name|g
operator|->
name|global_gotsym
operator|==
name|NULL
condition|)
comment|/* If we haven't got through GOT allocation yet, just bump up the 	   number of local entries, as this symbol won't be counted as 	   global.  */
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|==
literal|1
condition|)
block|{
comment|/* If we're past non-multi-GOT allocation and this symbol had 	     been marked for a global got entry, give it a local entry 	     instead.  */
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|global_gotno
operator|>
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|--
expr_stmt|;
block|}
block|}
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|root
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|PDR_SIZE
value|32
end_define

begin_function
name|bfd_boolean
name|_bfd_mips_elf_discard_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|elf_reloc_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|bfd_boolean
name|ret
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tdata
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|skip
decl_stmt|;
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".pdr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|o
operator|->
name|_raw_size
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|o
operator|->
name|_raw_size
operator|%
name|PDR_SIZE
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|o
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|tdata
operator|=
name|bfd_zmalloc
argument_list|(
name|o
operator|->
name|_raw_size
operator|/
name|PDR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tdata
condition|)
return|return
name|FALSE
return|;
name|cookie
operator|->
name|rels
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cookie
operator|->
name|rels
condition|)
block|{
name|free
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|cookie
operator|->
name|rel
operator|=
name|cookie
operator|->
name|rels
expr_stmt|;
name|cookie
operator|->
name|relend
operator|=
name|cookie
operator|->
name|rels
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|skip
operator|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|_raw_size
operator|/
name|PDR_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfd_elf_reloc_symbol_deleted_p
argument_list|(
name|i
operator|*
name|PDR_SIZE
argument_list|,
name|cookie
argument_list|)
condition|)
block|{
name|tdata
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|skip
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|mips_elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|=
name|tdata
expr_stmt|;
name|o
operator|->
name|_cooked_size
operator|=
name|o
operator|->
name|_raw_size
operator|-
name|skip
operator|*
name|PDR_SIZE
expr_stmt|;
name|ret
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|cookie
operator|->
name|rels
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_mips_elf_ignore_discarded_relocs
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".pdr"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_mips_elf_write_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".pdr"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|mips_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|to
operator|=
name|contents
expr_stmt|;
name|end
operator|=
name|contents
operator|+
name|sec
operator|->
name|_raw_size
expr_stmt|;
for|for
control|(
name|from
operator|=
name|contents
operator|,
name|i
operator|=
literal|0
init|;
name|from
operator|<
name|end
condition|;
name|from
operator|+=
name|PDR_SIZE
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mips_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|)
index|[
name|i
index|]
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|to
operator|!=
name|from
condition|)
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|PDR_SIZE
argument_list|)
expr_stmt|;
name|to
operator|+=
name|PDR_SIZE
expr_stmt|;
block|}
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* MIPS ELF uses a special find_nearest_line routine in order the    handle the ECOFF debugging information.  */
end_comment

begin_struct
struct|struct
name|mips_elf_find_line
block|{
name|struct
name|ecoff_debug_info
name|d
decl_stmt|;
name|struct
name|ecoff_find_line
name|i
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|bfd_boolean
name|_bfd_mips_elf_find_nearest_line
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|line_ptr
parameter_list|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
if|if
condition|(
name|_bfd_dwarf1_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|_bfd_dwarf2_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|?
literal|8
else|:
literal|0
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf2_find_line_info
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msec
operator|!=
name|NULL
condition|)
block|{
name|flagword
name|origflags
decl_stmt|;
name|struct
name|mips_elf_find_line
modifier|*
name|fi
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
comment|/* If we are called during a link, mips_elf_final_link may have 	 cleared the SEC_HAS_CONTENTS field.  We force it back on here 	 if appropriate (which it normally will be).  */
name|origflags
operator|=
name|msec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|msec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|msec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|fi
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|external_fdr_size
decl_stmt|;
name|char
modifier|*
name|fraw_src
decl_stmt|;
name|char
modifier|*
name|fraw_end
decl_stmt|;
name|struct
name|fdr
modifier|*
name|fdr_ptr
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_find_line
argument_list|)
decl_stmt|;
name|fi
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_mips_elf_read_ecoff_info
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Swap in the FDR information.  */
name|amt
operator|=
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fdr
argument_list|)
expr_stmt|;
name|fi
operator|->
name|d
operator|.
name|fdr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|d
operator|.
name|fdr
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|external_fdr_size
operator|=
name|swap
operator|->
name|external_fdr_size
expr_stmt|;
name|fdr_ptr
operator|=
name|fi
operator|->
name|d
operator|.
name|fdr
expr_stmt|;
name|fraw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|fi
operator|->
name|d
operator|.
name|external_fdr
expr_stmt|;
name|fraw_end
operator|=
operator|(
name|fraw_src
operator|+
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
name|external_fdr_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|fraw_src
operator|<
name|fraw_end
condition|;
name|fraw_src
operator|+=
name|external_fdr_size
operator|,
name|fdr_ptr
operator|++
control|)
call|(
modifier|*
name|swap
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|fraw_src
argument_list|,
name|fdr_ptr
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
operator|=
name|fi
expr_stmt|;
comment|/* Note that we don't bother to ever free this information.              find_nearest_line is either called all the time, as in              objdump -l, so the information should be saved, or it is              rarely called, as in ld error messages, so the memory              wasted is unimportant.  Still, it would probably be a              good idea for free_cached_info to throw it away.  */
block|}
if|if
condition|(
name|_bfd_ecoff_locate_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|,
name|swap
argument_list|,
operator|&
name|fi
operator|->
name|i
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
block|}
comment|/* Fall back on the generic ELF find_nearest_line routine.  */
return|return
name|_bfd_elf_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When are writing out the .options or .MIPS.options section,    remember the bytes we are writing out, so that we can install the    GP value in the section_processing routine.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_set_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
specifier|const
name|void
modifier|*
name|location
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_elf_section_data
argument_list|)
decl_stmt|;
name|section
operator|->
name|used_by_bfd
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|c
operator|=
name|mips_elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|u
operator|.
name|tdata
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|size
operator|=
name|section
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|size
operator|=
name|section
operator|->
name|_raw_size
expr_stmt|;
name|c
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|mips_elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|=
name|c
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|c
operator|+
name|offset
argument_list|,
name|location
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|_bfd_elf_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is almost identical to bfd_generic_get_... except that some    MIPS relocations need to be handled specially.  Sigh.  */
end_comment

begin_function
name|bfd_byte
modifier|*
name|_bfd_elf_mips_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
comment|/* Get enough memory to hold the stuff */
name|bfd
modifier|*
name|input_bfd
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|long
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
name|NULL
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|reloc_vector
operator|=
name|bfd_malloc
argument_list|(
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_vector
operator|==
name|NULL
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* read in the section */
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* We're not relaxing the section, so just copy the size info */
name|input_section
operator|->
name|_cooked_size
operator|=
name|input_section
operator|->
name|_raw_size
expr_stmt|;
name|input_section
operator|->
name|reloc_done
operator|=
name|TRUE
expr_stmt|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
decl_stmt|;
comment|/* for mips */
name|int
name|gp_found
decl_stmt|;
name|bfd_vma
name|gp
init|=
literal|0x12345678
decl_stmt|;
comment|/* initialize just to shut gcc up */
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|lh
decl_stmt|;
comment|/* Skip all this stuff if we aren't mixing formats.  */
if|if
condition|(
name|abfd
operator|&&
name|input_bfd
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|input_bfd
operator|->
name|xvec
condition|)
name|lh
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|h
operator|=
name|bfd_hash_lookup
argument_list|(
operator|&
name|link_info
operator|->
name|hash
operator|->
name|table
argument_list|,
literal|"_gp"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|lh
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
block|}
name|lookup
label|:
if|if
condition|(
name|lh
condition|)
block|{
switch|switch
condition|(
name|lh
operator|->
name|type
condition|)
block|{
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
case|case
name|bfd_link_hash_common
case|:
name|gp_found
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|gp_found
operator|=
literal|1
expr_stmt|;
name|gp
operator|=
name|lh
operator|->
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
case|case
name|bfd_link_hash_warning
case|:
name|lh
operator|=
name|lh
operator|->
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* @@FIXME  ignoring warning for now */
goto|goto
name|lookup
goto|;
case|case
name|bfd_link_hash_new
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|gp_found
operator|=
literal|0
expr_stmt|;
block|}
comment|/* end mips */
for|for
control|(
name|parent
operator|=
name|reloc_vector
init|;
operator|*
name|parent
operator|!=
name|NULL
condition|;
name|parent
operator|++
control|)
block|{
name|char
modifier|*
name|error_message
init|=
name|NULL
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
comment|/* Specific to MIPS: Deal with relocation types that require 	     knowing the gp of the output bfd.  */
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|&&
name|abfd
condition|)
block|{
comment|/* The special_function wouldn't get called anyway.  */
block|}
elseif|else
if|if
condition|(
operator|!
name|gp_found
condition|)
block|{
comment|/* The gp isn't there; let the special function code 		 fall over on its own.  */
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|parent
operator|)
operator|->
name|howto
operator|->
name|special_function
operator|==
name|_bfd_mips_elf32_gprel16_reloc
condition|)
block|{
comment|/* bypass special_function call */
name|r
operator|=
name|_bfd_mips_elf_gprel16_with_gp
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|,
operator|*
name|parent
argument_list|,
name|input_section
argument_list|,
name|relocatable
argument_list|,
name|data
argument_list|,
name|gp
argument_list|)
expr_stmt|;
goto|goto
name|skip_bfd_perform_relocation
goto|;
block|}
comment|/* end mips specific stuff */
name|r
operator|=
name|bfd_perform_relocation
argument_list|(
name|input_bfd
argument_list|,
operator|*
name|parent
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|relocatable
condition|?
name|abfd
else|:
name|NULL
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
name|skip_bfd_perform_relocation
label|:
if|if
condition|(
name|relocatable
condition|)
block|{
name|asection
modifier|*
name|os
init|=
name|input_section
operator|->
name|output_section
decl_stmt|;
comment|/* A partial link, so keep the relocs */
name|os
operator|->
name|orelocation
index|[
name|os
operator|->
name|reloc_count
index|]
operator|=
operator|*
name|parent
expr_stmt|;
name|os
operator|->
name|reloc_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|BFD_ASSERT
argument_list|(
name|error_message
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|link_info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|howto
operator|->
name|name
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a MIPS ELF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_mips_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|mips_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|mips_elf_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|#
directive|if
literal|0
comment|/* We no longer use this.  */
block|for (i = 0; i< SIZEOF_MIPS_DYNSYM_SECNAMES; i++)     ret->dynsym_sec_strindex[i] = (bfd_size_type) -1;
endif|#
directive|endif
name|ret
operator|->
name|procedure_count
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|compact_rel_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|use_rld_obj_head
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|rld_value
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|mips16_stubs_seen
operator|=
name|FALSE
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We need to use a special link routine to handle the .reginfo and    the .mdebug sections.  We need to merge all instances of these    sections together, not write them all out sequentially.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_final_link
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|reginfo_sec
decl_stmt|,
modifier|*
name|mdebug_sec
decl_stmt|,
modifier|*
name|gptab_data_sec
decl_stmt|,
modifier|*
name|gptab_bss_sec
decl_stmt|;
name|asection
modifier|*
name|rtproc_sec
decl_stmt|;
name|Elf32_RegInfo
name|reginfo
decl_stmt|;
name|struct
name|ecoff_debug_info
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
name|HDRR
modifier|*
name|symhdr
init|=
operator|&
name|debug
operator|.
name|symbolic_header
decl_stmt|;
name|void
modifier|*
name|mdebug_handle
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|EXTR
name|esym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|secname
index|[]
init|=
block|{
literal|".text"
block|,
literal|".init"
block|,
literal|".fini"
block|,
literal|".data"
block|,
literal|".rodata"
block|,
literal|".sdata"
block|,
literal|".sbss"
block|,
literal|".bss"
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|sc
index|[]
init|=
block|{
name|scText
block|,
name|scInit
block|,
name|scFini
block|,
name|scData
block|,
name|scRData
block|,
name|scSData
block|,
name|scSBss
block|,
name|scBss
block|}
decl_stmt|;
comment|/* We'd carefully arranged the dynamic symbol indices, and then the      generic size_dynamic_sections renumbered them out from under us.      Rather than trying somehow to prevent the renumbering, just do      the sort again.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|got
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
comment|/* When we resort, we must tell mips_elf_sort_hash_table what 	 the lowest index it may use is.  That's the number of section 	 symbols we're going to add.  The generic ELF linker only 	 adds these symbols when building a shared object.  Note that 	 we count the sections after (possibly) removing the .options 	 section above.  */
if|if
condition|(
operator|!
name|mips_elf_sort_hash_table
argument_list|(
name|info
argument_list|,
operator|(
name|info
operator|->
name|shared
condition|?
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
else|:
literal|1
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Make sure we didn't grow the global .got region.  */
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|got
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|got
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|BFD_ASSERT
argument_list|(
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|-
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
operator|)
operator|<=
name|g
operator|->
name|global_gotno
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* We want to set the GP value for ld -r.  */
comment|/* On IRIX5, we omit the .options section.  On IRIX6, however, we      include it, even though we don't process it quite right.  (Some      entries are supposed to be merged.)  Empirically, we seem to be      better off including it then not.  */
block|if (IRIX_COMPAT (abfd) == ict_irix5 || IRIX_COMPAT (abfd) == ict_none)     for (secpp =&abfd->sections; *secpp != NULL; secpp =&(*secpp)->next)       { 	if (strcmp ((*secpp)->name, MIPS_ELF_OPTIONS_SECTION_NAME (abfd)) == 0) 	  { 	    for (p = (*secpp)->link_order_head; p != NULL; p = p->next) 	      if (p->type == bfd_indirect_link_order) 		p->u.indirect.section->flags&= ~SEC_HAS_CONTENTS; 	    (*secpp)->link_order_head = NULL; 	    bfd_section_list_remove (abfd, secpp); 	    --abfd->section_count;  	    break; 	  }       }
comment|/* We include .MIPS.options, even though we don't process it quite right.      (Some entries are supposed to be merged.)  At IRIX6 empirically we seem      to be better off including it than not.  */
block|for (secpp =&abfd->sections; *secpp != NULL; secpp =&(*secpp)->next)     {       if (strcmp ((*secpp)->name, ".MIPS.options") == 0) 	{ 	  for (p = (*secpp)->link_order_head; p != NULL; p = p->next) 	    if (p->type == bfd_indirect_link_order) 	      p->u.indirect.section->flags&=~ SEC_HAS_CONTENTS; 	  (*secpp)->link_order_head = NULL; 	  bfd_section_list_remove (abfd, secpp); 	  --abfd->section_count;  	  break; 	}     }
endif|#
directive|endif
comment|/* Get a value for the GP register.  */
if|if
condition|(
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
name|bfd_vma
name|lo
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* Find the GP-relative section with the lowest offset.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|o
operator|->
name|vma
operator|<
name|lo
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator|&
name|SHF_MIPS_GPREL
operator|)
condition|)
name|lo
operator|=
name|o
operator|->
name|vma
expr_stmt|;
comment|/* And calculate GP relative to that.  */
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|lo
operator|+
name|ELF_MIPS_GP_OFFSET
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the relocate_section function needs to do a reloc 	     involving the GP value, it should make a reloc_dangerous 	     callback to warn that GP is not defined.  */
block|}
block|}
comment|/* Go through the sections and collect the .reginfo and .mdebug      information.  */
name|reginfo_sec
operator|=
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_data_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_bss_sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|reginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|reginfo
argument_list|)
expr_stmt|;
comment|/* We have found the .reginfo section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|Elf32_RegInfo
name|sub
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_data_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
comment|/* The linker emulation code has probably clobbered the                  size to be zero bytes.  */
if|if
condition|(
name|input_section
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|input_section
operator|->
name|_raw_size
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|ext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|ext
argument_list|,
operator|&
name|sub
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gprmask
operator||=
name|sub
operator|.
name|ri_gprmask
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|0
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|1
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|2
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|3
index|]
expr_stmt|;
comment|/* ri_gp_value is set by the function 		 mips_elf32_section_processing when the section is 		 finally written out.  */
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Size has been set in _bfd_mips_elf_always_size_sections.  */
name|BFD_ASSERT
argument_list|(
name|o
operator|->
name|_raw_size
operator|==
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
name|NULL
expr_stmt|;
name|reginfo_sec
operator|=
name|o
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|extsym_info
name|einfo
decl_stmt|;
name|bfd_vma
name|last
decl_stmt|;
comment|/* We have found the .mdebug section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
name|symhdr
operator|->
name|magic
operator|=
name|swap
operator|->
name|sym_magic
expr_stmt|;
comment|/* FIXME: What should the version stamp be?  */
name|symhdr
operator|->
name|vstamp
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ilineMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|idnMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ipdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|isymMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ioptMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ifdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
comment|/* We accumulate the debugging information itself in the 	     debug_info structure.  */
name|debug
operator|.
name|line
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_dnr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_pdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_sym
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_opt
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_aux
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ss
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ssext
operator|=
name|debug
operator|.
name|ssext_end
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_rfd
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_ext
operator|=
name|debug
operator|.
name|external_ext_end
operator|=
name|NULL
expr_stmt|;
name|mdebug_handle
operator|=
name|bfd_ecoff_debug_init
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdebug_handle
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|iss
operator|=
name|issNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLocal
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|secname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|secname
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|sc
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|secname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|last
operator|=
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|secname
index|[
name|i
index|]
argument_list|,
operator|&
name|esym
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|input_swap
decl_stmt|;
name|struct
name|ecoff_debug_info
name|input_debug
decl_stmt|;
name|char
modifier|*
name|eraw_src
decl_stmt|;
name|char
modifier|*
name|eraw_end
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_data_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* I don't know what a non MIPS ELF bfd would be 		     doing with a .mdebug section, but I don't really 		     want to deal with it.  */
continue|continue;
block|}
name|input_swap
operator|=
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|size
operator|==
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
comment|/* The ECOFF linking code expects that we have already 		 read in the debugging information and set up an 		 ecoff_debug_info structure, so we do that now.  */
if|if
condition|(
operator|!
name|_bfd_mips_elf_read_ecoff_info
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|input_debug
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
operator|(
name|bfd_ecoff_debug_accumulate
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|input_bfd
argument_list|,
operator|&
name|input_debug
argument_list|,
name|input_swap
argument_list|,
name|info
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Loop through the external symbols.  For each one with 		 interesting information, try to find the symbol in 		 the linker global hash table and save the information 		 for the output external symbols.  */
name|eraw_src
operator|=
name|input_debug
operator|.
name|external_ext
expr_stmt|;
name|eraw_end
operator|=
operator|(
name|eraw_src
operator|+
operator|(
name|input_debug
operator|.
name|symbolic_header
operator|.
name|iextMax
operator|*
name|input_swap
operator|->
name|external_ext_size
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|eraw_src
operator|<
name|eraw_end
condition|;
name|eraw_src
operator|+=
name|input_swap
operator|->
name|external_ext_size
control|)
block|{
name|EXTR
name|ext
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
call|(
modifier|*
name|input_swap
operator|->
name|swap_ext_in
call|)
argument_list|(
name|input_bfd
argument_list|,
name|eraw_src
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scNil
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSUndefined
condition|)
continue|continue;
name|name
operator|=
name|input_debug
operator|.
name|ssext
operator|+
name|ext
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
name|h
operator|=
name|mips_elf_link_hash_lookup
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|esym
operator|.
name|ifd
operator|!=
operator|-
literal|2
condition|)
continue|continue;
if|if
condition|(
name|ext
operator|.
name|ifd
operator|!=
operator|-
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ext
operator|.
name|ifd
operator|<
name|input_debug
operator|.
name|symbolic_header
operator|.
name|ifdMax
argument_list|)
expr_stmt|;
name|ext
operator|.
name|ifd
operator|=
name|input_debug
operator|.
name|ifdmap
index|[
name|ext
operator|.
name|ifd
index|]
expr_stmt|;
block|}
name|h
operator|->
name|esym
operator|=
name|ext
expr_stmt|;
block|}
comment|/* Free up the information we just read.  */
name|free
argument_list|(
name|input_debug
operator|.
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_dnr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_pdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_opt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_aux
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ss
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ssext
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_fdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_rfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_ext
argument_list|)
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Create .rtproc section.  */
name|rtproc_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
init|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
decl_stmt|;
name|rtproc_sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|mips_elf_create_procedure_table
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|rtproc_sec
argument_list|,
operator|&
name|debug
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Build the external symbol information.  */
name|einfo
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|einfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|einfo
operator|.
name|debug
operator|=
operator|&
name|debug
expr_stmt|;
name|einfo
operator|.
name|swap
operator|=
name|swap
expr_stmt|;
name|einfo
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
name|mips_elf_link_hash_traverse
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_output_extsym
argument_list|,
operator|&
name|einfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|einfo
operator|.
name|failed
condition|)
return|return
name|FALSE
return|;
comment|/* Set the size of the .mdebug section.  */
name|o
operator|->
name|_raw_size
operator|=
name|bfd_ecoff_debug_size
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|o
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab."
argument_list|,
sizeof|sizeof
expr|".gptab."
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|subname
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|Elf32_gptab
modifier|*
name|tab
decl_stmt|;
name|Elf32_External_gptab
modifier|*
name|ext_tab
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* The .gptab.sdata and .gptab.sbss sections hold 	     information describing how the small data area would 	     change depending upon the -G switch.  These sections 	     not used in executables files.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_data_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		     elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Skip this section later on (I don't think this 		 currently matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
name|NULL
expr_stmt|;
comment|/* Really remove the section.  */
for|for
control|(
name|secpp
operator|=
operator|&
name|abfd
operator|->
name|sections
init|;
operator|*
name|secpp
operator|!=
name|o
condition|;
name|secpp
operator|=
operator|&
operator|(
operator|*
name|secpp
operator|)
operator|->
name|next
control|)
empty_stmt|;
name|bfd_section_list_remove
argument_list|(
name|abfd
argument_list|,
name|secpp
argument_list|)
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
continue|continue;
block|}
comment|/* There is one gptab for initialized data, and one for 	     uninitialized data.  */
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sdata"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_data_sec
operator|=
name|o
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sbss"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_bss_sec
operator|=
name|o
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: illegal section name `%s'"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* The linker script always combines .gptab.data and 	     .gptab.sdata into .gptab.sdata, and likewise for 	     .gptab.bss and .gptab.sbss.  It is possible that there is 	     no .sdata or .sbss section in the output file, in which 	     case we must change the name of the output section.  */
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|o
operator|==
name|gptab_data_sec
condition|)
name|o
operator|->
name|name
operator|=
literal|".gptab.data"
expr_stmt|;
else|else
name|o
operator|->
name|name
operator|=
literal|".gptab.bss"
expr_stmt|;
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the first entry.  */
name|c
operator|=
literal|1
expr_stmt|;
name|amt
operator|=
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_gptab
argument_list|)
expr_stmt|;
name|tab
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_current_g_value
operator|=
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_unused
operator|=
literal|0
expr_stmt|;
comment|/* Combine the input sections.  */
for|for
control|(
name|p
operator|=
name|o
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|unsigned
name|long
name|last
decl_stmt|;
name|bfd_size_type
name|gpentry
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_data_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
comment|/* Combine the gptab entries for this input section one 		 by one.  We know that the input gptab entries are 		 sorted by ascending -G value.  */
name|size
operator|=
name|bfd_section_size
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gpentry
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
init|;
name|gpentry
operator|<
name|size
condition|;
name|gpentry
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
control|)
block|{
name|Elf32_External_gptab
name|ext_gptab
decl_stmt|;
name|Elf32_gptab
name|int_gptab
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|add
decl_stmt|;
name|bfd_boolean
name|exact
decl_stmt|;
name|unsigned
name|int
name|look
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|ext_gptab
argument_list|,
name|gpentry
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bfd_mips_elf32_swap_gptab_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|ext_gptab
argument_list|,
operator|&
name|int_gptab
argument_list|)
expr_stmt|;
name|val
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_g_value
expr_stmt|;
name|add
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|-
name|last
expr_stmt|;
name|exact
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>=
name|val
condition|)
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|add
expr_stmt|;
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|==
name|val
condition|)
name|exact
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exact
condition|)
block|{
name|Elf32_gptab
modifier|*
name|new_tab
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
comment|/* We need a new table entry.  */
name|amt
operator|=
call|(
name|bfd_size_type
call|)
argument_list|(
name|c
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_gptab
argument_list|)
expr_stmt|;
name|new_tab
operator|=
name|bfd_realloc
argument_list|(
name|tab
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|tab
operator|=
name|new_tab
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|=
name|val
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|=
name|add
expr_stmt|;
comment|/* Merge in the size for the next smallest -G 			 value, since that will be implied by this new 			 value.  */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|<
name|val
operator|&&
operator|(
name|max
operator|==
literal|0
operator|||
operator|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|)
operator|)
condition|)
name|max
operator|=
name|look
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|!=
literal|0
condition|)
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|last
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
block|}
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* The table must be sorted by -G value.  */
if|if
condition|(
name|c
operator|>
literal|2
condition|)
name|qsort
argument_list|(
name|tab
operator|+
literal|1
argument_list|,
name|c
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|tab
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gptab_compare
argument_list|)
expr_stmt|;
comment|/* Swap out the table.  */
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
name|ext_tab
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|c
condition|;
name|j
operator|++
control|)
name|bfd_mips_elf32_swap_gptab_out
argument_list|(
name|abfd
argument_list|,
name|tab
operator|+
name|j
argument_list|,
name|ext_tab
operator|+
name|j
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|o
operator|->
name|_raw_size
operator|=
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
name|o
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_tab
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|link_order_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Invoke the regular ELF backend linker to do all the work.  */
if|if
condition|(
operator|!
name|bfd_elf_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Now write out the computed sections.  */
if|if
condition|(
name|reginfo_sec
operator|!=
name|NULL
condition|)
block|{
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|bfd_mips_elf32_swap_reginfo_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|reginfo
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|reginfo_sec
argument_list|,
operator|&
name|ext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|mdebug_sec
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|output_has_begun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_write_accumulated_debug
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|,
name|mdebug_sec
operator|->
name|filepos
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bfd_ecoff_debug_free
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gptab_data_sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_data_sec
argument_list|,
name|gptab_data_sec
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|gptab_data_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|gptab_bss_sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_bss_sec
argument_list|,
name|gptab_bss_sec
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|gptab_bss_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|rtproc_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
name|rtproc_sec
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|rtproc_sec
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure for saying that BFD machine EXTENSION extends BASE.  */
end_comment

begin_struct
struct|struct
name|mips_mach_extension
block|{
name|unsigned
name|long
name|extension
decl_stmt|,
name|base
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An array describing how BFD machines relate to one another.  The entries    are ordered topologically with MIPS I extensions listed last.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_mach_extension
name|mips_mach_extensions
index|[]
init|=
block|{
comment|/* MIPS64 extensions.  */
block|{
name|bfd_mach_mipsisa64r2
block|,
name|bfd_mach_mipsisa64
block|}
block|,
block|{
name|bfd_mach_mips_sb1
block|,
name|bfd_mach_mipsisa64
block|}
block|,
comment|/* MIPS V extensions.  */
block|{
name|bfd_mach_mipsisa64
block|,
name|bfd_mach_mips5
block|}
block|,
comment|/* R10000 extensions.  */
block|{
name|bfd_mach_mips12000
block|,
name|bfd_mach_mips10000
block|}
block|,
comment|/* R5000 extensions.  Note: the vr5500 ISA is an extension of the core      vr5400 ISA, but doesn't include the multimedia stuff.  It seems      better to allow vr5400 and vr5500 code to be merged anyway, since      many libraries will just use the core ISA.  Perhaps we could add      some sort of ASE flag if this ever proves a problem.  */
block|{
name|bfd_mach_mips5500
block|,
name|bfd_mach_mips5400
block|}
block|,
block|{
name|bfd_mach_mips5400
block|,
name|bfd_mach_mips5000
block|}
block|,
comment|/* MIPS IV extensions.  */
block|{
name|bfd_mach_mips5
block|,
name|bfd_mach_mips8000
block|}
block|,
block|{
name|bfd_mach_mips10000
block|,
name|bfd_mach_mips8000
block|}
block|,
block|{
name|bfd_mach_mips5000
block|,
name|bfd_mach_mips8000
block|}
block|,
block|{
name|bfd_mach_mips7000
block|,
name|bfd_mach_mips8000
block|}
block|,
comment|/* VR4100 extensions.  */
block|{
name|bfd_mach_mips4120
block|,
name|bfd_mach_mips4100
block|}
block|,
block|{
name|bfd_mach_mips4111
block|,
name|bfd_mach_mips4100
block|}
block|,
comment|/* MIPS III extensions.  */
block|{
name|bfd_mach_mips8000
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4650
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4600
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4400
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4300
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4100
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4010
block|,
name|bfd_mach_mips4000
block|}
block|,
comment|/* MIPS32 extensions.  */
block|{
name|bfd_mach_mipsisa32r2
block|,
name|bfd_mach_mipsisa32
block|}
block|,
comment|/* MIPS II extensions.  */
block|{
name|bfd_mach_mips4000
block|,
name|bfd_mach_mips6000
block|}
block|,
block|{
name|bfd_mach_mipsisa32
block|,
name|bfd_mach_mips6000
block|}
block|,
comment|/* MIPS I extensions.  */
block|{
name|bfd_mach_mips6000
block|,
name|bfd_mach_mips3000
block|}
block|,
block|{
name|bfd_mach_mips3900
block|,
name|bfd_mach_mips3000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if bfd machine EXTENSION is an extension of machine BASE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_mach_extends_p
parameter_list|(
name|unsigned
name|long
name|base
parameter_list|,
name|unsigned
name|long
name|extension
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|extension
operator|!=
name|base
operator|&&
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mips_mach_extensions
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|extension
operator|==
name|mips_mach_extensions
index|[
name|i
index|]
operator|.
name|extension
condition|)
name|extension
operator|=
name|mips_mach_extensions
index|[
name|i
index|]
operator|.
name|base
expr_stmt|;
return|return
name|extension
operator|==
name|base
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given ELF header flags describe a 32-bit binary.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_32bit_flags_p
parameter_list|(
name|flagword
name|flags
parameter_list|)
block|{
return|return
operator|(
operator|(
name|flags
operator|&
name|EF_MIPS_32BITMODE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_O32
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_EABI32
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_1
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_2
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_32
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_32R2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|old_flags
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|;
name|bfd_boolean
name|ok
decl_stmt|;
name|bfd_boolean
name|null_input_bfd
init|=
name|TRUE
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Check if we have the same endianess */
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: endianness incompatible with that of the selected emulation"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|obfd
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: ABI is incompatible with that of the selected emulation"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
name|EF_MIPS_NOREORDER
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/* Check flag compatibility.  */
name|new_flags
operator|&=
operator|~
name|EF_MIPS_NOREORDER
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_NOREORDER
expr_stmt|;
comment|/* Some IRIX 6 BSD-compatibility objects have this bit set.  It      doesn't seem to matter.  */
name|new_flags
operator|&=
operator|~
name|EF_MIPS_XGOT
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_XGOT
expr_stmt|;
comment|/* MIPSpro generates ucode info in n64 objects.  Again, we should      just be able to ignore this.  */
name|new_flags
operator|&=
operator|~
name|EF_MIPS_UCODE
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_UCODE
expr_stmt|;
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
return|return
name|TRUE
return|;
comment|/* Check to see if the input BFD actually contains any sections.      If not, its flags may not have been initialised either, but it cannot      actually cause any incompatibility.  */
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
comment|/* Ignore synthetic sections and empty .text, .data and .bss sections 	  which are automatically generated by gas.  */
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|&&
operator|(
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
operator|||
operator|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".data"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|)
operator|)
condition|)
block|{
name|null_input_bfd
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|null_input_bfd
condition|)
return|return
name|TRUE
return|;
name|ok
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|new_flags
operator|&
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|old_flags
operator|&
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: linking PIC files with non-PIC files"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|new_flags
operator|&
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_CPIC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|new_flags
operator|&
name|EF_MIPS_PIC
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_MIPS_PIC
expr_stmt|;
name|new_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
expr_stmt|;
comment|/* Compare the ISAs.  */
if|if
condition|(
name|mips_32bit_flags_p
argument_list|(
name|old_flags
argument_list|)
operator|!=
name|mips_32bit_flags_p
argument_list|(
name|new_flags
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking 32-bit code with 64-bit code"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_mach_extends_p
argument_list|(
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|obfd
argument_list|)
argument_list|)
condition|)
block|{
comment|/* OBFD's ISA isn't the same as, or an extension of, IBFD's.  */
if|if
condition|(
name|mips_mach_extends_p
argument_list|(
name|bfd_get_mach
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Copy the architecture info from IBFD to OBFD.  Also copy 	     the 32-bit flag (if set) so that we continue to recognise 	     OBFD as a 32-bit binary.  */
name|bfd_set_arch_info
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch_info
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator||
name|EF_MIPS_32BITMODE
operator|)
expr_stmt|;
comment|/* Copy across the ABI flags if OBFD doesn't use them 	     and if that was what caused us to treat IBFD as 32-bit.  */
if|if
condition|(
operator|(
name|old_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
literal|0
operator|&&
name|mips_32bit_flags_p
argument_list|(
name|new_flags
argument_list|)
operator|&&
operator|!
name|mips_32bit_flags_p
argument_list|(
name|new_flags
operator|&
operator|~
name|EF_MIPS_ABI
argument_list|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
name|EF_MIPS_ABI
expr_stmt|;
block|}
else|else
block|{
comment|/* The ISAs aren't compatible.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking %s module with previous %s modules"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_printable_name
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_printable_name
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|new_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator||
name|EF_MIPS_32BITMODE
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator||
name|EF_MIPS_32BITMODE
operator|)
expr_stmt|;
comment|/* Compare ABIs.  The 64-bit ABI does not use EF_MIPS_ABI.  But, it      does set EI_CLASS differently from any 32-bit ABI.  */
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|||
operator|(
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|)
condition|)
block|{
comment|/* Only error if both are set (to different values).  */
if|if
condition|(
operator|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|&&
operator|(
name|old_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|)
operator|||
operator|(
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: ABI mismatch: linking %s module with previous %s modules"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|elf_mips_abi_name
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|elf_mips_abi_name
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
name|new_flags
operator|&=
operator|~
name|EF_MIPS_ABI
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_ABI
expr_stmt|;
block|}
comment|/* For now, allow arbitrary mixing of ASEs (retain the union).  */
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_ARCH_ASE
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|EF_MIPS_ARCH_ASE
operator|)
condition|)
block|{
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
name|EF_MIPS_ARCH_ASE
expr_stmt|;
name|new_flags
operator|&=
operator|~
name|EF_MIPS_ARCH_ASE
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_ARCH_ASE
expr_stmt|;
block|}
comment|/* Warn about any other mismatches */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Function to keep MIPS specific file flags like as EF_MIPS_PIC.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_mips_elf_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
name|ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %lx:"
argument_list|)
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_O32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=O32]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_O64
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=O64]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_EABI32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=EABI32]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_EABI64
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=EABI64]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi unknown]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ABI_N32_P
argument_list|(
name|abfd
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=N32]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=64]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [no abi set]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips1]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_2
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips2]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_3
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips3]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_4
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips4]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_5
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips5]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips32]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_64
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips64]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_32R2
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips32r2]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_64R2
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips64r2]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [unknown ISA]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH_ASE_MDMX
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mdmx]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH_ASE_M16
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [mips16]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_32BITMODE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [32bitmode]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [not 32bitmode]"
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|bfd_elf_special_section
specifier|const
name|_bfd_mips_elf_special_sections
index|[]
init|=
block|{
block|{
literal|".sdata"
block|,
literal|6
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_MIPS_GPREL
block|}
block|,
block|{
literal|".sbss"
block|,
literal|5
block|,
operator|-
literal|2
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_MIPS_GPREL
block|}
block|,
block|{
literal|".lit4"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_MIPS_GPREL
block|}
block|,
block|{
literal|".lit8"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_MIPS_GPREL
block|}
block|,
block|{
literal|".ucode"
block|,
literal|6
block|,
literal|0
block|,
name|SHT_MIPS_UCODE
block|,
literal|0
block|}
block|,
block|{
literal|".mdebug"
block|,
literal|7
block|,
literal|0
block|,
name|SHT_MIPS_DEBUG
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

