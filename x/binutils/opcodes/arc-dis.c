begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction printing code for the ARC.    Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002    Free Software Foundation, Inc.    Contributed by Doug Evans (dje@cygnus.com).     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"opcode/arc.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/arc.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"arc-dis.h"
end_include

begin_include
include|#
directive|include
file|"arc-ext.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|dbg
end_ifndef

begin_define
define|#
directive|define
name|dbg
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BIT
parameter_list|(
name|word
parameter_list|,
name|n
parameter_list|)
value|((word)& (1<< n))
end_define

begin_define
define|#
directive|define
name|BITS
parameter_list|(
name|word
parameter_list|,
name|s
parameter_list|,
name|e
parameter_list|)
value|(((word)<< (31 - e))>> (s + (31 - e)))
end_define

begin_define
define|#
directive|define
name|OPCODE
parameter_list|(
name|word
parameter_list|)
value|(BITS ((word), 27, 31))
end_define

begin_define
define|#
directive|define
name|FIELDA
parameter_list|(
name|word
parameter_list|)
value|(BITS ((word), 21, 26))
end_define

begin_define
define|#
directive|define
name|FIELDB
parameter_list|(
name|word
parameter_list|)
value|(BITS ((word), 15, 20))
end_define

begin_define
define|#
directive|define
name|FIELDC
parameter_list|(
name|word
parameter_list|)
value|(BITS ((word),  9, 14))
end_define

begin_comment
comment|/* FIELD D is signed in all of its uses, so we make sure argument is    treated as signed for bit shifting purposes:  */
end_comment

begin_define
define|#
directive|define
name|FIELDD
parameter_list|(
name|word
parameter_list|)
value|(BITS (((signed int)word), 0, 8))
end_define

begin_define
define|#
directive|define
name|PUT_NEXT_WORD_IN
parameter_list|(
name|a
parameter_list|)
define|\
value|do									\     {									\       if (is_limm == 1&& !NEXT_WORD (1))				\         mwerror (state, _("Illegal limm reference in last instruction!\n")); \       a = state->words[1];						\     }									\   while (0)
end_define

begin_define
define|#
directive|define
name|CHECK_FLAG_COND_NULLIFY
parameter_list|()
define|\
value|do								\     {								\       if (is_shimm == 0)					\         {							\           flag = BIT (state->words[0], 8);			\           state->nullifyMode = BITS (state->words[0], 5, 6);	\           cond = BITS (state->words[0], 0, 4);			\         }							\     }								\   while (0)
end_define

begin_define
define|#
directive|define
name|CHECK_COND
parameter_list|()
define|\
value|do						\     {						\       if (is_shimm == 0)			\         cond = BITS (state->words[0], 0, 4);	\     }						\   while (0)
end_define

begin_define
define|#
directive|define
name|CHECK_FIELD
parameter_list|(
name|field
parameter_list|)
define|\
value|do						\     {						\       if (field == 62)				\         {					\           is_limm++;				\ 	  field##isReg = 0;			\ 	  PUT_NEXT_WORD_IN (field);		\ 	  limm_value = field;			\ 	}					\       else if (field> 60)			\         {					\ 	  field##isReg = 0;			\ 	  is_shimm++;				\ 	  flag = (field == 61);			\ 	  field = FIELDD (state->words[0]);	\ 	}					\     }						\   while (0)
end_define

begin_define
define|#
directive|define
name|CHECK_FIELD_A
parameter_list|()
define|\
value|do						\     {						\       fieldA = FIELDA (state->words[0]);	\       if (fieldA> 60)				\         {					\ 	  fieldAisReg = 0;			\ 	  fieldA = 0;				\ 	}					\     }						\   while (0)
end_define

begin_define
define|#
directive|define
name|CHECK_FIELD_B
parameter_list|()
define|\
value|do						\     {						\       fieldB = FIELDB (state->words[0]);	\       CHECK_FIELD (fieldB);			\     }						\   while (0)
end_define

begin_define
define|#
directive|define
name|CHECK_FIELD_C
parameter_list|()
define|\
value|do						\     {						\       fieldC = FIELDC (state->words[0]);	\       CHECK_FIELD (fieldC);			\     }						\   while (0)
end_define

begin_define
define|#
directive|define
name|IS_SMALL
parameter_list|(
name|x
parameter_list|)
value|(((field##x)< 256)&& ((field##x)> -257))
end_define

begin_define
define|#
directive|define
name|IS_REG
parameter_list|(
name|x
parameter_list|)
value|(field##x##isReg)
end_define

begin_define
define|#
directive|define
name|WRITE_FORMAT_LB_Rx_RB
parameter_list|(
name|x
parameter_list|)
value|WRITE_FORMAT(x,"[","]","","")
end_define

begin_define
define|#
directive|define
name|WRITE_FORMAT_x_COMMA_LB
parameter_list|(
name|x
parameter_list|)
value|WRITE_FORMAT(x,"",",[","",",[")
end_define

begin_define
define|#
directive|define
name|WRITE_FORMAT_COMMA_x_RB
parameter_list|(
name|x
parameter_list|)
value|WRITE_FORMAT(x,",","]",",","]")
end_define

begin_define
define|#
directive|define
name|WRITE_FORMAT_x_RB
parameter_list|(
name|x
parameter_list|)
value|WRITE_FORMAT(x,"","]","","]")
end_define

begin_define
define|#
directive|define
name|WRITE_FORMAT_COMMA_x
parameter_list|(
name|x
parameter_list|)
value|WRITE_FORMAT(x,",","",",","")
end_define

begin_define
define|#
directive|define
name|WRITE_FORMAT_x_COMMA
parameter_list|(
name|x
parameter_list|)
value|WRITE_FORMAT(x,"",",","",",")
end_define

begin_define
define|#
directive|define
name|WRITE_FORMAT_x
parameter_list|(
name|x
parameter_list|)
value|WRITE_FORMAT(x,"","","","")
end_define

begin_define
define|#
directive|define
name|WRITE_FORMAT
parameter_list|(
name|x
parameter_list|,
name|cb1
parameter_list|,
name|ca1
parameter_list|,
name|cb
parameter_list|,
name|ca
parameter_list|)
value|strcat (formatString,		\ 				     (IS_REG (x) ? cb1"%r"ca1 :		\ 				      usesAuxReg ? cb"%a"ca :		\ 				      IS_SMALL (x) ? cb"%d"ca : cb"%h"ca))
end_define

begin_define
define|#
directive|define
name|WRITE_FORMAT_RB
parameter_list|()
value|strcat (formatString, "]")
end_define

begin_define
define|#
directive|define
name|WRITE_COMMENT
parameter_list|(
name|str
parameter_list|)
value|(state->comm[state->commNum++] = (str))
end_define

begin_define
define|#
directive|define
name|WRITE_NOP_COMMENT
parameter_list|()
value|if (!fieldAisReg&& !flag) WRITE_COMMENT ("nop");
end_define

begin_define
define|#
directive|define
name|NEXT_WORD
parameter_list|(
name|x
parameter_list|)
value|(offset += 4, state->words[x])
end_define

begin_define
define|#
directive|define
name|add_target
parameter_list|(
name|x
parameter_list|)
value|(state->targets[state->tcnt++] = (x))
end_define

begin_decl_stmt
specifier|static
name|char
name|comment_prefix
index|[]
init|=
literal|"\t; "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|core_reg_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arcDisState
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|aux_reg_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arcDisState
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cond_code_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arcDisState
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|instruction_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arcDisState
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mwerror
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arcDisState
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|post_address
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arcDisState
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_comments_
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arcDisState
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_instr_name_
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arcDisState
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dsmOneArcInst
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|arcDisState
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|_coreRegName
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|decodeInstr
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|core_reg_name
parameter_list|(
name|state
parameter_list|,
name|val
parameter_list|)
name|struct
name|arcDisState
modifier|*
name|state
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
if|if
condition|(
name|state
operator|->
name|coreRegName
condition|)
return|return
call|(
modifier|*
name|state
operator|->
name|coreRegName
call|)
argument_list|(
name|state
operator|->
name|_this
argument_list|,
name|val
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|aux_reg_name
parameter_list|(
name|state
parameter_list|,
name|val
parameter_list|)
name|struct
name|arcDisState
modifier|*
name|state
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
if|if
condition|(
name|state
operator|->
name|auxRegName
condition|)
return|return
call|(
modifier|*
name|state
operator|->
name|auxRegName
call|)
argument_list|(
name|state
operator|->
name|_this
argument_list|,
name|val
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cond_code_name
parameter_list|(
name|state
parameter_list|,
name|val
parameter_list|)
name|struct
name|arcDisState
modifier|*
name|state
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
if|if
condition|(
name|state
operator|->
name|condCodeName
condition|)
return|return
call|(
modifier|*
name|state
operator|->
name|condCodeName
call|)
argument_list|(
name|state
operator|->
name|_this
argument_list|,
name|val
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|instruction_name
parameter_list|(
name|state
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|,
name|flags
parameter_list|)
name|struct
name|arcDisState
modifier|*
name|state
decl_stmt|;
name|int
name|op1
decl_stmt|;
name|int
name|op2
decl_stmt|;
name|int
modifier|*
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|state
operator|->
name|instName
condition|)
return|return
call|(
modifier|*
name|state
operator|->
name|instName
call|)
argument_list|(
name|state
operator|->
name|_this
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|flags
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mwerror
parameter_list|(
name|state
parameter_list|,
name|msg
parameter_list|)
name|struct
name|arcDisState
modifier|*
name|state
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
if|if
condition|(
name|state
operator|->
name|err
operator|!=
literal|0
condition|)
call|(
modifier|*
name|state
operator|->
name|err
call|)
argument_list|(
name|state
operator|->
name|_this
argument_list|,
operator|(
name|msg
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|post_address
parameter_list|(
name|state
parameter_list|,
name|addr
parameter_list|)
name|struct
name|arcDisState
modifier|*
name|state
decl_stmt|;
name|int
name|addr
decl_stmt|;
block|{
specifier|static
name|char
name|id
index|[
literal|3
operator|*
name|ARRAY_SIZE
argument_list|(
name|state
operator|->
name|addresses
argument_list|)
index|]
decl_stmt|;
name|int
name|j
decl_stmt|,
name|i
init|=
name|state
operator|->
name|acnt
decl_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|state
operator|->
name|addresses
argument_list|)
operator|)
condition|)
block|{
name|state
operator|->
name|addresses
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
operator|++
name|state
operator|->
name|acnt
expr_stmt|;
name|j
operator|=
name|i
operator|*
literal|3
expr_stmt|;
name|id
index|[
name|j
operator|+
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
name|id
index|[
name|j
operator|+
literal|1
index|]
operator|=
literal|'0'
operator|+
name|i
expr_stmt|;
name|id
index|[
name|j
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|id
operator|+
name|j
return|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|my_sprintf
name|PARAMS
argument_list|(
operator|(
expr|struct
name|arcDisState
operator|*
operator|,
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|my_sprintf
name|VPARAMS
argument_list|(
operator|(
expr|struct
name|arcDisState
operator|*
name|state
operator|,
name|char
operator|*
name|buf
operator|,
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
name|char
modifier|*
name|bp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|,
name|leading_zero
decl_stmt|,
name|regMap
index|[
literal|2
index|]
decl_stmt|;
name|long
name|auxNum
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
expr|struct
name|arcDisState
operator|*
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|format
expr_stmt|;
name|auxNum
operator|=
operator|-
literal|1
expr_stmt|;
name|regMap
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|regMap
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|0
case|:
goto|goto
name|DOCOMM
goto|;
comment|/* (return)  */
default|default:
operator|*
name|bp
operator|++
operator|=
name|p
index|[
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|size
operator|=
literal|0
expr_stmt|;
name|leading_zero
operator|=
literal|0
expr_stmt|;
name|RETRY
label|:
empty_stmt|;
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
comment|/* size.  */
name|size
operator|=
name|p
index|[
operator|-
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|leading_zero
operator|=
literal|1
expr_stmt|;
comment|/* e.g. %08x  */
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
block|{
name|size
operator|=
name|size
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
goto|goto
name|RETRY
goto|;
block|}
define|#
directive|define
name|inc_bp
parameter_list|()
value|bp = bp + strlen (bp)
case|case
literal|'h'
case|:
block|{
name|unsigned
name|u
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
comment|/* Hex.  We can change the format to 0x%08x in 		 one place, here, if we wish. 		 We add underscores for easy reading.  */
if|if
condition|(
name|u
operator|>
literal|65536
condition|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"0x%x_%04x"
argument_list|,
name|u
operator|>>
literal|16
argument_list|,
name|u
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"0x%x"
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|inc_bp
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
block|{
name|int
name|val
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
if|if
condition|(
name|leading_zero
condition|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%0*x"
argument_list|,
name|size
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%*x"
argument_list|,
name|size
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|inc_bp
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
block|{
name|int
name|val
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%*d"
argument_list|,
name|size
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|inc_bp
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
block|{
comment|/* Register.  */
name|int
name|val
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
define|#
directive|define
name|REG2NAME
parameter_list|(
name|num
parameter_list|,
name|name
parameter_list|)
value|case num: sprintf (bp, ""name); \   regMap[(num< 32) ? 0 : 1] |= 1<< (num - ((num< 32) ? 0 : 32)); break;
switch|switch
condition|(
name|val
condition|)
block|{
name|REG2NAME
argument_list|(
literal|26
argument_list|,
literal|"gp"
argument_list|)
expr_stmt|;
name|REG2NAME
argument_list|(
literal|27
argument_list|,
literal|"fp"
argument_list|)
expr_stmt|;
name|REG2NAME
argument_list|(
literal|28
argument_list|,
literal|"sp"
argument_list|)
expr_stmt|;
name|REG2NAME
argument_list|(
literal|29
argument_list|,
literal|"ilink1"
argument_list|)
expr_stmt|;
name|REG2NAME
argument_list|(
literal|30
argument_list|,
literal|"ilink2"
argument_list|)
expr_stmt|;
name|REG2NAME
argument_list|(
literal|31
argument_list|,
literal|"blink"
argument_list|)
expr_stmt|;
name|REG2NAME
argument_list|(
literal|60
argument_list|,
literal|"lp_count"
argument_list|)
expr_stmt|;
default|default:
block|{
specifier|const
name|char
modifier|*
name|ext
decl_stmt|;
name|ext
operator|=
name|core_reg_name
argument_list|(
name|state
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
condition|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s"
argument_list|,
name|ext
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"r%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|inc_bp
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
block|{
comment|/* Aux Register.  */
name|int
name|val
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
define|#
directive|define
name|AUXREG2NAME
parameter_list|(
name|num
parameter_list|,
name|name
parameter_list|)
value|case num: sprintf (bp,name); break;
switch|switch
condition|(
name|val
condition|)
block|{
name|AUXREG2NAME
argument_list|(
literal|0x0
argument_list|,
literal|"status"
argument_list|)
expr_stmt|;
name|AUXREG2NAME
argument_list|(
literal|0x1
argument_list|,
literal|"semaphore"
argument_list|)
expr_stmt|;
name|AUXREG2NAME
argument_list|(
literal|0x2
argument_list|,
literal|"lp_start"
argument_list|)
expr_stmt|;
name|AUXREG2NAME
argument_list|(
literal|0x3
argument_list|,
literal|"lp_end"
argument_list|)
expr_stmt|;
name|AUXREG2NAME
argument_list|(
literal|0x4
argument_list|,
literal|"identity"
argument_list|)
expr_stmt|;
name|AUXREG2NAME
argument_list|(
literal|0x5
argument_list|,
literal|"debug"
argument_list|)
expr_stmt|;
default|default:
block|{
specifier|const
name|char
modifier|*
name|ext
decl_stmt|;
name|ext
operator|=
name|aux_reg_name
argument_list|(
name|state
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
condition|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s"
argument_list|,
name|ext
argument_list|)
expr_stmt|;
else|else
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|bp
argument_list|,
literal|"%h"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|inc_bp
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
block|{
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s"
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|inc_bp
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"?? format %c\n"
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|DOCOMM
label|:
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|write_comments_
parameter_list|(
name|state
parameter_list|,
name|shimm
parameter_list|,
name|is_limm
parameter_list|,
name|limm_value
parameter_list|)
name|struct
name|arcDisState
modifier|*
name|state
decl_stmt|;
name|int
name|shimm
decl_stmt|;
name|int
name|is_limm
decl_stmt|;
name|long
name|limm_value
decl_stmt|;
block|{
if|if
condition|(
name|state
operator|->
name|commentBuffer
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|is_limm
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|post_address
argument_list|(
name|state
argument_list|,
name|limm_value
operator|+
name|shimm
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|0
condition|)
name|WRITE_COMMENT
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|commNum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|state
operator|->
name|commentBuffer
argument_list|,
name|comment_prefix
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|state
operator|->
name|commentBuffer
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|state
operator|->
name|commentBuffer
argument_list|,
name|state
operator|->
name|comm
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|state
operator|->
name|commentBuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|write_comments2
parameter_list|(
name|x
parameter_list|)
value|write_comments_(state, x, is_limm, limm_value)
end_define

begin_define
define|#
directive|define
name|write_comments
parameter_list|()
value|write_comments2(0)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|condName
index|[]
init|=
block|{
comment|/* 0..15.  */
literal|""
block|,
literal|"z"
block|,
literal|"nz"
block|,
literal|"p"
block|,
literal|"n"
block|,
literal|"c"
block|,
literal|"nc"
block|,
literal|"v"
block|,
literal|"nv"
block|,
literal|"gt"
block|,
literal|"ge"
block|,
literal|"lt"
block|,
literal|"le"
block|,
literal|"hi"
block|,
literal|"ls"
block|,
literal|"pnz"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|write_instr_name_
parameter_list|(
name|state
parameter_list|,
name|instrName
parameter_list|,
name|cond
parameter_list|,
name|condCodeIsPartOfName
parameter_list|,
name|flag
parameter_list|,
name|signExtend
parameter_list|,
name|addrWriteBack
parameter_list|,
name|directMem
parameter_list|)
name|struct
name|arcDisState
modifier|*
name|state
decl_stmt|;
specifier|const
name|char
modifier|*
name|instrName
decl_stmt|;
name|int
name|cond
decl_stmt|;
name|int
name|condCodeIsPartOfName
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|signExtend
decl_stmt|;
name|int
name|addrWriteBack
decl_stmt|;
name|int
name|directMem
decl_stmt|;
block|{
name|strcpy
argument_list|(
name|state
operator|->
name|instrBuffer
argument_list|,
name|instrName
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|cc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|condCodeIsPartOfName
condition|)
name|strcat
argument_list|(
name|state
operator|->
name|instrBuffer
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|<
literal|16
condition|)
name|cc
operator|=
name|condName
index|[
name|cond
index|]
expr_stmt|;
else|else
name|cc
operator|=
name|cond_code_name
argument_list|(
name|state
argument_list|,
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cc
condition|)
name|cc
operator|=
literal|"???"
expr_stmt|;
name|strcat
argument_list|(
name|state
operator|->
name|instrBuffer
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
name|strcat
argument_list|(
name|state
operator|->
name|instrBuffer
argument_list|,
literal|".f"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
operator|->
name|nullifyMode
condition|)
block|{
case|case
name|BR_exec_always
case|:
name|strcat
argument_list|(
name|state
operator|->
name|instrBuffer
argument_list|,
literal|".d"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BR_exec_when_jump
case|:
name|strcat
argument_list|(
name|state
operator|->
name|instrBuffer
argument_list|,
literal|".jd"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|signExtend
condition|)
name|strcat
argument_list|(
name|state
operator|->
name|instrBuffer
argument_list|,
literal|".x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrWriteBack
condition|)
name|strcat
argument_list|(
name|state
operator|->
name|instrBuffer
argument_list|,
literal|".a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|directMem
condition|)
name|strcat
argument_list|(
name|state
operator|->
name|instrBuffer
argument_list|,
literal|".di"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|write_instr_name
parameter_list|()
define|\
value|do									\     {									\       write_instr_name_(state, instrName,cond, condCodeIsPartOfName,	\ 			flag, signExtend, addrWriteBack, directMem);	\       formatString[0] = '\0';						\     }									\   while (0)
end_define

begin_enum
enum|enum
block|{
name|op_LD0
init|=
literal|0
block|,
name|op_LD1
init|=
literal|1
block|,
name|op_ST
init|=
literal|2
block|,
name|op_3
init|=
literal|3
block|,
name|op_BC
init|=
literal|4
block|,
name|op_BLC
init|=
literal|5
block|,
name|op_LPC
init|=
literal|6
block|,
name|op_JC
init|=
literal|7
block|,
name|op_ADD
init|=
literal|8
block|,
name|op_ADC
init|=
literal|9
block|,
name|op_SUB
init|=
literal|10
block|,
name|op_SBC
init|=
literal|11
block|,
name|op_AND
init|=
literal|12
block|,
name|op_OR
init|=
literal|13
block|,
name|op_BIC
init|=
literal|14
block|,
name|op_XOR
init|=
literal|15
block|}
enum|;
end_enum

begin_decl_stmt
specifier|extern
name|disassemble_info
name|tm_print_insn_info
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dsmOneArcInst
parameter_list|(
name|addr
parameter_list|,
name|state
parameter_list|)
name|bfd_vma
name|addr
decl_stmt|;
name|struct
name|arcDisState
modifier|*
name|state
decl_stmt|;
block|{
name|int
name|condCodeIsPartOfName
init|=
literal|0
decl_stmt|;
name|int
name|decodingClass
decl_stmt|;
specifier|const
name|char
modifier|*
name|instrName
decl_stmt|;
name|int
name|repeatsOp
init|=
literal|0
decl_stmt|;
name|int
name|fieldAisReg
init|=
literal|1
decl_stmt|;
name|int
name|fieldBisReg
init|=
literal|1
decl_stmt|;
name|int
name|fieldCisReg
init|=
literal|1
decl_stmt|;
name|int
name|fieldA
decl_stmt|;
name|int
name|fieldB
decl_stmt|;
name|int
name|fieldC
init|=
literal|0
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|int
name|cond
init|=
literal|0
decl_stmt|;
name|int
name|is_shimm
init|=
literal|0
decl_stmt|;
name|int
name|is_limm
init|=
literal|0
decl_stmt|;
name|long
name|limm_value
init|=
literal|0
decl_stmt|;
name|int
name|signExtend
init|=
literal|0
decl_stmt|;
name|int
name|addrWriteBack
init|=
literal|0
decl_stmt|;
name|int
name|directMem
init|=
literal|0
decl_stmt|;
name|int
name|is_linked
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|usesAuxReg
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|ignoreFirstOpd
decl_stmt|;
name|char
name|formatString
index|[
literal|60
index|]
decl_stmt|;
name|state
operator|->
name|instructionLen
operator|=
literal|4
expr_stmt|;
name|state
operator|->
name|nullifyMode
operator|=
name|BR_exec_when_no_jump
expr_stmt|;
name|state
operator|->
name|opWidth
operator|=
literal|12
expr_stmt|;
name|state
operator|->
name|isBranch
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|_mem_load
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|_ea_present
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|_load_len
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|ea_reg1
operator|=
name|no_reg
expr_stmt|;
name|state
operator|->
name|ea_reg2
operator|=
name|no_reg
expr_stmt|;
name|state
operator|->
name|_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NEXT_WORD
argument_list|(
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|state
operator|->
name|_opcode
operator|=
name|OPCODE
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|instrName
operator|=
literal|0
expr_stmt|;
name|decodingClass
operator|=
literal|0
expr_stmt|;
comment|/* default!  */
name|repeatsOp
operator|=
literal|0
expr_stmt|;
name|condCodeIsPartOfName
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|commNum
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|tcnt
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|acnt
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|flow
operator|=
name|noflow
expr_stmt|;
name|ignoreFirstOpd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|commentBuffer
condition|)
name|state
operator|->
name|commentBuffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|state
operator|->
name|_opcode
condition|)
block|{
case|case
name|op_LD0
case|:
switch|switch
condition|(
name|BITS
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|instrName
operator|=
literal|"ld"
expr_stmt|;
name|state
operator|->
name|_load_len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|instrName
operator|=
literal|"ldb"
expr_stmt|;
name|state
operator|->
name|_load_len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|instrName
operator|=
literal|"ldw"
expr_stmt|;
name|state
operator|->
name|_load_len
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|instrName
operator|=
literal|"??? (0[3])"
expr_stmt|;
name|state
operator|->
name|flow
operator|=
name|invalid_instr
expr_stmt|;
break|break;
block|}
name|decodingClass
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|op_LD1
case|:
if|if
condition|(
name|BIT
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|13
argument_list|)
condition|)
block|{
name|instrName
operator|=
literal|"lr"
expr_stmt|;
name|decodingClass
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|BITS
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|10
argument_list|,
literal|11
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|instrName
operator|=
literal|"ld"
expr_stmt|;
name|state
operator|->
name|_load_len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|instrName
operator|=
literal|"ldb"
expr_stmt|;
name|state
operator|->
name|_load_len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|instrName
operator|=
literal|"ldw"
expr_stmt|;
name|state
operator|->
name|_load_len
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|instrName
operator|=
literal|"??? (1[3])"
expr_stmt|;
name|state
operator|->
name|flow
operator|=
name|invalid_instr
expr_stmt|;
break|break;
block|}
name|decodingClass
operator|=
literal|6
expr_stmt|;
block|}
break|break;
case|case
name|op_ST
case|:
if|if
condition|(
name|BIT
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|25
argument_list|)
condition|)
block|{
name|instrName
operator|=
literal|"sr"
expr_stmt|;
name|decodingClass
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|BITS
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|22
argument_list|,
literal|23
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|instrName
operator|=
literal|"st"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|instrName
operator|=
literal|"stb"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|instrName
operator|=
literal|"stw"
expr_stmt|;
break|break;
default|default:
name|instrName
operator|=
literal|"??? (2[3])"
expr_stmt|;
name|state
operator|->
name|flow
operator|=
name|invalid_instr
expr_stmt|;
break|break;
block|}
name|decodingClass
operator|=
literal|7
expr_stmt|;
block|}
break|break;
case|case
name|op_3
case|:
name|decodingClass
operator|=
literal|1
expr_stmt|;
comment|/* default for opcode 3...  */
switch|switch
condition|(
name|FIELDC
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|instrName
operator|=
literal|"flag"
expr_stmt|;
name|decodingClass
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|instrName
operator|=
literal|"asr"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|instrName
operator|=
literal|"lsr"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|instrName
operator|=
literal|"ror"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|instrName
operator|=
literal|"rrc"
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|instrName
operator|=
literal|"sexb"
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|instrName
operator|=
literal|"sexw"
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|instrName
operator|=
literal|"extb"
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|instrName
operator|=
literal|"extw"
expr_stmt|;
break|break;
case|case
literal|0x3f
case|:
block|{
name|decodingClass
operator|=
literal|9
expr_stmt|;
switch|switch
condition|(
name|FIELDD
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|instrName
operator|=
literal|"brk"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|instrName
operator|=
literal|"sleep"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|instrName
operator|=
literal|"swi"
expr_stmt|;
break|break;
default|default:
name|instrName
operator|=
literal|"???"
expr_stmt|;
name|state
operator|->
name|flow
operator|=
name|invalid_instr
expr_stmt|;
break|break;
block|}
block|}
break|break;
comment|/* ARC Extension Library Instructions 	     NOTE: We assume that extension codes are these instrs.  */
default|default:
name|instrName
operator|=
name|instruction_name
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|_opcode
argument_list|,
name|FIELDC
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instrName
condition|)
block|{
name|instrName
operator|=
literal|"???"
expr_stmt|;
name|state
operator|->
name|flow
operator|=
name|invalid_instr
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|IGNORE_FIRST_OPD
condition|)
name|ignoreFirstOpd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|op_BC
case|:
name|instrName
operator|=
literal|"b"
expr_stmt|;
case|case
name|op_BLC
case|:
if|if
condition|(
operator|!
name|instrName
condition|)
name|instrName
operator|=
literal|"bl"
expr_stmt|;
case|case
name|op_LPC
case|:
if|if
condition|(
operator|!
name|instrName
condition|)
name|instrName
operator|=
literal|"lp"
expr_stmt|;
case|case
name|op_JC
case|:
if|if
condition|(
operator|!
name|instrName
condition|)
block|{
if|if
condition|(
name|BITS
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|9
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|instrName
operator|=
literal|"jl"
expr_stmt|;
name|is_linked
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|instrName
operator|=
literal|"j"
expr_stmt|;
name|is_linked
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|condCodeIsPartOfName
operator|=
literal|1
expr_stmt|;
name|decodingClass
operator|=
operator|(
operator|(
name|state
operator|->
name|_opcode
operator|==
name|op_JC
operator|)
condition|?
literal|4
else|:
literal|3
operator|)
expr_stmt|;
name|state
operator|->
name|isBranch
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|op_ADD
case|:
case|case
name|op_ADC
case|:
case|case
name|op_AND
case|:
name|repeatsOp
operator|=
operator|(
name|FIELDC
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|)
operator|==
name|FIELDB
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
name|decodingClass
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|state
operator|->
name|_opcode
condition|)
block|{
case|case
name|op_ADD
case|:
name|instrName
operator|=
operator|(
name|repeatsOp
condition|?
literal|"asl"
else|:
literal|"add"
operator|)
expr_stmt|;
break|break;
case|case
name|op_ADC
case|:
name|instrName
operator|=
operator|(
name|repeatsOp
condition|?
literal|"rlc"
else|:
literal|"adc"
operator|)
expr_stmt|;
break|break;
case|case
name|op_AND
case|:
name|instrName
operator|=
operator|(
name|repeatsOp
condition|?
literal|"mov"
else|:
literal|"and"
operator|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|op_SUB
case|:
name|instrName
operator|=
literal|"sub"
expr_stmt|;
break|break;
case|case
name|op_SBC
case|:
name|instrName
operator|=
literal|"sbc"
expr_stmt|;
break|break;
case|case
name|op_OR
case|:
name|instrName
operator|=
literal|"or"
expr_stmt|;
break|break;
case|case
name|op_BIC
case|:
name|instrName
operator|=
literal|"bic"
expr_stmt|;
break|break;
case|case
name|op_XOR
case|:
if|if
condition|(
name|state
operator|->
name|words
index|[
literal|0
index|]
operator|==
literal|0x7fffffff
condition|)
block|{
comment|/* nop encoded as xor -1, -1, -1  */
name|instrName
operator|=
literal|"nop"
expr_stmt|;
name|decodingClass
operator|=
literal|9
expr_stmt|;
block|}
else|else
name|instrName
operator|=
literal|"xor"
expr_stmt|;
break|break;
default|default:
name|instrName
operator|=
name|instruction_name
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|_opcode
argument_list|,
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|/* if (instrName) printf("FLAGS=0x%x\n", flags);  */
if|if
condition|(
operator|!
name|instrName
condition|)
block|{
name|instrName
operator|=
literal|"???"
expr_stmt|;
name|state
operator|->
name|flow
operator|=
name|invalid_instr
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|IGNORE_FIRST_OPD
condition|)
name|ignoreFirstOpd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|fieldAisReg
operator|=
name|fieldBisReg
operator|=
name|fieldCisReg
operator|=
literal|1
expr_stmt|;
comment|/* Assume regs for now.  */
name|flag
operator|=
name|cond
operator|=
name|is_shimm
operator|=
name|is_limm
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|nullifyMode
operator|=
name|BR_exec_when_no_jump
expr_stmt|;
comment|/* 0  */
name|signExtend
operator|=
name|addrWriteBack
operator|=
name|directMem
operator|=
literal|0
expr_stmt|;
name|usesAuxReg
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|decodingClass
condition|)
block|{
case|case
literal|0
case|:
name|CHECK_FIELD_A
argument_list|()
expr_stmt|;
name|CHECK_FIELD_B
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|repeatsOp
condition|)
name|CHECK_FIELD_C
argument_list|()
expr_stmt|;
name|CHECK_FLAG_COND_NULLIFY
argument_list|()
expr_stmt|;
name|write_instr_name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ignoreFirstOpd
condition|)
block|{
name|WRITE_FORMAT_x
argument_list|(
name|A
argument_list|)
expr_stmt|;
name|WRITE_FORMAT_COMMA_x
argument_list|(
name|B
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|repeatsOp
condition|)
name|WRITE_FORMAT_COMMA_x
argument_list|(
name|C
argument_list|)
expr_stmt|;
name|WRITE_NOP_COMMENT
argument_list|()
expr_stmt|;
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|fieldA
argument_list|,
name|fieldB
argument_list|,
name|fieldC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_FORMAT_x
argument_list|(
name|B
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|repeatsOp
condition|)
name|WRITE_FORMAT_COMMA_x
argument_list|(
name|C
argument_list|)
expr_stmt|;
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|fieldB
argument_list|,
name|fieldC
argument_list|)
expr_stmt|;
block|}
name|write_comments
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|CHECK_FIELD_A
argument_list|()
expr_stmt|;
name|CHECK_FIELD_B
argument_list|()
expr_stmt|;
name|CHECK_FLAG_COND_NULLIFY
argument_list|()
expr_stmt|;
name|write_instr_name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ignoreFirstOpd
condition|)
block|{
name|WRITE_FORMAT_x
argument_list|(
name|A
argument_list|)
expr_stmt|;
name|WRITE_FORMAT_COMMA_x
argument_list|(
name|B
argument_list|)
expr_stmt|;
name|WRITE_NOP_COMMENT
argument_list|()
expr_stmt|;
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|fieldA
argument_list|,
name|fieldB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_FORMAT_x
argument_list|(
name|B
argument_list|)
expr_stmt|;
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|fieldB
argument_list|)
expr_stmt|;
block|}
name|write_comments
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|CHECK_FIELD_B
argument_list|()
expr_stmt|;
name|CHECK_FLAG_COND_NULLIFY
argument_list|()
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
comment|/* this is the FLAG instruction -- it's redundant  */
name|write_instr_name
argument_list|()
expr_stmt|;
name|WRITE_FORMAT_x
argument_list|(
name|B
argument_list|)
expr_stmt|;
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|fieldB
argument_list|)
expr_stmt|;
name|write_comments
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fieldA
operator|=
name|BITS
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|7
argument_list|,
literal|26
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|fieldA
operator|=
operator|(
name|fieldA
operator|<<
literal|10
operator|)
operator|>>
literal|10
expr_stmt|;
comment|/* make it signed  */
name|fieldA
operator|+=
name|addr
operator|+
literal|4
expr_stmt|;
name|CHECK_FLAG_COND_NULLIFY
argument_list|()
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
name|write_instr_name
argument_list|()
expr_stmt|;
comment|/* This address could be a label we know. Convert it.  */
if|if
condition|(
name|state
operator|->
name|_opcode
operator|!=
name|op_LPC
comment|/* LP  */
condition|)
block|{
name|add_target
argument_list|(
name|fieldA
argument_list|)
expr_stmt|;
comment|/* For debugger.  */
name|state
operator|->
name|flow
operator|=
name|state
operator|->
name|_opcode
operator|==
name|op_BLC
comment|/* BL  */
condition|?
name|direct_call
else|:
name|direct_jump
expr_stmt|;
comment|/* indirect calls are achieved by "lr blink,[status]; 	     lr dest<- func addr; j [dest]"  */
block|}
name|strcat
argument_list|(
name|formatString
argument_list|,
literal|"%s"
argument_list|)
expr_stmt|;
comment|/* address/label name */
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|post_address
argument_list|(
name|state
argument_list|,
name|fieldA
argument_list|)
argument_list|)
expr_stmt|;
name|write_comments
argument_list|()
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* For op_JC -- jump to address specified. 	 Also covers jump and link--bit 9 of the instr. word 	 selects whether linked, thus "is_linked" is set above.  */
name|fieldA
operator|=
literal|0
expr_stmt|;
name|CHECK_FIELD_B
argument_list|()
expr_stmt|;
name|CHECK_FLAG_COND_NULLIFY
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fieldBisReg
condition|)
block|{
name|fieldAisReg
operator|=
literal|0
expr_stmt|;
name|fieldA
operator|=
operator|(
name|fieldB
operator|>>
literal|25
operator|)
operator|&
literal|0x7F
expr_stmt|;
comment|/* flags */
name|fieldB
operator|=
operator|(
name|fieldB
operator|&
literal|0xFFFFFF
operator|)
operator|<<
literal|2
expr_stmt|;
name|state
operator|->
name|flow
operator|=
name|is_linked
condition|?
name|direct_call
else|:
name|direct_jump
expr_stmt|;
name|add_target
argument_list|(
name|fieldB
argument_list|)
expr_stmt|;
comment|/* screwy JLcc requires .jd mode to execute correctly 	   * but we pretend it is .nd (no delay slot).  */
if|if
condition|(
name|is_linked
operator|&&
name|state
operator|->
name|nullifyMode
operator|==
name|BR_exec_when_jump
condition|)
name|state
operator|->
name|nullifyMode
operator|=
name|BR_exec_when_no_jump
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|flow
operator|=
name|is_linked
condition|?
name|indirect_call
else|:
name|indirect_jump
expr_stmt|;
comment|/* We should also treat this as indirect call if NOT linked 	   * but the preceding instruction was a "lr blink,[status]" 	   * and we have a delay slot with "add blink,blink,2". 	   * For now we can't detect such.  */
name|state
operator|->
name|register_for_indirect_jump
operator|=
name|fieldB
expr_stmt|;
block|}
name|write_instr_name
argument_list|()
expr_stmt|;
name|strcat
argument_list|(
name|formatString
argument_list|,
name|IS_REG
argument_list|(
name|B
argument_list|)
condition|?
literal|"[%r]"
else|:
literal|"%s"
argument_list|)
expr_stmt|;
comment|/* address/label name  */
if|if
condition|(
name|fieldA
operator|!=
literal|0
condition|)
block|{
name|fieldAisReg
operator|=
literal|0
expr_stmt|;
name|WRITE_FORMAT_COMMA_x
argument_list|(
name|A
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_REG
argument_list|(
name|B
argument_list|)
condition|)
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|fieldB
argument_list|,
name|fieldA
argument_list|)
expr_stmt|;
else|else
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|post_address
argument_list|(
name|state
argument_list|,
name|fieldB
argument_list|)
argument_list|,
name|fieldA
argument_list|)
expr_stmt|;
name|write_comments
argument_list|()
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* LD instruction. 	 B and C can be regs, or one (both?) can be limm.  */
name|CHECK_FIELD_A
argument_list|()
expr_stmt|;
name|CHECK_FIELD_B
argument_list|()
expr_stmt|;
name|CHECK_FIELD_C
argument_list|()
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"5:b reg %d %d c reg %d %d  \n"
argument_list|,
name|fieldBisReg
argument_list|,
name|fieldB
argument_list|,
name|fieldCisReg
argument_list|,
name|fieldC
argument_list|)
expr_stmt|;
name|state
operator|->
name|_offset
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|_ea_present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fieldBisReg
condition|)
name|state
operator|->
name|ea_reg1
operator|=
name|fieldB
expr_stmt|;
else|else
name|state
operator|->
name|_offset
operator|+=
name|fieldB
expr_stmt|;
if|if
condition|(
name|fieldCisReg
condition|)
name|state
operator|->
name|ea_reg2
operator|=
name|fieldC
expr_stmt|;
else|else
name|state
operator|->
name|_offset
operator|+=
name|fieldC
expr_stmt|;
name|state
operator|->
name|_mem_load
operator|=
literal|1
expr_stmt|;
name|directMem
operator|=
name|BIT
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|addrWriteBack
operator|=
name|BIT
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|signExtend
operator|=
name|BIT
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write_instr_name
argument_list|()
expr_stmt|;
name|WRITE_FORMAT_x_COMMA_LB
argument_list|(
name|A
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldBisReg
operator|||
name|fieldB
operator|!=
literal|0
condition|)
name|WRITE_FORMAT_x_COMMA
argument_list|(
name|B
argument_list|)
expr_stmt|;
else|else
name|fieldB
operator|=
name|fieldC
expr_stmt|;
name|WRITE_FORMAT_x_RB
argument_list|(
name|C
argument_list|)
expr_stmt|;
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|fieldA
argument_list|,
name|fieldB
argument_list|,
name|fieldC
argument_list|)
expr_stmt|;
name|write_comments
argument_list|()
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* LD instruction.  */
name|CHECK_FIELD_B
argument_list|()
expr_stmt|;
name|CHECK_FIELD_A
argument_list|()
expr_stmt|;
name|fieldC
operator|=
name|FIELDD
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"6:b reg %d %d c 0x%x  \n"
argument_list|,
name|fieldBisReg
argument_list|,
name|fieldB
argument_list|,
name|fieldC
argument_list|)
expr_stmt|;
name|state
operator|->
name|_ea_present
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|_offset
operator|=
name|fieldC
expr_stmt|;
name|state
operator|->
name|_mem_load
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fieldBisReg
condition|)
name|state
operator|->
name|ea_reg1
operator|=
name|fieldB
expr_stmt|;
comment|/* field B is either a shimm (same as fieldC) or limm (different!) 	 Say ea is not present, so only one of us will do the name lookup.  */
else|else
name|state
operator|->
name|_offset
operator|+=
name|fieldB
operator|,
name|state
operator|->
name|_ea_present
operator|=
literal|0
expr_stmt|;
name|directMem
operator|=
name|BIT
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|addrWriteBack
operator|=
name|BIT
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|signExtend
operator|=
name|BIT
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|write_instr_name
argument_list|()
expr_stmt|;
name|WRITE_FORMAT_x_COMMA_LB
argument_list|(
name|A
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fieldBisReg
condition|)
block|{
name|fieldB
operator|=
name|state
operator|->
name|_offset
expr_stmt|;
name|WRITE_FORMAT_x_RB
argument_list|(
name|B
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_FORMAT_x
argument_list|(
name|B
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldC
operator|!=
literal|0
operator|&&
operator|!
name|BIT
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|13
argument_list|)
condition|)
block|{
name|fieldCisReg
operator|=
literal|0
expr_stmt|;
name|WRITE_FORMAT_COMMA_x_RB
argument_list|(
name|C
argument_list|)
expr_stmt|;
block|}
else|else
name|WRITE_FORMAT_RB
argument_list|()
expr_stmt|;
block|}
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|fieldA
argument_list|,
name|fieldB
argument_list|,
name|fieldC
argument_list|)
expr_stmt|;
name|write_comments
argument_list|()
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* ST instruction.  */
name|CHECK_FIELD_B
argument_list|()
expr_stmt|;
name|CHECK_FIELD_C
argument_list|()
expr_stmt|;
name|fieldA
operator|=
name|FIELDD
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* shimm  */
comment|/* [B,A offset]  */
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"7:b reg %d %x off %x\n"
argument_list|,
name|fieldBisReg
argument_list|,
name|fieldB
argument_list|,
name|fieldA
argument_list|)
expr_stmt|;
name|state
operator|->
name|_ea_present
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|_offset
operator|=
name|fieldA
expr_stmt|;
if|if
condition|(
name|fieldBisReg
condition|)
name|state
operator|->
name|ea_reg1
operator|=
name|fieldB
expr_stmt|;
comment|/* field B is either a shimm (same as fieldA) or limm (different!) 	 Say ea is not present, so only one of us will do the name lookup. 	 (for is_limm we do the name translation here).  */
else|else
name|state
operator|->
name|_offset
operator|+=
name|fieldB
operator|,
name|state
operator|->
name|_ea_present
operator|=
literal|0
expr_stmt|;
name|directMem
operator|=
name|BIT
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|addrWriteBack
operator|=
name|BIT
argument_list|(
name|state
operator|->
name|words
index|[
literal|0
index|]
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|write_instr_name
argument_list|()
expr_stmt|;
name|WRITE_FORMAT_x_COMMA_LB
argument_list|(
name|C
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fieldBisReg
condition|)
block|{
name|fieldB
operator|=
name|state
operator|->
name|_offset
expr_stmt|;
name|WRITE_FORMAT_x_RB
argument_list|(
name|B
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_FORMAT_x
argument_list|(
name|B
argument_list|)
expr_stmt|;
if|if
condition|(
name|fieldBisReg
operator|&&
name|fieldA
operator|!=
literal|0
condition|)
block|{
name|fieldAisReg
operator|=
literal|0
expr_stmt|;
name|WRITE_FORMAT_COMMA_x_RB
argument_list|(
name|A
argument_list|)
expr_stmt|;
block|}
else|else
name|WRITE_FORMAT_RB
argument_list|()
expr_stmt|;
block|}
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|fieldC
argument_list|,
name|fieldB
argument_list|,
name|fieldA
argument_list|)
expr_stmt|;
name|write_comments2
argument_list|(
name|fieldA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* SR instruction  */
name|CHECK_FIELD_B
argument_list|()
expr_stmt|;
name|CHECK_FIELD_C
argument_list|()
expr_stmt|;
name|write_instr_name
argument_list|()
expr_stmt|;
name|WRITE_FORMAT_x_COMMA_LB
argument_list|(
name|C
argument_list|)
expr_stmt|;
comment|/* Try to print B as an aux reg if it is not a core reg.  */
name|usesAuxReg
operator|=
literal|1
expr_stmt|;
name|WRITE_FORMAT_x
argument_list|(
name|B
argument_list|)
expr_stmt|;
name|WRITE_FORMAT_RB
argument_list|()
expr_stmt|;
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|fieldC
argument_list|,
name|fieldB
argument_list|)
expr_stmt|;
name|write_comments
argument_list|()
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|write_instr_name
argument_list|()
expr_stmt|;
name|state
operator|->
name|operandBuffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* LR instruction */
name|CHECK_FIELD_A
argument_list|()
expr_stmt|;
name|CHECK_FIELD_B
argument_list|()
expr_stmt|;
name|write_instr_name
argument_list|()
expr_stmt|;
name|WRITE_FORMAT_x_COMMA_LB
argument_list|(
name|A
argument_list|)
expr_stmt|;
comment|/* Try to print B as an aux reg if it is not a core reg. */
name|usesAuxReg
operator|=
literal|1
expr_stmt|;
name|WRITE_FORMAT_x
argument_list|(
name|B
argument_list|)
expr_stmt|;
name|WRITE_FORMAT_RB
argument_list|()
expr_stmt|;
name|my_sprintf
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|operandBuffer
argument_list|,
name|formatString
argument_list|,
name|fieldA
argument_list|,
name|fieldB
argument_list|)
expr_stmt|;
name|write_comments
argument_list|()
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|CHECK_COND
argument_list|()
expr_stmt|;
name|write_instr_name
argument_list|()
expr_stmt|;
name|state
operator|->
name|operandBuffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|mwerror
argument_list|(
name|state
argument_list|,
literal|"Bad decoding class in ARC disassembler"
argument_list|)
expr_stmt|;
break|break;
block|}
name|state
operator|->
name|_cond
operator|=
name|cond
expr_stmt|;
return|return
name|state
operator|->
name|instructionLen
operator|=
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Returns the name the user specified core extension register.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_coreRegName
parameter_list|(
name|arg
parameter_list|,
name|regval
parameter_list|)
name|void
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|regval
decl_stmt|;
block|{
return|return
name|arcExtMap_coreRegName
argument_list|(
name|regval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the name the user specified AUX extension register.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_auxRegName
parameter_list|(
name|void
modifier|*
name|_this
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|regval
parameter_list|)
block|{
return|return
name|arcExtMap_auxRegName
argument_list|(
name|regval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the name the user specified condition code name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_condCodeName
parameter_list|(
name|void
modifier|*
name|_this
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|regval
parameter_list|)
block|{
return|return
name|arcExtMap_condCodeName
argument_list|(
name|regval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the name the user specified extension instruction.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_instName
parameter_list|(
name|void
modifier|*
name|_this
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|majop
parameter_list|,
name|int
name|minop
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|)
block|{
return|return
name|arcExtMap_instName
argument_list|(
name|majop
argument_list|,
name|minop
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode an instruction returning the size of the instruction    in bytes or zero if unrecognized.  */
end_comment

begin_function
specifier|static
name|int
name|decodeInstr
parameter_list|(
name|address
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|address
decl_stmt|;
comment|/* Address of this instruction.  */
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|arcDisState
name|s
decl_stmt|;
comment|/* ARC Disassembler state  */
name|void
modifier|*
name|stream
init|=
name|info
operator|->
name|stream
decl_stmt|;
comment|/* output stream  */
name|fprintf_ftype
name|func
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|memset
argument_list|(
operator|&
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|arcDisState
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read first instruction  */
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|address
argument_list|,
name|buffer
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|address
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
name|s
operator|.
name|words
index|[
literal|0
index|]
operator|=
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
name|s
operator|.
name|words
index|[
literal|0
index|]
operator|=
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* always read second word in case of limm  */
comment|/* we ignore the result since last insn may not have a limm  */
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|address
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
name|s
operator|.
name|words
index|[
literal|1
index|]
operator|=
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
name|s
operator|.
name|words
index|[
literal|1
index|]
operator|=
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|s
operator|.
name|_this
operator|=
operator|&
name|s
expr_stmt|;
name|s
operator|.
name|coreRegName
operator|=
name|_coreRegName
expr_stmt|;
name|s
operator|.
name|auxRegName
operator|=
name|_auxRegName
expr_stmt|;
name|s
operator|.
name|condCodeName
operator|=
name|_condCodeName
expr_stmt|;
name|s
operator|.
name|instName
operator|=
name|_instName
expr_stmt|;
comment|/* disassemble  */
name|bytes
operator|=
name|dsmOneArcInst
argument_list|(
name|address
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* display the disassembly instruction  */
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%08x "
argument_list|,
name|s
operator|.
name|words
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%-10s "
argument_list|,
name|s
operator|.
name|instrBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|__TRANSLATION_REQUIRED
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|bfd_vma
name|addr
init|=
name|s
operator|.
name|addresses
index|[
name|s
operator|.
name|operandBuffer
index|[
literal|1
index|]
operator|-
literal|'0'
index|]
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|bfd_vma
operator|)
name|addr
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|s
operator|.
name|operandBuffer
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|instructionLen
return|;
block|}
end_function

begin_comment
comment|/* Return the print_insn function to use.    Side effect: load (possibly empty) extension section  */
end_comment

begin_function
name|disassembler_ftype
name|arc_get_disassembler
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|ptr
condition|)
name|build_ARC_extmap
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
name|decodeInstr
return|;
block|}
end_function

end_unit

