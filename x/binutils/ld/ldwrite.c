begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ldwrite.c -- write out the linked file    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2002, 2003    Free Software Foundation, Inc.    Written by Steve Chamberlain sac@cygnus.com  This file is part of GLD, the Gnu Linker.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldwrite.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|<ldgram.h>
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_comment
comment|/* Build link_order structures for the BFD linker.  */
end_comment

begin_function
specifier|static
name|void
name|build_link_order
parameter_list|(
name|lang_statement_union_type
modifier|*
name|statement
parameter_list|)
block|{
switch|switch
condition|(
name|statement
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_data_statement_enum
case|:
block|{
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_boolean
name|big_endian
init|=
name|FALSE
decl_stmt|;
name|output_section
operator|=
name|statement
operator|->
name|data_statement
operator|.
name|output_section
expr_stmt|;
name|ASSERT
argument_list|(
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
name|link_order
operator|=
name|bfd_new_link_order
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_order
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_new_link_order failed\n"
argument_list|)
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|type
operator|=
name|bfd_data_link_order
expr_stmt|;
name|link_order
operator|->
name|offset
operator|=
name|statement
operator|->
name|data_statement
operator|.
name|output_vma
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
operator|=
name|xmalloc
argument_list|(
name|QUAD_SIZE
argument_list|)
expr_stmt|;
name|value
operator|=
name|statement
operator|->
name|data_statement
operator|.
name|value
expr_stmt|;
comment|/* If the endianness of the output BFD is not known, then we 	   base the endianness of the data on the first input file. 	   By convention, the bfd_put routines for an unknown 	   endianness are big endian, so we must swap here if the 	   input file is little endian.  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|big_endian
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|big_endian
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|bfd_boolean
name|swap
decl_stmt|;
name|swap
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_BIG
condition|)
name|big_endian
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_LITTLE
condition|)
block|{
name|big_endian
operator|=
name|FALSE
expr_stmt|;
name|swap
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_UNSET
condition|)
block|{
name|big_endian
operator|=
name|TRUE
expr_stmt|;
block|{
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|s
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|the_bfd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|s
operator|->
name|the_bfd
argument_list|)
condition|)
block|{
name|big_endian
operator|=
name|FALSE
expr_stmt|;
name|swap
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|swap
condition|)
block|{
name|bfd_byte
name|buffer
index|[
literal|8
index|]
decl_stmt|;
switch|switch
condition|(
name|statement
operator|->
name|data_statement
operator|.
name|type
condition|)
block|{
case|case
name|QUAD
case|:
case|case
name|SQUAD
case|:
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|>=
name|QUAD_SIZE
condition|)
block|{
name|bfd_putl64
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_getb64
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|LONG
case|:
name|bfd_putl32
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|bfd_putl16
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_getb16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|ASSERT
argument_list|(
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|statement
operator|->
name|data_statement
operator|.
name|type
condition|)
block|{
case|case
name|QUAD
case|:
case|case
name|SQUAD
case|:
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|>=
name|QUAD_SIZE
condition|)
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_vma
name|high
decl_stmt|;
if|if
condition|(
name|statement
operator|->
name|data_statement
operator|.
name|type
operator|==
name|QUAD
condition|)
name|high
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|value
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
name|high
operator|=
literal|0
expr_stmt|;
else|else
name|high
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|high
argument_list|,
operator|(
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
operator|+
operator|(
name|big_endian
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
operator|(
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
operator|+
operator|(
name|big_endian
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|link_order
operator|->
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|size
operator|=
name|LONG_SIZE
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|size
operator|=
name|SHORT_SIZE
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|size
operator|=
name|BYTE_SIZE
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|lang_reloc_statement_enum
case|:
block|{
name|lang_reloc_statement_type
modifier|*
name|rs
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|rs
operator|=
operator|&
name|statement
operator|->
name|reloc_statement
expr_stmt|;
name|output_section
operator|=
name|rs
operator|->
name|output_section
expr_stmt|;
name|ASSERT
argument_list|(
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
name|link_order
operator|=
name|bfd_new_link_order
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_order
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_new_link_order failed\n"
argument_list|)
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|offset
operator|=
name|rs
operator|->
name|output_vma
expr_stmt|;
name|link_order
operator|->
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|rs
operator|->
name|howto
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_order_reloc
argument_list|)
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|reloc
operator|=
name|rs
operator|->
name|reloc
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
operator|=
name|rs
operator|->
name|addend_value
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|link_order
operator|->
name|type
operator|=
name|bfd_section_reloc_link_order
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|section
operator|->
name|owner
operator|==
name|output_bfd
condition|)
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
operator|=
name|rs
operator|->
name|section
expr_stmt|;
else|else
block|{
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
operator|=
name|rs
operator|->
name|section
operator|->
name|output_section
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
operator|+=
name|rs
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
else|else
block|{
name|link_order
operator|->
name|type
operator|=
name|bfd_symbol_reloc_link_order
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
operator|=
name|rs
operator|->
name|name
expr_stmt|;
block|}
block|}
break|break;
case|case
name|lang_input_section_enum
case|:
comment|/* Create a new link_order in the output section with this 	 attached */
if|if
condition|(
operator|!
name|statement
operator|->
name|input_section
operator|.
name|ifile
operator|->
name|just_syms_flag
condition|)
block|{
name|asection
modifier|*
name|i
init|=
name|statement
operator|->
name|input_section
operator|.
name|section
decl_stmt|;
name|asection
modifier|*
name|output_section
init|=
name|i
operator|->
name|output_section
decl_stmt|;
name|ASSERT
argument_list|(
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
operator|)
operator|)
condition|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|link_order
operator|=
name|bfd_new_link_order
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|flags
operator|&
name|SEC_NEVER_LOAD
condition|)
block|{
comment|/* We've got a never load section inside one which 		     is going to be output, we'll change it into a 		     fill.  */
name|link_order
operator|->
name|type
operator|=
name|bfd_data_link_order
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
operator|=
literal|""
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|link_order
operator|->
name|type
operator|=
name|bfd_indirect_link_order
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|=
name|i
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|->
name|output_section
operator|==
name|output_section
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|->
name|_cooked_size
condition|)
name|link_order
operator|->
name|size
operator|=
name|i
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|link_order
operator|->
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|offset
operator|=
name|i
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
break|break;
case|case
name|lang_padding_statement_enum
case|:
comment|/* Make a new link_order with the right filler */
block|{
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|output_section
operator|=
name|statement
operator|->
name|padding_statement
operator|.
name|output_section
expr_stmt|;
name|ASSERT
argument_list|(
name|statement
operator|->
name|padding_statement
operator|.
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
block|{
name|link_order
operator|=
name|bfd_new_link_order
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|type
operator|=
name|bfd_data_link_order
expr_stmt|;
name|link_order
operator|->
name|size
operator|=
name|statement
operator|->
name|padding_statement
operator|.
name|size
expr_stmt|;
name|link_order
operator|->
name|offset
operator|=
name|statement
operator|->
name|padding_statement
operator|.
name|output_offset
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
operator|=
name|statement
operator|->
name|padding_statement
operator|.
name|fill
operator|->
name|data
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|size
operator|=
name|statement
operator|->
name|padding_statement
operator|.
name|fill
operator|->
name|size
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* All the other ones fall through */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return true if NAME is the name of an unsplittable section. These    are the stabs strings, dwarf strings.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|unsplittable_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".stab"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* There are several stab like string sections. We pattern match on 	 ".stab...str"  */
name|unsigned
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|name
index|[
name|len
operator|-
literal|3
index|]
argument_list|,
literal|"str"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"$GDB_STRINGS$"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Wander around the input sections, make sure that    we'll never try and create an output section with more relocs    than will fit.. Do this by always assuming the worst case, and    creating new output sections with all the right bits.  */
end_comment

begin_define
define|#
directive|define
name|TESTIT
value|1
end_define

begin_function
specifier|static
name|asection
modifier|*
name|clone_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|char
modifier|*
name|tname
decl_stmt|;
name|char
modifier|*
name|sname
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|asection
modifier|*
name|n
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Invent a section name from the section name and a dotted numeric      suffix.   */
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|tname
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tname
argument_list|,
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Remove a dotted number suffix, from a previous split link. */
while|while
condition|(
name|len
operator|&&
name|ISDIGIT
argument_list|(
name|tname
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|tname
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
comment|/* It was a dotted number. */
name|tname
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* We want to use the whole of the original section name for the      split name, but coff can be restricted to 8 character names.  */
if|if
condition|(
name|bfd_family_coff
argument_list|(
name|abfd
argument_list|)
operator|&&
name|strlen
argument_list|(
name|tname
argument_list|)
operator|>
literal|5
condition|)
block|{
comment|/* Some section names cannot be truncated, as the name is 	 used to locate some other section.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".stab"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"$GDB_SYMBOLS$"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: cannot create split section name for %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Silence gcc warnings.  einfo exits, so we never reach here.  */
return|return
name|NULL
return|;
block|}
name|tname
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sname
operator|=
name|bfd_get_unique_section_name
argument_list|(
name|abfd
argument_list|,
name|tname
argument_list|,
name|count
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|n
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|sname
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|sname
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: clone section failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Silence gcc warnings.  einfo exits, so we never reach here.  */
return|return
name|NULL
return|;
block|}
name|free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
comment|/* Set up section symbol.  */
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|flags
operator|=
name|s
operator|->
name|flags
expr_stmt|;
name|n
operator|->
name|vma
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|n
operator|->
name|user_set_vma
operator|=
name|s
operator|->
name|user_set_vma
expr_stmt|;
name|n
operator|->
name|lma
operator|=
name|s
operator|->
name|lma
expr_stmt|;
name|n
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|output_offset
operator|=
name|s
operator|->
name|output_offset
expr_stmt|;
name|n
operator|->
name|output_section
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|orelocation
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|alignment_power
operator|=
name|s
operator|->
name|alignment_power
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TESTING
end_if

begin_function
specifier|static
name|void
name|ds
parameter_list|(
name|asection
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|l
init|=
name|s
operator|->
name|link_order_head
decl_stmt|;
name|printf
argument_list|(
literal|"vma %x size %x\n"
argument_list|,
name|s
operator|->
name|vma
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|printf
argument_list|(
literal|"%8x %s\n"
argument_list|,
name|l
operator|->
name|offset
argument_list|,
name|l
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"%8x something else\n"
argument_list|)
argument_list|,
name|l
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|dump
argument_list|(
argument|char *s
argument_list|,
argument|asection *a1
argument_list|,
argument|asection *a2
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ds
argument_list|(
name|a1
argument_list|)
expr_stmt|;
name|ds
argument_list|(
name|a2
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|sanity_check
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|bfd_vma
name|prev
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|->
name|link_order_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|offset
operator|>
literal|100000
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|offset
operator|<
name|prev
condition|)
name|abort
argument_list|()
expr_stmt|;
name|prev
operator|=
name|p
operator|->
name|offset
expr_stmt|;
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sanity_check
parameter_list|(
name|a
parameter_list|)
end_define

begin_define
define|#
directive|define
name|dump
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|split_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|original_sec
decl_stmt|;
name|int
name|nsecs
init|=
name|abfd
operator|->
name|section_count
decl_stmt|;
name|sanity_check
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Look through all the original sections.  */
for|for
control|(
name|original_sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|original_sec
operator|&&
name|nsecs
condition|;
name|original_sec
operator|=
name|original_sec
operator|->
name|next
operator|,
name|nsecs
operator|--
control|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|lines
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|relocs
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|sec_size
init|=
literal|0
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|l
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|bfd_vma
name|vma
init|=
name|original_sec
operator|->
name|vma
decl_stmt|;
name|asection
modifier|*
name|cursor
init|=
name|original_sec
decl_stmt|;
comment|/* Count up the relocations and line entries to see if anything 	 would be too big to fit.  Accumulate section size too.  */
for|for
control|(
name|l
operator|=
name|NULL
operator|,
name|p
operator|=
name|cursor
operator|->
name|link_order_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|l
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|thislines
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|thisrelocs
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|thissize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_none
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_some
condition|)
name|thislines
operator|=
name|sec
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
name|thisrelocs
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|thissize
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|thissize
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|relocatable
operator|&&
operator|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
operator|)
condition|)
name|thisrelocs
operator|++
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|NULL
operator|&&
operator|(
name|thisrelocs
operator|+
name|relocs
operator|>=
name|config
operator|.
name|split_by_reloc
operator|||
name|thislines
operator|+
name|lines
operator|>=
name|config
operator|.
name|split_by_reloc
operator|||
operator|(
name|thissize
operator|+
name|sec_size
operator|>=
name|config
operator|.
name|split_by_file
operator|)
operator|)
operator|&&
operator|!
name|unsplittable_name
argument_list|(
name|cursor
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* Create a new section and put this link order and the 		 following link orders into it.  */
name|bfd_vma
name|shift_offset
decl_stmt|;
name|asection
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|clone_section
argument_list|(
name|abfd
argument_list|,
name|cursor
argument_list|,
name|original_sec
operator|->
name|name
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
comment|/* Attach the link orders to the new section and snip 		 them off from the old section.  */
name|n
operator|->
name|link_order_head
operator|=
name|p
expr_stmt|;
name|n
operator|->
name|link_order_tail
operator|=
name|cursor
operator|->
name|link_order_tail
expr_stmt|;
name|cursor
operator|->
name|link_order_tail
operator|=
name|l
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|l
operator|=
name|p
expr_stmt|;
comment|/* Change the size of the original section and 		 update the vma of the new one.  */
name|dump
argument_list|(
literal|"before snip"
argument_list|,
name|cursor
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|shift_offset
operator|=
name|p
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|cursor
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
block|{
name|n
operator|->
name|_cooked_size
operator|=
name|cursor
operator|->
name|_cooked_size
operator|-
name|shift_offset
expr_stmt|;
name|cursor
operator|->
name|_cooked_size
operator|=
name|shift_offset
expr_stmt|;
block|}
name|n
operator|->
name|_raw_size
operator|=
name|cursor
operator|->
name|_raw_size
operator|-
name|shift_offset
expr_stmt|;
name|cursor
operator|->
name|_raw_size
operator|=
name|shift_offset
expr_stmt|;
name|vma
operator|+=
name|shift_offset
expr_stmt|;
name|n
operator|->
name|lma
operator|=
name|n
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
comment|/* Run down the chain and change the output section to 		 the right one, update the offsets too.  */
do|do
block|{
name|p
operator|->
name|offset
operator|-=
name|shift_offset
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|=
name|n
expr_stmt|;
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_offset
operator|=
name|p
operator|->
name|offset
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
condition|)
do|;
name|dump
argument_list|(
literal|"after snip"
argument_list|,
name|cursor
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|n
expr_stmt|;
name|relocs
operator|=
name|thisrelocs
expr_stmt|;
name|lines
operator|=
name|thislines
expr_stmt|;
name|sec_size
operator|=
name|thissize
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|p
expr_stmt|;
name|relocs
operator|+=
name|thisrelocs
expr_stmt|;
name|lines
operator|+=
name|thislines
expr_stmt|;
name|sec_size
operator|+=
name|thissize
expr_stmt|;
block|}
block|}
block|}
name|sanity_check
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call BFD to write out the linked file.  */
end_comment

begin_function
name|void
name|ldwrite
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Reset error indicator, which can typically something like invalid      format from opening up the .o files.  */
name|bfd_set_error
argument_list|(
name|bfd_error_no_error
argument_list|)
expr_stmt|;
name|lang_for_each_statement
argument_list|(
name|build_link_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|split_by_reloc
operator|!=
operator|(
name|unsigned
operator|)
operator|-
literal|1
operator|||
name|config
operator|.
name|split_by_file
operator|!=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
name|split_sections
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_final_link
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
condition|)
block|{
comment|/* If there was an error recorded, print it out.  Otherwise assume 	 an appropriate error message like unknown symbol was printed 	 out.  */
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_no_error
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: final link failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

