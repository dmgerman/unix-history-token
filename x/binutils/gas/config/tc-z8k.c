begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-z8k.c -- Assemble code for the Zilog Z800n    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001    Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written By Steve Chamberlain<sac@cygnus.com>.  */
end_comment

begin_define
define|#
directive|define
name|DEFINE_TABLE
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"opcodes/z8k-opc.h"
end_include

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"!"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|machine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|coff_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|segmented_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|cons
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|s_segm
parameter_list|()
block|{
name|segmented_mode
operator|=
literal|1
expr_stmt|;
name|machine
operator|=
name|bfd_mach_z8001
expr_stmt|;
name|coff_flags
operator|=
name|F_Z8001
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_unseg
parameter_list|()
block|{
name|segmented_mode
operator|=
literal|0
expr_stmt|;
name|machine
operator|=
name|bfd_mach_z8002
expr_stmt|;
name|coff_flags
operator|=
name|F_Z8002
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|even
parameter_list|()
block|{
name|frag_align
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|obj_coff_section
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|tohex
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|c
operator|-
literal|'0'
return|;
if|if
condition|(
name|ISLOWER
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|c
operator|-
literal|'a'
operator|+
literal|10
return|;
return|return
name|c
operator|-
literal|'A'
operator|+
literal|10
return|;
block|}
end_function

begin_function
name|void
name|sval
parameter_list|()
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\''
condition|)
block|{
name|int
name|c
decl_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\''
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|c
operator|=
operator|(
name|tohex
argument_list|(
name|input_line_pointer
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|tohex
argument_list|(
name|input_line_pointer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
block|}
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:    pseudo-op name without dot    function to call to execute this pseudo-op    Integer arg to pass to the function    */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"int"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"data.b"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"data.w"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"data.l"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"form"
block|,
name|listing_psize
block|,
literal|0
block|}
block|,
block|{
literal|"heading"
block|,
name|listing_title
block|,
literal|0
block|}
block|,
block|{
literal|"import"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"page"
block|,
name|listing_eject
block|,
literal|0
block|}
block|,
block|{
literal|"program"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"z8001"
block|,
name|s_segm
block|,
literal|0
block|}
block|,
block|{
literal|"z8002"
block|,
name|s_unseg
block|,
literal|0
block|}
block|,
block|{
literal|"segm"
block|,
name|s_segm
block|,
literal|0
block|}
block|,
block|{
literal|"unsegm"
block|,
name|s_unseg
block|,
literal|0
block|}
block|,
block|{
literal|"unseg"
block|,
name|s_unseg
block|,
literal|0
block|}
block|,
block|{
literal|"name"
block|,
name|s_app_file
block|,
literal|0
block|}
block|,
block|{
literal|"global"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"wval"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"lval"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"bval"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"sval"
block|,
name|sval
block|,
literal|0
block|}
block|,
block|{
literal|"rsect"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"sect"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"block"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"even"
block|,
name|even
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant.    As in 0f12.456    or    0d1.2345e12  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode mnemonics.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|opcode_hash_control
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|opcode_entry_type
modifier|*
name|opcode
decl_stmt|;
name|char
modifier|*
name|prev_name
init|=
literal|""
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|opcode_hash_control
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|opcode
operator|=
name|z8k_table
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
block|{
comment|/* Only enter unique codes into the table.  */
if|if
condition|(
name|strcmp
argument_list|(
name|opcode
operator|->
name|name
argument_list|,
name|prev_name
argument_list|)
condition|)
block|{
name|hash_insert
argument_list|(
name|opcode_hash_control
argument_list|,
name|opcode
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opcode
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|opcode
operator|->
name|idx
operator|=
name|idx
expr_stmt|;
name|prev_name
operator|=
name|opcode
operator|->
name|name
expr_stmt|;
block|}
comment|/* Default to z8002.  */
name|s_unseg
argument_list|()
expr_stmt|;
comment|/* Insert the pseudo ops, too.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|md_pseudo_table
index|[
name|idx
index|]
operator|.
name|poc_name
condition|;
name|idx
operator|++
control|)
block|{
name|opcode_entry_type
modifier|*
name|fake_opcode
decl_stmt|;
name|fake_opcode
operator|=
operator|(
name|opcode_entry_type
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|opcode_entry_type
argument_list|)
argument_list|)
expr_stmt|;
name|fake_opcode
operator|->
name|name
operator|=
name|md_pseudo_table
index|[
name|idx
index|]
operator|.
name|poc_name
expr_stmt|;
name|fake_opcode
operator|->
name|func
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|md_pseudo_table
operator|+
name|idx
operator|)
expr_stmt|;
name|fake_opcode
operator|->
name|opcode
operator|=
literal|250
expr_stmt|;
name|hash_insert
argument_list|(
name|opcode_hash_control
argument_list|,
name|fake_opcode
operator|->
name|name
argument_list|,
name|fake_opcode
argument_list|)
expr_stmt|;
block|}
name|linkrelax
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|z8k_exp
block|{
name|char
modifier|*
name|e_beg
decl_stmt|;
name|char
modifier|*
name|e_end
decl_stmt|;
name|expressionS
name|e_exp
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|z8k_op
block|{
comment|/* 'b','w','r','q'.  */
name|char
name|regsize
decl_stmt|;
comment|/* 0 .. 15.  */
name|unsigned
name|int
name|reg
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* Any other register associated with the mode.  */
name|unsigned
name|int
name|x_reg
decl_stmt|;
comment|/* Any expression.  */
name|expressionS
name|exp
decl_stmt|;
block|}
name|op_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|expressionS
modifier|*
name|da_operand
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|expressionS
modifier|*
name|imm_operand
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reg
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|the_cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|the_ctrl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|the_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|the_interrupt
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|whatreg
parameter_list|(
name|reg
parameter_list|,
name|src
parameter_list|)
name|int
modifier|*
name|reg
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|src
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
name|src
operator|+
literal|2
return|;
block|}
else|else
block|{
operator|*
name|reg
operator|=
operator|(
name|src
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
name|src
operator|+
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse operands     rh0-rh7, rl0-rl7    r0-r15    rr0-rr14    rq0--rq12    WREG r0,r1,r2,r3,r4,r5,r6,r7,fp,sp    r0l,r0h,..r7l,r7h    @WREG    @WREG+    @-WREG    #const */
end_comment

begin_comment
comment|/* Try to parse a reg name.  Return a pointer to the first character    in SRC after the reg name.  */
end_comment

begin_function
name|char
modifier|*
name|parse_reg
parameter_list|(
name|src
parameter_list|,
name|mode
parameter_list|,
name|reg
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
name|int
modifier|*
name|mode
decl_stmt|;
name|unsigned
name|int
modifier|*
name|reg
decl_stmt|;
block|{
name|char
modifier|*
name|res
init|=
literal|0
decl_stmt|;
name|char
name|regno
decl_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
operator|(
name|src
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|src
index|[
literal|2
index|]
operator|==
literal|','
operator|)
condition|)
block|{
if|if
condition|(
name|segmented_mode
condition|)
block|{
operator|*
name|mode
operator|=
name|CLASS_REG_LONG
expr_stmt|;
operator|*
name|reg
operator|=
literal|14
expr_stmt|;
block|}
else|else
block|{
operator|*
name|mode
operator|=
name|CLASS_REG_WORD
expr_stmt|;
operator|*
name|reg
operator|=
literal|15
expr_stmt|;
block|}
return|return
name|src
operator|+
literal|2
return|;
block|}
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|<
literal|'0'
operator|||
name|src
index|[
literal|2
index|]
operator|>
literal|'9'
condition|)
return|return
name|res
return|;
comment|/* Assume no register name but a label starting with 'rr'.  */
operator|*
name|mode
operator|=
name|CLASS_REG_LONG
expr_stmt|;
name|res
operator|=
name|whatreg
argument_list|(
name|reg
argument_list|,
name|src
operator|+
literal|2
argument_list|)
expr_stmt|;
name|regno
operator|=
operator|*
name|reg
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|14
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"register rr%d, out of range."
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|<
literal|'0'
operator|||
name|src
index|[
literal|2
index|]
operator|>
literal|'9'
condition|)
return|return
name|res
return|;
comment|/* Assume no register name but a label starting with 'rh'.  */
operator|*
name|mode
operator|=
name|CLASS_REG_BYTE
expr_stmt|;
name|res
operator|=
name|whatreg
argument_list|(
name|reg
argument_list|,
name|src
operator|+
literal|2
argument_list|)
expr_stmt|;
name|regno
operator|=
operator|*
name|reg
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|7
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"register rh%d, out of range."
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|<
literal|'0'
operator|||
name|src
index|[
literal|2
index|]
operator|>
literal|'9'
condition|)
return|return
name|res
return|;
comment|/* Assume no register name but a label starting with 'rl'.  */
operator|*
name|mode
operator|=
name|CLASS_REG_BYTE
expr_stmt|;
name|res
operator|=
name|whatreg
argument_list|(
name|reg
argument_list|,
name|src
operator|+
literal|2
argument_list|)
expr_stmt|;
name|regno
operator|=
operator|*
name|reg
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|7
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"register rl%d, out of range."
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
operator|*
name|reg
operator|+=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
literal|'q'
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|2
index|]
operator|<
literal|'0'
operator|||
name|src
index|[
literal|2
index|]
operator|>
literal|'9'
condition|)
return|return
name|res
return|;
comment|/* Assume no register name but a label starting with 'rq'.  */
operator|*
name|mode
operator|=
name|CLASS_REG_QUAD
expr_stmt|;
name|res
operator|=
name|whatreg
argument_list|(
name|reg
argument_list|,
name|src
operator|+
literal|2
argument_list|)
expr_stmt|;
name|regno
operator|=
operator|*
name|reg
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|12
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"register rq%d, out of range."
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|<
literal|'0'
operator|||
name|src
index|[
literal|1
index|]
operator|>
literal|'9'
condition|)
return|return
name|res
return|;
comment|/* Assume no register name but a label starting with 'r'.  */
operator|*
name|mode
operator|=
name|CLASS_REG_WORD
expr_stmt|;
name|res
operator|=
name|whatreg
argument_list|(
name|reg
argument_list|,
name|src
operator|+
literal|1
argument_list|)
expr_stmt|;
name|regno
operator|=
operator|*
name|reg
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|15
condition|)
name|as_warn
argument_list|(
name|_
argument_list|(
literal|"register r%d, out of range."
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|parse_exp
parameter_list|(
name|s
parameter_list|,
name|op
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|expressionS
modifier|*
name|op
decl_stmt|;
block|{
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|expression
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|X_op
operator|==
name|O_absent
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"missing operand"
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* The many forms of operand:<rb><r><rr><rq>    @r    #exp    exp    exp(r)    r(#exp)    r(r)    */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|checkfor
parameter_list|(
name|ptr
parameter_list|,
name|what
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|what
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
name|what
condition|)
name|ptr
operator|++
expr_stmt|;
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"expected %c"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Make sure the mode supplied is the size of a word.  */
end_comment

begin_function
specifier|static
name|void
name|regword
parameter_list|(
name|mode
parameter_list|,
name|string
parameter_list|)
name|int
name|mode
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|ok
decl_stmt|;
name|ok
operator|=
name|CLASS_REG_WORD
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
name|mode
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register is wrong size for a word %s"
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make sure the mode supplied is the size of an address.  */
end_comment

begin_function
specifier|static
name|void
name|regaddr
parameter_list|(
name|mode
parameter_list|,
name|string
parameter_list|)
name|int
name|mode
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|ok
decl_stmt|;
name|ok
operator|=
name|segmented_mode
condition|?
name|CLASS_REG_LONG
else|:
name|CLASS_REG_WORD
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
name|mode
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"register is wrong size for address %s"
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|ctrl_names
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|ctrl_names
name|ctrl_table
index|[]
init|=
block|{
block|{
literal|0x2
block|,
literal|"fcw"
block|}
block|,
block|{
literal|0x3
block|,
literal|"refresh"
block|}
block|,
block|{
literal|0x4
block|,
literal|"psapseg"
block|}
block|,
block|{
literal|0x5
block|,
literal|"psapoff"
block|}
block|,
block|{
literal|0x5
block|,
literal|"psap"
block|}
block|,
block|{
literal|0x6
block|,
literal|"nspseg"
block|}
block|,
block|{
literal|0x7
block|,
literal|"nspoff"
block|}
block|,
block|{
literal|0x7
block|,
literal|"nsp"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_ctrl_operand
parameter_list|(
name|ptr
parameter_list|,
name|mode
parameter_list|,
name|dst
parameter_list|)
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|struct
name|z8k_op
modifier|*
name|mode
decl_stmt|;
name|unsigned
name|int
name|dst
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|==
literal|' '
condition|)
name|src
operator|++
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_CTRL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ctrl_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|ctrl_table
index|[
name|i
index|]
operator|.
name|name
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ctrl_table
index|[
name|i
index|]
operator|.
name|name
index|[
name|j
index|]
operator|!=
name|src
index|[
name|j
index|]
condition|)
goto|goto
name|fail
goto|;
block|}
name|the_ctrl
operator|=
name|ctrl_table
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
operator|*
name|ptr
operator|=
name|src
operator|+
name|j
expr_stmt|;
return|return;
name|fail
label|:
empty_stmt|;
block|}
name|the_ctrl
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_struct
struct|struct
name|flag_names
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|flag_names
name|flag_table
index|[]
init|=
block|{
block|{
literal|0x1
block|,
literal|"p"
block|}
block|,
block|{
literal|0x1
block|,
literal|"v"
block|}
block|,
block|{
literal|0x2
block|,
literal|"s"
block|}
block|,
block|{
literal|0x4
block|,
literal|"z"
block|}
block|,
block|{
literal|0x8
block|,
literal|"c"
block|}
block|,
block|{
literal|0x0
block|,
literal|"+"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_flags_operand
parameter_list|(
name|ptr
parameter_list|,
name|mode
parameter_list|,
name|dst
parameter_list|)
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|struct
name|z8k_op
modifier|*
name|mode
decl_stmt|;
name|unsigned
name|int
name|dst
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|==
literal|' '
condition|)
name|src
operator|++
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_FLAGS
expr_stmt|;
name|the_flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|9
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|src
index|[
name|j
index|]
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|flag_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|flag_table
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
name|src
index|[
name|j
index|]
condition|)
block|{
name|the_flags
operator|=
name|the_flags
operator||
name|flag_table
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
goto|goto
name|match
goto|;
block|}
block|}
goto|goto
name|done
goto|;
name|match
label|:
empty_stmt|;
block|}
name|done
label|:
operator|*
name|ptr
operator|=
name|src
operator|+
name|j
expr_stmt|;
return|return;
block|}
end_function

begin_struct
struct|struct
name|interrupt_names
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|interrupt_names
name|intr_table
index|[]
init|=
block|{
block|{
literal|0x1
block|,
literal|"nvi"
block|}
block|,
block|{
literal|0x2
block|,
literal|"vi"
block|}
block|,
block|{
literal|0x3
block|,
literal|"both"
block|}
block|,
block|{
literal|0x3
block|,
literal|"all"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_interrupt_operand
parameter_list|(
name|ptr
parameter_list|,
name|mode
parameter_list|,
name|dst
parameter_list|)
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|struct
name|z8k_op
modifier|*
name|mode
decl_stmt|;
name|unsigned
name|int
name|dst
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|==
literal|' '
condition|)
name|src
operator|++
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_IMM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|intr_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|intr_table
index|[
name|i
index|]
operator|.
name|name
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|intr_table
index|[
name|i
index|]
operator|.
name|name
index|[
name|j
index|]
operator|!=
name|src
index|[
name|j
index|]
condition|)
goto|goto
name|fail
goto|;
block|}
name|the_interrupt
operator|=
name|intr_table
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
operator|*
name|ptr
operator|=
name|src
operator|+
name|j
expr_stmt|;
return|return;
name|fail
label|:
empty_stmt|;
block|}
name|the_interrupt
operator|=
literal|0x0
expr_stmt|;
return|return;
block|}
end_function

begin_struct
struct|struct
name|cc_names
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|cc_names
name|table
index|[]
init|=
block|{
block|{
literal|0x0
block|,
literal|"f"
block|}
block|,
block|{
literal|0x1
block|,
literal|"lt"
block|}
block|,
block|{
literal|0x2
block|,
literal|"le"
block|}
block|,
block|{
literal|0x3
block|,
literal|"ule"
block|}
block|,
block|{
literal|0x4
block|,
literal|"ov"
block|}
block|,
block|{
literal|0x4
block|,
literal|"pe"
block|}
block|,
block|{
literal|0x5
block|,
literal|"mi"
block|}
block|,
block|{
literal|0x6
block|,
literal|"eq"
block|}
block|,
block|{
literal|0x6
block|,
literal|"z"
block|}
block|,
block|{
literal|0x7
block|,
literal|"c"
block|}
block|,
block|{
literal|0x7
block|,
literal|"ult"
block|}
block|,
block|{
literal|0x8
block|,
literal|"t"
block|}
block|,
block|{
literal|0x9
block|,
literal|"ge"
block|}
block|,
block|{
literal|0xa
block|,
literal|"gt"
block|}
block|,
block|{
literal|0xb
block|,
literal|"ugt"
block|}
block|,
block|{
literal|0xc
block|,
literal|"nov"
block|}
block|,
block|{
literal|0xc
block|,
literal|"po"
block|}
block|,
block|{
literal|0xd
block|,
literal|"pl"
block|}
block|,
block|{
literal|0xe
block|,
literal|"ne"
block|}
block|,
block|{
literal|0xe
block|,
literal|"nz"
block|}
block|,
block|{
literal|0xf
block|,
literal|"nc"
block|}
block|,
block|{
literal|0xf
block|,
literal|"uge"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_cc_operand
parameter_list|(
name|ptr
parameter_list|,
name|mode
parameter_list|,
name|dst
parameter_list|)
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|struct
name|z8k_op
modifier|*
name|mode
decl_stmt|;
name|unsigned
name|int
name|dst
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|==
literal|' '
condition|)
name|src
operator|++
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_CC
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|name
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|name
index|[
name|j
index|]
operator|!=
name|src
index|[
name|j
index|]
condition|)
goto|goto
name|fail
goto|;
block|}
name|the_cc
operator|=
name|table
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
operator|*
name|ptr
operator|=
name|src
operator|+
name|j
expr_stmt|;
return|return;
name|fail
label|:
empty_stmt|;
block|}
name|the_cc
operator|=
literal|0x8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_operand
parameter_list|(
name|ptr
parameter_list|,
name|mode
parameter_list|,
name|dst
parameter_list|)
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|struct
name|z8k_op
modifier|*
name|mode
decl_stmt|;
name|unsigned
name|int
name|dst
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|src
init|=
operator|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|mode
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|==
literal|' '
condition|)
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'#'
condition|)
block|{
name|mode
operator|->
name|mode
operator|=
name|CLASS_IMM
expr_stmt|;
name|imm_operand
operator|=
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
expr_stmt|;
name|src
operator|=
name|parse_exp
argument_list|(
name|src
operator|+
literal|1
argument_list|,
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|src
operator|==
literal|'@'
condition|)
block|{
name|int
name|d
decl_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_IR
expr_stmt|;
name|src
operator|=
name|parse_reg
argument_list|(
name|src
operator|+
literal|1
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|mode
operator|->
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|regn
decl_stmt|;
name|end
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|mode
operator|->
name|mode
argument_list|,
operator|&
name|regn
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
name|int
name|nw
decl_stmt|,
name|nr
decl_stmt|;
name|src
operator|=
name|end
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'('
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|end
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
name|nw
argument_list|,
operator|&
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
comment|/* Got Ra(Rb).  */
name|src
operator|=
name|end
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|!=
literal|')'
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Missing ) in ra(rb)"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src
operator|++
expr_stmt|;
name|regaddr
argument_list|(
name|mode
operator|->
name|mode
argument_list|,
literal|"ra(rb) ra"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|regword (mode->mode, "ra(rb) rb");
endif|#
directive|endif
name|mode
operator|->
name|mode
operator|=
name|CLASS_BX
expr_stmt|;
name|mode
operator|->
name|reg
operator|=
name|regn
expr_stmt|;
name|mode
operator|->
name|x_reg
operator|=
name|nr
expr_stmt|;
name|reg
index|[
name|ARG_RX
index|]
operator|=
name|nr
expr_stmt|;
block|}
else|else
block|{
comment|/* Got Ra(disp).  */
if|if
condition|(
operator|*
name|src
operator|==
literal|'#'
condition|)
name|src
operator|++
expr_stmt|;
name|src
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|,
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|checkfor
argument_list|(
name|src
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_BA
expr_stmt|;
name|mode
operator|->
name|reg
operator|=
name|regn
expr_stmt|;
name|mode
operator|->
name|x_reg
operator|=
literal|0
expr_stmt|;
name|imm_operand
operator|=
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mode
operator|->
name|reg
operator|=
name|regn
expr_stmt|;
name|mode
operator|->
name|x_reg
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* No initial reg.  */
name|src
operator|=
name|parse_exp
argument_list|(
name|src
argument_list|,
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'('
condition|)
block|{
name|src
operator|++
expr_stmt|;
name|end
operator|=
name|parse_reg
argument_list|(
name|src
argument_list|,
operator|&
operator|(
name|mode
operator|->
name|mode
operator|)
argument_list|,
operator|&
name|regn
argument_list|)
expr_stmt|;
name|regword
argument_list|(
name|mode
operator|->
name|mode
argument_list|,
literal|"addr(Ra) ra"
argument_list|)
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|CLASS_X
expr_stmt|;
name|mode
operator|->
name|reg
operator|=
name|regn
expr_stmt|;
name|mode
operator|->
name|x_reg
operator|=
literal|0
expr_stmt|;
name|da_operand
operator|=
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
expr_stmt|;
name|src
operator|=
name|checkfor
argument_list|(
name|end
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just an address.  */
name|mode
operator|->
name|mode
operator|=
name|CLASS_DA
expr_stmt|;
name|mode
operator|->
name|reg
operator|=
literal|0
expr_stmt|;
name|mode
operator|->
name|x_reg
operator|=
literal|0
expr_stmt|;
name|da_operand
operator|=
operator|&
operator|(
name|mode
operator|->
name|exp
operator|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|ptr
operator|=
name|src
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_operands
parameter_list|(
name|opcode
parameter_list|,
name|op_end
parameter_list|,
name|operand
parameter_list|)
name|opcode_entry_type
modifier|*
name|opcode
decl_stmt|;
name|char
modifier|*
name|op_end
decl_stmt|;
name|op_type
modifier|*
name|operand
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
init|=
name|op_end
decl_stmt|;
name|char
modifier|*
name|savptr
decl_stmt|;
switch|switch
condition|(
name|opcode
operator|->
name|noperands
condition|)
block|{
case|case
literal|0
case|:
name|operand
index|[
literal|0
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|arg_info
index|[
literal|0
index|]
operator|==
name|CLASS_CC
condition|)
block|{
name|get_cc_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|arg_info
index|[
literal|0
index|]
operator|==
name|CLASS_FLAGS
condition|)
block|{
name|get_flags_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|arg_info
index|[
literal|0
index|]
operator|==
operator|(
name|CLASS_IMM
operator|+
operator|(
name|ARG_IMM2
operator|)
operator|)
condition|)
block|{
name|get_interrupt_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|operand
index|[
literal|1
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptr
operator|++
expr_stmt|;
name|savptr
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|arg_info
index|[
literal|0
index|]
operator|==
name|CLASS_CC
condition|)
block|{
name|get_cc_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|->
name|arg_info
index|[
literal|0
index|]
operator|==
name|CLASS_CTRL
condition|)
block|{
name|get_ctrl_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_ctrl
operator|==
literal|0
condition|)
block|{
name|ptr
operator|=
name|savptr
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_ctrl_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
block|}
else|else
block|{
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|','
condition|)
name|ptr
operator|++
expr_stmt|;
name|get_cc_operand
argument_list|(
operator|&
name|ptr
argument_list|,
name|operand
operator|+
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Passed a pointer to a list of opcodes which use different    addressing modes.  Return the opcode which matches the opcodes    provided.  */
end_comment

begin_function
specifier|static
name|opcode_entry_type
modifier|*
name|get_specific
parameter_list|(
name|opcode
parameter_list|,
name|operands
parameter_list|)
name|opcode_entry_type
modifier|*
name|opcode
decl_stmt|;
name|op_type
modifier|*
name|operands
decl_stmt|;
block|{
name|opcode_entry_type
modifier|*
name|this_try
init|=
name|opcode
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|noperands
init|=
name|opcode
operator|->
name|noperands
decl_stmt|;
name|int
name|this_index
init|=
name|opcode
operator|->
name|idx
decl_stmt|;
while|while
condition|(
name|this_index
operator|==
name|opcode
operator|->
name|idx
operator|&&
operator|!
name|found
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|this_try
operator|=
name|opcode
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|mode
init|=
name|operands
index|[
name|i
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|CLASS_MASK
operator|)
operator|!=
operator|(
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
operator|&
name|CLASS_MASK
operator|)
condition|)
block|{
comment|/* It could be an pc rel operand, if this is a da mode 		 and we like disps, then insert it.  */
if|if
condition|(
name|mode
operator|==
name|CLASS_DA
operator|&&
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
operator|==
name|CLASS_DISP
condition|)
block|{
comment|/* This is the case.  */
name|operands
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|CLASS_DISP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CLASS_BA
operator|&&
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
condition|)
block|{
comment|/* Can't think of a way to turn what we've been 		     given into something that's OK.  */
goto|goto
name|fail
goto|;
block|}
elseif|else
if|if
condition|(
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
operator|&
name|CLASS_PR
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|CLASS_REG_LONG
operator|&&
name|segmented_mode
condition|)
block|{
comment|/* OK.  */
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CLASS_REG_WORD
operator|&&
operator|!
name|segmented_mode
condition|)
block|{
comment|/* OK.  */
block|}
else|else
goto|goto
name|fail
goto|;
block|}
else|else
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|mode
operator|&
name|CLASS_MASK
condition|)
block|{
default|default:
break|break;
case|case
name|CLASS_X
case|:
case|case
name|CLASS_IR
case|:
case|case
name|CLASS_BA
case|:
case|case
name|CLASS_BX
case|:
case|case
name|CLASS_DISP
case|:
case|case
name|CLASS_REG
case|:
case|case
name|CLASS_REG_WORD
case|:
case|case
name|CLASS_REG_BYTE
case|:
case|case
name|CLASS_REG_QUAD
case|:
case|case
name|CLASS_REG_LONG
case|:
case|case
name|CLASS_REGN0
case|:
name|reg
index|[
name|this_try
operator|->
name|arg_info
index|[
name|i
index|]
operator|&
name|ARG_MASK
index|]
operator|=
name|operands
index|[
name|i
index|]
operator|.
name|reg
expr_stmt|;
break|break;
block|}
block|}
name|found
operator|=
literal|1
expr_stmt|;
name|fail
label|:
empty_stmt|;
block|}
if|if
condition|(
name|found
condition|)
return|return
name|this_try
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not used.  */
end_comment

begin_comment
unit|static void check_operand (operand, width, string)      struct z8k_op *operand;      unsigned int width;      char *string; {   if (operand->exp.X_add_symbol == 0&& operand->exp.X_op_symbol == 0)     {
comment|/* No symbol involved, let's look at offset, it's dangerous if 	 any of the high bits are not 0 or ff's, find out by oring or 	 anding with the width and seeing if the answer is 0 or all 	 fs.  */
end_comment

begin_endif
unit|if ((operand->exp.X_add_number& ~width) != 0&& 	  (operand->exp.X_add_number | width) != (~0)) 	{ 	  as_warn (_("operand %s0x%x out of range."), 		   string, operand->exp.X_add_number); 	}     }  }
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|newfix
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|,
name|operand
parameter_list|)
name|int
name|ptr
decl_stmt|;
name|int
name|type
decl_stmt|;
name|expressionS
modifier|*
name|operand
decl_stmt|;
block|{
if|if
condition|(
name|operand
operator|->
name|X_add_symbol
operator|||
name|operand
operator|->
name|X_op_symbol
operator|||
name|operand
operator|->
name|X_add_number
condition|)
block|{
name|fix_new_exp
argument_list|(
name|frag_now
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|,
name|operand
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|apply_fix
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|,
name|operand
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|type
decl_stmt|;
name|expressionS
modifier|*
name|operand
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|n
init|=
name|operand
operator|->
name|X_add_number
decl_stmt|;
name|newfix
argument_list|(
operator|(
name|ptr
operator|-
name|buffer
operator|)
operator|/
literal|2
argument_list|,
name|type
argument_list|,
name|operand
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
comment|/* 8 nibbles == 32 bits.  */
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|28
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|24
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|20
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|16
expr_stmt|;
case|case
literal|4
case|:
comment|/* 4 nibbles == 16 bits.  */
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|12
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|8
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|4
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|ptr
operator|++
operator|=
name|n
operator|>>
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Now we know what sort of opcodes it is.  Let's build the bytes.  */
end_comment

begin_define
define|#
directive|define
name|INSERT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|*x++ = y>>24; *x++ = y>> 16; *x++=y>>8; *x++ =y;
end_define

begin_function
specifier|static
name|void
name|build_bytes
parameter_list|(
name|this_try
parameter_list|,
name|operand
parameter_list|)
name|opcode_entry_type
modifier|*
name|this_try
decl_stmt|;
name|struct
name|z8k_op
modifier|*
name|operand
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|output_ptr
init|=
name|buffer
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|nib
decl_stmt|;
name|int
name|nibble
decl_stmt|;
name|unsigned
name|int
modifier|*
name|class_ptr
decl_stmt|;
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buffer
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|class_ptr
operator|=
name|this_try
operator|->
name|byte_info
expr_stmt|;
for|for
control|(
name|nibble
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|class_ptr
operator|++
operator|)
condition|;
name|nibble
operator|++
control|)
block|{
switch|switch
condition|(
name|c
operator|&
name|CLASS_MASK
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|CLASS_ADDRESS
case|:
comment|/* Direct address, we don't cope with the SS mode right now.  */
if|if
condition|(
name|segmented_mode
condition|)
block|{
comment|/* da_operand->X_add_number |= 0x80000000;  --  Now set at relocation time.  */
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_IMM32
argument_list|,
name|da_operand
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_IMM16
argument_list|,
name|da_operand
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|da_operand
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLASS_DISP8
case|:
comment|/* pc rel 8 bit  */
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_JR
argument_list|,
name|da_operand
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|da_operand
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLASS_0DISP7
case|:
comment|/* pc rel 7 bit  */
operator|*
name|output_ptr
operator|=
literal|0
expr_stmt|;
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_DISP7
argument_list|,
name|da_operand
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|da_operand
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLASS_1DISP7
case|:
comment|/* pc rel 7 bit  */
operator|*
name|output_ptr
operator|=
literal|0x80
expr_stmt|;
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_DISP7
argument_list|,
name|da_operand
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|output_ptr
index|[
operator|-
literal|2
index|]
operator|=
literal|0x8
expr_stmt|;
name|da_operand
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLASS_BIT_1OR2
case|:
operator|*
name|output_ptr
operator|=
name|c
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|imm_operand
condition|)
block|{
if|if
condition|(
name|imm_operand
operator|->
name|X_add_number
operator|==
literal|2
condition|)
operator|*
name|output_ptr
operator||=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|imm_operand
operator|->
name|X_add_number
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"immediate must be 1 or 2"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"immediate 1 or 2 expected"
argument_list|)
argument_list|)
expr_stmt|;
name|output_ptr
operator|++
expr_stmt|;
break|break;
case|case
name|CLASS_CC
case|:
operator|*
name|output_ptr
operator|++
operator|=
name|the_cc
expr_stmt|;
break|break;
case|case
name|CLASS_0CCC
case|:
operator|*
name|output_ptr
operator|++
operator|=
name|the_ctrl
expr_stmt|;
break|break;
case|case
name|CLASS_1CCC
case|:
operator|*
name|output_ptr
operator|++
operator|=
name|the_ctrl
operator||
literal|0x8
expr_stmt|;
break|break;
case|case
name|CLASS_00II
case|:
operator|*
name|output_ptr
operator|++
operator|=
operator|(
operator|~
name|the_interrupt
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
case|case
name|CLASS_01II
case|:
operator|*
name|output_ptr
operator|++
operator|=
operator|(
operator|~
name|the_interrupt
operator|&
literal|0x3
operator|)
operator||
literal|0x4
expr_stmt|;
break|break;
case|case
name|CLASS_FLAGS
case|:
operator|*
name|output_ptr
operator|++
operator|=
name|the_flags
expr_stmt|;
break|break;
case|case
name|CLASS_BIT
case|:
operator|*
name|output_ptr
operator|++
operator|=
name|c
operator|&
literal|0xf
expr_stmt|;
break|break;
case|case
name|CLASS_REGN0
case|:
if|if
condition|(
name|reg
index|[
name|c
operator|&
literal|0xf
index|]
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't use R0 here"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|CLASS_REG
case|:
case|case
name|CLASS_REG_BYTE
case|:
case|case
name|CLASS_REG_WORD
case|:
case|case
name|CLASS_REG_LONG
case|:
case|case
name|CLASS_REG_QUAD
case|:
comment|/* Insert bit mattern of right reg.  */
operator|*
name|output_ptr
operator|++
operator|=
name|reg
index|[
name|c
operator|&
literal|0xf
index|]
expr_stmt|;
break|break;
case|case
name|CLASS_DISP
case|:
switch|switch
condition|(
name|c
operator|&
name|ARG_MASK
condition|)
block|{
case|case
name|ARG_DISP12
case|:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_CALLR
argument_list|,
name|da_operand
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_DISP16
case|:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_REL16
argument_list|,
name|da_operand
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_IMM16
argument_list|,
name|da_operand
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|da_operand
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLASS_IMM
case|:
block|{
name|nib
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
operator|&
name|ARG_MASK
condition|)
block|{
case|case
name|ARG_IMM4
case|:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_IMM4L
argument_list|,
name|imm_operand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_IMM4M1
case|:
name|imm_operand
operator|->
name|X_add_number
operator|--
expr_stmt|;
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_IMM4L
argument_list|,
name|imm_operand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_IMMNMINUS1
case|:
name|imm_operand
operator|->
name|X_add_number
operator|--
expr_stmt|;
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_IMM4L
argument_list|,
name|imm_operand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_NIM8
case|:
name|imm_operand
operator|->
name|X_add_number
operator|=
operator|-
name|imm_operand
operator|->
name|X_add_number
expr_stmt|;
case|case
name|ARG_IMM8
case|:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_IMM8
argument_list|,
name|imm_operand
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_IMM16
case|:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_IMM16
argument_list|,
name|imm_operand
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_IMM32
case|:
name|output_ptr
operator|=
name|apply_fix
argument_list|(
name|output_ptr
argument_list|,
name|R_IMM32
argument_list|,
name|imm_operand
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Copy from the nibble buffer into the frag.  */
block|{
name|int
name|length
init|=
operator|(
name|output_ptr
operator|-
name|buffer
operator|)
operator|/
literal|2
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|buffer
decl_stmt|;
name|char
modifier|*
name|fragp
init|=
name|frag_more
argument_list|(
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|src
operator|<
name|output_ptr
condition|)
block|{
operator|*
name|fragp
operator|=
operator|(
name|src
index|[
literal|0
index|]
operator|<<
literal|4
operator|)
operator||
name|src
index|[
literal|1
index|]
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|fragp
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  STR points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|op_start
decl_stmt|;
name|char
modifier|*
name|op_end
decl_stmt|;
name|struct
name|z8k_op
name|operand
index|[
literal|3
index|]
decl_stmt|;
name|opcode_entry_type
modifier|*
name|opcode
decl_stmt|;
name|opcode_entry_type
modifier|*
name|prev_opcode
decl_stmt|;
comment|/* Drop leading whitespace.  */
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Find the op code end.  */
for|for
control|(
name|op_start
operator|=
name|op_end
operator|=
name|str
init|;
operator|*
name|op_end
operator|!=
literal|0
operator|&&
operator|*
name|op_end
operator|!=
literal|' '
condition|;
name|op_end
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|op_end
operator|==
name|op_start
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"can't find opcode "
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|op_end
expr_stmt|;
operator|*
name|op_end
operator|=
literal|0
expr_stmt|;
name|opcode
operator|=
operator|(
name|opcode_entry_type
operator|*
operator|)
name|hash_find
argument_list|(
name|opcode_hash_control
argument_list|,
name|op_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"unknown opcode"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|opcode
operator|->
name|opcode
operator|==
literal|250
condition|)
block|{
comment|/* Was really a pseudo op.  */
name|pseudo_typeS
modifier|*
name|p
decl_stmt|;
name|char
name|oc
decl_stmt|;
name|char
modifier|*
name|old
init|=
name|input_line_pointer
decl_stmt|;
operator|*
name|op_end
operator|=
name|c
expr_stmt|;
name|input_line_pointer
operator|=
name|op_end
expr_stmt|;
name|oc
operator|=
operator|*
name|old
expr_stmt|;
operator|*
name|old
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|' '
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
name|p
operator|=
operator|(
name|pseudo_typeS
operator|*
operator|)
operator|(
name|opcode
operator|->
name|func
operator|)
expr_stmt|;
call|(
name|p
operator|->
name|poc_handler
call|)
argument_list|(
name|p
operator|->
name|poc_val
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|old
expr_stmt|;
operator|*
name|old
operator|=
name|oc
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|=
name|get_operands
argument_list|(
name|opcode
argument_list|,
name|op_end
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|prev_opcode
operator|=
name|opcode
expr_stmt|;
name|opcode
operator|=
name|get_specific
argument_list|(
name|opcode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
block|{
comment|/* Couldn't find an opcode which matched the operands.  */
name|char
modifier|*
name|where
init|=
name|frag_more
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|where
index|[
literal|0
index|]
operator|=
literal|0x0
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can't find opcode to match operands"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|build_bytes
argument_list|(
name|opcode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tc_crawl_symbol_chain
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to tc_crawl_symbol_chain \n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|tc_headers_hook
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to tc_headers_hook \n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Various routines to kill one day.  */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant    of type TYPE, and store the appropriate bytes in *LITP.  The number    of LITTLENUMS emitted is stored in *SIZEP.  An error message is    returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|atof_ieee
parameter_list|()
function_decl|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
name|_
argument_list|(
literal|"Bad call to MD_ATOF()"
argument_list|)
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|CONST
name|char
modifier|*
name|md_shortopts
init|=
literal|"z:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|md_longopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|md_longopts_size
init|=
sizeof|sizeof
argument_list|(
name|md_longopts
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|md_parse_option
parameter_list|(
name|c
parameter_list|,
name|arg
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'z'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"8001"
argument_list|)
condition|)
name|s_segm
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"8002"
argument_list|)
condition|)
name|s_unseg
argument_list|()
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"invalid architecture -z%s"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|md_show_usage
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\ Z8K options:\n\ -z8001			generate segmented code\n\ -z8002			generate unsegmented code\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|()
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to tc_aout_fix_to_chars \n"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|seg
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|segT
name|seg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call to md_convert_frag \n"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|valueT
name|md_section_align
parameter_list|(
name|seg
parameter_list|,
name|size
parameter_list|)
name|segT
name|seg
decl_stmt|;
name|valueT
name|size
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|size
operator|+
operator|(
literal|1
operator|<<
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix3
parameter_list|(
name|fixP
parameter_list|,
name|valP
parameter_list|,
name|segment
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|valueT
modifier|*
name|valP
decl_stmt|;
name|segT
name|segment
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|long
name|val
init|=
operator|*
operator|(
name|long
operator|*
operator|)
name|valP
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|R_IMM4L
case|:
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0xf0
operator|)
operator||
operator|(
operator|(
name|buf
index|[
literal|0
index|]
operator|+
name|val
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
break|break;
case|case
name|R_JR
case|:
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
if|#
directive|if
literal|0
block|if (val != 0) 	abort ();
endif|#
directive|endif
break|break;
case|case
name|R_DISP7
case|:
operator|*
name|buf
operator|++
operator|+=
name|val
expr_stmt|;
if|#
directive|if
literal|0
block|if (val != 0) 	abort ();
endif|#
directive|endif
break|break;
case|case
name|R_IMM8
case|:
name|buf
index|[
literal|0
index|]
operator|+=
name|val
expr_stmt|;
break|break;
case|case
name|R_IMM16
case|:
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|R_IMM32
case|:
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case R_DA | R_SEG:       *buf++ = (val>> 16);       *buf++ = 0x00;       *buf++ = (val>> 8);       *buf++ = val;       break;
endif|#
directive|endif
case|case
literal|0
case|:
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|==
literal|0
condition|)
name|fixP
operator|->
name|fx_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment_type
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|segT
name|segment_type
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"call tomd_estimate_size_before_relax \n"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put number into target byte order.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|ptr
parameter_list|,
name|use
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|valueT
name|use
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|number_to_chars_bigendian
argument_list|(
name|ptr
argument_list|,
name|use
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tc_coff_symbol_emit_hook
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|tc_reloc_mangle
parameter_list|(
name|fix_ptr
parameter_list|,
name|intr
parameter_list|,
name|base
parameter_list|)
name|fixS
modifier|*
name|fix_ptr
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|intr
decl_stmt|;
name|bfd_vma
name|base
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbol_ptr
decl_stmt|;
if|if
condition|(
name|fix_ptr
operator|->
name|fx_addsy
operator|&&
name|fix_ptr
operator|->
name|fx_subsy
condition|)
block|{
name|symbolS
modifier|*
name|add
init|=
name|fix_ptr
operator|->
name|fx_addsy
decl_stmt|;
name|symbolS
modifier|*
name|sub
init|=
name|fix_ptr
operator|->
name|fx_subsy
decl_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|add
argument_list|)
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|sub
argument_list|)
condition|)
name|as_bad
argument_list|(
name|_
argument_list|(
literal|"Can't subtract symbols in different sections %s %s"
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|add
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|diff
init|=
name|S_GET_VALUE
argument_list|(
name|add
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sub
argument_list|)
decl_stmt|;
name|fix_ptr
operator|->
name|fx_addsy
operator|=
literal|0
expr_stmt|;
name|fix_ptr
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
name|fix_ptr
operator|->
name|fx_offset
operator|+=
name|diff
expr_stmt|;
block|}
block|}
name|symbol_ptr
operator|=
name|fix_ptr
operator|->
name|fx_addsy
expr_stmt|;
comment|/* If this relocation is attached to a symbol then it's ok      to output it.  */
if|if
condition|(
name|fix_ptr
operator|->
name|fx_r_type
operator|==
literal|0
condition|)
block|{
comment|/* cons likes to create reloc32's whatever the size of the reloc.  */
switch|switch
condition|(
name|fix_ptr
operator|->
name|fx_size
condition|)
block|{
case|case
literal|2
case|:
name|intr
operator|->
name|r_type
operator|=
name|R_IMM16
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|intr
operator|->
name|r_type
operator|=
name|R_IMM8
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|intr
operator|->
name|r_type
operator|=
name|R_IMM32
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|intr
operator|->
name|r_type
operator|=
name|fix_ptr
operator|->
name|fx_r_type
expr_stmt|;
name|intr
operator|->
name|r_vaddr
operator|=
name|fix_ptr
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fix_ptr
operator|->
name|fx_where
operator|+
name|base
expr_stmt|;
name|intr
operator|->
name|r_offset
operator|=
name|fix_ptr
operator|->
name|fx_offset
expr_stmt|;
if|if
condition|(
name|symbol_ptr
condition|)
name|intr
operator|->
name|r_symndx
operator|=
name|symbol_ptr
operator|->
name|sy_number
expr_stmt|;
else|else
name|intr
operator|->
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

end_unit

