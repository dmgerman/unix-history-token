begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2011 Michihiro NAKAJIMA  * Copyright (c) 2003-2007 Kees Zeelenberg  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * A set of compatibility glue for building libarchive on Windows platforms.  *  * Originally created as "libarchive-nonposix.c" by Kees Zeelenberg  * for the GnuWin32 project, trimmed significantly by Tim Kientzle.  *  * Much of the original file was unnecessary for libarchive, because  * many of the features it emulated were not strictly necessary for  * libarchive.  I hope for this to shrink further as libarchive  * internals are gradually reworked to sit more naturally on both  * POSIX and Windows.  Any ideas for this are greatly appreciated.  *  * The biggest remaining issue is the dev/ino emulation; libarchive  * has a couple of public APIs that rely on dev/ino uniquely  * identifying a file.  This doesn't match well with Windows.  I'm  * considering alternative APIs.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UTIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<share.h>
end_include

begin_define
define|#
directive|define
name|EPOC_TIME
value|ARCHIVE_LITERAL_ULL(116444736000000000)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__LA_LSEEK_NEEDED
argument_list|)
end_if

begin_function
specifier|static
name|BOOL
name|SetFilePointerEx_perso
parameter_list|(
name|HANDLE
name|hFile
parameter_list|,
name|LARGE_INTEGER
name|liDistanceToMove
parameter_list|,
name|PLARGE_INTEGER
name|lpNewFilePointer
parameter_list|,
name|DWORD
name|dwMoveMethod
parameter_list|)
block|{
name|LARGE_INTEGER
name|li
decl_stmt|;
name|li
operator|.
name|QuadPart
operator|=
name|liDistanceToMove
operator|.
name|QuadPart
expr_stmt|;
name|li
operator|.
name|LowPart
operator|=
name|SetFilePointer
argument_list|(
name|hFile
argument_list|,
name|li
operator|.
name|LowPart
argument_list|,
operator|&
name|li
operator|.
name|HighPart
argument_list|,
name|dwMoveMethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|lpNewFilePointer
condition|)
block|{
name|lpNewFilePointer
operator|->
name|QuadPart
operator|=
name|li
operator|.
name|QuadPart
expr_stmt|;
block|}
return|return
name|li
operator|.
name|LowPart
operator|!=
operator|-
literal|1
operator|||
name|GetLastError
argument_list|()
operator|==
name|NO_ERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|ustat
block|{
name|int64_t
name|st_atime
decl_stmt|;
name|uint32_t
name|st_atime_nsec
decl_stmt|;
name|int64_t
name|st_ctime
decl_stmt|;
name|uint32_t
name|st_ctime_nsec
decl_stmt|;
name|int64_t
name|st_mtime
decl_stmt|;
name|uint32_t
name|st_mtime_nsec
decl_stmt|;
name|gid_t
name|st_gid
decl_stmt|;
comment|/* 64bits ino */
name|int64_t
name|st_ino
decl_stmt|;
name|mode_t
name|st_mode
decl_stmt|;
name|uint32_t
name|st_nlink
decl_stmt|;
name|uint64_t
name|st_size
decl_stmt|;
name|uid_t
name|st_uid
decl_stmt|;
name|dev_t
name|st_dev
decl_stmt|;
name|dev_t
name|st_rdev
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Transform 64-bits ino into 32-bits by hashing.  * You do not forget that really unique number size is 64-bits.  */
end_comment

begin_define
define|#
directive|define
name|INOSIZE
value|(8*sizeof(ino_t))
end_define

begin_comment
comment|/* 32 */
end_comment

begin_function
specifier|static
name|__inline
name|ino_t
name|getino
parameter_list|(
name|struct
name|ustat
modifier|*
name|ub
parameter_list|)
block|{
name|ULARGE_INTEGER
name|ino64
decl_stmt|;
name|ino64
operator|.
name|QuadPart
operator|=
name|ub
operator|->
name|st_ino
expr_stmt|;
comment|/* I don't know this hashing is correct way */
return|return
operator|(
call|(
name|ino_t
call|)
argument_list|(
name|ino64
operator|.
name|LowPart
operator|^
operator|(
name|ino64
operator|.
name|LowPart
operator|>>
name|INOSIZE
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepend "\\?\" to the path name and convert it to unicode to permit  * an extended-length path for a maximum total path length of 32767  * characters.  * see also http://msdn.microsoft.com/en-us/library/aa365247.aspx  */
end_comment

begin_function
name|wchar_t
modifier|*
name|__la_win_permissive_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|wchar_t
modifier|*
name|wn
decl_stmt|;
name|wchar_t
modifier|*
name|ws
decl_stmt|;
name|size_t
name|ll
decl_stmt|;
name|ll
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|wn
operator|=
name|malloc
argument_list|(
operator|(
name|ll
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ll
operator|=
name|mbstowcs
argument_list|(
name|wn
argument_list|,
name|name
argument_list|,
name|ll
argument_list|)
expr_stmt|;
if|if
condition|(
name|ll
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|wn
index|[
name|ll
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
name|ws
operator|=
name|__la_win_permissive_name_w
argument_list|(
name|wn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|ws
operator|)
return|;
block|}
end_function

begin_function
name|wchar_t
modifier|*
name|__la_win_permissive_name_w
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|wname
parameter_list|)
block|{
name|wchar_t
modifier|*
name|wn
decl_stmt|,
modifier|*
name|wnp
decl_stmt|;
name|wchar_t
modifier|*
name|ws
decl_stmt|,
modifier|*
name|wsp
decl_stmt|;
name|DWORD
name|l
decl_stmt|,
name|len
decl_stmt|,
name|slen
decl_stmt|;
name|int
name|unc
decl_stmt|;
comment|/* Get a full-pathname. */
name|l
operator|=
name|GetFullPathNameW
argument_list|(
name|wname
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* NOTE: GetFullPathNameW has a bug that if the length of the file 	 * name is just 1 then it returns incomplete buffer size. Thus, we 	 * have to add three to the size to allocate a sufficient buffer 	 * size for the full-pathname of the file name. */
name|l
operator|+=
literal|3
expr_stmt|;
name|wnp
operator|=
name|malloc
argument_list|(
name|l
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wnp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|len
operator|=
name|GetFullPathNameW
argument_list|(
name|wname
argument_list|,
name|l
argument_list|,
name|wnp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wn
operator|=
name|wnp
expr_stmt|;
if|if
condition|(
name|wnp
index|[
literal|0
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|1
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|2
index|]
operator|==
literal|L'
expr|?'
operator|&&
name|wnp
index|[
literal|3
index|]
operator|==
literal|L'
expr|\\'
condition|)
comment|/* We have already a permissive name. */
return|return
operator|(
name|wn
operator|)
return|;
if|if
condition|(
name|wnp
index|[
literal|0
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|1
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|2
index|]
operator|==
literal|L'
expr|.'
operator|&&
name|wnp
index|[
literal|3
index|]
operator|==
literal|L'
expr|\\'
condition|)
block|{
comment|/* This is a device name */
if|if
condition|(
operator|(
operator|(
name|wnp
index|[
literal|4
index|]
operator|>=
literal|L'
expr|a'
operator|&&
name|wnp
index|[
literal|4
index|]
operator|<=
literal|L'
expr|z'
operator|)
operator|||
operator|(
name|wnp
index|[
literal|4
index|]
operator|>=
literal|L'
expr|A'
operator|&&
name|wnp
index|[
literal|4
index|]
operator|<=
literal|L'
expr|Z'
operator|)
operator|)
operator|&&
name|wnp
index|[
literal|5
index|]
operator|==
literal|L'
expr|:'
operator|&&
name|wnp
index|[
literal|6
index|]
operator|==
literal|L'
expr|\\'
condition|)
name|wnp
index|[
literal|2
index|]
operator|=
literal|L'
expr|?'
expr_stmt|;
comment|/* Not device name. */
return|return
operator|(
name|wn
operator|)
return|;
block|}
name|unc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wnp
index|[
literal|0
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|1
index|]
operator|==
literal|L'
expr|\\'
operator|&&
name|wnp
index|[
literal|2
index|]
operator|!=
literal|L'
expr|\\'
condition|)
block|{
name|wchar_t
modifier|*
name|p
init|=
operator|&
name|wnp
index|[
literal|2
index|]
decl_stmt|;
comment|/* Skip server-name letters. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|L'
expr|\\'
operator|&&
operator|*
name|p
operator|!=
literal|L'
expr|\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|L'
expr|\\'
condition|)
block|{
name|wchar_t
modifier|*
name|rp
init|=
operator|++
name|p
decl_stmt|;
comment|/* Skip share-name letters. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|L'
expr|\\'
operator|&&
operator|*
name|p
operator|!=
literal|L'
expr|\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|L'
expr|\\'
operator|&&
name|p
operator|!=
name|rp
condition|)
block|{
comment|/* Now, match patterns such as 				 * "\\server-name\share-name\" */
name|wnp
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
name|unc
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|slen
operator|=
literal|4
operator|+
operator|(
name|unc
operator|*
literal|4
operator|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|ws
operator|=
name|wsp
operator|=
name|malloc
argument_list|(
name|slen
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* prepend "\\?\" */
name|wcsncpy
argument_list|(
name|wsp
argument_list|,
literal|L"\\\\?\\"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wsp
operator|+=
literal|4
expr_stmt|;
name|slen
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|unc
condition|)
block|{
comment|/* append "UNC\" ---> "\\?\UNC\" */
name|wcsncpy
argument_list|(
name|wsp
argument_list|,
literal|L"UNC\\"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wsp
operator|+=
literal|4
expr_stmt|;
name|slen
operator|-=
literal|4
expr_stmt|;
block|}
name|wcsncpy
argument_list|(
name|wsp
argument_list|,
name|wnp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|wsp
index|[
name|slen
operator|-
literal|1
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
comment|/* Ensure null termination. */
name|free
argument_list|(
name|wn
argument_list|)
expr_stmt|;
return|return
operator|(
name|ws
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a file handle.  * This can exceed MAX_PATH limitation.  */
end_comment

begin_function
specifier|static
name|HANDLE
name|la_CreateFile
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|DWORD
name|dwDesiredAccess
parameter_list|,
name|DWORD
name|dwShareMode
parameter_list|,
name|LPSECURITY_ATTRIBUTES
name|lpSecurityAttributes
parameter_list|,
name|DWORD
name|dwCreationDisposition
parameter_list|,
name|DWORD
name|dwFlagsAndAttributes
parameter_list|,
name|HANDLE
name|hTemplateFile
parameter_list|)
block|{
name|wchar_t
modifier|*
name|wpath
decl_stmt|;
name|HANDLE
name|handle
decl_stmt|;
name|handle
operator|=
name|CreateFileA
argument_list|(
name|path
argument_list|,
name|dwDesiredAccess
argument_list|,
name|dwShareMode
argument_list|,
name|lpSecurityAttributes
argument_list|,
name|dwCreationDisposition
argument_list|,
name|dwFlagsAndAttributes
argument_list|,
name|hTemplateFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
return|return
operator|(
name|handle
operator|)
return|;
if|if
condition|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_PATH_NOT_FOUND
condition|)
return|return
operator|(
name|handle
operator|)
return|;
name|wpath
operator|=
name|__la_win_permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpath
operator|==
name|NULL
condition|)
return|return
operator|(
name|handle
operator|)
return|;
name|handle
operator|=
name|CreateFileW
argument_list|(
name|wpath
argument_list|,
name|dwDesiredAccess
argument_list|,
name|dwShareMode
argument_list|,
name|lpSecurityAttributes
argument_list|,
name|dwCreationDisposition
argument_list|,
name|dwFlagsAndAttributes
argument_list|,
name|hTemplateFile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|handle
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__LA_LSEEK_NEEDED
argument_list|)
end_if

begin_function
name|__int64
name|__la_lseek
parameter_list|(
name|int
name|fd
parameter_list|,
name|__int64
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|LARGE_INTEGER
name|distance
decl_stmt|;
name|LARGE_INTEGER
name|newpointer
decl_stmt|;
name|HANDLE
name|handle
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|handle
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|GetFileType
argument_list|(
name|handle
argument_list|)
operator|!=
name|FILE_TYPE_DISK
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|distance
operator|.
name|QuadPart
operator|=
name|offset
expr_stmt|;
if|if
condition|(
operator|!
name|SetFilePointerEx_perso
argument_list|(
name|handle
argument_list|,
name|distance
argument_list|,
operator|&
name|newpointer
argument_list|,
name|whence
argument_list|)
condition|)
block|{
name|DWORD
name|lasterr
decl_stmt|;
name|lasterr
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|lasterr
operator|==
name|ERROR_BROKEN_PIPE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lasterr
operator|==
name|ERROR_ACCESS_DENIED
condition|)
name|errno
operator|=
name|EBADF
expr_stmt|;
else|else
name|la_dosmaperr
argument_list|(
name|lasterr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|newpointer
operator|.
name|QuadPart
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This can exceed MAX_PATH limitation. */
end_comment

begin_function
name|int
name|__la_open
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|wchar_t
modifier|*
name|ws
decl_stmt|;
name|int
name|r
decl_stmt|,
name|pmode
decl_stmt|;
name|DWORD
name|attr
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pmode
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ws
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|~
name|O_BINARY
operator|)
operator|==
name|O_RDONLY
condition|)
block|{
comment|/* 		 * When we open a directory, _open function returns  		 * "Permission denied" error. 		 */
name|attr
operator|=
name|GetFileAttributesA
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
operator|&&
name|GetLastError
argument_list|()
operator|==
name|ERROR_PATH_NOT_FOUND
condition|)
block|{
name|ws
operator|=
name|__la_win_permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|attr
operator|=
name|GetFileAttributesW
argument_list|(
name|ws
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|attr
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
block|{
name|HANDLE
name|handle
decl_stmt|;
if|if
condition|(
name|ws
operator|!=
name|NULL
condition|)
name|handle
operator|=
name|CreateFileW
argument_list|(
name|ws
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
operator||
name|FILE_ATTRIBUTE_READONLY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|handle
operator|=
name|CreateFileA
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
operator||
name|FILE_ATTRIBUTE_READONLY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|_open_osfhandle
argument_list|(
operator|(
name|intptr_t
operator|)
name|handle
argument_list|,
name|_O_RDONLY
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
comment|/* Borland has no mode argument. 		   TODO: Fix mode of new file.  */
name|r
operator|=
name|_open
argument_list|(
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|_open
argument_list|(
name|path
argument_list|,
name|flags
argument_list|,
name|pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EACCES
operator|&&
operator|(
name|flags
operator|&
name|O_CREAT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Simulate other POSIX system action to pass our test suite. */
name|attr
operator|=
name|GetFileAttributesA
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
name|errno
operator|=
name|EISDIR
expr_stmt|;
else|else
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|r
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|ws
operator|=
name|__la_win_permissive_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|r
operator|=
name|_wopen
argument_list|(
name|ws
argument_list|,
name|flags
argument_list|,
name|pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EACCES
operator|&&
operator|(
name|flags
operator|&
name|O_CREAT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Simulate other POSIX system action to pass our test suite. */
name|attr
operator|=
name|GetFileAttributesW
argument_list|(
name|ws
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
operator|(
name|DWORD
operator|)
operator|-
literal|1
condition|)
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
name|errno
operator|=
name|EISDIR
expr_stmt|;
else|else
name|errno
operator|=
name|EACCES
expr_stmt|;
block|}
name|free
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|__la_read
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|HANDLE
name|handle
decl_stmt|;
name|DWORD
name|bytes_read
decl_stmt|,
name|lasterr
decl_stmt|;
name|int
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN64
if|if
condition|(
name|nbytes
operator|>
name|UINT32_MAX
condition|)
name|nbytes
operator|=
name|UINT32_MAX
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Do not pass 0 to third parameter of ReadFile(), read bytes. 	 * This will not return to application side. */
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|handle
operator|=
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|r
operator|=
name|ReadFile
argument_list|(
name|handle
argument_list|,
name|buf
argument_list|,
operator|(
name|uint32_t
operator|)
name|nbytes
argument_list|,
operator|&
name|bytes_read
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|lasterr
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|lasterr
operator|==
name|ERROR_NO_DATA
condition|)
block|{
name|errno
operator|=
name|EAGAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lasterr
operator|==
name|ERROR_BROKEN_PIPE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lasterr
operator|==
name|ERROR_ACCESS_DENIED
condition|)
name|errno
operator|=
name|EBADF
expr_stmt|;
else|else
name|la_dosmaperr
argument_list|(
name|lasterr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|ssize_t
operator|)
name|bytes_read
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert Windows FILETIME to UTC */
end_comment

begin_function
name|__inline
specifier|static
name|void
name|fileTimeToUTC
parameter_list|(
specifier|const
name|FILETIME
modifier|*
name|filetime
parameter_list|,
name|time_t
modifier|*
name|t
parameter_list|,
name|long
modifier|*
name|ns
parameter_list|)
block|{
name|ULARGE_INTEGER
name|utc
decl_stmt|;
name|utc
operator|.
name|HighPart
operator|=
name|filetime
operator|->
name|dwHighDateTime
expr_stmt|;
name|utc
operator|.
name|LowPart
operator|=
name|filetime
operator|->
name|dwLowDateTime
expr_stmt|;
if|if
condition|(
name|utc
operator|.
name|QuadPart
operator|>=
name|EPOC_TIME
condition|)
block|{
name|utc
operator|.
name|QuadPart
operator|-=
name|EPOC_TIME
expr_stmt|;
operator|*
name|t
operator|=
call|(
name|time_t
call|)
argument_list|(
name|utc
operator|.
name|QuadPart
operator|/
literal|10000000
argument_list|)
expr_stmt|;
comment|/* milli seconds base */
operator|*
name|ns
operator|=
call|(
name|long
call|)
argument_list|(
name|utc
operator|.
name|QuadPart
operator|%
literal|10000000
argument_list|)
operator|*
literal|100
expr_stmt|;
comment|/* nano seconds base */
block|}
else|else
block|{
operator|*
name|t
operator|=
literal|0
expr_stmt|;
operator|*
name|ns
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Stat by handle  * Windows' stat() does not accept the path added "\\?\" especially "?"  * character.  * It means we cannot access the long name path longer than MAX_PATH.  * So I've implemented simular Windows' stat() to access the long name path.  * And I've added some feature.  * 1. set st_ino by nFileIndexHigh and nFileIndexLow of  *    BY_HANDLE_FILE_INFORMATION.  * 2. set st_nlink by nNumberOfLinks of BY_HANDLE_FILE_INFORMATION.  * 3. set st_dev by dwVolumeSerialNumber by BY_HANDLE_FILE_INFORMATION.  */
end_comment

begin_function
specifier|static
name|int
name|__hstat
parameter_list|(
name|HANDLE
name|handle
parameter_list|,
name|struct
name|ustat
modifier|*
name|st
parameter_list|)
block|{
name|BY_HANDLE_FILE_INFORMATION
name|info
decl_stmt|;
name|ULARGE_INTEGER
name|ino64
decl_stmt|;
name|DWORD
name|ftype
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|long
name|ns
decl_stmt|;
switch|switch
condition|(
name|ftype
operator|=
name|GetFileType
argument_list|(
name|handle
argument_list|)
condition|)
block|{
case|case
name|FILE_TYPE_UNKNOWN
case|:
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|FILE_TYPE_CHAR
case|:
case|case
name|FILE_TYPE_PIPE
case|:
if|if
condition|(
name|ftype
operator|==
name|FILE_TYPE_CHAR
condition|)
block|{
name|st
operator|->
name|st_mode
operator|=
name|S_IFCHR
expr_stmt|;
name|st
operator|->
name|st_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DWORD
name|avail
decl_stmt|;
name|st
operator|->
name|st_mode
operator|=
name|S_IFIFO
expr_stmt|;
if|if
condition|(
name|PeekNamedPipe
argument_list|(
name|handle
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|avail
argument_list|,
name|NULL
argument_list|)
condition|)
name|st
operator|->
name|st_size
operator|=
name|avail
expr_stmt|;
else|else
name|st
operator|->
name|st_size
operator|=
literal|0
expr_stmt|;
block|}
name|st
operator|->
name|st_atime
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_atime_nsec
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_mtime
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_mtime_nsec
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_ctime
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_ctime_nsec
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_ino
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_nlink
operator|=
literal|1
expr_stmt|;
name|st
operator|->
name|st_uid
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_gid
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_rdev
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_dev
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FILE_TYPE_DISK
case|:
break|break;
default|default:
comment|/* This ftype is undocumented type. */
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ZeroMemory
argument_list|(
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|GetFileInformationByHandle
argument_list|(
name|handle
argument_list|,
operator|&
name|info
argument_list|)
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mode
operator|=
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|.
name|dwFileAttributes
operator|&
name|FILE_ATTRIBUTE_READONLY
operator|)
operator|==
literal|0
condition|)
name|mode
operator||=
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|dwFileAttributes
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
name|mode
operator||=
name|S_IFDIR
operator||
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
expr_stmt|;
else|else
name|mode
operator||=
name|S_IFREG
expr_stmt|;
name|st
operator|->
name|st_mode
operator|=
name|mode
expr_stmt|;
name|fileTimeToUTC
argument_list|(
operator|&
name|info
operator|.
name|ftLastAccessTime
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|ns
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_atime
operator|=
name|t
expr_stmt|;
name|st
operator|->
name|st_atime_nsec
operator|=
name|ns
expr_stmt|;
name|fileTimeToUTC
argument_list|(
operator|&
name|info
operator|.
name|ftLastWriteTime
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|ns
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_mtime
operator|=
name|t
expr_stmt|;
name|st
operator|->
name|st_mtime_nsec
operator|=
name|ns
expr_stmt|;
name|fileTimeToUTC
argument_list|(
operator|&
name|info
operator|.
name|ftCreationTime
argument_list|,
operator|&
name|t
argument_list|,
operator|&
name|ns
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_ctime
operator|=
name|t
expr_stmt|;
name|st
operator|->
name|st_ctime_nsec
operator|=
name|ns
expr_stmt|;
name|st
operator|->
name|st_size
operator|=
operator|(
call|(
name|int64_t
call|)
argument_list|(
name|info
operator|.
name|nFileSizeHigh
argument_list|)
operator|*
operator|(
operator|(
name|int64_t
operator|)
name|MAXDWORD
operator|+
literal|1
operator|)
operator|)
operator|+
call|(
name|int64_t
call|)
argument_list|(
name|info
operator|.
name|nFileSizeLow
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIMULATE_WIN_STAT
name|st
operator|->
name|st_ino
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_nlink
operator|=
literal|1
expr_stmt|;
name|st
operator|->
name|st_dev
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* Getting FileIndex as i-node. We should remove a sequence which 	 * is high-16-bits of nFileIndexHigh. */
name|ino64
operator|.
name|HighPart
operator|=
name|info
operator|.
name|nFileIndexHigh
operator|&
literal|0x0000FFFFUL
expr_stmt|;
name|ino64
operator|.
name|LowPart
operator|=
name|info
operator|.
name|nFileIndexLow
expr_stmt|;
name|st
operator|->
name|st_ino
operator|=
name|ino64
operator|.
name|QuadPart
expr_stmt|;
name|st
operator|->
name|st_nlink
operator|=
name|info
operator|.
name|nNumberOfLinks
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|dwFileAttributes
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
operator|++
name|st
operator|->
name|st_nlink
expr_stmt|;
comment|/* Add parent directory. */
name|st
operator|->
name|st_dev
operator|=
name|info
operator|.
name|dwVolumeSerialNumber
expr_stmt|;
endif|#
directive|endif
name|st
operator|->
name|st_uid
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_gid
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_rdev
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_stat
parameter_list|(
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|struct
name|ustat
modifier|*
name|us
parameter_list|)
block|{
name|st
operator|->
name|st_atime
operator|=
name|us
operator|->
name|st_atime
expr_stmt|;
name|st
operator|->
name|st_ctime
operator|=
name|us
operator|->
name|st_ctime
expr_stmt|;
name|st
operator|->
name|st_mtime
operator|=
name|us
operator|->
name|st_mtime
expr_stmt|;
name|st
operator|->
name|st_gid
operator|=
name|us
operator|->
name|st_gid
expr_stmt|;
name|st
operator|->
name|st_ino
operator|=
name|getino
argument_list|(
name|us
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_mode
operator|=
name|us
operator|->
name|st_mode
expr_stmt|;
name|st
operator|->
name|st_nlink
operator|=
name|us
operator|->
name|st_nlink
expr_stmt|;
name|st
operator|->
name|st_size
operator|=
operator|(
name|off_t
operator|)
name|us
operator|->
name|st_size
expr_stmt|;
name|st
operator|->
name|st_uid
operator|=
name|us
operator|->
name|st_uid
expr_stmt|;
name|st
operator|->
name|st_dev
operator|=
name|us
operator|->
name|st_dev
expr_stmt|;
name|st
operator|->
name|st_rdev
operator|=
name|us
operator|->
name|st_rdev
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TODO: Remove a use of __la_fstat and __la_stat.  * We should use GetFileInformationByHandle in place  * where We still use the *stat functions.  */
end_comment

begin_function
name|int
name|__la_fstat
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|ustat
name|u
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|__hstat
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|copy_stat
argument_list|(
name|st
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|st_mode
operator|&
operator|(
name|S_IFCHR
operator||
name|S_IFIFO
operator|)
condition|)
block|{
name|st
operator|->
name|st_dev
operator|=
name|fd
expr_stmt|;
name|st
operator|->
name|st_rdev
operator|=
name|fd
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This can exceed MAX_PATH limitation. */
end_comment

begin_function
name|int
name|__la_stat
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
name|HANDLE
name|handle
decl_stmt|;
name|struct
name|ustat
name|u
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|handle
operator|=
name|la_CreateFile
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|OPEN_EXISTING
argument_list|,
name|FILE_FLAG_BACKUP_SEMANTICS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|__hstat
argument_list|(
name|handle
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|copy_stat
argument_list|(
name|st
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|p
argument_list|)
operator|==
literal|4
condition|)
block|{
name|char
name|exttype
index|[
literal|4
index|]
decl_stmt|;
operator|++
name|p
expr_stmt|;
name|exttype
index|[
literal|0
index|]
operator|=
name|toupper
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|exttype
index|[
literal|1
index|]
operator|=
name|toupper
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|exttype
index|[
literal|2
index|]
operator|=
name|toupper
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|exttype
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|exttype
argument_list|,
literal|"EXE"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|exttype
argument_list|,
literal|"CMD"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|exttype
argument_list|,
literal|"BAT"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|exttype
argument_list|,
literal|"COM"
argument_list|)
condition|)
name|st
operator|->
name|st_mode
operator||=
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This waitpid is limited implementation.  */
end_comment

begin_function
name|pid_t
name|__la_waitpid
parameter_list|(
name|HANDLE
name|child
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|option
parameter_list|)
block|{
name|DWORD
name|cs
decl_stmt|;
operator|(
name|void
operator|)
name|option
expr_stmt|;
comment|/* UNUSED */
do|do
block|{
if|if
condition|(
name|GetExitCodeProcess
argument_list|(
name|child
argument_list|,
operator|&
name|cs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CloseHandle
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|la_dosmaperr
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
name|cs
operator|==
name|STILL_ACTIVE
condition|)
do|;
operator|*
name|status
operator|=
call|(
name|int
call|)
argument_list|(
name|cs
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|__la_write
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|DWORD
name|bytes_written
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN64
if|if
condition|(
name|nbytes
operator|>
name|UINT32_MAX
condition|)
name|nbytes
operator|=
name|UINT32_MAX
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|WriteFile
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|(
name|uint32_t
operator|)
name|nbytes
argument_list|,
operator|&
name|bytes_written
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|DWORD
name|lasterr
decl_stmt|;
name|lasterr
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|lasterr
operator|==
name|ERROR_ACCESS_DENIED
condition|)
name|errno
operator|=
name|EBADF
expr_stmt|;
else|else
name|la_dosmaperr
argument_list|(
name|lasterr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|bytes_written
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Replace the Windows path separator '\' with '/'.  */
end_comment

begin_function
specifier|static
name|int
name|replace_pathseparator
parameter_list|(
name|struct
name|archive_wstring
modifier|*
name|ws
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|wp
parameter_list|)
block|{
name|wchar_t
modifier|*
name|w
decl_stmt|;
name|size_t
name|path_length
decl_stmt|;
if|if
condition|(
name|wp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|wcschr
argument_list|(
name|wp
argument_list|,
literal|L'
expr|\\'
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|path_length
operator|=
name|wcslen
argument_list|(
name|wp
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_wstring_ensure
argument_list|(
name|ws
argument_list|,
name|path_length
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|archive_wstrncpy
argument_list|(
name|ws
argument_list|,
name|wp
argument_list|,
name|path_length
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
name|ws
operator|->
name|s
init|;
operator|*
name|w
condition|;
name|w
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|w
operator|==
literal|L'
expr|\\'
condition|)
operator|*
name|w
operator|=
literal|L'
expr|/'
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fix_pathseparator
parameter_list|(
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|archive_wstring
name|ws
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|ws
argument_list|)
expr_stmt|;
name|wp
operator|=
name|archive_entry_pathname_w
argument_list|(
name|entry
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|replace_pathseparator
argument_list|(
operator|&
name|ws
argument_list|,
name|wp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Not replaced. */
break|break;
case|case
literal|1
case|:
comment|/* Replaced. */
name|archive_entry_copy_pathname_w
argument_list|(
name|entry
argument_list|,
name|ws
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
block|}
name|wp
operator|=
name|archive_entry_hardlink_w
argument_list|(
name|entry
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|replace_pathseparator
argument_list|(
operator|&
name|ws
argument_list|,
name|wp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Not replaced. */
break|break;
case|case
literal|1
case|:
comment|/* Replaced. */
name|archive_entry_copy_hardlink_w
argument_list|(
name|entry
argument_list|,
name|ws
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
block|}
name|wp
operator|=
name|archive_entry_symlink_w
argument_list|(
name|entry
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|replace_pathseparator
argument_list|(
operator|&
name|ws
argument_list|,
name|wp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Not replaced. */
break|break;
case|case
literal|1
case|:
comment|/* Replaced. */
name|archive_entry_copy_symlink_w
argument_list|(
name|entry
argument_list|,
name|ws
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ARCHIVE_FAILED
expr_stmt|;
block|}
name|archive_wstring_free
argument_list|(
operator|&
name|ws
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|archive_entry
modifier|*
name|__la_win_entry_in_posix_pathseparator
parameter_list|(
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|archive_entry
modifier|*
name|entry_main
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
name|int
name|has_backslash
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|wp
operator|=
name|archive_entry_pathname_w
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
operator|&&
name|wcschr
argument_list|(
name|wp
argument_list|,
literal|L'
expr|\\'
argument_list|)
operator|!=
name|NULL
condition|)
name|has_backslash
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|has_backslash
condition|)
block|{
name|wp
operator|=
name|archive_entry_hardlink_w
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
operator|&&
name|wcschr
argument_list|(
name|wp
argument_list|,
literal|L'
expr|\\'
argument_list|)
operator|!=
name|NULL
condition|)
name|has_backslash
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|has_backslash
condition|)
block|{
name|wp
operator|=
name|archive_entry_symlink_w
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
operator|&&
name|wcschr
argument_list|(
name|wp
argument_list|,
literal|L'
expr|\\'
argument_list|)
operator|!=
name|NULL
condition|)
name|has_backslash
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If there is no backslach chars, return the original. 	 */
if|if
condition|(
operator|!
name|has_backslash
condition|)
return|return
operator|(
name|entry
operator|)
return|;
comment|/* Copy entry so we can modify it as needed. */
name|entry_main
operator|=
name|archive_entry_clone
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_main
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Replace the Windows path-separator '\' with '/'. */
name|ret
operator|=
name|fix_pathseparator
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|ARCHIVE_WARN
condition|)
block|{
name|archive_entry_free
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|entry_main
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following function was modified from PostgreSQL sources and is  * subject to the copyright below.  */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------  *  * win32error.c  *	  Map win32 error codes to errno values  *  * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group  *  * IDENTIFICATION  *	  $PostgreSQL: pgsql/src/port/win32error.c,v 1.4 2008/01/01 19:46:00 momjian Exp $  *  *-------------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* PostgreSQL Database Management System (formerly known as Postgres, then as Postgres95)  Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group  Portions Copyright (c) 1994, The Regents of the University of California  Permission to use, copy, modify, and distribute this software and its documentation for any purpose, without fee, and without a written agreement is hereby granted, provided that the above copyright notice and this paragraph and the following two paragraphs appear in all copies.  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|DWORD
name|winerr
decl_stmt|;
name|int
name|doserr
decl_stmt|;
block|}
name|doserrors
index|[]
init|=
block|{
block|{
name|ERROR_INVALID_FUNCTION
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_FILE_NOT_FOUND
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_PATH_NOT_FOUND
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_TOO_MANY_OPEN_FILES
block|,
name|EMFILE
block|}
block|,
block|{
name|ERROR_ACCESS_DENIED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_INVALID_HANDLE
block|,
name|EBADF
block|}
block|,
block|{
name|ERROR_ARENA_TRASHED
block|,
name|ENOMEM
block|}
block|,
block|{
name|ERROR_NOT_ENOUGH_MEMORY
block|,
name|ENOMEM
block|}
block|,
block|{
name|ERROR_INVALID_BLOCK
block|,
name|ENOMEM
block|}
block|,
block|{
name|ERROR_BAD_ENVIRONMENT
block|,
name|E2BIG
block|}
block|,
block|{
name|ERROR_BAD_FORMAT
block|,
name|ENOEXEC
block|}
block|,
block|{
name|ERROR_INVALID_ACCESS
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_INVALID_DATA
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_INVALID_DRIVE
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_CURRENT_DIRECTORY
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_NOT_SAME_DEVICE
block|,
name|EXDEV
block|}
block|,
block|{
name|ERROR_NO_MORE_FILES
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_LOCK_VIOLATION
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_SHARING_VIOLATION
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BAD_NETPATH
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_NETWORK_ACCESS_DENIED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BAD_NET_NAME
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_FILE_EXISTS
block|,
name|EEXIST
block|}
block|,
block|{
name|ERROR_CANNOT_MAKE
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_FAIL_I24
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_INVALID_PARAMETER
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_NO_PROC_SLOTS
block|,
name|EAGAIN
block|}
block|,
block|{
name|ERROR_DRIVE_LOCKED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BROKEN_PIPE
block|,
name|EPIPE
block|}
block|,
block|{
name|ERROR_DISK_FULL
block|,
name|ENOSPC
block|}
block|,
block|{
name|ERROR_INVALID_TARGET_HANDLE
block|,
name|EBADF
block|}
block|,
block|{
name|ERROR_INVALID_HANDLE
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_WAIT_NO_CHILDREN
block|,
name|ECHILD
block|}
block|,
block|{
name|ERROR_CHILD_NOT_COMPLETE
block|,
name|ECHILD
block|}
block|,
block|{
name|ERROR_DIRECT_ACCESS_HANDLE
block|,
name|EBADF
block|}
block|,
block|{
name|ERROR_NEGATIVE_SEEK
block|,
name|EINVAL
block|}
block|,
block|{
name|ERROR_SEEK_ON_DEVICE
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_DIR_NOT_EMPTY
block|,
name|ENOTEMPTY
block|}
block|,
block|{
name|ERROR_NOT_LOCKED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_BAD_PATHNAME
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_MAX_THRDS_REACHED
block|,
name|EAGAIN
block|}
block|,
block|{
name|ERROR_LOCK_FAILED
block|,
name|EACCES
block|}
block|,
block|{
name|ERROR_ALREADY_EXISTS
block|,
name|EEXIST
block|}
block|,
block|{
name|ERROR_FILENAME_EXCED_RANGE
block|,
name|ENOENT
block|}
block|,
block|{
name|ERROR_NESTING_NOT_ALLOWED
block|,
name|EAGAIN
block|}
block|,
block|{
name|ERROR_NOT_ENOUGH_QUOTA
block|,
name|ENOMEM
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|__la_dosmaperr
parameter_list|(
name|unsigned
name|long
name|e
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|doserrors
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|doserrors
index|[
name|i
index|]
operator|.
name|winerr
operator|==
name|e
condition|)
block|{
name|errno
operator|=
name|doserrors
index|[
name|i
index|]
operator|.
name|doserr
expr_stmt|;
return|return;
block|}
block|}
comment|/* fprintf(stderr, "unrecognized win32 error code: %lu", e); */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32&& !__CYGWIN__ */
end_comment

end_unit

