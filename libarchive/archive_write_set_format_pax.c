begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * Copyright (c) 2010-2012 Michihiro NAKAJIMA  * Copyright (c) 2016 Martin Matuska  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD: head/lib/libarchive/archive_write_set_format_pax.c 201162 2009-12-29 05:47:46Z kientzle $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_write_private.h"
end_include

begin_struct
struct|struct
name|sparse_block
block|{
name|struct
name|sparse_block
modifier|*
name|next
decl_stmt|;
name|int
name|is_hole
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|uint64_t
name|remaining
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pax
block|{
name|uint64_t
name|entry_bytes_remaining
decl_stmt|;
name|uint64_t
name|entry_padding
decl_stmt|;
name|struct
name|archive_string
name|l_url_encoded_name
decl_stmt|;
name|struct
name|archive_string
name|pax_header
decl_stmt|;
name|struct
name|archive_string
name|sparse_map
decl_stmt|;
name|size_t
name|sparse_map_padding
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|sparse_list
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|sparse_tail
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_utf8
decl_stmt|;
name|int
name|opt_binary
decl_stmt|;
name|unsigned
name|flags
decl_stmt|;
define|#
directive|define
name|WRITE_SCHILY_XATTR
value|(1<< 0)
define|#
directive|define
name|WRITE_LIBARCHIVE_XATTR
value|(1<< 1)
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|add_pax_attr
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pax_attr_binary
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|size_t
name|value_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pax_attr_int
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pax_attr_time
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|sec
parameter_list|,
name|unsigned
name|long
name|nanos
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_pax_acl
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|struct
name|pax
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|archive_write_pax_data
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_close
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_free
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_header
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_options
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|base64_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|build_gnu_sparse_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|build_pax_attribute_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|build_ustar_entry_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|src_length
parameter_list|,
specifier|const
name|char
modifier|*
name|insert
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|format_int
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|has_non_ASCII
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparse_list_clear
parameter_list|(
name|struct
name|pax
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sparse_list_add
parameter_list|(
name|struct
name|pax
modifier|*
parameter_list|,
name|int64_t
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|url_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Set output format to 'restricted pax' format.  *  * This is the same as normal 'pax', but tries to suppress  * the pax header whenever possible.  This is the default for  * bsdtar, for instance.  */
end_comment

begin_function
name|int
name|archive_write_set_format_pax_restricted
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_WRITE_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_write_set_format_pax_restricted"
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_set_format_pax
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_RESTRICTED
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"restricted POSIX pax interchange"
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set output format to 'pax' format.  */
end_comment

begin_function
name|int
name|archive_write_set_format_pax
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_WRITE_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_write_set_format_pax"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|format_free
operator|!=
name|NULL
condition|)
call|(
name|a
operator|->
name|format_free
call|)
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|pax
operator|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pax
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pax
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate pax data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|pax
operator|->
name|flags
operator|=
name|WRITE_LIBARCHIVE_XATTR
operator||
name|WRITE_SCHILY_XATTR
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|pax
expr_stmt|;
name|a
operator|->
name|format_name
operator|=
literal|"pax"
expr_stmt|;
name|a
operator|->
name|format_options
operator|=
name|archive_write_pax_options
expr_stmt|;
name|a
operator|->
name|format_write_header
operator|=
name|archive_write_pax_header
expr_stmt|;
name|a
operator|->
name|format_write_data
operator|=
name|archive_write_pax_data
expr_stmt|;
name|a
operator|->
name|format_close
operator|=
name|archive_write_pax_close
expr_stmt|;
name|a
operator|->
name|format_free
operator|=
name|archive_write_pax_free
expr_stmt|;
name|a
operator|->
name|format_finish_entry
operator|=
name|archive_write_pax_finish_entry
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"POSIX pax interchange"
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_pax_options
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
init|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_FAILED
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"hdrcharset"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The character-set we can use are defined in 		 * IEEE Std 1003.1-2001 		 */
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|val
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"pax: hdrcharset option needs a character-set name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"BINARY"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"binary"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Specify binary mode. We will not convert 			 * filenames, uname and gname to any charsets. 			 */
name|pax
operator|->
name|opt_binary
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Specify UTF-8 character-set to be used for 			 * filenames. This is almost the test that 			 * running platform supports the string conversion. 			 * Especially libarchive_test needs this trick for 			 * its test. 			 */
name|pax
operator|->
name|sconv_utf8
operator|=
name|archive_string_conversion_to_charset
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
literal|"UTF-8"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pax
operator|->
name|sconv_utf8
operator|==
name|NULL
condition|)
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
else|else
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
block|}
else|else
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"pax: invalid charset name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Note: The "warn" return is just to inform the options 	 * supervisor that we didn't handle it.  It will generate 	 * a suitable error if no one used this option. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note: This code assumes that 'nanos' has the same sign as 'sec',  * which implies that sec=-1, nanos=200000000 represents -1.2 seconds  * and not -0.8 seconds.  This is a pretty pedantic point, as we're  * unlikely to encounter many real files created before Jan 1, 1970,  * much less ones with timestamps recorded to sub-second resolution.  */
end_comment

begin_function
specifier|static
name|void
name|add_pax_attr_time
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|sec
parameter_list|,
name|unsigned
name|long
name|nanos
parameter_list|)
block|{
name|int
name|digit
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
comment|/* 	 * Note that each byte contributes fewer than 3 base-10 	 * digits, so this will always be big enough. 	 */
name|char
name|tmp
index|[
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|sec
argument_list|)
operator|+
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|nanos
argument_list|)
index|]
decl_stmt|;
name|tmp
index|[
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|tmp
operator|+
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Skip trailing zeros in the fractional part. */
for|for
control|(
name|digit
operator|=
literal|0
operator|,
name|i
operator|=
literal|10
init|;
name|i
operator|>
literal|0
operator|&&
name|digit
operator|==
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|digit
operator|=
name|nanos
operator|%
literal|10
expr_stmt|;
name|nanos
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* Only format the fraction if it's non-zero. */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|*
operator|--
name|t
operator|=
literal|"0123456789"
index|[
name|digit
index|]
expr_stmt|;
name|digit
operator|=
name|nanos
operator|%
literal|10
expr_stmt|;
name|nanos
operator|/=
literal|10
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
operator|*
operator|--
name|t
operator|=
literal|'.'
expr_stmt|;
block|}
name|t
operator|=
name|format_int
argument_list|(
name|t
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|add_pax_attr
argument_list|(
name|as
argument_list|,
name|key
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|format_int
parameter_list|(
name|char
modifier|*
name|t
parameter_list|,
name|int64_t
name|i
parameter_list|)
block|{
name|uint64_t
name|ui
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|ui
operator|=
operator|(
name|i
operator|==
name|INT64_MIN
operator|)
condition|?
call|(
name|uint64_t
call|)
argument_list|(
name|INT64_MAX
argument_list|)
operator|+
literal|1
else|:
call|(
name|uint64_t
call|)
argument_list|(
operator|-
name|i
argument_list|)
expr_stmt|;
else|else
name|ui
operator|=
name|i
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|t
operator|=
literal|"0123456789"
index|[
name|ui
operator|%
literal|10
index|]
expr_stmt|;
block|}
do|while
condition|(
name|ui
operator|/=
literal|10
condition|)
do|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
operator|*
operator|--
name|t
operator|=
literal|'-'
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_pax_attr_int
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|value
parameter_list|)
block|{
name|char
name|tmp
index|[
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|value
argument_list|)
index|]
decl_stmt|;
name|tmp
index|[
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|add_pax_attr
argument_list|(
name|as
argument_list|,
name|key
argument_list|,
name|format_int
argument_list|(
name|tmp
operator|+
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a key/value attribute to the pax header.  This function handles  * the length field and various other syntactic requirements.  */
end_comment

begin_function
specifier|static
name|void
name|add_pax_attr
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|add_pax_attr_binary
argument_list|(
name|as
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a key/value attribute to the pax header.  This function handles  * binary values.  */
end_comment

begin_function
specifier|static
name|void
name|add_pax_attr_binary
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|size_t
name|value_len
parameter_list|)
block|{
name|int
name|digits
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|next_ten
decl_stmt|;
name|char
name|tmp
index|[
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
comment|/*< 3 base-10 digits per byte */
comment|/*- 	 * PAX attributes have the following layout: 	 *<len><space><key><=><value><nl> 	 */
name|len
operator|=
literal|1
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|key
argument_list|)
operator|+
literal|1
operator|+
operator|(
name|int
operator|)
name|value_len
operator|+
literal|1
expr_stmt|;
comment|/* 	 * The<len> field includes the length of the<len> field, so 	 * computing the correct length is tricky.  I start by 	 * counting the number of base-10 digits in 'len' and 	 * computing the next higher power of 10. 	 */
name|next_ten
operator|=
literal|1
expr_stmt|;
name|digits
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|i
operator|/
literal|10
expr_stmt|;
name|digits
operator|++
expr_stmt|;
name|next_ten
operator|=
name|next_ten
operator|*
literal|10
expr_stmt|;
block|}
comment|/* 	 * For example, if string without the length field is 99 	 * chars, then adding the 2 digit length "99" will force the 	 * total length past 100, requiring an extra digit.  The next 	 * statement adjusts for this effect. 	 */
if|if
condition|(
name|len
operator|+
name|digits
operator|>=
name|next_ten
condition|)
name|digits
operator|++
expr_stmt|;
comment|/* Now, we have the right length so we can build the line. */
name|tmp
index|[
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Null-terminate the work area. */
name|archive_strcat
argument_list|(
name|as
argument_list|,
name|format_int
argument_list|(
name|tmp
operator|+
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
argument_list|,
name|len
operator|+
name|digits
argument_list|)
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|as
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|archive_array_append
argument_list|(
name|as
argument_list|,
name|value
argument_list|,
name|value_len
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|archive_write_pax_header_xattr
parameter_list|(
name|struct
name|pax
modifier|*
name|pax
parameter_list|,
specifier|const
name|char
modifier|*
name|encoded_name
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|,
name|size_t
name|value_len
parameter_list|)
block|{
name|struct
name|archive_string
name|s
decl_stmt|;
name|char
modifier|*
name|encoded_value
decl_stmt|;
if|if
condition|(
name|pax
operator|->
name|flags
operator|&
name|WRITE_LIBARCHIVE_XATTR
condition|)
block|{
name|encoded_value
operator|=
name|base64_encode
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|value
argument_list|,
name|value_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoded_name
operator|!=
name|NULL
operator|&&
name|encoded_value
operator|!=
name|NULL
condition|)
block|{
name|archive_string_init
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
name|s
argument_list|,
literal|"LIBARCHIVE.xattr."
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|s
argument_list|,
name|encoded_name
argument_list|)
expr_stmt|;
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
name|s
operator|.
name|s
argument_list|,
name|encoded_value
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|encoded_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pax
operator|->
name|flags
operator|&
name|WRITE_SCHILY_XATTR
condition|)
block|{
name|archive_string_init
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
name|s
argument_list|,
literal|"SCHILY.xattr."
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|s
argument_list|,
name|encoded_name
argument_list|)
expr_stmt|;
name|add_pax_attr_binary
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
name|s
operator|.
name|s
argument_list|,
name|value
argument_list|,
name|value_len
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_pax_header_xattrs
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|pax
modifier|*
name|pax
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|i
init|=
name|archive_entry_xattr_reset
argument_list|(
name|entry
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|void
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|url_encoded_name
init|=
name|NULL
decl_stmt|,
modifier|*
name|encoded_name
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_entry_xattr_next
argument_list|(
name|entry
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|url_encoded_name
operator|=
name|url_encode
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|url_encoded_name
operator|!=
name|NULL
condition|)
block|{
comment|/* Convert narrow-character to UTF-8. */
name|r
operator|=
name|archive_strcpy_l
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|l_url_encoded_name
operator|)
argument_list|,
name|url_encoded_name
argument_list|,
name|pax
operator|->
name|sconv_utf8
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|url_encoded_name
argument_list|)
expr_stmt|;
comment|/* Done with this. */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|encoded_name
operator|=
name|pax
operator|->
name|l_url_encoded_name
operator|.
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Linkname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|archive_write_pax_header_xattr
argument_list|(
name|pax
argument_list|,
name|encoded_name
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_entry_hardlink
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_entry_hardlink_l
argument_list|(
name|entry
argument_list|,
name|name
argument_list|,
name|length
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Linkname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_entry_pathname
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_entry_pathname_l
argument_list|(
name|entry
argument_list|,
name|name
argument_list|,
name|length
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_entry_uname
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_entry_uname_l
argument_list|(
name|entry
argument_list|,
name|name
argument_list|,
name|length
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Uname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_entry_gname
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_entry_gname_l
argument_list|(
name|entry
argument_list|,
name|name
argument_list|,
name|length
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Gname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_entry_symlink
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_entry_symlink_l
argument_list|(
name|entry
argument_list|,
name|name
argument_list|,
name|length
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Linkname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add ACL to pax header */
end_comment

begin_function
specifier|static
name|int
name|add_pax_acl
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|pax
modifier|*
name|pax
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|attr
decl_stmt|;
name|int
name|acl_types
decl_stmt|;
name|acl_types
operator|=
name|archive_entry_acl_types
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acl_types
operator|&
name|ARCHIVE_ENTRY_ACL_TYPE_NFS4
operator|)
operator|!=
literal|0
condition|)
name|attr
operator|=
literal|"SCHILY.acl.ace"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
operator|)
operator|!=
literal|0
condition|)
name|attr
operator|=
literal|"SCHILY.acl.access"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
operator|)
operator|!=
literal|0
condition|)
name|attr
operator|=
literal|"SCHILY.acl.default"
expr_stmt|;
else|else
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|p
operator|=
name|archive_entry_acl_to_text_l
argument_list|(
name|entry
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|pax
operator|->
name|sconv_utf8
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"%s %s"
argument_list|,
literal|"Can't allocate memory for "
argument_list|,
name|attr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"%s %s %s"
argument_list|,
literal|"Can't translate "
argument_list|,
name|attr
argument_list|,
literal|" to UTF-8"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
name|attr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: Consider adding 'comment' and 'charset' fields to  * archive_entry so that clients can specify them.  Also, consider  * adding generic key/value tags so clients can add arbitrary  * key/value data.  *  * TODO: Break up this 700-line function!!!!  Yowza!  */
end_comment

begin_function
specifier|static
name|int
name|archive_write_pax_header
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry_original
parameter_list|)
block|{
name|struct
name|archive_entry
modifier|*
name|entry_main
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|int
name|need_extension
decl_stmt|,
name|r
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|acl_types
decl_stmt|;
name|int
name|sparse_count
decl_stmt|;
name|uint64_t
name|sparse_total
decl_stmt|,
name|real_size
decl_stmt|;
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
specifier|const
name|char
modifier|*
name|hardlink
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|,
modifier|*
name|linkpath
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|uname
init|=
name|NULL
decl_stmt|,
modifier|*
name|gname
init|=
name|NULL
decl_stmt|;
specifier|const
name|void
modifier|*
name|mac_metadata
decl_stmt|;
name|size_t
name|mac_metadata_size
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
name|size_t
name|hardlink_length
decl_stmt|,
name|path_length
decl_stmt|,
name|linkpath_length
decl_stmt|;
name|size_t
name|uname_length
decl_stmt|,
name|gname_length
decl_stmt|;
name|char
name|paxbuff
index|[
literal|512
index|]
decl_stmt|;
name|char
name|ustarbuff
index|[
literal|512
index|]
decl_stmt|;
name|char
name|ustar_entry_name
index|[
literal|256
index|]
decl_stmt|;
name|char
name|pax_entry_name
index|[
literal|256
index|]
decl_stmt|;
name|char
name|gnu_sparse_name
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|archive_string
name|entry_name
decl_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|need_extension
operator|=
literal|0
expr_stmt|;
name|pax
operator|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|archive_entry_pathname
argument_list|(
name|entry_original
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't record entry in tar file without pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* 	 * Choose a header encoding. 	 */
if|if
condition|(
name|pax
operator|->
name|opt_binary
condition|)
name|sconv
operator|=
name|NULL
expr_stmt|;
comment|/* Binary mode. */
else|else
block|{
comment|/* Header encoding is UTF-8. */
if|if
condition|(
name|pax
operator|->
name|sconv_utf8
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the string conversion object 			 * we must need */
name|pax
operator|->
name|sconv_utf8
operator|=
name|archive_string_conversion_to_charset
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|,
literal|"UTF-8"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pax
operator|->
name|sconv_utf8
operator|==
name|NULL
condition|)
comment|/* Couldn't allocate memory */
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|sconv
operator|=
name|pax
operator|->
name|sconv_utf8
expr_stmt|;
block|}
name|r
operator|=
name|get_entry_hardlink
argument_list|(
name|a
argument_list|,
name|entry_original
argument_list|,
operator|&
name|hardlink
argument_list|,
operator|&
name|hardlink_length
argument_list|,
name|sconv
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
elseif|else
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|r
operator|=
name|get_entry_hardlink
argument_list|(
name|a
argument_list|,
name|entry_original
argument_list|,
operator|&
name|hardlink
argument_list|,
operator|&
name|hardlink_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Can't translate linkname '%s' to %s"
argument_list|,
name|hardlink
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|sconv
operator|=
name|NULL
expr_stmt|;
comment|/* The header charset switches to binary mode. */
block|}
comment|/* Make sure this is a type of entry that we can handle here */
if|if
condition|(
name|hardlink
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|archive_entry_filetype
argument_list|(
name|entry_original
argument_list|)
condition|)
block|{
case|case
name|AE_IFBLK
case|:
case|case
name|AE_IFCHR
case|:
case|case
name|AE_IFIFO
case|:
case|case
name|AE_IFLNK
case|:
case|case
name|AE_IFREG
case|:
break|break;
case|case
name|AE_IFDIR
case|:
block|{
comment|/* 			 * Ensure a trailing '/'.  Modify the original 			 * entry so the client sees the change. 			 */
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
name|wp
operator|=
name|archive_entry_pathname_w
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
operator|&&
name|wp
index|[
name|wcslen
argument_list|(
name|wp
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|L'
expr|/'
condition|)
block|{
name|struct
name|archive_wstring
name|ws
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|ws
argument_list|)
expr_stmt|;
name|path_length
operator|=
name|wcslen
argument_list|(
name|wp
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_wstring_ensure
argument_list|(
operator|&
name|ws
argument_list|,
name|path_length
operator|+
literal|2
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate pax data"
argument_list|)
expr_stmt|;
name|archive_wstring_free
argument_list|(
operator|&
name|ws
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Should we keep '\' ? */
if|if
condition|(
name|wp
index|[
name|path_length
operator|-
literal|1
index|]
operator|==
literal|L'
expr|\\'
condition|)
name|path_length
operator|--
expr_stmt|;
name|archive_wstrncpy
argument_list|(
operator|&
name|ws
argument_list|,
name|wp
argument_list|,
name|path_length
argument_list|)
expr_stmt|;
name|archive_wstrappend_wchar
argument_list|(
operator|&
name|ws
argument_list|,
literal|L'
expr|/'
argument_list|)
expr_stmt|;
name|archive_entry_copy_pathname_w
argument_list|(
name|entry_original
argument_list|,
name|ws
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_wstring_free
argument_list|(
operator|&
name|ws
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|p
operator|=
name|archive_entry_pathname
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
comment|/* 			 * On Windows, this is a backup operation just in 			 * case getting WCS failed. On POSIX, this is a 			 * normal operation. 			 */
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|struct
name|archive_string
name|as
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
name|path_length
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
operator|&
name|as
argument_list|,
name|path_length
operator|+
literal|2
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate pax data"
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* NOTE: This might break the pathname 				 * if the current code page is CP932 and 				 * the pathname includes a character '\' 				 * as a part of its multibyte pathname. */
if|if
condition|(
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|path_length
operator|--
expr_stmt|;
else|else
endif|#
directive|endif
name|archive_strncpy
argument_list|(
operator|&
name|as
argument_list|,
name|p
argument_list|,
name|path_length
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
operator|&
name|as
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|archive_entry_copy_pathname
argument_list|(
name|entry_original
argument_list|,
name|as
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|as
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|AE_IFSOCK
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"tar format cannot archive socket"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"tar format cannot archive this (type=0%lo)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|archive_entry_filetype
argument_list|(
name|entry_original
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
block|}
comment|/* 	 * If Mac OS metadata blob is here, recurse to write that 	 * as a separate entry.  This is really a pretty poor design: 	 * In particular, it doubles the overhead for long filenames. 	 * TODO: Help Apple folks design something better and figure 	 * out how to transition from this legacy format. 	 * 	 * Note that this code is present on every platform; clients 	 * on non-Mac are unlikely to ever provide this data, but 	 * applications that copy entries from one archive to another 	 * should not lose data just because the local filesystem 	 * can't store it. 	 */
name|mac_metadata
operator|=
name|archive_entry_mac_metadata
argument_list|(
name|entry_original
argument_list|,
operator|&
name|mac_metadata_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac_metadata
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|oname
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|bname
decl_stmt|;
name|size_t
name|name_length
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|extra
init|=
name|archive_entry_new2
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
decl_stmt|;
name|oname
operator|=
name|archive_entry_pathname
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|oname
argument_list|)
expr_stmt|;
name|name
operator|=
name|malloc
argument_list|(
name|name_length
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|extra
operator|==
name|NULL
condition|)
block|{
comment|/* XXX error message */
name|archive_entry_free
argument_list|(
name|extra
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|name
argument_list|,
name|oname
argument_list|)
expr_stmt|;
comment|/* Find last '/'; strip trailing '/' characters */
name|bname
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
while|while
condition|(
name|bname
operator|!=
name|NULL
operator|&&
name|bname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|bname
operator|=
literal|'\0'
expr_stmt|;
name|bname
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bname
operator|==
name|NULL
condition|)
block|{
name|memmove
argument_list|(
name|name
operator|+
literal|2
argument_list|,
name|name
argument_list|,
name|name_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|name
argument_list|,
literal|"._"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bname
operator|+=
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|bname
operator|+
literal|2
argument_list|,
name|bname
argument_list|,
name|strlen
argument_list|(
name|bname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|bname
argument_list|,
literal|"._"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|archive_entry_copy_pathname
argument_list|(
name|extra
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|extra
argument_list|,
name|mac_metadata_size
argument_list|)
expr_stmt|;
name|archive_entry_set_filetype
argument_list|(
name|extra
argument_list|,
name|AE_IFREG
argument_list|)
expr_stmt|;
name|archive_entry_set_perm
argument_list|(
name|extra
argument_list|,
name|archive_entry_perm
argument_list|(
name|entry_original
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|extra
argument_list|,
name|archive_entry_mtime
argument_list|(
name|entry_original
argument_list|)
argument_list|,
name|archive_entry_mtime_nsec
argument_list|(
name|entry_original
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|extra
argument_list|,
name|archive_entry_gid
argument_list|(
name|entry_original
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_gname
argument_list|(
name|extra
argument_list|,
name|archive_entry_gname
argument_list|(
name|entry_original
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|extra
argument_list|,
name|archive_entry_uid
argument_list|(
name|entry_original
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_uname
argument_list|(
name|extra
argument_list|,
name|archive_entry_uname
argument_list|(
name|entry_original
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Recurse to write the special copyfile entry. */
name|r
operator|=
name|archive_write_pax_header
argument_list|(
name|a
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|r
operator|<
name|ret
condition|)
name|ret
operator|=
name|r
expr_stmt|;
name|r
operator|=
operator|(
name|int
operator|)
name|archive_write_pax_data
argument_list|(
name|a
argument_list|,
name|mac_metadata
argument_list|,
name|mac_metadata_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|r
operator|<
name|ret
condition|)
name|ret
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|archive_write_pax_finish_entry
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|r
operator|<
name|ret
condition|)
name|ret
operator|=
name|r
expr_stmt|;
block|}
comment|/* Copy entry so we can modify it as needed. */
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* Make sure the path separators in pathname, hardlink and symlink 	 * are all slash '/', not the Windows path separator '\'. */
name|entry_main
operator|=
name|__la_win_entry_in_posix_pathseparator
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_main
operator|==
name|entry_original
condition|)
name|entry_main
operator|=
name|archive_entry_clone
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
else|#
directive|else
name|entry_main
operator|=
name|archive_entry_clone
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry_main
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate pax data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
expr_stmt|;
comment|/* Blank our work area. */
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|sparse_map
operator|)
argument_list|)
expr_stmt|;
name|sparse_total
operator|=
literal|0
expr_stmt|;
name|sparse_list_clear
argument_list|(
name|pax
argument_list|)
expr_stmt|;
if|if
condition|(
name|hardlink
operator|==
name|NULL
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry_main
argument_list|)
operator|==
name|AE_IFREG
condition|)
name|sparse_count
operator|=
name|archive_entry_sparse_reset
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
else|else
name|sparse_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sparse_count
condition|)
block|{
name|int64_t
name|offset
decl_stmt|,
name|length
decl_stmt|,
name|last_offset
init|=
literal|0
decl_stmt|;
comment|/* Get the last entry of sparse block. */
while|while
condition|(
name|archive_entry_sparse_next
argument_list|(
name|entry_main
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|length
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
name|last_offset
operator|=
name|offset
operator|+
name|length
expr_stmt|;
comment|/* If the last sparse block does not reach the end of file, 		 * We have to add a empty sparse block as the last entry to 		 * manage storing file data. */
if|if
condition|(
name|last_offset
operator|<
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
condition|)
name|archive_entry_sparse_add_entry
argument_list|(
name|entry_main
argument_list|,
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sparse_count
operator|=
name|archive_entry_sparse_reset
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * First, check the name fields and see if any of them 	 * require binary coding.  If any of them does, then all of 	 * them do. 	 */
name|r
operator|=
name|get_entry_pathname
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|path_length
argument_list|,
name|sconv
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
elseif|else
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|r
operator|=
name|get_entry_pathname
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|path_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Can't translate pathname '%s' to %s"
argument_list|,
name|path
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|sconv
operator|=
name|NULL
expr_stmt|;
comment|/* The header charset switches to binary mode. */
block|}
name|r
operator|=
name|get_entry_uname
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|uname
argument_list|,
operator|&
name|uname_length
argument_list|,
name|sconv
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
elseif|else
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|r
operator|=
name|get_entry_uname
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|uname
argument_list|,
operator|&
name|uname_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Can't translate uname '%s' to %s"
argument_list|,
name|uname
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|sconv
operator|=
name|NULL
expr_stmt|;
comment|/* The header charset switches to binary mode. */
block|}
name|r
operator|=
name|get_entry_gname
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|gname
argument_list|,
operator|&
name|gname_length
argument_list|,
name|sconv
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
elseif|else
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|r
operator|=
name|get_entry_gname
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|gname
argument_list|,
operator|&
name|gname_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Can't translate gname '%s' to %s"
argument_list|,
name|gname
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|sconv
operator|=
name|NULL
expr_stmt|;
comment|/* The header charset switches to binary mode. */
block|}
name|linkpath
operator|=
name|hardlink
expr_stmt|;
name|linkpath_length
operator|=
name|hardlink_length
expr_stmt|;
if|if
condition|(
name|linkpath
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|get_entry_symlink
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|linkpath
argument_list|,
operator|&
name|linkpath_length
argument_list|,
name|sconv
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
elseif|else
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|r
operator|=
name|get_entry_symlink
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|linkpath
argument_list|,
operator|&
name|linkpath_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Can't translate linkname '%s' to %s"
argument_list|,
name|linkpath
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|sconv
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If any string conversions failed, get all attributes 	 * in binary-mode. */
if|if
condition|(
name|sconv
operator|==
name|NULL
operator|&&
operator|!
name|pax
operator|->
name|opt_binary
condition|)
block|{
if|if
condition|(
name|hardlink
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|get_entry_hardlink
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|hardlink
argument_list|,
operator|&
name|hardlink_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|linkpath
operator|=
name|hardlink
expr_stmt|;
name|linkpath_length
operator|=
name|hardlink_length
expr_stmt|;
block|}
name|r
operator|=
name|get_entry_pathname
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|path_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
name|get_entry_uname
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|uname
argument_list|,
operator|&
name|uname_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
name|get_entry_gname
argument_list|(
name|a
argument_list|,
name|entry_main
argument_list|,
operator|&
name|gname
argument_list|,
operator|&
name|gname_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Store the header encoding first, to be nice to readers. */
if|if
condition|(
name|sconv
operator|==
name|NULL
condition|)
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"hdrcharset"
argument_list|,
literal|"BINARY"
argument_list|)
expr_stmt|;
comment|/* 	 * If name is too long, or has non-ASCII characters, add 	 * 'path' to pax extended attrs.  (Note that an unconvertible 	 * name must have non-ASCII characters.) 	 */
if|if
condition|(
name|has_non_ASCII
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|/* We have non-ASCII characters. */
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"path"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry_main
argument_list|,
name|build_ustar_entry_name
argument_list|(
name|ustar_entry_name
argument_list|,
name|path
argument_list|,
name|path_length
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We have an all-ASCII path; we'd like to just store 		 * it in the ustar header if it will fit.  Yes, this 		 * duplicates some of the logic in 		 * archive_write_set_format_ustar.c 		 */
if|if
condition|(
name|path_length
operator|<=
literal|100
condition|)
block|{
comment|/* Fits in the old 100-char tar name field. */
block|}
else|else
block|{
comment|/* Find largest suffix that will fit. */
comment|/* Note: strlen()> 100, so strlen() - 100 - 1>= 0 */
name|suffix
operator|=
name|strchr
argument_list|(
name|path
operator|+
name|path_length
operator|-
literal|100
operator|-
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Don't attempt an empty prefix. */
if|if
condition|(
name|suffix
operator|==
name|path
condition|)
name|suffix
operator|=
name|strchr
argument_list|(
name|suffix
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* We can put it in the ustar header if it's 			 * all ASCII and it's either<= 100 characters 			 * or can be split at a '/' into a prefix<= 			 * 155 chars and a suffix<= 100 chars.  (Note 			 * the strchr() above will return NULL exactly 			 * when the path can't be split.) 			 */
if|if
condition|(
name|suffix
operator|==
name|NULL
comment|/* Suffix> 100 chars. */
operator|||
name|suffix
index|[
literal|1
index|]
operator|==
literal|'\0'
comment|/* empty suffix */
operator|||
name|suffix
operator|-
name|path
operator|>
literal|155
condition|)
comment|/* Prefix> 155 chars */
block|{
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"path"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry_main
argument_list|,
name|build_ustar_entry_name
argument_list|(
name|ustar_entry_name
argument_list|,
name|path
argument_list|,
name|path_length
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|linkpath
operator|!=
name|NULL
condition|)
block|{
comment|/* If link name is too long or has non-ASCII characters, add 		 * 'linkpath' to pax extended attrs. */
if|if
condition|(
name|linkpath_length
operator|>
literal|100
operator|||
name|has_non_ASCII
argument_list|(
name|linkpath
argument_list|)
condition|)
block|{
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"linkpath"
argument_list|,
name|linkpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkpath_length
operator|>
literal|100
condition|)
block|{
if|if
condition|(
name|hardlink
operator|!=
name|NULL
condition|)
name|archive_entry_set_hardlink
argument_list|(
name|entry_main
argument_list|,
literal|"././@LongHardLink"
argument_list|)
expr_stmt|;
else|else
name|archive_entry_set_symlink
argument_list|(
name|entry_main
argument_list|,
literal|"././@LongSymLink"
argument_list|)
expr_stmt|;
block|}
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Save a pathname since it will be renamed if `entry_main` has 	 * sparse blocks. */
name|archive_string_init
argument_list|(
operator|&
name|entry_name
argument_list|)
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
name|entry_name
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If file size is too large, add 'size' to pax extended attrs. */
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
operator|>=
operator|(
operator|(
operator|(
name|int64_t
operator|)
literal|1
operator|)
operator|<<
literal|33
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"size"
argument_list|,
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If numeric GID is too large, add 'gid' to pax extended attrs. */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|archive_entry_gid
argument_list|(
name|entry_main
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"gid"
argument_list|,
name|archive_entry_gid
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If group name is too large or has non-ASCII characters, add 	 * 'gname' to pax extended attrs. */
if|if
condition|(
name|gname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gname_length
operator|>
literal|31
operator|||
name|has_non_ASCII
argument_list|(
name|gname
argument_list|)
condition|)
block|{
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"gname"
argument_list|,
name|gname
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If numeric UID is too large, add 'uid' to pax extended attrs. */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|archive_entry_uid
argument_list|(
name|entry_main
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"uid"
argument_list|,
name|archive_entry_uid
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Add 'uname' to pax extended attrs if necessary. */
if|if
condition|(
name|uname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|uname_length
operator|>
literal|31
operator|||
name|has_non_ASCII
argument_list|(
name|uname
argument_list|)
condition|)
block|{
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"uname"
argument_list|,
name|uname
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * POSIX/SUSv3 doesn't provide a standard key for large device 	 * numbers.  I use the same keys here that Joerg Schilling 	 * used for 'star.'  (Which, somewhat confusingly, are called 	 * "devXXX" even though they code "rdev" values.)  No doubt, 	 * other implementations use other keys.  Note that there's no 	 * reason we can't write the same information into a number of 	 * different keys. 	 * 	 * Of course, this is only needed for block or char device entries. 	 */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry_main
argument_list|)
operator|==
name|AE_IFBLK
operator|||
name|archive_entry_filetype
argument_list|(
name|entry_main
argument_list|)
operator|==
name|AE_IFCHR
condition|)
block|{
comment|/* 		 * If rdevmajor is too large, add 'SCHILY.devmajor' to 		 * extended attributes. 		 */
name|int
name|rdevmajor
decl_stmt|,
name|rdevminor
decl_stmt|;
name|rdevmajor
operator|=
name|archive_entry_rdevmajor
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|rdevminor
operator|=
name|archive_entry_rdevminor
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdevmajor
operator|>=
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.devmajor"
argument_list|,
name|rdevmajor
argument_list|)
expr_stmt|;
comment|/* 			 * Non-strict formatting below means we don't 			 * have to truncate here.  Not truncating improves 			 * the chance that some more modern tar archivers 			 * (such as GNU tar 1.13) can restore the full 			 * value even if they don't understand the pax 			 * extended attributes.  See my rant below about 			 * file size fields for additional details. 			 */
comment|/* archive_entry_set_rdevmajor(entry_main, 			   rdevmajor& ((1<< 18) - 1)); */
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * If devminor is too large, add 'SCHILY.devminor' to 		 * extended attributes. 		 */
if|if
condition|(
name|rdevminor
operator|>=
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.devminor"
argument_list|,
name|rdevminor
argument_list|)
expr_stmt|;
comment|/* Truncation is not necessary here, either. */
comment|/* archive_entry_set_rdevminor(entry_main, 			   rdevminor& ((1<< 18) - 1)); */
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Technically, the mtime field in the ustar header can 	 * support 33 bits, but many platforms use signed 32-bit time 	 * values.  The cutoff of 0x7fffffff here is a compromise. 	 * Yes, this check is duplicated just below; this helps to 	 * avoid writing an mtime attribute just to handle a 	 * high-resolution timestamp in "restricted pax" mode. 	 */
if|if
condition|(
operator|!
name|need_extension
operator|&&
operator|(
operator|(
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
operator|>=
literal|0x7fffffff
operator|)
operator|)
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* I use a star-compatible file flag attribute. */
name|p
operator|=
name|archive_entry_fflags_text
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_extension
operator|&&
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* If there are extended attributes, we need an extension */
if|if
condition|(
operator|!
name|need_extension
operator|&&
name|archive_entry_xattr_count
argument_list|(
name|entry_original
argument_list|)
operator|>
literal|0
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* If there are sparse info, we need an extension */
if|if
condition|(
operator|!
name|need_extension
operator|&&
name|sparse_count
operator|>
literal|0
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
name|acl_types
operator|=
name|archive_entry_acl_types
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
comment|/* If there are any ACL entries, we need an extension */
if|if
condition|(
operator|!
name|need_extension
operator|&&
name|acl_types
operator|!=
literal|0
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Libarchive used to include these in extended headers for 	 * restricted pax format, but that confused people who 	 * expected ustar-like time semantics.  So now we only include 	 * them in full pax format. 	 */
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_TAR_PAX_RESTRICTED
condition|)
block|{
if|if
condition|(
name|archive_entry_ctime
argument_list|(
name|entry_main
argument_list|)
operator|!=
literal|0
operator|||
name|archive_entry_ctime_nsec
argument_list|(
name|entry_main
argument_list|)
operator|!=
literal|0
condition|)
name|add_pax_attr_time
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"ctime"
argument_list|,
name|archive_entry_ctime
argument_list|(
name|entry_main
argument_list|)
argument_list|,
name|archive_entry_ctime_nsec
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_atime
argument_list|(
name|entry_main
argument_list|)
operator|!=
literal|0
operator|||
name|archive_entry_atime_nsec
argument_list|(
name|entry_main
argument_list|)
operator|!=
literal|0
condition|)
name|add_pax_attr_time
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"atime"
argument_list|,
name|archive_entry_atime
argument_list|(
name|entry_main
argument_list|)
argument_list|,
name|archive_entry_atime_nsec
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store birth/creationtime only if it's earlier than mtime */
if|if
condition|(
name|archive_entry_birthtime_is_set
argument_list|(
name|entry_main
argument_list|)
operator|&&
name|archive_entry_birthtime
argument_list|(
name|entry_main
argument_list|)
operator|<
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
condition|)
name|add_pax_attr_time
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"LIBARCHIVE.creationtime"
argument_list|,
name|archive_entry_birthtime
argument_list|(
name|entry_main
argument_list|)
argument_list|,
name|archive_entry_birthtime_nsec
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The following items are handled differently in "pax 	 * restricted" format.  In particular, in "pax restricted" 	 * format they won't be added unless need_extension is 	 * already set (we're already generating an extended header, so 	 * may as well include these). 	 */
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_TAR_PAX_RESTRICTED
operator|||
name|need_extension
condition|)
block|{
if|if
condition|(
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
operator|<
literal|0
operator|||
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
operator|>=
literal|0x7fffffff
operator|||
name|archive_entry_mtime_nsec
argument_list|(
name|entry_main
argument_list|)
operator|!=
literal|0
condition|)
name|add_pax_attr_time
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"mtime"
argument_list|,
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
argument_list|,
name|archive_entry_mtime_nsec
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
comment|/* I use a star-compatible file flag attribute. */
name|p
operator|=
name|archive_entry_fflags_text
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.fflags"
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* I use star-compatible ACL attributes. */
if|if
condition|(
operator|(
name|acl_types
operator|&
name|ARCHIVE_ENTRY_ACL_TYPE_NFS4
operator|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|add_pax_acl
argument_list|(
name|a
argument_list|,
name|entry_original
argument_list|,
name|pax
argument_list|,
name|ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID
operator||
name|ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA
operator||
name|ARCHIVE_ENTRY_ACL_STYLE_COMPACT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|acl_types
operator|&
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
condition|)
block|{
name|ret
operator|=
name|add_pax_acl
argument_list|(
name|a
argument_list|,
name|entry_original
argument_list|,
name|pax
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
operator||
name|ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID
operator||
name|ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|acl_types
operator|&
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
condition|)
block|{
name|ret
operator|=
name|add_pax_acl
argument_list|(
name|a
argument_list|,
name|entry_original
argument_list|,
name|pax
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
operator||
name|ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID
operator||
name|ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* We use GNU-tar-compatible sparse attributes. */
if|if
condition|(
name|sparse_count
operator|>
literal|0
condition|)
block|{
name|int64_t
name|soffset
decl_stmt|,
name|slength
decl_stmt|;
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"GNU.sparse.major"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"GNU.sparse.minor"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Make sure to store the original path, since 			 * truncation to ustar limit happened already. 			 */
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"GNU.sparse.name"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"GNU.sparse.realsize"
argument_list|,
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rename the file name which will be used for 			 * ustar header to a special name, which GNU 			 * PAX Format 1.0 requires */
name|archive_entry_set_pathname
argument_list|(
name|entry_main
argument_list|,
name|build_gnu_sparse_name
argument_list|(
name|gnu_sparse_name
argument_list|,
name|entry_name
operator|.
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * - Make a sparse map, which will precede a file data. 			 * - Get the total size of available data of sparse. 			 */
name|archive_string_sprintf
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|sparse_map
operator|)
argument_list|,
literal|"%d\n"
argument_list|,
name|sparse_count
argument_list|)
expr_stmt|;
while|while
condition|(
name|archive_entry_sparse_next
argument_list|(
name|entry_main
argument_list|,
operator|&
name|soffset
argument_list|,
operator|&
name|slength
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
block|{
name|archive_string_sprintf
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|sparse_map
operator|)
argument_list|,
literal|"%jd\n%jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|soffset
argument_list|,
operator|(
name|intmax_t
operator|)
name|slength
argument_list|)
expr_stmt|;
name|sparse_total
operator|+=
name|slength
expr_stmt|;
if|if
condition|(
name|sparse_list_add
argument_list|(
name|pax
argument_list|,
name|soffset
argument_list|,
name|slength
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory"
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|entry_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
block|}
comment|/* Store extended attributes */
if|if
condition|(
name|archive_write_pax_header_xattrs
argument_list|(
name|a
argument_list|,
name|pax
argument_list|,
name|entry_original
argument_list|)
operator|==
name|ARCHIVE_FATAL
condition|)
block|{
name|archive_entry_free
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|entry_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
comment|/* Only regular files have data. */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry_main
argument_list|)
operator|!=
name|AE_IFREG
condition|)
name|archive_entry_set_size
argument_list|(
name|entry_main
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Pax-restricted does not store data for hardlinks, in order 	 * to improve compatibility with ustar. 	 */
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
operator|&&
name|hardlink
operator|!=
name|NULL
condition|)
name|archive_entry_set_size
argument_list|(
name|entry_main
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Full pax interchange format does permit a hardlink 	 * entry to have data associated with it.  I'm not supporting 	 * that here because the client expects me to tell them whether 	 * or not this format expects data for hardlinks.  If I 	 * don't check here, then every pax archive will end up with 	 * duplicated data for hardlinks.  Someday, there may be 	 * need to select this behavior, in which case the following 	 * will need to be revisited. XXX 	 */
if|if
condition|(
name|hardlink
operator|!=
name|NULL
condition|)
name|archive_entry_set_size
argument_list|(
name|entry_main
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Save a real file size. */
name|real_size
operator|=
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
comment|/* 	 * Overwrite a file size by the total size of sparse blocks and 	 * the size of sparse map info. That file size is the length of 	 * the data, which we will exactly store into an archive file. 	 */
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|sparse_map
operator|)
argument_list|)
condition|)
block|{
name|size_t
name|mapsize
init|=
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|sparse_map
operator|)
argument_list|)
decl_stmt|;
name|pax
operator|->
name|sparse_map_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
operator|(
name|ssize_t
operator|)
name|mapsize
operator|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry_main
argument_list|,
name|mapsize
operator|+
name|pax
operator|->
name|sparse_map_padding
operator|+
name|sparse_total
argument_list|)
expr_stmt|;
block|}
comment|/* Format 'ustar' header for main entry. 	 * 	 * The trouble with file size: If the reader can't understand 	 * the file size, they may not be able to locate the next 	 * entry and the rest of the archive is toast.  Pax-compliant 	 * readers are supposed to ignore the file size in the main 	 * header, so the question becomes how to maximize portability 	 * for readers that don't support pax attribute extensions. 	 * For maximum compatibility, I permit numeric extensions in 	 * the main header so that the file size stored will always be 	 * correct, even if it's in a format that only some 	 * implementations understand.  The technique used here is: 	 * 	 *  a) If possible, follow the standard exactly.  This handles 	 *  files up to 8 gigabytes minus 1. 	 * 	 *  b) If that fails, try octal but omit the field terminator. 	 *  That handles files up to 64 gigabytes minus 1. 	 * 	 *  c) Otherwise, use base-256 extensions.  That handles files 	 *  up to 2^63 in this implementation, with the potential to 	 *  go up to 2^94.  That should hold us for a while. ;-) 	 * 	 * The non-strict formatter uses similar logic for other 	 * numeric fields, though they're less critical. 	 */
if|if
condition|(
name|__archive_write_format_header_ustar
argument_list|(
name|a
argument_list|,
name|ustarbuff
argument_list|,
name|entry_main
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
name|ARCHIVE_FATAL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* If we built any extended attributes, write that entry first. */
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|struct
name|archive_entry
modifier|*
name|pax_attr_entry
decl_stmt|;
name|time_t
name|s
decl_stmt|;
name|int64_t
name|uid
decl_stmt|,
name|gid
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|pax_attr_entry
operator|=
name|archive_entry_new2
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
name|p
operator|=
name|entry_name
operator|.
name|s
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|pax_attr_entry
argument_list|,
name|build_pax_attribute_name
argument_list|(
name|pax_entry_name
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|pax_attr_entry
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy uid/gid (but clip to ustar limits). */
name|uid
operator|=
name|archive_entry_uid
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|>=
literal|1
operator|<<
literal|18
condition|)
name|uid
operator|=
operator|(
literal|1
operator|<<
literal|18
operator|)
operator|-
literal|1
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|pax_attr_entry
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|gid
operator|=
name|archive_entry_gid
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|gid
operator|>=
literal|1
operator|<<
literal|18
condition|)
name|gid
operator|=
operator|(
literal|1
operator|<<
literal|18
operator|)
operator|-
literal|1
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|pax_attr_entry
argument_list|,
name|gid
argument_list|)
expr_stmt|;
comment|/* Copy mode over (but not setuid/setgid bits) */
name|mode
operator|=
name|archive_entry_mode
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|S_ISUID
name|mode
operator|&=
operator|~
name|S_ISUID
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISGID
name|mode
operator|&=
operator|~
name|S_ISGID
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISVTX
name|mode
operator|&=
operator|~
name|S_ISVTX
expr_stmt|;
endif|#
directive|endif
name|archive_entry_set_mode
argument_list|(
name|pax_attr_entry
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Copy uname/gname. */
name|archive_entry_set_uname
argument_list|(
name|pax_attr_entry
argument_list|,
name|archive_entry_uname
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_gname
argument_list|(
name|pax_attr_entry
argument_list|,
name|archive_entry_gname
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy mtime, but clip to ustar limits. */
name|s
operator|=
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|s
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|>=
literal|0x7fffffff
condition|)
block|{
name|s
operator|=
literal|0x7fffffff
expr_stmt|;
block|}
name|archive_entry_set_mtime
argument_list|(
name|pax_attr_entry
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Standard ustar doesn't support atime. */
name|archive_entry_set_atime
argument_list|(
name|pax_attr_entry
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Standard ustar doesn't support ctime. */
name|archive_entry_set_ctime
argument_list|(
name|pax_attr_entry
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|__archive_write_format_header_ustar
argument_list|(
name|a
argument_list|,
name|paxbuff
argument_list|,
name|pax_attr_entry
argument_list|,
literal|'x'
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|pax_attr_entry
argument_list|)
expr_stmt|;
comment|/* Note that the 'x' header shouldn't ever fail to format */
if|if
condition|(
name|r
operator|<
name|ARCHIVE_WARN
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"archive_write_pax_header: "
literal|"'x' header failed?!  This can't happen.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|<
name|ret
condition|)
name|ret
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|paxbuff
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|sparse_list_clear
argument_list|(
name|pax
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|pax
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|pax
operator|->
name|entry_bytes_remaining
operator|=
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
operator|(
name|int64_t
operator|)
name|pax
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
name|r
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|pax
operator|->
name|pax_header
operator|.
name|s
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
comment|/* If a write fails, we're pretty much toast. */
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Pad out the end of the entry. */
name|r
operator|=
name|__archive_write_nulls
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|pax
operator|->
name|entry_padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
comment|/* If a write fails, we're pretty much toast. */
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|pax
operator|->
name|entry_bytes_remaining
operator|=
name|pax
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Write the header for main entry. */
name|r
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|ustarbuff
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* 	 * Inform the client of the on-disk size we're using, so 	 * they can avoid unnecessarily writing a body for something 	 * that we're just going to ignore. 	 */
name|archive_entry_set_size
argument_list|(
name|entry_original
argument_list|,
name|real_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pax
operator|->
name|sparse_list
operator|==
name|NULL
operator|&&
name|real_size
operator|>
literal|0
condition|)
block|{
comment|/* This is not a sparse file but we handle its data as 		 * a sparse block. */
name|sparse_list_add
argument_list|(
name|pax
argument_list|,
literal|0
argument_list|,
name|real_size
argument_list|)
expr_stmt|;
name|sparse_total
operator|=
name|real_size
expr_stmt|;
block|}
name|pax
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
operator|(
name|int64_t
operator|)
name|sparse_total
operator|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|entry_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need a valid name for the regular 'ustar' entry.  This routine  * tries to hack something more-or-less reasonable.  *  * The approach here tries to preserve leading dir names.  We do so by  * working with four sections:  *   1) "prefix" directory names,  *   2) "suffix" directory names,  *   3) inserted dir name (optional),  *   4) filename.  *  * These sections must satisfy the following requirements:  *   * Parts 1& 2 together form an initial portion of the dir name.  *   * Part 3 is specified by the caller.  (It should not contain a leading  *     or trailing '/'.)  *   * Part 4 forms an initial portion of the base filename.  *   * The filename must be<= 99 chars to fit the ustar 'name' field.  *   * Parts 2, 3, 4 together must be<= 99 chars to fit the ustar 'name' fld.  *   * Part 1 must be<= 155 chars to fit the ustar 'prefix' field.  *   * If the original name ends in a '/', the new name must also end in a '/'  *   * Trailing '/.' sequences may be stripped.  *  * Note: Recall that the ustar format does not store the '/' separating  * parts 1& 2, but does store the '/' separating parts 2& 3.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_ustar_entry_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|src_length
parameter_list|,
specifier|const
name|char
modifier|*
name|insert
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|prefix_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|suffix_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|filename_end
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|need_slash
init|=
literal|0
decl_stmt|;
comment|/* Was there a trailing slash? */
name|size_t
name|suffix_length
init|=
literal|99
decl_stmt|;
name|size_t
name|insert_length
decl_stmt|;
comment|/* Length of additional dir element to be added. */
if|if
condition|(
name|insert
operator|==
name|NULL
condition|)
name|insert_length
operator|=
literal|0
expr_stmt|;
else|else
comment|/* +2 here allows for '/' before and after the insert. */
name|insert_length
operator|=
name|strlen
argument_list|(
name|insert
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* Step 0: Quick bailout in a common case. */
if|if
condition|(
name|src_length
operator|<
literal|100
operator|&&
name|insert
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|src_length
argument_list|)
expr_stmt|;
name|dest
index|[
name|src_length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
comment|/* Step 1: Locate filename and enforce the length restriction. */
name|filename_end
operator|=
name|src
operator|+
name|src_length
expr_stmt|;
comment|/* Remove trailing '/' chars and '/.' pairs. */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|filename_end
operator|>
name|src
operator|&&
name|filename_end
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|filename_end
operator|--
expr_stmt|;
name|need_slash
operator|=
literal|1
expr_stmt|;
comment|/* Remember to restore trailing '/'. */
continue|continue;
block|}
if|if
condition|(
name|filename_end
operator|>
name|src
operator|+
literal|1
operator|&&
name|filename_end
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|filename_end
index|[
operator|-
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
name|filename_end
operator|-=
literal|2
expr_stmt|;
name|need_slash
operator|=
literal|1
expr_stmt|;
comment|/* "foo/." will become "foo/" */
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|need_slash
condition|)
name|suffix_length
operator|--
expr_stmt|;
comment|/* Find start of filename. */
name|filename
operator|=
name|filename_end
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|filename
operator|>
name|src
operator|)
operator|&&
operator|(
operator|*
name|filename
operator|!=
literal|'/'
operator|)
condition|)
name|filename
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|filename
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|filename
operator|<
name|filename_end
operator|-
literal|1
operator|)
condition|)
name|filename
operator|++
expr_stmt|;
comment|/* Adjust filename_end so that filename + insert fits in 99 chars. */
name|suffix_length
operator|-=
name|insert_length
expr_stmt|;
if|if
condition|(
name|filename_end
operator|>
name|filename
operator|+
name|suffix_length
condition|)
name|filename_end
operator|=
name|filename
operator|+
name|suffix_length
expr_stmt|;
comment|/* Calculate max size for "suffix" section (#3 above). */
name|suffix_length
operator|-=
name|filename_end
operator|-
name|filename
expr_stmt|;
comment|/* Step 2: Locate the "prefix" section of the dirname, including 	 * trailing '/'. */
name|prefix
operator|=
name|src
expr_stmt|;
name|prefix_end
operator|=
name|prefix
operator|+
literal|155
expr_stmt|;
if|if
condition|(
name|prefix_end
operator|>
name|filename
condition|)
name|prefix_end
operator|=
name|filename
expr_stmt|;
while|while
condition|(
name|prefix_end
operator|>
name|prefix
operator|&&
operator|*
name|prefix_end
operator|!=
literal|'/'
condition|)
name|prefix_end
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|prefix_end
operator|<
name|filename
operator|)
operator|&&
operator|(
operator|*
name|prefix_end
operator|==
literal|'/'
operator|)
condition|)
name|prefix_end
operator|++
expr_stmt|;
comment|/* Step 3: Locate the "suffix" section of the dirname, 	 * including trailing '/'. */
name|suffix
operator|=
name|prefix_end
expr_stmt|;
name|suffix_end
operator|=
name|suffix
operator|+
name|suffix_length
expr_stmt|;
comment|/* Enforce limit. */
if|if
condition|(
name|suffix_end
operator|>
name|filename
condition|)
name|suffix_end
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|suffix_end
operator|<
name|suffix
condition|)
name|suffix_end
operator|=
name|suffix
expr_stmt|;
while|while
condition|(
name|suffix_end
operator|>
name|suffix
operator|&&
operator|*
name|suffix_end
operator|!=
literal|'/'
condition|)
name|suffix_end
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|suffix_end
operator|<
name|filename
operator|)
operator|&&
operator|(
operator|*
name|suffix_end
operator|==
literal|'/'
operator|)
condition|)
name|suffix_end
operator|++
expr_stmt|;
comment|/* Step 4: Build the new name. */
comment|/* The OpenBSD strlcpy function is safer, but less portable. */
comment|/* Rather than maintain two versions, just use the strncpy version. */
name|p
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|prefix_end
operator|>
name|prefix
condition|)
block|{
name|strncpy
argument_list|(
name|p
argument_list|,
name|prefix
argument_list|,
name|prefix_end
operator|-
name|prefix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|prefix_end
operator|-
name|prefix
expr_stmt|;
block|}
if|if
condition|(
name|suffix_end
operator|>
name|suffix
condition|)
block|{
name|strncpy
argument_list|(
name|p
argument_list|,
name|suffix
argument_list|,
name|suffix_end
operator|-
name|suffix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|suffix_end
operator|-
name|suffix
expr_stmt|;
block|}
if|if
condition|(
name|insert
operator|!=
name|NULL
condition|)
block|{
comment|/* Note: assume insert does not have leading or trailing '/' */
name|strcpy
argument_list|(
name|p
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|insert
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|p
argument_list|,
name|filename
argument_list|,
name|filename_end
operator|-
name|filename
argument_list|)
expr_stmt|;
name|p
operator|+=
name|filename_end
operator|-
name|filename
expr_stmt|;
if|if
condition|(
name|need_slash
condition|)
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ustar header for the pax extended attributes must have a  * reasonable name:  SUSv3 requires 'dirname'/PaxHeader.'pid'/'filename'  * where 'pid' is the PID of the archiving process.  Unfortunately,  * that makes testing a pain since the output varies for each run,  * so I'm sticking with the simpler 'dirname'/PaxHeader/'filename'  * for now.  (Someday, I'll make this settable.  Then I can use the  * SUS recommendation as default and test harnesses can override it  * to get predictable results.)  *  * Joerg Schilling has argued that this is unnecessary because, in  * practice, if the pax extended attributes get extracted as regular  * files, no one is going to bother reading those attributes to  * manually restore them.  Based on this, 'star' uses  * /tmp/PaxHeader/'basename' as the ustar header name.  This is a  * tempting argument, in part because it's simpler than the SUSv3  * recommendation, but I'm not entirely convinced.  I'm also  * uncomfortable with the fact that "/tmp" is a Unix-ism.  *  * The following routine leverages build_ustar_entry_name() above and  * so is simpler than you might think.  It just needs to provide the  * additional path element and handle a few pathological cases).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_pax_attribute_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Handle the null filename case. */
if|if
condition|(
name|src
operator|==
name|NULL
operator|||
operator|*
name|src
operator|==
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|dest
argument_list|,
literal|"PaxHeader/blank"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
comment|/* Prune final '/' and other unwanted final elements. */
name|p
operator|=
name|src
operator|+
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Ends in "/", remove the '/' */
if|if
condition|(
name|p
operator|>
name|src
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
operator|--
name|p
expr_stmt|;
continue|continue;
block|}
comment|/* Ends in "/.", remove the '.' */
if|if
condition|(
name|p
operator|>
name|src
operator|+
literal|1
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
operator|--
name|p
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* Pathological case: After above, there was nothing left. 	 * This includes "/." "/./." "/.//./." etc. */
if|if
condition|(
name|p
operator|==
name|src
condition|)
block|{
name|strcpy
argument_list|(
name|dest
argument_list|,
literal|"/PaxHeader/rootdir"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
comment|/* Convert unadorned "." into a suitable filename. */
if|if
condition|(
operator|*
name|src
operator|==
literal|'.'
operator|&&
name|p
operator|==
name|src
operator|+
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|dest
argument_list|,
literal|"PaxHeader/currentdir"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
comment|/* 	 * TODO: Push this string into the 'pax' structure to avoid 	 * recomputing it every time.  That will also open the door 	 * to having clients override it. 	 */
if|#
directive|if
name|HAVE_GETPID
operator|&&
literal|0
comment|/* Disable this for now; see above comment. */
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"PaxHeader.%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* If the platform can't fetch the pid, don't include it. */
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"PaxHeader"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* General case: build a ustar-compatible name adding 	 * "/PaxHeader/". */
name|build_ustar_entry_name
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|p
operator|-
name|src
argument_list|,
name|buff
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * GNU PAX Format 1.0 requires the special name, which pattern is:  *<dir>/GNUSparseFile.<pid>/<original file name>  *  * Since reproducable archives are more important, use 0 as pid.  *  * This function is used for only Sparse file, a file type of which  * is regular file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_gnu_sparse_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Handle the null filename case. */
if|if
condition|(
name|src
operator|==
name|NULL
operator|||
operator|*
name|src
operator|==
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|dest
argument_list|,
literal|"GNUSparseFile/blank"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
comment|/* Prune final '/' and other unwanted final elements. */
name|p
operator|=
name|src
operator|+
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Ends in "/", remove the '/' */
if|if
condition|(
name|p
operator|>
name|src
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
operator|--
name|p
expr_stmt|;
continue|continue;
block|}
comment|/* Ends in "/.", remove the '.' */
if|if
condition|(
name|p
operator|>
name|src
operator|+
literal|1
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
operator|--
name|p
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* General case: build a ustar-compatible name adding 	 * "/GNUSparseFile/". */
name|build_ustar_entry_name
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|p
operator|-
name|src
argument_list|,
literal|"GNUSparseFile.0"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write two null blocks for the end of archive */
end_comment

begin_function
specifier|static
name|int
name|archive_write_pax_close
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
return|return
operator|(
name|__archive_write_nulls
argument_list|(
name|a
argument_list|,
literal|512
operator|*
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_pax_free
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
name|pax
operator|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
if|if
condition|(
name|pax
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|archive_string_free
argument_list|(
operator|&
name|pax
operator|->
name|pax_header
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|pax
operator|->
name|sparse_map
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|pax
operator|->
name|l_url_encoded_name
argument_list|)
expr_stmt|;
name|sparse_list_clear
argument_list|(
name|pax
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pax
argument_list|)
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_pax_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
name|uint64_t
name|remaining
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|pax
operator|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|remaining
operator|=
name|pax
operator|->
name|entry_bytes_remaining
expr_stmt|;
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|pax
operator|->
name|sparse_list
condition|)
block|{
name|struct
name|sparse_block
modifier|*
name|sb
decl_stmt|;
if|if
condition|(
operator|!
name|pax
operator|->
name|sparse_list
operator|->
name|is_hole
condition|)
name|remaining
operator|+=
name|pax
operator|->
name|sparse_list
operator|->
name|remaining
expr_stmt|;
name|sb
operator|=
name|pax
operator|->
name|sparse_list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|pax
operator|->
name|sparse_list
argument_list|)
expr_stmt|;
name|pax
operator|->
name|sparse_list
operator|=
name|sb
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|__archive_write_nulls
argument_list|(
name|a
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|remaining
operator|+
name|pax
operator|->
name|entry_padding
argument_list|)
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_bytes_remaining
operator|=
name|pax
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|archive_write_pax_data
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
name|size_t
name|ws
decl_stmt|;
name|size_t
name|total
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|pax
operator|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
comment|/* 	 * According to GNU PAX format 1.0, write a sparse map 	 * before the body. 	 */
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|sparse_map
operator|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|pax
operator|->
name|sparse_map
operator|.
name|s
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|sparse_map
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ret
operator|=
name|__archive_write_nulls
argument_list|(
name|a
argument_list|,
name|pax
operator|->
name|sparse_map_padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|sparse_map
operator|)
argument_list|)
expr_stmt|;
block|}
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|total
operator|<
name|s
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|pax
operator|->
name|sparse_list
operator|!=
name|NULL
operator|&&
name|pax
operator|->
name|sparse_list
operator|->
name|remaining
operator|==
literal|0
condition|)
block|{
name|struct
name|sparse_block
modifier|*
name|sb
init|=
name|pax
operator|->
name|sparse_list
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|pax
operator|->
name|sparse_list
argument_list|)
expr_stmt|;
name|pax
operator|->
name|sparse_list
operator|=
name|sb
expr_stmt|;
block|}
if|if
condition|(
name|pax
operator|->
name|sparse_list
operator|==
name|NULL
condition|)
return|return
operator|(
name|total
operator|)
return|;
name|p
operator|=
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buff
operator|)
operator|+
name|total
expr_stmt|;
name|ws
operator|=
name|s
operator|-
name|total
expr_stmt|;
if|if
condition|(
name|ws
operator|>
name|pax
operator|->
name|sparse_list
operator|->
name|remaining
condition|)
name|ws
operator|=
operator|(
name|size_t
operator|)
name|pax
operator|->
name|sparse_list
operator|->
name|remaining
expr_stmt|;
if|if
condition|(
name|pax
operator|->
name|sparse_list
operator|->
name|is_hole
condition|)
block|{
comment|/* Current block is hole thus we do not write 			 * the body. */
name|pax
operator|->
name|sparse_list
operator|->
name|remaining
operator|-=
name|ws
expr_stmt|;
name|total
operator|+=
name|ws
expr_stmt|;
continue|continue;
block|}
name|ret
operator|=
name|__archive_write_output
argument_list|(
name|a
argument_list|,
name|p
argument_list|,
name|ws
argument_list|)
expr_stmt|;
name|pax
operator|->
name|sparse_list
operator|->
name|remaining
operator|-=
name|ws
expr_stmt|;
name|total
operator|+=
name|ws
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
name|total
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|has_non_ASCII
parameter_list|(
specifier|const
name|char
modifier|*
name|_p
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_p
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|<
literal|128
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used by extended attribute support; encodes the name  * so that there will be no '=' characters in the result.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|url_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|out_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
for|for
control|(
name|s
operator|=
name|in
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|<
literal|33
operator|||
operator|*
name|s
operator|>
literal|126
operator|||
operator|*
name|s
operator|==
literal|'%'
operator|||
operator|*
name|s
operator|==
literal|'='
condition|)
name|out_len
operator|+=
literal|3
expr_stmt|;
else|else
name|out_len
operator|++
expr_stmt|;
block|}
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|out_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|s
operator|=
name|in
operator|,
name|d
operator|=
name|out
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
comment|/* encode any non-printable ASCII character or '%' or '=' */
if|if
condition|(
operator|*
name|s
operator|<
literal|33
operator|||
operator|*
name|s
operator|>
literal|126
operator|||
operator|*
name|s
operator|==
literal|'%'
operator|||
operator|*
name|s
operator|==
literal|'='
condition|)
block|{
comment|/* URL encoding is '%' followed by two hex digits */
operator|*
name|d
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|"0123456789ABCDEF"
index|[
literal|0x0f
operator|&
operator|(
operator|*
name|s
operator|>>
literal|4
operator|)
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|"0123456789ABCDEF"
index|[
literal|0x0f
operator|&
operator|*
name|s
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a sequence of bytes into a C string using base-64 encoding.  *  * Returns a null-terminated C string allocated with malloc(); caller  * is responsible for freeing the result.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|base64_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|digits
index|[
literal|64
index|]
init|=
block|{
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|,
literal|'Z'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|,
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'+'
block|,
literal|'/'
block|}
decl_stmt|;
name|int
name|v
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|out
decl_stmt|;
comment|/* 3 bytes becomes 4 chars, but round up and allow for trailing NUL */
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|len
operator|*
literal|4
operator|+
literal|2
operator|)
operator|/
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|d
operator|=
name|out
expr_stmt|;
comment|/* Convert each group of 3 bytes into 4 characters. */
while|while
condition|(
name|len
operator|>=
literal|3
condition|)
block|{
name|v
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|2
index|]
operator|)
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
block|}
comment|/* Handle final group of 1 byte (2 chars) or 2 bytes (3 chars). */
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|v
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|v
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
break|break;
block|}
comment|/* Add trailing NUL character so output is a valid C string. */
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sparse_list_clear
parameter_list|(
name|struct
name|pax
modifier|*
name|pax
parameter_list|)
block|{
while|while
condition|(
name|pax
operator|->
name|sparse_list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sparse_block
modifier|*
name|sb
init|=
name|pax
operator|->
name|sparse_list
decl_stmt|;
name|pax
operator|->
name|sparse_list
operator|=
name|sb
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
name|pax
operator|->
name|sparse_tail
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|_sparse_list_add_block
parameter_list|(
name|struct
name|pax
modifier|*
name|pax
parameter_list|,
name|int64_t
name|offset
parameter_list|,
name|int64_t
name|length
parameter_list|,
name|int
name|is_hole
parameter_list|)
block|{
name|struct
name|sparse_block
modifier|*
name|sb
decl_stmt|;
name|sb
operator|=
operator|(
expr|struct
name|sparse_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|sb
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|sb
operator|->
name|is_hole
operator|=
name|is_hole
expr_stmt|;
name|sb
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|sb
operator|->
name|remaining
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|pax
operator|->
name|sparse_list
operator|==
name|NULL
operator|||
name|pax
operator|->
name|sparse_tail
operator|==
name|NULL
condition|)
name|pax
operator|->
name|sparse_list
operator|=
name|pax
operator|->
name|sparse_tail
operator|=
name|sb
expr_stmt|;
else|else
block|{
name|pax
operator|->
name|sparse_tail
operator|->
name|next
operator|=
name|sb
expr_stmt|;
name|pax
operator|->
name|sparse_tail
operator|=
name|sb
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sparse_list_add
parameter_list|(
name|struct
name|pax
modifier|*
name|pax
parameter_list|,
name|int64_t
name|offset
parameter_list|,
name|int64_t
name|length
parameter_list|)
block|{
name|int64_t
name|last_offset
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|pax
operator|->
name|sparse_tail
operator|==
name|NULL
condition|)
name|last_offset
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|last_offset
operator|=
name|pax
operator|->
name|sparse_tail
operator|->
name|offset
operator|+
name|pax
operator|->
name|sparse_tail
operator|->
name|remaining
expr_stmt|;
block|}
if|if
condition|(
name|last_offset
operator|<
name|offset
condition|)
block|{
comment|/* Add a hole block. */
name|r
operator|=
name|_sparse_list_add_block
argument_list|(
name|pax
argument_list|,
name|last_offset
argument_list|,
name|offset
operator|-
name|last_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Add data block. */
return|return
operator|(
name|_sparse_list_add_block
argument_list|(
name|pax
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

