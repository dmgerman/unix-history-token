begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2013 Tim Kientzle  * Copyright (c) 2011-2012,2014 Michihiro NAKAJIMA  * Copyright (c) 2013 Konrad Kleine  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD: head/lib/libarchive/archive_read_support_format_zip.c 201102 2009-12-28 03:11:36Z kientzle $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The definitive documentation of the Zip file format is:  *   http://www.pkware.com/documents/casestudies/APPNOTE.TXT  *  * The Info-Zip project has pioneered various extensions to better  * support Zip on Unix, including the 0x5455 "UT", 0x5855 "UX", 0x7855  * "Ux", and 0x7875 "ux" extensions for time and ownership  * information.  *  * History of this code: The streaming Zip reader was first added to  * libarchive in January 2005.  Support for seekable input sources was  * added in Nov 2011.  Zip64 support (including a significant code  * refactoring) was added in 2014.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_digest_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_cryptor_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry_locale.h"
end_include

begin_include
include|#
directive|include
file|"archive_hmac_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_rb.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_ZLIB_H
end_ifndef

begin_include
include|#
directive|include
file|"archive_crc32.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|zip_entry
block|{
name|struct
name|archive_rb_node
name|node
decl_stmt|;
name|struct
name|zip_entry
modifier|*
name|next
decl_stmt|;
name|int64_t
name|local_header_offset
decl_stmt|;
name|int64_t
name|compressed_size
decl_stmt|;
name|int64_t
name|uncompressed_size
decl_stmt|;
name|int64_t
name|gid
decl_stmt|;
name|int64_t
name|uid
decl_stmt|;
name|struct
name|archive_string
name|rsrcname
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|time_t
name|atime
decl_stmt|;
name|time_t
name|ctime
decl_stmt|;
name|uint32_t
name|crc32
decl_stmt|;
name|uint16_t
name|mode
decl_stmt|;
name|uint16_t
name|zip_flags
decl_stmt|;
comment|/* From GP Flags Field */
name|unsigned
name|char
name|compression
decl_stmt|;
name|unsigned
name|char
name|system
decl_stmt|;
comment|/* From "version written by" */
name|unsigned
name|char
name|flags
decl_stmt|;
comment|/* Our extra markers. */
name|unsigned
name|char
name|decdat
decl_stmt|;
comment|/* Used for Decryption check */
comment|/* WinZip AES encryption extra field should be available 	 * when compression is 99. */
struct|struct
block|{
comment|/* Vendor version: AE-1 - 0x0001, AE-2 - 0x0002 */
name|unsigned
name|vendor
decl_stmt|;
define|#
directive|define
name|AES_VENDOR_AE_1
value|0x0001
define|#
directive|define
name|AES_VENDOR_AE_2
value|0x0002
comment|/* AES encryption strength: 		 * 1 - 128 bits, 2 - 192 bits, 2 - 256 bits. */
name|unsigned
name|strength
decl_stmt|;
comment|/* Actual compression method. */
name|unsigned
name|char
name|compression
decl_stmt|;
block|}
name|aes_extra
struct|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|trad_enc_ctx
block|{
name|uint32_t
name|keys
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Bits used in zip_flags. */
end_comment

begin_define
define|#
directive|define
name|ZIP_ENCRYPTED
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|ZIP_LENGTH_AT_END
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|ZIP_STRONG_ENCRYPTED
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|ZIP_UTF8_NAME
value|(1<< 11)
end_define

begin_comment
comment|/* See "7.2 Single Password Symmetric Encryption Method"    in http://www.pkware.com/documents/casestudies/APPNOTE.TXT */
end_comment

begin_define
define|#
directive|define
name|ZIP_CENTRAL_DIRECTORY_ENCRYPTED
value|(1<< 13)
end_define

begin_comment
comment|/* Bits used in flags. */
end_comment

begin_define
define|#
directive|define
name|LA_USED_ZIP64
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|LA_FROM_CENTRAL_DIRECTORY
value|(1<< 1)
end_define

begin_comment
comment|/*  * See "WinZip - AES Encryption Information"  *     http://www.winzip.com/aes_info.htm  */
end_comment

begin_comment
comment|/* Value used in compression method. */
end_comment

begin_define
define|#
directive|define
name|WINZIP_AES_ENCRYPTION
value|99
end_define

begin_comment
comment|/* Authentication code size. */
end_comment

begin_define
define|#
directive|define
name|AUTH_CODE_SIZE
value|10
end_define

begin_comment
comment|/**/
end_comment

begin_define
define|#
directive|define
name|MAX_DERIVED_KEY_BUF_SIZE
value|(AES_MAX_KEY_SIZE * 2 + 2)
end_define

begin_struct
struct|struct
name|zip
block|{
comment|/* Structural information about the archive. */
name|struct
name|archive_string
name|format_name
decl_stmt|;
name|int64_t
name|central_directory_offset
decl_stmt|;
name|size_t
name|central_directory_entries_total
decl_stmt|;
name|size_t
name|central_directory_entries_on_this_disk
decl_stmt|;
name|int
name|has_encrypted_entries
decl_stmt|;
comment|/* List of entries (seekable Zip only) */
name|struct
name|zip_entry
modifier|*
name|zip_entries
decl_stmt|;
name|struct
name|archive_rb_tree
name|tree
decl_stmt|;
name|struct
name|archive_rb_tree
name|tree_rsrc
decl_stmt|;
comment|/* Bytes read but not yet consumed via __archive_read_consume() */
name|size_t
name|unconsumed
decl_stmt|;
comment|/* Information about entry we're currently reading. */
name|struct
name|zip_entry
modifier|*
name|entry
decl_stmt|;
name|int64_t
name|entry_bytes_remaining
decl_stmt|;
comment|/* These count the number of bytes actually read for the entry. */
name|int64_t
name|entry_compressed_bytes_read
decl_stmt|;
name|int64_t
name|entry_uncompressed_bytes_read
decl_stmt|;
comment|/* Running CRC32 of the decompressed data */
name|unsigned
name|long
name|entry_crc32
decl_stmt|;
name|unsigned
name|long
function_decl|(
modifier|*
name|crc32func
function_decl|)
parameter_list|(
name|unsigned
name|long
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|char
name|ignore_crc32
decl_stmt|;
comment|/* Flags to mark progress of decompression. */
name|char
name|decompress_init
decl_stmt|;
name|char
name|end_of_entry
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
name|unsigned
name|char
modifier|*
name|uncompressed_buffer
decl_stmt|;
name|size_t
name|uncompressed_buffer_size
decl_stmt|;
name|z_stream
name|stream
decl_stmt|;
name|char
name|stream_valid
decl_stmt|;
endif|#
directive|endif
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_default
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv_utf8
decl_stmt|;
name|int
name|init_default_conversion
decl_stmt|;
name|int
name|process_mac_extensions
decl_stmt|;
name|char
name|init_decryption
decl_stmt|;
comment|/* Decryption buffer. */
comment|/* 	 * The decrypted data starts at decrypted_ptr and 	 * extends for decrypted_bytes_remaining.  Decryption 	 * adds new data to the end of this block, data is returned 	 * to clients from the beginning.  When the block hits the 	 * end of decrypted_buffer, it has to be shuffled back to 	 * the beginning of the buffer. 	 */
name|unsigned
name|char
modifier|*
name|decrypted_buffer
decl_stmt|;
name|unsigned
name|char
modifier|*
name|decrypted_ptr
decl_stmt|;
name|size_t
name|decrypted_buffer_size
decl_stmt|;
name|size_t
name|decrypted_bytes_remaining
decl_stmt|;
name|size_t
name|decrypted_unconsumed_bytes
decl_stmt|;
comment|/* Traditional PKWARE decryption. */
name|struct
name|trad_enc_ctx
name|tctx
decl_stmt|;
name|char
name|tctx_valid
decl_stmt|;
comment|/* WinZip AES decryption. */
comment|/* Contexts used for AES decryption. */
name|archive_crypto_ctx
name|cctx
decl_stmt|;
name|char
name|cctx_valid
decl_stmt|;
name|archive_hmac_sha1_ctx
name|hctx
decl_stmt|;
name|char
name|hctx_valid
decl_stmt|;
comment|/* Strong encryption's decryption header information. */
name|unsigned
name|iv_size
decl_stmt|;
name|unsigned
name|alg_id
decl_stmt|;
name|unsigned
name|bit_len
decl_stmt|;
name|unsigned
name|flags
decl_stmt|;
name|unsigned
name|erd_size
decl_stmt|;
name|unsigned
name|v_size
decl_stmt|;
name|unsigned
name|v_crc32
decl_stmt|;
name|uint8_t
modifier|*
name|iv
decl_stmt|;
name|uint8_t
modifier|*
name|erd
decl_stmt|;
name|uint8_t
modifier|*
name|v_data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Many systems define min or MIN, but not all. */
end_comment

begin_define
define|#
directive|define
name|zipmin
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*   Traditional PKWARE Decryption functions.  */
end_comment

begin_function
specifier|static
name|void
name|trad_enc_update_keys
parameter_list|(
name|struct
name|trad_enc_ctx
modifier|*
name|ctx
parameter_list|,
name|uint8_t
name|c
parameter_list|)
block|{
name|uint8_t
name|t
decl_stmt|;
define|#
directive|define
name|CRC32
parameter_list|(
name|c
parameter_list|,
name|b
parameter_list|)
value|(crc32(c ^ 0xffffffffUL,&b, 1) ^ 0xffffffffUL)
name|ctx
operator|->
name|keys
index|[
literal|0
index|]
operator|=
name|CRC32
argument_list|(
name|ctx
operator|->
name|keys
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|keys
index|[
literal|1
index|]
operator|=
operator|(
name|ctx
operator|->
name|keys
index|[
literal|1
index|]
operator|+
operator|(
name|ctx
operator|->
name|keys
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|)
operator|*
literal|134775813L
operator|+
literal|1
expr_stmt|;
name|t
operator|=
operator|(
name|ctx
operator|->
name|keys
index|[
literal|1
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ctx
operator|->
name|keys
index|[
literal|2
index|]
operator|=
name|CRC32
argument_list|(
name|ctx
operator|->
name|keys
index|[
literal|2
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CRC32
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|trad_enc_decrypt_byte
parameter_list|(
name|struct
name|trad_enc_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|unsigned
name|temp
init|=
name|ctx
operator|->
name|keys
index|[
literal|2
index|]
operator||
literal|2
decl_stmt|;
return|return
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|temp
operator|*
operator|(
name|temp
operator|^
literal|1
operator|)
operator|)
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trad_enc_decrypt_update
parameter_list|(
name|struct
name|trad_enc_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|in
parameter_list|,
name|size_t
name|in_len
parameter_list|,
name|uint8_t
modifier|*
name|out
parameter_list|,
name|size_t
name|out_len
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|max
decl_stmt|;
name|max
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|in_len
operator|<
name|out_len
operator|)
condition|?
name|in_len
else|:
name|out_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|t
init|=
name|in
index|[
name|i
index|]
operator|^
name|trad_enc_decrypt_byte
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|out
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
name|trad_enc_update_keys
argument_list|(
name|ctx
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|trad_enc_init
parameter_list|(
name|struct
name|trad_enc_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|pw
parameter_list|,
name|size_t
name|pw_len
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|key
parameter_list|,
name|size_t
name|key_len
parameter_list|,
name|uint8_t
modifier|*
name|crcchk
parameter_list|)
block|{
name|uint8_t
name|header
index|[
literal|12
index|]
decl_stmt|;
if|if
condition|(
name|key_len
operator|<
literal|12
condition|)
block|{
operator|*
name|crcchk
operator|=
literal|0xff
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ctx
operator|->
name|keys
index|[
literal|0
index|]
operator|=
literal|305419896L
expr_stmt|;
name|ctx
operator|->
name|keys
index|[
literal|1
index|]
operator|=
literal|591751049L
expr_stmt|;
name|ctx
operator|->
name|keys
index|[
literal|2
index|]
operator|=
literal|878082192L
expr_stmt|;
for|for
control|(
init|;
name|pw_len
condition|;
operator|--
name|pw_len
control|)
name|trad_enc_update_keys
argument_list|(
name|ctx
argument_list|,
operator|*
name|pw
operator|++
argument_list|)
expr_stmt|;
name|trad_enc_decrypt_update
argument_list|(
name|ctx
argument_list|,
name|key
argument_list|,
literal|12
argument_list|,
name|header
argument_list|,
literal|12
argument_list|)
expr_stmt|;
comment|/* Return the last byte for CRC check. */
operator|*
name|crcchk
operator|=
name|header
index|[
literal|11
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_define
unit|static void crypt_derive_key_sha1(const void *p, int size, unsigned char *key,     int key_size) {
define|#
directive|define
name|MD_SIZE
value|20
end_define

begin_undef
unit|archive_sha1_ctx ctx; 	unsigned char md1[MD_SIZE]; 	unsigned char md2[MD_SIZE * 2]; 	unsigned char mkb[64]; 	int i;  	archive_sha1_init(&ctx); 	archive_sha1_update(&ctx, p, size); 	archive_sha1_final(&ctx, md1);  	memset(mkb, 0x36, sizeof(mkb)); 	for (i = 0; i< MD_SIZE; i++) 		mkb[i] ^= md1[i]; 	archive_sha1_init(&ctx); 	archive_sha1_update(&ctx, mkb, sizeof(mkb)); 	archive_sha1_final(&ctx, md2);  	memset(mkb, 0x5C, sizeof(mkb)); 	for (i = 0; i< MD_SIZE; i++) 		mkb[i] ^= md1[i]; 	archive_sha1_init(&ctx); 	archive_sha1_update(&ctx, mkb, sizeof(mkb)); 	archive_sha1_final(&ctx, md2 + MD_SIZE);  	if (key_size> 32) 		key_size = 32; 	memcpy(key, md2, key_size);
undef|#
directive|undef
name|MD_SIZE
end_undef

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Common code for streaming or seeking modes.  *  * Includes code to read local file headers, decompress data  * from entry bodies, and common API.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|real_crc32
parameter_list|(
name|unsigned
name|long
name|crc
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|crc32
argument_list|(
name|crc
argument_list|,
name|buff
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Used by "ignorecrc32" option to speed up tests. */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|fake_crc32
parameter_list|(
name|unsigned
name|long
name|crc
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
operator|(
name|void
operator|)
name|crc
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|buff
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|len
expr_stmt|;
comment|/* UNUSED */
return|return
literal|0
return|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|int
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|compression_methods
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|"uncompressed"
block|}
block|,
comment|/* The file is stored (no compression) */
block|{
literal|1
block|,
literal|"shrinking"
block|}
block|,
comment|/* The file is Shrunk */
block|{
literal|2
block|,
literal|"reduced-1"
block|}
block|,
comment|/* The file is Reduced with compression factor 1 */
block|{
literal|3
block|,
literal|"reduced-2"
block|}
block|,
comment|/* The file is Reduced with compression factor 2 */
block|{
literal|4
block|,
literal|"reduced-3"
block|}
block|,
comment|/* The file is Reduced with compression factor 3 */
block|{
literal|5
block|,
literal|"reduced-4"
block|}
block|,
comment|/* The file is Reduced with compression factor 4 */
block|{
literal|6
block|,
literal|"imploded"
block|}
block|,
comment|/* The file is Imploded */
block|{
literal|7
block|,
literal|"reserved"
block|}
block|,
comment|/* Reserved for Tokenizing compression algorithm */
block|{
literal|8
block|,
literal|"deflation"
block|}
block|,
comment|/* The file is Deflated */
block|{
literal|9
block|,
literal|"deflation-64-bit"
block|}
block|,
comment|/* Enhanced Deflating using Deflate64(tm) */
block|{
literal|10
block|,
literal|"ibm-terse"
block|}
block|,
comment|/* PKWARE Data Compression Library Imploding 			   * (old IBM TERSE) */
block|{
literal|11
block|,
literal|"reserved"
block|}
block|,
comment|/* Reserved by PKWARE */
block|{
literal|12
block|,
literal|"bzip"
block|}
block|,
comment|/* File is compressed using BZIP2 algorithm */
block|{
literal|13
block|,
literal|"reserved"
block|}
block|,
comment|/* Reserved by PKWARE */
block|{
literal|14
block|,
literal|"lzma"
block|}
block|,
comment|/* LZMA (EFS) */
block|{
literal|15
block|,
literal|"reserved"
block|}
block|,
comment|/* Reserved by PKWARE */
block|{
literal|16
block|,
literal|"reserved"
block|}
block|,
comment|/* Reserved by PKWARE */
block|{
literal|17
block|,
literal|"reserved"
block|}
block|,
comment|/* Reserved by PKWARE */
block|{
literal|18
block|,
literal|"ibm-terse-new"
block|}
block|,
comment|/* File is compressed using IBM TERSE (new) */
block|{
literal|19
block|,
literal|"ibm-lz777"
block|}
block|,
comment|/* IBM LZ77 z Architecture (PFS) */
block|{
literal|97
block|,
literal|"wav-pack"
block|}
block|,
comment|/* WavPack compressed data */
block|{
literal|98
block|,
literal|"ppmd-1"
block|}
block|,
comment|/* PPMd version I, Rev 1 */
block|{
literal|99
block|,
literal|"aes"
block|}
comment|/* WinZip AES encryption  */
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|compression_name
parameter_list|(
specifier|const
name|int
name|compression
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|num_compression_methods
init|=
sizeof|sizeof
argument_list|(
name|compression_methods
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|compression_methods
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|compression
operator|>=
literal|0
operator|&&
name|i
operator|<
name|num_compression_methods
condition|)
block|{
if|if
condition|(
name|compression_methods
index|[
name|i
index|]
operator|.
name|id
operator|==
name|compression
condition|)
return|return
name|compression_methods
index|[
name|i
index|]
operator|.
name|name
return|;
name|i
operator|++
expr_stmt|;
block|}
return|return
literal|"??"
return|;
block|}
end_function

begin_comment
comment|/* Convert an MSDOS-style date/time into Unix-style time. */
end_comment

begin_function
specifier|static
name|time_t
name|zip_time
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|msTime
decl_stmt|,
name|msDate
decl_stmt|;
name|struct
name|tm
name|ts
decl_stmt|;
name|msTime
operator|=
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|0
index|]
operator|)
operator|+
literal|256
operator|*
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|msDate
operator|=
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|2
index|]
operator|)
operator|+
literal|256
operator|*
operator|(
literal|0xff
operator|&
operator|(
name|unsigned
operator|)
name|p
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|msDate
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
operator|)
operator|+
literal|80
expr_stmt|;
comment|/* Years since 1900. */
name|ts
operator|.
name|tm_mon
operator|=
operator|(
operator|(
name|msDate
operator|>>
literal|5
operator|)
operator|&
literal|0x0f
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Month number. */
name|ts
operator|.
name|tm_mday
operator|=
name|msDate
operator|&
literal|0x1f
expr_stmt|;
comment|/* Day of month. */
name|ts
operator|.
name|tm_hour
operator|=
operator|(
name|msTime
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|ts
operator|.
name|tm_min
operator|=
operator|(
name|msTime
operator|>>
literal|5
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|ts
operator|.
name|tm_sec
operator|=
operator|(
name|msTime
operator|<<
literal|1
operator|)
operator|&
literal|0x3e
expr_stmt|;
name|ts
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|mktime
argument_list|(
operator|&
name|ts
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * The extra data is stored as a list of  *	id1+size1+data1 + id2+size2+data2 ...  *  triplets.  id and size are 2 bytes each.  */
end_comment

begin_function
specifier|static
name|int
name|process_extra
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|extra_length
parameter_list|,
name|struct
name|zip_entry
modifier|*
name|zip_entry
parameter_list|)
block|{
name|unsigned
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|extra_length
operator|==
literal|0
condition|)
block|{
return|return
name|ARCHIVE_OK
return|;
block|}
if|if
condition|(
name|extra_length
operator|<
literal|4
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Too-small extra data: Need at least 4 bytes, but only found %d bytes"
argument_list|,
operator|(
name|int
operator|)
name|extra_length
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
while|while
condition|(
name|offset
operator|<=
name|extra_length
operator|-
literal|4
condition|)
block|{
name|unsigned
name|short
name|headerid
init|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|datasize
init|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
decl_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|datasize
operator|>
name|extra_length
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Extra data overflow: Need %d bytes but only found %d bytes"
argument_list|,
operator|(
name|int
operator|)
name|datasize
argument_list|,
call|(
name|int
call|)
argument_list|(
name|extra_length
operator|-
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Header id 0x%04x, length %d\n"
argument_list|,
name|headerid
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|headerid
condition|)
block|{
case|case
literal|0x0001
case|:
comment|/* Zip64 extended information extra field. */
name|zip_entry
operator|->
name|flags
operator||=
name|LA_USED_ZIP64
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|uncompressed_size
operator|==
literal|0xffffffff
condition|)
block|{
name|uint64_t
name|t
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|datasize
operator|<
literal|8
operator|||
operator|(
name|t
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
operator|)
operator|>
name|INT64_MAX
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Malformed 64-bit uncompressed size"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
name|zip_entry
operator|->
name|uncompressed_size
operator|=
name|t
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|datasize
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|zip_entry
operator|->
name|compressed_size
operator|==
literal|0xffffffff
condition|)
block|{
name|uint64_t
name|t
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|datasize
operator|<
literal|8
operator|||
operator|(
name|t
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
operator|)
operator|>
name|INT64_MAX
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Malformed 64-bit compressed size"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
name|zip_entry
operator|->
name|compressed_size
operator|=
name|t
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|datasize
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|zip_entry
operator|->
name|local_header_offset
operator|==
literal|0xffffffff
condition|)
block|{
name|uint64_t
name|t
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|datasize
operator|<
literal|8
operator|||
operator|(
name|t
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
operator|)
operator|>
name|INT64_MAX
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Malformed 64-bit local header offset"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
name|zip_entry
operator|->
name|local_header_offset
operator|=
name|t
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|datasize
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* archive_le32dec(p + offset) gives disk 			 * on which file starts, but we don't handle 			 * multi-volume Zip files. */
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|0x0017
case|:
block|{
comment|/* Strong encryption field. */
if|if
condition|(
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
operator|==
literal|2
condition|)
block|{
name|unsigned
name|algId
init|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
decl_stmt|;
name|unsigned
name|bitLen
init|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|4
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|6
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"algId=0x%04x, bitLen=%u, "
literal|"flgas=%d\n"
argument_list|,
name|algId
argument_list|,
name|bitLen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
case|case
literal|0x5455
case|:
block|{
comment|/* Extended time field "UT". */
name|int
name|flags
init|=
name|p
index|[
name|offset
index|]
decl_stmt|;
name|offset
operator|++
expr_stmt|;
name|datasize
operator|--
expr_stmt|;
comment|/* Flag bits indicate which dates are present. */
if|if
condition|(
name|flags
operator|&
literal|0x01
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mtime: %lld -> %d\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|zip_entry
operator|->
name|mtime
argument_list|,
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|datasize
operator|<
literal|4
condition|)
break|break;
name|zip_entry
operator|->
name|mtime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|datasize
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
literal|0x02
condition|)
block|{
if|if
condition|(
name|datasize
operator|<
literal|4
condition|)
break|break;
name|zip_entry
operator|->
name|atime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|datasize
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
literal|0x04
condition|)
block|{
if|if
condition|(
name|datasize
operator|<
literal|4
condition|)
break|break;
name|zip_entry
operator|->
name|ctime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|datasize
operator|-=
literal|4
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|0x5855
case|:
block|{
comment|/* Info-ZIP Unix Extra Field (old version) "UX". */
if|if
condition|(
name|datasize
operator|>=
literal|8
condition|)
block|{
name|zip_entry
operator|->
name|atime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|mtime
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|datasize
operator|>=
literal|12
condition|)
block|{
name|zip_entry
operator|->
name|uid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|gid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|10
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|0x6c78
case|:
block|{
comment|/* Experimental 'xl' field */
comment|/* 			 * Introduced Dec 2013 to provide a way to 			 * include external file attributes (and other 			 * fields that ordinarily appear only in 			 * central directory) in local file header. 			 * This provides file type and permission 			 * information necessary to support full 			 * streaming extraction.  Currently being 			 * discussed with other Zip developers 			 * ... subject to change. 			 * 			 * Format: 			 *  The field starts with a bitmap that specifies 			 *  which additional fields are included.  The 			 *  bitmap is variable length and can be extended in 			 *  the future. 			 * 			 *  n bytes - feature bitmap: first byte has low-order 			 *    7 bits.  If high-order bit is set, a subsequent 			 *    byte holds the next 7 bits, etc. 			 * 			 *  if bitmap& 1, 2 byte "version made by" 			 *  if bitmap& 2, 2 byte "internal file attributes" 			 *  if bitmap& 4, 4 byte "external file attributes" 			 *  if bitmap& 8, 2 byte comment length + n byte comment 			 */
name|int
name|bitmap
decl_stmt|,
name|bitmap_last
decl_stmt|;
if|if
condition|(
name|datasize
operator|<
literal|1
condition|)
break|break;
name|bitmap_last
operator|=
name|bitmap
operator|=
literal|0xff
operator|&
name|p
index|[
name|offset
index|]
expr_stmt|;
name|offset
operator|+=
literal|1
expr_stmt|;
name|datasize
operator|-=
literal|1
expr_stmt|;
comment|/* We only support first 7 bits of bitmap; skip rest. */
while|while
condition|(
operator|(
name|bitmap_last
operator|&
literal|0x80
operator|)
operator|!=
literal|0
operator|&&
name|datasize
operator|>=
literal|1
condition|)
block|{
name|bitmap_last
operator|=
name|p
index|[
name|offset
index|]
expr_stmt|;
name|offset
operator|+=
literal|1
expr_stmt|;
name|datasize
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bitmap
operator|&
literal|1
condition|)
block|{
comment|/* 2 byte "version made by" */
if|if
condition|(
name|datasize
operator|<
literal|2
condition|)
break|break;
name|zip_entry
operator|->
name|system
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
operator|>>
literal|8
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|datasize
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|bitmap
operator|&
literal|2
condition|)
block|{
comment|/* 2 byte "internal file attributes" */
name|uint32_t
name|internal_attributes
decl_stmt|;
if|if
condition|(
name|datasize
operator|<
literal|2
condition|)
break|break;
name|internal_attributes
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
comment|/* Not used by libarchive at present. */
operator|(
name|void
operator|)
name|internal_attributes
expr_stmt|;
comment|/* UNUSED */
name|offset
operator|+=
literal|2
expr_stmt|;
name|datasize
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|bitmap
operator|&
literal|4
condition|)
block|{
comment|/* 4 byte "external file attributes" */
name|uint32_t
name|external_attributes
decl_stmt|;
if|if
condition|(
name|datasize
operator|<
literal|4
condition|)
break|break;
name|external_attributes
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|system
operator|==
literal|3
condition|)
block|{
name|zip_entry
operator|->
name|mode
operator|=
name|external_attributes
operator|>>
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip_entry
operator|->
name|system
operator|==
literal|0
condition|)
block|{
comment|// Interpret MSDOS directory bit
if|if
condition|(
literal|0x10
operator|==
operator|(
name|external_attributes
operator|&
literal|0x10
operator|)
condition|)
block|{
name|zip_entry
operator|->
name|mode
operator|=
name|AE_IFDIR
operator||
literal|0775
expr_stmt|;
block|}
else|else
block|{
name|zip_entry
operator|->
name|mode
operator|=
name|AE_IFREG
operator||
literal|0664
expr_stmt|;
block|}
if|if
condition|(
literal|0x01
operator|==
operator|(
name|external_attributes
operator|&
literal|0x01
operator|)
condition|)
block|{
comment|// Read-only bit; strip write permissions
name|zip_entry
operator|->
name|mode
operator|&=
literal|0555
expr_stmt|;
block|}
block|}
else|else
block|{
name|zip_entry
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
block|}
name|offset
operator|+=
literal|4
expr_stmt|;
name|datasize
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bitmap
operator|&
literal|8
condition|)
block|{
comment|/* 2 byte comment length + comment */
name|uint32_t
name|comment_length
decl_stmt|;
if|if
condition|(
name|datasize
operator|<
literal|2
condition|)
break|break;
name|comment_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|datasize
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|datasize
operator|<
name|comment_length
condition|)
break|break;
comment|/* Comment is not supported by libarchive */
name|offset
operator|+=
name|comment_length
expr_stmt|;
name|datasize
operator|-=
name|comment_length
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|0x7855
case|:
comment|/* Info-ZIP Unix Extra Field (type 2) "Ux". */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uid %d gid %d\n"
argument_list|,
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
argument_list|,
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|datasize
operator|>=
literal|2
condition|)
name|zip_entry
operator|->
name|uid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|>=
literal|4
condition|)
name|zip_entry
operator|->
name|gid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7875
case|:
block|{
comment|/* Info-Zip Unix Extra Field (type 3) "ux". */
name|int
name|uidsize
init|=
literal|0
decl_stmt|,
name|gidsize
init|=
literal|0
decl_stmt|;
comment|/* TODO: support arbitrary uidsize/gidsize. */
if|if
condition|(
name|datasize
operator|>=
literal|1
operator|&&
name|p
index|[
name|offset
index|]
operator|==
literal|1
condition|)
block|{
comment|/* version=1 */
if|if
condition|(
name|datasize
operator|>=
literal|4
condition|)
block|{
comment|/* get a uid size. */
name|uidsize
operator|=
literal|0xff
operator|&
operator|(
name|int
operator|)
name|p
index|[
name|offset
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|uidsize
operator|==
literal|2
condition|)
name|zip_entry
operator|->
name|uid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uidsize
operator|==
literal|4
operator|&&
name|datasize
operator|>=
literal|6
condition|)
name|zip_entry
operator|->
name|uid
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|datasize
operator|>=
operator|(
literal|2
operator|+
name|uidsize
operator|+
literal|3
operator|)
condition|)
block|{
comment|/* get a gid size. */
name|gidsize
operator|=
literal|0xff
operator|&
operator|(
name|int
operator|)
name|p
index|[
name|offset
operator|+
literal|2
operator|+
name|uidsize
index|]
expr_stmt|;
if|if
condition|(
name|gidsize
operator|==
literal|2
condition|)
name|zip_entry
operator|->
name|gid
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
operator|+
name|uidsize
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gidsize
operator|==
literal|4
operator|&&
name|datasize
operator|>=
operator|(
literal|2
operator|+
name|uidsize
operator|+
literal|5
operator|)
condition|)
name|zip_entry
operator|->
name|gid
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|2
operator|+
name|uidsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
literal|0x9901
case|:
comment|/* WinZip AES extra data field. */
if|if
condition|(
name|datasize
operator|<
literal|6
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Incomplete AES field"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
if|if
condition|(
name|p
index|[
name|offset
operator|+
literal|2
index|]
operator|==
literal|'A'
operator|&&
name|p
index|[
name|offset
operator|+
literal|3
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* Vendor version. */
name|zip_entry
operator|->
name|aes_extra
operator|.
name|vendor
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
name|offset
argument_list|)
expr_stmt|;
comment|/* AES encryption strength. */
name|zip_entry
operator|->
name|aes_extra
operator|.
name|strength
operator|=
name|p
index|[
name|offset
operator|+
literal|4
index|]
expr_stmt|;
comment|/* Actual compression method. */
name|zip_entry
operator|->
name|aes_extra
operator|.
name|compression
operator|=
name|p
index|[
name|offset
operator|+
literal|5
index|]
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|offset
operator|+=
name|datasize
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
name|extra_length
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Malformed extra data: Consumed %d bytes of %d bytes"
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
operator|(
name|int
operator|)
name|extra_length
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
return|return
name|ARCHIVE_OK
return|;
block|}
end_function

begin_comment
comment|/*  * Assumes file pointer is at beginning of local file header.  */
end_comment

begin_function
specifier|static
name|int
name|zip_read_local_file_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|filename_length
decl_stmt|,
name|extra_length
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
name|struct
name|zip_entry
modifier|*
name|zip_entry
init|=
name|zip
operator|->
name|entry
decl_stmt|;
name|struct
name|zip_entry
name|zip_entry_central_dir
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|char
name|version
decl_stmt|;
comment|/* Save a copy of the original for consistency checks. */
name|zip_entry_central_dir
operator|=
operator|*
name|zip_entry
expr_stmt|;
name|zip
operator|->
name|decompress_init
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|end_of_entry
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_compressed_bytes_read
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry_crc32
operator|=
name|zip
operator|->
name|crc32func
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup default conversion. */
if|if
condition|(
name|zip
operator|->
name|sconv
operator|==
name|NULL
operator|&&
operator|!
name|zip
operator|->
name|init_default_conversion
condition|)
block|{
name|zip
operator|->
name|sconv_default
operator|=
name|archive_string_default_conversion_for_read
argument_list|(
operator|&
operator|(
name|a
operator|->
name|archive
operator|)
argument_list|)
expr_stmt|;
name|zip
operator|->
name|init_default_conversion
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|30
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"PK\003\004"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Damaged Zip archive"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|version
operator|=
name|p
index|[
literal|4
index|]
expr_stmt|;
name|zip_entry
operator|->
name|system
operator|=
name|p
index|[
literal|5
index|]
expr_stmt|;
name|zip_entry
operator|->
name|zip_flags
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|zip_flags
operator|&
operator|(
name|ZIP_ENCRYPTED
operator||
name|ZIP_STRONG_ENCRYPTED
operator|)
condition|)
block|{
name|zip
operator|->
name|has_encrypted_entries
operator|=
literal|1
expr_stmt|;
name|archive_entry_set_is_data_encrypted
argument_list|(
name|entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|zip_flags
operator|&
name|ZIP_CENTRAL_DIRECTORY_ENCRYPTED
operator|&&
name|zip_entry
operator|->
name|zip_flags
operator|&
name|ZIP_ENCRYPTED
operator|&&
name|zip_entry
operator|->
name|zip_flags
operator|&
name|ZIP_STRONG_ENCRYPTED
condition|)
block|{
name|archive_entry_set_is_metadata_encrypted
argument_list|(
name|entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
block|}
name|zip
operator|->
name|init_decryption
operator|=
operator|(
name|zip_entry
operator|->
name|zip_flags
operator|&
name|ZIP_ENCRYPTED
operator|)
expr_stmt|;
name|zip_entry
operator|->
name|compression
operator|=
operator|(
name|char
operator|)
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|mtime
operator|=
name|zip_time
argument_list|(
name|p
operator|+
literal|10
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
condition|)
name|zip_entry
operator|->
name|decdat
operator|=
name|p
index|[
literal|11
index|]
expr_stmt|;
else|else
name|zip_entry
operator|->
name|decdat
operator|=
name|p
index|[
literal|17
index|]
expr_stmt|;
name|zip_entry
operator|->
name|compressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|18
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|22
argument_list|)
expr_stmt|;
name|filename_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|26
argument_list|)
expr_stmt|;
name|extra_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|28
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|30
argument_list|)
expr_stmt|;
comment|/* Read the filename. */
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|filename_length
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|zip_entry
operator|->
name|zip_flags
operator|&
name|ZIP_UTF8_NAME
condition|)
block|{
comment|/* The filename is stored to be UTF-8. */
if|if
condition|(
name|zip
operator|->
name|sconv_utf8
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|sconv_utf8
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|"UTF-8"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|sconv_utf8
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|sconv
operator|=
name|zip
operator|->
name|sconv_utf8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip
operator|->
name|sconv
operator|!=
name|NULL
condition|)
name|sconv
operator|=
name|zip
operator|->
name|sconv
expr_stmt|;
else|else
name|sconv
operator|=
name|zip
operator|->
name|sconv_default
expr_stmt|;
if|if
condition|(
name|archive_entry_copy_pathname_l
argument_list|(
name|entry
argument_list|,
name|h
argument_list|,
name|filename_length
argument_list|,
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Pathname cannot be converted "
literal|"from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|filename_length
argument_list|)
expr_stmt|;
comment|/* Read the extra data. */
if|if
condition|(
operator|(
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|extra_length
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|process_extra
argument_list|(
name|a
argument_list|,
name|h
argument_list|,
name|extra_length
argument_list|,
name|zip_entry
argument_list|)
condition|)
block|{
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|extra_length
argument_list|)
expr_stmt|;
comment|/* Work around a bug in Info-Zip: When reading from a pipe, it 	 * stats the pipe instead of synthesizing a file entry. */
if|if
condition|(
operator|(
name|zip_entry
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFIFO
condition|)
block|{
name|zip_entry
operator|->
name|mode
operator|&=
operator|~
name|AE_IFMT
expr_stmt|;
name|zip_entry
operator|->
name|mode
operator||=
name|AE_IFREG
expr_stmt|;
block|}
comment|/* If the mode is totally empty, set some sane default. */
if|if
condition|(
name|zip_entry
operator|->
name|mode
operator|==
literal|0
condition|)
block|{
name|zip_entry
operator|->
name|mode
operator||=
literal|0664
expr_stmt|;
block|}
comment|/* Make sure that entries with a trailing '/' are marked as directories 	 * even if the External File Attributes contains bogus values.  If this 	 * is not a directory and there is no type, assume regularfile. */
if|if
condition|(
operator|(
name|zip_entry
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|!=
name|AE_IFDIR
condition|)
block|{
name|int
name|has_slash
decl_stmt|;
name|wp
operator|=
name|archive_entry_pathname_w
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|wcslen
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|has_slash
operator|=
name|len
operator|>
literal|0
operator|&&
name|wp
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|L'
expr|/'
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|cp
operator|!=
name|NULL
operator|)
condition|?
name|strlen
argument_list|(
name|cp
argument_list|)
else|:
literal|0
expr_stmt|;
name|has_slash
operator|=
name|len
operator|>
literal|0
operator|&&
name|cp
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
expr_stmt|;
block|}
comment|/* Correct file type as needed. */
if|if
condition|(
name|has_slash
condition|)
block|{
name|zip_entry
operator|->
name|mode
operator|&=
operator|~
name|AE_IFMT
expr_stmt|;
name|zip_entry
operator|->
name|mode
operator||=
name|AE_IFDIR
expr_stmt|;
name|zip_entry
operator|->
name|mode
operator||=
literal|0111
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|zip_entry
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
literal|0
condition|)
block|{
name|zip_entry
operator|->
name|mode
operator||=
name|AE_IFREG
expr_stmt|;
block|}
block|}
comment|/* Make sure directories end in '/' */
if|if
condition|(
operator|(
name|zip_entry
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFDIR
condition|)
block|{
name|wp
operator|=
name|archive_entry_pathname_w
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|wcslen
argument_list|(
name|wp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|wp
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|L'
expr|/'
condition|)
block|{
name|struct
name|archive_wstring
name|s
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|archive_wstrcat
argument_list|(
operator|&
name|s
argument_list|,
name|wp
argument_list|)
expr_stmt|;
name|archive_wstrappend_wchar
argument_list|(
operator|&
name|s
argument_list|,
literal|L'
expr|/'
argument_list|)
expr_stmt|;
name|archive_entry_copy_pathname_w
argument_list|(
name|entry
argument_list|,
name|s
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_wstring_free
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cp
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|cp
operator|!=
name|NULL
operator|)
condition|?
name|strlen
argument_list|(
name|cp
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|cp
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|struct
name|archive_string
name|s
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|s
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
operator|&
name|s
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|s
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|zip_entry
operator|->
name|flags
operator|&
name|LA_FROM_CENTRAL_DIRECTORY
condition|)
block|{
comment|/* If this came from the central dir, it's size info 		 * is definitive, so ignore the length-at-end flag. */
name|zip_entry
operator|->
name|zip_flags
operator|&=
operator|~
name|ZIP_LENGTH_AT_END
expr_stmt|;
comment|/* If local header is missing a value, use the one from 		   the central directory.  If both have it, warn about 		   mismatches. */
if|if
condition|(
name|zip_entry
operator|->
name|crc32
operator|==
literal|0
condition|)
block|{
name|zip_entry
operator|->
name|crc32
operator|=
name|zip_entry_central_dir
operator|.
name|crc32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zip
operator|->
name|ignore_crc32
operator|&&
name|zip_entry
operator|->
name|crc32
operator|!=
name|zip_entry_central_dir
operator|.
name|crc32
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Inconsistent CRC32 values"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
if|if
condition|(
name|zip_entry
operator|->
name|compressed_size
operator|==
literal|0
condition|)
block|{
name|zip_entry
operator|->
name|compressed_size
operator|=
name|zip_entry_central_dir
operator|.
name|compressed_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip_entry
operator|->
name|compressed_size
operator|!=
name|zip_entry_central_dir
operator|.
name|compressed_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Inconsistent compressed size: "
literal|"%jd in central directory, %jd in local header"
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip_entry_central_dir
operator|.
name|compressed_size
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip_entry
operator|->
name|compressed_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
if|if
condition|(
name|zip_entry
operator|->
name|uncompressed_size
operator|==
literal|0
condition|)
block|{
name|zip_entry
operator|->
name|uncompressed_size
operator|=
name|zip_entry_central_dir
operator|.
name|uncompressed_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip_entry
operator|->
name|uncompressed_size
operator|!=
name|zip_entry_central_dir
operator|.
name|uncompressed_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Inconsistent uncompressed size: "
literal|"%jd in central directory, %jd in local header"
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip_entry_central_dir
operator|.
name|uncompressed_size
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip_entry
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
comment|/* Populate some additional entry fields: */
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|mode
argument_list|)
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|uid
argument_list|)
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|gid
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|mtime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|ctime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|atime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zip
operator|->
name|entry
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
operator|==
name|AE_IFLNK
condition|)
block|{
name|size_t
name|linkname_length
decl_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|compressed_size
operator|>
literal|64
operator|*
literal|1024
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Zip file with oversized link entry"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|linkname_length
operator|=
operator|(
name|size_t
operator|)
name|zip_entry
operator|->
name|compressed_size
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|linkname_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Truncated Zip file"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
name|sconv
operator|=
name|zip
operator|->
name|sconv
expr_stmt|;
if|if
condition|(
name|sconv
operator|==
name|NULL
operator|&&
operator|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_UTF8_NAME
operator|)
condition|)
name|sconv
operator|=
name|zip
operator|->
name|sconv_utf8
expr_stmt|;
if|if
condition|(
name|sconv
operator|==
name|NULL
condition|)
name|sconv
operator|=
name|zip
operator|->
name|sconv_default
expr_stmt|;
if|if
condition|(
name|archive_entry_copy_symlink_l
argument_list|(
name|entry
argument_list|,
name|p
argument_list|,
name|linkname_length
argument_list|,
name|sconv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOMEM
operator|&&
name|sconv
operator|==
name|zip
operator|->
name|sconv_utf8
operator|&&
operator|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_UTF8_NAME
operator|)
condition|)
name|archive_entry_copy_symlink_l
argument_list|(
name|entry
argument_list|,
name|p
argument_list|,
name|linkname_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Symlink"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* 			 * Since there is no character-set regulation for 			 * symlink name, do not report the conversion error 			 * in an automatic conversion. 			 */
if|if
condition|(
name|sconv
operator|!=
name|zip
operator|->
name|sconv_utf8
operator|||
operator|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_UTF8_NAME
operator|)
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Symlink cannot be converted "
literal|"from %s to current locale."
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
name|zip_entry
operator|->
name|uncompressed_size
operator|=
name|zip_entry
operator|->
name|compressed_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|linkname_length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Read error skipping symlink target name"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
operator|(
name|zip_entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
operator|||
name|zip_entry
operator|->
name|uncompressed_size
operator|>
literal|0
condition|)
block|{
comment|/* Set the size only if it's meaningful. */
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|zip_entry
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
block|}
name|zip
operator|->
name|entry_bytes_remaining
operator|=
name|zip_entry
operator|->
name|compressed_size
expr_stmt|;
comment|/* If there's no body, force read_data() to return EOF immediately. */
if|if
condition|(
literal|0
operator|==
operator|(
name|zip_entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
operator|&&
name|zip
operator|->
name|entry_bytes_remaining
operator|<
literal|1
condition|)
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
comment|/* Set up a more descriptive format name. */
name|archive_string_sprintf
argument_list|(
operator|&
name|zip
operator|->
name|format_name
argument_list|,
literal|"ZIP %d.%d (%s)"
argument_list|,
name|version
operator|/
literal|10
argument_list|,
name|version
operator|%
literal|10
argument_list|,
name|compression_name
argument_list|(
name|zip
operator|->
name|entry
operator|->
name|compression
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
name|zip
operator|->
name|format_name
operator|.
name|s
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_authentication_code
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
comment|/* Check authentication code. */
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
block|{
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
name|uint8_t
name|hmac
index|[
literal|20
index|]
decl_stmt|;
name|size_t
name|hmac_len
init|=
literal|20
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|archive_hmac_sha1_final
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|,
name|hmac
argument_list|,
operator|&
name|hmac_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|_p
operator|==
name|NULL
condition|)
block|{
comment|/* Read authentication code. */
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|AUTH_CODE_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|_p
expr_stmt|;
block|}
name|cmp
operator|=
name|memcmp
argument_list|(
name|hmac
argument_list|,
name|p
argument_list|,
name|AUTH_CODE_SIZE
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|AUTH_CODE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP bad Authentication code"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read "uncompressed" data.  There are three cases:  *  1) We know the size of the data.  This is always true for the  * seeking reader (we've examined the Central Directory already).  *  2) ZIP_LENGTH_AT_END was set, but only the CRC was deferred.  * Info-ZIP seems to do this; we know the size but have to grab  * the CRC from the data descriptor afterwards.  *  3) We're streaming and ZIP_LENGTH_AT_END was specified and  * we have no size information.  In this case, we can do pretty  * well by watching for the data descriptor record.  The data  * descriptor is 16 bytes and includes a computed CRC that should  * provide a strong check.  *  * TODO: Technically, the PK\007\010 signature is optional.  * In the original spec, the data descriptor contained CRC  * and size fields but had no leading signature.  In practice,  * newer writers seem to provide the signature pretty consistently.  *  * For uncompressed data, the PK\007\010 marker seems essential  * to be sure we've actually seen the end of the entry.  *  * Returns ARCHIVE_OK if successful, ARCHIVE_FATAL otherwise, sets  * zip->end_of_entry if it consumes all of the data.  */
end_comment

begin_function
specifier|static
name|int
name|zip_read_data_none
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|_buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
specifier|const
name|char
modifier|*
name|buff
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
name|int
name|r
decl_stmt|;
operator|(
name|void
operator|)
name|offset
expr_stmt|;
comment|/* UNUSED */
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|grabbing_bytes
init|=
literal|24
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
name|grabbing_bytes
operator|+=
name|AUTH_CODE_SIZE
expr_stmt|;
comment|/* Grab at least 24 bytes. */
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|grabbing_bytes
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<
name|grabbing_bytes
condition|)
block|{
comment|/* Zip archives have end-of-archive markers 			   that are longer than this, so a failure to get at 			   least 24 bytes really does indicate a truncated 			   file. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Check for a complete PK\007\010 signature, followed 		 * by the correct 4-byte CRC. */
name|p
operator|=
name|buff
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
name|p
operator|+=
name|AUTH_CODE_SIZE
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\010'
operator|&&
operator|(
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
operator|==
name|zip
operator|->
name|entry_crc32
operator|||
name|zip
operator|->
name|ignore_crc32
operator|||
operator|(
name|zip
operator|->
name|hctx_valid
operator|&&
name|zip
operator|->
name|entry
operator|->
name|aes_extra
operator|.
name|vendor
operator|==
name|AES_VENDOR_AE_2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|flags
operator|&
name|LA_USED_ZIP64
condition|)
block|{
name|uint64_t
name|compressed
decl_stmt|,
name|uncompressed
decl_stmt|;
name|zip
operator|->
name|entry
operator|->
name|crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|compressed
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
name|uncompressed
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|compressed
operator|>
name|INT64_MAX
operator|||
name|uncompressed
operator|>
name|INT64_MAX
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Overflow of 64-bit file sizes"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
name|zip
operator|->
name|entry
operator|->
name|compressed_size
operator|=
name|compressed
expr_stmt|;
name|zip
operator|->
name|entry
operator|->
name|uncompressed_size
operator|=
name|uncompressed
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|24
expr_stmt|;
block|}
else|else
block|{
name|zip
operator|->
name|entry
operator|->
name|crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry
operator|->
name|compressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry
operator|->
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
block|{
name|r
operator|=
name|check_authentication_code
argument_list|(
name|a
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* If not at EOF, ensure we consume at least one byte. */
operator|++
name|p
expr_stmt|;
comment|/* Scan forward until we see where a PK\007\010 signature 		 * might be. */
comment|/* Return bytes up until that point.  On the next call, 		 * the code above will verify the data descriptor. */
while|while
condition|(
name|p
operator|<
name|buff
operator|+
name|bytes_avail
operator|-
literal|4
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'P'
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'K'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'\007'
condition|)
block|{
name|p
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'\010'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
name|p
operator|-=
name|AUTH_CODE_SIZE
expr_stmt|;
break|break;
block|}
else|else
block|{
name|p
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|bytes_avail
operator|=
name|p
operator|-
name|buff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zip
operator|->
name|entry_bytes_remaining
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
block|{
name|r
operator|=
name|check_authentication_code
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* Grab a bunch of bytes. */
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_avail
operator|>
name|zip
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|zip
operator|->
name|entry_bytes_remaining
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|tctx_valid
operator|||
name|zip
operator|->
name|cctx_valid
condition|)
block|{
name|size_t
name|dec_size
init|=
name|bytes_avail
decl_stmt|;
if|if
condition|(
name|dec_size
operator|>
name|zip
operator|->
name|decrypted_buffer_size
condition|)
name|dec_size
operator|=
name|zip
operator|->
name|decrypted_buffer_size
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|tctx_valid
condition|)
block|{
name|trad_enc_decrypt_update
argument_list|(
operator|&
name|zip
operator|->
name|tctx
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|buff
argument_list|,
name|dec_size
argument_list|,
name|zip
operator|->
name|decrypted_buffer
argument_list|,
name|dec_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|dsize
init|=
name|dec_size
decl_stmt|;
name|archive_hmac_sha1_update
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|buff
argument_list|,
name|dec_size
argument_list|)
expr_stmt|;
name|archive_decrypto_aes_ctr_update
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|buff
argument_list|,
name|dec_size
argument_list|,
name|zip
operator|->
name|decrypted_buffer
argument_list|,
operator|&
name|dsize
argument_list|)
expr_stmt|;
block|}
name|bytes_avail
operator|=
name|dec_size
expr_stmt|;
name|buff
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|zip
operator|->
name|decrypted_buffer
expr_stmt|;
block|}
operator|*
name|size
operator|=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|+=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|entry_compressed_bytes_read
operator|+=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|+=
name|bytes_avail
expr_stmt|;
operator|*
name|_buff
operator|=
name|buff
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
end_ifdef

begin_function
specifier|static
name|int
name|zip_deflate_init
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
comment|/* If we haven't yet read any data, initialize the decompressor. */
if|if
condition|(
operator|!
name|zip
operator|->
name|decompress_init
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|stream_valid
condition|)
name|r
operator|=
name|inflateReset
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|inflateInit2
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|,
operator|-
literal|15
comment|/* Don't check for zlib header */
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't initialize ZIP decompression."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Stream structure has been set up. */
name|zip
operator|->
name|stream_valid
operator|=
literal|1
expr_stmt|;
comment|/* We've initialized decompression for this stream. */
name|zip
operator|->
name|decompress_init
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zip_read_data_deflate
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
specifier|const
name|void
modifier|*
name|compressed_buff
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|int
name|r
decl_stmt|;
operator|(
name|void
operator|)
name|offset
expr_stmt|;
comment|/* UNUSED */
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* If the buffer hasn't been allocated, allocate it now. */
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|uncompressed_buffer_size
operator|=
literal|256
operator|*
literal|1024
expr_stmt|;
name|zip
operator|->
name|uncompressed_buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|zip
operator|->
name|uncompressed_buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|uncompressed_buffer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for ZIP decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|r
operator|=
name|zip_deflate_init
argument_list|(
name|a
argument_list|,
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* 	 * Note: '1' here is a performance optimization. 	 * Recall that the decompression layer returns a count of 	 * available bytes; asking for more than that forces the 	 * decompressor to combine reads by copying data. 	 */
name|compressed_buff
operator|=
name|sp
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
operator|&&
name|bytes_avail
operator|>
name|zip
operator|->
name|entry_bytes_remaining
condition|)
block|{
name|bytes_avail
operator|=
operator|(
name|ssize_t
operator|)
name|zip
operator|->
name|entry_bytes_remaining
expr_stmt|;
block|}
if|if
condition|(
name|bytes_avail
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file body"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|zip
operator|->
name|tctx_valid
operator|||
name|zip
operator|->
name|cctx_valid
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|decrypted_bytes_remaining
operator|<
operator|(
name|size_t
operator|)
name|bytes_avail
condition|)
block|{
name|size_t
name|buff_remaining
init|=
operator|(
name|zip
operator|->
name|decrypted_buffer
operator|+
name|zip
operator|->
name|decrypted_buffer_size
operator|)
operator|-
operator|(
name|zip
operator|->
name|decrypted_ptr
operator|+
name|zip
operator|->
name|decrypted_bytes_remaining
operator|)
decl_stmt|;
if|if
condition|(
name|buff_remaining
operator|>
operator|(
name|size_t
operator|)
name|bytes_avail
condition|)
name|buff_remaining
operator|=
operator|(
name|size_t
operator|)
name|bytes_avail
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
operator|&&
name|zip
operator|->
name|entry_bytes_remaining
operator|>
literal|0
condition|)
block|{
if|if
condition|(
call|(
name|int64_t
call|)
argument_list|(
name|zip
operator|->
name|decrypted_bytes_remaining
operator|+
name|buff_remaining
argument_list|)
operator|>
name|zip
operator|->
name|entry_bytes_remaining
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|entry_bytes_remaining
operator|<
operator|(
name|int64_t
operator|)
name|zip
operator|->
name|decrypted_bytes_remaining
condition|)
name|buff_remaining
operator|=
literal|0
expr_stmt|;
else|else
name|buff_remaining
operator|=
operator|(
name|size_t
operator|)
name|zip
operator|->
name|entry_bytes_remaining
operator|-
name|zip
operator|->
name|decrypted_bytes_remaining
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buff_remaining
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|tctx_valid
condition|)
block|{
name|trad_enc_decrypt_update
argument_list|(
operator|&
name|zip
operator|->
name|tctx
argument_list|,
name|compressed_buff
argument_list|,
name|buff_remaining
argument_list|,
name|zip
operator|->
name|decrypted_ptr
operator|+
name|zip
operator|->
name|decrypted_bytes_remaining
argument_list|,
name|buff_remaining
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|dsize
init|=
name|buff_remaining
decl_stmt|;
name|archive_decrypto_aes_ctr_update
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|,
name|compressed_buff
argument_list|,
name|buff_remaining
argument_list|,
name|zip
operator|->
name|decrypted_ptr
operator|+
name|zip
operator|->
name|decrypted_bytes_remaining
argument_list|,
operator|&
name|dsize
argument_list|)
expr_stmt|;
block|}
name|zip
operator|->
name|decrypted_bytes_remaining
operator|+=
name|buff_remaining
expr_stmt|;
block|}
block|}
name|bytes_avail
operator|=
name|zip
operator|->
name|decrypted_bytes_remaining
expr_stmt|;
name|compressed_buff
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|zip
operator|->
name|decrypted_ptr
expr_stmt|;
block|}
comment|/* 	 * A bug in zlib.h: stream.next_in should be marked 'const' 	 * but isn't (the library never alters data through the 	 * next_in pointer, only reads it).  The result: this ugly 	 * cast to remove 'const'. 	 */
name|zip
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|compressed_buff
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|next_out
operator|=
name|zip
operator|->
name|uncompressed_buffer
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|zip
operator|->
name|uncompressed_buffer_size
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|inflate
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
break|break;
case|case
name|Z_STREAM_END
case|:
name|zip
operator|->
name|end_of_entry
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory for ZIP decompression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP decompression failed (%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Consume as much as the compressor actually used. */
name|bytes_avail
operator|=
name|zip
operator|->
name|stream
operator|.
name|total_in
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|tctx_valid
operator|||
name|zip
operator|->
name|cctx_valid
condition|)
block|{
name|zip
operator|->
name|decrypted_bytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|decrypted_bytes_remaining
operator|==
literal|0
condition|)
name|zip
operator|->
name|decrypted_ptr
operator|=
name|zip
operator|->
name|decrypted_buffer
expr_stmt|;
else|else
name|zip
operator|->
name|decrypted_ptr
operator|+=
name|bytes_avail
expr_stmt|;
block|}
comment|/* Calculate compressed data as much as we used.*/
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
name|archive_hmac_sha1_update
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|,
name|sp
argument_list|,
name|bytes_avail
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|bytes_avail
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|entry_compressed_bytes_read
operator|+=
name|bytes_avail
expr_stmt|;
operator|*
name|size
operator|=
name|zip
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|+=
name|zip
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
operator|*
name|buff
operator|=
name|zip
operator|->
name|uncompressed_buffer
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|end_of_entry
operator|&&
name|zip
operator|->
name|hctx_valid
condition|)
block|{
name|r
operator|=
name|check_authentication_code
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|zip
operator|->
name|end_of_entry
operator|&&
operator|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|24
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP end-of-file record"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Consume the optional PK\007\010 marker. */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\010'
condition|)
block|{
name|p
operator|+=
literal|4
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|flags
operator|&
name|LA_USED_ZIP64
condition|)
block|{
name|uint64_t
name|compressed
decl_stmt|,
name|uncompressed
decl_stmt|;
name|zip
operator|->
name|entry
operator|->
name|crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|compressed
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|uncompressed
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|compressed
operator|>
name|INT64_MAX
operator|||
name|uncompressed
operator|>
name|INT64_MAX
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Overflow of 64-bit file sizes"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FAILED
return|;
block|}
name|zip
operator|->
name|entry
operator|->
name|compressed_size
operator|=
name|compressed
expr_stmt|;
name|zip
operator|->
name|entry
operator|->
name|uncompressed_size
operator|=
name|uncompressed
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|+=
literal|20
expr_stmt|;
block|}
else|else
block|{
name|zip
operator|->
name|entry
operator|->
name|crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry
operator|->
name|compressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry
operator|->
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|+=
literal|12
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|read_decryption_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|remaining_size
decl_stmt|;
name|unsigned
name|int
name|ts
decl_stmt|;
comment|/* 	 * Read an initialization vector data field. 	 */
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|truncated
goto|;
name|ts
operator|=
name|zip
operator|->
name|iv_size
expr_stmt|;
name|zip
operator|->
name|iv_size
operator|=
name|archive_le16dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|<
name|zip
operator|->
name|iv_size
condition|)
block|{
name|free
argument_list|(
name|zip
operator|->
name|iv
argument_list|)
expr_stmt|;
name|zip
operator|->
name|iv
operator|=
name|NULL
expr_stmt|;
block|}
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|iv_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|truncated
goto|;
if|if
condition|(
name|zip
operator|->
name|iv
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|iv
operator|=
name|malloc
argument_list|(
name|zip
operator|->
name|iv_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|iv
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
block|}
name|memcpy
argument_list|(
name|zip
operator|->
name|iv
argument_list|,
name|p
argument_list|,
name|zip
operator|->
name|iv_size
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|iv_size
argument_list|)
expr_stmt|;
comment|/* 	 * Read a size of remaining decryption header field. 	 */
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|14
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|truncated
goto|;
name|remaining_size
operator|=
name|archive_le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|remaining_size
operator|<
literal|16
operator|||
name|remaining_size
operator|>
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
goto|goto
name|corrupted
goto|;
comment|/* Check if format version is supported. */
if|if
condition|(
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
operator|!=
literal|3
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unsupported encryption format version: %u"
argument_list|,
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* 	 * Read an encryption algorithm field. 	 */
name|zip
operator|->
name|alg_id
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|zip
operator|->
name|alg_id
condition|)
block|{
case|case
literal|0x6601
case|:
comment|/* DES */
case|case
literal|0x6602
case|:
comment|/* RC2 */
case|case
literal|0x6603
case|:
comment|/* 3DES 168 */
case|case
literal|0x6609
case|:
comment|/* 3DES 112 */
case|case
literal|0x660E
case|:
comment|/* AES 128 */
case|case
literal|0x660F
case|:
comment|/* AES 192 */
case|case
literal|0x6610
case|:
comment|/* AES 256 */
case|case
literal|0x6702
case|:
comment|/* RC2 (version>= 5.2) */
case|case
literal|0x6720
case|:
comment|/* Blowfish */
case|case
literal|0x6721
case|:
comment|/* Twofish */
case|case
literal|0x6801
case|:
comment|/* RC4 */
comment|/* Supported encryption algorithm. */
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unknown encryption algorithm: %u"
argument_list|,
name|zip
operator|->
name|alg_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* 	 * Read a bit length field. 	 */
name|zip
operator|->
name|bit_len
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Read a flags field. 	 */
name|zip
operator|->
name|flags
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|10
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|zip
operator|->
name|flags
operator|&
literal|0xf000
condition|)
block|{
case|case
literal|0x0001
case|:
comment|/* Password is required to decrypt. */
case|case
literal|0x0002
case|:
comment|/* Certificates only. */
case|case
literal|0x0003
case|:
comment|/* Password or certificate required to decrypt. */
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unknown encryption flag: %u"
argument_list|,
name|zip
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zip
operator|->
name|flags
operator|&
literal|0xf000
operator|)
operator|==
literal|0
operator|||
operator|(
name|zip
operator|->
name|flags
operator|&
literal|0xf000
operator|)
operator|==
literal|0x4000
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unknown encryption flag: %u"
argument_list|,
name|zip
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* 	 * Read an encrypted random data field. 	 */
name|ts
operator|=
name|zip
operator|->
name|erd_size
expr_stmt|;
name|zip
operator|->
name|erd_size
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zip
operator|->
name|erd_size
operator|&
literal|0xf
operator|)
operator|!=
literal|0
operator|||
operator|(
name|zip
operator|->
name|erd_size
operator|+
literal|16
operator|)
operator|>
name|remaining_size
operator|||
operator|(
name|zip
operator|->
name|erd_size
operator|+
literal|16
operator|)
operator|<
name|zip
operator|->
name|erd_size
condition|)
goto|goto
name|corrupted
goto|;
if|if
condition|(
name|ts
operator|<
name|zip
operator|->
name|erd_size
condition|)
block|{
name|free
argument_list|(
name|zip
operator|->
name|erd
argument_list|)
expr_stmt|;
name|zip
operator|->
name|erd
operator|=
name|NULL
expr_stmt|;
block|}
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|erd_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|truncated
goto|;
if|if
condition|(
name|zip
operator|->
name|erd
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|erd
operator|=
name|malloc
argument_list|(
name|zip
operator|->
name|erd_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|erd
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
block|}
name|memcpy
argument_list|(
name|zip
operator|->
name|erd
argument_list|,
name|p
argument_list|,
name|zip
operator|->
name|erd_size
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|erd_size
argument_list|)
expr_stmt|;
comment|/* 	 * Read a reserved data field. 	 */
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|truncated
goto|;
comment|/* Reserved data size should be zero. */
if|if
condition|(
name|archive_le32dec
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|corrupted
goto|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * Read a password validation data field. 	 */
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|truncated
goto|;
name|ts
operator|=
name|zip
operator|->
name|v_size
expr_stmt|;
name|zip
operator|->
name|v_size
operator|=
name|archive_le16dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zip
operator|->
name|v_size
operator|&
literal|0x0f
operator|)
operator|!=
literal|0
operator|||
operator|(
name|zip
operator|->
name|erd_size
operator|+
name|zip
operator|->
name|v_size
operator|+
literal|16
operator|)
operator|>
name|remaining_size
operator|||
operator|(
name|zip
operator|->
name|erd_size
operator|+
name|zip
operator|->
name|v_size
operator|+
literal|16
operator|)
operator|<
operator|(
name|zip
operator|->
name|erd_size
operator|+
name|zip
operator|->
name|v_size
operator|)
condition|)
goto|goto
name|corrupted
goto|;
if|if
condition|(
name|ts
operator|<
name|zip
operator|->
name|v_size
condition|)
block|{
name|free
argument_list|(
name|zip
operator|->
name|v_data
argument_list|)
expr_stmt|;
name|zip
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
block|}
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|v_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|truncated
goto|;
if|if
condition|(
name|zip
operator|->
name|v_data
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|v_data
operator|=
name|malloc
argument_list|(
name|zip
operator|->
name|v_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|v_data
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
block|}
name|memcpy
argument_list|(
name|zip
operator|->
name|v_data
argument_list|,
name|p
argument_list|,
name|zip
operator|->
name|v_size
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|v_size
argument_list|)
expr_stmt|;
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|truncated
goto|;
name|zip
operator|->
name|v_crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/*return (ARCHIVE_OK); 	 * This is not fully implemented yet.*/
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Encrypted file is unsupported"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
name|truncated
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|corrupted
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Corrupted ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|nomem
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for ZIP decryption"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zip_alloc_decryption_buffer
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
name|size_t
name|bs
init|=
literal|256
operator|*
literal|1024
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|decrypted_buffer
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|decrypted_buffer_size
operator|=
name|bs
expr_stmt|;
name|zip
operator|->
name|decrypted_buffer
operator|=
name|malloc
argument_list|(
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|decrypted_buffer
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory for ZIP decryption"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
name|zip
operator|->
name|decrypted_ptr
operator|=
name|zip
operator|->
name|decrypted_buffer
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_traditional_PKWARE_decryption
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|tctx_valid
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* 	   Read the 12 bytes encryption header stored at 	   the start of the data area. 	 */
define|#
directive|define
name|ENC_HEADER_SIZE
value|12
if|if
condition|(
literal|0
operator|==
operator|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
operator|&&
name|zip
operator|->
name|entry_bytes_remaining
operator|<
name|ENC_HEADER_SIZE
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated Zip encrypted body: only %jd bytes available"
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|ENC_HEADER_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
for|for
control|(
name|retry
operator|=
literal|0
init|;
condition|;
name|retry
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|passphrase
decl_stmt|;
name|uint8_t
name|crcchk
decl_stmt|;
name|passphrase
operator|=
name|__archive_read_next_passphrase
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|passphrase
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
operator|(
name|retry
operator|>
literal|0
operator|)
condition|?
literal|"Incorrect passphrase"
else|:
literal|"Passphrase required for this entry"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* 		 * Initialize ctx for Traditional PKWARE Decryption. 		 */
name|r
operator|=
name|trad_enc_init
argument_list|(
operator|&
name|zip
operator|->
name|tctx
argument_list|,
name|passphrase
argument_list|,
name|strlen
argument_list|(
name|passphrase
argument_list|)
argument_list|,
name|p
argument_list|,
name|ENC_HEADER_SIZE
argument_list|,
operator|&
name|crcchk
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|crcchk
operator|==
name|zip
operator|->
name|entry
operator|->
name|decdat
condition|)
break|break;
comment|/* The passphrase is OK. */
if|if
condition|(
name|retry
operator|>
literal|10000
condition|)
block|{
comment|/* Avoid infinity loop. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Too many incorrect passphrases"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|ENC_HEADER_SIZE
argument_list|)
expr_stmt|;
name|zip
operator|->
name|tctx_valid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
condition|)
block|{
name|zip
operator|->
name|entry_bytes_remaining
operator|-=
name|ENC_HEADER_SIZE
expr_stmt|;
block|}
comment|/*zip->entry_uncompressed_bytes_read += ENC_HEADER_SIZE;*/
name|zip
operator|->
name|entry_compressed_bytes_read
operator|+=
name|ENC_HEADER_SIZE
expr_stmt|;
name|zip
operator|->
name|decrypted_bytes_remaining
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|zip_alloc_decryption_buffer
argument_list|(
name|a
argument_list|)
operator|)
return|;
undef|#
directive|undef
name|ENC_HEADER_SIZE
block|}
end_function

begin_function
specifier|static
name|int
name|init_WinZip_AES_decryption
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|pv
decl_stmt|;
name|size_t
name|key_len
decl_stmt|,
name|salt_len
decl_stmt|;
name|uint8_t
name|derived_key
index|[
name|MAX_DERIVED_KEY_BUF_SIZE
index|]
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|cctx_valid
operator|||
name|zip
operator|->
name|hctx_valid
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
switch|switch
condition|(
name|zip
operator|->
name|entry
operator|->
name|aes_extra
operator|.
name|strength
condition|)
block|{
case|case
literal|1
case|:
name|salt_len
operator|=
literal|8
expr_stmt|;
name|key_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|salt_len
operator|=
literal|12
expr_stmt|;
name|key_len
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|salt_len
operator|=
literal|16
expr_stmt|;
name|key_len
operator|=
literal|32
expr_stmt|;
break|break;
default|default:
goto|goto
name|corrupted
goto|;
block|}
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|salt_len
operator|+
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|truncated
goto|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
condition|;
name|retry
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|passphrase
decl_stmt|;
name|passphrase
operator|=
name|__archive_read_next_passphrase
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|passphrase
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
operator|(
name|retry
operator|>
literal|0
operator|)
condition|?
literal|"Incorrect passphrase"
else|:
literal|"Passphrase required for this entry"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|memset
argument_list|(
name|derived_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|derived_key
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_pbkdf2_sha1
argument_list|(
name|passphrase
argument_list|,
name|strlen
argument_list|(
name|passphrase
argument_list|)
argument_list|,
name|p
argument_list|,
name|salt_len
argument_list|,
literal|1000
argument_list|,
name|derived_key
argument_list|,
name|key_len
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Decryption is unsupported due to lack of "
literal|"crypto library"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
comment|/* Check password verification value. */
name|pv
operator|=
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|p
operator|)
operator|+
name|salt_len
expr_stmt|;
if|if
condition|(
name|derived_key
index|[
name|key_len
operator|*
literal|2
index|]
operator|==
name|pv
index|[
literal|0
index|]
operator|&&
name|derived_key
index|[
name|key_len
operator|*
literal|2
operator|+
literal|1
index|]
operator|==
name|pv
index|[
literal|1
index|]
condition|)
break|break;
comment|/* The passphrase is OK. */
if|if
condition|(
name|retry
operator|>
literal|10000
condition|)
block|{
comment|/* Avoid infinity loop. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Too many incorrect passphrases"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
block|}
name|r
operator|=
name|archive_decrypto_aes_ctr_init
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|,
name|derived_key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Decryption is unsupported due to lack of crypto library"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|r
operator|=
name|archive_hmac_sha1_init
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|,
name|derived_key
operator|+
name|key_len
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|archive_decrypto_aes_ctr_release
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to initialize HMAC-SHA1"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
block|}
name|zip
operator|->
name|cctx_valid
operator|=
name|zip
operator|->
name|hctx_valid
operator|=
literal|1
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|salt_len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|zip
operator|->
name|entry_bytes_remaining
operator|-=
name|salt_len
operator|+
literal|2
operator|+
name|AUTH_CODE_SIZE
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
operator|&&
name|zip
operator|->
name|entry_bytes_remaining
operator|<
literal|0
condition|)
goto|goto
name|corrupted
goto|;
name|zip
operator|->
name|entry_compressed_bytes_read
operator|+=
name|salt_len
operator|+
literal|2
operator|+
name|AUTH_CODE_SIZE
expr_stmt|;
name|zip
operator|->
name|decrypted_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|entry
operator|->
name|compression
operator|=
name|zip
operator|->
name|entry
operator|->
name|aes_extra
operator|.
name|compression
expr_stmt|;
return|return
operator|(
name|zip_alloc_decryption_buffer
argument_list|(
name|a
argument_list|)
operator|)
return|;
name|truncated
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|corrupted
label|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Corrupted ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int64_t
modifier|*
name|offset
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
decl_stmt|;
if|if
condition|(
name|zip
operator|->
name|has_encrypted_entries
operator|==
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
condition|)
block|{
name|zip
operator|->
name|has_encrypted_entries
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|zip
operator|->
name|entry_uncompressed_bytes_read
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
comment|/* If we hit end-of-entry last time, return ARCHIVE_EOF. */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
comment|/* Return EOF immediately if this is a non-regular file. */
if|if
condition|(
name|AE_IFREG
operator|!=
operator|(
name|zip
operator|->
name|entry
operator|->
name|mode
operator|&
name|AE_IFMT
operator|)
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|unconsumed
argument_list|)
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|init_decryption
condition|)
block|{
name|zip
operator|->
name|has_encrypted_entries
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_STRONG_ENCRYPTED
condition|)
name|r
operator|=
name|read_decryption_header
argument_list|(
name|a
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|compression
operator|==
name|WINZIP_AES_ENCRYPTION
condition|)
name|r
operator|=
name|init_WinZip_AES_decryption
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|init_traditional_PKWARE_decryption
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|zip
operator|->
name|init_decryption
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|zip
operator|->
name|entry
operator|->
name|compression
condition|)
block|{
case|case
literal|0
case|:
comment|/* No compression. */
name|r
operator|=
name|zip_read_data_none
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
case|case
literal|8
case|:
comment|/* Deflate compression. */
name|r
operator|=
name|zip_read_data_deflate
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* Unsupported compression. */
comment|/* Return a warning. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unsupported ZIP compression method (%s)"
argument_list|,
name|compression_name
argument_list|(
name|zip
operator|->
name|entry
operator|->
name|compression
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't decompress this entry, but we will 		 * be able to skip() it and try the next entry. */
return|return
operator|(
name|ARCHIVE_FAILED
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* Update checksum */
if|if
condition|(
operator|*
name|size
condition|)
name|zip
operator|->
name|entry_crc32
operator|=
name|zip
operator|->
name|crc32func
argument_list|(
name|zip
operator|->
name|entry_crc32
argument_list|,
operator|*
name|buff
argument_list|,
operator|(
name|unsigned
operator|)
operator|*
name|size
argument_list|)
expr_stmt|;
comment|/* If we hit the end, swallow any end-of-data marker. */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
block|{
comment|/* Check file size, CRC against these values. */
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|compressed_size
operator|!=
name|zip
operator|->
name|entry_compressed_bytes_read
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP compressed data is wrong size "
literal|"(read %jd, expected %jd)"
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip
operator|->
name|entry_compressed_bytes_read
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip
operator|->
name|entry
operator|->
name|compressed_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Size field only stores the lower 32 bits of the actual 		 * size. */
if|if
condition|(
operator|(
name|zip
operator|->
name|entry
operator|->
name|uncompressed_size
operator|&
name|UINT32_MAX
operator|)
operator|!=
operator|(
name|zip
operator|->
name|entry_uncompressed_bytes_read
operator|&
name|UINT32_MAX
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP uncompressed data is wrong size "
literal|"(read %jd, expected %jd)\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip
operator|->
name|entry_uncompressed_bytes_read
argument_list|,
operator|(
name|intmax_t
operator|)
name|zip
operator|->
name|entry
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Check computed CRC against header */
if|if
condition|(
operator|(
operator|!
name|zip
operator|->
name|hctx_valid
operator|||
name|zip
operator|->
name|entry
operator|->
name|aes_extra
operator|.
name|vendor
operator|!=
name|AES_VENDOR_AE_2
operator|)
operator|&&
name|zip
operator|->
name|entry
operator|->
name|crc32
operator|!=
name|zip
operator|->
name|entry_crc32
operator|&&
operator|!
name|zip
operator|->
name|ignore_crc32
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP bad CRC: 0x%lx should be 0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zip
operator|->
name|entry_crc32
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|zip
operator|->
name|entry
operator|->
name|crc32
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|struct
name|zip_entry
modifier|*
name|zip_entry
decl_stmt|,
modifier|*
name|next_zip_entry
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
if|if
condition|(
name|zip
operator|->
name|stream_valid
condition|)
name|inflateEnd
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|uncompressed_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zip
operator|->
name|zip_entries
condition|)
block|{
name|zip_entry
operator|=
name|zip
operator|->
name|zip_entries
expr_stmt|;
while|while
condition|(
name|zip_entry
operator|!=
name|NULL
condition|)
block|{
name|next_zip_entry
operator|=
name|zip_entry
operator|->
name|next
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|zip_entry
operator|->
name|rsrcname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip_entry
argument_list|)
expr_stmt|;
name|zip_entry
operator|=
name|next_zip_entry
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|zip
operator|->
name|decrypted_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|cctx_valid
condition|)
name|archive_decrypto_aes_ctr_release
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
name|archive_hmac_sha1_cleanup
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|iv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|erd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
operator|->
name|v_data
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|zip
operator|->
name|format_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_has_encrypted_entries
parameter_list|(
name|struct
name|archive_read
modifier|*
name|_a
parameter_list|)
block|{
if|if
condition|(
name|_a
operator|&&
name|_a
operator|->
name|format
condition|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|_a
operator|->
name|format
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|zip
condition|)
block|{
return|return
name|zip
operator|->
name|has_encrypted_entries
return|;
block|}
block|}
return|return
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_options
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_FAILED
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"compat-2x"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Handle filenames as libarchive 2.x */
name|zip
operator|->
name|init_default_conversion
operator|=
operator|(
name|val
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"hdrcharset"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|val
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"zip: hdrcharset option needs a character-set name"
argument_list|)
expr_stmt|;
else|else
block|{
name|zip
operator|->
name|sconv
operator|=
name|archive_string_conversion_from_charset
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|sconv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
condition|)
name|zip
operator|->
name|sconv_utf8
operator|=
name|zip
operator|->
name|sconv
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"ignorecrc32"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Mostly useful for testing. */
if|if
condition|(
name|val
operator|==
name|NULL
operator|||
name|val
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|crc32func
operator|=
name|real_crc32
expr_stmt|;
name|zip
operator|->
name|ignore_crc32
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|zip
operator|->
name|crc32func
operator|=
name|fake_crc32
expr_stmt|;
name|zip
operator|->
name|ignore_crc32
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"mac-ext"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zip
operator|->
name|process_mac_extensions
operator|=
operator|(
name|val
operator|!=
name|NULL
operator|&&
name|val
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* Note: The "warn" return is just to inform the options 	 * supervisor that we didn't handle it.  It will generate 	 * a suitable error if no one used this option. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_read_support_format_zip
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_read_support_format_zip_streamable
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
name|r
return|;
return|return
operator|(
name|archive_read_support_format_zip_seekable
argument_list|(
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Streaming-mode support  */
end_comment

begin_function
specifier|static
name|int
name|archive_read_support_format_zip_capabilities_streamable
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA
operator||
name|ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_streamable_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|best_bid
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
operator|(
name|void
operator|)
name|best_bid
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Bid of 29 here comes from: 	 *  + 16 bits for "PK", 	 *  + next 16-bit field has 6 options so contributes 	 *    about 16 - log_2(6) ~= 16 - 2.6 ~= 13 bits 	 * 	 * So we've effectively verified ~29 total bits of check data. 	 */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
condition|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\001'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\002'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\003'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\004'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\005'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\006'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\006'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\006'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\010'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'0'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'0'
operator|)
condition|)
return|return
operator|(
literal|29
operator|)
return|;
block|}
comment|/* TODO: It's worth looking ahead a little bit for a valid 	 * PK signature.  In particular, that would make it possible 	 * to read some UUEncoded SFX files or SFX files coming from 	 * a network socket. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_streamable_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_ZIP
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|==
name|NULL
condition|)
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"ZIP"
expr_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* 	 * It should be sufficient to call archive_read_next_header() for 	 * a reader to determine if an entry is encrypted or not. If the 	 * encryption of an entry is only detectable when calling 	 * archive_read_data(), so be it. We'll do the same check there 	 * as well. 	 */
if|if
condition|(
name|zip
operator|->
name|has_encrypted_entries
operator|==
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
condition|)
name|zip
operator|->
name|has_encrypted_entries
operator|=
literal|0
expr_stmt|;
comment|/* Make sure we have a zip_entry structure to use. */
if|if
condition|(
name|zip
operator|->
name|zip_entries
operator|==
name|NULL
condition|)
block|{
name|zip
operator|->
name|zip_entries
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|zip_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|zip_entries
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out  of memory"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
block|}
name|zip
operator|->
name|entry
operator|=
name|zip
operator|->
name|zip_entries
expr_stmt|;
name|memset
argument_list|(
name|zip
operator|->
name|entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|zip_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|cctx_valid
condition|)
name|archive_decrypto_aes_ctr_release
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
name|archive_hmac_sha1_cleanup
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|)
expr_stmt|;
name|zip
operator|->
name|tctx_valid
operator|=
name|zip
operator|->
name|cctx_valid
operator|=
name|zip
operator|->
name|hctx_valid
operator|=
literal|0
expr_stmt|;
name|__archive_read_reset_passphrase
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Search ahead for the next local file header. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|unconsumed
argument_list|)
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int64_t
name|skipped
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|ssize_t
name|bytes
decl_stmt|;
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|end
operator|=
name|p
operator|+
name|bytes
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|4
operator|<=
name|end
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\003'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\004'
condition|)
block|{
comment|/* Regular file entry. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skipped
argument_list|)
expr_stmt|;
return|return
name|zip_read_local_file_header
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|zip
argument_list|)
return|;
block|}
comment|/*                                * TODO: We cannot restore permissions                                * based only on the local file headers.                                * Consider scanning the central                                * directory and returning additional                                * entries for at least directories.                                * This would allow us to properly set                                * directory permissions. 			       * 			       * This won't help us fix symlinks 			       * and may not help with regular file 			       * permissions, either.<sigh>                                */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\001'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\002'
condition|)
block|{
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
comment|/* End of central directory?  Must be an                                * empty archive. */
if|if
condition|(
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\005'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\006'
operator|)
operator|||
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\006'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'\006'
operator|)
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
operator|++
name|p
expr_stmt|;
operator|++
name|skipped
expr_stmt|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|skipped
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_read_data_skip_streamable
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|int64_t
name|bytes_skipped
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|bytes_skipped
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|unconsumed
argument_list|)
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* If we've already read to end of data, we're done. */
if|if
condition|(
name|zip
operator|->
name|end_of_entry
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* So we know we're streaming... */
if|if
condition|(
literal|0
operator|==
operator|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
operator|)
operator|||
name|zip
operator|->
name|entry
operator|->
name|compressed_size
operator|>
literal|0
condition|)
block|{
comment|/* We know the compressed length, so we can just skip. */
name|bytes_skipped
operator|=
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|zip
operator|->
name|init_decryption
condition|)
block|{
name|int
name|r
decl_stmt|;
name|zip
operator|->
name|has_encrypted_entries
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|zip_flags
operator|&
name|ZIP_STRONG_ENCRYPTED
condition|)
name|r
operator|=
name|read_decryption_header
argument_list|(
name|a
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|compression
operator|==
name|WINZIP_AES_ENCRYPTION
condition|)
name|r
operator|=
name|init_WinZip_AES_decryption
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|init_traditional_PKWARE_decryption
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|zip
operator|->
name|init_decryption
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We're streaming and we don't know the length. */
comment|/* If the body is compressed and we know the format, we can 	 * find an exact end-of-entry by decompressing it. */
switch|switch
condition|(
name|zip
operator|->
name|entry
operator|->
name|compression
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
case|case
literal|8
case|:
comment|/* Deflate compression. */
while|while
condition|(
operator|!
name|zip
operator|->
name|end_of_entry
condition|)
block|{
name|int64_t
name|offset
init|=
literal|0
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|zip_read_data_deflate
argument_list|(
name|a
argument_list|,
operator|&
name|buff
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
name|ARCHIVE_OK
return|;
endif|#
directive|endif
default|default:
comment|/* Uncompressed or unknown. */
comment|/* Scan for a PK\007\010 signature. */
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|buff
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|16
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_avail
operator|<
literal|16
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|p
operator|=
name|buff
expr_stmt|;
while|while
condition|(
name|p
operator|<=
name|buff
operator|+
name|bytes_avail
operator|-
literal|16
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'P'
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'K'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'\007'
condition|)
block|{
name|p
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'\010'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\007'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
condition|)
block|{
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|flags
operator|&
name|LA_USED_ZIP64
condition|)
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|p
operator|-
name|buff
operator|+
literal|24
argument_list|)
expr_stmt|;
else|else
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|p
operator|-
name|buff
operator|+
literal|16
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_OK
return|;
block|}
else|else
block|{
name|p
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|p
operator|-
name|buff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|archive_read_support_format_zip_streamable
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_zip"
argument_list|)
expr_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate zip data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Streamable reader doesn't support mac extensions. */
name|zip
operator|->
name|process_mac_extensions
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Until enough data has been read, we cannot tell about 	 * any encrypted entries yet. 	 */
name|zip
operator|->
name|has_encrypted_entries
operator|=
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
expr_stmt|;
name|zip
operator|->
name|crc32func
operator|=
name|real_crc32
expr_stmt|;
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|zip
argument_list|,
literal|"zip"
argument_list|,
name|archive_read_format_zip_streamable_bid
argument_list|,
name|archive_read_format_zip_options
argument_list|,
name|archive_read_format_zip_streamable_read_header
argument_list|,
name|archive_read_format_zip_read_data
argument_list|,
name|archive_read_format_zip_read_data_skip_streamable
argument_list|,
name|NULL
argument_list|,
name|archive_read_format_zip_cleanup
argument_list|,
name|archive_read_support_format_zip_capabilities_streamable
argument_list|,
name|archive_read_format_zip_has_encrypted_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Seeking-mode support  */
end_comment

begin_function
specifier|static
name|int
name|archive_read_support_format_zip_capabilities_seekable
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA
operator||
name|ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: This is a performance sink because it forces the read core to  * drop buffered data from the start of file, which will then have to  * be re-read again if this bidder loses.  *  * We workaround this a little by passing in the best bid so far so  * that later bidders can do nothing if they know they'll never  * outbid.  But we can certainly do better...  */
end_comment

begin_function
specifier|static
name|int
name|read_eocd
parameter_list|(
name|struct
name|zip
modifier|*
name|zip
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int64_t
name|current_offset
parameter_list|)
block|{
comment|/* Sanity-check the EOCD we've found. */
comment|/* This must be the first volume. */
if|if
condition|(
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Central directory must be on this volume. */
if|if
condition|(
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
operator|!=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|6
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* All central directory entries must be on this volume. */
if|if
condition|(
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|10
argument_list|)
operator|!=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Central directory can't extend beyond start of EOCD record. */
if|if
condition|(
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|16
argument_list|)
operator|+
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|12
argument_list|)
operator|>
name|current_offset
condition|)
return|return
literal|0
return|;
comment|/* Save the central directory location for later use. */
name|zip
operator|->
name|central_directory_offset
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|16
argument_list|)
expr_stmt|;
comment|/* This is just a tiny bit higher than the maximum 	   returned by the streaming Zip bidder.  This ensures 	   that the more accurate seeking Zip parser wins 	   whenever seek is available. */
return|return
literal|32
return|;
block|}
end_function

begin_comment
comment|/*  * Examine Zip64 EOCD locator:  If it's valid, store the information  * from it.  */
end_comment

begin_function
specifier|static
name|int
name|read_zip64_eocd
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int64_t
name|eocd64_offset
decl_stmt|;
name|int64_t
name|eocd64_size
decl_stmt|;
comment|/* Sanity-check the locator record. */
comment|/* Central dir must be on first volume. */
if|if
condition|(
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Must be only a single volume. */
if|if
condition|(
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|16
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Find the Zip64 EOCD record. */
name|eocd64_offset
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|eocd64_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|56
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Make sure we can read all of it. */
name|eocd64_size
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
literal|4
argument_list|)
operator|+
literal|12
expr_stmt|;
if|if
condition|(
name|eocd64_size
operator|<
literal|56
operator|||
name|eocd64_size
operator|>
literal|16384
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|eocd64_size
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Sanity-check the EOCD64 */
if|if
condition|(
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|16
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Must be disk #0 */
return|return
literal|0
return|;
if|if
condition|(
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|20
argument_list|)
operator|!=
literal|0
condition|)
comment|/* CD must be on disk #0 */
return|return
literal|0
return|;
comment|/* CD can't be split. */
if|if
condition|(
name|archive_le64dec
argument_list|(
name|p
operator|+
literal|24
argument_list|)
operator|!=
name|archive_le64dec
argument_list|(
name|p
operator|+
literal|32
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Save the central directory offset for later use. */
name|zip
operator|->
name|central_directory_offset
operator|=
name|archive_le64dec
argument_list|(
name|p
operator|+
literal|48
argument_list|)
expr_stmt|;
return|return
literal|32
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_seekable_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|best_bid
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|int64_t
name|file_size
decl_stmt|,
name|current_offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tail
decl_stmt|;
comment|/* If someone has already bid more than 32, then avoid 	   trashing the look-ahead buffers with a seek. */
if|if
condition|(
name|best_bid
operator|>
literal|32
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|file_size
operator|=
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_size
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Search last 16k of file for end-of-central-directory 	 * record (which starts with PK\005\006) */
name|tail
operator|=
operator|(
name|int
operator|)
name|zipmin
argument_list|(
literal|1024
operator|*
literal|16
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
name|current_offset
operator|=
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
operator|-
name|tail
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_offset
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
operator|(
name|size_t
operator|)
name|tail
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Boyer-Moore search backwards from the end, since we want 	 * to match the last EOCD in the file (there can be more than 	 * one if there is an uncompressed Zip archive as a member 	 * within this Zip archive). */
for|for
control|(
name|i
operator|=
name|tail
operator|-
literal|22
init|;
name|i
operator|>
literal|0
condition|;
control|)
block|{
switch|switch
condition|(
name|p
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'P'
case|:
if|if
condition|(
name|memcmp
argument_list|(
name|p
operator|+
name|i
argument_list|,
literal|"PK\005\006"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|ret
init|=
name|read_eocd
argument_list|(
name|zip
argument_list|,
name|p
operator|+
name|i
argument_list|,
name|current_offset
operator|+
name|i
argument_list|)
decl_stmt|;
comment|/* Zip64 EOCD locator precedes 				 * regular EOCD if present. */
if|if
condition|(
name|i
operator|>=
literal|20
operator|&&
name|memcmp
argument_list|(
name|p
operator|+
name|i
operator|-
literal|20
argument_list|,
literal|"PK\006\007"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|ret_zip64
init|=
name|read_zip64_eocd
argument_list|(
name|a
argument_list|,
name|zip
argument_list|,
name|p
operator|+
name|i
operator|-
literal|20
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret_zip64
operator|>
name|ret
condition|)
name|ret
operator|=
name|ret_zip64
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|i
operator|-=
literal|4
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|i
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
literal|005
case|:
name|i
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|006
case|:
name|i
operator|-=
literal|3
expr_stmt|;
break|break;
default|default:
name|i
operator|-=
literal|4
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The red-black trees are only used in seeking mode to manage  * the in-memory copy of the central directory. */
end_comment

begin_function
specifier|static
name|int
name|cmp_node
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n1
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|zip_entry
modifier|*
name|e1
init|=
operator|(
specifier|const
expr|struct
name|zip_entry
operator|*
operator|)
name|n1
decl_stmt|;
specifier|const
name|struct
name|zip_entry
modifier|*
name|e2
init|=
operator|(
specifier|const
expr|struct
name|zip_entry
operator|*
operator|)
name|n2
decl_stmt|;
if|if
condition|(
name|e1
operator|->
name|local_header_offset
operator|>
name|e2
operator|->
name|local_header_offset
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|e1
operator|->
name|local_header_offset
operator|<
name|e2
operator|->
name|local_header_offset
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmp_key
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
comment|/* This function won't be called */
operator|(
name|void
operator|)
name|n
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|key
expr_stmt|;
comment|/* UNUSED */
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|archive_rb_tree_ops
name|rb_ops
init|=
block|{
operator|&
name|cmp_node
block|,
operator|&
name|cmp_key
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|rsrc_cmp_node
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n1
parameter_list|,
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|struct
name|zip_entry
modifier|*
name|e1
init|=
operator|(
specifier|const
expr|struct
name|zip_entry
operator|*
operator|)
name|n1
decl_stmt|;
specifier|const
name|struct
name|zip_entry
modifier|*
name|e2
init|=
operator|(
specifier|const
expr|struct
name|zip_entry
operator|*
operator|)
name|n2
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|e2
operator|->
name|rsrcname
operator|.
name|s
argument_list|,
name|e1
operator|->
name|rsrcname
operator|.
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rsrc_cmp_key
parameter_list|(
specifier|const
name|struct
name|archive_rb_node
modifier|*
name|n
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|struct
name|zip_entry
modifier|*
name|e
init|=
operator|(
specifier|const
expr|struct
name|zip_entry
operator|*
operator|)
name|n
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|,
name|e
operator|->
name|rsrcname
operator|.
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|archive_rb_tree_ops
name|rb_rsrc_ops
init|=
block|{
operator|&
name|rsrc_cmp_node
block|,
operator|&
name|rsrc_cmp_key
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rsrc_basename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|name_length
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|s
operator|=
name|name
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|memchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|,
name|name_length
operator|-
operator|(
name|s
operator|-
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
break|break;
name|r
operator|=
operator|++
name|s
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|expose_parent_dirs
parameter_list|(
name|struct
name|zip
modifier|*
name|zip
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|name_length
parameter_list|)
block|{
name|struct
name|archive_string
name|str
decl_stmt|;
name|struct
name|zip_entry
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
name|str
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|strrchr
argument_list|(
name|str
operator|.
name|s
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
break|break;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
comment|/* Transfer the parent directory from zip->tree_rsrc RB 		 * tree to zip->tree RB tree to expose. */
name|dir
operator|=
operator|(
expr|struct
name|zip_entry
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
name|zip
operator|->
name|tree_rsrc
argument_list|,
name|str
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
break|break;
name|__archive_rb_tree_remove_node
argument_list|(
operator|&
name|zip
operator|->
name|tree_rsrc
argument_list|,
operator|&
name|dir
operator|->
name|node
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|dir
operator|->
name|rsrcname
argument_list|)
expr_stmt|;
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|,
operator|&
name|dir
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_central_directory
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|zip
modifier|*
name|zip
parameter_list|)
block|{
name|ssize_t
name|i
decl_stmt|;
name|unsigned
name|found
decl_stmt|;
name|int64_t
name|correction
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Find the start of the central directory.  The end-of-CD 	 * record has our starting point, but there are lots of 	 * Zip archives which have had other data prepended to the 	 * file, which makes the recorded offsets all too small. 	 * So we search forward from the specified offset until we 	 * find the real start of the central directory.  Then we 	 * know the correction we need to apply to account for leading 	 * padding. 	 */
if|if
condition|(
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|central_directory_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ARCHIVE_FATAL
return|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|20
argument_list|,
operator|&
name|bytes_avail
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ARCHIVE_FATAL
return|;
for|for
control|(
name|found
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|i
operator|<
name|bytes_avail
operator|-
literal|4
condition|;
control|)
block|{
switch|switch
condition|(
name|p
index|[
name|i
operator|+
literal|3
index|]
condition|)
block|{
case|case
literal|'P'
case|:
name|i
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|001
case|:
name|i
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|002
case|:
if|if
condition|(
name|memcmp
argument_list|(
name|p
operator|+
name|i
argument_list|,
literal|"PK\001\002"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
name|i
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|i
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|005
case|:
name|i
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|006
case|:
if|if
condition|(
name|memcmp
argument_list|(
name|p
operator|+
name|i
argument_list|,
literal|"PK\005\006"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
name|i
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|p
operator|+
name|i
argument_list|,
literal|"PK\006\006"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
name|i
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|i
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
name|i
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|correction
operator|=
name|archive_filter_bytes
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|0
argument_list|)
operator|-
name|zip
operator|->
name|central_directory_offset
expr_stmt|;
name|__archive_rb_tree_init
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|,
operator|&
name|rb_ops
argument_list|)
expr_stmt|;
name|__archive_rb_tree_init
argument_list|(
operator|&
name|zip
operator|->
name|tree_rsrc
argument_list|,
operator|&
name|rb_rsrc_ops
argument_list|)
expr_stmt|;
name|zip
operator|->
name|central_directory_entries_total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|zip_entry
modifier|*
name|zip_entry
decl_stmt|;
name|size_t
name|filename_length
decl_stmt|,
name|extra_length
decl_stmt|,
name|comment_length
decl_stmt|;
name|uint32_t
name|external_attributes
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ARCHIVE_FATAL
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"PK\006\006"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"PK\005\006"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"PK\001\002"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Invalid central directory signature"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|46
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ARCHIVE_FATAL
return|;
name|zip_entry
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|zip_entry
argument_list|)
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|next
operator|=
name|zip
operator|->
name|zip_entries
expr_stmt|;
name|zip_entry
operator|->
name|flags
operator||=
name|LA_FROM_CENTRAL_DIRECTORY
expr_stmt|;
name|zip
operator|->
name|zip_entries
operator|=
name|zip_entry
expr_stmt|;
name|zip
operator|->
name|central_directory_entries_total
operator|++
expr_stmt|;
comment|/* version = p[4]; */
name|zip_entry
operator|->
name|system
operator|=
name|p
index|[
literal|5
index|]
expr_stmt|;
comment|/* version_required = archive_le16dec(p + 6); */
name|zip_entry
operator|->
name|zip_flags
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|zip_flags
operator|&
operator|(
name|ZIP_ENCRYPTED
operator||
name|ZIP_STRONG_ENCRYPTED
operator|)
condition|)
block|{
name|zip
operator|->
name|has_encrypted_entries
operator|=
literal|1
expr_stmt|;
block|}
name|zip_entry
operator|->
name|compression
operator|=
operator|(
name|char
operator|)
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|10
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|mtime
operator|=
name|zip_time
argument_list|(
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|crc32
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip_entry
operator|->
name|zip_flags
operator|&
name|ZIP_LENGTH_AT_END
condition|)
name|zip_entry
operator|->
name|decdat
operator|=
name|p
index|[
literal|13
index|]
expr_stmt|;
else|else
name|zip_entry
operator|->
name|decdat
operator|=
name|p
index|[
literal|19
index|]
expr_stmt|;
name|zip_entry
operator|->
name|compressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|20
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|uncompressed_size
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|24
argument_list|)
expr_stmt|;
name|filename_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|28
argument_list|)
expr_stmt|;
name|extra_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|30
argument_list|)
expr_stmt|;
name|comment_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* disk_start = archive_le16dec(p + 34); */
comment|/* Better be zero. */
comment|/* internal_attributes = archive_le16dec(p + 36); */
comment|/* text bit */
name|external_attributes
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|38
argument_list|)
expr_stmt|;
name|zip_entry
operator|->
name|local_header_offset
operator|=
name|archive_le32dec
argument_list|(
name|p
operator|+
literal|42
argument_list|)
operator|+
name|correction
expr_stmt|;
comment|/* If we can't guess the mode, leave it zero here; 		   when we read the local file header we might get 		   more information. */
if|if
condition|(
name|zip_entry
operator|->
name|system
operator|==
literal|3
condition|)
block|{
name|zip_entry
operator|->
name|mode
operator|=
name|external_attributes
operator|>>
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip_entry
operator|->
name|system
operator|==
literal|0
condition|)
block|{
comment|// Interpret MSDOS directory bit
if|if
condition|(
literal|0x10
operator|==
operator|(
name|external_attributes
operator|&
literal|0x10
operator|)
condition|)
block|{
name|zip_entry
operator|->
name|mode
operator|=
name|AE_IFDIR
operator||
literal|0775
expr_stmt|;
block|}
else|else
block|{
name|zip_entry
operator|->
name|mode
operator|=
name|AE_IFREG
operator||
literal|0664
expr_stmt|;
block|}
if|if
condition|(
literal|0x01
operator|==
operator|(
name|external_attributes
operator|&
literal|0x01
operator|)
condition|)
block|{
comment|// Read-only bit; strip write permissions
name|zip_entry
operator|->
name|mode
operator|&=
literal|0555
expr_stmt|;
block|}
block|}
else|else
block|{
name|zip_entry
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We're done with the regular data; get the filename and 		 * extra data. */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|46
argument_list|)
expr_stmt|;
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|filename_length
operator|+
name|extra_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_FATAL
return|;
block|}
if|if
condition|(
name|ARCHIVE_OK
operator|!=
name|process_extra
argument_list|(
name|a
argument_list|,
name|p
operator|+
name|filename_length
argument_list|,
name|extra_length
argument_list|,
name|zip_entry
argument_list|)
condition|)
block|{
return|return
name|ARCHIVE_FATAL
return|;
block|}
comment|/* 		 * Mac resource fork files are stored under the 		 * "__MACOSX/" directory, so we should check if 		 * it is. 		 */
if|if
condition|(
operator|!
name|zip
operator|->
name|process_mac_extensions
condition|)
block|{
comment|/* Treat every entry as a regular entry. */
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|,
operator|&
name|zip_entry
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|p
expr_stmt|;
name|r
operator|=
name|rsrc_basename
argument_list|(
name|name
argument_list|,
name|filename_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename_length
operator|>=
literal|9
operator|&&
name|strncmp
argument_list|(
literal|"__MACOSX/"
argument_list|,
name|name
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If this file is not a resource fork nor 				 * a directory. We should treat it as a non 				 * resource fork file to expose it. */
if|if
condition|(
name|name
index|[
name|filename_length
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
operator|(
name|r
operator|-
name|name
operator|<
literal|3
operator|||
name|r
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|r
index|[
literal|1
index|]
operator|!=
literal|'_'
operator|)
condition|)
block|{
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|,
operator|&
name|zip_entry
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* Expose its parent directories. */
name|expose_parent_dirs
argument_list|(
name|zip
argument_list|,
name|name
argument_list|,
name|filename_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This file is a resource fork file or 					 * a directory. */
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|zip_entry
operator|->
name|rsrcname
operator|)
argument_list|,
name|name
argument_list|,
name|filename_length
argument_list|)
expr_stmt|;
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
name|zip
operator|->
name|tree_rsrc
argument_list|,
operator|&
name|zip_entry
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Generate resource fork name to find its 				 * resource file at zip->tree_rsrc. */
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|zip_entry
operator|->
name|rsrcname
operator|)
argument_list|,
literal|"__MACOSX/"
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
operator|(
name|zip_entry
operator|->
name|rsrcname
operator|)
argument_list|,
name|name
argument_list|,
name|r
operator|-
name|name
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
operator|(
name|zip_entry
operator|->
name|rsrcname
operator|)
argument_list|,
literal|"._"
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
operator|(
name|zip_entry
operator|->
name|rsrcname
operator|)
argument_list|,
name|name
operator|+
operator|(
name|r
operator|-
name|name
operator|)
argument_list|,
name|filename_length
operator|-
operator|(
name|r
operator|-
name|name
operator|)
argument_list|)
expr_stmt|;
comment|/* Register an entry to RB tree to sort it by 				 * file offset. */
name|__archive_rb_tree_insert_node
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|,
operator|&
name|zip_entry
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Skip the comment too ... */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|filename_length
operator|+
name|extra_length
operator|+
name|comment_length
argument_list|)
expr_stmt|;
block|}
return|return
name|ARCHIVE_OK
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|zip_get_local_file_header_size
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|size_t
name|extra
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|filename_length
decl_stmt|,
name|extra_length
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|extra
operator|+
literal|30
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|p
operator|+=
name|extra
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"PK\003\004"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Damaged Zip archive"
argument_list|)
expr_stmt|;
return|return
name|ARCHIVE_WARN
return|;
block|}
name|filename_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|26
argument_list|)
expr_stmt|;
name|extra_length
operator|=
name|archive_le16dec
argument_list|(
name|p
operator|+
literal|28
argument_list|)
expr_stmt|;
return|return
operator|(
literal|30
operator|+
name|filename_length
operator|+
name|extra_length
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zip_read_mac_metadata
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|zip_entry
modifier|*
name|rsrc
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|unsigned
name|char
modifier|*
name|metadata
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|int64_t
name|offset
init|=
name|archive_filter_bytes
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|remaining_bytes
decl_stmt|,
name|metadata_bytes
decl_stmt|;
name|ssize_t
name|hsize
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|,
name|eof
decl_stmt|;
switch|switch
condition|(
name|rsrc
operator|->
name|compression
condition|)
block|{
case|case
literal|0
case|:
comment|/* No compression. */
if|if
condition|(
name|rsrc
operator|->
name|uncompressed_size
operator|!=
name|rsrc
operator|->
name|compressed_size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Malformed OS X metadata entry: inconsistent size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
case|case
literal|8
case|:
comment|/* Deflate compression. */
endif|#
directive|endif
break|break;
default|default:
comment|/* Unsupported compression. */
comment|/* Return a warning. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Unsupported ZIP compression method (%s)"
argument_list|,
name|compression_name
argument_list|(
name|rsrc
operator|->
name|compression
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't decompress this entry, but we will 		 * be able to skip() it and try the next entry. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|if
condition|(
name|rsrc
operator|->
name|uncompressed_size
operator|>
operator|(
literal|4
operator|*
literal|1024
operator|*
literal|1024
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Mac metadata is too large: %jd> 4M bytes"
argument_list|,
operator|(
name|intmax_t
operator|)
name|rsrc
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|if
condition|(
name|rsrc
operator|->
name|compressed_size
operator|>
operator|(
literal|4
operator|*
literal|1024
operator|*
literal|1024
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Mac metadata is too large: %jd> 4M bytes"
argument_list|,
operator|(
name|intmax_t
operator|)
name|rsrc
operator|->
name|compressed_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|metadata
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|rsrc
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadata
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate memory for Mac metadata"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|offset
operator|<
name|rsrc
operator|->
name|local_header_offset
condition|)
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|rsrc
operator|->
name|local_header_offset
operator|-
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|!=
name|rsrc
operator|->
name|local_header_offset
condition|)
block|{
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|rsrc
operator|->
name|local_header_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
name|hsize
operator|=
name|zip_get_local_file_header_size
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|remaining_bytes
operator|=
operator|(
name|size_t
operator|)
name|rsrc
operator|->
name|compressed_size
expr_stmt|;
name|metadata_bytes
operator|=
operator|(
name|size_t
operator|)
name|rsrc
operator|->
name|uncompressed_size
expr_stmt|;
name|mp
operator|=
name|metadata
expr_stmt|;
name|eof
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|eof
operator|&&
name|remaining_bytes
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|bytes_avail
decl_stmt|;
name|size_t
name|bytes_used
decl_stmt|;
name|p
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated ZIP file header"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|exit_mac_metadata
goto|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|bytes_avail
operator|>
name|remaining_bytes
condition|)
name|bytes_avail
operator|=
name|remaining_bytes
expr_stmt|;
switch|switch
condition|(
name|rsrc
operator|->
name|compression
condition|)
block|{
case|case
literal|0
case|:
comment|/* No compression. */
if|if
condition|(
operator|(
name|size_t
operator|)
name|bytes_avail
operator|>
name|metadata_bytes
condition|)
name|bytes_avail
operator|=
name|metadata_bytes
expr_stmt|;
name|memcpy
argument_list|(
name|mp
argument_list|,
name|p
argument_list|,
name|bytes_avail
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
operator|(
name|size_t
operator|)
name|bytes_avail
expr_stmt|;
name|metadata_bytes
operator|-=
name|bytes_used
expr_stmt|;
name|mp
operator|+=
name|bytes_used
expr_stmt|;
if|if
condition|(
name|metadata_bytes
operator|==
literal|0
condition|)
name|eof
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_ZLIB_H
case|case
literal|8
case|:
comment|/* Deflate compression. */
block|{
name|int
name|r
decl_stmt|;
name|ret
operator|=
name|zip_deflate_init
argument_list|(
name|a
argument_list|,
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
goto|goto
name|exit_mac_metadata
goto|;
name|zip
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|const
name|void
operator|*
operator|)
name|p
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|bytes_avail
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_in
operator|=
literal|0
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|next_out
operator|=
name|mp
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|metadata_bytes
expr_stmt|;
name|zip
operator|->
name|stream
operator|.
name|total_out
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|inflate
argument_list|(
operator|&
name|zip
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|Z_OK
case|:
break|break;
case|case
name|Z_STREAM_END
case|:
name|eof
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Z_MEM_ERROR
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Out of memory for ZIP decompression"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
goto|goto
name|exit_mac_metadata
goto|;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"ZIP decompression failed (%d)"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_FATAL
expr_stmt|;
goto|goto
name|exit_mac_metadata
goto|;
block|}
name|bytes_used
operator|=
name|zip
operator|->
name|stream
operator|.
name|total_in
expr_stmt|;
name|metadata_bytes
operator|-=
name|zip
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
name|mp
operator|+=
name|zip
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|bytes_used
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|remaining_bytes
operator|-=
name|bytes_used
expr_stmt|;
block|}
name|archive_entry_copy_mac_metadata
argument_list|(
name|entry
argument_list|,
name|metadata
argument_list|,
operator|(
name|size_t
operator|)
name|rsrc
operator|->
name|uncompressed_size
operator|-
name|metadata_bytes
argument_list|)
expr_stmt|;
name|exit_mac_metadata
label|:
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|zip
operator|->
name|decompress_init
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_zip_seekable_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
init|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|struct
name|zip_entry
modifier|*
name|rsrc
decl_stmt|;
name|int64_t
name|offset
decl_stmt|;
name|int
name|r
decl_stmt|,
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
comment|/* 	 * It should be sufficient to call archive_read_next_header() for 	 * a reader to determine if an entry is encrypted or not. If the 	 * encryption of an entry is only detectable when calling 	 * archive_read_data(), so be it. We'll do the same check there 	 * as well. 	 */
if|if
condition|(
name|zip
operator|->
name|has_encrypted_entries
operator|==
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
condition|)
name|zip
operator|->
name|has_encrypted_entries
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_ZIP
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|==
name|NULL
condition|)
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"ZIP"
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|zip_entries
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|slurp_central_directory
argument_list|(
name|a
argument_list|,
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
name|r
return|;
comment|/* Get first entry whose local header offset is lower than 		 * other entries in the archive file. */
name|zip
operator|->
name|entry
operator|=
operator|(
expr|struct
name|zip_entry
operator|*
operator|)
name|ARCHIVE_RB_TREE_MIN
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zip
operator|->
name|entry
operator|!=
name|NULL
condition|)
block|{
comment|/* Get next entry in local header offset order. */
name|zip
operator|->
name|entry
operator|=
operator|(
expr|struct
name|zip_entry
operator|*
operator|)
name|__archive_rb_tree_iterate
argument_list|(
operator|&
name|zip
operator|->
name|tree
argument_list|,
operator|&
name|zip
operator|->
name|entry
operator|->
name|node
argument_list|,
name|ARCHIVE_RB_DIR_RIGHT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zip
operator|->
name|entry
operator|==
name|NULL
condition|)
return|return
name|ARCHIVE_EOF
return|;
if|if
condition|(
name|zip
operator|->
name|entry
operator|->
name|rsrcname
operator|.
name|s
condition|)
name|rsrc
operator|=
operator|(
expr|struct
name|zip_entry
operator|*
operator|)
name|__archive_rb_tree_find_node
argument_list|(
operator|&
name|zip
operator|->
name|tree_rsrc
argument_list|,
name|zip
operator|->
name|entry
operator|->
name|rsrcname
operator|.
name|s
argument_list|)
expr_stmt|;
else|else
name|rsrc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|cctx_valid
condition|)
name|archive_decrypto_aes_ctr_release
argument_list|(
operator|&
name|zip
operator|->
name|cctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|->
name|hctx_valid
condition|)
name|archive_hmac_sha1_cleanup
argument_list|(
operator|&
name|zip
operator|->
name|hctx
argument_list|)
expr_stmt|;
name|zip
operator|->
name|tctx_valid
operator|=
name|zip
operator|->
name|cctx_valid
operator|=
name|zip
operator|->
name|hctx_valid
operator|=
literal|0
expr_stmt|;
name|__archive_read_reset_passphrase
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* File entries are sorted by the header offset, we should mostly 	 * use __archive_read_consume to advance a read point to avoid redundant 	 * data reading.  */
name|offset
operator|=
name|archive_filter_bytes
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|zip
operator|->
name|entry
operator|->
name|local_header_offset
condition|)
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|entry
operator|->
name|local_header_offset
operator|-
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|!=
name|zip
operator|->
name|entry
operator|->
name|local_header_offset
condition|)
block|{
name|__archive_read_seek
argument_list|(
name|a
argument_list|,
name|zip
operator|->
name|entry
operator|->
name|local_header_offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
name|zip
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|zip_read_local_file_header
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|zip
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
name|r
return|;
if|if
condition|(
name|rsrc
condition|)
block|{
name|int
name|ret2
init|=
name|zip_read_mac_metadata
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|rsrc
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret2
operator|<
name|ret
condition|)
name|ret
operator|=
name|ret2
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We're going to seek for the next header anyway, so we don't  * need to bother doing anything here.  */
end_comment

begin_function
specifier|static
name|int
name|archive_read_format_zip_read_data_skip_seekable
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|zip
operator|->
name|unconsumed
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_read_support_format_zip_seekable
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|zip
modifier|*
name|zip
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_zip_seekable"
argument_list|)
expr_stmt|;
name|zip
operator|=
operator|(
expr|struct
name|zip
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zip
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate zip data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAVE_COPYFILE_H
comment|/* Set this by default on Mac OS. */
name|zip
operator|->
name|process_mac_extensions
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Until enough data has been read, we cannot tell about 	 * any encrypted entries yet. 	 */
name|zip
operator|->
name|has_encrypted_entries
operator|=
name|ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW
expr_stmt|;
name|zip
operator|->
name|crc32func
operator|=
name|real_crc32
expr_stmt|;
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|zip
argument_list|,
literal|"zip"
argument_list|,
name|archive_read_format_zip_seekable_bid
argument_list|,
name|archive_read_format_zip_options
argument_list|,
name|archive_read_format_zip_seekable_read_header
argument_list|,
name|archive_read_format_zip_read_data
argument_list|,
name|archive_read_format_zip_read_data_skip_seekable
argument_list|,
name|NULL
argument_list|,
name|archive_read_format_zip_cleanup
argument_list|,
name|archive_read_support_format_zip_capabilities_seekable
argument_list|,
name|archive_read_format_zip_has_encrypted_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|zip
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

end_unit

