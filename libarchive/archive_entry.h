begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2008 Tim Kientzle  * Copyright (c) 2016 Martin Matuska  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD: head/lib/libarchive/archive_entry.h 201096 2009-12-28 02:41:27Z kientzle $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARCHIVE_ENTRY_H_INCLUDED
end_ifndef

begin_define
define|#
directive|define
name|ARCHIVE_ENTRY_H_INCLUDED
end_define

begin_comment
comment|/* Note: Compiler will complain if this does not match archive.h! */
end_comment

begin_define
define|#
directive|define
name|ARCHIVE_VERSION_NUMBER
value|3003003
end_define

begin_comment
comment|/*  * Note: archive_entry.h is for use outside of libarchive; the  * configuration headers (config.h, archive_platform.h, etc.) are  * purely internal.  Do NOT use HAVE_XXX configuration macros to  * control the behavior of this header!  If you must conditionalize,  * use predefined compiler and/or platform macros.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* for wchar_t */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get a suitable 64-bit integer type. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__LA_INT64_T_DEFINED
argument_list|)
end_if

begin_if
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|4000000
end_if

begin_define
define|#
directive|define
name|__LA_INT64_T
value|la_int64_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|__LA_INT64_T_DEFINED
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__WATCOMC__
argument_list|)
end_if

begin_typedef
typedef|typedef
name|__int64
name|la_int64_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_SCO_DS
argument_list|)
operator|||
name|defined
argument_list|(
name|__osf__
argument_list|)
end_if

begin_typedef
typedef|typedef
name|long
name|long
name|la_int64_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int64_t
name|la_int64_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The la_ssize_t should match the type used in 'struct stat' */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__LA_SSIZE_T_DEFINED
argument_list|)
end_if

begin_comment
comment|/* Older code relied on the __LA_SSIZE_T macro; after 4.0 we'll switch to the typedef exclusively. */
end_comment

begin_if
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|<
literal|4000000
end_if

begin_define
define|#
directive|define
name|__LA_SSIZE_T
value|la_ssize_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|__LA_SSIZE_T_DEFINED
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__WATCOMC__
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_SSIZE_T_DEFINED
argument_list|)
operator|||
name|defined
argument_list|(
name|_SSIZE_T_
argument_list|)
end_if

begin_typedef
typedef|typedef
name|ssize_t
name|la_ssize_t
typedef|;
end_typedef

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN64
argument_list|)
end_elif

begin_typedef
typedef|typedef
name|__int64
name|la_ssize_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|long
name|la_ssize_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* ssize_t */
end_comment

begin_typedef
typedef|typedef
name|ssize_t
name|la_ssize_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get a suitable definition for mode_t */
end_comment

begin_if
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|>=
literal|3999000
end_if

begin_comment
comment|/* Switch to plain 'int' for libarchive 4.0.  It's less broken than 'mode_t' */
end_comment

begin_define
define|#
directive|define
name|__LA_MODE_T
value|int
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__WATCOMC__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|__LA_MODE_T
value|unsigned short
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LA_MODE_T
value|mode_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Large file support for Android */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__ANDROID__
end_ifdef

begin_include
include|#
directive|include
file|"android_lf.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * On Windows, define LIBARCHIVE_STATIC if you're building or using a  * .lib.  The default here assumes you're building a DLL.  Only  * libarchive source should ever define __LIBARCHIVE_BUILD.  */
end_comment

begin_if
if|#
directive|if
operator|(
operator|(
name|defined
name|__WIN32__
operator|)
operator|||
operator|(
name|defined
name|_WIN32
operator|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|defined
name|LIBARCHIVE_STATIC
operator|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__LIBARCHIVE_BUILD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|__LA_DECL
value|__attribute__((dllexport)) extern
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LA_DECL
value|__declspec(dllexport)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|__LA_DECL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LA_DECL
value|__declspec(dllimport)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Static libraries on all platforms and shared libraries on non-Windows. */
end_comment

begin_define
define|#
directive|define
name|__LA_DECL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|3
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|1
end_if

begin_define
define|#
directive|define
name|__LA_DEPRECATED
value|__attribute__((deprecated))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LA_DEPRECATED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * Description of an archive entry.  *  * You can think of this as "struct stat" with some text fields added in.  *  * TODO: Add "comment", "charset", and possibly other entries that are  * supported by "pax interchange" format.  However, GNU, ustar, cpio,  * and other variants don't support these features, so they're not an  * excruciatingly high priority right now.  *  * TODO: "pax interchange" format allows essentially arbitrary  * key/value attributes to be attached to any entry.  Supporting  * such extensions may make this library useful for special  * applications (e.g., a package manager could attach special  * package-management attributes to each entry).  */
struct_decl|struct
name|archive
struct_decl|;
struct_decl|struct
name|archive_entry
struct_decl|;
comment|/*  * File-type constants.  These are returned from archive_entry_filetype()  * and passed to archive_entry_set_filetype().  *  * These values match S_XXX defines on every platform I've checked,  * including Windows, AIX, Linux, Solaris, and BSD.  They're  * (re)defined here because platforms generally don't define the ones  * they don't support.  For example, Windows doesn't define S_IFLNK or  * S_IFBLK.  Instead of having a mass of conditional logic and system  * checks to define any S_XXX values that aren't supported locally,  * I've just defined a new set of such constants so that  * libarchive-based applications can manipulate and identify archive  * entries properly even if the hosting platform can't store them on  * disk.  *  * These values are also used directly within some portable formats,  * such as cpio.  If you find a platform that varies from these, the  * correct solution is to leave these alone and translate from these  * portable values to platform-native values when entries are read from  * or written to disk.  */
comment|/*  * In libarchive 4.0, we can drop the casts here.  * They're needed to work around Borland C's broken mode_t.  */
define|#
directive|define
name|AE_IFMT
value|((__LA_MODE_T)0170000)
define|#
directive|define
name|AE_IFREG
value|((__LA_MODE_T)0100000)
define|#
directive|define
name|AE_IFLNK
value|((__LA_MODE_T)0120000)
define|#
directive|define
name|AE_IFSOCK
value|((__LA_MODE_T)0140000)
define|#
directive|define
name|AE_IFCHR
value|((__LA_MODE_T)0020000)
define|#
directive|define
name|AE_IFBLK
value|((__LA_MODE_T)0060000)
define|#
directive|define
name|AE_IFDIR
value|((__LA_MODE_T)0040000)
define|#
directive|define
name|AE_IFIFO
value|((__LA_MODE_T)0010000)
comment|/*  * Basic object manipulation  */
name|__LA_DECL
name|struct
name|archive_entry
modifier|*
name|archive_entry_clear
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
comment|/* The 'clone' function does a deep copy; all of the strings are copied too. */
name|__LA_DECL
name|struct
name|archive_entry
modifier|*
name|archive_entry_clone
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_free
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|struct
name|archive_entry
modifier|*
name|archive_entry_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * This form of archive_entry_new2() will pull character-set  * conversion information from the specified archive handle.  The  * older archive_entry_new(void) form is equivalent to calling  * archive_entry_new2(NULL) and will result in the use of an internal  * default character-set conversion.  */
name|__LA_DECL
name|struct
name|archive_entry
modifier|*
name|archive_entry_new2
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Retrieve fields from an archive_entry.  *  * There are a number of implicit conversions among these fields.  For  * example, if a regular string field is set and you read the _w wide  * character field, the entry will implicitly convert narrow-to-wide  * using the current locale.  Similarly, dev values are automatically  * updated when you write devmajor or devminor and vice versa.  *  * In addition, fields can be "set" or "unset."  Unset string fields  * return NULL, non-string fields have _is_set() functions to test  * whether they've been set.  You can "unset" a string field by  * assigning NULL; non-string fields have _unset() functions to  * unset them.  *  * Note: There is one ambiguity in the above; string fields will  * also return NULL when implicit character set conversions fail.  * This is usually what you want.  */
name|__LA_DECL
name|time_t
name|archive_entry_atime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|long
name|archive_entry_atime_nsec
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_atime_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|time_t
name|archive_entry_birthtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|long
name|archive_entry_birthtime_nsec
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_birthtime_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|time_t
name|archive_entry_ctime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|long
name|archive_entry_ctime_nsec
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_ctime_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_dev
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_dev_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_devmajor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_devminor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|__LA_MODE_T
name|archive_entry_filetype
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_fflags
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|unsigned
name|long
modifier|*
comment|/* set */
parameter_list|,
name|unsigned
name|long
modifier|*
comment|/* clear */
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_fflags_text
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|la_int64_t
name|archive_entry_gid
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_gname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_gname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_gname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_hardlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_hardlink_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_hardlink_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|la_int64_t
name|archive_entry_ino
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|la_int64_t
name|archive_entry_ino64
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_ino_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|__LA_MODE_T
name|archive_entry_mode
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|time_t
name|archive_entry_mtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|long
name|archive_entry_mtime_nsec
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_mtime_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|unsigned
name|int
name|archive_entry_nlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_pathname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_pathname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_pathname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|__LA_MODE_T
name|archive_entry_perm
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_rdev
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_rdevmajor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_rdevminor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_sourcepath
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_sourcepath_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|la_int64_t
name|archive_entry_size
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_size_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_strmode
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_symlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_symlink_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_symlink_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|la_int64_t
name|archive_entry_uid
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_uname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_uname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_uname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_is_data_encrypted
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_is_metadata_encrypted
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_is_encrypted
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Set fields in an archive_entry.  *  * Note: Before libarchive 2.4, there were 'set' and 'copy' versions  * of the string setters.  'copy' copied the actual string, 'set' just  * stored the pointer.  In libarchive 2.4 and later, strings are  * always copied.  */
name|__LA_DECL
name|void
name|archive_entry_set_atime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_unset_atime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|__LA_DECL
name|void
name|archive_entry_copy_bhfi
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|BY_HANDLE_FILE_INFORMATION
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
name|__LA_DECL
name|void
name|archive_entry_set_birthtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_unset_birthtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_ctime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_unset_ctime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_dev
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_devmajor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_devminor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_filetype
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_fflags
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|unsigned
name|long
comment|/* set */
parameter_list|,
name|unsigned
name|long
comment|/* clear */
parameter_list|)
function_decl|;
comment|/* Returns pointer to start of first invalid token, or NULL if none. */
comment|/* Note that all recognized tokens are processed, regardless. */
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_copy_fflags_text
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_copy_fflags_text_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_gid
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_gname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_gname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_gname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_gname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_gname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_hardlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_hardlink_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_hardlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_hardlink_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_hardlink_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_ino
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_ino64
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_link
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_link_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_link
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_link_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_link_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_mode
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|__LA_MODE_T
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_mtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_unset_mtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_nlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_pathname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_pathname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_pathname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_pathname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_pathname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_perm
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|__LA_MODE_T
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_rdev
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_rdevmajor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_rdevminor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_size
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_unset_size
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_sourcepath
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_sourcepath_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_symlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_symlink_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_symlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_symlink_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_symlink_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_uid
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|la_int64_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_uname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_uname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_uname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_uname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_uname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_is_data_encrypted
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|char
name|is_encrypted
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_is_metadata_encrypted
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|char
name|is_encrypted
parameter_list|)
function_decl|;
comment|/*  * Routines to bulk copy fields to/from a platform-native "struct  * stat."  Libarchive used to just store a struct stat inside of each  * archive_entry object, but this created issues when trying to  * manipulate archives on systems different than the ones they were  * created on.  *  * TODO: On Linux and other LFS systems, provide both stat32 and  * stat64 versions of these functions and all of the macro glue so  * that archive_entry_stat is magically defined to  * archive_entry_stat32 or archive_entry_stat64 as appropriate.  */
name|__LA_DECL
specifier|const
expr|struct
name|stat
operator|*
name|archive_entry_stat
argument_list|(
expr|struct
name|archive_entry
operator|*
argument_list|)
expr_stmt|;
name|__LA_DECL
name|void
name|archive_entry_copy_stat
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Storage for Mac OS-specific AppleDouble metadata information.  * Apple-format tar files store a separate binary blob containing  * encoded metadata with ACL, extended attributes, etc.  * This provides a place to store that blob.  */
name|__LA_DECL
specifier|const
name|void
modifier|*
name|archive_entry_mac_metadata
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_mac_metadata
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/*  * ACL routines.  This used to simply store and return text-format ACL  * strings, but that proved insufficient for a number of reasons:  *   = clients need control over uname/uid and gname/gid mappings  *   = there are many different ACL text formats  *   = would like to be able to read/convert archives containing ACLs  *     on platforms that lack ACL libraries  *  *  This last point, in particular, forces me to implement a reasonably  *  complete set of ACL support routines.  */
comment|/*  * Permission bits.  */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_EXECUTE
value|0x00000001
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_WRITE
value|0x00000002
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_READ
value|0x00000004
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_READ_DATA
value|0x00000008
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_LIST_DIRECTORY
value|0x00000008
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_WRITE_DATA
value|0x00000010
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_ADD_FILE
value|0x00000010
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_APPEND_DATA
value|0x00000020
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY
value|0x00000020
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS
value|0x00000040
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS
value|0x00000080
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_DELETE_CHILD
value|0x00000100
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES
value|0x00000200
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES
value|0x00000400
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_DELETE
value|0x00000800
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_READ_ACL
value|0x00001000
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_WRITE_ACL
value|0x00002000
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_WRITE_OWNER
value|0x00004000
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_SYNCHRONIZE
value|0x00008000
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_PERMS_POSIX1E
define|\
value|(ARCHIVE_ENTRY_ACL_EXECUTE			\ 	    | ARCHIVE_ENTRY_ACL_WRITE			\ 	    | ARCHIVE_ENTRY_ACL_READ)
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_PERMS_NFS4
define|\
value|(ARCHIVE_ENTRY_ACL_EXECUTE			\ 	    | ARCHIVE_ENTRY_ACL_READ_DATA		\ 	    | ARCHIVE_ENTRY_ACL_LIST_DIRECTORY 		\ 	    | ARCHIVE_ENTRY_ACL_WRITE_DATA		\ 	    | ARCHIVE_ENTRY_ACL_ADD_FILE		\ 	    | ARCHIVE_ENTRY_ACL_APPEND_DATA		\ 	    | ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY	\ 	    | ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS	\ 	    | ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS	\ 	    | ARCHIVE_ENTRY_ACL_DELETE_CHILD		\ 	    | ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES		\ 	    | ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES	\ 	    | ARCHIVE_ENTRY_ACL_DELETE			\ 	    | ARCHIVE_ENTRY_ACL_READ_ACL		\ 	    | ARCHIVE_ENTRY_ACL_WRITE_ACL		\ 	    | ARCHIVE_ENTRY_ACL_WRITE_OWNER		\ 	    | ARCHIVE_ENTRY_ACL_SYNCHRONIZE)
comment|/*  * Inheritance values (NFS4 ACLs only); included in permset.  */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_ENTRY_INHERITED
value|0x01000000
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT
value|0x02000000
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT
value|0x04000000
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT
value|0x08000000
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY
value|0x10000000
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS
value|0x20000000
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS
value|0x40000000
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_INHERITANCE_NFS4
define|\
value|(ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT			\ 	    | ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT		\ 	    | ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT	\ 	    | ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY		\ 	    | ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS		\ 	    | ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS		\ 	    | ARCHIVE_ENTRY_ACL_ENTRY_INHERITED)
comment|/* We need to be able to specify combinations of these. */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
value|0x00000100
comment|/* POSIX.1e only */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
value|0x00000200
comment|/* POSIX.1e only */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_TYPE_ALLOW
value|0x00000400
comment|/* NFS4 only */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_TYPE_DENY
value|0x00000800
comment|/* NFS4 only */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_TYPE_AUDIT
value|0x00001000
comment|/* NFS4 only */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_TYPE_ALARM
value|0x00002000
comment|/* NFS4 only */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_TYPE_POSIX1E
value|(ARCHIVE_ENTRY_ACL_TYPE_ACCESS \ 	    | ARCHIVE_ENTRY_ACL_TYPE_DEFAULT)
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_TYPE_NFS4
value|(ARCHIVE_ENTRY_ACL_TYPE_ALLOW \ 	    | ARCHIVE_ENTRY_ACL_TYPE_DENY \ 	    | ARCHIVE_ENTRY_ACL_TYPE_AUDIT \ 	    | ARCHIVE_ENTRY_ACL_TYPE_ALARM)
comment|/* Tag values mimic POSIX.1e */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_USER
value|10001
comment|/* Specified user. */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_USER_OBJ
value|10002
comment|/* User who owns the file. */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_GROUP
value|10003
comment|/* Specified group. */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_GROUP_OBJ
value|10004
comment|/* Group who owns the file. */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_MASK
value|10005
comment|/* Modify group access (POSIX.1e only) */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_OTHER
value|10006
comment|/* Public (POSIX.1e only) */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_EVERYONE
value|10107
comment|/* Everyone (NFS4 only) */
comment|/*  * Set the ACL by clearing it and adding entries one at a time.  * Unlike the POSIX.1e ACL routines, you must specify the type  * (access/default) for each entry.  Internally, the ACL data is just  * a soup of entries.  API calls here allow you to retrieve just the  * entries of interest.  This design (which goes against the spirit of  * POSIX.1e) is useful for handling archive formats that combine  * default and access information in a single ACL list.  */
name|__LA_DECL
name|void
name|archive_entry_acl_clear
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_acl_add_entry
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* type */
parameter_list|,
name|int
comment|/* permset */
parameter_list|,
name|int
comment|/* tag */
parameter_list|,
name|int
comment|/* qual */
parameter_list|,
specifier|const
name|char
modifier|*
comment|/* name */
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_acl_add_entry_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* type */
parameter_list|,
name|int
comment|/* permset */
parameter_list|,
name|int
comment|/* tag */
parameter_list|,
name|int
comment|/* qual */
parameter_list|,
specifier|const
name|wchar_t
modifier|*
comment|/* name */
parameter_list|)
function_decl|;
comment|/*  * To retrieve the ACL, first "reset", then repeatedly ask for the  * "next" entry.  The want_type parameter allows you to request only  * certain types of entries.  */
name|__LA_DECL
name|int
name|archive_entry_acl_reset
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* want_type */
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_acl_next
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* want_type */
parameter_list|,
name|int
modifier|*
comment|/* type */
parameter_list|,
name|int
modifier|*
comment|/* permset */
parameter_list|,
name|int
modifier|*
comment|/* tag */
parameter_list|,
name|int
modifier|*
comment|/* qual */
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
comment|/* name */
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_acl_next_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* want_type */
parameter_list|,
name|int
modifier|*
comment|/* type */
parameter_list|,
name|int
modifier|*
comment|/* permset */
parameter_list|,
name|int
modifier|*
comment|/* tag */
parameter_list|,
name|int
modifier|*
comment|/* qual */
parameter_list|,
specifier|const
name|wchar_t
modifier|*
modifier|*
comment|/* name */
parameter_list|)
function_decl|;
comment|/*  * Construct a text-format ACL.  The flags argument is a bitmask that  * can include any of the following:  *  * Flags only for archive entries with POSIX.1e ACL:  * ARCHIVE_ENTRY_ACL_TYPE_ACCESS - Include POSIX.1e "access" entries.  * ARCHIVE_ENTRY_ACL_TYPE_DEFAULT - Include POSIX.1e "default" entries.  * ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT - Include "default:" before each  *    default ACL entry.  * ARCHIVE_ENTRY_ACL_STYLE_SOLARIS - Output only one colon after "other" and  *    "mask" entries.  *  * Flags only for archive entries with NFSv4 ACL:  * ARCHIVE_ENTRY_ACL_STYLE_COMPACT - Do not output the minus character for  *    unset permissions and flags in NFSv4 ACL permission and flag fields  *  * Flags for for archive entries with POSIX.1e ACL or NFSv4 ACL:  * ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID - Include extra numeric ID field in  *    each ACL entry.  * ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA - Separate entries with comma  *    instead of newline.  */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID
value|0x00000001
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT
value|0x00000002
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_STYLE_SOLARIS
value|0x00000004
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA
value|0x00000008
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_STYLE_COMPACT
value|0x00000010
name|__LA_DECL
name|wchar_t
modifier|*
name|archive_entry_acl_to_text_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|la_ssize_t
modifier|*
comment|/* len */
parameter_list|,
name|int
comment|/* flags */
parameter_list|)
function_decl|;
name|__LA_DECL
name|char
modifier|*
name|archive_entry_acl_to_text
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|la_ssize_t
modifier|*
comment|/* len */
parameter_list|,
name|int
comment|/* flags */
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_acl_from_text_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
comment|/* wtext */
parameter_list|,
name|int
comment|/* type */
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_acl_from_text
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
comment|/* text */
parameter_list|,
name|int
comment|/* type */
parameter_list|)
function_decl|;
comment|/* Deprecated constants */
define|#
directive|define
name|OLD_ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID
value|1024
define|#
directive|define
name|OLD_ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT
value|2048
comment|/* Deprecated functions */
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_acl_text_w
argument_list|(
expr|struct
name|archive_entry
operator|*
argument_list|,
name|int
comment|/* flags */
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_acl_text
argument_list|(
expr|struct
name|archive_entry
operator|*
argument_list|,
name|int
comment|/* flags */
argument_list|)
name|__LA_DEPRECATED
decl_stmt|;
comment|/* Return bitmask of ACL types in an archive entry */
name|__LA_DECL
name|int
name|archive_entry_acl_types
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
comment|/* Return a count of entries matching 'want_type' */
name|__LA_DECL
name|int
name|archive_entry_acl_count
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* want_type */
parameter_list|)
function_decl|;
comment|/* Return an opaque ACL object. */
comment|/* There's not yet anything clients can actually do with this... */
struct_decl|struct
name|archive_acl
struct_decl|;
name|__LA_DECL
name|struct
name|archive_acl
modifier|*
name|archive_entry_acl
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
comment|/*  * extended attributes  */
name|__LA_DECL
name|void
name|archive_entry_xattr_clear
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_xattr_add_entry
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
comment|/* name */
parameter_list|,
specifier|const
name|void
modifier|*
comment|/* value */
parameter_list|,
name|size_t
comment|/* size */
parameter_list|)
function_decl|;
comment|/*  * To retrieve the xattr list, first "reset", then repeatedly ask for the  * "next" entry.  */
name|__LA_DECL
name|int
name|archive_entry_xattr_count
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_xattr_reset
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_xattr_next
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
comment|/* name */
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
comment|/* value */
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * sparse  */
name|__LA_DECL
name|void
name|archive_entry_sparse_clear
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_sparse_add_entry
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|la_int64_t
comment|/* offset */
parameter_list|,
name|la_int64_t
comment|/* length */
parameter_list|)
function_decl|;
comment|/*  * To retrieve the xattr list, first "reset", then repeatedly ask for the  * "next" entry.  */
name|__LA_DECL
name|int
name|archive_entry_sparse_count
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_sparse_reset
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_sparse_next
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|la_int64_t
modifier|*
comment|/* offset */
parameter_list|,
name|la_int64_t
modifier|*
comment|/* length */
parameter_list|)
function_decl|;
comment|/*  * Utility to match up hardlinks.  *  * The 'struct archive_entry_linkresolver' is a cache of archive entries  * for files with multiple links.  Here's how to use it:  *   1. Create a lookup object with archive_entry_linkresolver_new()  *   2. Tell it the archive format you're using.  *   3. Hand each archive_entry to archive_entry_linkify().  *      That function will return 0, 1, or 2 entries that should  *      be written.  *   4. Call archive_entry_linkify(resolver, NULL) until  *      no more entries are returned.  *   5. Call archive_entry_linkresolver_free(resolver) to free resources.  *  * The entries returned have their hardlink and size fields updated  * appropriately.  If an entry is passed in that does not refer to  * a file with multiple links, it is returned unchanged.  The intention  * is that you should be able to simply filter all entries through  * this machine.  *  * To make things more efficient, be sure that each entry has a valid  * nlinks value.  The hardlink cache uses this to track when all links  * have been found.  If the nlinks value is zero, it will keep every  * name in the cache indefinitely, which can use a lot of memory.  *  * Note that archive_entry_size() is reset to zero if the file  * body should not be written to the archive.  Pay attention!  */
struct_decl|struct
name|archive_entry_linkresolver
struct_decl|;
comment|/*  * There are three different strategies for marking hardlinks.  * The descriptions below name them after the best-known  * formats that rely on each strategy:  *  * "Old cpio" is the simplest, it always returns any entry unmodified.  *    As far as I know, only cpio formats use this.  Old cpio archives  *    store every link with the full body; the onus is on the dearchiver  *    to detect and properly link the files as they are restored.  * "tar" is also pretty simple; it caches a copy the first time it sees  *    any link.  Subsequent appearances are modified to be hardlink  *    references to the first one without any body.  Used by all tar  *    formats, although the newest tar formats permit the "old cpio" strategy  *    as well.  This strategy is very simple for the dearchiver,  *    and reasonably straightforward for the archiver.  * "new cpio" is trickier.  It stores the body only with the last  *    occurrence.  The complication is that we might not  *    see every link to a particular file in a single session, so  *    there's no easy way to know when we've seen the last occurrence.  *    The solution here is to queue one link until we see the next.  *    At the end of the session, you can enumerate any remaining  *    entries by calling archive_entry_linkify(NULL) and store those  *    bodies.  If you have a file with three links l1, l2, and l3,  *    you'll get the following behavior if you see all three links:  *           linkify(l1) => NULL   (the resolver stores l1 internally)  *           linkify(l2) => l1     (resolver stores l2, you write l1)  *           linkify(l3) => l2, l3 (all links seen, you can write both).  *    If you only see l1 and l2, you'll get this behavior:  *           linkify(l1) => NULL  *           linkify(l2) => l1  *           linkify(NULL) => l2   (at end, you retrieve remaining links)  *    As the name suggests, this strategy is used by newer cpio variants.  *    It's noticeably more complex for the archiver, slightly more complex  *    for the dearchiver than the tar strategy, but makes it straightforward  *    to restore a file using any link by simply continuing to scan until  *    you see a link that is stored with a body.  In contrast, the tar  *    strategy requires you to rescan the archive from the beginning to  *    correctly extract an arbitrary link.  */
name|__LA_DECL
name|struct
name|archive_entry_linkresolver
modifier|*
name|archive_entry_linkresolver_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_linkresolver_set_strategy
parameter_list|(
name|struct
name|archive_entry_linkresolver
modifier|*
parameter_list|,
name|int
comment|/* format_code */
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_linkresolver_free
parameter_list|(
name|struct
name|archive_entry_linkresolver
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_linkify
parameter_list|(
name|struct
name|archive_entry_linkresolver
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|struct
name|archive_entry
modifier|*
name|archive_entry_partial_links
parameter_list|(
name|struct
name|archive_entry_linkresolver
modifier|*
name|res
parameter_list|,
name|unsigned
name|int
modifier|*
name|links
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is meaningless outside of this header. */
end_comment

begin_undef
undef|#
directive|undef
name|__LA_DECL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !ARCHIVE_ENTRY_H_INCLUDED */
end_comment

end_unit

