begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This code is in the public domain and has no copyright.  *  * This is a plain C recursive-descent translation of an old  * public-domain YACC grammar that has been used for parsing dates in  * very many open-source projects.  *  * Since the original authors were generous enough to donate their  * work to the public domain, I feel compelled to match their  * generosity.  *  * Tim Kientzle, February 2009.  */
end_comment

begin_comment
comment|/*  * Header comment from original getdate.y:  */
end_comment

begin_comment
comment|/* **  Originally written by Steven M. Bellovin<smb@research.att.com> while **  at the University of North Carolina at Chapel Hill.  Later tweaked by **  a couple of people on Usenet.  Completely overhauled by Rich $alz **<rsalz@bbn.com> and Jim Berets<jberets@bbn.com> in August, 1990; ** **  This grammar has 10 shift/reduce conflicts. ** **  This code is in the public domain and has no copyright. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_define
define|#
directive|define
name|__LIBARCHIVE_BUILD
value|1
end_define

begin_include
include|#
directive|include
file|"archive_getdate.h"
end_include

begin_comment
comment|/* Basic time units. */
end_comment

begin_define
define|#
directive|define
name|EPOCH
value|1970
end_define

begin_define
define|#
directive|define
name|MINUTE
value|(60L)
end_define

begin_define
define|#
directive|define
name|HOUR
value|(60L * MINUTE)
end_define

begin_define
define|#
directive|define
name|DAY
value|(24L * HOUR)
end_define

begin_comment
comment|/* Daylight-savings mode:  on, off, or not yet known. */
end_comment

begin_enum
enum|enum
name|DSTMODE
block|{
name|DSTon
block|,
name|DSToff
block|,
name|DSTmaybe
block|}
enum|;
end_enum

begin_comment
comment|/* Meridian:  am or pm. */
end_comment

begin_enum
enum|enum
block|{
name|tAM
block|,
name|tPM
block|}
enum|;
end_enum

begin_comment
comment|/* Token types returned by nexttoken() */
end_comment

begin_enum
enum|enum
block|{
name|tAGO
init|=
literal|260
block|,
name|tDAY
block|,
name|tDAYZONE
block|,
name|tAMPM
block|,
name|tMONTH
block|,
name|tMONTH_UNIT
block|,
name|tSEC_UNIT
block|,
name|tUNUMBER
block|,
name|tZONE
block|,
name|tDST
block|}
enum|;
end_enum

begin_struct
struct|struct
name|token
block|{
name|int
name|token
decl_stmt|;
name|time_t
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Parser state.  */
end_comment

begin_struct
struct|struct
name|gdstate
block|{
name|struct
name|token
modifier|*
name|tokenp
decl_stmt|;
comment|/* Pointer to next token. */
comment|/* HaveXxxx counts how many of this kind of phrase we've seen; 	 * it's a fatal error to have more than one time, zone, day, 	 * or date phrase. */
name|int
name|HaveYear
decl_stmt|;
name|int
name|HaveMonth
decl_stmt|;
name|int
name|HaveDay
decl_stmt|;
name|int
name|HaveWeekDay
decl_stmt|;
comment|/* Day of week */
name|int
name|HaveTime
decl_stmt|;
comment|/* Hour/minute/second */
name|int
name|HaveZone
decl_stmt|;
comment|/* timezone and/or DST info */
name|int
name|HaveRel
decl_stmt|;
comment|/* time offset; we can have more than one */
comment|/* Absolute time values. */
name|time_t
name|Timezone
decl_stmt|;
comment|/* Seconds offset from GMT */
name|time_t
name|Day
decl_stmt|;
name|time_t
name|Hour
decl_stmt|;
name|time_t
name|Minutes
decl_stmt|;
name|time_t
name|Month
decl_stmt|;
name|time_t
name|Seconds
decl_stmt|;
name|time_t
name|Year
decl_stmt|;
comment|/* DST selection */
name|enum
name|DSTMODE
name|DSTmode
decl_stmt|;
comment|/* Day of week accounting, e.g., "3rd Tuesday" */
name|time_t
name|DayOrdinal
decl_stmt|;
comment|/* "3" in "3rd Tuesday" */
name|time_t
name|DayNumber
decl_stmt|;
comment|/* "Tuesday" in "3rd Tuesday" */
comment|/* Relative time values: hour/day/week offsets are measured in 	 * seconds, month/year are counted in months. */
name|time_t
name|RelMonth
decl_stmt|;
name|time_t
name|RelSeconds
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * A series of functions that recognize certain common time phrases.  * Each function returns 1 if it managed to make sense of some of the  * tokens, zero otherwise.  */
end_comment

begin_comment
comment|/*  *  hour:minute or hour:minute:second with optional AM, PM, or numeric  *  timezone offset  */
end_comment

begin_function
specifier|static
name|int
name|timephrase
parameter_list|(
name|struct
name|gdstate
modifier|*
name|gds
parameter_list|)
block|{
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
literal|':'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|3
index|]
operator|.
name|token
operator|==
literal|':'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
comment|/* "12:14:18" or "22:08:07" */
operator|++
name|gds
operator|->
name|HaveTime
expr_stmt|;
name|gds
operator|->
name|Hour
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Minutes
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Seconds
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
literal|':'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
comment|/* "12:14" or "22:08" */
operator|++
name|gds
operator|->
name|HaveTime
expr_stmt|;
name|gds
operator|->
name|Hour
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Minutes
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Seconds
operator|=
literal|0
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tAMPM
condition|)
block|{
comment|/* "7" is a time if it's followed by "am" or "pm" */
operator|++
name|gds
operator|->
name|HaveTime
expr_stmt|;
name|gds
operator|->
name|Hour
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Minutes
operator|=
name|gds
operator|->
name|Seconds
operator|=
literal|0
expr_stmt|;
comment|/* We'll handle the AM/PM below. */
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't handle this. */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tAMPM
condition|)
block|{
comment|/* "7:12pm", "12:20:13am" */
if|if
condition|(
name|gds
operator|->
name|Hour
operator|==
literal|12
condition|)
name|gds
operator|->
name|Hour
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|==
name|tPM
condition|)
name|gds
operator|->
name|Hour
operator|+=
literal|12
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
literal|'+'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
comment|/* "7:14+0700" */
name|gds
operator|->
name|HaveZone
operator|++
expr_stmt|;
name|gds
operator|->
name|DSTmode
operator|=
name|DSToff
expr_stmt|;
name|gds
operator|->
name|Timezone
operator|=
operator|-
operator|(
operator|(
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
operator|/
literal|100
operator|)
operator|*
name|HOUR
operator|+
operator|(
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
operator|%
literal|100
operator|)
operator|*
name|MINUTE
operator|)
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
literal|'-'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
comment|/* "19:14:12-0530" */
name|gds
operator|->
name|HaveZone
operator|++
expr_stmt|;
name|gds
operator|->
name|DSTmode
operator|=
name|DSToff
expr_stmt|;
name|gds
operator|->
name|Timezone
operator|=
operator|+
operator|(
operator|(
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
operator|/
literal|100
operator|)
operator|*
name|HOUR
operator|+
operator|(
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
operator|%
literal|100
operator|)
operator|*
name|MINUTE
operator|)
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|2
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Timezone name, possibly including DST.  */
end_comment

begin_function
specifier|static
name|int
name|zonephrase
parameter_list|(
name|struct
name|gdstate
modifier|*
name|gds
parameter_list|)
block|{
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tZONE
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tDST
condition|)
block|{
name|gds
operator|->
name|HaveZone
operator|++
expr_stmt|;
name|gds
operator|->
name|Timezone
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|DSTmode
operator|=
name|DSTon
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tZONE
condition|)
block|{
name|gds
operator|->
name|HaveZone
operator|++
expr_stmt|;
name|gds
operator|->
name|Timezone
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|DSTmode
operator|=
name|DSToff
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tDAYZONE
condition|)
block|{
name|gds
operator|->
name|HaveZone
operator|++
expr_stmt|;
name|gds
operator|->
name|Timezone
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|DSTmode
operator|=
name|DSTon
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Year/month/day in various combinations.  */
end_comment

begin_function
specifier|static
name|int
name|datephrase
parameter_list|(
name|struct
name|gdstate
modifier|*
name|gds
parameter_list|)
block|{
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
literal|'/'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|3
index|]
operator|.
name|token
operator|==
literal|'/'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
name|gds
operator|->
name|HaveYear
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveMonth
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveDay
operator|++
expr_stmt|;
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|>=
literal|13
condition|)
block|{
comment|/* First number is big:  2004/01/29, 99/02/17 */
name|gds
operator|->
name|Year
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Month
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Day
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|value
operator|>=
literal|13
operator|)
operator|||
operator|(
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
operator|>=
literal|13
operator|)
condition|)
block|{
comment|/* Last number is big:  01/07/98 */
comment|/* Middle number is big:  01/29/04 */
name|gds
operator|->
name|Month
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Day
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Year
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* No significant clues: 02/03/04 */
name|gds
operator|->
name|Month
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Day
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Year
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|value
expr_stmt|;
block|}
name|gds
operator|->
name|tokenp
operator|+=
literal|5
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
literal|'/'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
comment|/* "1/15" */
name|gds
operator|->
name|HaveMonth
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveDay
operator|++
expr_stmt|;
name|gds
operator|->
name|Month
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Day
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|3
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
literal|'-'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|3
index|]
operator|.
name|token
operator|==
literal|'-'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
comment|/* ISO 8601 format.  yyyy-mm-dd.  */
name|gds
operator|->
name|HaveYear
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveMonth
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveDay
operator|++
expr_stmt|;
name|gds
operator|->
name|Year
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Month
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Day
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|5
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
literal|'-'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
name|tMONTH
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|3
index|]
operator|.
name|token
operator|==
literal|'-'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
name|gds
operator|->
name|HaveYear
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveMonth
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveDay
operator|++
expr_stmt|;
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|>
literal|31
condition|)
block|{
comment|/* e.g. 1992-Jun-17 */
name|gds
operator|->
name|Year
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Month
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Day
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* e.g. 17-JUN-1992.  */
name|gds
operator|->
name|Day
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Month
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Year
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|4
index|]
operator|.
name|value
expr_stmt|;
block|}
name|gds
operator|->
name|tokenp
operator|+=
literal|5
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tMONTH
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
literal|','
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|3
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
comment|/* "June 17, 2001" */
name|gds
operator|->
name|HaveYear
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveMonth
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveDay
operator|++
expr_stmt|;
name|gds
operator|->
name|Month
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Day
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Year
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|3
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|4
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tMONTH
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
comment|/* "May 3" */
name|gds
operator|->
name|HaveMonth
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveDay
operator|++
expr_stmt|;
name|gds
operator|->
name|Month
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Day
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tMONTH
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
comment|/* "12 Sept 1997" */
name|gds
operator|->
name|HaveYear
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveMonth
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveDay
operator|++
expr_stmt|;
name|gds
operator|->
name|Day
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Month
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Year
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|3
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tMONTH
condition|)
block|{
comment|/* "12 Sept" */
name|gds
operator|->
name|HaveMonth
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveDay
operator|++
expr_stmt|;
name|gds
operator|->
name|Day
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Month
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Relative time phrase: "tomorrow", "yesterday", "+1 hour", etc.  */
end_comment

begin_function
specifier|static
name|int
name|relunitphrase
parameter_list|(
name|struct
name|gdstate
modifier|*
name|gds
parameter_list|)
block|{
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
literal|'-'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
name|tSEC_UNIT
condition|)
block|{
comment|/* "-3 hours" */
name|gds
operator|->
name|HaveRel
operator|++
expr_stmt|;
name|gds
operator|->
name|RelSeconds
operator|-=
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
operator|*
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|3
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
literal|'+'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
name|tSEC_UNIT
condition|)
block|{
comment|/* "+1 minute" */
name|gds
operator|->
name|HaveRel
operator|++
expr_stmt|;
name|gds
operator|->
name|RelSeconds
operator|+=
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
operator|*
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|3
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tSEC_UNIT
condition|)
block|{
comment|/* "1 day" */
name|gds
operator|->
name|HaveRel
operator|++
expr_stmt|;
name|gds
operator|->
name|RelSeconds
operator|+=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|*
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
literal|'-'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
name|tMONTH_UNIT
condition|)
block|{
comment|/* "-3 months" */
name|gds
operator|->
name|HaveRel
operator|++
expr_stmt|;
name|gds
operator|->
name|RelMonth
operator|-=
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
operator|*
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|3
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
literal|'+'
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|token
operator|==
name|tMONTH_UNIT
condition|)
block|{
comment|/* "+5 years" */
name|gds
operator|->
name|HaveRel
operator|++
expr_stmt|;
name|gds
operator|->
name|RelMonth
operator|+=
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
operator|*
name|gds
operator|->
name|tokenp
index|[
literal|2
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|3
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tMONTH_UNIT
condition|)
block|{
comment|/* "2 years" */
name|gds
operator|->
name|HaveRel
operator|++
expr_stmt|;
name|gds
operator|->
name|RelMonth
operator|+=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|*
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tSEC_UNIT
condition|)
block|{
comment|/* "now", "tomorrow" */
name|gds
operator|->
name|HaveRel
operator|++
expr_stmt|;
name|gds
operator|->
name|RelSeconds
operator|+=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tMONTH_UNIT
condition|)
block|{
comment|/* "month" */
name|gds
operator|->
name|HaveRel
operator|++
expr_stmt|;
name|gds
operator|->
name|RelMonth
operator|+=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Day of the week specification.  */
end_comment

begin_function
specifier|static
name|int
name|dayphrase
parameter_list|(
name|struct
name|gdstate
modifier|*
name|gds
parameter_list|)
block|{
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tDAY
condition|)
block|{
comment|/* "tues", "wednesday," */
name|gds
operator|->
name|HaveWeekDay
operator|++
expr_stmt|;
name|gds
operator|->
name|DayOrdinal
operator|=
literal|1
expr_stmt|;
name|gds
operator|->
name|DayNumber
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
literal|','
condition|)
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
operator|&&
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|token
operator|==
name|tDAY
condition|)
block|{
comment|/* "second tues" "3 wed" */
name|gds
operator|->
name|HaveWeekDay
operator|++
expr_stmt|;
name|gds
operator|->
name|DayOrdinal
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|DayNumber
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|1
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|2
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Try to match a phrase using one of the above functions.  * This layer also deals with a couple of generic issues.  */
end_comment

begin_function
specifier|static
name|int
name|phrase
parameter_list|(
name|struct
name|gdstate
modifier|*
name|gds
parameter_list|)
block|{
if|if
condition|(
name|timephrase
argument_list|(
name|gds
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|zonephrase
argument_list|(
name|gds
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|datephrase
argument_list|(
name|gds
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|dayphrase
argument_list|(
name|gds
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|relunitphrase
argument_list|(
name|gds
argument_list|)
condition|)
block|{
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tAGO
condition|)
block|{
name|gds
operator|->
name|RelSeconds
operator|=
operator|-
name|gds
operator|->
name|RelSeconds
expr_stmt|;
name|gds
operator|->
name|RelMonth
operator|=
operator|-
name|gds
operator|->
name|RelMonth
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* Bare numbers sometimes have meaning. */
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|token
operator|==
name|tUNUMBER
condition|)
block|{
if|if
condition|(
name|gds
operator|->
name|HaveTime
operator|&&
operator|!
name|gds
operator|->
name|HaveYear
operator|&&
operator|!
name|gds
operator|->
name|HaveRel
condition|)
block|{
name|gds
operator|->
name|HaveYear
operator|++
expr_stmt|;
name|gds
operator|->
name|Year
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|>
literal|10000
condition|)
block|{
comment|/* "20040301" */
name|gds
operator|->
name|HaveYear
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveMonth
operator|++
expr_stmt|;
name|gds
operator|->
name|HaveDay
operator|++
expr_stmt|;
name|gds
operator|->
name|Day
operator|=
operator|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|)
operator|%
literal|100
expr_stmt|;
name|gds
operator|->
name|Month
operator|=
operator|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|/
literal|100
operator|)
operator|%
literal|100
expr_stmt|;
name|gds
operator|->
name|Year
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|/
literal|10000
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|<
literal|24
condition|)
block|{
name|gds
operator|->
name|HaveTime
operator|++
expr_stmt|;
name|gds
operator|->
name|Hour
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
expr_stmt|;
name|gds
operator|->
name|Minutes
operator|=
literal|0
expr_stmt|;
name|gds
operator|->
name|Seconds
operator|=
literal|0
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|/
literal|100
operator|<
literal|24
operator|)
operator|&&
operator|(
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|%
literal|100
operator|<
literal|60
operator|)
condition|)
block|{
comment|/* "513" is same as "5:13" */
name|gds
operator|->
name|Hour
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|/
literal|100
expr_stmt|;
name|gds
operator|->
name|Minutes
operator|=
name|gds
operator|->
name|tokenp
index|[
literal|0
index|]
operator|.
name|value
operator|%
literal|100
expr_stmt|;
name|gds
operator|->
name|Seconds
operator|=
literal|0
expr_stmt|;
name|gds
operator|->
name|tokenp
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * A dictionary of time words.  */
end_comment

begin_struct
specifier|static
struct|struct
name|LEXICON
block|{
name|size_t
name|abbrev
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|time_t
name|value
decl_stmt|;
block|}
decl|const
name|TimeWords
index|[]
init|=
block|{
comment|/* am/pm */
block|{
literal|0
block|,
literal|"am"
block|,
name|tAMPM
block|,
name|tAM
block|}
block|,
block|{
literal|0
block|,
literal|"pm"
block|,
name|tAMPM
block|,
name|tPM
block|}
block|,
comment|/* Month names. */
block|{
literal|3
block|,
literal|"january"
block|,
name|tMONTH
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|"february"
block|,
name|tMONTH
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|"march"
block|,
name|tMONTH
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|"april"
block|,
name|tMONTH
block|,
literal|4
block|}
block|,
block|{
literal|3
block|,
literal|"may"
block|,
name|tMONTH
block|,
literal|5
block|}
block|,
block|{
literal|3
block|,
literal|"june"
block|,
name|tMONTH
block|,
literal|6
block|}
block|,
block|{
literal|3
block|,
literal|"july"
block|,
name|tMONTH
block|,
literal|7
block|}
block|,
block|{
literal|3
block|,
literal|"august"
block|,
name|tMONTH
block|,
literal|8
block|}
block|,
block|{
literal|3
block|,
literal|"september"
block|,
name|tMONTH
block|,
literal|9
block|}
block|,
block|{
literal|3
block|,
literal|"october"
block|,
name|tMONTH
block|,
literal|10
block|}
block|,
block|{
literal|3
block|,
literal|"november"
block|,
name|tMONTH
block|,
literal|11
block|}
block|,
block|{
literal|3
block|,
literal|"december"
block|,
name|tMONTH
block|,
literal|12
block|}
block|,
comment|/* Days of the week. */
block|{
literal|2
block|,
literal|"sunday"
block|,
name|tDAY
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|"monday"
block|,
name|tDAY
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|"tuesday"
block|,
name|tDAY
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|"wednesday"
block|,
name|tDAY
block|,
literal|3
block|}
block|,
block|{
literal|2
block|,
literal|"thursday"
block|,
name|tDAY
block|,
literal|4
block|}
block|,
block|{
literal|2
block|,
literal|"friday"
block|,
name|tDAY
block|,
literal|5
block|}
block|,
block|{
literal|2
block|,
literal|"saturday"
block|,
name|tDAY
block|,
literal|6
block|}
block|,
comment|/* Timezones: Offsets are in seconds. */
block|{
literal|0
block|,
literal|"gmt"
block|,
name|tZONE
block|,
literal|0
operator|*
name|HOUR
block|}
block|,
comment|/* Greenwich Mean */
block|{
literal|0
block|,
literal|"ut"
block|,
name|tZONE
block|,
literal|0
operator|*
name|HOUR
block|}
block|,
comment|/* Universal (Coordinated) */
block|{
literal|0
block|,
literal|"utc"
block|,
name|tZONE
block|,
literal|0
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"wet"
block|,
name|tZONE
block|,
literal|0
operator|*
name|HOUR
block|}
block|,
comment|/* Western European */
block|{
literal|0
block|,
literal|"bst"
block|,
name|tDAYZONE
block|,
literal|0
operator|*
name|HOUR
block|}
block|,
comment|/* British Summer */
block|{
literal|0
block|,
literal|"wat"
block|,
name|tZONE
block|,
literal|1
operator|*
name|HOUR
block|}
block|,
comment|/* West Africa */
block|{
literal|0
block|,
literal|"at"
block|,
name|tZONE
block|,
literal|2
operator|*
name|HOUR
block|}
block|,
comment|/* Azores */
comment|/* { 0, "bst", tZONE, 3*HOUR }, */
comment|/* Brazil Standard: Conflict */
comment|/* { 0, "gst", tZONE, 3*HOUR }, */
comment|/* Greenland Standard: Conflict*/
block|{
literal|0
block|,
literal|"nft"
block|,
name|tZONE
block|,
literal|3
operator|*
name|HOUR
operator|+
literal|30
operator|*
name|MINUTE
block|}
block|,
comment|/* Newfoundland */
block|{
literal|0
block|,
literal|"nst"
block|,
name|tZONE
block|,
literal|3
operator|*
name|HOUR
operator|+
literal|30
operator|*
name|MINUTE
block|}
block|,
comment|/* Newfoundland Standard */
block|{
literal|0
block|,
literal|"ndt"
block|,
name|tDAYZONE
block|,
literal|3
operator|*
name|HOUR
operator|+
literal|30
operator|*
name|MINUTE
block|}
block|,
comment|/* Newfoundland Daylight */
block|{
literal|0
block|,
literal|"ast"
block|,
name|tZONE
block|,
literal|4
operator|*
name|HOUR
block|}
block|,
comment|/* Atlantic Standard */
block|{
literal|0
block|,
literal|"adt"
block|,
name|tDAYZONE
block|,
literal|4
operator|*
name|HOUR
block|}
block|,
comment|/* Atlantic Daylight */
block|{
literal|0
block|,
literal|"est"
block|,
name|tZONE
block|,
literal|5
operator|*
name|HOUR
block|}
block|,
comment|/* Eastern Standard */
block|{
literal|0
block|,
literal|"edt"
block|,
name|tDAYZONE
block|,
literal|5
operator|*
name|HOUR
block|}
block|,
comment|/* Eastern Daylight */
block|{
literal|0
block|,
literal|"cst"
block|,
name|tZONE
block|,
literal|6
operator|*
name|HOUR
block|}
block|,
comment|/* Central Standard */
block|{
literal|0
block|,
literal|"cdt"
block|,
name|tDAYZONE
block|,
literal|6
operator|*
name|HOUR
block|}
block|,
comment|/* Central Daylight */
block|{
literal|0
block|,
literal|"mst"
block|,
name|tZONE
block|,
literal|7
operator|*
name|HOUR
block|}
block|,
comment|/* Mountain Standard */
block|{
literal|0
block|,
literal|"mdt"
block|,
name|tDAYZONE
block|,
literal|7
operator|*
name|HOUR
block|}
block|,
comment|/* Mountain Daylight */
block|{
literal|0
block|,
literal|"pst"
block|,
name|tZONE
block|,
literal|8
operator|*
name|HOUR
block|}
block|,
comment|/* Pacific Standard */
block|{
literal|0
block|,
literal|"pdt"
block|,
name|tDAYZONE
block|,
literal|8
operator|*
name|HOUR
block|}
block|,
comment|/* Pacific Daylight */
block|{
literal|0
block|,
literal|"yst"
block|,
name|tZONE
block|,
literal|9
operator|*
name|HOUR
block|}
block|,
comment|/* Yukon Standard */
block|{
literal|0
block|,
literal|"ydt"
block|,
name|tDAYZONE
block|,
literal|9
operator|*
name|HOUR
block|}
block|,
comment|/* Yukon Daylight */
block|{
literal|0
block|,
literal|"hst"
block|,
name|tZONE
block|,
literal|10
operator|*
name|HOUR
block|}
block|,
comment|/* Hawaii Standard */
block|{
literal|0
block|,
literal|"hdt"
block|,
name|tDAYZONE
block|,
literal|10
operator|*
name|HOUR
block|}
block|,
comment|/* Hawaii Daylight */
block|{
literal|0
block|,
literal|"cat"
block|,
name|tZONE
block|,
literal|10
operator|*
name|HOUR
block|}
block|,
comment|/* Central Alaska */
block|{
literal|0
block|,
literal|"ahst"
block|,
name|tZONE
block|,
literal|10
operator|*
name|HOUR
block|}
block|,
comment|/* Alaska-Hawaii Standard */
block|{
literal|0
block|,
literal|"nt"
block|,
name|tZONE
block|,
literal|11
operator|*
name|HOUR
block|}
block|,
comment|/* Nome */
block|{
literal|0
block|,
literal|"idlw"
block|,
name|tZONE
block|,
literal|12
operator|*
name|HOUR
block|}
block|,
comment|/* Intl Date Line West */
block|{
literal|0
block|,
literal|"cet"
block|,
name|tZONE
block|,
operator|-
literal|1
operator|*
name|HOUR
block|}
block|,
comment|/* Central European */
block|{
literal|0
block|,
literal|"met"
block|,
name|tZONE
block|,
operator|-
literal|1
operator|*
name|HOUR
block|}
block|,
comment|/* Middle European */
block|{
literal|0
block|,
literal|"mewt"
block|,
name|tZONE
block|,
operator|-
literal|1
operator|*
name|HOUR
block|}
block|,
comment|/* Middle European Winter */
block|{
literal|0
block|,
literal|"mest"
block|,
name|tDAYZONE
block|,
operator|-
literal|1
operator|*
name|HOUR
block|}
block|,
comment|/* Middle European Summer */
block|{
literal|0
block|,
literal|"swt"
block|,
name|tZONE
block|,
operator|-
literal|1
operator|*
name|HOUR
block|}
block|,
comment|/* Swedish Winter */
block|{
literal|0
block|,
literal|"sst"
block|,
name|tDAYZONE
block|,
operator|-
literal|1
operator|*
name|HOUR
block|}
block|,
comment|/* Swedish Summer */
block|{
literal|0
block|,
literal|"fwt"
block|,
name|tZONE
block|,
operator|-
literal|1
operator|*
name|HOUR
block|}
block|,
comment|/* French Winter */
block|{
literal|0
block|,
literal|"fst"
block|,
name|tDAYZONE
block|,
operator|-
literal|1
operator|*
name|HOUR
block|}
block|,
comment|/* French Summer */
block|{
literal|0
block|,
literal|"eet"
block|,
name|tZONE
block|,
operator|-
literal|2
operator|*
name|HOUR
block|}
block|,
comment|/* Eastern Eur, USSR Zone 1 */
block|{
literal|0
block|,
literal|"bt"
block|,
name|tZONE
block|,
operator|-
literal|3
operator|*
name|HOUR
block|}
block|,
comment|/* Baghdad, USSR Zone 2 */
block|{
literal|0
block|,
literal|"it"
block|,
name|tZONE
block|,
operator|-
literal|3
operator|*
name|HOUR
operator|-
literal|30
operator|*
name|MINUTE
block|}
block|,
comment|/* Iran */
block|{
literal|0
block|,
literal|"zp4"
block|,
name|tZONE
block|,
operator|-
literal|4
operator|*
name|HOUR
block|}
block|,
comment|/* USSR Zone 3 */
block|{
literal|0
block|,
literal|"zp5"
block|,
name|tZONE
block|,
operator|-
literal|5
operator|*
name|HOUR
block|}
block|,
comment|/* USSR Zone 4 */
block|{
literal|0
block|,
literal|"ist"
block|,
name|tZONE
block|,
operator|-
literal|5
operator|*
name|HOUR
operator|-
literal|30
operator|*
name|MINUTE
block|}
block|,
comment|/* Indian Standard */
block|{
literal|0
block|,
literal|"zp6"
block|,
name|tZONE
block|,
operator|-
literal|6
operator|*
name|HOUR
block|}
block|,
comment|/* USSR Zone 5 */
comment|/* { 0, "nst",  tZONE, -6.5*HOUR }, */
comment|/* North Sumatra: Conflict */
comment|/* { 0, "sst", tZONE, -7*HOUR }, */
comment|/* So Sumatra, USSR 6: Conflict */
block|{
literal|0
block|,
literal|"wast"
block|,
name|tZONE
block|,
operator|-
literal|7
operator|*
name|HOUR
block|}
block|,
comment|/* West Australian Standard */
block|{
literal|0
block|,
literal|"wadt"
block|,
name|tDAYZONE
block|,
operator|-
literal|7
operator|*
name|HOUR
block|}
block|,
comment|/* West Australian Daylight */
block|{
literal|0
block|,
literal|"jt"
block|,
name|tZONE
block|,
operator|-
literal|7
operator|*
name|HOUR
operator|-
literal|30
operator|*
name|MINUTE
block|}
block|,
comment|/* Java (3pm in Cronusland!)*/
block|{
literal|0
block|,
literal|"cct"
block|,
name|tZONE
block|,
operator|-
literal|8
operator|*
name|HOUR
block|}
block|,
comment|/* China Coast, USSR Zone 7 */
block|{
literal|0
block|,
literal|"jst"
block|,
name|tZONE
block|,
operator|-
literal|9
operator|*
name|HOUR
block|}
block|,
comment|/* Japan Std, USSR Zone 8 */
block|{
literal|0
block|,
literal|"cast"
block|,
name|tZONE
block|,
operator|-
literal|9
operator|*
name|HOUR
operator|-
literal|30
operator|*
name|MINUTE
block|}
block|,
comment|/* Ctrl Australian Std */
block|{
literal|0
block|,
literal|"cadt"
block|,
name|tDAYZONE
block|,
operator|-
literal|9
operator|*
name|HOUR
operator|-
literal|30
operator|*
name|MINUTE
block|}
block|,
comment|/* Ctrl Australian Daylt */
block|{
literal|0
block|,
literal|"east"
block|,
name|tZONE
block|,
operator|-
literal|10
operator|*
name|HOUR
block|}
block|,
comment|/* Eastern Australian Std */
block|{
literal|0
block|,
literal|"eadt"
block|,
name|tDAYZONE
block|,
operator|-
literal|10
operator|*
name|HOUR
block|}
block|,
comment|/* Eastern Australian Daylt */
block|{
literal|0
block|,
literal|"gst"
block|,
name|tZONE
block|,
operator|-
literal|10
operator|*
name|HOUR
block|}
block|,
comment|/* Guam Std, USSR Zone 9 */
block|{
literal|0
block|,
literal|"nzt"
block|,
name|tZONE
block|,
operator|-
literal|12
operator|*
name|HOUR
block|}
block|,
comment|/* New Zealand */
block|{
literal|0
block|,
literal|"nzst"
block|,
name|tZONE
block|,
operator|-
literal|12
operator|*
name|HOUR
block|}
block|,
comment|/* New Zealand Standard */
block|{
literal|0
block|,
literal|"nzdt"
block|,
name|tDAYZONE
block|,
operator|-
literal|12
operator|*
name|HOUR
block|}
block|,
comment|/* New Zealand Daylight */
block|{
literal|0
block|,
literal|"idle"
block|,
name|tZONE
block|,
operator|-
literal|12
operator|*
name|HOUR
block|}
block|,
comment|/* Intl Date Line East */
block|{
literal|0
block|,
literal|"dst"
block|,
name|tDST
block|,
literal|0
block|}
block|,
comment|/* Time units. */
block|{
literal|4
block|,
literal|"years"
block|,
name|tMONTH_UNIT
block|,
literal|12
block|}
block|,
block|{
literal|5
block|,
literal|"months"
block|,
name|tMONTH_UNIT
block|,
literal|1
block|}
block|,
block|{
literal|9
block|,
literal|"fortnights"
block|,
name|tSEC_UNIT
block|,
literal|14
operator|*
name|DAY
block|}
block|,
block|{
literal|4
block|,
literal|"weeks"
block|,
name|tSEC_UNIT
block|,
literal|7
operator|*
name|DAY
block|}
block|,
block|{
literal|3
block|,
literal|"days"
block|,
name|tSEC_UNIT
block|,
name|DAY
block|}
block|,
block|{
literal|4
block|,
literal|"hours"
block|,
name|tSEC_UNIT
block|,
name|HOUR
block|}
block|,
block|{
literal|3
block|,
literal|"minutes"
block|,
name|tSEC_UNIT
block|,
name|MINUTE
block|}
block|,
block|{
literal|3
block|,
literal|"seconds"
block|,
name|tSEC_UNIT
block|,
literal|1
block|}
block|,
comment|/* Relative-time words. */
block|{
literal|0
block|,
literal|"tomorrow"
block|,
name|tSEC_UNIT
block|,
name|DAY
block|}
block|,
block|{
literal|0
block|,
literal|"yesterday"
block|,
name|tSEC_UNIT
block|,
operator|-
name|DAY
block|}
block|,
block|{
literal|0
block|,
literal|"today"
block|,
name|tSEC_UNIT
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|"now"
block|,
name|tSEC_UNIT
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|"last"
block|,
name|tUNUMBER
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|"this"
block|,
name|tSEC_UNIT
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|"next"
block|,
name|tUNUMBER
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|"first"
block|,
name|tUNUMBER
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|"1st"
block|,
name|tUNUMBER
block|,
literal|1
block|}
block|,
comment|/*	{ 0, "second",		tUNUMBER,	2 }, */
block|{
literal|0
block|,
literal|"2nd"
block|,
name|tUNUMBER
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|"third"
block|,
name|tUNUMBER
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|"3rd"
block|,
name|tUNUMBER
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|"fourth"
block|,
name|tUNUMBER
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|"4th"
block|,
name|tUNUMBER
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|"fifth"
block|,
name|tUNUMBER
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|"5th"
block|,
name|tUNUMBER
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|"sixth"
block|,
name|tUNUMBER
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|"seventh"
block|,
name|tUNUMBER
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|"eighth"
block|,
name|tUNUMBER
block|,
literal|8
block|}
block|,
block|{
literal|0
block|,
literal|"ninth"
block|,
name|tUNUMBER
block|,
literal|9
block|}
block|,
block|{
literal|0
block|,
literal|"tenth"
block|,
name|tUNUMBER
block|,
literal|10
block|}
block|,
block|{
literal|0
block|,
literal|"eleventh"
block|,
name|tUNUMBER
block|,
literal|11
block|}
block|,
block|{
literal|0
block|,
literal|"twelfth"
block|,
name|tUNUMBER
block|,
literal|12
block|}
block|,
block|{
literal|0
block|,
literal|"ago"
block|,
name|tAGO
block|,
literal|1
block|}
block|,
comment|/* Military timezones. */
block|{
literal|0
block|,
literal|"a"
block|,
name|tZONE
block|,
literal|1
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"b"
block|,
name|tZONE
block|,
literal|2
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"c"
block|,
name|tZONE
block|,
literal|3
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"d"
block|,
name|tZONE
block|,
literal|4
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"e"
block|,
name|tZONE
block|,
literal|5
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"f"
block|,
name|tZONE
block|,
literal|6
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"g"
block|,
name|tZONE
block|,
literal|7
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"h"
block|,
name|tZONE
block|,
literal|8
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"i"
block|,
name|tZONE
block|,
literal|9
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"k"
block|,
name|tZONE
block|,
literal|10
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"l"
block|,
name|tZONE
block|,
literal|11
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"m"
block|,
name|tZONE
block|,
literal|12
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"n"
block|,
name|tZONE
block|,
operator|-
literal|1
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"o"
block|,
name|tZONE
block|,
operator|-
literal|2
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"p"
block|,
name|tZONE
block|,
operator|-
literal|3
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"q"
block|,
name|tZONE
block|,
operator|-
literal|4
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"r"
block|,
name|tZONE
block|,
operator|-
literal|5
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"s"
block|,
name|tZONE
block|,
operator|-
literal|6
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"t"
block|,
name|tZONE
block|,
operator|-
literal|7
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"u"
block|,
name|tZONE
block|,
operator|-
literal|8
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"v"
block|,
name|tZONE
block|,
operator|-
literal|9
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"w"
block|,
name|tZONE
block|,
operator|-
literal|10
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"x"
block|,
name|tZONE
block|,
operator|-
literal|11
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"y"
block|,
name|tZONE
block|,
operator|-
literal|12
operator|*
name|HOUR
block|}
block|,
block|{
literal|0
block|,
literal|"z"
block|,
name|tZONE
block|,
literal|0
operator|*
name|HOUR
block|}
block|,
comment|/* End of table. */
block|{
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Year is either:  *  = A number from 0 to 99, which means a year from 1970 to 2069, or  *  = The actual year (>=100).  */
end_comment

begin_function
specifier|static
name|time_t
name|Convert
parameter_list|(
name|time_t
name|Month
parameter_list|,
name|time_t
name|Day
parameter_list|,
name|time_t
name|Year
parameter_list|,
name|time_t
name|Hours
parameter_list|,
name|time_t
name|Minutes
parameter_list|,
name|time_t
name|Seconds
parameter_list|,
name|time_t
name|Timezone
parameter_list|,
name|enum
name|DSTMODE
name|DSTmode
parameter_list|)
block|{
name|signed
name|char
name|DaysInMonth
index|[
literal|12
index|]
init|=
block|{
literal|31
block|,
literal|0
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
name|time_t
name|Julian
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Year
operator|<
literal|69
condition|)
name|Year
operator|+=
literal|2000
expr_stmt|;
elseif|else
if|if
condition|(
name|Year
operator|<
literal|100
condition|)
name|Year
operator|+=
literal|1900
expr_stmt|;
name|DaysInMonth
index|[
literal|1
index|]
operator|=
name|Year
operator|%
literal|4
operator|==
literal|0
operator|&&
operator|(
name|Year
operator|%
literal|100
operator|!=
literal|0
operator|||
name|Year
operator|%
literal|400
operator|==
literal|0
operator|)
condition|?
literal|29
else|:
literal|28
expr_stmt|;
comment|/* Checking for 2038 bogusly assumes that time_t is 32 bits.  But 	   I'm too lazy to try to check for time_t overflow in another way.  */
if|if
condition|(
name|Year
operator|<
name|EPOCH
operator|||
name|Year
operator|>
literal|2038
operator|||
name|Month
operator|<
literal|1
operator|||
name|Month
operator|>
literal|12
comment|/* Lint fluff:  "conversion from long may lose accuracy" */
operator|||
name|Day
operator|<
literal|1
operator|||
name|Day
operator|>
name|DaysInMonth
index|[
operator|(
name|int
operator|)
operator|--
name|Month
index|]
operator|||
name|Hours
operator|<
literal|0
operator|||
name|Hours
operator|>
literal|23
operator|||
name|Minutes
operator|<
literal|0
operator|||
name|Minutes
operator|>
literal|59
operator|||
name|Seconds
operator|<
literal|0
operator|||
name|Seconds
operator|>
literal|59
condition|)
return|return
operator|-
literal|1
return|;
name|Julian
operator|=
name|Day
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Month
condition|;
name|i
operator|++
control|)
name|Julian
operator|+=
name|DaysInMonth
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|EPOCH
init|;
name|i
operator|<
name|Year
condition|;
name|i
operator|++
control|)
name|Julian
operator|+=
literal|365
operator|+
operator|(
name|i
operator|%
literal|4
operator|==
literal|0
operator|)
expr_stmt|;
name|Julian
operator|*=
name|DAY
expr_stmt|;
name|Julian
operator|+=
name|Timezone
expr_stmt|;
name|Julian
operator|+=
name|Hours
operator|*
name|HOUR
operator|+
name|Minutes
operator|*
name|MINUTE
operator|+
name|Seconds
expr_stmt|;
if|if
condition|(
name|DSTmode
operator|==
name|DSTon
operator|||
operator|(
name|DSTmode
operator|==
name|DSTmaybe
operator|&&
name|localtime
argument_list|(
operator|&
name|Julian
argument_list|)
operator|->
name|tm_isdst
operator|)
condition|)
name|Julian
operator|-=
name|HOUR
expr_stmt|;
return|return
name|Julian
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|DSTcorrect
parameter_list|(
name|time_t
name|Start
parameter_list|,
name|time_t
name|Future
parameter_list|)
block|{
name|time_t
name|StartDay
decl_stmt|;
name|time_t
name|FutureDay
decl_stmt|;
name|StartDay
operator|=
operator|(
name|localtime
argument_list|(
operator|&
name|Start
argument_list|)
operator|->
name|tm_hour
operator|+
literal|1
operator|)
operator|%
literal|24
expr_stmt|;
name|FutureDay
operator|=
operator|(
name|localtime
argument_list|(
operator|&
name|Future
argument_list|)
operator|->
name|tm_hour
operator|+
literal|1
operator|)
operator|%
literal|24
expr_stmt|;
return|return
operator|(
name|Future
operator|-
name|Start
operator|)
operator|+
operator|(
name|StartDay
operator|-
name|FutureDay
operator|)
operator|*
name|HOUR
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|RelativeDate
parameter_list|(
name|time_t
name|Start
parameter_list|,
name|time_t
name|zone
parameter_list|,
name|int
name|dstmode
parameter_list|,
name|time_t
name|DayOrdinal
parameter_list|,
name|time_t
name|DayNumber
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|time_t
name|t
decl_stmt|,
name|now
decl_stmt|;
name|t
operator|=
name|Start
operator|-
name|zone
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|now
operator|=
name|Start
expr_stmt|;
name|now
operator|+=
name|DAY
operator|*
operator|(
operator|(
name|DayNumber
operator|-
name|tm
operator|->
name|tm_wday
operator|+
literal|7
operator|)
operator|%
literal|7
operator|)
expr_stmt|;
name|now
operator|+=
literal|7
operator|*
name|DAY
operator|*
operator|(
name|DayOrdinal
operator|<=
literal|0
condition|?
name|DayOrdinal
else|:
name|DayOrdinal
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|dstmode
operator|==
name|DSTmaybe
condition|)
return|return
name|DSTcorrect
argument_list|(
name|Start
argument_list|,
name|now
argument_list|)
return|;
return|return
name|now
operator|-
name|Start
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|RelativeMonth
parameter_list|(
name|time_t
name|Start
parameter_list|,
name|time_t
name|Timezone
parameter_list|,
name|time_t
name|RelMonth
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|time_t
name|Month
decl_stmt|;
name|time_t
name|Year
decl_stmt|;
if|if
condition|(
name|RelMonth
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|Start
argument_list|)
expr_stmt|;
name|Month
operator|=
literal|12
operator|*
operator|(
name|tm
operator|->
name|tm_year
operator|+
literal|1900
operator|)
operator|+
name|tm
operator|->
name|tm_mon
operator|+
name|RelMonth
expr_stmt|;
name|Year
operator|=
name|Month
operator|/
literal|12
expr_stmt|;
name|Month
operator|=
name|Month
operator|%
literal|12
operator|+
literal|1
expr_stmt|;
return|return
name|DSTcorrect
argument_list|(
name|Start
argument_list|,
name|Convert
argument_list|(
name|Month
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_mday
argument_list|,
name|Year
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_hour
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_min
argument_list|,
operator|(
name|time_t
operator|)
name|tm
operator|->
name|tm_sec
argument_list|,
name|Timezone
argument_list|,
name|DSTmaybe
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tokenizer.  */
end_comment

begin_function
specifier|static
name|int
name|nexttoken
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|in
parameter_list|,
name|time_t
modifier|*
name|value
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|in
argument_list|)
condition|)
operator|++
operator|*
name|in
expr_stmt|;
comment|/* Skip parenthesized comments. */
if|if
condition|(
operator|*
operator|*
name|in
operator|==
literal|'('
condition|)
block|{
name|int
name|Count
init|=
literal|0
decl_stmt|;
do|do
block|{
name|c
operator|=
operator|*
operator|(
operator|*
name|in
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
name|c
return|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|Count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|Count
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|Count
operator|>
literal|0
condition|)
do|;
continue|continue;
block|}
comment|/* Try the next token in the word table first. */
comment|/* This allows us to match "2nd", for example. */
block|{
specifier|const
name|char
modifier|*
name|src
init|=
operator|*
name|in
decl_stmt|;
specifier|const
name|struct
name|LEXICON
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
comment|/* Force to lowercase and strip '.' characters. */
while|while
condition|(
operator|*
name|src
operator|!=
literal|'\0'
operator|&&
operator|(
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|src
argument_list|)
operator|||
operator|*
name|src
operator|==
literal|'.'
operator|)
operator|&&
name|i
operator|<
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|src
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|src
argument_list|)
condition|)
name|buff
index|[
name|i
operator|++
index|]
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|src
argument_list|)
expr_stmt|;
else|else
name|buff
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|src
expr_stmt|;
block|}
name|src
operator|++
expr_stmt|;
block|}
name|buff
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * Find the first match.  If the word can be 			 * abbreviated, make sure we match at least 			 * the minimum abbreviation. 			 */
for|for
control|(
name|tp
operator|=
name|TimeWords
init|;
name|tp
operator|->
name|name
condition|;
name|tp
operator|++
control|)
block|{
name|size_t
name|abbrev
init|=
name|tp
operator|->
name|abbrev
decl_stmt|;
if|if
condition|(
name|abbrev
operator|==
literal|0
condition|)
name|abbrev
operator|=
name|strlen
argument_list|(
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buff
argument_list|)
operator|>=
name|abbrev
operator|&&
name|strncmp
argument_list|(
name|tp
operator|->
name|name
argument_list|,
name|buff
argument_list|,
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Skip over token. */
operator|*
name|in
operator|=
name|src
expr_stmt|;
comment|/* Return the match. */
operator|*
name|value
operator|=
name|tp
operator|->
name|value
expr_stmt|;
return|return
name|tp
operator|->
name|type
return|;
block|}
block|}
block|}
comment|/* 		 * Not in the word table, maybe it's a number.  Note: 		 * Because '-' and '+' have other special meanings, I 		 * don't deal with signed numbers here. 		 */
if|if
condition|(
name|isdigit
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|=
operator|*
operator|*
name|in
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
operator|*
name|value
operator|=
literal|0
init|;
name|isdigit
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|c
operator|=
operator|*
operator|(
operator|*
name|in
operator|)
operator|++
argument_list|)
argument_list|)
condition|;
control|)
operator|*
name|value
operator|=
literal|10
operator|*
operator|*
name|value
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|in
operator|)
operator|--
expr_stmt|;
return|return
operator|(
name|tUNUMBER
operator|)
return|;
block|}
return|return
operator|*
operator|(
operator|*
name|in
operator|)
operator|++
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|TM_YEAR_ORIGIN
value|1900
end_define

begin_comment
comment|/* Yield A - B, measured in seconds.  */
end_comment

begin_function
specifier|static
name|long
name|difftm
parameter_list|(
name|struct
name|tm
modifier|*
name|a
parameter_list|,
name|struct
name|tm
modifier|*
name|b
parameter_list|)
block|{
name|int
name|ay
init|=
name|a
operator|->
name|tm_year
operator|+
operator|(
name|TM_YEAR_ORIGIN
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|by
init|=
name|b
operator|->
name|tm_year
operator|+
operator|(
name|TM_YEAR_ORIGIN
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|days
init|=
operator|(
comment|/* difference in day of year */
name|a
operator|->
name|tm_yday
operator|-
name|b
operator|->
name|tm_yday
comment|/* + intervening leap days */
operator|+
operator|(
operator|(
name|ay
operator|>>
literal|2
operator|)
operator|-
operator|(
name|by
operator|>>
literal|2
operator|)
operator|)
operator|-
operator|(
name|ay
operator|/
literal|100
operator|-
name|by
operator|/
literal|100
operator|)
operator|+
operator|(
operator|(
name|ay
operator|/
literal|100
operator|>>
literal|2
operator|)
operator|-
operator|(
name|by
operator|/
literal|100
operator|>>
literal|2
operator|)
operator|)
comment|/* + difference in years * 365 */
operator|+
call|(
name|long
call|)
argument_list|(
name|ay
operator|-
name|by
argument_list|)
operator|*
literal|365
operator|)
decl_stmt|;
return|return
operator|(
name|days
operator|*
name|DAY
operator|+
operator|(
name|a
operator|->
name|tm_hour
operator|-
name|b
operator|->
name|tm_hour
operator|)
operator|*
name|HOUR
operator|+
operator|(
name|a
operator|->
name|tm_min
operator|-
name|b
operator|->
name|tm_min
operator|)
operator|*
name|MINUTE
operator|+
operator|(
name|a
operator|->
name|tm_sec
operator|-
name|b
operator|->
name|tm_sec
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  * The public function.  *  * TODO: tokens[] array should be dynamically sized.  */
end_comment

begin_function
name|time_t
name|__archive_get_date
parameter_list|(
name|time_t
name|now
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|token
name|tokens
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|gdstate
name|_gds
decl_stmt|;
name|struct
name|token
modifier|*
name|lasttoken
decl_stmt|;
name|struct
name|gdstate
modifier|*
name|gds
decl_stmt|;
name|struct
name|tm
name|local
decl_stmt|,
modifier|*
name|tm
decl_stmt|;
name|struct
name|tm
name|gmt
decl_stmt|,
modifier|*
name|gmt_ptr
decl_stmt|;
name|time_t
name|Start
decl_stmt|;
name|time_t
name|tod
decl_stmt|;
name|long
name|tzone
decl_stmt|;
comment|/* Clear out the parsed token array. */
name|memset
argument_list|(
name|tokens
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tokens
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the parser state. */
name|memset
argument_list|(
operator|&
name|_gds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|_gds
argument_list|)
argument_list|)
expr_stmt|;
name|gds
operator|=
operator|&
name|_gds
expr_stmt|;
comment|/* Look up the current time. */
name|memset
argument_list|(
operator|&
name|local
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|local
operator|=
operator|*
name|tm
expr_stmt|;
comment|/* Look up UTC if we can and use that to determine the current 	 * timezone offset. */
name|memset
argument_list|(
operator|&
name|gmt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gmt
argument_list|)
argument_list|)
expr_stmt|;
name|gmt_ptr
operator|=
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmt_ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* Copy, in case localtime and gmtime use the same buffer. */
name|gmt
operator|=
operator|*
name|gmt_ptr
expr_stmt|;
block|}
if|if
condition|(
name|gmt_ptr
operator|!=
name|NULL
condition|)
name|tzone
operator|=
name|difftm
argument_list|(
operator|&
name|gmt
argument_list|,
operator|&
name|local
argument_list|)
expr_stmt|;
else|else
comment|/* This system doesn't understand timezones; fake it. */
name|tzone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|local
operator|.
name|tm_isdst
condition|)
name|tzone
operator|+=
name|HOUR
expr_stmt|;
comment|/* Tokenize the input string. */
name|lasttoken
operator|=
name|tokens
expr_stmt|;
while|while
condition|(
operator|(
name|lasttoken
operator|->
name|token
operator|=
name|nexttoken
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|lasttoken
operator|->
name|value
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|++
name|lasttoken
expr_stmt|;
if|if
condition|(
name|lasttoken
operator|>
name|tokens
operator|+
literal|255
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|gds
operator|->
name|tokenp
operator|=
name|tokens
expr_stmt|;
comment|/* Match phrases until we run out of input tokens. */
while|while
condition|(
name|gds
operator|->
name|tokenp
operator|<
name|lasttoken
condition|)
block|{
if|if
condition|(
operator|!
name|phrase
argument_list|(
name|gds
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Use current local timezone if none was specified. */
if|if
condition|(
operator|!
name|gds
operator|->
name|HaveZone
condition|)
block|{
name|gds
operator|->
name|Timezone
operator|=
name|tzone
expr_stmt|;
name|gds
operator|->
name|DSTmode
operator|=
name|DSTmaybe
expr_stmt|;
block|}
comment|/* If a timezone was specified, use that for generating the default 	 * time components instead of the local timezone. */
if|if
condition|(
name|gds
operator|->
name|HaveZone
operator|&&
name|gmt_ptr
operator|!=
name|NULL
condition|)
block|{
name|now
operator|-=
name|gds
operator|->
name|Timezone
expr_stmt|;
name|gmt_ptr
operator|=
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmt_ptr
operator|!=
name|NULL
condition|)
name|local
operator|=
operator|*
name|gmt_ptr
expr_stmt|;
name|now
operator|+=
name|gds
operator|->
name|Timezone
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gds
operator|->
name|HaveYear
condition|)
name|gds
operator|->
name|Year
operator|=
name|local
operator|.
name|tm_year
operator|+
literal|1900
expr_stmt|;
if|if
condition|(
operator|!
name|gds
operator|->
name|HaveMonth
condition|)
name|gds
operator|->
name|Month
operator|=
name|local
operator|.
name|tm_mon
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|gds
operator|->
name|HaveDay
condition|)
name|gds
operator|->
name|Day
operator|=
name|local
operator|.
name|tm_mday
expr_stmt|;
comment|/* Note: No default for hour/min/sec; a specifier that just 	 * gives date always refers to 00:00 on that date. */
comment|/* If we saw more than one time, timezone, weekday, year, month, 	 * or day, then give up. */
if|if
condition|(
name|gds
operator|->
name|HaveTime
operator|>
literal|1
operator|||
name|gds
operator|->
name|HaveZone
operator|>
literal|1
operator|||
name|gds
operator|->
name|HaveWeekDay
operator|>
literal|1
operator|||
name|gds
operator|->
name|HaveYear
operator|>
literal|1
operator|||
name|gds
operator|->
name|HaveMonth
operator|>
literal|1
operator|||
name|gds
operator|->
name|HaveDay
operator|>
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Compute an absolute time based on whatever absolute information 	 * we collected. */
if|if
condition|(
name|gds
operator|->
name|HaveYear
operator|||
name|gds
operator|->
name|HaveMonth
operator|||
name|gds
operator|->
name|HaveDay
operator|||
name|gds
operator|->
name|HaveTime
operator|||
name|gds
operator|->
name|HaveWeekDay
condition|)
block|{
name|Start
operator|=
name|Convert
argument_list|(
name|gds
operator|->
name|Month
argument_list|,
name|gds
operator|->
name|Day
argument_list|,
name|gds
operator|->
name|Year
argument_list|,
name|gds
operator|->
name|Hour
argument_list|,
name|gds
operator|->
name|Minutes
argument_list|,
name|gds
operator|->
name|Seconds
argument_list|,
name|gds
operator|->
name|Timezone
argument_list|,
name|gds
operator|->
name|DSTmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|Start
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|Start
operator|=
name|now
expr_stmt|;
if|if
condition|(
operator|!
name|gds
operator|->
name|HaveRel
condition|)
name|Start
operator|-=
name|local
operator|.
name|tm_hour
operator|*
name|HOUR
operator|+
name|local
operator|.
name|tm_min
operator|*
name|MINUTE
operator|+
name|local
operator|.
name|tm_sec
expr_stmt|;
block|}
comment|/* Add the relative offset. */
name|Start
operator|+=
name|gds
operator|->
name|RelSeconds
expr_stmt|;
name|Start
operator|+=
name|RelativeMonth
argument_list|(
name|Start
argument_list|,
name|gds
operator|->
name|Timezone
argument_list|,
name|gds
operator|->
name|RelMonth
argument_list|)
expr_stmt|;
comment|/* Adjust for day-of-week offsets. */
if|if
condition|(
name|gds
operator|->
name|HaveWeekDay
operator|&&
operator|!
operator|(
name|gds
operator|->
name|HaveYear
operator|||
name|gds
operator|->
name|HaveMonth
operator|||
name|gds
operator|->
name|HaveDay
operator|)
condition|)
block|{
name|tod
operator|=
name|RelativeDate
argument_list|(
name|Start
argument_list|,
name|gds
operator|->
name|Timezone
argument_list|,
name|gds
operator|->
name|DSTmode
argument_list|,
name|gds
operator|->
name|DayOrdinal
argument_list|,
name|gds
operator|->
name|DayNumber
argument_list|)
expr_stmt|;
name|Start
operator|+=
name|tod
expr_stmt|;
block|}
comment|/* -1 is an error indicator, so return 0 instead of -1 if 	 * that's the actual time. */
return|return
name|Start
operator|==
operator|-
literal|1
condition|?
literal|0
else|:
name|Start
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST
argument_list|)
end_if

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|time_t
name|d
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
operator|++
name|argv
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Input: %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_date
argument_list|(
name|now
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Bad format - couldn't convert.\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Output: %s\n"
argument_list|,
name|ctime
argument_list|(
operator|&
name|d
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(TEST) */
end_comment

end_unit

