begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2011 Tim Kientzle  * Copyright (c) 2011-2012 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD: head/lib/libarchive/archive_string.c 201095 2009-12-28 02:33:22Z kientzle $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Basic resizable string support, to simplify manipulating arbitrary-sized  * strings while minimizing heap activity.  *  * In particular, the buffer used by a string object is only grown, it  * never shrinks, so you can clear and reuse the same string object  * without incurring additional memory allocations.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ICONV_H
end_ifdef

begin_include
include|#
directive|include
file|<iconv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LANGINFO_H
end_ifdef

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LOCALCHARSET_H
end_ifdef

begin_include
include|#
directive|include
file|<localcharset.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WCHAR_H
end_ifdef

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive_endian.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_string.h"
end_include

begin_include
include|#
directive|include
file|"archive_string_composition.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_WMEMCPY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|wmemcpy
argument_list|)
end_if

begin_define
define|#
directive|define
name|wmemcpy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|i
parameter_list|)
value|(wchar_t *)memcpy((a), (b), (i) * sizeof(wchar_t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_WMEMMOVE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|wmemmove
argument_list|)
end_if

begin_define
define|#
directive|define
name|wmemmove
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|i
parameter_list|)
value|(wchar_t *)memmove((a), (b), (i) * sizeof(wchar_t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|archive_string_conv
block|{
name|struct
name|archive_string_conv
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|from_charset
decl_stmt|;
name|char
modifier|*
name|to_charset
decl_stmt|;
name|unsigned
name|from_cp
decl_stmt|;
name|unsigned
name|to_cp
decl_stmt|;
comment|/* Set 1 if from_charset and to_charset are the same. */
name|int
name|same
decl_stmt|;
name|int
name|flag
decl_stmt|;
define|#
directive|define
name|SCONV_TO_CHARSET
value|1
comment|/* MBS is being converted to specified 					 * charset. */
define|#
directive|define
name|SCONV_FROM_CHARSET
value|(1<<1)
comment|/* MBS is being converted from 					 * specified charset. */
define|#
directive|define
name|SCONV_BEST_EFFORT
value|(1<<2)
comment|/* Copy at least ASCII code. */
define|#
directive|define
name|SCONV_WIN_CP
value|(1<<3)
comment|/* Use Windows API for converting 					 * MBS. */
define|#
directive|define
name|SCONV_UTF8_LIBARCHIVE_2
value|(1<<4)
comment|/* Incorrect UTF-8 made by libarchive 					 * 2.x in the wrong assumption. */
define|#
directive|define
name|SCONV_NORMALIZATION_C
value|(1<<6)
comment|/* Need normalization to be Form C. 					 * Before UTF-8 characters are actually 					 * processed. */
define|#
directive|define
name|SCONV_NORMALIZATION_D
value|(1<<7)
comment|/* Need normalization to be Form D. 					 * Before UTF-8 characters are actually 					 * processed. 					 * Currently this only for MAC OS X. */
define|#
directive|define
name|SCONV_TO_UTF8
value|(1<<8)
comment|/* "to charset" side is UTF-8. */
define|#
directive|define
name|SCONV_FROM_UTF8
value|(1<<9)
comment|/* "from charset" side is UTF-8. */
define|#
directive|define
name|SCONV_TO_UTF16BE
value|(1<<10)
comment|/* "to charset" side is UTF-16BE. */
define|#
directive|define
name|SCONV_FROM_UTF16BE
value|(1<<11)
comment|/* "from charset" side is UTF-16BE. */
define|#
directive|define
name|SCONV_TO_UTF16LE
value|(1<<12)
comment|/* "to charset" side is UTF-16LE. */
define|#
directive|define
name|SCONV_FROM_UTF16LE
value|(1<<13)
comment|/* "from charset" side is UTF-16LE. */
define|#
directive|define
name|SCONV_TO_UTF16
value|(SCONV_TO_UTF16BE | SCONV_TO_UTF16LE)
define|#
directive|define
name|SCONV_FROM_UTF16
value|(SCONV_FROM_UTF16BE | SCONV_FROM_UTF16LE)
if|#
directive|if
name|HAVE_ICONV
name|iconv_t
name|cd
decl_stmt|;
name|iconv_t
name|cd_w
decl_stmt|;
comment|/* Use at archive_mstring on 				 	       * Windows. */
endif|#
directive|endif
comment|/* A temporary buffer for normalization. */
name|struct
name|archive_string
name|utftmp
decl_stmt|;
name|int
function_decl|(
modifier|*
name|converter
index|[
literal|2
index|]
function_decl|)
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
name|int
name|nconverter
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CP_C_LOCALE
value|0
end_define

begin_comment
comment|/* "C" locale only for this file. */
end_comment

begin_define
define|#
directive|define
name|CP_UTF16LE
value|1200
end_define

begin_define
define|#
directive|define
name|CP_UTF16BE
value|1201
end_define

begin_define
define|#
directive|define
name|IS_HIGH_SURROGATE_LA
parameter_list|(
name|uc
parameter_list|)
value|((uc)>= 0xD800&& (uc)<= 0xDBFF)
end_define

begin_define
define|#
directive|define
name|IS_LOW_SURROGATE_LA
parameter_list|(
name|uc
parameter_list|)
value|((uc)>= 0xDC00&& (uc)<= 0xDFFF)
end_define

begin_define
define|#
directive|define
name|IS_SURROGATE_PAIR_LA
parameter_list|(
name|uc
parameter_list|)
value|((uc)>= 0xD800&& (uc)<= 0xDFFF)
end_define

begin_define
define|#
directive|define
name|UNICODE_MAX
value|0x10FFFF
end_define

begin_define
define|#
directive|define
name|UNICODE_R_CHAR
value|0xFFFD
end_define

begin_comment
comment|/* Replacement character. */
end_comment

begin_comment
comment|/* Set U+FFFD(Replacement character) in UTF-8. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|utf8_replacement_char
index|[]
init|=
block|{
literal|0xef
block|,
literal|0xbf
block|,
literal|0xbd
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|archive_string_conv
modifier|*
name|find_sconv_object
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_sconv_object
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|archive_string_conv
modifier|*
name|create_sconv_object
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_sconv_object
parameter_list|(
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|archive_string_conv
modifier|*
name|get_sconv_object
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|make_codepage_from_charset
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|get_current_codepage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|get_current_oemcp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|mbsnbytes
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|utf16nbytes
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|archive_wstring_append_from_mbs_in_codepage
parameter_list|(
name|struct
name|archive_wstring
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_string_append_from_wcs_in_codepage
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_big_endian
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|strncat_in_codepage
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|win_strncat_from_utf16be
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|win_strncat_from_utf16le
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|win_strncat_to_utf16be
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|win_strncat_to_utf16le
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|best_effort_strncat_from_utf16be
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|best_effort_strncat_from_utf16le
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|best_effort_strncat_to_utf16be
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|best_effort_strncat_to_utf16le
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ICONV
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|iconv_strncat_in_locale
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|best_effort_strncat_in_locale
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_utf8_to_unicode
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|utf8_to_unicode
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|uint32_t
name|combine_surrogate_pair
parameter_list|(
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cesu8_to_unicode
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|unicode_to_utf8
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|utf16_to_unicode
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|unicode_to_utf16be
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|unicode_to_utf16le
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|strncat_from_utf8_libarchive2
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|strncat_from_utf8_to_utf8
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_string_normalize_C
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_string_normalize_D
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_string_append_unicode
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|archive_string
modifier|*
name|archive_string_append
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|s
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|s
condition|)
name|memmove
argument_list|(
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|as
operator|->
name|length
operator|+=
name|s
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|as
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|archive_wstring
modifier|*
name|archive_wstring_append
parameter_list|(
name|struct
name|archive_wstring
modifier|*
name|as
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
if|if
condition|(
name|archive_wstring_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|s
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|wmemmove
argument_list|(
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|as
operator|->
name|length
operator|+=
name|s
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|as
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|archive_string
modifier|*
name|archive_array_append
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
name|archive_string_append
argument_list|(
name|as
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|archive_string_concat
parameter_list|(
name|struct
name|archive_string
modifier|*
name|dest
parameter_list|,
name|struct
name|archive_string
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
name|archive_string_append
argument_list|(
name|dest
argument_list|,
name|src
operator|->
name|s
argument_list|,
name|src
operator|->
name|length
argument_list|)
operator|==
name|NULL
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|archive_wstring_concat
parameter_list|(
name|struct
name|archive_wstring
modifier|*
name|dest
parameter_list|,
name|struct
name|archive_wstring
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
name|archive_wstring_append
argument_list|(
name|dest
argument_list|,
name|src
operator|->
name|s
argument_list|,
name|src
operator|->
name|length
argument_list|)
operator|==
name|NULL
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|archive_string_free
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|)
block|{
name|as
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|as
operator|->
name|buffer_length
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|as
operator|->
name|s
argument_list|)
expr_stmt|;
name|as
operator|->
name|s
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|archive_wstring_free
parameter_list|(
name|struct
name|archive_wstring
modifier|*
name|as
parameter_list|)
block|{
name|as
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|as
operator|->
name|buffer_length
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|as
operator|->
name|s
argument_list|)
expr_stmt|;
name|as
operator|->
name|s
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|archive_wstring
modifier|*
name|archive_wstring_ensure
parameter_list|(
name|struct
name|archive_wstring
modifier|*
name|as
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|archive_wstring
operator|*
operator|)
name|archive_string_ensure
argument_list|(
operator|(
expr|struct
name|archive_string
operator|*
operator|)
name|as
argument_list|,
name|s
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns NULL on any allocation failure. */
end_comment

begin_function
name|struct
name|archive_string
modifier|*
name|archive_string_ensure
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|new_length
decl_stmt|;
comment|/* If buffer is already big enough, don't reallocate. */
if|if
condition|(
name|as
operator|->
name|s
operator|&&
operator|(
name|s
operator|<=
name|as
operator|->
name|buffer_length
operator|)
condition|)
return|return
operator|(
name|as
operator|)
return|;
comment|/* 	 * Growing the buffer at least exponentially ensures that 	 * append operations are always linear in the number of 	 * characters appended.  Using a smaller growth rate for 	 * larger buffers reduces memory waste somewhat at the cost of 	 * a larger constant factor. 	 */
if|if
condition|(
name|as
operator|->
name|buffer_length
operator|<
literal|32
condition|)
comment|/* Start with a minimum 32-character buffer. */
name|new_length
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|as
operator|->
name|buffer_length
operator|<
literal|8192
condition|)
comment|/* Buffers under 8k are doubled for speed. */
name|new_length
operator|=
name|as
operator|->
name|buffer_length
operator|+
name|as
operator|->
name|buffer_length
expr_stmt|;
else|else
block|{
comment|/* Buffers 8k and over grow by at least 25% each time. */
name|new_length
operator|=
name|as
operator|->
name|buffer_length
operator|+
name|as
operator|->
name|buffer_length
operator|/
literal|4
expr_stmt|;
comment|/* Be safe: If size wraps, fail. */
if|if
condition|(
name|new_length
operator|<
name|as
operator|->
name|buffer_length
condition|)
block|{
comment|/* On failure, wipe the string and return NULL. */
name|archive_string_free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
comment|/* Make sure errno has ENOMEM. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * The computation above is a lower limit to how much we'll 	 * grow the buffer.  In any case, we have to grow it enough to 	 * hold the request. 	 */
if|if
condition|(
name|new_length
operator|<
name|s
condition|)
name|new_length
operator|=
name|s
expr_stmt|;
comment|/* Now we can reallocate the buffer. */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|as
operator|->
name|s
argument_list|,
name|new_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* On failure, wipe the string and return NULL. */
name|archive_string_free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
comment|/* Make sure errno has ENOMEM. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|as
operator|->
name|s
operator|=
name|p
expr_stmt|;
name|as
operator|->
name|buffer_length
operator|=
name|new_length
expr_stmt|;
return|return
operator|(
name|as
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: See if there's a way to avoid scanning  * the source string twice.  Then test to see  * if it actually helps (remember that we're almost  * always called with pretty short arguments, so  * such an optimization might not help).  */
end_comment

begin_function
name|struct
name|archive_string
modifier|*
name|archive_strncat
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
expr_stmt|;
comment|/* Like strlen(p), except won't examine positions beyond p[n]. */
name|s
operator|=
literal|0
expr_stmt|;
name|pp
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|n
operator|&&
operator|*
name|pp
condition|)
block|{
name|pp
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|as
operator|=
name|archive_string_append
argument_list|(
name|as
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|as
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|archive_wstring
modifier|*
name|archive_wstrncat
parameter_list|(
name|struct
name|archive_wstring
modifier|*
name|as
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|pp
decl_stmt|;
comment|/* Like strlen(p), except won't examine positions beyond p[n]. */
name|s
operator|=
literal|0
expr_stmt|;
name|pp
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|n
operator|&&
operator|*
name|pp
condition|)
block|{
name|pp
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|as
operator|=
name|archive_wstring_append
argument_list|(
name|as
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|as
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|archive_string
modifier|*
name|archive_strcat
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
comment|/* strcat is just strncat without an effective limit.  	 * Assert that we'll never get called with a source 	 * string over 16MB. 	 * TODO: Review all uses of strcat in the source 	 * and try to replace them with strncat(). 	 */
return|return
name|archive_strncat
argument_list|(
name|as
argument_list|,
name|p
argument_list|,
literal|0x1000000
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|archive_wstring
modifier|*
name|archive_wstrcat
parameter_list|(
name|struct
name|archive_wstring
modifier|*
name|as
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* Ditto. */
return|return
name|archive_wstrncat
argument_list|(
name|as
argument_list|,
name|p
argument_list|,
literal|0x1000000
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|archive_string
modifier|*
name|archive_strappend_char
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|as
operator|=
name|archive_string_append
argument_list|(
name|as
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|as
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|archive_wstring
modifier|*
name|archive_wstrappend_wchar
parameter_list|(
name|struct
name|archive_wstring
modifier|*
name|as
parameter_list|,
name|wchar_t
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|as
operator|=
name|archive_wstring_append
argument_list|(
name|as
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|as
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the "current character set" name to use with iconv.  * On FreeBSD, the empty character set name "" chooses  * the correct character encoding for the current locale,  * so this isn't necessary.  * But iconv on Mac OS 10.6 doesn't seem to handle this correctly;  * on that system, we have to explicitly call nl_langinfo()  * to get the right name.  Not sure about other platforms.  *  * NOTE: GNU libiconv does not recognize the character-set name  * which some platform nl_langinfo(CODESET) returns, so we should  * use locale_charset() instead of nl_langinfo(CODESET) for GNU libiconv.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|default_iconv_charset
parameter_list|(
specifier|const
name|char
modifier|*
name|charset
parameter_list|)
block|{
if|if
condition|(
name|charset
operator|!=
name|NULL
operator|&&
name|charset
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|charset
return|;
if|#
directive|if
name|HAVE_LOCALE_CHARSET
operator|&&
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
comment|/* locale_charset() is broken on Mac OS */
return|return
name|locale_charset
argument_list|()
return|;
elif|#
directive|elif
name|HAVE_NL_LANGINFO
return|return
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
return|;
else|#
directive|else
return|return
literal|""
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_comment
comment|/*  * Convert MBS to WCS.  * Note: returns -1 if conversion fails.  */
end_comment

begin_function
name|int
name|archive_wstring_append_from_mbs
parameter_list|(
name|struct
name|archive_wstring
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|archive_wstring_append_from_mbs_in_codepage
argument_list|(
name|dest
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_wstring_append_from_mbs_in_codepage
parameter_list|(
name|struct
name|archive_wstring
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|UINT
name|from_cp
decl_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|from_cp
operator|=
name|sc
operator|->
name|from_cp
expr_stmt|;
else|else
name|from_cp
operator|=
name|get_current_codepage
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_cp
operator|==
name|CP_C_LOCALE
condition|)
block|{
comment|/* 		 * "C" locale special process. 		 */
name|wchar_t
modifier|*
name|ws
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|archive_wstring_ensure
argument_list|(
name|dest
argument_list|,
name|dest
operator|->
name|length
operator|+
name|length
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ws
operator|=
name|dest
operator|->
name|s
operator|+
name|dest
operator|->
name|length
expr_stmt|;
name|mp
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
operator|(
name|int
operator|)
name|length
operator|&&
operator|*
name|mp
condition|)
block|{
operator|*
name|ws
operator|++
operator|=
operator|(
name|wchar_t
operator|)
operator|*
name|mp
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|!=
name|NULL
operator|&&
operator|(
name|sc
operator|->
name|flag
operator|&
operator|(
name|SCONV_NORMALIZATION_C
operator||
name|SCONV_NORMALIZATION_D
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Normalize UTF-8 and UTF-16BE and convert it directly 		 * to UTF-16 as wchar_t. 		 */
name|struct
name|archive_string
name|u16
decl_stmt|;
name|int
name|saved_flag
init|=
name|sc
operator|->
name|flag
decl_stmt|;
comment|/* save current flag. */
if|if
condition|(
name|is_big_endian
argument_list|()
condition|)
name|sc
operator|->
name|flag
operator||=
name|SCONV_TO_UTF16BE
expr_stmt|;
else|else
name|sc
operator|->
name|flag
operator||=
name|SCONV_TO_UTF16LE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16
condition|)
block|{
comment|/* 			 *  UTF-16BE/LE NFD ===> UTF-16 NFC 			 *  UTF-16BE/LE NFC ===> UTF-16 NFD 			 */
name|count
operator|=
operator|(
name|int
operator|)
name|utf16nbytes
argument_list|(
name|s
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *  UTF-8 NFD ===> UTF-16 NFC 			 *  UTF-8 NFC ===> UTF-16 NFD 			 */
name|count
operator|=
operator|(
name|int
operator|)
name|mbsnbytes
argument_list|(
name|s
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|u16
operator|.
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|dest
operator|->
name|s
expr_stmt|;
name|u16
operator|.
name|length
operator|=
name|dest
operator|->
name|length
operator|<<
literal|1
expr_stmt|;
empty_stmt|;
name|u16
operator|.
name|buffer_length
operator|=
name|dest
operator|->
name|buffer_length
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_NORMALIZATION_C
condition|)
name|ret
operator|=
name|archive_string_normalize_C
argument_list|(
operator|&
name|u16
argument_list|,
name|s
argument_list|,
name|count
argument_list|,
name|sc
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|archive_string_normalize_D
argument_list|(
operator|&
name|u16
argument_list|,
name|s
argument_list|,
name|count
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|dest
operator|->
name|s
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|u16
operator|.
name|s
expr_stmt|;
name|dest
operator|->
name|length
operator|=
name|u16
operator|.
name|length
operator|>>
literal|1
expr_stmt|;
name|dest
operator|->
name|buffer_length
operator|=
name|u16
operator|.
name|buffer_length
expr_stmt|;
name|sc
operator|->
name|flag
operator|=
name|saved_flag
expr_stmt|;
comment|/* restore the saved flag. */
return|return
operator|(
name|ret
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|!=
name|NULL
operator|&&
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16
operator|)
condition|)
block|{
name|count
operator|=
operator|(
name|int
operator|)
name|utf16nbytes
argument_list|(
name|s
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|count
operator|>>=
literal|1
expr_stmt|;
comment|/* to be WCS length */
comment|/* Allocate memory for WCS. */
if|if
condition|(
name|NULL
operator|==
name|archive_wstring_ensure
argument_list|(
name|dest
argument_list|,
name|dest
operator|->
name|length
operator|+
name|count
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wmemcpy
argument_list|(
name|dest
operator|->
name|s
operator|+
name|dest
operator|->
name|length
argument_list|,
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|s
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16BE
operator|)
operator|&&
operator|!
name|is_big_endian
argument_list|()
condition|)
block|{
name|uint16_t
modifier|*
name|u16
init|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|dest
operator|->
name|s
operator|+
name|dest
operator|->
name|length
operator|)
decl_stmt|;
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|count
condition|;
name|b
operator|++
control|)
block|{
name|uint16_t
name|val
init|=
name|archive_le16dec
argument_list|(
name|u16
operator|+
name|b
argument_list|)
decl_stmt|;
name|archive_be16enc
argument_list|(
name|u16
operator|+
name|b
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16LE
operator|)
operator|&&
name|is_big_endian
argument_list|()
condition|)
block|{
name|uint16_t
modifier|*
name|u16
init|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|dest
operator|->
name|s
operator|+
name|dest
operator|->
name|length
operator|)
decl_stmt|;
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|count
condition|;
name|b
operator|++
control|)
block|{
name|uint16_t
name|val
init|=
name|archive_be16dec
argument_list|(
name|u16
operator|+
name|b
argument_list|)
decl_stmt|;
name|archive_le16enc
argument_list|(
name|u16
operator|+
name|b
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|DWORD
name|mbflag
decl_stmt|;
name|size_t
name|buffsize
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
name|mbflag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_CHARSET
condition|)
block|{
comment|/* Do not trust the length which comes from 			 * an archive file. */
name|length
operator|=
name|mbsnbytes
argument_list|(
name|s
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|mbflag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|mbflag
operator|=
name|MB_PRECOMPOSED
expr_stmt|;
name|buffsize
operator|=
name|dest
operator|->
name|length
operator|+
name|length
operator|+
literal|1
expr_stmt|;
do|do
block|{
comment|/* Allocate memory for WCS. */
if|if
condition|(
name|NULL
operator|==
name|archive_wstring_ensure
argument_list|(
name|dest
argument_list|,
name|buffsize
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Convert MBS to WCS. */
name|count
operator|=
name|MultiByteToWideChar
argument_list|(
name|from_cp
argument_list|,
name|mbflag
argument_list|,
name|s
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|,
name|dest
operator|->
name|s
operator|+
name|dest
operator|->
name|length
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dest
operator|->
name|buffer_length
operator|>>
literal|1
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|GetLastError
argument_list|()
operator|==
name|ERROR_INSUFFICIENT_BUFFER
condition|)
block|{
comment|/* Expand the WCS buffer. */
name|buffsize
operator|=
name|dest
operator|->
name|buffer_length
operator|<<
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|length
operator|!=
literal|0
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
name|dest
operator|->
name|length
operator|+=
name|count
expr_stmt|;
name|dest
operator|->
name|s
index|[
name|dest
operator|->
name|length
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Convert MBS to WCS.  * Note: returns -1 if conversion fails.  */
end_comment

begin_function
name|int
name|archive_wstring_append_from_mbs
parameter_list|(
name|struct
name|archive_wstring
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|r
decl_stmt|;
name|int
name|ret_val
init|=
literal|0
decl_stmt|;
comment|/* 	 * No single byte will be more than one wide character, 	 * so this length estimate will always be big enough. 	 */
name|size_t
name|wcs_length
init|=
name|len
decl_stmt|;
name|size_t
name|mbs_length
init|=
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|mbs
init|=
name|p
decl_stmt|;
name|wchar_t
modifier|*
name|wcs
decl_stmt|;
if|#
directive|if
name|HAVE_MBRTOWC
name|mbstate_t
name|shift_state
decl_stmt|;
name|memset
argument_list|(
operator|&
name|shift_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|shift_state
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|NULL
operator|==
name|archive_wstring_ensure
argument_list|(
name|dest
argument_list|,
name|dest
operator|->
name|length
operator|+
name|wcs_length
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wcs
operator|=
name|dest
operator|->
name|s
operator|+
name|dest
operator|->
name|length
expr_stmt|;
comment|/* 	 * We cannot use mbsrtowcs/mbstowcs here because those may convert 	 * extra MBS when strlen(p)> len and one wide character consists of 	 * multi bytes. 	 */
while|while
condition|(
operator|*
name|mbs
operator|&&
name|mbs_length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|wcs_length
operator|==
literal|0
condition|)
block|{
name|dest
operator|->
name|length
operator|=
name|wcs
operator|-
name|dest
operator|->
name|s
expr_stmt|;
name|dest
operator|->
name|s
index|[
name|dest
operator|->
name|length
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
name|wcs_length
operator|=
name|mbs_length
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|archive_wstring_ensure
argument_list|(
name|dest
argument_list|,
name|dest
operator|->
name|length
operator|+
name|wcs_length
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wcs
operator|=
name|dest
operator|->
name|s
operator|+
name|dest
operator|->
name|length
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_MBRTOWC
name|r
operator|=
name|mbrtowc
argument_list|(
name|wcs
argument_list|,
name|mbs
argument_list|,
name|wcs_length
argument_list|,
operator|&
name|shift_state
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|mbtowc
argument_list|(
name|wcs
argument_list|,
name|mbs
argument_list|,
name|wcs_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|r
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
block|{
name|ret_val
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EILSEQ
condition|)
block|{
operator|++
name|mbs
expr_stmt|;
operator|--
name|mbs_length
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|r
operator|==
literal|0
operator|||
name|r
operator|>
name|mbs_length
condition|)
break|break;
name|wcs
operator|++
expr_stmt|;
name|wcs_length
operator|--
expr_stmt|;
name|mbs
operator|+=
name|r
expr_stmt|;
name|mbs_length
operator|-=
name|r
expr_stmt|;
block|}
name|dest
operator|->
name|length
operator|=
name|wcs
operator|-
name|dest
operator|->
name|s
expr_stmt|;
name|dest
operator|->
name|s
index|[
name|dest
operator|->
name|length
index|]
operator|=
literal|L'
expr|\0'
expr_stmt|;
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_comment
comment|/*  * WCS ==> MBS.  * Note: returns -1 if conversion fails.  *  * Win32 builds use WideCharToMultiByte from the Windows API.  * (Maybe Cygwin should too?  WideCharToMultiByte will know a  * lot more about local character encodings than the wcrtomb()  * wrapper is going to know.)  */
end_comment

begin_function
name|int
name|archive_string_append_from_wcs
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|w
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|archive_string_append_from_wcs_in_codepage
argument_list|(
name|as
argument_list|,
name|w
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_string_append_from_wcs_in_codepage
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|ws
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|BOOL
name|defchar_used
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|count
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|UINT
name|to_cp
decl_stmt|;
name|int
name|wslen
init|=
operator|(
name|int
operator|)
name|len
decl_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|to_cp
operator|=
name|sc
operator|->
name|to_cp
expr_stmt|;
else|else
name|to_cp
operator|=
name|get_current_codepage
argument_list|()
expr_stmt|;
if|if
condition|(
name|to_cp
operator|==
name|CP_C_LOCALE
condition|)
block|{
comment|/* 		 * "C" locale special process. 		 */
specifier|const
name|wchar_t
modifier|*
name|wp
init|=
name|ws
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|wslen
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|defchar_used
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|wslen
operator|&&
operator|*
name|wp
condition|)
block|{
if|if
condition|(
operator|*
name|wp
operator|>
literal|255
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'?'
expr_stmt|;
name|wp
operator|++
expr_stmt|;
name|defchar_used
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
operator|(
name|char
operator|)
operator|*
name|wp
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|!=
name|NULL
operator|&&
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16
operator|)
condition|)
block|{
name|uint16_t
modifier|*
name|u16
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|len
operator|*
literal|2
operator|+
literal|2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|u16
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
operator|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|defchar_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16BE
condition|)
block|{
while|while
condition|(
name|count
operator|<
operator|(
name|int
operator|)
name|len
operator|&&
operator|*
name|ws
condition|)
block|{
name|archive_be16enc
argument_list|(
name|u16
operator|+
name|count
argument_list|,
operator|*
name|ws
argument_list|)
expr_stmt|;
name|ws
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|count
operator|<
operator|(
name|int
operator|)
name|len
operator|&&
operator|*
name|ws
condition|)
block|{
name|archive_le16enc
argument_list|(
name|u16
operator|+
name|count
argument_list|,
operator|*
name|ws
argument_list|)
expr_stmt|;
name|ws
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
name|count
operator|<<=
literal|1
expr_stmt|;
comment|/* to be byte size */
block|}
else|else
block|{
comment|/* Make sure the MBS buffer has plenty to set. */
if|if
condition|(
name|NULL
operator|==
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|len
operator|*
literal|2
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
do|do
block|{
name|defchar_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|to_cp
operator|==
name|CP_UTF8
operator|||
name|sc
operator|==
name|NULL
condition|)
name|dp
operator|=
name|NULL
expr_stmt|;
else|else
name|dp
operator|=
operator|&
name|defchar_used
expr_stmt|;
name|count
operator|=
name|WideCharToMultiByte
argument_list|(
name|to_cp
argument_list|,
literal|0
argument_list|,
name|ws
argument_list|,
name|wslen
argument_list|,
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
argument_list|,
operator|(
name|int
operator|)
name|as
operator|->
name|buffer_length
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|GetLastError
argument_list|()
operator|==
name|ERROR_INSUFFICIENT_BUFFER
condition|)
block|{
comment|/* Expand the MBS buffer and retry. */
if|if
condition|(
name|NULL
operator|==
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|buffer_length
operator|+
name|len
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
continue|continue;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
name|as
operator|->
name|length
operator|+=
name|count
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|defchar_used
condition|?
operator|-
literal|1
else|:
name|ret
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_WCTOMB
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_WCRTOMB
argument_list|)
end_elif

begin_comment
comment|/*  * Translates a wide character string into current locale character set  * and appends to the archive_string.  Note: returns -1 if conversion  * fails.  */
end_comment

begin_function
name|int
name|archive_string_append_from_wcs
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|w
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* We cannot use the standard wcstombs() here because it 	 * cannot tell us how big the output buffer should be.  So 	 * I've built a loop around wcrtomb() or wctomb() that 	 * converts a character at a time and resizes the string as 	 * needed.  We prefer wcrtomb() when it's available because 	 * it's thread-safe. */
name|int
name|n
decl_stmt|,
name|ret_val
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
if|#
directive|if
name|HAVE_WCRTOMB
name|mbstate_t
name|shift_state
decl_stmt|;
name|memset
argument_list|(
operator|&
name|shift_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|shift_state
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Clear the shift state before starting. */
name|wctomb
argument_list|(
name|NULL
argument_list|,
literal|L'
expr|\0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate buffer for MBS. 	 * We need this allocation here since it is possible that 	 * as->s is still NULL. 	 */
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|len
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|end
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|buffer_length
operator|-
name|MB_CUR_MAX
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|w
operator|!=
literal|L'
expr|\0'
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|end
condition|)
block|{
name|as
operator|->
name|length
operator|=
name|p
operator|-
name|as
operator|->
name|s
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Re-allocate buffer for MBS. */
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|len
operator|*
literal|2
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|end
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|buffer_length
operator|-
name|MB_CUR_MAX
operator|-
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_WCRTOMB
name|n
operator|=
name|wcrtomb
argument_list|(
name|p
argument_list|,
operator|*
name|w
operator|++
argument_list|,
operator|&
name|shift_state
argument_list|)
expr_stmt|;
else|#
directive|else
name|n
operator|=
name|wctomb
argument_list|(
name|p
argument_list|,
operator|*
name|w
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EILSEQ
condition|)
block|{
comment|/* Skip an illegal wide char. */
operator|*
name|p
operator|++
operator|=
literal|'?'
expr_stmt|;
name|ret_val
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
name|p
operator|+=
name|n
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|as
operator|->
name|length
operator|=
name|p
operator|-
name|as
operator|->
name|s
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_WCTOMB || HAVE_WCRTOMB */
end_comment

begin_comment
comment|/*  * TODO: Test if __STDC_ISO_10646__ is defined.  * Non-Windows uses ISO C wcrtomb() or wctomb() to perform the conversion  * one character at a time.  If a non-Windows platform doesn't have  * either of these, fall back to the built-in UTF8 conversion.  */
end_comment

begin_function
name|int
name|archive_string_append_from_wcs
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|w
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
operator|(
name|void
operator|)
name|as
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|w
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|len
expr_stmt|;
comment|/* UNUSED */
name|errno
operator|=
name|ENOSYS
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_WCTOMB || HAVE_WCRTOMB */
end_comment

begin_comment
comment|/*  * Find a string conversion object by a pair of 'from' charset name  * and 'to' charset name from an archive object.  * Return NULL if not found.  */
end_comment

begin_function
specifier|static
name|struct
name|archive_string_conv
modifier|*
name|find_sconv_object
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|fc
parameter_list|,
specifier|const
name|char
modifier|*
name|tc
parameter_list|)
block|{
name|struct
name|archive_string_conv
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|sc
operator|=
name|a
operator|->
name|sconv
init|;
name|sc
operator|!=
name|NULL
condition|;
name|sc
operator|=
name|sc
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sc
operator|->
name|from_charset
argument_list|,
name|fc
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|sc
operator|->
name|to_charset
argument_list|,
name|tc
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register a string object to an archive object.  */
end_comment

begin_function
specifier|static
name|void
name|add_sconv_object
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|archive_string_conv
modifier|*
modifier|*
name|psc
decl_stmt|;
comment|/* Add a new sconv to sconv list. */
name|psc
operator|=
operator|&
operator|(
name|a
operator|->
name|sconv
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|psc
operator|!=
name|NULL
condition|)
name|psc
operator|=
operator|&
operator|(
operator|(
operator|*
name|psc
operator|)
operator|->
name|next
operator|)
expr_stmt|;
operator|*
name|psc
operator|=
name|sc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_converter
parameter_list|(
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|,
name|int
function_decl|(
modifier|*
name|converter
function_decl|)
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|nconverter
operator|>=
literal|2
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Programing error"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|converter
index|[
name|sc
operator|->
name|nconverter
operator|++
index|]
operator|=
name|converter
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_converter
parameter_list|(
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Reset. */
name|sc
operator|->
name|nconverter
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Perform special sequence for the incorrect UTF-8 filenames 	 * made by libarchive2.x. 	 */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_UTF8_LIBARCHIVE_2
condition|)
block|{
name|add_converter
argument_list|(
name|sc
argument_list|,
name|strncat_from_utf8_libarchive2
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Convert a string to UTF-16BE/LE. 	 */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16
condition|)
block|{
comment|/* 		 * If the current locale is UTF-8, we can translate 		 * a UTF-8 string into a UTF-16BE string. 		 */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF8
condition|)
block|{
name|add_converter
argument_list|(
name|sc
argument_list|,
name|archive_string_append_unicode
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_WIN_CP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16BE
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|win_strncat_to_utf16be
argument_list|)
expr_stmt|;
else|else
name|add_converter
argument_list|(
name|sc
argument_list|,
name|win_strncat_to_utf16le
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ICONV
argument_list|)
if|if
condition|(
name|sc
operator|->
name|cd
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
block|{
name|add_converter
argument_list|(
name|sc
argument_list|,
name|iconv_strncat_in_locale
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_BEST_EFFORT
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16BE
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|best_effort_strncat_to_utf16be
argument_list|)
expr_stmt|;
else|else
name|add_converter
argument_list|(
name|sc
argument_list|,
name|best_effort_strncat_to_utf16le
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Make sure we have no converter. */
name|sc
operator|->
name|nconverter
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * Convert a string from UTF-16BE/LE. 	 */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16
condition|)
block|{
comment|/* 		 * At least we should normalize a UTF-16BE string. 		 */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_NORMALIZATION_D
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|archive_string_normalize_D
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_NORMALIZATION_C
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|archive_string_normalize_C
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF8
condition|)
block|{
comment|/* 			 * If the current locale is UTF-8, we can translate 			 * a UTF-16BE/LE string into a UTF-8 string directly. 			 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flag
operator|&
operator|(
name|SCONV_NORMALIZATION_D
operator||
name|SCONV_NORMALIZATION_C
operator|)
operator|)
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|archive_string_append_unicode
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_WIN_CP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16BE
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|win_strncat_from_utf16be
argument_list|)
expr_stmt|;
else|else
name|add_converter
argument_list|(
name|sc
argument_list|,
name|win_strncat_from_utf16le
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ICONV
argument_list|)
if|if
condition|(
name|sc
operator|->
name|cd
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
block|{
name|add_converter
argument_list|(
name|sc
argument_list|,
name|iconv_strncat_in_locale
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|flag
operator|&
operator|(
name|SCONV_BEST_EFFORT
operator||
name|SCONV_FROM_UTF16BE
operator|)
operator|)
operator|==
operator|(
name|SCONV_BEST_EFFORT
operator||
name|SCONV_FROM_UTF16BE
operator|)
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|best_effort_strncat_from_utf16be
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|flag
operator|&
operator|(
name|SCONV_BEST_EFFORT
operator||
name|SCONV_FROM_UTF16LE
operator|)
operator|)
operator|==
operator|(
name|SCONV_BEST_EFFORT
operator||
name|SCONV_FROM_UTF16LE
operator|)
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|best_effort_strncat_from_utf16le
argument_list|)
expr_stmt|;
else|else
comment|/* Make sure we have no converter. */
name|sc
operator|->
name|nconverter
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF8
condition|)
block|{
comment|/* 		 * At least we should normalize a UTF-8 string. 		 */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_NORMALIZATION_D
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|archive_string_normalize_D
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_NORMALIZATION_C
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|archive_string_normalize_C
argument_list|)
expr_stmt|;
comment|/* 		 * Copy UTF-8 string with a check of CESU-8. 		 * Apparently, iconv does not check surrogate pairs in UTF-8 		 * when both from-charset and to-charset are UTF-8, and then 		 * we use our UTF-8 copy code. 		 */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF8
condition|)
block|{
comment|/* 			 * If the current locale is UTF-8, we can translate 			 * a UTF-16BE string into a UTF-8 string directly. 			 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flag
operator|&
operator|(
name|SCONV_NORMALIZATION_D
operator||
name|SCONV_NORMALIZATION_C
operator|)
operator|)
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|strncat_from_utf8_to_utf8
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* 	 * On Windows we can use Windows API for a string conversion. 	 */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_WIN_CP
condition|)
block|{
name|add_converter
argument_list|(
name|sc
argument_list|,
name|strncat_in_codepage
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|HAVE_ICONV
if|if
condition|(
name|sc
operator|->
name|cd
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
block|{
name|add_converter
argument_list|(
name|sc
argument_list|,
name|iconv_strncat_in_locale
argument_list|)
expr_stmt|;
comment|/* 		 * iconv generally does not support UTF-8-MAC and so 		 * we have to the output of iconv from NFC to NFD if 		 * need. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_CHARSET
operator|)
operator|&&
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF8
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_NORMALIZATION_D
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|archive_string_normalize_D
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Try conversion in the best effort or no conversion. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_BEST_EFFORT
operator|)
operator|||
name|sc
operator|->
name|same
condition|)
name|add_converter
argument_list|(
name|sc
argument_list|,
name|best_effort_strncat_in_locale
argument_list|)
expr_stmt|;
else|else
comment|/* Make sure we have no converter. */
name|sc
operator|->
name|nconverter
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return canonicalized charset-name but this supports just UTF-8, UTF-16BE  * and CP932 which are referenced in create_sconv_object().  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|canonical_charset_name
parameter_list|(
specifier|const
name|char
modifier|*
name|charset
parameter_list|)
block|{
name|char
name|cs
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|charset
operator|==
name|NULL
operator|||
name|charset
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strlen
argument_list|(
name|charset
argument_list|)
operator|>
literal|15
condition|)
return|return
operator|(
name|charset
operator|)
return|;
comment|/* Copy name to uppercase. */
name|p
operator|=
name|cs
expr_stmt|;
name|s
operator|=
name|charset
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|char
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
name|c
operator|-=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cs
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|cs
argument_list|,
literal|"UTF8"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|"UTF-8"
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cs
argument_list|,
literal|"UTF-16BE"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|cs
argument_list|,
literal|"UTF16BE"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|"UTF-16BE"
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cs
argument_list|,
literal|"UTF-16LE"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|cs
argument_list|,
literal|"UTF16LE"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|"UTF-16LE"
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cs
argument_list|,
literal|"CP932"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|"CP932"
operator|)
return|;
return|return
operator|(
name|charset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a string conversion object.  */
end_comment

begin_function
specifier|static
name|struct
name|archive_string_conv
modifier|*
name|create_sconv_object
parameter_list|(
specifier|const
name|char
modifier|*
name|fc
parameter_list|,
specifier|const
name|char
modifier|*
name|tc
parameter_list|,
name|unsigned
name|current_codepage
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|archive_string_conv
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|from_charset
operator|=
name|strdup
argument_list|(
name|fc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|from_charset
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|->
name|to_charset
operator|=
name|strdup
argument_list|(
name|tc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|to_charset
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|from_charset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|archive_string_init
argument_list|(
operator|&
name|sc
operator|->
name|utftmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|SCONV_TO_CHARSET
condition|)
block|{
comment|/* 		 * Convert characters from the current locale charset to 		 * a specified charset. 		 */
name|sc
operator|->
name|from_cp
operator|=
name|current_codepage
expr_stmt|;
name|sc
operator|->
name|to_cp
operator|=
name|make_codepage_from_charset
argument_list|(
name|tc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|IsValidCodePage
argument_list|(
name|sc
operator|->
name|to_cp
argument_list|)
condition|)
name|flag
operator||=
name|SCONV_WIN_CP
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
name|SCONV_FROM_CHARSET
condition|)
block|{
comment|/* 		 * Convert characters from a specified charset to 		 * the current locale charset. 		 */
name|sc
operator|->
name|to_cp
operator|=
name|current_codepage
expr_stmt|;
name|sc
operator|->
name|from_cp
operator|=
name|make_codepage_from_charset
argument_list|(
name|fc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|IsValidCodePage
argument_list|(
name|sc
operator|->
name|from_cp
argument_list|)
condition|)
name|flag
operator||=
name|SCONV_WIN_CP
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Check if "from charset" and "to charset" are the same. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|fc
argument_list|,
name|tc
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|sc
operator|->
name|from_cp
operator|!=
operator|(
name|unsigned
operator|)
operator|-
literal|1
operator|&&
name|sc
operator|->
name|from_cp
operator|==
name|sc
operator|->
name|to_cp
operator|)
condition|)
name|sc
operator|->
name|same
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|same
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Mark if "from charset" or "to charset" are UTF-8 or UTF-16BE/LE. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|tc
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
condition|)
name|flag
operator||=
name|SCONV_TO_UTF8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tc
argument_list|,
literal|"UTF-16BE"
argument_list|)
operator|==
literal|0
condition|)
name|flag
operator||=
name|SCONV_TO_UTF16BE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tc
argument_list|,
literal|"UTF-16LE"
argument_list|)
operator|==
literal|0
condition|)
name|flag
operator||=
name|SCONV_TO_UTF16LE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fc
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
condition|)
name|flag
operator||=
name|SCONV_FROM_UTF8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fc
argument_list|,
literal|"UTF-16BE"
argument_list|)
operator|==
literal|0
condition|)
name|flag
operator||=
name|SCONV_FROM_UTF16BE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fc
argument_list|,
literal|"UTF-16LE"
argument_list|)
operator|==
literal|0
condition|)
name|flag
operator||=
name|SCONV_FROM_UTF16LE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
name|sc
operator|->
name|to_cp
operator|==
name|CP_UTF8
condition|)
name|flag
operator||=
name|SCONV_TO_UTF8
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|to_cp
operator|==
name|CP_UTF16BE
condition|)
name|flag
operator||=
name|SCONV_TO_UTF16BE
operator||
name|SCONV_WIN_CP
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|to_cp
operator|==
name|CP_UTF16LE
condition|)
name|flag
operator||=
name|SCONV_TO_UTF16LE
operator||
name|SCONV_WIN_CP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|from_cp
operator|==
name|CP_UTF8
condition|)
name|flag
operator||=
name|SCONV_FROM_UTF8
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|from_cp
operator|==
name|CP_UTF16BE
condition|)
name|flag
operator||=
name|SCONV_FROM_UTF16BE
operator||
name|SCONV_WIN_CP
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|from_cp
operator|==
name|CP_UTF16LE
condition|)
name|flag
operator||=
name|SCONV_FROM_UTF16LE
operator||
name|SCONV_WIN_CP
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set a flag for Unicode NFD. Usually iconv cannot correctly 	 * handle it. So we have to translate NFD characters to NFC ones 	 * ourselves before iconv handles. Another reason is to prevent 	 * that the same sight of two filenames, one is NFC and other 	 * is NFD, would be in its directory. 	 * On Mac OS X, although its filesystem layer automatically 	 * convert filenames to NFD, it would be useful for filename 	 * comparing to find out the same filenames that we normalize 	 * that to be NFD ourselves. 	 */
if|if
condition|(
operator|(
name|flag
operator|&
name|SCONV_FROM_CHARSET
operator|)
operator|&&
operator|(
name|flag
operator|&
operator|(
name|SCONV_FROM_UTF16
operator||
name|SCONV_FROM_UTF8
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
if|if
condition|(
name|flag
operator|&
name|SCONV_TO_UTF8
condition|)
name|flag
operator||=
name|SCONV_NORMALIZATION_D
expr_stmt|;
else|else
endif|#
directive|endif
name|flag
operator||=
name|SCONV_NORMALIZATION_C
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
comment|/* 	 * In case writing an archive file, make sure that a filename 	 * going to be passed to iconv is a Unicode NFC string since 	 * a filename in HFS Plus filesystem is a Unicode NFD one and 	 * iconv cannot handle it with "UTF-8" charset. It is simpler 	 * than a use of "UTF-8-MAC" charset. 	 */
if|if
condition|(
operator|(
name|flag
operator|&
name|SCONV_TO_CHARSET
operator|)
operator|&&
operator|(
name|flag
operator|&
operator|(
name|SCONV_FROM_UTF16
operator||
name|SCONV_FROM_UTF8
operator|)
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
operator|(
name|SCONV_TO_UTF16
operator||
name|SCONV_TO_UTF8
operator|)
operator|)
condition|)
name|flag
operator||=
name|SCONV_NORMALIZATION_C
expr_stmt|;
comment|/* 	 * In case reading an archive file. make sure that a filename 	 * will be passed to users is a Unicode NFD string in order to 	 * correctly compare the filename with other one which comes 	 * from HFS Plus filesystem. 	 */
if|if
condition|(
operator|(
name|flag
operator|&
name|SCONV_FROM_CHARSET
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
operator|(
name|SCONV_FROM_UTF16
operator||
name|SCONV_FROM_UTF8
operator|)
operator|)
operator|&&
operator|(
name|flag
operator|&
name|SCONV_TO_UTF8
operator|)
condition|)
name|flag
operator||=
name|SCONV_NORMALIZATION_D
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ICONV
argument_list|)
name|sc
operator|->
name|cd_w
operator|=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Create an iconv object. 	 */
if|if
condition|(
operator|(
operator|(
name|flag
operator|&
operator|(
name|SCONV_TO_UTF8
operator||
name|SCONV_TO_UTF16
operator|)
operator|)
operator|&&
operator|(
name|flag
operator|&
operator|(
name|SCONV_FROM_UTF8
operator||
name|SCONV_FROM_UTF16
operator|)
operator|)
operator|)
operator|||
operator|(
name|flag
operator|&
name|SCONV_WIN_CP
operator|)
condition|)
block|{
comment|/* This case we won't use iconv. */
name|sc
operator|->
name|cd
operator|=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|cd
operator|=
name|iconv_open
argument_list|(
name|tc
argument_list|,
name|fc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cd
operator|==
operator|(
name|iconv_t
operator|)
operator|-
literal|1
operator|&&
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_BEST_EFFORT
operator|)
condition|)
block|{
comment|/* 			 * Unfortunately, all of iconv implements do support 			 * "CP932" character-set, so we should use "SJIS" 			 * instead if iconv_open failed. 			 */
if|if
condition|(
name|strcmp
argument_list|(
name|tc
argument_list|,
literal|"CP932"
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|cd
operator|=
name|iconv_open
argument_list|(
literal|"SJIS"
argument_list|,
name|fc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fc
argument_list|,
literal|"CP932"
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|cd
operator|=
name|iconv_open
argument_list|(
name|tc
argument_list|,
literal|"SJIS"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* 		 * archive_mstring on Windows directly convert multi-bytes 		 * into archive_wstring in order not to depend on locale 		 * so that you can do a I18N programming. This will be 		 * used only in archive_mstring_copy_mbs_len_l so far. 		 */
if|if
condition|(
name|flag
operator|&
name|SCONV_FROM_CHARSET
condition|)
block|{
name|sc
operator|->
name|cd_w
operator|=
name|iconv_open
argument_list|(
literal|"UTF-8"
argument_list|,
name|fc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cd_w
operator|==
operator|(
name|iconv_t
operator|)
operator|-
literal|1
operator|&&
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_BEST_EFFORT
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fc
argument_list|,
literal|"CP932"
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|cd_w
operator|=
name|iconv_open
argument_list|(
literal|"UTF-8"
argument_list|,
literal|"SJIS"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* _WIN32&& !__CYGWIN__ */
block|}
endif|#
directive|endif
comment|/* HAVE_ICONV */
name|sc
operator|->
name|flag
operator|=
name|flag
expr_stmt|;
comment|/* 	 * Set up converters. 	 */
name|setup_converter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a string conversion object.  */
end_comment

begin_function
specifier|static
name|void
name|free_sconv_object
parameter_list|(
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|from_charset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|to_charset
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|sc
operator|->
name|utftmp
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_ICONV
if|if
condition|(
name|sc
operator|->
name|cd
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
name|iconv_close
argument_list|(
name|sc
operator|->
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cd_w
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
name|iconv_close
argument_list|(
name|sc
operator|->
name|cd_w
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_function
specifier|static
name|unsigned
name|my_atoi
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|cp
decl_stmt|;
name|cp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|cp
operator|=
name|cp
operator|*
literal|10
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translate Charset name (as used by iconv) into CodePage (as used by Windows)  * Return -1 if failed.  *  * Note: This translation code may be insufficient.  */
end_comment

begin_struct
specifier|static
struct|struct
name|charset
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|cp
decl_stmt|;
block|}
name|charsets
index|[]
init|=
block|{
comment|/* MUST BE SORTED! */
block|{
literal|"ASCII"
block|,
literal|1252
block|}
block|,
block|{
literal|"ASMO-708"
block|,
literal|708
block|}
block|,
block|{
literal|"BIG5"
block|,
literal|950
block|}
block|,
block|{
literal|"CHINESE"
block|,
literal|936
block|}
block|,
block|{
literal|"CP367"
block|,
literal|1252
block|}
block|,
block|{
literal|"CP819"
block|,
literal|1252
block|}
block|,
block|{
literal|"CP1025"
block|,
literal|21025
block|}
block|,
block|{
literal|"DOS-720"
block|,
literal|720
block|}
block|,
block|{
literal|"DOS-862"
block|,
literal|862
block|}
block|,
block|{
literal|"EUC-CN"
block|,
literal|51936
block|}
block|,
block|{
literal|"EUC-JP"
block|,
literal|51932
block|}
block|,
block|{
literal|"EUC-KR"
block|,
literal|949
block|}
block|,
block|{
literal|"EUCCN"
block|,
literal|51936
block|}
block|,
block|{
literal|"EUCJP"
block|,
literal|51932
block|}
block|,
block|{
literal|"EUCKR"
block|,
literal|949
block|}
block|,
block|{
literal|"GB18030"
block|,
literal|54936
block|}
block|,
block|{
literal|"GB2312"
block|,
literal|936
block|}
block|,
block|{
literal|"HEBREW"
block|,
literal|1255
block|}
block|,
block|{
literal|"HZ-GB-2312"
block|,
literal|52936
block|}
block|,
block|{
literal|"IBM273"
block|,
literal|20273
block|}
block|,
block|{
literal|"IBM277"
block|,
literal|20277
block|}
block|,
block|{
literal|"IBM278"
block|,
literal|20278
block|}
block|,
block|{
literal|"IBM280"
block|,
literal|20280
block|}
block|,
block|{
literal|"IBM284"
block|,
literal|20284
block|}
block|,
block|{
literal|"IBM285"
block|,
literal|20285
block|}
block|,
block|{
literal|"IBM290"
block|,
literal|20290
block|}
block|,
block|{
literal|"IBM297"
block|,
literal|20297
block|}
block|,
block|{
literal|"IBM367"
block|,
literal|1252
block|}
block|,
block|{
literal|"IBM420"
block|,
literal|20420
block|}
block|,
block|{
literal|"IBM423"
block|,
literal|20423
block|}
block|,
block|{
literal|"IBM424"
block|,
literal|20424
block|}
block|,
block|{
literal|"IBM819"
block|,
literal|1252
block|}
block|,
block|{
literal|"IBM871"
block|,
literal|20871
block|}
block|,
block|{
literal|"IBM880"
block|,
literal|20880
block|}
block|,
block|{
literal|"IBM905"
block|,
literal|20905
block|}
block|,
block|{
literal|"IBM924"
block|,
literal|20924
block|}
block|,
block|{
literal|"ISO-8859-1"
block|,
literal|28591
block|}
block|,
block|{
literal|"ISO-8859-13"
block|,
literal|28603
block|}
block|,
block|{
literal|"ISO-8859-15"
block|,
literal|28605
block|}
block|,
block|{
literal|"ISO-8859-2"
block|,
literal|28592
block|}
block|,
block|{
literal|"ISO-8859-3"
block|,
literal|28593
block|}
block|,
block|{
literal|"ISO-8859-4"
block|,
literal|28594
block|}
block|,
block|{
literal|"ISO-8859-5"
block|,
literal|28595
block|}
block|,
block|{
literal|"ISO-8859-6"
block|,
literal|28596
block|}
block|,
block|{
literal|"ISO-8859-7"
block|,
literal|28597
block|}
block|,
block|{
literal|"ISO-8859-8"
block|,
literal|28598
block|}
block|,
block|{
literal|"ISO-8859-9"
block|,
literal|28599
block|}
block|,
block|{
literal|"ISO8859-1"
block|,
literal|28591
block|}
block|,
block|{
literal|"ISO8859-13"
block|,
literal|28603
block|}
block|,
block|{
literal|"ISO8859-15"
block|,
literal|28605
block|}
block|,
block|{
literal|"ISO8859-2"
block|,
literal|28592
block|}
block|,
block|{
literal|"ISO8859-3"
block|,
literal|28593
block|}
block|,
block|{
literal|"ISO8859-4"
block|,
literal|28594
block|}
block|,
block|{
literal|"ISO8859-5"
block|,
literal|28595
block|}
block|,
block|{
literal|"ISO8859-6"
block|,
literal|28596
block|}
block|,
block|{
literal|"ISO8859-7"
block|,
literal|28597
block|}
block|,
block|{
literal|"ISO8859-8"
block|,
literal|28598
block|}
block|,
block|{
literal|"ISO8859-9"
block|,
literal|28599
block|}
block|,
block|{
literal|"JOHAB"
block|,
literal|1361
block|}
block|,
block|{
literal|"KOI8-R"
block|,
literal|20866
block|}
block|,
block|{
literal|"KOI8-U"
block|,
literal|21866
block|}
block|,
block|{
literal|"KS_C_5601-1987"
block|,
literal|949
block|}
block|,
block|{
literal|"LATIN1"
block|,
literal|1252
block|}
block|,
block|{
literal|"LATIN2"
block|,
literal|28592
block|}
block|,
block|{
literal|"MACINTOSH"
block|,
literal|10000
block|}
block|,
block|{
literal|"SHIFT-JIS"
block|,
literal|932
block|}
block|,
block|{
literal|"SHIFT_JIS"
block|,
literal|932
block|}
block|,
block|{
literal|"SJIS"
block|,
literal|932
block|}
block|,
block|{
literal|"US"
block|,
literal|1252
block|}
block|,
block|{
literal|"US-ASCII"
block|,
literal|1252
block|}
block|,
block|{
literal|"UTF-16"
block|,
literal|1200
block|}
block|,
block|{
literal|"UTF-16BE"
block|,
literal|1201
block|}
block|,
block|{
literal|"UTF-16LE"
block|,
literal|1200
block|}
block|,
block|{
literal|"UTF-8"
block|,
name|CP_UTF8
block|}
block|,
block|{
literal|"X-EUROPA"
block|,
literal|29001
block|}
block|,
block|{
literal|"X-MAC-ARABIC"
block|,
literal|10004
block|}
block|,
block|{
literal|"X-MAC-CE"
block|,
literal|10029
block|}
block|,
block|{
literal|"X-MAC-CHINESEIMP"
block|,
literal|10008
block|}
block|,
block|{
literal|"X-MAC-CHINESETRAD"
block|,
literal|10002
block|}
block|,
block|{
literal|"X-MAC-CROATIAN"
block|,
literal|10082
block|}
block|,
block|{
literal|"X-MAC-CYRILLIC"
block|,
literal|10007
block|}
block|,
block|{
literal|"X-MAC-GREEK"
block|,
literal|10006
block|}
block|,
block|{
literal|"X-MAC-HEBREW"
block|,
literal|10005
block|}
block|,
block|{
literal|"X-MAC-ICELANDIC"
block|,
literal|10079
block|}
block|,
block|{
literal|"X-MAC-JAPANESE"
block|,
literal|10001
block|}
block|,
block|{
literal|"X-MAC-KOREAN"
block|,
literal|10003
block|}
block|,
block|{
literal|"X-MAC-ROMANIAN"
block|,
literal|10010
block|}
block|,
block|{
literal|"X-MAC-THAI"
block|,
literal|10021
block|}
block|,
block|{
literal|"X-MAC-TURKISH"
block|,
literal|10081
block|}
block|,
block|{
literal|"X-MAC-UKRAINIAN"
block|,
literal|10017
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|unsigned
name|make_codepage_from_charset
parameter_list|(
specifier|const
name|char
modifier|*
name|charset
parameter_list|)
block|{
name|char
name|cs
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|cp
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
name|charset
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|charset
argument_list|)
operator|>
literal|15
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Copy name to uppercase. */
name|p
operator|=
name|cs
expr_stmt|;
while|while
condition|(
operator|*
name|charset
condition|)
block|{
name|char
name|c
init|=
operator|*
name|charset
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
name|c
operator|-=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Look it up in the table first, so that we can easily 	 * override CP367, which we map to 1252 instead of 367. */
name|a
operator|=
literal|0
expr_stmt|;
name|b
operator|=
sizeof|sizeof
argument_list|(
name|charsets
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|charsets
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|b
operator|>
name|a
condition|)
block|{
name|int
name|c
init|=
operator|(
name|b
operator|+
name|a
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|r
init|=
name|strcmp
argument_list|(
name|charsets
index|[
name|c
index|]
operator|.
name|name
argument_list|,
name|cs
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|a
operator|=
name|c
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|>
literal|0
condition|)
name|b
operator|=
name|c
expr_stmt|;
else|else
return|return
name|charsets
index|[
name|c
index|]
operator|.
name|cp
return|;
block|}
comment|/* If it's not in the table, try to parse it. */
switch|switch
condition|(
operator|*
name|cs
condition|)
block|{
case|case
literal|'C'
case|:
if|if
condition|(
name|cs
index|[
literal|1
index|]
operator|==
literal|'P'
operator|&&
name|cs
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|cs
index|[
literal|2
index|]
operator|<=
literal|'9'
condition|)
block|{
name|cp
operator|=
name|my_atoi
argument_list|(
name|cs
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cs
argument_list|,
literal|"CP_ACP"
argument_list|)
operator|==
literal|0
condition|)
name|cp
operator|=
name|get_current_codepage
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cs
argument_list|,
literal|"CP_OEMCP"
argument_list|)
operator|==
literal|0
condition|)
name|cp
operator|=
name|get_current_oemcp
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|cs
index|[
literal|1
index|]
operator|==
literal|'B'
operator|&&
name|cs
index|[
literal|2
index|]
operator|==
literal|'M'
operator|&&
name|cs
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|cs
index|[
literal|3
index|]
operator|<=
literal|'9'
condition|)
block|{
name|cp
operator|=
name|my_atoi
argument_list|(
name|cs
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|cs
argument_list|,
literal|"WINDOWS-"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|my_atoi
argument_list|(
name|cs
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
literal|874
operator|&&
operator|(
name|cp
operator|<
literal|1250
operator|||
name|cp
operator|>
literal|1258
operator|)
condition|)
name|cp
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* This may invalid code. */
block|}
break|break;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return ANSI Code Page of current locale set by setlocale().  */
end_comment

begin_function
specifier|static
name|unsigned
name|get_current_codepage
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|locale
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|cp
decl_stmt|;
name|locale
operator|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|locale
operator|==
name|NULL
condition|)
return|return
operator|(
name|GetACP
argument_list|()
operator|)
return|;
if|if
condition|(
name|locale
index|[
literal|0
index|]
operator|==
literal|'C'
operator|&&
name|locale
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|CP_C_LOCALE
operator|)
return|;
name|p
operator|=
name|strrchr
argument_list|(
name|locale
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|GetACP
argument_list|()
operator|)
return|;
name|cp
operator|=
name|my_atoi
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|<=
literal|0
condition|)
return|return
operator|(
name|GetACP
argument_list|()
operator|)
return|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translation table between Locale Name and ACP/OEMCP.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|unsigned
name|acp
decl_stmt|;
name|unsigned
name|ocp
decl_stmt|;
specifier|const
name|char
modifier|*
name|locale
decl_stmt|;
block|}
name|acp_ocp_map
index|[]
init|=
block|{
block|{
literal|950
block|,
literal|950
block|,
literal|"Chinese_Taiwan"
block|}
block|,
block|{
literal|936
block|,
literal|936
block|,
literal|"Chinese_People's Republic of China"
block|}
block|,
block|{
literal|950
block|,
literal|950
block|,
literal|"Chinese_Taiwan"
block|}
block|,
block|{
literal|1250
block|,
literal|852
block|,
literal|"Czech_Czech Republic"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Danish_Denmark"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Dutch_Netherlands"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Dutch_Belgium"
block|}
block|,
block|{
literal|1252
block|,
literal|437
block|,
literal|"English_United States"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"English_Australia"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"English_Canada"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"English_New Zealand"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"English_United Kingdom"
block|}
block|,
block|{
literal|1252
block|,
literal|437
block|,
literal|"English_United States"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Finnish_Finland"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"French_France"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"French_Belgium"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"French_Canada"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"French_Switzerland"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"German_Germany"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"German_Austria"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"German_Switzerland"
block|}
block|,
block|{
literal|1253
block|,
literal|737
block|,
literal|"Greek_Greece"
block|}
block|,
block|{
literal|1250
block|,
literal|852
block|,
literal|"Hungarian_Hungary"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Icelandic_Iceland"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Italian_Italy"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Italian_Switzerland"
block|}
block|,
block|{
literal|932
block|,
literal|932
block|,
literal|"Japanese_Japan"
block|}
block|,
block|{
literal|949
block|,
literal|949
block|,
literal|"Korean_Korea"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Norwegian (BokmOl)_Norway"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Norwegian (BokmOl)_Norway"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Norwegian-Nynorsk_Norway"
block|}
block|,
block|{
literal|1250
block|,
literal|852
block|,
literal|"Polish_Poland"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Portuguese_Portugal"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Portuguese_Brazil"
block|}
block|,
block|{
literal|1251
block|,
literal|866
block|,
literal|"Russian_Russia"
block|}
block|,
block|{
literal|1250
block|,
literal|852
block|,
literal|"Slovak_Slovakia"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Spanish_Spain"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Spanish_Mexico"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Spanish_Spain"
block|}
block|,
block|{
literal|1252
block|,
literal|850
block|,
literal|"Swedish_Sweden"
block|}
block|,
block|{
literal|1254
block|,
literal|857
block|,
literal|"Turkish_Turkey"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Return OEM Code Page of current locale set by setlocale().  */
end_comment

begin_function
specifier|static
name|unsigned
name|get_current_oemcp
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|locale
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|locale
operator|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|locale
operator|==
name|NULL
condition|)
return|return
operator|(
name|GetOEMCP
argument_list|()
operator|)
return|;
if|if
condition|(
name|locale
index|[
literal|0
index|]
operator|==
literal|'C'
operator|&&
name|locale
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|CP_C_LOCALE
operator|)
return|;
name|p
operator|=
name|strrchr
argument_list|(
name|locale
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|GetOEMCP
argument_list|()
operator|)
return|;
name|len
operator|=
name|p
operator|-
name|locale
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|acp_ocp_map
index|[
name|i
index|]
operator|.
name|acp
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|acp_ocp_map
index|[
name|i
index|]
operator|.
name|locale
argument_list|,
name|locale
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|acp_ocp_map
index|[
name|i
index|]
operator|.
name|ocp
operator|)
return|;
block|}
return|return
operator|(
name|GetOEMCP
argument_list|()
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * POSIX platform does not use CodePage.  */
end_comment

begin_function
specifier|static
name|unsigned
name|get_current_codepage
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Unknown */
block|}
end_function

begin_function
specifier|static
name|unsigned
name|make_codepage_from_charset
parameter_list|(
specifier|const
name|char
modifier|*
name|charset
parameter_list|)
block|{
operator|(
name|void
operator|)
name|charset
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Unknown */
block|}
end_function

begin_function
specifier|static
name|unsigned
name|get_current_oemcp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Unknown */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(_WIN32)&& !defined(__CYGWIN__) */
end_comment

begin_comment
comment|/*  * Return a string conversion object.  */
end_comment

begin_function
specifier|static
name|struct
name|archive_string_conv
modifier|*
name|get_sconv_object
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|fc
parameter_list|,
specifier|const
name|char
modifier|*
name|tc
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|archive_string_conv
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|current_codepage
decl_stmt|;
comment|/* Check if we have made the sconv object. */
name|sc
operator|=
name|find_sconv_object
argument_list|(
name|a
argument_list|,
name|fc
argument_list|,
name|tc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
return|return
operator|(
name|sc
operator|)
return|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|current_codepage
operator|=
name|get_current_codepage
argument_list|()
expr_stmt|;
else|else
name|current_codepage
operator|=
name|a
operator|->
name|current_codepage
expr_stmt|;
name|sc
operator|=
name|create_sconv_object
argument_list|(
name|canonical_charset_name
argument_list|(
name|fc
argument_list|)
argument_list|,
name|canonical_charset_name
argument_list|(
name|tc
argument_list|)
argument_list|,
name|current_codepage
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Could not allocate memory for "
literal|"a string conversion object"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If there is no converter for current string conversion object, 	 * we cannot handle this conversion. 	 */
if|if
condition|(
name|sc
operator|->
name|nconverter
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|HAVE_ICONV
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"iconv_open failed : Cannot handle ``%s''"
argument_list|,
operator|(
name|flag
operator|&
name|SCONV_TO_CHARSET
operator|)
condition|?
name|tc
else|:
name|fc
argument_list|)
expr_stmt|;
else|#
directive|else
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"A character-set conversion not fully supported "
literal|"on this platform"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Failed; free a sconv object. */
name|free_sconv_object
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Success! 	 */
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
name|add_sconv_object
argument_list|(
name|a
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_current_charset
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cur_charset
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|cur_charset
operator|=
name|default_iconv_charset
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
name|cur_charset
operator|=
name|default_iconv_charset
argument_list|(
name|a
operator|->
name|current_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|current_code
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|current_code
operator|=
name|strdup
argument_list|(
name|cur_charset
argument_list|)
expr_stmt|;
name|a
operator|->
name|current_codepage
operator|=
name|get_current_codepage
argument_list|()
expr_stmt|;
name|a
operator|->
name|current_oemcp
operator|=
name|get_current_oemcp
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
name|cur_charset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make and Return a string conversion object.  * Return NULL if the platform does not support the specified conversion  * and best_effort is 0.  * If best_effort is set, A string conversion object must be returned  * unless memory allocation for the object fails, but the conversion  * might fail when non-ASCII code is found.  */
end_comment

begin_function
name|struct
name|archive_string_conv
modifier|*
name|archive_string_conversion_to_charset
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|charset
parameter_list|,
name|int
name|best_effort
parameter_list|)
block|{
name|int
name|flag
init|=
name|SCONV_TO_CHARSET
decl_stmt|;
if|if
condition|(
name|best_effort
condition|)
name|flag
operator||=
name|SCONV_BEST_EFFORT
expr_stmt|;
return|return
operator|(
name|get_sconv_object
argument_list|(
name|a
argument_list|,
name|get_current_charset
argument_list|(
name|a
argument_list|)
argument_list|,
name|charset
argument_list|,
name|flag
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|archive_string_conv
modifier|*
name|archive_string_conversion_from_charset
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|charset
parameter_list|,
name|int
name|best_effort
parameter_list|)
block|{
name|int
name|flag
init|=
name|SCONV_FROM_CHARSET
decl_stmt|;
if|if
condition|(
name|best_effort
condition|)
name|flag
operator||=
name|SCONV_BEST_EFFORT
expr_stmt|;
return|return
operator|(
name|get_sconv_object
argument_list|(
name|a
argument_list|,
name|charset
argument_list|,
name|get_current_charset
argument_list|(
name|a
argument_list|)
argument_list|,
name|flag
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * archive_string_default_conversion_*_archive() are provided for Windows  * platform because other archiver application use CP_OEMCP for  * MultiByteToWideChar() and WideCharToMultiByte() for the filenames  * in tar or zip files. But mbstowcs/wcstombs(CRT) usually use CP_ACP  * unless you use setlocale(LC_ALL, ".OCP")(specify CP_OEMCP).  * So we should make a string conversion between CP_ACP and CP_OEMCP  * for compatibility.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_function
name|struct
name|archive_string_conv
modifier|*
name|archive_string_default_conversion_for_read
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cur_charset
init|=
name|get_current_charset
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|char
name|oemcp
index|[
literal|16
index|]
decl_stmt|;
comment|/* NOTE: a check of cur_charset is unneeded but we need 	 * that get_current_charset() has been surely called at 	 * this time whatever C compiler optimized. */
if|if
condition|(
name|cur_charset
operator|!=
name|NULL
operator|&&
operator|(
name|a
operator|->
name|current_codepage
operator|==
name|CP_C_LOCALE
operator|||
name|a
operator|->
name|current_codepage
operator|==
name|a
operator|->
name|current_oemcp
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* no conversion. */
name|_snprintf
argument_list|(
name|oemcp
argument_list|,
sizeof|sizeof
argument_list|(
name|oemcp
argument_list|)
operator|-
literal|1
argument_list|,
literal|"CP%d"
argument_list|,
name|a
operator|->
name|current_oemcp
argument_list|)
expr_stmt|;
comment|/* Make sure a null termination must be set. */
name|oemcp
index|[
sizeof|sizeof
argument_list|(
name|oemcp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|get_sconv_object
argument_list|(
name|a
argument_list|,
name|oemcp
argument_list|,
name|cur_charset
argument_list|,
name|SCONV_FROM_CHARSET
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|archive_string_conv
modifier|*
name|archive_string_default_conversion_for_write
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cur_charset
init|=
name|get_current_charset
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|char
name|oemcp
index|[
literal|16
index|]
decl_stmt|;
comment|/* NOTE: a check of cur_charset is unneeded but we need 	 * that get_current_charset() has been surely called at 	 * this time whatever C compiler optimized. */
if|if
condition|(
name|cur_charset
operator|!=
name|NULL
operator|&&
operator|(
name|a
operator|->
name|current_codepage
operator|==
name|CP_C_LOCALE
operator|||
name|a
operator|->
name|current_codepage
operator|==
name|a
operator|->
name|current_oemcp
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* no conversion. */
name|_snprintf
argument_list|(
name|oemcp
argument_list|,
sizeof|sizeof
argument_list|(
name|oemcp
argument_list|)
operator|-
literal|1
argument_list|,
literal|"CP%d"
argument_list|,
name|a
operator|->
name|current_oemcp
argument_list|)
expr_stmt|;
comment|/* Make sure a null termination must be set. */
name|oemcp
index|[
sizeof|sizeof
argument_list|(
name|oemcp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|get_sconv_object
argument_list|(
name|a
argument_list|,
name|cur_charset
argument_list|,
name|oemcp
argument_list|,
name|SCONV_TO_CHARSET
argument_list|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|struct
name|archive_string_conv
modifier|*
name|archive_string_default_conversion_for_read
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|archive_string_conv
modifier|*
name|archive_string_default_conversion_for_write
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Dispose of all character conversion objects in the archive object.  */
end_comment

begin_function
name|void
name|archive_string_conversion_free
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|archive_string_conv
modifier|*
name|sc
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sc_next
decl_stmt|;
for|for
control|(
name|sc
operator|=
name|a
operator|->
name|sconv
init|;
name|sc
operator|!=
name|NULL
condition|;
name|sc
operator|=
name|sc_next
control|)
block|{
name|sc_next
operator|=
name|sc
operator|->
name|next
expr_stmt|;
name|free_sconv_object
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|a
operator|->
name|sconv
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|current_code
argument_list|)
expr_stmt|;
name|a
operator|->
name|current_code
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a conversion charset name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|archive_string_conversion_charset_name
parameter_list|(
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_CHARSET
condition|)
return|return
operator|(
name|sc
operator|->
name|to_charset
operator|)
return|;
else|else
return|return
operator|(
name|sc
operator|->
name|from_charset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change the behavior of a string conversion.  */
end_comment

begin_function
name|void
name|archive_string_conversion_set_opt
parameter_list|(
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
comment|/* 	 * A filename in UTF-8 was made with libarchive 2.x in a wrong 	 * assumption that wchar_t was Unicode. 	 * This option enables simulating the assumption in order to read 	 * that filename correctly. 	 */
case|case
name|SCONV_SET_OPT_UTF8_LIBARCHIVE2X
case|:
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|)
expr|\
operator|||
name|defined
argument_list|(
name|__STDC_ISO_10646__
argument_list|)
operator|||
name|defined
argument_list|(
name|__APPLE__
argument_list|)
comment|/* 		 * Nothing to do for it since wchar_t on these platforms 		 * is really Unicode. 		 */
operator|(
name|void
operator|)
name|sc
expr_stmt|;
comment|/* UNUSED */
else|#
directive|else
if|if
condition|(
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_UTF8_LIBARCHIVE_2
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|flag
operator||=
name|SCONV_UTF8_LIBARCHIVE_2
expr_stmt|;
comment|/* Set up string converters. */
name|setup_converter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|SCONV_SET_OPT_NORMALIZATION_C
case|:
if|if
condition|(
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_NORMALIZATION_C
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|flag
operator||=
name|SCONV_NORMALIZATION_C
expr_stmt|;
name|sc
operator|->
name|flag
operator|&=
operator|~
name|SCONV_NORMALIZATION_D
expr_stmt|;
comment|/* Set up string converters. */
name|setup_converter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCONV_SET_OPT_NORMALIZATION_D
case|:
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ICONV
argument_list|)
comment|/* 		 * If iconv will take the string, do not change the 		 * setting of the normalization. 		 */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_WIN_CP
operator|)
operator|&&
operator|(
name|sc
operator|->
name|flag
operator|&
operator|(
name|SCONV_FROM_UTF16
operator||
name|SCONV_FROM_UTF8
operator|)
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flag
operator|&
operator|(
name|SCONV_TO_UTF16
operator||
name|SCONV_TO_UTF8
operator|)
operator|)
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_NORMALIZATION_D
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|flag
operator||=
name|SCONV_NORMALIZATION_D
expr_stmt|;
name|sc
operator|->
name|flag
operator|&=
operator|~
name|SCONV_NORMALIZATION_C
expr_stmt|;
comment|/* Set up string converters. */
name|setup_converter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *  * Copy one archive_string to another in locale conversion.  *  *	archive_strncat_l();  *	archive_strncpy_l();  *  */
end_comment

begin_function
specifier|static
name|size_t
name|mbsnbytes
parameter_list|(
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|_p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
expr_stmt|;
comment|/* Like strlen(p), except won't examine positions beyond p[n]. */
name|s
operator|=
literal|0
expr_stmt|;
name|pp
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|n
operator|&&
operator|*
name|pp
condition|)
block|{
name|pp
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|utf16nbytes
parameter_list|(
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|size_t
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|_p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
expr_stmt|;
comment|/* Like strlen(p), except won't examine positions beyond p[n]. */
name|s
operator|=
literal|0
expr_stmt|;
name|pp
operator|=
name|p
expr_stmt|;
name|n
operator|>>=
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|n
operator|&&
operator|(
name|pp
index|[
literal|0
index|]
operator|||
name|pp
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|pp
operator|+=
literal|2
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|<<
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_strncpy_l
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|as
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|archive_strncat_l
argument_list|(
name|as
argument_list|,
name|_p
argument_list|,
name|n
argument_list|,
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_strncat_l
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|s
decl_stmt|;
name|size_t
name|length
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
init|=
literal|0
decl_stmt|,
name|r2
decl_stmt|;
if|if
condition|(
name|_p
operator|!=
name|NULL
operator|&&
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|!=
name|NULL
operator|&&
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16
operator|)
condition|)
name|length
operator|=
name|utf16nbytes
argument_list|(
name|_p
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
name|mbsnbytes
argument_list|(
name|_p
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* We must allocate memory even if there is no data for conversion 	 * or copy. This simulates archive_string_append behavior. */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|int
name|tn
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
operator|&&
operator|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16
operator|)
condition|)
name|tn
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|tn
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tn
operator|==
literal|2
condition|)
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If sc is NULL, we just make a copy. 	 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|archive_string_append
argument_list|(
name|as
argument_list|,
name|_p
argument_list|,
name|length
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* No memory */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|s
operator|=
name|_p
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nconverter
operator|>
literal|1
condition|)
block|{
name|sc
operator|->
name|utftmp
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|r2
operator|=
name|sc
operator|->
name|converter
index|[
literal|0
index|]
operator|(
operator|&
operator|(
name|sc
operator|->
name|utftmp
operator|)
operator|,
name|s
operator|,
name|length
operator|,
name|sc
operator|)
expr_stmt|;
if|if
condition|(
name|r2
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOMEM
condition|)
return|return
operator|(
name|r2
operator|)
return|;
if|if
condition|(
name|r
operator|>
name|r2
condition|)
name|r
operator|=
name|r2
expr_stmt|;
name|s
operator|=
name|sc
operator|->
name|utftmp
operator|.
name|s
expr_stmt|;
name|length
operator|=
name|sc
operator|->
name|utftmp
operator|.
name|length
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|r2
operator|=
name|sc
operator|->
name|converter
index|[
name|i
index|]
operator|(
name|as
operator|,
name|s
operator|,
name|length
operator|,
name|sc
operator|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
name|r2
condition|)
name|r
operator|=
name|r2
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_ICONV
end_if

begin_comment
comment|/*  * Return -1 if conversion fails.  */
end_comment

begin_function
specifier|static
name|int
name|iconv_strncat_in_locale
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|ICONV_CONST
name|char
modifier|*
name|itp
decl_stmt|;
name|size_t
name|remaining
decl_stmt|;
name|iconv_t
name|cd
decl_stmt|;
name|char
modifier|*
name|outp
decl_stmt|;
name|size_t
name|avail
decl_stmt|,
name|bs
decl_stmt|;
name|int
name|return_value
init|=
literal|0
decl_stmt|;
comment|/* success */
name|int
name|to_size
decl_stmt|,
name|from_size
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16
condition|)
name|to_size
operator|=
literal|2
expr_stmt|;
else|else
name|to_size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16
condition|)
name|from_size
operator|=
literal|2
expr_stmt|;
else|else
name|from_size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|length
operator|*
literal|2
operator|+
name|to_size
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cd
operator|=
name|sc
operator|->
name|cd
expr_stmt|;
name|itp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|_p
expr_stmt|;
name|remaining
operator|=
name|length
expr_stmt|;
name|outp
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|avail
operator|=
name|as
operator|->
name|buffer_length
operator|-
name|as
operator|->
name|length
operator|-
name|to_size
expr_stmt|;
while|while
condition|(
name|remaining
operator|>=
operator|(
name|size_t
operator|)
name|from_size
condition|)
block|{
name|size_t
name|result
init|=
name|iconv
argument_list|(
name|cd
argument_list|,
operator|&
name|itp
argument_list|,
operator|&
name|remaining
argument_list|,
operator|&
name|outp
argument_list|,
operator|&
name|avail
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
break|break;
comment|/* Conversion completed. */
if|if
condition|(
name|errno
operator|==
name|EILSEQ
operator|||
name|errno
operator|==
name|EINVAL
condition|)
block|{
comment|/* 		 	 * If an output charset is UTF-8 or UTF-16BE/LE, 			 * unknown character should be U+FFFD 			 * (replacement character). 			 */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
operator|(
name|SCONV_TO_UTF8
operator||
name|SCONV_TO_UTF16
operator|)
condition|)
block|{
name|size_t
name|rbytes
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF8
condition|)
name|rbytes
operator|=
sizeof|sizeof
argument_list|(
name|utf8_replacement_char
argument_list|)
expr_stmt|;
else|else
name|rbytes
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|avail
operator|<
name|rbytes
condition|)
block|{
name|as
operator|->
name|length
operator|=
name|outp
operator|-
name|as
operator|->
name|s
expr_stmt|;
name|bs
operator|=
name|as
operator|->
name|buffer_length
operator|+
operator|(
name|remaining
operator|*
name|to_size
operator|)
operator|+
name|rbytes
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|bs
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|outp
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|avail
operator|=
name|as
operator|->
name|buffer_length
operator|-
name|as
operator|->
name|length
operator|-
name|to_size
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF8
condition|)
name|memcpy
argument_list|(
name|outp
argument_list|,
name|utf8_replacement_char
argument_list|,
sizeof|sizeof
argument_list|(
name|utf8_replacement_char
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16BE
condition|)
name|archive_be16enc
argument_list|(
name|outp
argument_list|,
name|UNICODE_R_CHAR
argument_list|)
expr_stmt|;
else|else
name|archive_le16enc
argument_list|(
name|outp
argument_list|,
name|UNICODE_R_CHAR
argument_list|)
expr_stmt|;
name|outp
operator|+=
name|rbytes
expr_stmt|;
name|avail
operator|-=
name|rbytes
expr_stmt|;
block|}
else|else
block|{
comment|/* Skip the illegal input bytes. */
operator|*
name|outp
operator|++
operator|=
literal|'?'
expr_stmt|;
name|avail
operator|--
expr_stmt|;
block|}
name|itp
operator|+=
name|from_size
expr_stmt|;
name|remaining
operator|-=
name|from_size
expr_stmt|;
name|return_value
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* failure */
block|}
else|else
block|{
comment|/* E2BIG no output buffer, 			 * Increase an output buffer.  */
name|as
operator|->
name|length
operator|=
name|outp
operator|-
name|as
operator|->
name|s
expr_stmt|;
name|bs
operator|=
name|as
operator|->
name|buffer_length
operator|+
name|remaining
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|bs
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|outp
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|avail
operator|=
name|as
operator|->
name|buffer_length
operator|-
name|as
operator|->
name|length
operator|-
name|to_size
expr_stmt|;
block|}
block|}
name|as
operator|->
name|length
operator|=
name|outp
operator|-
name|as
operator|->
name|s
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|to_size
operator|==
literal|2
condition|)
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ICONV */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_comment
comment|/*  * Translate a string from a some CodePage to an another CodePage by  * Windows APIs, and copy the result. Return -1 if conversion fails.  */
end_comment

begin_function
specifier|static
name|int
name|strncat_in_codepage
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
decl_stmt|;
name|struct
name|archive_wstring
name|aws
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|int
name|r
decl_stmt|,
name|saved_flag
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|aws
argument_list|)
expr_stmt|;
name|saved_flag
operator|=
name|sc
operator|->
name|flag
expr_stmt|;
name|sc
operator|->
name|flag
operator|&=
operator|~
operator|(
name|SCONV_NORMALIZATION_D
operator||
name|SCONV_NORMALIZATION_C
operator|)
expr_stmt|;
name|r
operator|=
name|archive_wstring_append_from_mbs_in_codepage
argument_list|(
operator|&
name|aws
argument_list|,
name|s
argument_list|,
name|length
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flag
operator|=
name|saved_flag
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|archive_wstring_free
argument_list|(
operator|&
name|aws
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOMEM
condition|)
name|archive_string_append
argument_list|(
name|as
argument_list|,
name|s
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|l
operator|=
name|as
operator|->
name|length
expr_stmt|;
name|r
operator|=
name|archive_string_append_from_wcs_in_codepage
argument_list|(
name|as
argument_list|,
name|aws
operator|.
name|s
argument_list|,
name|aws
operator|.
name|length
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|ENOMEM
operator|&&
name|l
operator|==
name|as
operator|->
name|length
condition|)
name|archive_string_append
argument_list|(
name|as
argument_list|,
name|s
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|archive_wstring_free
argument_list|(
operator|&
name|aws
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether MBS ==> WCS is okay.  */
end_comment

begin_function
specifier|static
name|int
name|invalid_mbs
parameter_list|(
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
decl_stmt|;
name|unsigned
name|codepage
decl_stmt|;
name|DWORD
name|mbflag
init|=
name|MB_ERR_INVALID_CHARS
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_CHARSET
condition|)
name|codepage
operator|=
name|sc
operator|->
name|to_cp
expr_stmt|;
else|else
name|codepage
operator|=
name|sc
operator|->
name|from_cp
expr_stmt|;
if|if
condition|(
name|codepage
operator|==
name|CP_C_LOCALE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|codepage
operator|!=
name|CP_UTF8
condition|)
name|mbflag
operator||=
name|MB_PRECOMPOSED
expr_stmt|;
if|if
condition|(
name|MultiByteToWideChar
argument_list|(
name|codepage
argument_list|,
name|mbflag
argument_list|,
name|p
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Invalid */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Okay */
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Test whether MBS ==> WCS is okay.  */
end_comment

begin_function
specifier|static
name|int
name|invalid_mbs
parameter_list|(
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
decl_stmt|;
name|size_t
name|r
decl_stmt|;
if|#
directive|if
name|HAVE_MBRTOWC
name|mbstate_t
name|shift_state
decl_stmt|;
name|memset
argument_list|(
operator|&
name|shift_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|shift_state
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Clear the shift state before starting. */
name|mbtowc
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|n
condition|)
block|{
name|wchar_t
name|wc
decl_stmt|;
if|#
directive|if
name|HAVE_MBRTOWC
name|r
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
operator|&
name|shift_state
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|r
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Invalid. */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|r
expr_stmt|;
name|n
operator|-=
name|r
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sc
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* All Okey. */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(_WIN32)&& !defined(__CYGWIN__) */
end_comment

begin_comment
comment|/*  * Basically returns -1 because we cannot make a conversion of charset  * without iconv but in some cases this would return 0.  * Returns 0 if all copied characters are ASCII.  * Returns 0 if both from-locale and to-locale are the same and those  * can be WCS with no error.  */
end_comment

begin_function
specifier|static
name|int
name|best_effort_strncat_in_locale
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|size_t
name|remaining
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|itp
decl_stmt|;
name|int
name|return_value
init|=
literal|0
decl_stmt|;
comment|/* success */
comment|/* 	 * If both from-locale and to-locale is the same, this makes a copy. 	 * And then this checks all copied MBS can be WCS if so returns 0. 	 */
if|if
condition|(
name|sc
operator|->
name|same
condition|)
block|{
if|if
condition|(
name|archive_string_append
argument_list|(
name|as
argument_list|,
name|_p
argument_list|,
name|length
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* No memory */
return|return
operator|(
name|invalid_mbs
argument_list|(
name|_p
argument_list|,
name|length
argument_list|,
name|sc
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If a character is ASCII, this just copies it. If not, this 	 * assigns '?' character instead but in UTF-8 locale this assigns 	 * byte sequence 0xEF 0xBD 0xBD, which are code point U+FFFD, 	 * a Replacement Character in Unicode. 	 */
name|remaining
operator|=
name|length
expr_stmt|;
name|itp
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|_p
expr_stmt|;
while|while
condition|(
operator|*
name|itp
operator|&&
name|remaining
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|itp
operator|>
literal|127
condition|)
block|{
comment|// Non-ASCII: Substitute with suitable replacement
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF8
condition|)
block|{
if|if
condition|(
name|archive_string_append
argument_list|(
name|as
argument_list|,
name|utf8_replacement_char
argument_list|,
sizeof|sizeof
argument_list|(
name|utf8_replacement_char
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
block|}
name|return_value
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
operator|*
name|itp
argument_list|)
expr_stmt|;
block|}
operator|++
name|itp
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unicode conversion functions.  *   - UTF-8<===> UTF-8 in removing surrogate pairs.  *   - UTF-8 NFD ===> UTF-8 NFC in removing surrogate pairs.  *   - UTF-8 made by libarchive 2.x ===> UTF-8.  *   - UTF-16BE<===> UTF-8.  *  */
end_comment

begin_comment
comment|/*  * Utility to convert a single UTF-8 sequence.  *  * Usually return used bytes, return used byte in negative value when  * a unicode character is replaced with U+FFFD.  * See also http://unicode.org/review/pr-121.html Public Review Issue #121  * Recommended Practice for Replacement Characters.  */
end_comment

begin_function
specifier|static
name|int
name|_utf8_to_unicode
parameter_list|(
name|uint32_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|utf8_count
index|[
literal|256
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 00 - 0F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 10 - 1F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 20 - 2F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 30 - 3F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 40 - 4F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 50 - 5F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 60 - 6F */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 70 - 7F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 80 - 8F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 90 - 9F */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* A0 - AF */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* B0 - BF */
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* C0 - CF */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* D0 - DF */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* E0 - EF */
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* F0 - FF */
block|}
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|uint32_t
name|wc
decl_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Decode 1-4 bytes depending on the value of the first byte. 	 */
name|ch
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Standard:  return 0 for end-of-string. */
name|cnt
operator|=
name|utf8_count
index|[
name|ch
index|]
expr_stmt|;
comment|/* Invalid sequence or there are not plenty bytes. */
if|if
condition|(
operator|(
name|int
operator|)
name|n
operator|<
name|cnt
condition|)
block|{
name|cnt
operator|=
operator|(
name|int
operator|)
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|s
index|[
name|i
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|cnt
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
goto|goto
name|invalid_sequence
goto|;
block|}
comment|/* Make a Unicode code point from a single UTF-8 sequence. */
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
literal|1
case|:
comment|/* 1 byte sequence. */
operator|*
name|pwc
operator|=
name|ch
operator|&
literal|0x7f
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
case|case
literal|2
case|:
comment|/* 2 bytes sequence. */
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|cnt
operator|=
literal|1
expr_stmt|;
goto|goto
name|invalid_sequence
goto|;
block|}
operator|*
name|pwc
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0x1f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
case|case
literal|3
case|:
comment|/* 3 bytes sequence. */
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|cnt
operator|=
literal|1
expr_stmt|;
goto|goto
name|invalid_sequence
goto|;
block|}
if|if
condition|(
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|cnt
operator|=
literal|2
expr_stmt|;
goto|goto
name|invalid_sequence
goto|;
block|}
name|wc
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0x0f
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
if|if
condition|(
name|wc
operator|<
literal|0x800
condition|)
goto|goto
name|invalid_sequence
goto|;
comment|/* Overlong sequence. */
break|break;
case|case
literal|4
case|:
comment|/* 4 bytes sequence. */
if|if
condition|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|cnt
operator|=
literal|1
expr_stmt|;
goto|goto
name|invalid_sequence
goto|;
block|}
if|if
condition|(
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|cnt
operator|=
literal|2
expr_stmt|;
goto|goto
name|invalid_sequence
goto|;
block|}
if|if
condition|(
operator|(
name|s
index|[
literal|3
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|cnt
operator|=
literal|3
expr_stmt|;
goto|goto
name|invalid_sequence
goto|;
block|}
name|wc
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0x07
operator|)
operator|<<
literal|18
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|s
index|[
literal|3
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
if|if
condition|(
name|wc
operator|<
literal|0x10000
condition|)
goto|goto
name|invalid_sequence
goto|;
comment|/* Overlong sequence. */
break|break;
default|default:
comment|/* Others are all invalid sequence. */
if|if
condition|(
name|ch
operator|==
literal|0xc0
operator|||
name|ch
operator|==
literal|0xc1
condition|)
name|cnt
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|0xf5
operator|&&
name|ch
operator|<=
literal|0xf7
condition|)
name|cnt
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|0xf8
operator|&&
name|ch
operator|<=
literal|0xfb
condition|)
name|cnt
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|0xfc
operator|||
name|ch
operator|==
literal|0xfd
condition|)
name|cnt
operator|=
literal|6
expr_stmt|;
else|else
name|cnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|n
operator|<
name|cnt
condition|)
name|cnt
operator|=
operator|(
name|int
operator|)
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|s
index|[
name|i
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|cnt
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
goto|goto
name|invalid_sequence
goto|;
block|}
comment|/* The code point larger than 0x10FFFF is not legal 	 * Unicode values. */
if|if
condition|(
name|wc
operator|>
name|UNICODE_MAX
condition|)
goto|goto
name|invalid_sequence
goto|;
comment|/* Correctly gets a Unicode, returns used bytes. */
operator|*
name|pwc
operator|=
name|wc
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
name|invalid_sequence
label|:
operator|*
name|pwc
operator|=
name|UNICODE_R_CHAR
expr_stmt|;
comment|/* set the Replacement Character instead. */
return|return
operator|(
name|cnt
operator|*
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|utf8_to_unicode
parameter_list|(
name|uint32_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
name|_utf8_to_unicode
argument_list|(
name|pwc
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Any of Surrogate pair is not legal Unicode values. */
if|if
condition|(
name|cnt
operator|==
literal|3
operator|&&
name|IS_SURROGATE_PAIR_LA
argument_list|(
operator|*
name|pwc
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|combine_surrogate_pair
parameter_list|(
name|uint32_t
name|uc
parameter_list|,
name|uint32_t
name|uc2
parameter_list|)
block|{
name|uc
operator|-=
literal|0xD800
expr_stmt|;
name|uc
operator|*=
literal|0x400
expr_stmt|;
name|uc
operator|+=
name|uc2
operator|-
literal|0xDC00
expr_stmt|;
name|uc
operator|+=
literal|0x10000
expr_stmt|;
return|return
operator|(
name|uc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a single UTF-8/CESU-8 sequence to a Unicode code point in  * removing surrogate pairs.  *  * CESU-8: The Compatibility Encoding Scheme for UTF-16.  *  * Usually return used bytes, return used byte in negative value when  * a unicode character is replaced with U+FFFD.  */
end_comment

begin_function
specifier|static
name|int
name|cesu8_to_unicode
parameter_list|(
name|uint32_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|uint32_t
name|wc
init|=
literal|0
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
name|_utf8_to_unicode
argument_list|(
operator|&
name|wc
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|3
operator|&&
name|IS_HIGH_SURROGATE_LA
argument_list|(
name|wc
argument_list|)
condition|)
block|{
name|uint32_t
name|wc2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|n
operator|-
literal|3
operator|<
literal|3
condition|)
block|{
comment|/* Invalid byte sequence. */
goto|goto
name|invalid_sequence
goto|;
block|}
name|cnt
operator|=
name|_utf8_to_unicode
argument_list|(
operator|&
name|wc2
argument_list|,
name|s
operator|+
literal|3
argument_list|,
name|n
operator|-
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|3
operator|||
operator|!
name|IS_LOW_SURROGATE_LA
argument_list|(
name|wc2
argument_list|)
condition|)
block|{
comment|/* Invalid byte sequence. */
goto|goto
name|invalid_sequence
goto|;
block|}
name|wc
operator|=
name|combine_surrogate_pair
argument_list|(
name|wc
argument_list|,
name|wc2
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cnt
operator|==
literal|3
operator|&&
name|IS_LOW_SURROGATE_LA
argument_list|(
name|wc
argument_list|)
condition|)
block|{
comment|/* Invalid byte sequence. */
goto|goto
name|invalid_sequence
goto|;
block|}
operator|*
name|pwc
operator|=
name|wc
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
name|invalid_sequence
label|:
operator|*
name|pwc
operator|=
name|UNICODE_R_CHAR
expr_stmt|;
comment|/* set the Replacement Character instead. */
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
name|cnt
operator|*=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a Unicode code point to a single UTF-8 sequence.  *  * NOTE:This function does not check if the Unicode is legal or not.  * Please you definitely check it before calling this.  */
end_comment

begin_function
specifier|static
name|size_t
name|unicode_to_utf8
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|remaining
parameter_list|,
name|uint32_t
name|uc
parameter_list|)
block|{
name|char
modifier|*
name|_p
init|=
name|p
decl_stmt|;
comment|/* Invalid Unicode char maps to Replacement character */
if|if
condition|(
name|uc
operator|>
name|UNICODE_MAX
condition|)
name|uc
operator|=
name|UNICODE_R_CHAR
expr_stmt|;
comment|/* Translate code point to UTF8 */
if|if
condition|(
name|uc
operator|<=
literal|0x7f
condition|)
block|{
if|if
condition|(
name|remaining
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|p
operator|++
operator|=
operator|(
name|char
operator|)
name|uc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
operator|<=
literal|0x7ff
condition|)
block|{
if|if
condition|(
name|remaining
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|p
operator|++
operator|=
literal|0xc0
operator||
operator|(
operator|(
name|uc
operator|>>
literal|6
operator|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
name|uc
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
operator|<=
literal|0xffff
condition|)
block|{
if|if
condition|(
name|remaining
operator|<
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|p
operator|++
operator|=
literal|0xe0
operator||
operator|(
operator|(
name|uc
operator|>>
literal|12
operator|)
operator|&
literal|0x0f
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
operator|(
name|uc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
name|uc
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remaining
operator|<
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|p
operator|++
operator|=
literal|0xf0
operator||
operator|(
operator|(
name|uc
operator|>>
literal|18
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
operator|(
name|uc
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
operator|(
name|uc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
name|uc
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|-
name|_p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|utf16be_to_unicode
parameter_list|(
name|uint32_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|utf16_to_unicode
argument_list|(
name|pwc
argument_list|,
name|s
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|utf16le_to_unicode
parameter_list|(
name|uint32_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|utf16_to_unicode
argument_list|(
name|pwc
argument_list|,
name|s
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|utf16_to_unicode
parameter_list|(
name|uint32_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|,
name|int
name|be
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|utf16
init|=
name|s
decl_stmt|;
name|unsigned
name|uc
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
comment|/* set the Replacement Character instead. */
operator|*
name|pwc
operator|=
name|UNICODE_R_CHAR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|be
condition|)
name|uc
operator|=
name|archive_be16dec
argument_list|(
name|utf16
argument_list|)
expr_stmt|;
else|else
name|uc
operator|=
name|archive_le16dec
argument_list|(
name|utf16
argument_list|)
expr_stmt|;
name|utf16
operator|+=
literal|2
expr_stmt|;
comment|/* If this is a surrogate pair, assemble the full code point.*/
if|if
condition|(
name|IS_HIGH_SURROGATE_LA
argument_list|(
name|uc
argument_list|)
condition|)
block|{
name|unsigned
name|uc2
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|be
condition|)
name|uc2
operator|=
name|archive_be16dec
argument_list|(
name|utf16
argument_list|)
expr_stmt|;
else|else
name|uc2
operator|=
name|archive_le16dec
argument_list|(
name|utf16
argument_list|)
expr_stmt|;
block|}
else|else
name|uc2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_LOW_SURROGATE_LA
argument_list|(
name|uc2
argument_list|)
condition|)
block|{
name|uc
operator|=
name|combine_surrogate_pair
argument_list|(
name|uc
argument_list|,
name|uc2
argument_list|)
expr_stmt|;
name|utf16
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Undescribed code point should be U+FFFD 		 	* (replacement character). */
operator|*
name|pwc
operator|=
name|UNICODE_R_CHAR
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
comment|/* 	 * Surrogate pair values(0xd800 through 0xdfff) are only 	 * used by UTF-16, so, after above calculation, the code 	 * must not be surrogate values, and Unicode has no codes 	 * larger than 0x10ffff. Thus, those are not legal Unicode 	 * values. 	 */
if|if
condition|(
name|IS_SURROGATE_PAIR_LA
argument_list|(
name|uc
argument_list|)
operator|||
name|uc
operator|>
name|UNICODE_MAX
condition|)
block|{
comment|/* Undescribed code point should be U+FFFD 	 	* (replacement character). */
operator|*
name|pwc
operator|=
name|UNICODE_R_CHAR
expr_stmt|;
return|return
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|utf16
operator|-
name|s
argument_list|)
operator|)
operator|*
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|pwc
operator|=
name|uc
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|utf16
operator|-
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|unicode_to_utf16be
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|remaining
parameter_list|,
name|uint32_t
name|uc
parameter_list|)
block|{
name|char
modifier|*
name|utf16
init|=
name|p
decl_stmt|;
if|if
condition|(
name|uc
operator|>
literal|0xffff
condition|)
block|{
comment|/* We have a code point that won't fit into a 		 * wchar_t; convert it to a surrogate pair. */
if|if
condition|(
name|remaining
operator|<
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|uc
operator|-=
literal|0x10000
expr_stmt|;
name|archive_be16enc
argument_list|(
name|utf16
argument_list|,
operator|(
operator|(
name|uc
operator|>>
literal|10
operator|)
operator|&
literal|0x3ff
operator|)
operator|+
literal|0xD800
argument_list|)
expr_stmt|;
name|archive_be16enc
argument_list|(
name|utf16
operator|+
literal|2
argument_list|,
operator|(
name|uc
operator|&
literal|0x3ff
operator|)
operator|+
literal|0xDC00
argument_list|)
expr_stmt|;
return|return
operator|(
literal|4
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|remaining
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|archive_be16enc
argument_list|(
name|utf16
argument_list|,
name|uc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|unicode_to_utf16le
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|remaining
parameter_list|,
name|uint32_t
name|uc
parameter_list|)
block|{
name|char
modifier|*
name|utf16
init|=
name|p
decl_stmt|;
if|if
condition|(
name|uc
operator|>
literal|0xffff
condition|)
block|{
comment|/* We have a code point that won't fit into a 		 * wchar_t; convert it to a surrogate pair. */
if|if
condition|(
name|remaining
operator|<
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|uc
operator|-=
literal|0x10000
expr_stmt|;
name|archive_le16enc
argument_list|(
name|utf16
argument_list|,
operator|(
operator|(
name|uc
operator|>>
literal|10
operator|)
operator|&
literal|0x3ff
operator|)
operator|+
literal|0xD800
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|utf16
operator|+
literal|2
argument_list|,
operator|(
name|uc
operator|&
literal|0x3ff
operator|)
operator|+
literal|0xDC00
argument_list|)
expr_stmt|;
return|return
operator|(
literal|4
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|remaining
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|archive_le16enc
argument_list|(
name|utf16
argument_list|,
name|uc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy UTF-8 string in checking surrogate pair.  * If any surrogate pair are found, it would be canonicalized.  */
end_comment

begin_function
specifier|static
name|int
name|strncat_from_utf8_to_utf8
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|sc
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|len
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|s
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
expr_stmt|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|endp
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|buffer_length
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|uint32_t
name|uc
decl_stmt|;
specifier|const
name|char
modifier|*
name|ss
init|=
name|s
decl_stmt|;
name|size_t
name|w
decl_stmt|;
comment|/* 		 * Forward byte sequence until a conversion of that is needed. 		 */
while|while
condition|(
operator|(
name|n
operator|=
name|utf8_to_unicode
argument_list|(
operator|&
name|uc
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|s
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|ss
operator|<
name|s
condition|)
block|{
if|if
condition|(
name|p
operator|+
operator|(
name|s
operator|-
name|ss
operator|)
operator|>
name|endp
condition|)
block|{
name|as
operator|->
name|length
operator|=
name|p
operator|-
name|as
operator|->
name|s
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|buffer_length
operator|+
name|len
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|endp
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|buffer_length
operator|-
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|ss
argument_list|,
name|s
operator|-
name|ss
argument_list|)
expr_stmt|;
name|p
operator|+=
name|s
operator|-
name|ss
expr_stmt|;
block|}
comment|/* 		 * If n is negative, current byte sequence needs a replacement. 		 */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
operator|-
literal|3
operator|&&
name|IS_SURROGATE_PAIR_LA
argument_list|(
name|uc
argument_list|)
condition|)
block|{
comment|/* Current byte sequence may be CESU-8. */
name|n
operator|=
name|cesu8_to_unicode
argument_list|(
operator|&
name|uc
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|n
operator|*=
operator|-
literal|1
expr_stmt|;
comment|/* Use a replaced unicode character. */
block|}
comment|/* Rebuild UTF-8 byte sequence. */
while|while
condition|(
operator|(
name|w
operator|=
name|unicode_to_utf8
argument_list|(
name|p
argument_list|,
name|endp
operator|-
name|p
argument_list|,
name|uc
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|as
operator|->
name|length
operator|=
name|p
operator|-
name|as
operator|->
name|s
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|buffer_length
operator|+
name|len
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|endp
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|buffer_length
operator|-
literal|1
expr_stmt|;
block|}
name|p
operator|+=
name|w
expr_stmt|;
name|s
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
block|}
do|while
condition|(
name|n
operator|>
literal|0
condition|)
do|;
name|as
operator|->
name|length
operator|=
name|p
operator|-
name|as
operator|->
name|s
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_string_append_unicode
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|uint32_t
name|uc
decl_stmt|;
name|size_t
name|w
decl_stmt|;
name|int
name|n
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|ts
decl_stmt|,
name|tm
decl_stmt|;
name|int
function_decl|(
modifier|*
name|parse
function_decl|)
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|size_t
function_decl|(
modifier|*
name|unparse
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16BE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16be
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16LE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16le
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF8
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf8
expr_stmt|;
name|ts
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This case is going to be converted to another 		 * character-set through iconv. 		 */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16BE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16be
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16LE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16le
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|unparse
operator|=
name|unicode_to_utf8
expr_stmt|;
name|ts
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16BE
condition|)
block|{
name|parse
operator|=
name|utf16be_to_unicode
expr_stmt|;
name|tm
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16LE
condition|)
block|{
name|parse
operator|=
name|utf16le_to_unicode
expr_stmt|;
name|tm
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|parse
operator|=
name|cesu8_to_unicode
expr_stmt|;
name|tm
operator|=
name|ts
expr_stmt|;
block|}
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|len
operator|*
name|tm
operator|+
name|ts
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|s
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
expr_stmt|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|endp
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|buffer_length
operator|-
name|ts
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|parse
argument_list|(
operator|&
name|uc
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* Use a replaced unicode character. */
name|n
operator|*=
operator|-
literal|1
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|s
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|unparse
argument_list|(
name|p
argument_list|,
name|endp
operator|-
name|p
argument_list|,
name|uc
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* There is not enough output buffer so 			 * we have to expand it. */
name|as
operator|->
name|length
operator|=
name|p
operator|-
name|as
operator|->
name|s
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|buffer_length
operator|+
name|len
operator|*
name|tm
operator|+
name|ts
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|endp
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|buffer_length
operator|-
name|ts
expr_stmt|;
block|}
name|p
operator|+=
name|w
expr_stmt|;
block|}
name|as
operator|->
name|length
operator|=
name|p
operator|-
name|as
operator|->
name|s
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ts
operator|==
literal|2
condition|)
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Following Constants for Hangul compositions this information comes from  * Unicode Standard Annex #15  http://unicode.org/reports/tr15/  */
end_comment

begin_define
define|#
directive|define
name|HC_SBASE
value|0xAC00
end_define

begin_define
define|#
directive|define
name|HC_LBASE
value|0x1100
end_define

begin_define
define|#
directive|define
name|HC_VBASE
value|0x1161
end_define

begin_define
define|#
directive|define
name|HC_TBASE
value|0x11A7
end_define

begin_define
define|#
directive|define
name|HC_LCOUNT
value|19
end_define

begin_define
define|#
directive|define
name|HC_VCOUNT
value|21
end_define

begin_define
define|#
directive|define
name|HC_TCOUNT
value|28
end_define

begin_define
define|#
directive|define
name|HC_NCOUNT
value|(HC_VCOUNT * HC_TCOUNT)
end_define

begin_define
define|#
directive|define
name|HC_SCOUNT
value|(HC_LCOUNT * HC_NCOUNT)
end_define

begin_function
specifier|static
name|uint32_t
name|get_nfc
parameter_list|(
name|uint32_t
name|uc
parameter_list|,
name|uint32_t
name|uc2
parameter_list|)
block|{
name|int
name|t
decl_stmt|,
name|b
decl_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
name|b
operator|=
sizeof|sizeof
argument_list|(
name|u_composition_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u_composition_table
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|b
operator|>=
name|t
condition|)
block|{
name|int
name|m
init|=
operator|(
name|t
operator|+
name|b
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|u_composition_table
index|[
name|m
index|]
operator|.
name|cp1
operator|<
name|uc
condition|)
name|t
operator|=
name|m
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|u_composition_table
index|[
name|m
index|]
operator|.
name|cp1
operator|>
name|uc
condition|)
name|b
operator|=
name|m
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|u_composition_table
index|[
name|m
index|]
operator|.
name|cp2
operator|<
name|uc2
condition|)
name|t
operator|=
name|m
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|u_composition_table
index|[
name|m
index|]
operator|.
name|cp2
operator|>
name|uc2
condition|)
name|b
operator|=
name|m
operator|-
literal|1
expr_stmt|;
else|else
return|return
operator|(
name|u_composition_table
index|[
name|m
index|]
operator|.
name|nfc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FDC_MAX
value|10
end_define

begin_comment
comment|/* The maximum number of Following Decomposable 			 * Characters. */
end_comment

begin_comment
comment|/*  * Update first code point.  */
end_comment

begin_define
define|#
directive|define
name|UPDATE_UC
parameter_list|(
name|new_uc
parameter_list|)
value|do {		\ 	uc = new_uc;				\ 	ucptr = NULL;				\ } while (0)
end_define

begin_comment
comment|/*  * Replace first code point with second code point.  */
end_comment

begin_define
define|#
directive|define
name|REPLACE_UC_WITH_UC2
parameter_list|()
value|do {		\ 	uc = uc2;				\ 	ucptr = uc2ptr;				\ 	n = n2;					\ } while (0)
end_define

begin_define
define|#
directive|define
name|EXPAND_BUFFER
parameter_list|()
value|do {			\ 	as->length = p - as->s;			\ 	if (archive_string_ensure(as,		\ 	    as->buffer_length + len * tm + ts) == NULL)\ 		return (-1);			\ 	p = as->s + as->length;			\ 	endp = as->s + as->buffer_length - ts;	\ } while (0)
end_define

begin_define
define|#
directive|define
name|UNPARSE
parameter_list|(
name|p
parameter_list|,
name|endp
parameter_list|,
name|uc
parameter_list|)
value|do {		\ 	while ((w = unparse(p, (endp) - (p), uc)) == 0) {\ 		EXPAND_BUFFER();		\ 	}					\ 	p += w;					\ } while (0)
end_define

begin_comment
comment|/*  * Write first code point.  * If the code point has not be changed from its original code,  * this just copies it from its original buffer pointer.  * If not, this converts it to UTF-8 byte sequence and copies it.  */
end_comment

begin_define
define|#
directive|define
name|WRITE_UC
parameter_list|()
value|do {			\ 	if (ucptr) {				\ 		if (p + n> endp)		\ 			EXPAND_BUFFER();	\ 		switch (n) {			\ 		case 4:				\ 			*p++ = *ucptr++;	\
comment|/* FALL THROUGH */
value|\ 		case 3:				\ 			*p++ = *ucptr++;	\
comment|/* FALL THROUGH */
value|\ 		case 2:				\ 			*p++ = *ucptr++;	\
comment|/* FALL THROUGH */
value|\ 		case 1:				\ 			*p++ = *ucptr;		\ 			break;			\ 		}				\ 		ucptr = NULL;			\ 	} else {				\ 		UNPARSE(p, endp, uc);		\ 	}					\ } while (0)
end_define

begin_comment
comment|/*  * Collect following decomposable code points.  */
end_comment

begin_define
define|#
directive|define
name|COLLECT_CPS
parameter_list|(
name|start
parameter_list|)
value|do {		\ 	int _i;					\ 	for (_i = start; _i< FDC_MAX ; _i++) {	\ 		nx = parse(&ucx[_i], s, len);	\ 		if (nx<= 0)			\ 			break;			\ 		cx = CCC(ucx[_i]);		\ 		if (cl>= cx&& cl != 228&& cx != 228)\ 			break;			\ 		s += nx;			\ 		len -= nx;			\ 		cl = cx;			\ 		ccx[_i] = cx;			\ 	}					\ 	if (_i>= FDC_MAX) {			\ 		ret = -1;			\ 		ucx_size = FDC_MAX;		\ 	} else					\ 		ucx_size = _i;			\ } while (0)
end_define

begin_comment
comment|/*  * Normalize UTF-8/UTF-16BE characters to Form C and copy the result.  *  * TODO: Convert composition exclusions, which are never converted  * from NFC,NFD,NFKC and NFKD, to Form C.  */
end_comment

begin_function
specifier|static
name|int
name|archive_string_normalize_C
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|uint32_t
name|uc
decl_stmt|,
name|uc2
decl_stmt|;
name|size_t
name|w
decl_stmt|;
name|int
name|always_replace
decl_stmt|,
name|n
decl_stmt|,
name|n2
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|spair
decl_stmt|,
name|ts
decl_stmt|,
name|tm
decl_stmt|;
name|int
function_decl|(
modifier|*
name|parse
function_decl|)
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|size_t
function_decl|(
modifier|*
name|unparse
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
name|always_replace
operator|=
literal|1
expr_stmt|;
name|ts
operator|=
literal|1
expr_stmt|;
comment|/* text size. */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16BE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16be
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16BE
condition|)
name|always_replace
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16LE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16le
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16LE
condition|)
name|always_replace
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF8
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf8
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF8
condition|)
name|always_replace
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This case is going to be converted to another 		 * character-set through iconv. 		 */
name|always_replace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16BE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16be
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16LE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16le
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|unparse
operator|=
name|unicode_to_utf8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16BE
condition|)
block|{
name|parse
operator|=
name|utf16be_to_unicode
expr_stmt|;
name|tm
operator|=
literal|1
expr_stmt|;
name|spair
operator|=
literal|4
expr_stmt|;
comment|/* surrogate pair size in UTF-16. */
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16LE
condition|)
block|{
name|parse
operator|=
name|utf16le_to_unicode
expr_stmt|;
name|tm
operator|=
literal|1
expr_stmt|;
name|spair
operator|=
literal|4
expr_stmt|;
comment|/* surrogate pair size in UTF-16. */
block|}
else|else
block|{
name|parse
operator|=
name|cesu8_to_unicode
expr_stmt|;
name|tm
operator|=
name|ts
expr_stmt|;
name|spair
operator|=
literal|6
expr_stmt|;
comment|/* surrogate pair size in UTF-8. */
block|}
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|len
operator|*
name|tm
operator|+
name|ts
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|endp
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|buffer_length
operator|-
name|ts
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|parse
argument_list|(
operator|&
name|uc
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|ucptr
decl_stmt|,
modifier|*
name|uc2ptr
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* Use a replaced unicode character. */
name|UNPARSE
argument_list|(
name|p
argument_list|,
name|endp
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|+=
name|n
operator|*
operator|-
literal|1
expr_stmt|;
name|len
operator|-=
name|n
operator|*
operator|-
literal|1
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
name|spair
operator|||
name|always_replace
condition|)
comment|/* uc is converted from a surrogate pair. 			 * this should be treated as a changed code. */
name|ucptr
operator|=
name|NULL
expr_stmt|;
else|else
name|ucptr
operator|=
name|s
expr_stmt|;
name|s
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
comment|/* Read second code point. */
while|while
condition|(
operator|(
name|n2
operator|=
name|parse
argument_list|(
operator|&
name|uc2
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|ucx
index|[
name|FDC_MAX
index|]
decl_stmt|;
name|int
name|ccx
index|[
name|FDC_MAX
index|]
decl_stmt|;
name|int
name|cl
decl_stmt|,
name|cx
decl_stmt|,
name|i
decl_stmt|,
name|nx
decl_stmt|,
name|ucx_size
decl_stmt|;
name|int
name|LIndex
decl_stmt|,
name|SIndex
decl_stmt|;
name|uint32_t
name|nfc
decl_stmt|;
if|if
condition|(
name|n2
operator|==
name|spair
operator|||
name|always_replace
condition|)
comment|/* uc2 is converted from a surrogate pair. 			 	 * this should be treated as a changed code. */
name|uc2ptr
operator|=
name|NULL
expr_stmt|;
else|else
name|uc2ptr
operator|=
name|s
expr_stmt|;
name|s
operator|+=
name|n2
expr_stmt|;
name|len
operator|-=
name|n2
expr_stmt|;
comment|/* 			 * If current second code point is out of decomposable 			 * code points, finding compositions is unneeded. 			 */
if|if
condition|(
operator|!
name|IS_DECOMPOSABLE_BLOCK
argument_list|(
name|uc2
argument_list|)
condition|)
block|{
name|WRITE_UC
argument_list|()
expr_stmt|;
name|REPLACE_UC_WITH_UC2
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Try to combine current code points. 			 */
comment|/* 			 * We have to combine Hangul characters according to 			 * http://uniicode.org/reports/tr15/#Hangul 			 */
if|if
condition|(
literal|0
operator|<=
operator|(
name|LIndex
operator|=
name|uc
operator|-
name|HC_LBASE
operator|)
operator|&&
name|LIndex
operator|<
name|HC_LCOUNT
condition|)
block|{
comment|/* 				 * Hangul Composition. 				 * 1. Two current code points are L and V. 				 */
name|int
name|VIndex
init|=
name|uc2
operator|-
name|HC_VBASE
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|VIndex
operator|&&
name|VIndex
operator|<
name|HC_VCOUNT
condition|)
block|{
comment|/* Make syllable of form LV. */
name|UPDATE_UC
argument_list|(
name|HC_SBASE
operator|+
operator|(
name|LIndex
operator|*
name|HC_VCOUNT
operator|+
name|VIndex
operator|)
operator|*
name|HC_TCOUNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_UC
argument_list|()
expr_stmt|;
name|REPLACE_UC_WITH_UC2
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|0
operator|<=
operator|(
name|SIndex
operator|=
name|uc
operator|-
name|HC_SBASE
operator|)
operator|&&
name|SIndex
operator|<
name|HC_SCOUNT
operator|&&
operator|(
name|SIndex
operator|%
name|HC_TCOUNT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Hangul Composition. 				 * 2. Two current code points are LV and T. 				 */
name|int
name|TIndex
init|=
name|uc2
operator|-
name|HC_TBASE
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|TIndex
operator|&&
name|TIndex
operator|<
name|HC_TCOUNT
condition|)
block|{
comment|/* Make syllable of form LVT. */
name|UPDATE_UC
argument_list|(
name|uc
operator|+
name|TIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_UC
argument_list|()
expr_stmt|;
name|REPLACE_UC_WITH_UC2
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|nfc
operator|=
name|get_nfc
argument_list|(
name|uc
argument_list|,
name|uc2
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* A composition to current code points 				 * is found. */
name|UPDATE_UC
argument_list|(
name|nfc
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|cl
operator|=
name|CCC
argument_list|(
name|uc2
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Clearly 'uc2' the second code point is not 				 * a decomposable code. */
name|WRITE_UC
argument_list|()
expr_stmt|;
name|REPLACE_UC_WITH_UC2
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Collect following decomposable code points. 			 */
name|cx
operator|=
literal|0
expr_stmt|;
name|ucx
index|[
literal|0
index|]
operator|=
name|uc2
expr_stmt|;
name|ccx
index|[
literal|0
index|]
operator|=
name|cl
expr_stmt|;
name|COLLECT_CPS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Find a composed code in the collected code points. 			 */
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|ucx_size
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|nfc
operator|=
name|get_nfc
argument_list|(
name|uc
argument_list|,
name|ucx
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * nfc is composed of uc and ucx[i]. 				 */
name|UPDATE_UC
argument_list|(
name|nfc
argument_list|)
expr_stmt|;
comment|/* 				 * Remove ucx[i] by shifting 				 * following code points. 				 */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|+
literal|1
operator|<
name|ucx_size
condition|;
name|j
operator|++
control|)
block|{
name|ucx
index|[
name|j
index|]
operator|=
name|ucx
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|ccx
index|[
name|j
index|]
operator|=
name|ccx
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|ucx_size
operator|--
expr_stmt|;
comment|/* 				 * Collect following code points blocked 				 * by ucx[i] the removed code point. 				 */
if|if
condition|(
name|ucx_size
operator|>
literal|0
operator|&&
name|i
operator|==
name|ucx_size
operator|&&
name|nx
operator|>
literal|0
operator|&&
name|cx
operator|==
name|cl
condition|)
block|{
name|cl
operator|=
name|ccx
index|[
name|ucx_size
operator|-
literal|1
index|]
expr_stmt|;
name|COLLECT_CPS
argument_list|(
name|ucx_size
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Restart finding a composed code with 				 * the updated uc from the top of the 				 * collected code points. 				 */
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Apparently the current code points are not 			 * decomposed characters or already composed. 			 */
name|WRITE_UC
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ucx_size
condition|;
name|i
operator|++
control|)
name|UNPARSE
argument_list|(
name|p
argument_list|,
name|endp
argument_list|,
name|ucx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 			 * Flush out remaining canonical combining characters. 			 */
if|if
condition|(
name|nx
operator|>
literal|0
operator|&&
name|cx
operator|==
name|cl
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|nx
operator|=
name|parse
argument_list|(
operator|&
name|ucx
index|[
literal|0
index|]
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cx
operator|=
name|CCC
argument_list|(
name|ucx
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|>
name|cx
condition|)
break|break;
name|s
operator|+=
name|nx
expr_stmt|;
name|len
operator|-=
name|nx
expr_stmt|;
name|cl
operator|=
name|cx
expr_stmt|;
name|UNPARSE
argument_list|(
name|p
argument_list|,
name|endp
argument_list|,
name|ucx
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|n2
operator|<
literal|0
condition|)
block|{
name|WRITE_UC
argument_list|()
expr_stmt|;
comment|/* Use a replaced unicode character. */
name|UNPARSE
argument_list|(
name|p
argument_list|,
name|endp
argument_list|,
name|uc2
argument_list|)
expr_stmt|;
name|s
operator|+=
name|n2
operator|*
operator|-
literal|1
expr_stmt|;
name|len
operator|-=
name|n2
operator|*
operator|-
literal|1
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|n2
operator|==
literal|0
condition|)
block|{
name|WRITE_UC
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|as
operator|->
name|length
operator|=
name|p
operator|-
name|as
operator|->
name|s
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ts
operator|==
literal|2
condition|)
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_nfd
parameter_list|(
name|uint32_t
modifier|*
name|cp1
parameter_list|,
name|uint32_t
modifier|*
name|cp2
parameter_list|,
name|uint32_t
name|uc
parameter_list|)
block|{
name|int
name|t
decl_stmt|,
name|b
decl_stmt|;
comment|/* 	 * These are not converted to NFD on Mac OS. 	 */
if|if
condition|(
operator|(
name|uc
operator|>=
literal|0x2000
operator|&&
name|uc
operator|<=
literal|0x2FFF
operator|)
operator|||
operator|(
name|uc
operator|>=
literal|0xF900
operator|&&
name|uc
operator|<=
literal|0xFAFF
operator|)
operator|||
operator|(
name|uc
operator|>=
literal|0x2F800
operator|&&
name|uc
operator|<=
literal|0x2FAFF
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Those code points are not converted to NFD on Mac OS. 	 * I do not know the reason because it is undocumented. 	 *   NFC        NFD 	 *   1109A  ==> 11099 110BA 	 *   1109C  ==> 1109B 110BA 	 *   110AB  ==> 110A5 110BA 	 */
if|if
condition|(
name|uc
operator|==
literal|0x1109A
operator|||
name|uc
operator|==
literal|0x1109C
operator|||
name|uc
operator|==
literal|0x110AB
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t
operator|=
literal|0
expr_stmt|;
name|b
operator|=
sizeof|sizeof
argument_list|(
name|u_decomposition_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u_decomposition_table
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|b
operator|>=
name|t
condition|)
block|{
name|int
name|m
init|=
operator|(
name|t
operator|+
name|b
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|u_decomposition_table
index|[
name|m
index|]
operator|.
name|nfc
operator|<
name|uc
condition|)
name|t
operator|=
name|m
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|u_decomposition_table
index|[
name|m
index|]
operator|.
name|nfc
operator|>
name|uc
condition|)
name|b
operator|=
name|m
operator|-
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|cp1
operator|=
name|u_decomposition_table
index|[
name|m
index|]
operator|.
name|cp1
expr_stmt|;
operator|*
name|cp2
operator|=
name|u_decomposition_table
index|[
name|m
index|]
operator|.
name|cp2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|REPLACE_UC_WITH
parameter_list|(
name|cp
parameter_list|)
value|do {		\ 	uc = cp;				\ 	ucptr = NULL;				\ } while (0)
end_define

begin_comment
comment|/*  * Normalize UTF-8 characters to Form D and copy the result.  */
end_comment

begin_function
specifier|static
name|int
name|archive_string_normalize_D
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|uint32_t
name|uc
decl_stmt|,
name|uc2
decl_stmt|;
name|size_t
name|w
decl_stmt|;
name|int
name|always_replace
decl_stmt|,
name|n
decl_stmt|,
name|n2
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|spair
decl_stmt|,
name|ts
decl_stmt|,
name|tm
decl_stmt|;
name|int
function_decl|(
modifier|*
name|parse
function_decl|)
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|size_t
function_decl|(
modifier|*
name|unparse
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
name|always_replace
operator|=
literal|1
expr_stmt|;
name|ts
operator|=
literal|1
expr_stmt|;
comment|/* text size. */
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16BE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16be
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16BE
condition|)
name|always_replace
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF16LE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16le
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16LE
condition|)
name|always_replace
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_TO_UTF8
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf8
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF8
condition|)
name|always_replace
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This case is going to be converted to another 		 * character-set through iconv. 		 */
name|always_replace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16BE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16be
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16LE
condition|)
block|{
name|unparse
operator|=
name|unicode_to_utf16le
expr_stmt|;
name|ts
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|unparse
operator|=
name|unicode_to_utf8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16BE
condition|)
block|{
name|parse
operator|=
name|utf16be_to_unicode
expr_stmt|;
name|tm
operator|=
literal|1
expr_stmt|;
name|spair
operator|=
literal|4
expr_stmt|;
comment|/* surrogate pair size in UTF-16. */
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|flag
operator|&
name|SCONV_FROM_UTF16LE
condition|)
block|{
name|parse
operator|=
name|utf16le_to_unicode
expr_stmt|;
name|tm
operator|=
literal|1
expr_stmt|;
name|spair
operator|=
literal|4
expr_stmt|;
comment|/* surrogate pair size in UTF-16. */
block|}
else|else
block|{
name|parse
operator|=
name|cesu8_to_unicode
expr_stmt|;
name|tm
operator|=
name|ts
expr_stmt|;
name|spair
operator|=
literal|6
expr_stmt|;
comment|/* surrogate pair size in UTF-8. */
block|}
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|len
operator|*
name|tm
operator|+
name|ts
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|endp
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|buffer_length
operator|-
name|ts
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|parse
argument_list|(
operator|&
name|uc
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|ucptr
decl_stmt|;
name|uint32_t
name|cp1
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|SIndex
decl_stmt|;
struct|struct
block|{
name|uint32_t
name|uc
decl_stmt|;
name|int
name|ccc
decl_stmt|;
block|}
name|fdc
index|[
name|FDC_MAX
index|]
struct|;
name|int
name|fdi
decl_stmt|,
name|fdj
decl_stmt|;
name|int
name|ccc
decl_stmt|;
name|check_first_code
label|:
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* Use a replaced unicode character. */
name|UNPARSE
argument_list|(
name|p
argument_list|,
name|endp
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|+=
name|n
operator|*
operator|-
literal|1
expr_stmt|;
name|len
operator|-=
name|n
operator|*
operator|-
literal|1
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
name|spair
operator|||
name|always_replace
condition|)
comment|/* uc is converted from a surrogate pair. 			 * this should be treated as a changed code. */
name|ucptr
operator|=
name|NULL
expr_stmt|;
else|else
name|ucptr
operator|=
name|s
expr_stmt|;
name|s
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
comment|/* Hangul Decomposition. */
if|if
condition|(
operator|(
name|SIndex
operator|=
name|uc
operator|-
name|HC_SBASE
operator|)
operator|>=
literal|0
operator|&&
name|SIndex
operator|<
name|HC_SCOUNT
condition|)
block|{
name|int
name|L
init|=
name|HC_LBASE
operator|+
name|SIndex
operator|/
name|HC_NCOUNT
decl_stmt|;
name|int
name|V
init|=
name|HC_VBASE
operator|+
operator|(
name|SIndex
operator|%
name|HC_NCOUNT
operator|)
operator|/
name|HC_TCOUNT
decl_stmt|;
name|int
name|T
init|=
name|HC_TBASE
operator|+
name|SIndex
operator|%
name|HC_TCOUNT
decl_stmt|;
name|REPLACE_UC_WITH
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|WRITE_UC
argument_list|()
expr_stmt|;
name|REPLACE_UC_WITH
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|WRITE_UC
argument_list|()
expr_stmt|;
if|if
condition|(
name|T
operator|!=
name|HC_TBASE
condition|)
block|{
name|REPLACE_UC_WITH
argument_list|(
name|T
argument_list|)
expr_stmt|;
name|WRITE_UC
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|IS_DECOMPOSABLE_BLOCK
argument_list|(
name|uc
argument_list|)
operator|&&
name|CCC
argument_list|(
name|uc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|WRITE_UC
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|fdi
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|get_nfd
argument_list|(
operator|&
name|cp1
argument_list|,
operator|&
name|cp2
argument_list|,
name|uc
argument_list|)
operator|&&
name|fdi
operator|<
name|FDC_MAX
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
name|fdi
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
control|)
name|fdc
index|[
name|k
index|]
operator|=
name|fdc
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|fdc
index|[
literal|0
index|]
operator|.
name|ccc
operator|=
name|CCC
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
name|fdc
index|[
literal|0
index|]
operator|.
name|uc
operator|=
name|cp2
expr_stmt|;
name|fdi
operator|++
expr_stmt|;
name|REPLACE_UC_WITH
argument_list|(
name|cp1
argument_list|)
expr_stmt|;
block|}
comment|/* Read following code points. */
while|while
condition|(
operator|(
name|n2
operator|=
name|parse
argument_list|(
operator|&
name|uc2
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|)
operator|>
literal|0
operator|&&
operator|(
name|ccc
operator|=
name|CCC
argument_list|(
name|uc2
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|fdi
operator|<
name|FDC_MAX
condition|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|s
operator|+=
name|n2
expr_stmt|;
name|len
operator|-=
name|n2
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|fdi
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fdc
index|[
name|j
index|]
operator|.
name|ccc
operator|>
name|ccc
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|<
name|fdi
condition|)
block|{
for|for
control|(
name|k
operator|=
name|fdi
init|;
name|k
operator|>
name|j
condition|;
name|k
operator|--
control|)
name|fdc
index|[
name|k
index|]
operator|=
name|fdc
index|[
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|fdc
index|[
name|j
index|]
operator|.
name|ccc
operator|=
name|ccc
expr_stmt|;
name|fdc
index|[
name|j
index|]
operator|.
name|uc
operator|=
name|uc2
expr_stmt|;
block|}
else|else
block|{
name|fdc
index|[
name|fdi
index|]
operator|.
name|ccc
operator|=
name|ccc
expr_stmt|;
name|fdc
index|[
name|fdi
index|]
operator|.
name|uc
operator|=
name|uc2
expr_stmt|;
block|}
name|fdi
operator|++
expr_stmt|;
block|}
name|WRITE_UC
argument_list|()
expr_stmt|;
for|for
control|(
name|fdj
operator|=
literal|0
init|;
name|fdj
operator|<
name|fdi
condition|;
name|fdj
operator|++
control|)
block|{
name|REPLACE_UC_WITH
argument_list|(
name|fdc
index|[
name|fdj
index|]
operator|.
name|uc
argument_list|)
expr_stmt|;
name|WRITE_UC
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|n2
operator|==
literal|0
condition|)
break|break;
name|REPLACE_UC_WITH
argument_list|(
name|uc2
argument_list|)
expr_stmt|;
name|n
operator|=
name|n2
expr_stmt|;
goto|goto
name|check_first_code
goto|;
block|}
name|as
operator|->
name|length
operator|=
name|p
operator|-
name|as
operator|->
name|s
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ts
operator|==
literal|2
condition|)
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * libarchive 2.x made incorrect UTF-8 strings in the wrong assumption  * that WCS is Unicode. It is true for several platforms but some are false.  * And then people who did not use UTF-8 locale on the non Unicode WCS  * platform and made a tar file with libarchive(mostly bsdtar) 2.x. Those  * now cannot get right filename from libarchive 3.x and later since we  * fixed the wrong assumption and it is incompatible to older its versions.  * So we provide special option, "compat-2x.x", for resolving it.  * That option enable the string conversion of libarchive 2.x.  *  * Translates the wrong UTF-8 string made by libarchive 2.x into current  * locale character set and appends to the archive_string.  * Note: returns -1 if conversion fails.  */
end_comment

begin_function
specifier|static
name|int
name|strncat_from_utf8_libarchive2
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|uint32_t
name|unicode
decl_stmt|;
if|#
directive|if
name|HAVE_WCRTOMB
name|mbstate_t
name|shift_state
decl_stmt|;
name|memset
argument_list|(
operator|&
name|shift_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|shift_state
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Clear the shift state before starting. */
name|wctomb
argument_list|(
name|NULL
argument_list|,
literal|L'
expr|\0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sc
expr_stmt|;
comment|/* UNUSED */
comment|/* 	 * Allocate buffer for MBS. 	 * We need this allocation here since it is possible that 	 * as->s is still NULL. 	 */
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|len
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|s
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
expr_stmt|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|end
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|buffer_length
operator|-
name|MB_CUR_MAX
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|_utf8_to_unicode
argument_list|(
operator|&
name|unicode
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|wchar_t
name|wc
decl_stmt|;
if|if
condition|(
name|p
operator|>=
name|end
condition|)
block|{
name|as
operator|->
name|length
operator|=
name|p
operator|-
name|as
operator|->
name|s
expr_stmt|;
comment|/* Re-allocate buffer for MBS. */
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|len
operator|*
literal|2
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|end
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|buffer_length
operator|-
name|MB_CUR_MAX
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 		 * As libarchive 2.x, translates the UTF-8 characters into 		 * wide-characters in the assumption that WCS is Unicode. 		 */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|*=
operator|-
literal|1
expr_stmt|;
name|wc
operator|=
literal|L'
expr|?'
expr_stmt|;
block|}
else|else
name|wc
operator|=
operator|(
name|wchar_t
operator|)
name|unicode
expr_stmt|;
name|s
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
comment|/* 		 * Translates the wide-character into the current locale MBS. 		 */
if|#
directive|if
name|HAVE_WCRTOMB
name|n
operator|=
operator|(
name|int
operator|)
name|wcrtomb
argument_list|(
name|p
argument_list|,
name|wc
argument_list|,
operator|&
name|shift_state
argument_list|)
expr_stmt|;
else|#
directive|else
name|n
operator|=
operator|(
name|int
operator|)
name|wctomb
argument_list|(
name|p
argument_list|,
name|wc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|+=
name|n
expr_stmt|;
block|}
name|as
operator|->
name|length
operator|=
name|p
operator|-
name|as
operator|->
name|s
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Conversion functions between current locale dependent MBS and UTF-16BE.  *   strncat_from_utf16be() : UTF-16BE --> MBS  *   strncat_to_utf16be()   : MBS --> UTF16BE  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_comment
comment|/*  * Convert a UTF-16BE/LE string to current locale and copy the result.  * Return -1 if conversion fails.  */
end_comment

begin_function
specifier|static
name|int
name|win_strncat_from_utf16
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|,
name|int
name|be
parameter_list|)
block|{
name|struct
name|archive_string
name|tmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|u16
decl_stmt|;
name|int
name|ll
decl_stmt|;
name|BOOL
name|defchar
decl_stmt|;
name|char
modifier|*
name|mbs
decl_stmt|;
name|size_t
name|mbs_size
decl_stmt|,
name|b
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|bytes
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|bytes
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mbs
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|mbs_size
operator|=
name|as
operator|->
name|buffer_length
operator|-
name|as
operator|->
name|length
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|to_cp
operator|==
name|CP_C_LOCALE
condition|)
block|{
comment|/* 		 * "C" locale special process. 		 */
name|u16
operator|=
name|_p
expr_stmt|;
name|ll
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|+=
literal|2
control|)
block|{
name|uint16_t
name|val
decl_stmt|;
if|if
condition|(
name|be
condition|)
name|val
operator|=
name|archive_be16dec
argument_list|(
name|u16
operator|+
name|b
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|archive_le16dec
argument_list|(
name|u16
operator|+
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|255
condition|)
block|{
operator|*
name|mbs
operator|++
operator|=
literal|'?'
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|mbs
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ll
operator|++
expr_stmt|;
block|}
name|as
operator|->
name|length
operator|+=
name|ll
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|archive_string_init
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|be
condition|)
block|{
if|if
condition|(
name|is_big_endian
argument_list|()
condition|)
block|{
name|u16
operator|=
name|_p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|archive_string_ensure
argument_list|(
operator|&
name|tmp
argument_list|,
name|bytes
operator|+
literal|2
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|tmp
operator|.
name|s
argument_list|,
name|_p
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|+=
literal|2
control|)
block|{
name|uint16_t
name|val
init|=
name|archive_be16dec
argument_list|(
name|tmp
operator|.
name|s
operator|+
name|b
argument_list|)
decl_stmt|;
name|archive_le16enc
argument_list|(
name|tmp
operator|.
name|s
operator|+
name|b
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|u16
operator|=
name|tmp
operator|.
name|s
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|is_big_endian
argument_list|()
condition|)
block|{
name|u16
operator|=
name|_p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|archive_string_ensure
argument_list|(
operator|&
name|tmp
argument_list|,
name|bytes
operator|+
literal|2
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|tmp
operator|.
name|s
argument_list|,
name|_p
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|bytes
condition|;
name|b
operator|+=
literal|2
control|)
block|{
name|uint16_t
name|val
init|=
name|archive_le16dec
argument_list|(
name|tmp
operator|.
name|s
operator|+
name|b
argument_list|)
decl_stmt|;
name|archive_be16enc
argument_list|(
name|tmp
operator|.
name|s
operator|+
name|b
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|u16
operator|=
name|tmp
operator|.
name|s
expr_stmt|;
block|}
block|}
do|do
block|{
name|defchar
operator|=
literal|0
expr_stmt|;
name|ll
operator|=
name|WideCharToMultiByte
argument_list|(
name|sc
operator|->
name|to_cp
argument_list|,
literal|0
argument_list|,
operator|(
name|LPCWSTR
operator|)
name|u16
argument_list|,
operator|(
name|int
operator|)
name|bytes
operator|>>
literal|1
argument_list|,
name|mbs
argument_list|,
operator|(
name|int
operator|)
name|mbs_size
argument_list|,
name|NULL
argument_list|,
operator|&
name|defchar
argument_list|)
expr_stmt|;
comment|/* Exit loop if we succeeded */
if|if
condition|(
name|ll
operator|!=
literal|0
operator|||
name|GetLastError
argument_list|()
operator|!=
name|ERROR_INSUFFICIENT_BUFFER
condition|)
block|{
break|break;
block|}
comment|/* Else expand buffer and loop to try again. */
name|ll
operator|=
name|WideCharToMultiByte
argument_list|(
name|sc
operator|->
name|to_cp
argument_list|,
literal|0
argument_list|,
operator|(
name|LPCWSTR
operator|)
name|u16
argument_list|,
operator|(
name|int
operator|)
name|bytes
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|ll
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mbs
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
name|mbs_size
operator|=
name|as
operator|->
name|buffer_length
operator|-
name|as
operator|->
name|length
operator|-
literal|1
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|archive_string_free
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|as
operator|->
name|length
operator|+=
name|ll
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ll
operator|==
literal|0
operator|||
name|defchar
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|win_strncat_from_utf16be
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|win_strncat_from_utf16
argument_list|(
name|as
argument_list|,
name|_p
argument_list|,
name|bytes
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|win_strncat_from_utf16le
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|win_strncat_from_utf16
argument_list|(
name|as
argument_list|,
name|_p
argument_list|,
name|bytes
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_big_endian
parameter_list|(
name|void
parameter_list|)
block|{
name|uint16_t
name|d
init|=
literal|1
decl_stmt|;
return|return
operator|(
name|archive_be16dec
argument_list|(
operator|&
name|d
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a current locale string to UTF-16BE/LE and copy the result.  * Return -1 if conversion fails.  */
end_comment

begin_function
specifier|static
name|int
name|win_strncat_to_utf16
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as16
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|,
name|int
name|bigendian
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
decl_stmt|;
name|char
modifier|*
name|u16
decl_stmt|;
name|size_t
name|count
decl_stmt|,
name|avail
decl_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as16
argument_list|,
name|as16
operator|->
name|length
operator|+
operator|(
name|length
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|u16
operator|=
name|as16
operator|->
name|s
operator|+
name|as16
operator|->
name|length
expr_stmt|;
name|avail
operator|=
name|as16
operator|->
name|buffer_length
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|from_cp
operator|==
name|CP_C_LOCALE
condition|)
block|{
comment|/* 		 * "C" locale special process. 		 */
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|length
operator|&&
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|bigendian
condition|)
name|archive_be16enc
argument_list|(
name|u16
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
else|else
name|archive_le16enc
argument_list|(
name|u16
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|u16
operator|+=
literal|2
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|as16
operator|->
name|length
operator|+=
name|count
operator|<<
literal|1
expr_stmt|;
name|as16
operator|->
name|s
index|[
name|as16
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|as16
operator|->
name|s
index|[
name|as16
operator|->
name|length
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|do
block|{
name|count
operator|=
name|MultiByteToWideChar
argument_list|(
name|sc
operator|->
name|from_cp
argument_list|,
name|MB_PRECOMPOSED
argument_list|,
name|s
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|,
operator|(
name|LPWSTR
operator|)
name|u16
argument_list|,
operator|(
name|int
operator|)
name|avail
operator|>>
literal|1
argument_list|)
expr_stmt|;
comment|/* Exit loop if we succeeded */
if|if
condition|(
name|count
operator|!=
literal|0
operator|||
name|GetLastError
argument_list|()
operator|!=
name|ERROR_INSUFFICIENT_BUFFER
condition|)
block|{
break|break;
block|}
comment|/* Expand buffer and try again */
name|count
operator|=
name|MultiByteToWideChar
argument_list|(
name|sc
operator|->
name|from_cp
argument_list|,
name|MB_PRECOMPOSED
argument_list|,
name|s
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as16
argument_list|,
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|u16
operator|=
name|as16
operator|->
name|s
operator|+
name|as16
operator|->
name|length
expr_stmt|;
name|avail
operator|=
name|as16
operator|->
name|buffer_length
operator|-
literal|2
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|as16
operator|->
name|length
operator|+=
name|count
operator|*
literal|2
expr_stmt|;
name|as16
operator|->
name|s
index|[
name|as16
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|as16
operator|->
name|s
index|[
name|as16
operator|->
name|length
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|is_big_endian
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|bigendian
condition|)
block|{
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|uint16_t
name|v
init|=
name|archive_be16dec
argument_list|(
name|u16
argument_list|)
decl_stmt|;
name|archive_le16enc
argument_list|(
name|u16
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|u16
operator|+=
literal|2
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|bigendian
condition|)
block|{
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|uint16_t
name|v
init|=
name|archive_le16dec
argument_list|(
name|u16
argument_list|)
decl_stmt|;
name|archive_be16enc
argument_list|(
name|u16
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|u16
operator|+=
literal|2
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|win_strncat_to_utf16be
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as16
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|win_strncat_to_utf16
argument_list|(
name|as16
argument_list|,
name|_p
argument_list|,
name|length
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|win_strncat_to_utf16le
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as16
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|win_strncat_to_utf16
argument_list|(
name|as16
argument_list|,
name|_p
argument_list|,
name|length
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32&& !__CYGWIN__ */
end_comment

begin_comment
comment|/*  * Do the best effort for conversions.  * We cannot handle UTF-16BE character-set without such iconv,  * but there is a chance if a string consists just ASCII code or  * a current locale is UTF-8.  */
end_comment

begin_comment
comment|/*  * Convert a UTF-16BE string to current locale and copy the result.  * Return -1 if conversion fails.  */
end_comment

begin_function
specifier|static
name|int
name|best_effort_strncat_from_utf16
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|,
name|int
name|be
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|utf16
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
decl_stmt|;
name|char
modifier|*
name|mbs
decl_stmt|;
name|uint32_t
name|uc
decl_stmt|;
name|int
name|n
decl_stmt|,
name|ret
decl_stmt|;
operator|(
name|void
operator|)
name|sc
expr_stmt|;
comment|/* UNUSED */
comment|/* 	 * Other case, we should do the best effort. 	 * If all character are ASCII(<0x7f), we can convert it. 	 * if not , we set a alternative character and return -1. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|as
operator|->
name|length
operator|+
name|bytes
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mbs
operator|=
name|as
operator|->
name|s
operator|+
name|as
operator|->
name|length
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|utf16_to_unicode
argument_list|(
operator|&
name|uc
argument_list|,
name|utf16
argument_list|,
name|bytes
argument_list|,
name|be
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|*=
operator|-
literal|1
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|bytes
operator|-=
name|n
expr_stmt|;
name|utf16
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|uc
operator|>
literal|127
condition|)
block|{
comment|/* We cannot handle it. */
operator|*
name|mbs
operator|++
operator|=
literal|'?'
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|mbs
operator|++
operator|=
operator|(
name|char
operator|)
name|uc
expr_stmt|;
block|}
name|as
operator|->
name|length
operator|=
name|mbs
operator|-
name|as
operator|->
name|s
expr_stmt|;
name|as
operator|->
name|s
index|[
name|as
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|best_effort_strncat_from_utf16be
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|best_effort_strncat_from_utf16
argument_list|(
name|as
argument_list|,
name|_p
argument_list|,
name|bytes
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|best_effort_strncat_from_utf16le
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|best_effort_strncat_from_utf16
argument_list|(
name|as
argument_list|,
name|_p
argument_list|,
name|bytes
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a current locale string to UTF-16BE/LE and copy the result.  * Return -1 if conversion fails.  */
end_comment

begin_function
specifier|static
name|int
name|best_effort_strncat_to_utf16
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as16
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|,
name|int
name|bigendian
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_p
decl_stmt|;
name|char
modifier|*
name|utf16
decl_stmt|;
name|size_t
name|remaining
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|(
name|void
operator|)
name|sc
expr_stmt|;
comment|/* UNUSED */
comment|/* 	 * Other case, we should do the best effort. 	 * If all character are ASCII(<0x7f), we can convert it. 	 * if not , we set a alternative character and return -1. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
name|remaining
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as16
argument_list|,
name|as16
operator|->
name|length
operator|+
operator|(
name|length
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|utf16
operator|=
name|as16
operator|->
name|s
operator|+
name|as16
operator|->
name|length
expr_stmt|;
while|while
condition|(
name|remaining
operator|--
condition|)
block|{
name|unsigned
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|>
literal|127
condition|)
block|{
comment|/* We cannot handle it. */
name|c
operator|=
name|UNICODE_R_CHAR
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bigendian
condition|)
name|archive_be16enc
argument_list|(
name|utf16
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|archive_le16enc
argument_list|(
name|utf16
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|utf16
operator|+=
literal|2
expr_stmt|;
block|}
name|as16
operator|->
name|length
operator|=
name|utf16
operator|-
name|as16
operator|->
name|s
expr_stmt|;
name|as16
operator|->
name|s
index|[
name|as16
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|as16
operator|->
name|s
index|[
name|as16
operator|->
name|length
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|best_effort_strncat_to_utf16be
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as16
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|best_effort_strncat_to_utf16
argument_list|(
name|as16
argument_list|,
name|_p
argument_list|,
name|length
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|best_effort_strncat_to_utf16le
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as16
parameter_list|,
specifier|const
name|void
modifier|*
name|_p
parameter_list|,
name|size_t
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|best_effort_strncat_to_utf16
argument_list|(
name|as16
argument_list|,
name|_p
argument_list|,
name|length
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Multistring operations.  */
end_comment

begin_function
name|void
name|archive_mstring_clean
parameter_list|(
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|)
block|{
name|archive_wstring_free
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_wcs
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_utf8
operator|)
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs_in_locale
operator|)
argument_list|)
expr_stmt|;
name|aes
operator|->
name|aes_set
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|archive_mstring_copy
parameter_list|(
name|struct
name|archive_mstring
modifier|*
name|dest
parameter_list|,
name|struct
name|archive_mstring
modifier|*
name|src
parameter_list|)
block|{
name|dest
operator|->
name|aes_set
operator|=
name|src
operator|->
name|aes_set
expr_stmt|;
name|archive_string_copy
argument_list|(
operator|&
operator|(
name|dest
operator|->
name|aes_mbs
operator|)
argument_list|,
operator|&
operator|(
name|src
operator|->
name|aes_mbs
operator|)
argument_list|)
expr_stmt|;
name|archive_string_copy
argument_list|(
operator|&
operator|(
name|dest
operator|->
name|aes_utf8
operator|)
argument_list|,
operator|&
operator|(
name|src
operator|->
name|aes_utf8
operator|)
argument_list|)
expr_stmt|;
name|archive_wstring_copy
argument_list|(
operator|&
operator|(
name|dest
operator|->
name|aes_wcs
operator|)
argument_list|,
operator|&
operator|(
name|src
operator|->
name|aes_wcs
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|archive_mstring_get_utf8
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|archive_string_conv
modifier|*
name|sc
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* If we already have a UTF8 form, return that immediately. */
if|if
condition|(
name|aes
operator|->
name|aes_set
operator|&
name|AES_SET_UTF8
condition|)
block|{
operator|*
name|p
operator|=
name|aes
operator|->
name|aes_utf8
operator|.
name|s
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|aes
operator|->
name|aes_set
operator|&
name|AES_SET_MBS
condition|)
block|{
name|sc
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a
argument_list|,
literal|"UTF-8"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Couldn't allocate memory for sc. */
name|r
operator|=
name|archive_strncpy_l
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_utf8
operator|)
argument_list|,
name|aes
operator|->
name|aes_mbs
operator|.
name|s
argument_list|,
name|aes
operator|->
name|aes_mbs
operator|.
name|length
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|free_sconv_object
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|aes
operator|->
name|aes_set
operator||=
name|AES_SET_UTF8
expr_stmt|;
operator|*
name|p
operator|=
name|aes
operator|->
name|aes_utf8
operator|.
name|s
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success. */
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* failure. */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success. */
block|}
end_function

begin_function
name|int
name|archive_mstring_get_mbs
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
comment|/* If we already have an MBS form, return that immediately. */
if|if
condition|(
name|aes
operator|->
name|aes_set
operator|&
name|AES_SET_MBS
condition|)
block|{
operator|*
name|p
operator|=
name|aes
operator|->
name|aes_mbs
operator|.
name|s
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* If there's a WCS form, try converting with the native locale. */
if|if
condition|(
name|aes
operator|->
name|aes_set
operator|&
name|AES_SET_WCS
condition|)
block|{
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_string_append_from_wcs
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|,
name|aes
operator|->
name|aes_wcs
operator|.
name|s
argument_list|,
name|aes
operator|->
name|aes_wcs
operator|.
name|length
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|aes
operator|->
name|aes_mbs
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|aes
operator|->
name|aes_set
operator||=
name|AES_SET_MBS
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
else|else
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Only a UTF-8 form cannot avail because its conversion already 	 * failed at archive_mstring_update_utf8(). 	 */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_mstring_get_wcs
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|,
specifier|const
name|wchar_t
modifier|*
modifier|*
name|wp
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
comment|/* Return WCS form if we already have it. */
if|if
condition|(
name|aes
operator|->
name|aes_set
operator|&
name|AES_SET_WCS
condition|)
block|{
operator|*
name|wp
operator|=
name|aes
operator|->
name|aes_wcs
operator|.
name|s
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
operator|*
name|wp
operator|=
name|NULL
expr_stmt|;
comment|/* Try converting MBS to WCS using native locale. */
if|if
condition|(
name|aes
operator|->
name|aes_set
operator|&
name|AES_SET_MBS
condition|)
block|{
name|archive_wstring_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_wcs
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_wstring_append_from_mbs
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_wcs
operator|)
argument_list|,
name|aes
operator|->
name|aes_mbs
operator|.
name|s
argument_list|,
name|aes
operator|->
name|aes_mbs
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|aes
operator|->
name|aes_set
operator||=
name|AES_SET_WCS
expr_stmt|;
operator|*
name|wp
operator|=
name|aes
operator|->
name|aes_wcs
operator|.
name|s
expr_stmt|;
block|}
else|else
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* failure. */
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_mstring_get_mbs_l
parameter_list|(
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|size_t
modifier|*
name|length
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* 	 * Internationalization programming on Windows must use Wide 	 * characters because Windows platform cannot make locale UTF-8. 	 */
if|if
condition|(
name|sc
operator|!=
name|NULL
operator|&&
operator|(
name|aes
operator|->
name|aes_set
operator|&
name|AES_SET_WCS
operator|)
operator|!=
literal|0
condition|)
block|{
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs_in_locale
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_string_append_from_wcs_in_codepage
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs_in_locale
operator|)
argument_list|,
name|aes
operator|->
name|aes_wcs
operator|.
name|s
argument_list|,
name|aes
operator|->
name|aes_wcs
operator|.
name|length
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|=
name|aes
operator|->
name|aes_mbs_in_locale
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
name|aes
operator|->
name|aes_mbs_in_locale
operator|.
name|length
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If there is not an MBS form but is a WCS form, try converting 	 * with the native locale to be used for translating it to specified 	 * character-set. */
if|if
condition|(
operator|(
name|aes
operator|->
name|aes_set
operator|&
name|AES_SET_MBS
operator|)
operator|==
literal|0
operator|&&
operator|(
name|aes
operator|->
name|aes_set
operator|&
name|AES_SET_WCS
operator|)
operator|!=
literal|0
condition|)
block|{
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_string_append_from_wcs
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|,
name|aes
operator|->
name|aes_wcs
operator|.
name|s
argument_list|,
name|aes
operator|->
name|aes_wcs
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|aes
operator|->
name|aes_set
operator||=
name|AES_SET_MBS
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* If we already have an MBS form, use it to be translated to 	 * specified character-set. */
if|if
condition|(
name|aes
operator|->
name|aes_set
operator|&
name|AES_SET_MBS
condition|)
block|{
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
comment|/* Conversion is unneeded. */
operator|*
name|p
operator|=
name|aes
operator|->
name|aes_mbs
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
name|aes
operator|->
name|aes_mbs
operator|.
name|length
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ret
operator|=
name|archive_strncpy_l
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs_in_locale
operator|)
argument_list|,
name|aes
operator|->
name|aes_mbs
operator|.
name|s
argument_list|,
name|aes
operator|->
name|aes_mbs
operator|.
name|length
argument_list|,
name|sc
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|aes
operator|->
name|aes_mbs_in_locale
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
name|aes
operator|->
name|aes_mbs_in_locale
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_mstring_copy_mbs
parameter_list|(
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|,
specifier|const
name|char
modifier|*
name|mbs
parameter_list|)
block|{
if|if
condition|(
name|mbs
operator|==
name|NULL
condition|)
block|{
name|aes
operator|->
name|aes_set
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|archive_mstring_copy_mbs_len
argument_list|(
name|aes
argument_list|,
name|mbs
argument_list|,
name|strlen
argument_list|(
name|mbs
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_mstring_copy_mbs_len
parameter_list|(
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|,
specifier|const
name|char
modifier|*
name|mbs
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|mbs
operator|==
name|NULL
condition|)
block|{
name|aes
operator|->
name|aes_set
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|aes
operator|->
name|aes_set
operator|=
name|AES_SET_MBS
expr_stmt|;
comment|/* Only MBS form is set now. */
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|,
name|mbs
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_utf8
operator|)
argument_list|)
expr_stmt|;
name|archive_wstring_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_wcs
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_mstring_copy_wcs
parameter_list|(
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|wcs
parameter_list|)
block|{
return|return
name|archive_mstring_copy_wcs_len
argument_list|(
name|aes
argument_list|,
name|wcs
argument_list|,
name|wcs
operator|==
name|NULL
condition|?
literal|0
else|:
name|wcslen
argument_list|(
name|wcs
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|archive_mstring_copy_utf8
parameter_list|(
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|,
specifier|const
name|char
modifier|*
name|utf8
parameter_list|)
block|{
if|if
condition|(
name|utf8
operator|==
name|NULL
condition|)
block|{
name|aes
operator|->
name|aes_set
operator|=
literal|0
expr_stmt|;
block|}
name|aes
operator|->
name|aes_set
operator|=
name|AES_SET_UTF8
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_wcs
operator|)
argument_list|)
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_utf8
operator|)
argument_list|,
name|utf8
argument_list|,
name|strlen
argument_list|(
name|utf8
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|utf8
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|archive_mstring_copy_wcs_len
parameter_list|(
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|wcs
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|wcs
operator|==
name|NULL
condition|)
block|{
name|aes
operator|->
name|aes_set
operator|=
literal|0
expr_stmt|;
block|}
name|aes
operator|->
name|aes_set
operator|=
name|AES_SET_WCS
expr_stmt|;
comment|/* Only WCS form set. */
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_utf8
operator|)
argument_list|)
expr_stmt|;
name|archive_wstrncpy
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_wcs
operator|)
argument_list|,
name|wcs
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_mstring_copy_mbs_len_l
parameter_list|(
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|,
specifier|const
name|char
modifier|*
name|mbs
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|archive_string_conv
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|mbs
operator|==
name|NULL
condition|)
block|{
name|aes
operator|->
name|aes_set
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|)
expr_stmt|;
name|archive_wstring_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_wcs
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_utf8
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* 	 * Internationalization programming on Windows must use Wide 	 * characters because Windows platform cannot make locale UTF-8. 	 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|archive_string_append
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|,
name|mbs
argument_list|,
name|mbsnbytes
argument_list|(
name|mbs
argument_list|,
name|len
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|aes
operator|->
name|aes_set
operator|=
literal|0
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|aes
operator|->
name|aes_set
operator|=
name|AES_SET_MBS
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ICONV
argument_list|)
block|}
elseif|else
if|if
condition|(
name|sc
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|cd_w
operator|!=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* 		 * This case happens only when MultiByteToWideChar() cannot 		 * handle sc->from_cp, and we have to iconv in order to 		 * translate character-set to wchar_t,UTF-16. 		 */
name|iconv_t
name|cd
init|=
name|sc
operator|->
name|cd
decl_stmt|;
name|unsigned
name|from_cp
decl_stmt|;
name|int
name|flag
decl_stmt|;
comment|/* 		 * Translate multi-bytes from some character-set to UTF-8. 		 */
name|sc
operator|->
name|cd
operator|=
name|sc
operator|->
name|cd_w
expr_stmt|;
name|r
operator|=
name|archive_strncpy_l
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_utf8
operator|)
argument_list|,
name|mbs
argument_list|,
name|len
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cd
operator|=
name|cd
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|aes
operator|->
name|aes_set
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|aes
operator|->
name|aes_set
operator|=
name|AES_SET_UTF8
expr_stmt|;
comment|/* 		 * Append the UTF-8 string into wstring. 		 */
name|flag
operator|=
name|sc
operator|->
name|flag
expr_stmt|;
name|sc
operator|->
name|flag
operator|&=
operator|~
operator|(
name|SCONV_NORMALIZATION_C
operator||
name|SCONV_TO_UTF16
operator||
name|SCONV_FROM_UTF16
operator|)
expr_stmt|;
name|from_cp
operator|=
name|sc
operator|->
name|from_cp
expr_stmt|;
name|sc
operator|->
name|from_cp
operator|=
name|CP_UTF8
expr_stmt|;
name|r
operator|=
name|archive_wstring_append_from_mbs_in_codepage
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_wcs
operator|)
argument_list|,
name|aes
operator|->
name|aes_utf8
operator|.
name|s
argument_list|,
name|aes
operator|->
name|aes_utf8
operator|.
name|length
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flag
operator|=
name|flag
expr_stmt|;
name|sc
operator|->
name|from_cp
operator|=
name|from_cp
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|aes
operator|->
name|aes_set
operator||=
name|AES_SET_WCS
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|r
operator|=
name|archive_wstring_append_from_mbs_in_codepage
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_wcs
operator|)
argument_list|,
name|mbs
argument_list|,
name|len
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|aes
operator|->
name|aes_set
operator|=
name|AES_SET_WCS
expr_stmt|;
else|else
name|aes
operator|->
name|aes_set
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|r
operator|=
name|archive_strncpy_l
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|,
name|mbs
argument_list|,
name|len
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|aes
operator|->
name|aes_set
operator|=
name|AES_SET_MBS
expr_stmt|;
comment|/* Only MBS form is set now. */
else|else
name|aes
operator|->
name|aes_set
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The 'update' form tries to proactively update all forms of  * this string (WCS and MBS) and returns an error if any of  * them fail.  This is used by the 'pax' handler, for instance,  * to detect and report character-conversion failures early while  * still allowing clients to get potentially useful values from  * the more tolerant lazy conversions.  (get_mbs and get_wcs will  * strive to give the user something useful, so you can get hopefully  * usable values even if some of the character conversions are failing.)  */
end_comment

begin_function
name|int
name|archive_mstring_update_utf8
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_mstring
modifier|*
name|aes
parameter_list|,
specifier|const
name|char
modifier|*
name|utf8
parameter_list|)
block|{
name|struct
name|archive_string_conv
modifier|*
name|sc
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|utf8
operator|==
name|NULL
condition|)
block|{
name|aes
operator|->
name|aes_set
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Succeeded in clearing everything. */
block|}
comment|/* Save the UTF8 string. */
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_utf8
operator|)
argument_list|,
name|utf8
argument_list|)
expr_stmt|;
comment|/* Empty the mbs and wcs strings. */
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|)
expr_stmt|;
name|archive_wstring_empty
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_wcs
operator|)
argument_list|)
expr_stmt|;
name|aes
operator|->
name|aes_set
operator|=
name|AES_SET_UTF8
expr_stmt|;
comment|/* Only UTF8 is set now. */
comment|/* Try converting UTF-8 to MBS, return false on failure. */
name|sc
operator|=
name|archive_string_conversion_from_charset
argument_list|(
name|a
argument_list|,
literal|"UTF-8"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Couldn't allocate memory for sc. */
name|r
operator|=
name|archive_strcpy_l
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_mbs
operator|)
argument_list|,
name|utf8
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|free_sconv_object
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|aes
operator|->
name|aes_set
operator|=
name|AES_SET_UTF8
operator||
name|AES_SET_MBS
expr_stmt|;
comment|/* Both UTF8 and MBS set. */
comment|/* Try converting MBS to WCS, return false on failure. */
if|if
condition|(
name|archive_wstring_append_from_mbs
argument_list|(
operator|&
operator|(
name|aes
operator|->
name|aes_wcs
operator|)
argument_list|,
name|aes
operator|->
name|aes_mbs
operator|.
name|s
argument_list|,
name|aes
operator|->
name|aes_mbs
operator|.
name|length
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|aes
operator|->
name|aes_set
operator|=
name|AES_SET_UTF8
operator||
name|AES_SET_WCS
operator||
name|AES_SET_MBS
expr_stmt|;
comment|/* All conversions succeeded. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

