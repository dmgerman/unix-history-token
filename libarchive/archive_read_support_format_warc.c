begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Sebastian Freundt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * WARC is standardised by ISO TC46/SC4/WG12 and currently available as  * ISO 28500:2009.  * For the purposes of this file we used the final draft from:  * http://bibnum.bnf.fr/warc/WARC_ISO_28500_version1_latestdraft.pdf  *  * Todo:  * [ ] real-world warcs can contain resources at endpoints ending in /  *     e.g. http://bibnum.bnf.fr/warc/  *     if you're lucky their response contains a Content-Location: header  *     pointing to a unix-compliant filename, in the example above it's  *     Content-Location: http://bibnum.bnf.fr/warc/index.html  *     however, that's not mandated and github for example doesn't follow  *     this convention.  *     We need a set of archive options to control what to do with  *     entries like these, at the moment care is taken to skip them.  *  **/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CTYPE_H
end_ifdef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|WT_NONE
block|,
comment|/* warcinfo */
name|WT_INFO
block|,
comment|/* metadata */
name|WT_META
block|,
comment|/* resource */
name|WT_RSRC
block|,
comment|/* request, unsupported */
name|WT_REQ
block|,
comment|/* response, unsupported */
name|WT_RSP
block|,
comment|/* revisit, unsupported */
name|WT_RVIS
block|,
comment|/* conversion, unsupported */
name|WT_CONV
block|,
comment|/* continuation, unsupported at the moment */
name|WT_CONT
block|,
comment|/* invalid type */
name|LAST_WT
block|}
name|warc_type_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|}
name|warc_string_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|}
name|warc_strbuf_t
typedef|;
end_typedef

begin_struct
struct|struct
name|warc_s
block|{
comment|/* content length ahead */
name|size_t
name|cntlen
decl_stmt|;
comment|/* and how much we've processed so far */
name|size_t
name|cntoff
decl_stmt|;
comment|/* and how much we need to consume between calls */
name|size_t
name|unconsumed
decl_stmt|;
comment|/* string pool */
name|warc_strbuf_t
name|pool
decl_stmt|;
comment|/* previous version */
name|unsigned
name|int
name|pver
decl_stmt|;
comment|/* stringified format name */
name|struct
name|archive_string
name|sver
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|_warc_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_warc_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_warc_read
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_warc_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_warc_rdhdr
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* private routines */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|int
name|_warc_rdver
parameter_list|(
specifier|const
name|char
name|buf
index|[
literal|10
index|]
parameter_list|,
name|size_t
name|bsz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|_warc_rdtyp
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|warc_string_t
name|_warc_rduri
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|_warc_rdlen
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|_warc_rdrtm
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|_warc_rdmtm
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|_warc_find_eoh
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|_warc_find_eol
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_read_support_format_warc
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|warc_s
modifier|*
name|w
decl_stmt|;
name|int
name|r
decl_stmt|;
name|archive_check_magic
argument_list|(
name|_a
argument_list|,
name|ARCHIVE_READ_MAGIC
argument_list|,
name|ARCHIVE_STATE_NEW
argument_list|,
literal|"archive_read_support_format_warc"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|w
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate warc data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|w
argument_list|,
literal|"warc"
argument_list|,
name|_warc_bid
argument_list|,
name|NULL
argument_list|,
name|_warc_rdhdr
argument_list|,
name|_warc_read
argument_list|,
name|_warc_skip
argument_list|,
name|NULL
argument_list|,
name|_warc_cleanup
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_warc_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|warc_s
modifier|*
name|w
init|=
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|pool
operator|.
name|len
operator|>
literal|0U
condition|)
block|{
name|free
argument_list|(
name|w
operator|->
name|pool
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|w
operator|->
name|sver
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|a
operator|->
name|format
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_warc_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|int
name|best_bid
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hdr
decl_stmt|;
name|ssize_t
name|nrd
decl_stmt|;
name|unsigned
name|int
name|ver
decl_stmt|;
operator|(
name|void
operator|)
name|best_bid
expr_stmt|;
comment|/* UNUSED */
comment|/* check first line of file, it should be a record already */
if|if
condition|(
operator|(
name|hdr
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|12U
argument_list|,
operator|&
name|nrd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no idea what to do */
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|nrd
operator|<
literal|12
condition|)
block|{
comment|/* nah, not for us, our magic cookie is at least 12 bytes */
return|return
operator|-
literal|1
return|;
block|}
comment|/* otherwise snarf the record's version number */
name|ver
operator|=
name|_warc_rdver
argument_list|(
name|hdr
argument_list|,
name|nrd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver
operator|<
literal|1200U
operator|||
name|ver
operator|>
literal|10000U
condition|)
block|{
comment|/* we only support WARC 0.12 to 1.0 */
return|return
operator|-
literal|1
return|;
block|}
comment|/* otherwise be confident */
return|return
operator|(
literal|64
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_warc_rdhdr
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
define|#
directive|define
name|HDR_PROBE_LEN
value|(12U)
name|struct
name|warc_s
modifier|*
name|w
init|=
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|unsigned
name|int
name|ver
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|ssize_t
name|nrd
decl_stmt|;
specifier|const
name|char
modifier|*
name|eoh
decl_stmt|;
comment|/* for the file name, saves some strndup()'ing */
name|warc_string_t
name|fnam
decl_stmt|;
comment|/* warc record type, not that we really use it a lot */
name|warc_type_t
name|ftyp
decl_stmt|;
comment|/* content-length+error monad */
name|ssize_t
name|cntlen
decl_stmt|;
comment|/* record time is the WARC-Date time we reinterpret it as ctime */
name|time_t
name|rtime
decl_stmt|;
comment|/* mtime is the Last-Modified time which will be the entry's mtime */
name|time_t
name|mtime
decl_stmt|;
name|start_over
label|:
comment|/* just use read_ahead() they keep track of unconsumed 	 * bits and bobs for us; no need to put an extra shift in 	 * and reproduce that functionality here */
name|buf
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|HDR_PROBE_LEN
argument_list|,
operator|&
name|nrd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrd
operator|<
literal|0
condition|)
block|{
comment|/* no good */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Bad record header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
comment|/* there should be room for at least WARC/bla\r\n 		 * must be EOF therefore */
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
comment|/* looks good so far, try and find the end of the header now */
name|eoh
operator|=
name|_warc_find_eoh
argument_list|(
name|buf
argument_list|,
name|nrd
argument_list|)
expr_stmt|;
if|if
condition|(
name|eoh
operator|==
name|NULL
condition|)
block|{
comment|/* still no good, the header end might be beyond the 		 * probe we've requested, but then again who'd cram 		 * so much stuff into the header *and* be 28500-compliant */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Bad record header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|ver
operator|=
name|_warc_rdver
argument_list|(
name|buf
argument_list|,
name|eoh
operator|-
name|buf
argument_list|)
expr_stmt|;
comment|/* we currently support WARC 0.12 to 1.0 */
if|if
condition|(
name|ver
operator|==
literal|0U
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid record version"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ver
operator|<
literal|1200U
operator|||
name|ver
operator|>
literal|10000U
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unsupported record version: %u.%u"
argument_list|,
name|ver
operator|/
literal|10000
argument_list|,
operator|(
name|ver
operator|%
literal|10000
operator|)
operator|/
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|cntlen
operator|=
name|_warc_rdlen
argument_list|(
name|buf
argument_list|,
name|eoh
operator|-
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntlen
operator|<
literal|0
condition|)
block|{
comment|/* nightmare!  the specs say content-length is mandatory 		 * so I don't feel overly bad stopping the reader here */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Bad content length"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|rtime
operator|=
name|_warc_rdrtm
argument_list|(
name|buf
argument_list|,
name|eoh
operator|-
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtime
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* record time is mandatory as per WARC/1.0, 		 * so just barf here, fast and loud */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Bad record time"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* let the world know we're a WARC archive */
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_WARC
expr_stmt|;
if|if
condition|(
name|ver
operator|!=
name|w
operator|->
name|pver
condition|)
block|{
comment|/* stringify this entry's version */
name|archive_string_sprintf
argument_list|(
operator|&
name|w
operator|->
name|sver
argument_list|,
literal|"WARC/%u.%u"
argument_list|,
name|ver
operator|/
literal|10000
argument_list|,
operator|(
name|ver
operator|%
literal|10000
operator|)
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* remember the version */
name|w
operator|->
name|pver
operator|=
name|ver
expr_stmt|;
block|}
comment|/* start off with the type */
name|ftyp
operator|=
name|_warc_rdtyp
argument_list|(
name|buf
argument_list|,
name|eoh
operator|-
name|buf
argument_list|)
expr_stmt|;
comment|/* and let future calls know about the content */
name|w
operator|->
name|cntlen
operator|=
name|cntlen
expr_stmt|;
name|w
operator|->
name|cntoff
operator|=
literal|0U
expr_stmt|;
name|mtime
operator|=
literal|0
expr_stmt|;
comment|/* Avoid compiling error on some platform. */
switch|switch
condition|(
name|ftyp
condition|)
block|{
case|case
name|WT_RSRC
case|:
case|case
name|WT_RSP
case|:
comment|/* only try and read the filename in the cases that are 		 * guaranteed to have one */
name|fnam
operator|=
name|_warc_rduri
argument_list|(
name|buf
argument_list|,
name|eoh
operator|-
name|buf
argument_list|)
expr_stmt|;
comment|/* check the last character in the URI to avoid creating 		 * directory endpoints as files, see Todo above */
if|if
condition|(
name|fnam
operator|.
name|len
operator|==
literal|0
operator|||
name|fnam
operator|.
name|str
index|[
name|fnam
operator|.
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* break here for now */
name|fnam
operator|.
name|len
operator|=
literal|0U
expr_stmt|;
name|fnam
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* bang to our string pool, so we save a 		 * malloc()+free() roundtrip */
if|if
condition|(
name|fnam
operator|.
name|len
operator|+
literal|1U
operator|>
name|w
operator|->
name|pool
operator|.
name|len
condition|)
block|{
name|w
operator|->
name|pool
operator|.
name|len
operator|=
operator|(
operator|(
name|fnam
operator|.
name|len
operator|+
literal|64U
operator|)
operator|/
literal|64U
operator|)
operator|*
literal|64U
expr_stmt|;
name|w
operator|->
name|pool
operator|.
name|str
operator|=
name|realloc
argument_list|(
name|w
operator|->
name|pool
operator|.
name|str
argument_list|,
name|w
operator|->
name|pool
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|w
operator|->
name|pool
operator|.
name|str
argument_list|,
name|fnam
operator|.
name|str
argument_list|,
name|fnam
operator|.
name|len
argument_list|)
expr_stmt|;
name|w
operator|->
name|pool
operator|.
name|str
index|[
name|fnam
operator|.
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* let no one else know about the pool, it's a secret, shhh */
name|fnam
operator|.
name|str
operator|=
name|w
operator|->
name|pool
operator|.
name|str
expr_stmt|;
comment|/* snarf mtime or deduce from rtime 		 * this is a custom header added by our writer, it's quite 		 * hard to believe anyone else would go through with it 		 * (apart from being part of some http responses of course) */
if|if
condition|(
operator|(
name|mtime
operator|=
name|_warc_rdmtm
argument_list|(
name|buf
argument_list|,
name|eoh
operator|-
name|buf
argument_list|)
operator|)
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|mtime
operator|=
name|rtime
expr_stmt|;
block|}
break|break;
default|default:
name|fnam
operator|.
name|len
operator|=
literal|0U
expr_stmt|;
name|fnam
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* now eat some of those delicious buffer bits */
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|eoh
operator|-
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ftyp
condition|)
block|{
case|case
name|WT_RSRC
case|:
case|case
name|WT_RSP
case|:
if|if
condition|(
name|fnam
operator|.
name|len
operator|>
literal|0U
condition|)
block|{
comment|/* populate entry object */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFREG
argument_list|)
expr_stmt|;
name|archive_entry_copy_pathname
argument_list|(
name|entry
argument_list|,
name|fnam
operator|.
name|str
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|cntlen
argument_list|)
expr_stmt|;
name|archive_entry_set_perm
argument_list|(
name|entry
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
comment|/* rtime is the new ctime, mtime stays mtime */
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|rtime
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|mtime
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
comment|/* consume the content and start over */
name|_warc_skip
argument_list|(
name|a
argument_list|)
expr_stmt|;
goto|goto
name|start_over
goto|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_warc_read
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|bsz
parameter_list|,
name|int64_t
modifier|*
name|off
parameter_list|)
block|{
name|struct
name|warc_s
modifier|*
name|w
init|=
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|rab
decl_stmt|;
name|ssize_t
name|nrd
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|cntoff
operator|>=
name|w
operator|->
name|cntlen
condition|)
block|{
name|eof
label|:
comment|/* it's our lucky day, no work, we can leave early */
operator|*
name|buf
operator|=
name|NULL
expr_stmt|;
operator|*
name|bsz
operator|=
literal|0U
expr_stmt|;
operator|*
name|off
operator|=
name|w
operator|->
name|cntoff
operator|+
literal|4U
comment|/*for \r\n\r\n separator*/
expr_stmt|;
name|w
operator|->
name|unconsumed
operator|=
literal|0U
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
name|rab
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1U
argument_list|,
operator|&
name|nrd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrd
operator|<
literal|0
condition|)
block|{
operator|*
name|bsz
operator|=
literal|0U
expr_stmt|;
comment|/* big catastrophe */
return|return
operator|(
name|int
operator|)
name|nrd
return|;
block|}
elseif|else
if|if
condition|(
name|nrd
operator|==
literal|0
condition|)
block|{
goto|goto
name|eof
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|nrd
operator|>
name|w
operator|->
name|cntlen
operator|-
name|w
operator|->
name|cntoff
condition|)
block|{
comment|/* clamp to content-length */
name|nrd
operator|=
name|w
operator|->
name|cntlen
operator|-
name|w
operator|->
name|cntoff
expr_stmt|;
block|}
operator|*
name|off
operator|=
name|w
operator|->
name|cntoff
expr_stmt|;
operator|*
name|bsz
operator|=
name|nrd
expr_stmt|;
operator|*
name|buf
operator|=
name|rab
expr_stmt|;
name|w
operator|->
name|cntoff
operator|+=
name|nrd
expr_stmt|;
name|w
operator|->
name|unconsumed
operator|=
operator|(
name|size_t
operator|)
name|nrd
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_warc_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|warc_s
modifier|*
name|w
init|=
name|a
operator|->
name|format
operator|->
name|data
decl_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|w
operator|->
name|cntlen
operator|+
literal|4U
comment|/*\r\n\r\n separator*/
argument_list|)
expr_stmt|;
name|w
operator|->
name|cntlen
operator|=
literal|0U
expr_stmt|;
name|w
operator|->
name|cntoff
operator|=
literal|0U
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* private routines */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|deconst
parameter_list|(
specifier|const
name|void
modifier|*
name|c
parameter_list|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
literal|0x1
operator|+
operator|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|c
operator|)
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0x1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xmemmem
parameter_list|(
specifier|const
name|char
modifier|*
name|hay
parameter_list|,
specifier|const
name|size_t
name|haysize
parameter_list|,
specifier|const
name|char
modifier|*
name|needle
parameter_list|,
specifier|const
name|size_t
name|needlesize
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|eoh
init|=
name|hay
operator|+
name|haysize
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|eon
init|=
name|needle
operator|+
name|needlesize
decl_stmt|;
specifier|const
name|char
modifier|*
name|hp
decl_stmt|;
specifier|const
name|char
modifier|*
name|np
decl_stmt|;
specifier|const
name|char
modifier|*
name|cand
decl_stmt|;
name|unsigned
name|int
name|hsum
decl_stmt|;
name|unsigned
name|int
name|nsum
decl_stmt|;
name|unsigned
name|int
name|eqp
decl_stmt|;
comment|/* trivial checks first          * a 0-sized needle is defined to be found anywhere in haystack          * then run strchr() to find a candidate in HAYSTACK (i.e. a portion          * that happens to begin with *NEEDLE) */
if|if
condition|(
name|needlesize
operator|==
literal|0UL
condition|)
block|{
return|return
name|deconst
argument_list|(
name|hay
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hay
operator|=
name|memchr
argument_list|(
name|hay
argument_list|,
operator|*
name|needle
argument_list|,
name|haysize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* trivial */
return|return
name|NULL
return|;
block|}
comment|/* First characters of haystack and needle are the same now. Both are 	 * guaranteed to be at least one character long.  Now computes the sum 	 * of characters values of needle together with the sum of the first 	 * needle_len characters of haystack. */
for|for
control|(
name|hp
operator|=
name|hay
operator|+
literal|1U
operator|,
name|np
operator|=
name|needle
operator|+
literal|1U
operator|,
name|hsum
operator|=
operator|*
name|hay
operator|,
name|nsum
operator|=
operator|*
name|hay
operator|,
name|eqp
operator|=
literal|1U
init|;
name|hp
operator|<
name|eoh
operator|&&
name|np
operator|<
name|eon
condition|;
name|hsum
operator|^=
operator|*
name|hp
operator|,
name|nsum
operator|^=
operator|*
name|np
operator|,
name|eqp
operator|&=
operator|*
name|hp
operator|==
operator|*
name|np
operator|,
name|hp
operator|++
operator|,
name|np
operator|++
control|)
empty_stmt|;
comment|/* HP now references the (NEEDLESIZE + 1)-th character. */
if|if
condition|(
name|np
operator|<
name|eon
condition|)
block|{
comment|/* haystack is smaller than needle, :O */
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|eqp
condition|)
block|{
comment|/* found a match */
return|return
name|deconst
argument_list|(
name|hay
argument_list|)
return|;
block|}
comment|/* now loop through the rest of haystack, 	 * updating the sum iteratively */
for|for
control|(
name|cand
operator|=
name|hay
init|;
name|hp
operator|<
name|eoh
condition|;
name|hp
operator|++
control|)
block|{
name|hsum
operator|^=
operator|*
name|cand
operator|++
expr_stmt|;
name|hsum
operator|^=
operator|*
name|hp
expr_stmt|;
comment|/* Since the sum of the characters is already known to be 		 * equal at that point, it is enough to check just NEEDLESIZE - 1 		 * characters for equality, 		 * also CAND is by design< HP, so no need for range checks */
if|if
condition|(
name|hsum
operator|==
name|nsum
operator|&&
name|memcmp
argument_list|(
name|cand
argument_list|,
name|needle
argument_list|,
name|needlesize
operator|-
literal|1U
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|deconst
argument_list|(
name|cand
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|strtoi_lim
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|ep
parameter_list|,
name|int
name|llim
parameter_list|,
name|int
name|ulim
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
comment|/* we keep track of the number of digits via rulim */
name|int
name|rulim
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|str
operator|,
name|rulim
operator|=
name|ulim
operator|>
literal|10
condition|?
name|ulim
else|:
literal|10
init|;
name|res
operator|*
literal|10
operator|<=
name|ulim
operator|&&
name|rulim
operator|&&
operator|*
name|sp
operator|>=
literal|'0'
operator|&&
operator|*
name|sp
operator|<=
literal|'9'
condition|;
name|sp
operator|++
operator|,
name|rulim
operator|/=
literal|10
control|)
block|{
name|res
operator|*=
literal|10
expr_stmt|;
name|res
operator|+=
operator|*
name|sp
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|==
name|str
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|<
name|llim
operator|||
name|res
operator|>
name|ulim
condition|)
block|{
name|res
operator|=
operator|-
literal|2
expr_stmt|;
block|}
operator|*
name|ep
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sp
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|time_from_tm
parameter_list|(
name|struct
name|tm
modifier|*
name|t
parameter_list|)
block|{
if|#
directive|if
name|HAVE_TIMEGM
comment|/* Use platform timegm() if available. */
return|return
operator|(
name|timegm
argument_list|(
name|t
argument_list|)
operator|)
return|;
elif|#
directive|elif
name|HAVE__MKGMTIME64
return|return
operator|(
name|_mkgmtime64
argument_list|(
name|t
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* Else use direct calculation using POSIX assumptions. */
comment|/* First, fix up tm_yday based on the year/month/day. */
if|if
condition|(
name|mktime
argument_list|(
name|t
argument_list|)
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|time_t
operator|)
operator|-
literal|1
operator|)
return|;
comment|/* Then we can compute timegm() from first principles. */
return|return
operator|(
name|t
operator|->
name|tm_sec
operator|+
name|t
operator|->
name|tm_min
operator|*
literal|60
operator|+
name|t
operator|->
name|tm_hour
operator|*
literal|3600
operator|+
name|t
operator|->
name|tm_yday
operator|*
literal|86400
operator|+
operator|(
name|t
operator|->
name|tm_year
operator|-
literal|70
operator|)
operator|*
literal|31536000
operator|+
operator|(
operator|(
name|t
operator|->
name|tm_year
operator|-
literal|69
operator|)
operator|/
literal|4
operator|)
operator|*
literal|86400
operator|-
operator|(
operator|(
name|t
operator|->
name|tm_year
operator|-
literal|1
operator|)
operator|/
literal|100
operator|)
operator|*
literal|86400
operator|+
operator|(
operator|(
name|t
operator|->
name|tm_year
operator|+
literal|299
operator|)
operator|/
literal|400
operator|)
operator|*
literal|86400
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|time_t
name|xstrpisotime
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|endptr
parameter_list|)
block|{
comment|/** like strptime() but strictly for ISO 8601 Zulu strings */
name|struct
name|tm
name|tm
decl_stmt|;
name|time_t
name|res
init|=
operator|(
name|time_t
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* make sure tm is clean */
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* as a courtesy to our callers, and since this is a non-standard 	 * routine, we skip leading whitespace */
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
operator|++
name|s
expr_stmt|;
comment|/* read year */
if|if
condition|(
operator|(
name|tm
operator|.
name|tm_year
operator|=
name|strtoi_lim
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|1583
argument_list|,
literal|4095
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|*
name|s
operator|++
operator|!=
literal|'-'
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* read month */
if|if
condition|(
operator|(
name|tm
operator|.
name|tm_mon
operator|=
name|strtoi_lim
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|*
name|s
operator|++
operator|!=
literal|'-'
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* read day-of-month */
if|if
condition|(
operator|(
name|tm
operator|.
name|tm_mday
operator|=
name|strtoi_lim
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|*
name|s
operator|++
operator|!=
literal|'T'
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* read hour */
if|if
condition|(
operator|(
name|tm
operator|.
name|tm_hour
operator|=
name|strtoi_lim
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|*
name|s
operator|++
operator|!=
literal|':'
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* read minute */
if|if
condition|(
operator|(
name|tm
operator|.
name|tm_min
operator|=
name|strtoi_lim
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|0
argument_list|,
literal|59
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|*
name|s
operator|++
operator|!=
literal|':'
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* read second */
if|if
condition|(
operator|(
name|tm
operator|.
name|tm_sec
operator|=
name|strtoi_lim
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|0
argument_list|,
literal|60
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|*
name|s
operator|++
operator|!=
literal|'Z'
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* massage TM to fulfill some of POSIX' constraints */
name|tm
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|--
expr_stmt|;
comment|/* now convert our custom tm struct to a unix stamp using UTC */
name|res
operator|=
name|time_from_tm
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|endptr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|endptr
operator|=
name|deconst
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|_warc_rdver
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|magic
index|[]
init|=
literal|"WARC/"
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|unsigned
name|int
name|ver
init|=
literal|0U
decl_stmt|;
name|unsigned
name|int
name|end
init|=
literal|0U
decl_stmt|;
if|if
condition|(
name|bsz
operator|<
literal|12
operator|||
name|memcmp
argument_list|(
name|buf
argument_list|,
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|-
literal|1U
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* buffer too small or invalid magic */
return|return
name|ver
return|;
block|}
comment|/* looks good so far, read the version number for a laugh */
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|-
literal|1U
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|0U
index|]
argument_list|)
operator|&&
operator|(
name|buf
index|[
literal|1U
index|]
operator|==
literal|'.'
operator|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|2U
index|]
argument_list|)
condition|)
block|{
comment|/* we support a maximum of 2 digits in the minor version */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|3U
index|]
argument_list|)
condition|)
name|end
operator|=
literal|1U
expr_stmt|;
comment|/* set up major version */
name|ver
operator|=
operator|(
name|buf
index|[
literal|0U
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10000U
expr_stmt|;
comment|/* set up minor version */
if|if
condition|(
name|end
operator|==
literal|1U
condition|)
block|{
name|ver
operator|+=
operator|(
name|buf
index|[
literal|2U
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|1000U
expr_stmt|;
name|ver
operator|+=
operator|(
name|buf
index|[
literal|3U
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|100U
expr_stmt|;
block|}
else|else
name|ver
operator|+=
operator|(
name|buf
index|[
literal|2U
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|100U
expr_stmt|;
comment|/* 		 * WARC below version 0.12 has a space-separated header 		 * WARC 0.12 and above terminates the version with a CRLF 		 */
name|c
operator|=
name|buf
operator|+
literal|3U
operator|+
name|end
expr_stmt|;
if|if
condition|(
name|ver
operator|>=
literal|1200U
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|c
argument_list|,
literal|"\r\n"
argument_list|,
literal|2U
argument_list|)
operator|!=
literal|0
condition|)
name|ver
operator|=
literal|0U
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ver
operator|<
literal|1200U
condition|)
block|{
if|if
condition|(
operator|*
name|c
operator|!=
literal|' '
operator|&&
operator|*
name|c
operator|!=
literal|'\t'
condition|)
name|ver
operator|=
literal|0U
expr_stmt|;
block|}
block|}
return|return
name|ver
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|_warc_rdtyp
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|_key
index|[]
init|=
literal|"\r\nWARC-Type:"
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|xmemmem
argument_list|(
name|buf
argument_list|,
name|bsz
argument_list|,
name|_key
argument_list|,
sizeof|sizeof
argument_list|(
name|_key
argument_list|)
operator|-
literal|1U
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no bother */
return|return
name|WT_NONE
return|;
block|}
name|val
operator|+=
sizeof|sizeof
argument_list|(
name|_key
argument_list|)
operator|-
literal|1U
expr_stmt|;
if|if
condition|(
operator|(
name|eol
operator|=
name|_warc_find_eol
argument_list|(
name|val
argument_list|,
name|buf
operator|+
name|bsz
operator|-
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no end of line */
return|return
name|WT_NONE
return|;
block|}
comment|/* overread whitespace */
while|while
condition|(
name|val
operator|<
name|eol
operator|&&
operator|(
operator|*
name|val
operator|==
literal|' '
operator|||
operator|*
name|val
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|val
expr_stmt|;
if|if
condition|(
name|val
operator|+
literal|8U
operator|==
name|eol
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|val
argument_list|,
literal|"resource"
argument_list|,
literal|8U
argument_list|)
operator|==
literal|0
condition|)
return|return
name|WT_RSRC
return|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|val
argument_list|,
literal|"response"
argument_list|,
literal|8U
argument_list|)
operator|==
literal|0
condition|)
return|return
name|WT_RSP
return|;
block|}
return|return
name|WT_NONE
return|;
block|}
end_function

begin_function
specifier|static
name|warc_string_t
name|_warc_rduri
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|_key
index|[]
init|=
literal|"\r\nWARC-Target-URI:"
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|uri
decl_stmt|,
modifier|*
name|eol
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|warc_string_t
name|res
init|=
block|{
literal|0U
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|xmemmem
argument_list|(
name|buf
argument_list|,
name|bsz
argument_list|,
name|_key
argument_list|,
sizeof|sizeof
argument_list|(
name|_key
argument_list|)
operator|-
literal|1U
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no bother */
return|return
name|res
return|;
block|}
comment|/* overread whitespace */
name|val
operator|+=
sizeof|sizeof
argument_list|(
name|_key
argument_list|)
operator|-
literal|1U
expr_stmt|;
if|if
condition|(
operator|(
name|eol
operator|=
name|_warc_find_eol
argument_list|(
name|val
argument_list|,
name|buf
operator|+
name|bsz
operator|-
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no end of line */
return|return
name|res
return|;
block|}
while|while
condition|(
name|val
operator|<
name|eol
operator|&&
operator|(
operator|*
name|val
operator|==
literal|' '
operator|||
operator|*
name|val
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|val
expr_stmt|;
comment|/* overread URL designators */
if|if
condition|(
operator|(
name|uri
operator|=
name|xmemmem
argument_list|(
name|val
argument_list|,
name|eol
operator|-
name|val
argument_list|,
literal|"://"
argument_list|,
literal|3U
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* not touching that! */
return|return
name|res
return|;
block|}
comment|/* spaces inside uri are not allowed, CRLF should follow */
for|for
control|(
name|p
operator|=
name|val
init|;
name|p
operator|<
name|eol
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
return|return
name|res
return|;
block|}
comment|/* there must be at least space for ftp */
if|if
condition|(
name|uri
operator|<
operator|(
name|val
operator|+
literal|3U
operator|)
condition|)
return|return
name|res
return|;
comment|/* move uri to point to after :// */
name|uri
operator|+=
literal|3U
expr_stmt|;
comment|/* now then, inspect the URI */
if|if
condition|(
name|memcmp
argument_list|(
name|val
argument_list|,
literal|"file"
argument_list|,
literal|4U
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* perfect, nothing left to do here */
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|val
argument_list|,
literal|"http"
argument_list|,
literal|4U
argument_list|)
operator|==
literal|0
operator|||
name|memcmp
argument_list|(
name|val
argument_list|,
literal|"ftp"
argument_list|,
literal|3U
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* overread domain, and the first / */
while|while
condition|(
name|uri
operator|<
name|eol
operator|&&
operator|*
name|uri
operator|++
operator|!=
literal|'/'
condition|)
empty_stmt|;
block|}
else|else
block|{
comment|/* not sure what to do? best to bugger off */
return|return
name|res
return|;
block|}
name|res
operator|.
name|str
operator|=
name|uri
expr_stmt|;
name|res
operator|.
name|len
operator|=
name|eol
operator|-
name|uri
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|_warc_rdlen
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|_key
index|[]
init|=
literal|"\r\nContent-Length:"
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
name|char
modifier|*
name|on
init|=
name|NULL
decl_stmt|;
name|long
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|xmemmem
argument_list|(
name|buf
argument_list|,
name|bsz
argument_list|,
name|_key
argument_list|,
sizeof|sizeof
argument_list|(
name|_key
argument_list|)
operator|-
literal|1U
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no bother */
return|return
operator|-
literal|1
return|;
block|}
name|val
operator|+=
sizeof|sizeof
argument_list|(
name|_key
argument_list|)
operator|-
literal|1U
expr_stmt|;
if|if
condition|(
operator|(
name|eol
operator|=
name|_warc_find_eol
argument_list|(
name|val
argument_list|,
name|buf
operator|+
name|bsz
operator|-
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no end of line */
return|return
operator|-
literal|1
return|;
block|}
comment|/* skip leading whitespace */
while|while
condition|(
name|val
operator|<
name|eol
operator|&&
operator|(
operator|*
name|val
operator|==
literal|' '
operator|||
operator|*
name|val
operator|==
literal|'\t'
operator|)
condition|)
name|val
operator|++
expr_stmt|;
comment|/* there must be at least one digit */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|val
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|=
name|strtol
argument_list|(
name|val
argument_list|,
operator|&
name|on
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
operator|!=
name|eol
condition|)
block|{
comment|/* line must end here */
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|size_t
operator|)
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|_warc_rdrtm
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|_key
index|[]
init|=
literal|"\r\nWARC-Date:"
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
name|char
modifier|*
name|on
init|=
name|NULL
decl_stmt|;
name|time_t
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|xmemmem
argument_list|(
name|buf
argument_list|,
name|bsz
argument_list|,
name|_key
argument_list|,
sizeof|sizeof
argument_list|(
name|_key
argument_list|)
operator|-
literal|1U
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no bother */
return|return
operator|(
name|time_t
operator|)
operator|-
literal|1
return|;
block|}
name|val
operator|+=
sizeof|sizeof
argument_list|(
name|_key
argument_list|)
operator|-
literal|1U
expr_stmt|;
if|if
condition|(
operator|(
name|eol
operator|=
name|_warc_find_eol
argument_list|(
name|val
argument_list|,
name|buf
operator|+
name|bsz
operator|-
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no end of line */
return|return
operator|-
literal|1
return|;
block|}
comment|/* xstrpisotime() kindly overreads whitespace for us, so use that */
name|res
operator|=
name|xstrpisotime
argument_list|(
name|val
argument_list|,
operator|&
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
operator|!=
name|eol
condition|)
block|{
comment|/* line must end here */
return|return
operator|-
literal|1
return|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|_warc_rdmtm
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|_key
index|[]
init|=
literal|"\r\nLast-Modified:"
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
name|char
modifier|*
name|on
init|=
name|NULL
decl_stmt|;
name|time_t
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|xmemmem
argument_list|(
name|buf
argument_list|,
name|bsz
argument_list|,
name|_key
argument_list|,
sizeof|sizeof
argument_list|(
name|_key
argument_list|)
operator|-
literal|1U
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no bother */
return|return
operator|(
name|time_t
operator|)
operator|-
literal|1
return|;
block|}
name|val
operator|+=
sizeof|sizeof
argument_list|(
name|_key
argument_list|)
operator|-
literal|1U
expr_stmt|;
if|if
condition|(
operator|(
name|eol
operator|=
name|_warc_find_eol
argument_list|(
name|val
argument_list|,
name|buf
operator|+
name|bsz
operator|-
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no end of line */
return|return
operator|-
literal|1
return|;
block|}
comment|/* xstrpisotime() kindly overreads whitespace for us, so use that */
name|res
operator|=
name|xstrpisotime
argument_list|(
name|val
argument_list|,
operator|&
name|on
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
operator|!=
name|eol
condition|)
block|{
comment|/* line must end here */
return|return
operator|-
literal|1
return|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_warc_find_eoh
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|_marker
index|[]
init|=
literal|"\r\n\r\n"
decl_stmt|;
specifier|const
name|char
modifier|*
name|hit
init|=
name|xmemmem
argument_list|(
name|buf
argument_list|,
name|bsz
argument_list|,
name|_marker
argument_list|,
sizeof|sizeof
argument_list|(
name|_marker
argument_list|)
operator|-
literal|1U
argument_list|)
decl_stmt|;
if|if
condition|(
name|hit
operator|!=
name|NULL
condition|)
block|{
name|hit
operator|+=
sizeof|sizeof
argument_list|(
name|_marker
argument_list|)
operator|-
literal|1U
expr_stmt|;
block|}
return|return
name|hit
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_warc_find_eol
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bsz
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|_marker
index|[]
init|=
literal|"\r\n"
decl_stmt|;
specifier|const
name|char
modifier|*
name|hit
init|=
name|xmemmem
argument_list|(
name|buf
argument_list|,
name|bsz
argument_list|,
name|_marker
argument_list|,
sizeof|sizeof
argument_list|(
name|_marker
argument_list|)
operator|-
literal|1U
argument_list|)
decl_stmt|;
return|return
name|hit
return|;
block|}
end_function

begin_comment
comment|/* archive_read_support_format_warc.c ends here */
end_comment

end_unit

