begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011-2012 Michihiro NAKAJIMA  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"test.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_define
define|#
directive|define
name|__LIBARCHIVE_TEST
end_define

begin_include
include|#
directive|include
file|"archive_string.h"
end_include

begin_comment
comment|/* Execute the following to rebuild the data for this program:    tail -n +36 test_archive_string_conversion.c | /bin/sh # # This requires http://unicode.org/Public/6.0.0/ucd/NormalizationTest.txt # if="NormalizationTest.txt" if [ ! -f ${if} ]; then   echo "Not found: \"${if}\""   exit 0 fi of=test_archive_string_conversion.txt.Z echo "\$FreeBSD\$"> ${of}.uu awk -F ';'  '$0 ~/^[0-9A-F]+/ {printf "%s;%s\n", $2, $3}' ${if} | compress | uuencode ${of}>> ${of}.uu exit 1 */
end_comment

begin_function
specifier|static
name|int
name|unicode_to_utf8
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|uint32_t
name|uc
parameter_list|)
block|{
name|char
modifier|*
name|_p
init|=
name|p
decl_stmt|;
comment|/* Translate code point to UTF8 */
if|if
condition|(
name|uc
operator|<=
literal|0x7f
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|char
operator|)
name|uc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
operator|<=
literal|0x7ff
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0xc0
operator||
operator|(
operator|(
name|uc
operator|>>
literal|6
operator|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
name|uc
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uc
operator|<=
literal|0xffff
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0xe0
operator||
operator|(
operator|(
name|uc
operator|>>
literal|12
operator|)
operator|&
literal|0x0f
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
operator|(
name|uc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
name|uc
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|0xf0
operator||
operator|(
operator|(
name|uc
operator|>>
literal|18
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
operator|(
name|uc
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
operator|(
name|uc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x80
operator||
operator|(
name|uc
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|archive_be16enc
parameter_list|(
name|void
modifier|*
name|pp
parameter_list|,
name|uint16_t
name|u
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pp
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|u
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|u
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unicode_to_utf16be
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|uint32_t
name|uc
parameter_list|)
block|{
name|char
modifier|*
name|utf16
init|=
name|p
decl_stmt|;
if|if
condition|(
name|uc
operator|>
literal|0xffff
condition|)
block|{
comment|/* We have a code point that won't fit into a 		 * wchar_t; convert it to a surrogate pair. */
name|uc
operator|-=
literal|0x10000
expr_stmt|;
name|archive_be16enc
argument_list|(
name|utf16
argument_list|,
operator|(
operator|(
name|uc
operator|>>
literal|10
operator|)
operator|&
literal|0x3ff
operator|)
operator|+
literal|0xD800
argument_list|)
expr_stmt|;
name|archive_be16enc
argument_list|(
name|utf16
operator|+
literal|2
argument_list|,
operator|(
name|uc
operator|&
literal|0x3ff
operator|)
operator|+
literal|0xDC00
argument_list|)
expr_stmt|;
return|return
operator|(
literal|4
operator|)
return|;
block|}
else|else
block|{
name|archive_be16enc
argument_list|(
name|utf16
argument_list|,
name|uc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|archive_le16enc
parameter_list|(
name|void
modifier|*
name|pp
parameter_list|,
name|uint16_t
name|u
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pp
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|u
operator|&
literal|0xff
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|u
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|unicode_to_utf16le
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|uint32_t
name|uc
parameter_list|)
block|{
name|char
modifier|*
name|utf16
init|=
name|p
decl_stmt|;
if|if
condition|(
name|uc
operator|>
literal|0xffff
condition|)
block|{
comment|/* We have a code point that won't fit into a 		 * wchar_t; convert it to a surrogate pair. */
name|uc
operator|-=
literal|0x10000
expr_stmt|;
name|archive_le16enc
argument_list|(
name|utf16
argument_list|,
operator|(
operator|(
name|uc
operator|>>
literal|10
operator|)
operator|&
literal|0x3ff
operator|)
operator|+
literal|0xD800
argument_list|)
expr_stmt|;
name|archive_le16enc
argument_list|(
name|utf16
operator|+
literal|2
argument_list|,
operator|(
name|uc
operator|&
literal|0x3ff
operator|)
operator|+
literal|0xDC00
argument_list|)
expr_stmt|;
return|return
operator|(
literal|4
operator|)
return|;
block|}
else|else
block|{
name|archive_le16enc
argument_list|(
name|utf16
argument_list|,
name|uc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wc_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unicode_to_wc
parameter_list|(
name|wchar_t
modifier|*
name|wp
parameter_list|,
name|uint32_t
name|uc
parameter_list|)
block|{
if|if
condition|(
name|wc_size
argument_list|()
operator|==
literal|4
condition|)
block|{
operator|*
name|wp
operator|=
operator|(
name|wchar_t
operator|)
name|uc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|uc
operator|>
literal|0xffff
condition|)
block|{
comment|/* We have a code point that won't fit into a 		 * wchar_t; convert it to a surrogate pair. */
name|uc
operator|-=
literal|0x10000
expr_stmt|;
operator|*
name|wp
operator|++
operator|=
call|(
name|wchar_t
call|)
argument_list|(
operator|(
operator|(
name|uc
operator|>>
literal|10
operator|)
operator|&
literal|0x3ff
operator|)
operator|+
literal|0xD800
argument_list|)
expr_stmt|;
operator|*
name|wp
operator|=
call|(
name|wchar_t
call|)
argument_list|(
operator|(
name|uc
operator|&
literal|0x3ff
operator|)
operator|+
literal|0xDC00
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
else|else
block|{
operator|*
name|wp
operator|=
operator|(
name|wchar_t
operator|)
name|uc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Note: U+2000 - U+2FFF, U+F900 - U+FAFF and U+2F800 - U+2FAFF are not  * converted to NFD on Mac OS.  * see also http://developer.apple.com/library/mac/#qa/qa2001/qa1173.html  */
end_comment

begin_function
specifier|static
name|int
name|scan_unicode_pattern
parameter_list|(
name|char
modifier|*
name|out
parameter_list|,
name|wchar_t
modifier|*
name|wout
parameter_list|,
name|char
modifier|*
name|u16be
parameter_list|,
name|char
modifier|*
name|u16le
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|mac_nfd
parameter_list|)
block|{
name|unsigned
name|uc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
name|char
modifier|*
name|op
init|=
name|out
decl_stmt|;
name|wchar_t
modifier|*
name|owp
init|=
name|wout
decl_stmt|;
name|char
modifier|*
name|op16be
init|=
name|u16be
decl_stmt|;
name|char
modifier|*
name|op16le
init|=
name|u16le
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|uc
operator|=
operator|(
name|uc
operator|<<
literal|4
operator|)
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'F'
condition|)
name|uc
operator|=
operator|(
name|uc
operator|<<
literal|4
operator|)
operator|+
operator|(
operator|*
name|p
operator|-
literal|'A'
operator|+
literal|0x0a
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mac_nfd
operator|&&
name|op
operator|==
name|out
condition|)
block|{
comment|/* 				 * These are not converted to NFD on Mac OS.  				 * U+2000 - U+2FFF 				 * U+F900 - U+FAFF 				 * U+2F800 - U+2FAFF 				 */
switch|switch
condition|(
name|uc
condition|)
block|{
case|case
literal|0x2194
case|:
case|case
literal|0x219A
case|:
case|case
literal|0x219B
case|:
case|case
literal|0x21AE
case|:
case|case
literal|0x21CD
case|:
case|case
literal|0x21CE
case|:
case|case
literal|0x21CF
case|:
case|case
literal|0x2204
case|:
case|case
literal|0x2209
case|:
case|case
literal|0x220C
case|:
case|case
literal|0x2224
case|:
case|case
literal|0x2226
case|:
case|case
literal|0x2241
case|:
case|case
literal|0x2244
case|:
case|case
literal|0x2247
case|:
case|case
literal|0x2249
case|:
case|case
literal|0x2260
case|:
case|case
literal|0x2262
case|:
case|case
literal|0x226D
case|:
case|case
literal|0x226E
case|:
case|case
literal|0x226F
case|:
case|case
literal|0x2270
case|:
case|case
literal|0x2271
case|:
case|case
literal|0x2274
case|:
case|case
literal|0x2275
case|:
case|case
literal|0x2276
case|:
case|case
literal|0x2278
case|:
case|case
literal|0x2279
case|:
case|case
literal|0x227A
case|:
case|case
literal|0x227B
case|:
case|case
literal|0x2280
case|:
case|case
literal|0x2281
case|:
case|case
literal|0x2284
case|:
case|case
literal|0x2285
case|:
case|case
literal|0x2288
case|:
case|case
literal|0x2289
case|:
case|case
literal|0x22AC
case|:
case|case
literal|0x22AD
case|:
case|case
literal|0x22AE
case|:
case|case
literal|0x22AF
case|:
case|case
literal|0x22E0
case|:
case|case
literal|0x22E1
case|:
case|case
literal|0x22E2
case|:
case|case
literal|0x22E3
case|:
case|case
literal|0x22EA
case|:
case|case
literal|0x22EB
case|:
case|case
literal|0x22EC
case|:
case|case
literal|0x22ED
case|:
comment|/* 				 * Those code points are not converted to 				 * NFD on Mac OS. I do not know the reason 				 * because it is undocumented. 				 *   NFC        NFD 				 *   1109A  ==> 11099 110BA 				 *   1109C  ==> 1109B 110BA 				 *   110AB  ==> 110A5 110BA 				 */
case|case
literal|0x1109A
case|:
case|case
literal|0x1109C
case|:
case|case
literal|0x110AB
case|:
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|op16be
operator|+=
name|unicode_to_utf16be
argument_list|(
name|op16be
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|op16le
operator|+=
name|unicode_to_utf16le
argument_list|(
name|op16le
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|owp
operator|+=
name|unicode_to_wc
argument_list|(
name|owp
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|op
operator|+=
name|unicode_to_utf8
argument_list|(
name|op
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
operator|*
name|op16be
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|op16be
operator|=
literal|0
expr_stmt|;
operator|*
name|op16le
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|op16le
operator|=
literal|0
expr_stmt|;
operator|*
name|owp
operator|=
literal|L'
expr|\0'
expr_stmt|;
operator|*
name|op
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|uc
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_wc_unicode
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * A conversion test that we correctly normalize UTF-8 and UTF-16BE characters.  * On Mac OS, the characters to be Form D.  * On other platforms, the characters to be Form C.  */
end_comment

begin_function
specifier|static
name|void
name|test_archive_string_normalization_nfc
parameter_list|(
specifier|const
name|char
modifier|*
name|testdata
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
name|struct
name|archive_string
name|utf8
decl_stmt|;
name|struct
name|archive_mstring
name|mstr
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|f_sconv8
decl_stmt|,
modifier|*
name|t_sconv8
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|f_sconv16be
decl_stmt|,
modifier|*
name|f_sconv16le
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buff
index|[
literal|512
index|]
decl_stmt|;
name|int
name|line
init|=
literal|0
decl_stmt|;
name|int
name|locale_is_utf8
decl_stmt|,
name|wc_is_unicode
decl_stmt|;
name|int
name|sconv_opt
init|=
name|SCONV_SET_OPT_NORMALIZATION_C
decl_stmt|;
name|locale_is_utf8
operator|=
operator|(
name|NULL
operator|!=
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|"en_US.UTF-8"
argument_list|)
operator|)
expr_stmt|;
name|wc_is_unicode
operator|=
name|is_wc_unicode
argument_list|()
expr_stmt|;
comment|/* If it doesn't exist, just warn and return. */
if|if
condition|(
operator|!
name|locale_is_utf8
operator|&&
operator|!
name|wc_is_unicode
condition|)
block|{
name|skipping
argument_list|(
literal|"A test of string normalization for NFC requires "
literal|"a suitable locale; en_US.UTF-8 not available on this "
literal|"system"
argument_list|)
expr_stmt|;
return|return;
block|}
name|archive_string_init
argument_list|(
operator|&
name|utf8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mstr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mstr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create string conversion objects. 	 */
name|assert
argument_list|(
operator|(
name|a
operator|=
name|archive_read_new
argument_list|()
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|f_sconv8
operator|=
name|archive_string_conversion_from_charset
argument_list|(
name|a
argument_list|,
literal|"UTF-8"
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|f_sconv16be
operator|=
name|archive_string_conversion_from_charset
argument_list|(
name|a
argument_list|,
literal|"UTF-16BE"
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|f_sconv16le
operator|=
name|archive_string_conversion_from_charset
argument_list|(
name|a
argument_list|,
literal|"UTF-16LE"
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|a2
operator|=
name|archive_write_new
argument_list|()
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|t_sconv8
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a2
argument_list|,
literal|"UTF-8"
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sconv8
operator|==
name|NULL
operator|||
name|f_sconv16be
operator|==
name|NULL
operator|||
name|f_sconv16le
operator|==
name|NULL
operator|||
name|t_sconv8
operator|==
name|NULL
condition|)
block|{
comment|/* We cannot continue this test. */
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_read_free
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|archive_string_conversion_set_opt
argument_list|(
name|f_sconv8
argument_list|,
name|sconv_opt
argument_list|)
expr_stmt|;
name|archive_string_conversion_set_opt
argument_list|(
name|f_sconv16be
argument_list|,
name|sconv_opt
argument_list|)
expr_stmt|;
name|archive_string_conversion_set_opt
argument_list|(
name|f_sconv16le
argument_list|,
name|sconv_opt
argument_list|)
expr_stmt|;
name|archive_string_conversion_set_opt
argument_list|(
name|t_sconv8
argument_list|,
name|sconv_opt
argument_list|)
expr_stmt|;
comment|/* Open a test pattern file. */
name|assert
argument_list|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|testdata
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Read test data. 	 *  Test data format: 	 *<NFC Unicode pattern> ';'<NFD Unicode pattern> '\n' 	 *  Unicode pattern format: 	 *     [0-9A-F]{4,5}([ ][0-9A-F]{4,5}){0,} 	 */
while|while
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|nfc
index|[
literal|80
index|]
decl_stmt|,
name|nfd
index|[
literal|80
index|]
decl_stmt|;
name|char
name|utf8_nfc
index|[
literal|80
index|]
decl_stmt|,
name|utf8_nfd
index|[
literal|80
index|]
decl_stmt|;
name|char
name|utf16be_nfc
index|[
literal|80
index|]
decl_stmt|,
name|utf16be_nfd
index|[
literal|80
index|]
decl_stmt|;
name|char
name|utf16le_nfc
index|[
literal|80
index|]
decl_stmt|,
name|utf16le_nfd
index|[
literal|80
index|]
decl_stmt|;
name|wchar_t
name|wc_nfc
index|[
literal|40
index|]
decl_stmt|,
name|wc_nfd
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
specifier|const
name|char
modifier|*
name|mp
decl_stmt|;
name|size_t
name|mplen
decl_stmt|;
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Copy an NFC pattern */
name|strncpy
argument_list|(
name|nfc
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|nfc
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nfc
index|[
sizeof|sizeof
argument_list|(
name|nfc
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|e
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Copy an NFD pattern */
name|strncpy
argument_list|(
name|nfd
argument_list|,
name|e
argument_list|,
sizeof|sizeof
argument_list|(
name|nfd
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nfd
index|[
sizeof|sizeof
argument_list|(
name|nfd
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Get an NFC patterns. 		 */
name|scan_unicode_pattern
argument_list|(
name|utf8_nfc
argument_list|,
name|wc_nfc
argument_list|,
name|utf16be_nfc
argument_list|,
name|utf16le_nfc
argument_list|,
name|nfc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Get an NFD patterns. 		 */
name|scan_unicode_pattern
argument_list|(
name|utf8_nfd
argument_list|,
name|wc_nfd
argument_list|,
name|utf16be_nfd
argument_list|,
name|utf16le_nfd
argument_list|,
name|nfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|locale_is_utf8
condition|)
block|{
comment|/* 			 * Normalize an NFD string for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_strcpy_l
argument_list|(
operator|&
name|utf8
argument_list|,
name|utf8_nfd
argument_list|,
name|f_sconv8
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"NFD(%s) should be converted to NFC(%s):%d"
argument_list|,
name|nfd
argument_list|,
name|nfc
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfc
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* 			 * Normalize an NFC string for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_strcpy_l
argument_list|(
operator|&
name|utf8
argument_list|,
name|utf8_nfc
argument_list|,
name|f_sconv8
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"NFC(%s) should not be any changed:%d"
argument_list|,
name|nfc
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfc
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* 			 * Copy an NFC string for export. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_strcpy_l
argument_list|(
operator|&
name|utf8
argument_list|,
name|utf8_nfc
argument_list|,
name|t_sconv8
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"NFC(%s) should not be any changed:%d"
argument_list|,
name|nfc
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfc
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* 			 * Normalize an NFD string in UTF-16BE for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_strncpy_l
argument_list|(
operator|&
name|utf8
argument_list|,
name|utf16be_nfd
argument_list|,
literal|100000
argument_list|,
name|f_sconv16be
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"NFD(%s) should be converted to NFC(%s):%d"
argument_list|,
name|nfd
argument_list|,
name|nfc
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfc
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* 			 * Normalize an NFD string in UTF-16LE for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_strncpy_l
argument_list|(
operator|&
name|utf8
argument_list|,
name|utf16le_nfd
argument_list|,
literal|100000
argument_list|,
name|f_sconv16le
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"NFD(%s) should be converted to NFC(%s):%d"
argument_list|,
name|nfd
argument_list|,
name|nfc
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfc
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Test for archive_mstring interface. 		 * In specific, Windows platform UTF-16BE is directly 		 * converted to/from wide-character to avoid the effect of 		 * current locale since windows platform cannot make 		 * locale UTF-8. 		 */
if|if
condition|(
name|locale_is_utf8
operator|||
name|wc_is_unicode
condition|)
block|{
comment|/* 			 * Normalize an NFD string in UTF-8 for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_copy_mbs_len_l
argument_list|(
operator|&
name|mstr
argument_list|,
name|utf8_nfd
argument_list|,
literal|100000
argument_list|,
name|f_sconv8
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_get_wcs
argument_list|(
name|a
argument_list|,
operator|&
name|mstr
argument_list|,
operator|&
name|wp
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"UTF-8 NFD(%s) should be converted "
literal|"to WCS NFC(%s):%d"
argument_list|,
name|nfd
argument_list|,
name|nfc
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualWString
argument_list|(
name|wc_nfc
argument_list|,
name|wp
argument_list|)
expr_stmt|;
comment|/* 			 * Normalize an NFD string in UTF-16BE for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_copy_mbs_len_l
argument_list|(
operator|&
name|mstr
argument_list|,
name|utf16be_nfd
argument_list|,
literal|100000
argument_list|,
name|f_sconv16be
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_get_wcs
argument_list|(
name|a
argument_list|,
operator|&
name|mstr
argument_list|,
operator|&
name|wp
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"UTF-8 NFD(%s) should be converted "
literal|"to WCS NFC(%s):%d"
argument_list|,
name|nfd
argument_list|,
name|nfc
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualWString
argument_list|(
name|wc_nfc
argument_list|,
name|wp
argument_list|)
expr_stmt|;
comment|/* 			 * Normalize an NFD string in UTF-16LE for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_copy_mbs_len_l
argument_list|(
operator|&
name|mstr
argument_list|,
name|utf16le_nfd
argument_list|,
literal|100000
argument_list|,
name|f_sconv16le
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_get_wcs
argument_list|(
name|a
argument_list|,
operator|&
name|mstr
argument_list|,
operator|&
name|wp
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"UTF-8 NFD(%s) should be converted "
literal|"to WCS NFC(%s):%d"
argument_list|,
name|nfd
argument_list|,
name|nfc
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualWString
argument_list|(
name|wc_nfc
argument_list|,
name|wp
argument_list|)
expr_stmt|;
comment|/* 			 * Copy an NFC wide-string for export. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_copy_wcs
argument_list|(
operator|&
name|mstr
argument_list|,
name|wc_nfc
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_get_mbs_l
argument_list|(
operator|&
name|mstr
argument_list|,
operator|&
name|mp
argument_list|,
operator|&
name|mplen
argument_list|,
name|t_sconv8
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"WCS NFC(%s) should be UTF-8 NFC:%d"
argument_list|,
name|nfc
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfc
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
name|archive_string_free
argument_list|(
operator|&
name|utf8
argument_list|)
expr_stmt|;
name|archive_mstring_clean
argument_list|(
operator|&
name|mstr
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_read_free
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_write_free
argument_list|(
name|a2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_archive_string_normalization_mac_nfd
parameter_list|(
specifier|const
name|char
modifier|*
name|testdata
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
name|struct
name|archive_string
name|utf8
decl_stmt|;
name|struct
name|archive_mstring
name|mstr
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|f_sconv8
decl_stmt|,
modifier|*
name|t_sconv8
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|f_sconv16be
decl_stmt|,
modifier|*
name|f_sconv16le
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buff
index|[
literal|512
index|]
decl_stmt|;
name|int
name|line
init|=
literal|0
decl_stmt|;
name|int
name|locale_is_utf8
decl_stmt|,
name|wc_is_unicode
decl_stmt|;
name|int
name|sconv_opt
init|=
name|SCONV_SET_OPT_NORMALIZATION_D
decl_stmt|;
name|locale_is_utf8
operator|=
operator|(
name|NULL
operator|!=
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|"en_US.UTF-8"
argument_list|)
operator|)
expr_stmt|;
name|wc_is_unicode
operator|=
name|is_wc_unicode
argument_list|()
expr_stmt|;
comment|/* If it doesn't exist, just warn and return. */
if|if
condition|(
operator|!
name|locale_is_utf8
operator|&&
operator|!
name|wc_is_unicode
condition|)
block|{
name|skipping
argument_list|(
literal|"A test of string normalization for NFD requires "
literal|"a suitable locale; en_US.UTF-8 not available on this "
literal|"system"
argument_list|)
expr_stmt|;
return|return;
block|}
name|archive_string_init
argument_list|(
operator|&
name|utf8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mstr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mstr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create string conversion objects. 	 */
name|assert
argument_list|(
operator|(
name|a
operator|=
name|archive_read_new
argument_list|()
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|f_sconv8
operator|=
name|archive_string_conversion_from_charset
argument_list|(
name|a
argument_list|,
literal|"UTF-8"
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|f_sconv16be
operator|=
name|archive_string_conversion_from_charset
argument_list|(
name|a
argument_list|,
literal|"UTF-16BE"
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|f_sconv16le
operator|=
name|archive_string_conversion_from_charset
argument_list|(
name|a
argument_list|,
literal|"UTF-16LE"
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|a2
operator|=
name|archive_write_new
argument_list|()
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|t_sconv8
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a2
argument_list|,
literal|"UTF-8"
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sconv8
operator|==
name|NULL
operator|||
name|f_sconv16be
operator|==
name|NULL
operator|||
name|f_sconv16le
operator|==
name|NULL
operator|||
name|t_sconv8
operator|==
name|NULL
condition|)
block|{
comment|/* We cannot continue this test. */
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_read_free
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|archive_string_conversion_set_opt
argument_list|(
name|f_sconv8
argument_list|,
name|sconv_opt
argument_list|)
expr_stmt|;
name|archive_string_conversion_set_opt
argument_list|(
name|f_sconv16be
argument_list|,
name|sconv_opt
argument_list|)
expr_stmt|;
name|archive_string_conversion_set_opt
argument_list|(
name|f_sconv16le
argument_list|,
name|sconv_opt
argument_list|)
expr_stmt|;
name|archive_string_conversion_set_opt
argument_list|(
name|t_sconv8
argument_list|,
name|sconv_opt
argument_list|)
expr_stmt|;
comment|/* Open a test pattern file. */
name|assert
argument_list|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|testdata
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Read test data. 	 *  Test data format: 	 *<NFC Unicode pattern> ';'<NFD Unicode pattern> '\n' 	 *  Unicode pattern format: 	 *     [0-9A-F]{4,5}([ ][0-9A-F]{4,5}){0,} 	 */
while|while
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|nfc
index|[
literal|80
index|]
decl_stmt|,
name|nfd
index|[
literal|80
index|]
decl_stmt|;
name|char
name|utf8_nfc
index|[
literal|80
index|]
decl_stmt|,
name|utf8_nfd
index|[
literal|80
index|]
decl_stmt|;
name|char
name|utf16be_nfc
index|[
literal|80
index|]
decl_stmt|,
name|utf16be_nfd
index|[
literal|80
index|]
decl_stmt|;
name|char
name|utf16le_nfc
index|[
literal|80
index|]
decl_stmt|,
name|utf16le_nfd
index|[
literal|80
index|]
decl_stmt|;
name|wchar_t
name|wc_nfc
index|[
literal|40
index|]
decl_stmt|,
name|wc_nfd
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
specifier|const
name|char
modifier|*
name|mp
decl_stmt|;
name|size_t
name|mplen
decl_stmt|;
name|int
name|should_be_nfc
decl_stmt|;
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Copy an NFC pattern */
name|strncpy
argument_list|(
name|nfc
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|nfc
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nfc
index|[
sizeof|sizeof
argument_list|(
name|nfc
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|e
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Copy an NFD pattern */
name|strncpy
argument_list|(
name|nfd
argument_list|,
name|e
argument_list|,
sizeof|sizeof
argument_list|(
name|nfd
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nfd
index|[
sizeof|sizeof
argument_list|(
name|nfd
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Get an NFC patterns. 		 */
name|should_be_nfc
operator|=
name|scan_unicode_pattern
argument_list|(
name|utf8_nfc
argument_list|,
name|wc_nfc
argument_list|,
name|utf16be_nfc
argument_list|,
name|utf16le_nfc
argument_list|,
name|nfc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Get an NFD patterns. 		 */
name|scan_unicode_pattern
argument_list|(
name|utf8_nfd
argument_list|,
name|wc_nfd
argument_list|,
name|utf16be_nfd
argument_list|,
name|utf16le_nfd
argument_list|,
name|nfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|locale_is_utf8
condition|)
block|{
comment|/* 			 * Normalize an NFC string for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_strcpy_l
argument_list|(
operator|&
name|utf8
argument_list|,
name|utf8_nfc
argument_list|,
name|f_sconv8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_be_nfc
condition|)
block|{
name|failure
argument_list|(
literal|"NFC(%s) should not be converted to"
literal|" NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfc
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|failure
argument_list|(
literal|"NFC(%s) should be converted to"
literal|" NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfd
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Normalize an NFD string for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_strcpy_l
argument_list|(
operator|&
name|utf8
argument_list|,
name|utf8_nfd
argument_list|,
name|f_sconv8
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"NFD(%s) should not be any changed:%d"
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfd
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* 			 * Copy an NFD string for export. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_strcpy_l
argument_list|(
operator|&
name|utf8
argument_list|,
name|utf8_nfd
argument_list|,
name|t_sconv8
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"NFD(%s) should not be any changed:%d"
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfd
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* 			 * Normalize an NFC string in UTF-16BE for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_strncpy_l
argument_list|(
operator|&
name|utf8
argument_list|,
name|utf16be_nfc
argument_list|,
literal|100000
argument_list|,
name|f_sconv16be
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_be_nfc
condition|)
block|{
name|failure
argument_list|(
literal|"NFC(%s) should not be converted to"
literal|" NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfc
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|failure
argument_list|(
literal|"NFC(%s) should be converted to"
literal|" NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfd
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Normalize an NFC string in UTF-16LE for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_strncpy_l
argument_list|(
operator|&
name|utf8
argument_list|,
name|utf16le_nfc
argument_list|,
literal|100000
argument_list|,
name|f_sconv16le
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_be_nfc
condition|)
block|{
name|failure
argument_list|(
literal|"NFC(%s) should not be converted to"
literal|" NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfc
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|failure
argument_list|(
literal|"NFC(%s) should be converted to"
literal|" NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfd
argument_list|,
name|utf8
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Test for archive_mstring interface. 		 * In specific, Windows platform UTF-16BE is directly 		 * converted to/from wide-character to avoid the effect of 		 * current locale since windows platform cannot make 		 * locale UTF-8. 		 */
if|if
condition|(
name|locale_is_utf8
operator|||
name|wc_is_unicode
condition|)
block|{
comment|/* 			 * Normalize an NFD string in UTF-8 for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_copy_mbs_len_l
argument_list|(
operator|&
name|mstr
argument_list|,
name|utf8_nfc
argument_list|,
literal|100000
argument_list|,
name|f_sconv8
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_get_wcs
argument_list|(
name|a
argument_list|,
operator|&
name|mstr
argument_list|,
operator|&
name|wp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_be_nfc
condition|)
block|{
name|failure
argument_list|(
literal|"UTF-8 NFC(%s) should not be converted "
literal|"to WCS NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualWString
argument_list|(
name|wc_nfc
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|failure
argument_list|(
literal|"UTF-8 NFC(%s) should be converted "
literal|"to WCS NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualWString
argument_list|(
name|wc_nfd
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Normalize an NFD string in UTF-16BE for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_copy_mbs_len_l
argument_list|(
operator|&
name|mstr
argument_list|,
name|utf16be_nfc
argument_list|,
literal|100000
argument_list|,
name|f_sconv16be
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_get_wcs
argument_list|(
name|a
argument_list|,
operator|&
name|mstr
argument_list|,
operator|&
name|wp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_be_nfc
condition|)
block|{
name|failure
argument_list|(
literal|"UTF-16BE NFC(%s) should not be "
literal|"converted to WCS NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualWString
argument_list|(
name|wc_nfc
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|failure
argument_list|(
literal|"UTF-16BE NFC(%s) should be converted "
literal|"to WCS NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualWString
argument_list|(
name|wc_nfd
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Normalize an NFD string in UTF-16LE for import. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_copy_mbs_len_l
argument_list|(
operator|&
name|mstr
argument_list|,
name|utf16le_nfc
argument_list|,
literal|100000
argument_list|,
name|f_sconv16le
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_get_wcs
argument_list|(
name|a
argument_list|,
operator|&
name|mstr
argument_list|,
operator|&
name|wp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_be_nfc
condition|)
block|{
name|failure
argument_list|(
literal|"UTF-16LE NFC(%s) should not be "
literal|"converted to WCS NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualWString
argument_list|(
name|wc_nfc
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|failure
argument_list|(
literal|"UTF-16LE NFC(%s) should be converted "
literal|"to WCS NFD(%s):%d"
argument_list|,
name|nfc
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualWString
argument_list|(
name|wc_nfd
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Copy an NFD wide-string for export. 			 */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_copy_wcs
argument_list|(
operator|&
name|mstr
argument_list|,
name|wc_nfd
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|archive_mstring_get_mbs_l
argument_list|(
operator|&
name|mstr
argument_list|,
operator|&
name|mp
argument_list|,
operator|&
name|mplen
argument_list|,
name|t_sconv8
argument_list|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"WCS NFD(%s) should be UTF-8 NFD:%d"
argument_list|,
name|nfd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|assertEqualUTF8String
argument_list|(
name|utf8_nfd
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
name|archive_string_free
argument_list|(
operator|&
name|utf8
argument_list|)
expr_stmt|;
name|archive_mstring_clean
argument_list|(
operator|&
name|mstr
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_read_free
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_write_free
argument_list|(
name|a2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_archive_string_canonicalization
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive_string_conv
modifier|*
name|sconv
decl_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|"en_US.UTF-8"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|a
operator|=
name|archive_read_new
argument_list|()
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|sconv
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a
argument_list|,
literal|"UTF-8"
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Charset name should be UTF-8"
argument_list|)
expr_stmt|;
name|assertEqualString
argument_list|(
literal|"UTF-8"
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|sconv
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a
argument_list|,
literal|"UTF8"
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Charset name should be UTF-8"
argument_list|)
expr_stmt|;
name|assertEqualString
argument_list|(
literal|"UTF-8"
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|sconv
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a
argument_list|,
literal|"utf8"
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Charset name should be UTF-8"
argument_list|)
expr_stmt|;
name|assertEqualString
argument_list|(
literal|"UTF-8"
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|sconv
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a
argument_list|,
literal|"UTF-16BE"
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Charset name should be UTF-16BE"
argument_list|)
expr_stmt|;
name|assertEqualString
argument_list|(
literal|"UTF-16BE"
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|sconv
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a
argument_list|,
literal|"UTF16BE"
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Charset name should be UTF-16BE"
argument_list|)
expr_stmt|;
name|assertEqualString
argument_list|(
literal|"UTF-16BE"
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|sconv
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a
argument_list|,
literal|"utf16be"
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Charset name should be UTF-16BE"
argument_list|)
expr_stmt|;
name|assertEqualString
argument_list|(
literal|"UTF-16BE"
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|sconv
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a
argument_list|,
literal|"UTF-16LE"
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Charset name should be UTF-16LE"
argument_list|)
expr_stmt|;
name|assertEqualString
argument_list|(
literal|"UTF-16LE"
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|sconv
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a
argument_list|,
literal|"UTF16LE"
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Charset name should be UTF-16LE"
argument_list|)
expr_stmt|;
name|assertEqualString
argument_list|(
literal|"UTF-16LE"
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|assertA
argument_list|(
name|NULL
operator|!=
operator|(
name|sconv
operator|=
name|archive_string_conversion_to_charset
argument_list|(
name|a
argument_list|,
literal|"utf16le"
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Charset name should be UTF-16LE"
argument_list|)
expr_stmt|;
name|assertEqualString
argument_list|(
literal|"UTF-16LE"
argument_list|,
name|archive_string_conversion_charset_name
argument_list|(
name|sconv
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_read_free
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|DEFINE_TEST
argument_list|(
argument|test_archive_string_conversion
argument_list|)
end_macro

begin_block
block|{
specifier|static
specifier|const
name|char
name|reffile
index|[]
init|=
literal|"test_archive_string_conversion.txt.Z"
decl_stmt|;
specifier|static
specifier|const
name|char
name|testdata
index|[]
init|=
literal|"testdata.txt"
decl_stmt|;
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|ae
decl_stmt|;
name|char
name|buff
index|[
literal|512
index|]
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* 	 * Extract a test pattern file. 	 */
name|extract_reference_file
argument_list|(
name|reffile
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|a
operator|=
name|archive_read_new
argument_list|()
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assertEqualIntA
argument_list|(
name|a
argument_list|,
name|ARCHIVE_OK
argument_list|,
name|archive_read_support_filter_all
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualIntA
argument_list|(
name|a
argument_list|,
name|ARCHIVE_OK
argument_list|,
name|archive_read_support_format_raw
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualIntA
argument_list|(
name|a
argument_list|,
name|ARCHIVE_OK
argument_list|,
name|archive_read_open_filename
argument_list|(
name|a
argument_list|,
name|reffile
argument_list|,
literal|512
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualIntA
argument_list|(
name|a
argument_list|,
name|ARCHIVE_OK
argument_list|,
name|archive_read_next_header
argument_list|(
name|a
argument_list|,
operator|&
name|ae
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|testdata
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|size
operator|=
name|archive_read_data
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
literal|512
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|ARCHIVE_OK
argument_list|,
name|archive_read_free
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|test_archive_string_normalization_nfc
argument_list|(
name|testdata
argument_list|)
expr_stmt|;
name|test_archive_string_normalization_mac_nfd
argument_list|(
name|testdata
argument_list|)
expr_stmt|;
name|test_archive_string_canonicalization
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

