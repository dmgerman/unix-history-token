begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xxHash - Fast Hash algorithm Copyright (C) 2012-2014, Yann Collet. BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  You can contact the author at : - xxHash source repository : http://code.google.com/p/xxhash/ */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"archive_xxhash.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBLZ4
end_ifdef

begin_comment
comment|/*************************************** ** Tuning parameters ****************************************/
end_comment

begin_comment
comment|/* Unaligned memory access is automatically enabled for "common" CPU, such as x86. ** For others CPU, the compiler will be more cautious, and insert extra code to ensure aligned access is respected. ** If you know your target CPU supports unaligned memory access, you want to force this option manually to improve performance. ** You can also enable this parameter if you know your input data will always be aligned (boundaries of 4, for U32). */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__ARM_FEATURE_UNALIGNED
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
end_if

begin_define
define|#
directive|define
name|XXH_USE_UNALIGNED_ACCESS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXH_ACCEPT_NULL_INPUT_POINTER : ** If the input pointer is a null pointer, xxHash default behavior is to trigger a memory access error, since it is a bad pointer. ** When this option is enabled, xxHash output for null input pointers will be the same as a null-length input. ** This option has a very small performance cost (only measurable on small inputs). ** By default, this option is disabled. To enable it, uncomment below define : ** #define XXH_ACCEPT_NULL_INPUT_POINTER 1  ** XXH_FORCE_NATIVE_FORMAT : ** By default, xxHash library provides endian-independent Hash values, based on little-endian convention. ** Results are therefore identical for little-endian and big-endian CPU. ** This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format. ** Should endian-independence be of no importance for your application, you may set the #define below to 1. ** It will improve speed for Big-endian CPU. ** This option has no impact on Little_Endian CPU. */
end_comment

begin_define
define|#
directive|define
name|XXH_FORCE_NATIVE_FORMAT
value|0
end_define

begin_comment
comment|/*************************************** ** Compiler Specific Options ****************************************/
end_comment

begin_comment
comment|/* Disable some Visual warning messages */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual Studio */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual Studio */
end_comment

begin_define
define|#
directive|define
name|FORCE_INLINE
value|__forceinline
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|FORCE_INLINE
value|inline __attribute__((always_inline))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*************************************** ** Includes& Memory related functions ****************************************/
end_comment

begin_define
define|#
directive|define
name|XXH_malloc
value|malloc
end_define

begin_define
define|#
directive|define
name|XXH_free
value|free
end_define

begin_define
define|#
directive|define
name|XXH_memcpy
value|memcpy
end_define

begin_function_decl
specifier|static
name|unsigned
name|int
name|XXH32
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|XXH32_init
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|XXH_errorcode
name|XXH32_update
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|XXH32_digest
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*static int		  XXH32_sizeofState(void);*/
end_comment

begin_function_decl
specifier|static
name|XXH_errorcode
name|XXH32_resetState
parameter_list|(
name|void
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|XXH32_SIZEOFSTATE
value|48
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|long
name|long
name|ll
index|[
operator|(
name|XXH32_SIZEOFSTATE
operator|+
operator|(
expr|sizeof
operator|(
name|long
name|long
operator|)
operator|-
literal|1
block|)
typedef|)/sizeof(
name|long
name|long
typedef|)];
end_typedef

begin_empty_stmt
unit|} XXH32_stateSpace_t
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|unsigned
name|int
name|XXH32_intermediateDigest
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*************************************** ** Basic Types ****************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_comment
comment|/* C99 */
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_typedef
typedef|typedef
name|uint8_t
name|BYTE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint16_t
name|U16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint32_t
name|U32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int32_t
name|S32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
name|U64
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|unsigned
name|char
name|BYTE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|U16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|U32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|signed
name|int
name|S32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|U64
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|XXH_USE_UNALIGNED_ACCESS
argument_list|)
end_if

begin_define
define|#
directive|define
name|_PACKED
value|__attribute__ ((packed))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_PACKED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|XXH_USE_UNALIGNED_ACCESS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__IBMC__
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|pack
name|(
name|1
name|)
end_pragma

begin_else
else|#
directive|else
end_else

begin_pragma
pragma|#
directive|pragma
name|pack
name|(
name|push
name|,
name|1
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|_U32_S
block|{
name|U32
name|v
decl_stmt|;
block|}
name|_PACKED
name|U32_S
typedef|;
end_typedef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|XXH_USE_UNALIGNED_ACCESS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|pack
name|(
name|pop
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|A32
parameter_list|(
name|x
parameter_list|)
value|(((const U32_S *)(x))->v)
end_define

begin_comment
comment|/**************************************** ** Compiler-specific Functions and Macros *****************************************/
end_comment

begin_define
define|#
directive|define
name|GCC_VERSION
value|(__GNUC__ * 100 + __GNUC_MINOR__)
end_define

begin_comment
comment|/* Note : although _rotl exists for minGW (GCC under windows), performance seems poor */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_define
define|#
directive|define
name|XXH_rotl32
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|_rotl(x,r)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XXH_rotl32
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|((x<< r) | (x>> (32 - r)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_comment
comment|/* Visual Studio */
end_comment

begin_define
define|#
directive|define
name|XXH_swap32
value|_byteswap_ulong
end_define

begin_elif
elif|#
directive|elif
name|GCC_VERSION
operator|>=
literal|403
end_elif

begin_define
define|#
directive|define
name|XXH_swap32
value|__builtin_bswap32
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
specifier|inline
name|U32
name|XXH_swap32
parameter_list|(
name|U32
name|x
parameter_list|)
block|{
return|return
operator|(
operator|(
name|x
operator|<<
literal|24
operator|)
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
name|x
operator|<<
literal|8
operator|)
operator|&
literal|0x00ff0000
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|24
operator|)
operator|&
literal|0x000000ff
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*************************************** ** Constants ****************************************/
end_comment

begin_define
define|#
directive|define
name|PRIME32_1
value|2654435761U
end_define

begin_define
define|#
directive|define
name|PRIME32_2
value|2246822519U
end_define

begin_define
define|#
directive|define
name|PRIME32_3
value|3266489917U
end_define

begin_define
define|#
directive|define
name|PRIME32_4
value|668265263U
end_define

begin_define
define|#
directive|define
name|PRIME32_5
value|374761393U
end_define

begin_comment
comment|/*************************************** ** Architecture Macros ****************************************/
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|XXH_bigEndian
init|=
literal|0
block|,
name|XXH_littleEndian
init|=
literal|1
block|}
name|XXH_endianess
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|XXH_CPU_LITTLE_ENDIAN
end_ifndef

begin_comment
comment|/* It is possible to define XXH_CPU_LITTLE_ENDIAN externally, for example using a compiler switch */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|one
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|XXH_CPU_LITTLE_ENDIAN
value|(*(const char*)(&one))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*************************************** ** Macros ****************************************/
end_comment

begin_define
define|#
directive|define
name|XXH_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { XXH_static_assert = 1/(!!(c)) }; }
end_define

begin_comment
comment|/* use only *after* variable declarations */
end_comment

begin_comment
comment|/***************************** ** Memory reads ******************************/
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|XXH_aligned
block|,
name|XXH_unaligned
block|}
name|XXH_alignment
typedef|;
end_typedef

begin_function
specifier|static
name|FORCE_INLINE
name|U32
name|XXH_readLE32_align
parameter_list|(
specifier|const
name|U32
modifier|*
name|ptr
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|,
name|XXH_alignment
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|==
name|XXH_unaligned
condition|)
return|return
name|endian
operator|==
name|XXH_littleEndian
condition|?
name|A32
argument_list|(
name|ptr
argument_list|)
else|:
name|XXH_swap32
argument_list|(
name|A32
argument_list|(
name|ptr
argument_list|)
argument_list|)
return|;
else|else
return|return
name|endian
operator|==
name|XXH_littleEndian
condition|?
operator|*
name|ptr
else|:
name|XXH_swap32
argument_list|(
operator|*
name|ptr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|FORCE_INLINE
name|U32
name|XXH_readLE32
parameter_list|(
specifier|const
name|U32
modifier|*
name|ptr
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
return|return
name|XXH_readLE32_align
argument_list|(
name|ptr
argument_list|,
name|endian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************** ** Simple Hash Functions ******************************/
end_comment

begin_function
specifier|static
name|FORCE_INLINE
name|U32
name|XXH32_endian_align
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|U32
name|seed
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|,
name|XXH_alignment
name|align
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|bEnd
init|=
name|p
operator|+
name|len
decl_stmt|;
name|U32
name|h32
decl_stmt|;
define|#
directive|define
name|XXH_get32bits
parameter_list|(
name|p
parameter_list|)
value|XXH_readLE32_align((const U32*)p, endian, align)
ifdef|#
directive|ifdef
name|XXH_ACCEPT_NULL_INPUT_POINTER
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|bEnd
operator|=
name|p
operator|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|size_t
operator|)
literal|16
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|len
operator|>=
literal|16
condition|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|limit
init|=
name|bEnd
operator|-
literal|16
decl_stmt|;
name|U32
name|v1
init|=
name|seed
operator|+
name|PRIME32_1
operator|+
name|PRIME32_2
decl_stmt|;
name|U32
name|v2
init|=
name|seed
operator|+
name|PRIME32_2
decl_stmt|;
name|U32
name|v3
init|=
name|seed
operator|+
literal|0
decl_stmt|;
name|U32
name|v4
init|=
name|seed
operator|-
name|PRIME32_1
decl_stmt|;
do|do
block|{
name|v1
operator|+=
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v1
operator|=
name|XXH_rotl32
argument_list|(
name|v1
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v1
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v2
operator|+=
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v2
operator|=
name|XXH_rotl32
argument_list|(
name|v2
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v2
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v3
operator|+=
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v3
operator|=
name|XXH_rotl32
argument_list|(
name|v3
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v3
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v4
operator|+=
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v4
operator|=
name|XXH_rotl32
argument_list|(
name|v4
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v4
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<=
name|limit
condition|)
do|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|v1
argument_list|,
literal|1
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|v2
argument_list|,
literal|7
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|v3
argument_list|,
literal|12
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|v4
argument_list|,
literal|18
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h32
operator|=
name|seed
operator|+
name|PRIME32_5
expr_stmt|;
block|}
name|h32
operator|+=
operator|(
name|U32
operator|)
name|len
expr_stmt|;
while|while
condition|(
name|p
operator|<=
name|bEnd
operator|-
literal|4
condition|)
block|{
name|h32
operator|+=
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME32_3
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|17
argument_list|)
operator|*
name|PRIME32_4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|h32
operator|+=
operator|(
operator|*
name|p
operator|)
operator|*
name|PRIME32_5
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|11
argument_list|)
operator|*
name|PRIME32_1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|h32
operator|^=
name|h32
operator|>>
literal|15
expr_stmt|;
name|h32
operator|*=
name|PRIME32_2
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|13
expr_stmt|;
name|h32
operator|*=
name|PRIME32_3
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|16
expr_stmt|;
return|return
name|h32
return|;
block|}
end_function

begin_function
name|U32
name|XXH32
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|U32
name|seed
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|// Simple version, good for code maintenance, but unfortunately slow for small inputs
block|void* state = XXH32_init(seed);     XXH32_update(state, input, len);     return XXH32_digest(state);
else|#
directive|else
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|XXH_USE_UNALIGNED_ACCESS
argument_list|)
if|if
condition|(
operator|(
operator|(
operator|(
name|size_t
operator|)
name|input
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
comment|/* Input is aligned, let's leverage the speed advantage */
block|{
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_littleEndian
argument_list|,
name|XXH_aligned
argument_list|)
return|;
else|else
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_bigEndian
argument_list|,
name|XXH_aligned
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_littleEndian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
else|else
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_bigEndian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/***************************** ** Advanced Hash Functions ******************************/
end_comment

begin_struct
struct|struct
name|XXH_state32_t
block|{
name|U64
name|total_len
decl_stmt|;
name|U32
name|seed
decl_stmt|;
name|U32
name|v1
decl_stmt|;
name|U32
name|v2
decl_stmt|;
name|U32
name|v3
decl_stmt|;
name|U32
name|v4
decl_stmt|;
name|int
name|memsize
decl_stmt|;
name|char
name|memory
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int XXH32_sizeofState(void) {     XXH_STATIC_ASSERT(XXH32_SIZEOFSTATE>= sizeof(struct XXH_state32_t));
comment|/* A compilation error here means XXH32_SIZEOFSTATE is not large enough */
end_comment

begin_endif
unit|return sizeof(struct XXH_state32_t); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|XXH_errorcode
name|XXH32_resetState
parameter_list|(
name|void
modifier|*
name|state_in
parameter_list|,
name|U32
name|seed
parameter_list|)
block|{
name|struct
name|XXH_state32_t
modifier|*
name|state
init|=
operator|(
expr|struct
name|XXH_state32_t
operator|*
operator|)
name|state_in
decl_stmt|;
name|state
operator|->
name|seed
operator|=
name|seed
expr_stmt|;
name|state
operator|->
name|v1
operator|=
name|seed
operator|+
name|PRIME32_1
operator|+
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|seed
operator|+
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|seed
operator|+
literal|0
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|seed
operator|-
name|PRIME32_1
expr_stmt|;
name|state
operator|->
name|total_len
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
literal|0
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|XXH32_init
parameter_list|(
name|U32
name|seed
parameter_list|)
block|{
name|void
modifier|*
name|state
init|=
name|XXH_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|XXH_state32_t
argument_list|)
argument_list|)
decl_stmt|;
name|XXH32_resetState
argument_list|(
name|state
argument_list|,
name|seed
argument_list|)
expr_stmt|;
return|return
name|state
return|;
block|}
end_function

begin_function
specifier|static
name|FORCE_INLINE
name|XXH_errorcode
name|XXH32_update_endian
parameter_list|(
name|void
modifier|*
name|state_in
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|int
name|len
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
name|struct
name|XXH_state32_t
modifier|*
name|state
init|=
operator|(
expr|struct
name|XXH_state32_t
operator|*
operator|)
name|state_in
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|bEnd
init|=
name|p
operator|+
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|XXH_ACCEPT_NULL_INPUT_POINTER
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
return|return
name|XXH_ERROR
return|;
endif|#
directive|endif
name|state
operator|->
name|total_len
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|memsize
operator|+
name|len
operator|<
literal|16
condition|)
comment|/* fill in tmp buffer */
block|{
name|XXH_memcpy
argument_list|(
name|state
operator|->
name|memory
operator|+
name|state
operator|->
name|memsize
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|state
operator|->
name|memsize
operator|+=
name|len
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
if|if
condition|(
name|state
operator|->
name|memsize
condition|)
comment|/* some data left from previous update */
block|{
name|XXH_memcpy
argument_list|(
name|state
operator|->
name|memory
operator|+
name|state
operator|->
name|memsize
argument_list|,
name|input
argument_list|,
literal|16
operator|-
name|state
operator|->
name|memsize
argument_list|)
expr_stmt|;
block|{
specifier|const
name|U32
modifier|*
name|p32
init|=
operator|(
specifier|const
name|U32
operator|*
operator|)
name|state
operator|->
name|memory
decl_stmt|;
name|state
operator|->
name|v1
operator|+=
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v1
operator|=
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v1
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|state
operator|->
name|v1
operator|*=
name|PRIME32_1
expr_stmt|;
name|p32
operator|++
expr_stmt|;
name|state
operator|->
name|v2
operator|+=
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v2
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|state
operator|->
name|v2
operator|*=
name|PRIME32_1
expr_stmt|;
name|p32
operator|++
expr_stmt|;
name|state
operator|->
name|v3
operator|+=
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v3
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|state
operator|->
name|v3
operator|*=
name|PRIME32_1
expr_stmt|;
name|p32
operator|++
expr_stmt|;
name|state
operator|->
name|v4
operator|+=
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v4
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|state
operator|->
name|v4
operator|*=
name|PRIME32_1
expr_stmt|;
name|p32
operator|++
expr_stmt|;
block|}
name|p
operator|+=
literal|16
operator|-
name|state
operator|->
name|memsize
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<=
name|bEnd
operator|-
literal|16
condition|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|limit
init|=
name|bEnd
operator|-
literal|16
decl_stmt|;
name|U32
name|v1
init|=
name|state
operator|->
name|v1
decl_stmt|;
name|U32
name|v2
init|=
name|state
operator|->
name|v2
decl_stmt|;
name|U32
name|v3
init|=
name|state
operator|->
name|v3
decl_stmt|;
name|U32
name|v4
init|=
name|state
operator|->
name|v4
decl_stmt|;
do|do
block|{
name|v1
operator|+=
name|XXH_readLE32
argument_list|(
operator|(
specifier|const
name|U32
operator|*
operator|)
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v1
operator|=
name|XXH_rotl32
argument_list|(
name|v1
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v1
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v2
operator|+=
name|XXH_readLE32
argument_list|(
operator|(
specifier|const
name|U32
operator|*
operator|)
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v2
operator|=
name|XXH_rotl32
argument_list|(
name|v2
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v2
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v3
operator|+=
name|XXH_readLE32
argument_list|(
operator|(
specifier|const
name|U32
operator|*
operator|)
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v3
operator|=
name|XXH_rotl32
argument_list|(
name|v3
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v3
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v4
operator|+=
name|XXH_readLE32
argument_list|(
operator|(
specifier|const
name|U32
operator|*
operator|)
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v4
operator|=
name|XXH_rotl32
argument_list|(
name|v4
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v4
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<=
name|limit
condition|)
do|;
name|state
operator|->
name|v1
operator|=
name|v1
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|v2
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|v3
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|v4
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|XXH_memcpy
argument_list|(
name|state
operator|->
name|memory
argument_list|,
name|p
argument_list|,
name|bEnd
operator|-
name|p
argument_list|)
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
call|(
name|int
call|)
argument_list|(
name|bEnd
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|XXH_OK
return|;
block|}
end_function

begin_function
specifier|static
name|XXH_errorcode
name|XXH32_update
parameter_list|(
name|void
modifier|*
name|state_in
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_update_endian
argument_list|(
name|state_in
argument_list|,
name|input
argument_list|,
name|len
argument_list|,
name|XXH_littleEndian
argument_list|)
return|;
else|else
return|return
name|XXH32_update_endian
argument_list|(
name|state_in
argument_list|,
name|input
argument_list|,
name|len
argument_list|,
name|XXH_bigEndian
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|FORCE_INLINE
name|U32
name|XXH32_intermediateDigest_endian
parameter_list|(
name|void
modifier|*
name|state_in
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
name|struct
name|XXH_state32_t
modifier|*
name|state
init|=
operator|(
expr|struct
name|XXH_state32_t
operator|*
operator|)
name|state_in
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|state
operator|->
name|memory
decl_stmt|;
name|BYTE
modifier|*
name|bEnd
init|=
operator|(
name|BYTE
operator|*
operator|)
name|state
operator|->
name|memory
operator|+
name|state
operator|->
name|memsize
decl_stmt|;
name|U32
name|h32
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|total_len
operator|>=
literal|16
condition|)
block|{
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v1
argument_list|,
literal|1
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v2
argument_list|,
literal|7
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v3
argument_list|,
literal|12
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v4
argument_list|,
literal|18
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h32
operator|=
name|state
operator|->
name|seed
operator|+
name|PRIME32_5
expr_stmt|;
block|}
name|h32
operator|+=
operator|(
name|U32
operator|)
name|state
operator|->
name|total_len
expr_stmt|;
while|while
condition|(
name|p
operator|<=
name|bEnd
operator|-
literal|4
condition|)
block|{
name|h32
operator|+=
name|XXH_readLE32
argument_list|(
operator|(
specifier|const
name|U32
operator|*
operator|)
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_3
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|17
argument_list|)
operator|*
name|PRIME32_4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|h32
operator|+=
operator|(
operator|*
name|p
operator|)
operator|*
name|PRIME32_5
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|11
argument_list|)
operator|*
name|PRIME32_1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|h32
operator|^=
name|h32
operator|>>
literal|15
expr_stmt|;
name|h32
operator|*=
name|PRIME32_2
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|13
expr_stmt|;
name|h32
operator|*=
name|PRIME32_3
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|16
expr_stmt|;
return|return
name|h32
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|XXH32_intermediateDigest
parameter_list|(
name|void
modifier|*
name|state_in
parameter_list|)
block|{
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_intermediateDigest_endian
argument_list|(
name|state_in
argument_list|,
name|XXH_littleEndian
argument_list|)
return|;
else|else
return|return
name|XXH32_intermediateDigest_endian
argument_list|(
name|state_in
argument_list|,
name|XXH_bigEndian
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|XXH32_digest
parameter_list|(
name|void
modifier|*
name|state_in
parameter_list|)
block|{
name|U32
name|h32
init|=
name|XXH32_intermediateDigest
argument_list|(
name|state_in
argument_list|)
decl_stmt|;
name|XXH_free
argument_list|(
name|state_in
argument_list|)
expr_stmt|;
return|return
name|h32
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|archive_xxhash
name|__archive_xxhash
init|=
block|{
name|XXH32
block|,
name|XXH32_init
block|,
name|XXH32_update
block|,
name|XXH32_digest
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Define an empty version of the struct if we aren't using the LZ4 library.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|archive_xxhash
name|__archive_xxhash
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIBLZ4 */
end_comment

end_unit

