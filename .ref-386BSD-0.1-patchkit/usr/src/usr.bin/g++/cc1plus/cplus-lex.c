begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cplus-lex.c	6.4 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Separate lexical analyzer for GNU C++.    Copyright (C) 1987 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@mcc.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file is the lexical analyzer for GNU C++.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|_IOFBF
value|2
end_define

begin_comment
comment|/* Missing from GNU's stdio.h */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cplus-tab.h"
end_include

begin_include
include|#
directive|include
file|"cplus-parse.h"
end_include

begin_include
include|#
directive|include
file|"cplus-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* needed for VAX.  */
end_comment

begin_decl_stmt
specifier|extern
name|jmp_buf
name|toplevel
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|NULL_FILE
value|"nla0:"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NULL_FILE
value|"/dev/null"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|double
name|atof
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* If you don't have strrchr, but instead have rindex,    add your machine to this list, and send mail to    tiemann@wheaties.ai.mit.edu.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sequent
argument_list|)
operator|||
name|defined
argument_list|(
name|convex
argument_list|)
end_if

begin_define
define|#
directive|define
name|strrchr
value|rindex
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|strrchr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* This obstack is needed to hold text.  It is not safe to use    TOKEN_BUFFER because `check_newline' calls `yylex'.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|inline_text_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inline_text_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds translations from TREE_CODEs to operator name strings,    i.e., opname_tab[PLUS_EXPR] == "+".  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|opname_tab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|assignop_tab
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|YYEMPTY
value|-1
end_define

begin_decl_stmt
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the lookahead symbol		*/
end_comment

begin_decl_stmt
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the semantic value of the		*/
end_comment

begin_comment
comment|/*  lookahead symbol			*/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|YYLTYPE yylloc;
comment|/*  location data for the lookahead	*/
end_comment

begin_comment
comment|/*  symbol				*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|end_of_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the declaration found for the last IDENTIFIER token read in.    yylex must look this up to detect typedefs, which get token type TYPENAME,    so it is left around in case the identifier is not a typedef but is    used in a context which makes it a reference to a variable.  */
end_comment

begin_decl_stmt
name|tree
name|lastiddecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++ extensions */
end_comment

begin_decl_stmt
name|tree
name|ridpointers
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need this up here */
end_comment

begin_comment
comment|/* We may keep statistics about how long which files took to compile.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|header_time
decl_stmt|,
name|body_time
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|get_time_identifier
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|tree
name|filename_times
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|this_filename_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For implementing #pragma unit.  */
end_comment

begin_decl_stmt
name|tree
name|current_unit_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|current_unit_language
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array for holding counts of the numbers of tokens seen.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|token_count
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return something to represent absolute declarators containing a *.    TARGET is the absolute declarator that the * contains.    TYPE_QUALS is a list of modifiers such as const or volatile    to apply to the pointer type, represented as identifiers.     We return an INDIRECT_REF whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_pointer_declarator
parameter_list|(
name|type_quals
parameter_list|,
name|target
parameter_list|)
name|tree
name|type_quals
decl_stmt|,
name|target
decl_stmt|;
block|{
if|if
condition|(
name|target
operator|&&
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|target
argument_list|)
condition|)
name|error
argument_list|(
literal|"type name expected before `*'"
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type_quals
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return something to represent absolute declarators containing a&.    TARGET is the absolute declarator that the& contains.    TYPE_QUALS is a list of modifiers such as const or volatile    to apply to the reference type, represented as identifiers.     We return an ADDR_EXPR whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_reference_declarator
parameter_list|(
name|type_quals
parameter_list|,
name|target
parameter_list|)
name|tree
name|type_quals
decl_stmt|,
name|target
decl_stmt|;
block|{
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare references to references"
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|error
argument_list|(
literal|"cannot declare pointers to references"
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|target
argument_list|)
condition|)
name|error
argument_list|(
literal|"type name expected before `&'"
argument_list|)
expr_stmt|;
block|}
return|return
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type_quals
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a chain of STRING_CST nodes,    concatenate them into one STRING_CST    and give it a suitable array-of-chars data type.  */
end_comment

begin_function
name|tree
name|combine_strings
parameter_list|(
name|strings
parameter_list|)
name|tree
name|strings
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|int
name|length
init|=
literal|1
decl_stmt|;
name|int
name|wide_length
init|=
literal|0
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|strings
argument_list|)
condition|)
block|{
comment|/* More than one in the chain, so concatenate.  */
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Don't include the \0 at the end of each substring, 	 except for the last one. 	 Count wide strings and ordinary strings separately.  */
for|for
control|(
name|t
operator|=
name|strings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|int_array_type_node
condition|)
block|{
name|wide_length
operator|+=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|wide_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|length
operator|+=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* If anything is wide, the non-wides will be converted, 	 which makes them take more space.  */
if|if
condition|(
name|wide_flag
condition|)
name|length
operator|=
name|length
operator|*
name|UNITS_PER_WORD
operator|+
name|wide_length
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|savealloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|/* Copy the individual strings into the new combined string. 	 If the combined string is wide, convert the chars to ints 	 for any individual strings that are not wide.  */
name|q
operator|=
name|p
expr_stmt|;
for|for
control|(
name|t
operator|=
name|strings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|int
name|len
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|int_array_type_node
operator|)
operator|==
name|wide_flag
condition|)
block|{
name|bcopy
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
argument_list|,
name|q
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|q
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|int
operator|*
operator|)
name|q
operator|)
index|[
name|i
index|]
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|q
operator|+=
name|len
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|make_node
argument_list|(
name|STRING_CST
argument_list|)
expr_stmt|;
name|TREE_STRING_POINTER
argument_list|(
name|value
argument_list|)
operator|=
name|p
expr_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
operator|=
name|length
expr_stmt|;
name|TREE_LITERAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|strings
expr_stmt|;
name|length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|int_array_type_node
condition|)
name|wide_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Create the array type for the string constant.      -Wwrite-strings says make the string constant an array of const char      so that copying it to a non-const pointer will get a warning.  */
if|if
condition|(
name|warn_write_strings
condition|)
block|{
name|tree
name|elements
init|=
name|build_type_variant
argument_list|(
name|wide_flag
condition|?
name|integer_type_node
else|:
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|elements
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|length
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|wide_flag
condition|?
name|integer_type_node
else|:
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|length
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_LITERAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build names and nodes for overloaded operators.  */
end_comment

begin_comment
comment|/* Memoized table for operator names.  */
end_comment

begin_decl_stmt
name|tree
modifier|*
name|node_table
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|build_opid
parameter_list|(
name|code1
parameter_list|,
name|code2
parameter_list|)
name|enum
name|tree_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|make_node
argument_list|(
name|OP_IDENTIFIER
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tmp
decl_stmt|;
specifier|extern
name|struct
name|obstack
modifier|*
name|expression_obstack
decl_stmt|,
name|permanent_obstack
decl_stmt|;
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|expression_obstack
decl_stmt|;
name|expression_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
if|if
condition|(
name|code1
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tmp
operator|=
name|node_table
index|[
operator|(
name|int
operator|)
name|code1
index|]
operator|)
operator|==
literal|0
condition|)
name|node_table
index|[
operator|(
name|int
operator|)
name|code1
index|]
operator|=
name|tmp
operator|=
name|make_node
argument_list|(
name|code1
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tmp
operator|=
name|node_table
index|[
operator|(
name|int
operator|)
name|code2
index|]
operator|)
operator|==
literal|0
condition|)
name|node_table
index|[
operator|(
name|int
operator|)
name|code2
index|]
operator|=
name|tmp
operator|=
name|make_node
argument_list|(
name|code2
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|expression_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LEN
parameter_list|)
value|sizeof (NAME),
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LEN
parameter_list|)
value|-1,
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|short
name|opname_end
index|[]
init|=
block|{
include|#
directive|include
file|"tree.def"
literal|7
block|,
comment|/* sizeof ("@@dummy"), */
include|#
directive|include
file|"cplus-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Given a TOKEN and its estimated tree code CODE, produce a name which    can be recognized by lookup_name.  Based on the number of PARMS,    build an appropriate operator fnname.  This function is needed because    until we know how many parameters we have, we cannot reliably tell    what function indeed we are trying to declare.     NPARMS is the number of additional parameters that this operator    will ultimately have.  If NPARMS == -1, then we are just building    a name, and should not complain.     This would be a good candidate for memoizing.  */
end_comment

begin_function
name|tree
name|build_operator_fnname
parameter_list|(
name|declp
parameter_list|,
name|parms
parameter_list|,
name|nparms
parameter_list|)
name|tree
modifier|*
name|declp
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|nparms
decl_stmt|;
block|{
name|tree
name|decl
init|=
operator|*
name|declp
decl_stmt|;
name|char
modifier|*
modifier|*
name|opname_table
decl_stmt|,
modifier|*
name|opname
decl_stmt|;
name|int
name|assignop_p
init|=
literal|0
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|saw_class
init|=
name|nparms
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|parms
condition|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|parms
operator|==
name|void_list_node
condition|)
break|break;
if|if
condition|(
operator|!
name|saw_class
condition|)
block|{
name|type
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|saw_class
operator|=
literal|1
expr_stmt|;
block|}
name|nparms
operator|++
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_EXPR
condition|)
block|{
comment|/* @@ may need to perform type instantiation here.  */
if|if
condition|(
name|nparms
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"wrong number of arguments to type conversion operator"
argument_list|)
expr_stmt|;
comment|/* The grammar will swallow an "()" if one was given. 	 We attempt to correct for this lossage here.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|rval
operator|=
name|build_typename_overload
argument_list|(
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|yychar
operator|=
name|LEFT_RIGHT
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
name|build_typename_overload
argument_list|(
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|opname_table
operator|=
name|assignop_tab
expr_stmt|;
name|assignop_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
else|else
name|opname_table
operator|=
name|opname_tab
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|opname
operator|=
name|opname_table
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
if|if
condition|(
name|assignop_p
condition|)
block|{
if|if
condition|(
name|nparms
operator|==
literal|1
operator|||
name|nparms
operator|>
literal|2
condition|)
name|error
argument_list|(
literal|"wrong number of parameters op `operator %s'"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|rval
operator|=
name|get_identifier
argument_list|(
literal|"<invalid operator>"
argument_list|)
expr_stmt|;
name|TREE_OVERLOADED
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
comment|/* AC/DC */
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|nparms
operator|==
literal|1
condition|)
name|code
operator|=
name|CONVERT_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|nparms
operator|!=
literal|2
condition|)
name|erred
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
name|nparms
operator|==
literal|1
condition|)
name|code
operator|=
name|ADDR_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|nparms
operator|==
literal|2
condition|)
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
else|else
block|{
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
name|erred
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|MULT_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
if|if
condition|(
name|nparms
operator|==
literal|1
condition|)
name|code
operator|=
name|INDIRECT_REF
expr_stmt|;
elseif|else
if|if
condition|(
name|nparms
operator|==
literal|2
condition|)
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
else|else
block|{
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
name|erred
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|MINUS_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
name|nparms
operator|==
literal|1
condition|)
name|code
operator|=
name|NEGATE_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|nparms
operator|==
literal|2
condition|)
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
else|else
block|{
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
name|erred
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|POINTSAT
case|:
if|if
condition|(
name|nparms
operator|==
literal|1
operator|||
name|nparms
operator|<
literal|0
condition|)
name|code
operator|=
name|COMPONENT_REF
expr_stmt|;
else|else
block|{
name|erred
operator|=
operator|-
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"wrong number of parameters to `operator ->()'"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|METHOD_CALL_EXPR
case|:
switch|switch
condition|(
name|nparms
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|erred
operator|=
operator|-
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"too few arguments to `operator ->()(...)'"
argument_list|)
expr_stmt|;
break|break;
comment|/* 4 happens when we pass in the canonical number 	     of arguments.  */
case|case
literal|4
case|:
name|nparms
operator|=
literal|3
expr_stmt|;
case|case
operator|-
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
break|break;
default|default:
name|erred
operator|=
operator|-
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"too many arguments to `operator ->()(...)'"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* The two following entrys are for two different ways of 	 encoding `operator ='.  */
case|case
name|NOP_EXPR
case|:
if|if
condition|(
name|nparms
operator|!=
literal|2
operator|&&
name|nparms
operator|>=
literal|0
condition|)
name|erred
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|nparms
operator|!=
literal|2
operator|&&
name|nparms
operator|>=
literal|0
condition|)
name|erred
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NEW_EXPR
case|:
if|if
condition|(
name|saw_class
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nparms
operator|>
literal|1
condition|)
return|return
name|get_identifier
argument_list|(
name|OPERATOR_NEW_FORMAT
argument_list|)
return|;
return|return
name|get_identifier
argument_list|(
literal|"__builtin_new"
argument_list|)
return|;
block|}
break|break;
case|case
name|DELETE_EXPR
case|:
if|if
condition|(
name|saw_class
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nparms
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"too many parameters to `operator ::delete'"
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
literal|"__builtin_delete"
argument_list|)
return|;
block|}
if|if
condition|(
name|nparms
operator|>
literal|2
condition|)
name|erred
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Whatever it was, we know its arity.  Just check that it          has the right number of parameters defined.  */
default|default:
comment|/* These are the only operators which do not need 	 to have a class-type associated with them.  */
if|if
condition|(
name|code
operator|==
name|PREDECREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|code
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
name|nparms
operator|>
literal|1
condition|)
name|erred
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nparms
operator|<
literal|0
operator|||
name|code
operator|==
name|CALL_EXPR
operator|||
name|code
operator|==
name|METHOD_CALL_EXPR
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|nparms
operator|!=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
condition|)
name|erred
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|erred
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"wrong number of parameters to `operator %s'"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|erred
operator|==
literal|0
operator|&&
name|code
operator|!=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|assign_code
init|=
name|ERROR_MARK
decl_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
condition|)
name|assign_code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_opid
argument_list|(
name|assign_code
argument_list|,
name|code
argument_list|)
expr_stmt|;
operator|*
name|declp
operator|=
name|decl
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|saw_class
condition|)
name|error
argument_list|(
literal|"`operator %s' must have at least one class type"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
if|if
condition|(
name|assignop_p
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
name|OPERATOR_ASSIGN_FORMAT
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|code
index|]
argument_list|)
expr_stmt|;
name|buf
index|[
name|opname_end
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|+
sizeof|sizeof
argument_list|(
name|OPERATOR_ASSIGN_FORMAT
argument_list|)
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
name|OPERATOR_FORMAT
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|code
index|]
argument_list|)
expr_stmt|;
name|buf
index|[
name|opname_end
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|+
sizeof|sizeof
argument_list|(
name|OPERATOR_FORMAT
argument_list|)
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|rval
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|TREE_OVERLOADED
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|operator_name_string
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|opname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|OPERATOR_FORMAT
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
literal|"%s"
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|assign
decl_stmt|;
comment|/* Works for builtin and user defined types.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|opname
argument_list|,
literal|"assign"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|opname
operator|+=
literal|7
expr_stmt|;
name|assign
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|assign
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LAST_CPLUS_TREE_CODE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|opname
argument_list|,
name|tree_code_name
index|[
name|i
index|]
argument_list|,
name|opname_end
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
block|}
name|assert
argument_list|(
name|i
operator|!=
name|LAST_CPLUS_TREE_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|assign
condition|)
return|return
name|assignop_tab
index|[
name|i
index|]
return|;
else|else
return|return
name|opname_tab
index|[
name|i
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line number in file being read */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|finput
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file. 				   Normally a pipe from the preprocessor.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|finput1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Real input files: 1 is main input file */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|finput2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2 is input file for inline functions */
end_comment

begin_decl_stmt
name|int
name|interface_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not current file is only for 				   interface definitions.  */
end_comment

begin_decl_stmt
name|int
name|interface_unknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not we know this class 				   to behave according to #pragma interface.  */
end_comment

begin_comment
comment|/* lexical analyzer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxtoken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current nominal length of token buffer.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|token_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to token buffer. 				   Actual allocated length is maxtoken + 2.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_wide
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current nominal length of wide_buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|wide_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to wide-string buffer. 				   Actual allocated length is max_wide + 1.  */
end_comment

begin_define
define|#
directive|define
name|NORID
value|RID_UNUSED
end_define

begin_comment
comment|/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$ gplus.gperf  */
end_comment

begin_struct
struct|struct
name|resword
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|short
name|token
decl_stmt|;
name|enum
name|rid
name|rid
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MIN_WORD_LENGTH
value|2
end_define

begin_define
define|#
directive|define
name|MAX_WORD_LENGTH
value|13
end_define

begin_define
define|#
directive|define
name|MIN_HASH_VALUE
value|4
end_define

begin_define
define|#
directive|define
name|MAX_HASH_VALUE
value|147
end_define

begin_comment
comment|/*    71 keywords   144 is the maximum key range */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
specifier|inline
endif|#
directive|endif
specifier|static
name|int
name|hash
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
name|unsigned
name|len
decl_stmt|;
block|{
specifier|static
name|unsigned
name|char
name|hash_table
index|[]
init|=
block|{
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|0
block|,
literal|147
block|,
literal|19
block|,
literal|6
block|,
literal|27
block|,
literal|37
block|,
literal|0
block|,
literal|12
block|,
literal|1
block|,
literal|15
block|,
literal|63
block|,
literal|147
block|,
literal|4
block|,
literal|0
block|,
literal|56
block|,
literal|20
block|,
literal|15
block|,
literal|42
block|,
literal|147
block|,
literal|31
block|,
literal|5
block|,
literal|26
block|,
literal|39
block|,
literal|32
block|,
literal|10
block|,
literal|147
block|,
literal|40
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,
literal|147
block|,     }
decl_stmt|;
specifier|register
name|int
name|hval
init|=
name|len
decl_stmt|;
switch|switch
condition|(
name|hval
condition|)
block|{
default|default:
case|case
literal|4
case|:
name|hval
operator|+=
name|hash_table
index|[
name|str
index|[
literal|3
index|]
index|]
expr_stmt|;
case|case
literal|3
case|:
case|case
literal|2
case|:
case|case
literal|1
case|:
name|hval
operator|+=
name|hash_table
index|[
name|str
index|[
literal|0
index|]
index|]
expr_stmt|;
block|}
return|return
name|hval
operator|+
name|hash_table
index|[
name|str
index|[
name|len
operator|-
literal|1
index|]
index|]
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
specifier|inline
endif|#
directive|endif
name|struct
name|resword
modifier|*
name|is_reserved_word
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|unsigned
name|int
name|len
decl_stmt|;
block|{
specifier|static
name|struct
name|resword
name|wordlist
index|[]
init|=
block|{
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"else"
block|,
name|ELSE
block|,
name|NORID
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"long"
block|,
name|TYPESPEC
block|,
name|RID_LONG
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"__alignof__"
block|,
name|ALIGNOF
block|,
name|NORID
block|}
block|,
block|{
literal|"__asm__"
block|,
name|ASM
block|,
name|NORID
block|}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"while"
block|,
name|WHILE
block|,
name|NORID
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"__alignof"
block|,
name|ALIGNOF
block|,
name|NORID
block|}
block|,
block|{
literal|"all"
block|,
name|ALL
block|,
name|NORID
comment|/* Extension */
block|,}
block|,
block|{
literal|"sizeof"
block|,
name|SIZEOF
block|,
name|NORID
block|,}
block|,
block|{
literal|"__const__"
block|,
name|TYPE_QUAL
block|,
name|RID_CONST
block|}
block|,
block|{
literal|"__volatile"
block|,
name|TYPE_QUAL
block|,
name|RID_VOLATILE
block|}
block|,
block|{
literal|"extern"
block|,
name|SCSPEC
block|,
name|RID_EXTERN
block|,}
block|,
block|{
literal|"__volatile__"
block|,
name|TYPE_QUAL
block|,
name|RID_VOLATILE
block|}
block|,
block|{
literal|"__inline"
block|,
name|SCSPEC
block|,
name|RID_INLINE
block|}
block|,
block|{
literal|"exception"
block|,
name|AGGR
block|,
name|RID_EXCEPTION
comment|/* Extension */
block|,}
block|,
block|{
literal|"__inline__"
block|,
name|SCSPEC
block|,
name|RID_INLINE
block|}
block|,
block|{
literal|"case"
block|,
name|CASE
block|,
name|NORID
block|,}
block|,
block|{
literal|"except"
block|,
name|EXCEPT
block|,
name|NORID
comment|/* Extension */
block|,}
block|,
block|{
literal|"new"
block|,
name|NEW
block|,
name|NORID
block|,}
block|,
block|{
literal|"break"
block|,
name|BREAK
block|,
name|NORID
block|,}
block|,
block|{
literal|"goto"
block|,
name|GOTO
block|,
name|NORID
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"__attribute"
block|,
name|ATTRIBUTE
block|,
name|NORID
block|}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"__attribute__"
block|,
name|ATTRIBUTE
block|,
name|NORID
block|}
block|,
block|{
literal|"this"
block|,
name|THIS
block|,
name|NORID
block|,}
block|,
block|{
literal|"raise"
block|,
name|RAISE
block|,
name|NORID
comment|/* Extension */
block|,}
block|,
block|{
literal|"class"
block|,
name|AGGR
block|,
name|RID_CLASS
block|,}
block|,
block|{
literal|"delete"
block|,
name|DELETE
block|,
name|NORID
block|,}
block|,
block|{
literal|"typeof"
block|,
name|TYPEOF
block|,
name|NORID
block|,}
block|,
block|{
literal|"typedef"
block|,
name|SCSPEC
block|,
name|RID_TYPEDEF
block|,}
block|,
block|{
literal|"for"
block|,
name|FOR
block|,
name|NORID
block|,}
block|,
block|{
literal|"raises"
block|,
name|RAISES
block|,
name|NORID
comment|/* Extension */
block|,}
block|,
block|{
literal|"__const"
block|,
name|TYPE_QUAL
block|,
name|RID_CONST
block|}
block|,
block|{
literal|"double"
block|,
name|TYPESPEC
block|,
name|RID_DOUBLE
block|,}
block|,
block|{
literal|"__typeof__"
block|,
name|TYPEOF
block|,
name|NORID
block|}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"switch"
block|,
name|SWITCH
block|,
name|NORID
block|,}
block|,
block|{
literal|"auto"
block|,
name|SCSPEC
block|,
name|RID_AUTO
block|,}
block|,
block|{
literal|"do"
block|,
name|DO
block|,
name|NORID
block|,}
block|,
block|{
literal|"friend"
block|,
name|SCSPEC
block|,
name|RID_FRIEND
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"reraise"
block|,
name|RERAISE
block|,
name|NORID
comment|/* Extension */
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"volatile"
block|,
name|TYPE_QUAL
block|,
name|RID_VOLATILE
block|,}
block|,
block|{
literal|"__typeof"
block|,
name|TYPEOF
block|,
name|NORID
block|}
block|,
block|{
literal|"continue"
block|,
name|CONTINUE
block|,
name|NORID
block|,}
block|,
block|{
literal|"float"
block|,
name|TYPESPEC
block|,
name|RID_FLOAT
block|,}
block|,
block|{
literal|"const"
block|,
name|TYPE_QUAL
block|,
name|RID_CONST
block|,}
block|,
block|{
literal|"static"
block|,
name|SCSPEC
block|,
name|RID_STATIC
block|,}
block|,
block|{
literal|"virtual"
block|,
name|SCSPEC
block|,
name|RID_VIRTUAL
block|,}
block|,
block|{
literal|"__asm"
block|,
name|ASM
block|,
name|NORID
block|}
block|,
block|{
literal|"short"
block|,
name|TYPESPEC
block|,
name|RID_SHORT
block|,}
block|,
block|{
literal|"signed"
block|,
name|TYPESPEC
block|,
name|RID_SIGNED
block|,}
block|,
block|{
literal|"try"
block|,
name|TRY
block|,
name|NORID
comment|/* Extension */
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"__signed__"
block|,
name|TYPESPEC
block|,
name|RID_SIGNED
block|}
block|,
block|{
literal|"catch"
block|,
name|CATCH
block|,
name|NORID
block|,}
block|,
block|{
literal|"public"
block|,
name|PUBLIC
block|,
name|NORID
block|,}
block|,
block|{
literal|"struct"
block|,
name|AGGR
block|,
name|RID_RECORD
block|,}
block|,
block|{
literal|"if"
block|,
name|IF
block|,
name|NORID
block|,}
block|,
block|{
literal|"asm"
block|,
name|ASM
block|,
name|NORID
block|,}
block|,
block|{
literal|"union"
block|,
name|AGGR
block|,
name|RID_UNION
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"private"
block|,
name|PRIVATE
block|,
name|NORID
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"operator"
block|,
name|OPERATOR
block|,
name|NORID
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"default"
block|,
name|DEFAULT
block|,
name|NORID
block|,}
block|,
block|{
literal|"dynamic"
block|,
name|DYNAMIC
block|,
name|NORID
block|,}
block|,
block|{
literal|"overload"
block|,
name|OVERLOAD
block|,
name|NORID
block|,}
block|,
block|{
literal|"int"
block|,
name|TYPESPEC
block|,
name|RID_INT
block|,}
block|,
block|{
literal|"char"
block|,
name|TYPESPEC
block|,
name|RID_CHAR
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"return"
block|,
name|RETURN
block|,
name|NORID
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"__signed"
block|,
name|TYPESPEC
block|,
name|RID_SIGNED
block|}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"void"
block|,
name|TYPESPEC
block|,
name|RID_VOID
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"protected"
block|,
name|PROTECTED
block|,
name|NORID
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"enum"
block|,
name|ENUM
block|,
name|NORID
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"inline"
block|,
name|SCSPEC
block|,
name|RID_INLINE
block|,}
block|,
block|{
literal|"register"
block|,
name|SCSPEC
block|,
name|RID_REGISTER
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|""
block|,}
block|,
block|{
literal|"unsigned"
block|,
name|TYPESPEC
block|,
name|RID_UNSIGNED
block|,}
block|,     }
decl_stmt|;
if|if
condition|(
name|len
operator|<=
name|MAX_WORD_LENGTH
operator|&&
name|len
operator|>=
name|MIN_WORD_LENGTH
condition|)
block|{
specifier|register
name|int
name|key
init|=
name|hash
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|<=
name|MAX_HASH_VALUE
operator|&&
name|key
operator|>=
name|MIN_HASH_VALUE
condition|)
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|wordlist
index|[
name|key
index|]
operator|.
name|name
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|str
operator|&&
operator|!
name|strcmp
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|s
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|&
name|wordlist
index|[
name|key
index|]
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The elements of `ridpointers' are identifier nodes    for the reserved type names and storage classes.    It is indexed by a RID_... value.  */
end_comment

begin_decl_stmt
name|tree
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|check_newline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_white_space
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|tree
name|get_time_identifier
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|time_identifier
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|6
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"file "
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|buf
operator|+
literal|5
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
operator|+
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
name|time_identifier
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|time_identifier
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|int
name|temp
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
if|if
condition|(
name|temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|time_identifier
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|time_identifier
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|time_identifier
argument_list|)
operator|=
name|filename_times
expr_stmt|;
name|filename_times
operator|=
name|time_identifier
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
return|return
name|time_identifier
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
name|__inline
endif|#
directive|endif
specifier|static
name|int
name|my_gettime
parameter_list|()
block|{
name|int
name|old_quiet_flag
init|=
name|quiet_flag
decl_stmt|;
name|int
name|this_time
decl_stmt|;
name|quiet_flag
operator|=
literal|0
expr_stmt|;
name|this_time
operator|=
name|gettime
argument_list|()
expr_stmt|;
name|quiet_flag
operator|=
name|old_quiet_flag
expr_stmt|;
return|return
name|this_time
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table indexed by tree code giving a string containing a character    classifying the tree code.  Possibilities are    t, d, s, c, r and e.  See cplus-tree.def for details.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|TYPE,
end_define

begin_decl_stmt
name|char
modifier|*
name|cplus_tree_code_type
index|[]
init|=
block|{
literal|"x"
block|,
include|#
directive|include
file|"cplus-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Table indexed by tree code giving number of expression    operands beyond the fixed part of the node structure.    Not used for types or decls.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|LENGTH,
end_define

begin_decl_stmt
name|int
name|cplus_tree_code_length
index|[]
init|=
block|{
literal|0
block|,
include|#
directive|include
file|"cplus-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Names of tree components.    Used for printing out the tree and error messages.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LEN
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
name|char
modifier|*
name|cplus_tree_code_name
index|[]
init|=
block|{
literal|"@@dummy"
block|,
include|#
directive|include
file|"cplus-tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_escape
end_escape

begin_function
name|void
name|init_filename_times
parameter_list|()
block|{
name|this_filename_time
operator|=
name|get_time_identifier
argument_list|(
literal|"<top level>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|header_time
operator|=
literal|0
expr_stmt|;
name|body_time
operator|=
name|my_gettime
argument_list|()
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|this_filename_time
argument_list|)
argument_list|)
operator|=
name|body_time
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Use 4.4 BSD fropen() stdio function to fake re-reads of inline functions.    We just decrement the buffer count until it reaches zero.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|next_inline_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|read_next_inline
parameter_list|(
name|unused_cookie
parameter_list|,
name|unused_buf
parameter_list|,
name|count
parameter_list|)
name|void
modifier|*
name|unused_cookie
decl_stmt|;
name|char
modifier|*
name|unused_buf
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
block|{
name|count
operator|=
name|count
operator|>
name|next_inline_count
condition|?
name|next_inline_count
else|:
name|count
expr_stmt|;
name|next_inline_count
operator|-=
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Change by Bryan Boreham, Kewill, Thu Jul 27 09:46:05 1989.    Stuck this hack in to get the files open correctly; this is called    in place of init_lex if we are an unexec'd binary.    */
end_comment

begin_function
name|void
name|reinit_lex_for_unexec
parameter_list|()
block|{
name|finput1
operator|=
name|finput
expr_stmt|;
name|finput2
operator|=
name|fropen
argument_list|(
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|read_next_inline
argument_list|)
expr_stmt|;
name|init_filename_times
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_lex
parameter_list|()
block|{
specifier|extern
name|int
modifier|*
name|init_parse
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
function_decl|(
modifier|*
name|decl_printable_name
function_decl|)
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|lang_printable_name
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|rtx_def
modifier|*
argument_list|(
operator|*
name|lang_expand_expr
argument_list|)
argument_list|()
decl_stmt|;
specifier|extern
name|struct
name|rtx_def
modifier|*
name|cplus_expand_expr
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
comment|/* Make identifier nodes long enough for the language-specific slots.  */
name|set_identifier_size
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_identifier
argument_list|)
argument_list|)
expr_stmt|;
name|decl_printable_name
operator|=
name|lang_printable_name
expr_stmt|;
name|lang_expand_expr
operator|=
name|cplus_expand_expr
expr_stmt|;
name|tree_code_type
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|tree_code_type
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|LAST_CPLUS_TREE_CODE
argument_list|)
expr_stmt|;
name|tree_code_length
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|tree_code_length
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|LAST_CPLUS_TREE_CODE
argument_list|)
expr_stmt|;
name|tree_code_name
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|tree_code_name
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|LAST_CPLUS_TREE_CODE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cplus_tree_code_type
argument_list|,
name|tree_code_type
operator|+
name|LAST_AND_UNUSED_TREE_CODE
argument_list|,
operator|(
name|LAST_CPLUS_TREE_CODE
operator|-
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cplus_tree_code_length
argument_list|,
name|tree_code_length
operator|+
name|LAST_AND_UNUSED_TREE_CODE
argument_list|,
operator|(
name|LAST_CPLUS_TREE_CODE
operator|-
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cplus_tree_code_name
argument_list|,
name|tree_code_name
operator|+
name|LAST_AND_UNUSED_TREE_CODE
argument_list|,
operator|(
name|LAST_CPLUS_TREE_CODE
operator|-
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|node_table
operator|=
operator|(
name|tree
operator|*
operator|)
name|oballoc
argument_list|(
name|LAST_CPLUS_TREE_CODE
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|opname_tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|oballoc
argument_list|(
name|LAST_CPLUS_TREE_CODE
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|assignop_tab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|oballoc
argument_list|(
name|LAST_CPLUS_TREE_CODE
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LAST_CPLUS_TREE_CODE
condition|;
name|i
operator|++
control|)
comment|/* Our only interest is _ref and _expr.  */
if|if
condition|(
name|tree_code_type
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'r'
operator|||
name|tree_code_type
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
block|{
name|char
modifier|*
name|end
init|=
operator|(
name|char
operator|*
operator|)
name|strrchr
argument_list|(
name|tree_code_name
index|[
name|i
index|]
argument_list|,
literal|'_'
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
condition|)
name|opname_end
index|[
name|i
index|]
operator|=
name|end
operator|-
name|tree_code_name
index|[
name|i
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|__GNUC__
else|else
name|opname_end
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|tree_code_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|__GNUC__
else|else
name|opname_end
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|tree_code_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_method
argument_list|()
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|inline_text_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Start it at 0, because check_newline is called at the very beginning      and will increment it to 1.  */
name|lineno
operator|=
literal|0
expr_stmt|;
name|finput1
operator|=
name|finput
expr_stmt|;
name|finput2
operator|=
name|fropen
argument_list|(
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|read_next_inline
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
name|maxtoken
operator|=
literal|40
expr_stmt|;
name|token_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|maxtoken
operator|+
literal|2
argument_list|)
expr_stmt|;
name|max_wide
operator|=
literal|40
expr_stmt|;
name|wide_buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_wide
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"char"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
operator|=
name|get_identifier
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"float"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"double"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SHORT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"short"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SHORT
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SHORT
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
operator|=
name|get_identifier
argument_list|(
literal|"long"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"unsigned"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"signed"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"inline"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
operator|=
name|get_identifier
argument_list|(
literal|"const"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"volatile"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
operator|=
name|get_identifier
argument_list|(
literal|"auto"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
operator|=
name|get_identifier
argument_list|(
literal|"static"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
operator|=
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"typedef"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
operator|=
name|get_identifier
argument_list|(
literal|"register"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* C++ extensions. These are probably not correctly named. */
name|class_type_node
operator|=
name|build_int_2
argument_list|(
name|class_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|class_type_node
argument_list|)
operator|=
name|class_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CLASS
index|]
operator|=
name|class_type_node
expr_stmt|;
name|record_type_node
operator|=
name|build_int_2
argument_list|(
name|record_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|record_type_node
argument_list|)
operator|=
name|record_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_RECORD
index|]
operator|=
name|record_type_node
expr_stmt|;
name|union_type_node
operator|=
name|build_int_2
argument_list|(
name|union_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|union_type_node
argument_list|)
operator|=
name|union_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNION
index|]
operator|=
name|union_type_node
expr_stmt|;
name|enum_type_node
operator|=
name|build_int_2
argument_list|(
name|enum_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|enum_type_node
argument_list|)
operator|=
name|enum_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ENUM
index|]
operator|=
name|enum_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
operator|=
name|get_identifier
argument_list|(
literal|"virtual"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
operator|=
name|get_identifier
argument_list|(
literal|"friend"
argument_list|)
expr_stmt|;
name|SET_IDENTIFIER_AS_LIST
argument_list|(
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Exception handling extensions.  */
name|exception_type_node
operator|=
name|build_int_2
argument_list|(
name|exception_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|exception_type_node
argument_list|)
operator|=
name|exception_type_node
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXCEPTION
index|]
operator|=
name|exception_type_node
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|COMPONENT_REF
index|]
operator|=
literal|"->"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|METHOD_CALL_EXPR
index|]
operator|=
literal|"->()"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|INDIRECT_REF
index|]
operator|=
literal|"(unary *)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ARRAY_REF
index|]
operator|=
literal|"[]"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MODIFY_EXPR
index|]
operator|=
literal|"="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|NEW_EXPR
index|]
operator|=
literal|"new"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|DELETE_EXPR
index|]
operator|=
literal|"delete"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|COND_EXPR
index|]
operator|=
literal|"... ? ... : ..."
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CALL_EXPR
index|]
operator|=
literal|"()"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
operator|=
literal|"+"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
operator|=
literal|"-"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
operator|=
literal|"*"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_DIV_EXPR
index|]
operator|=
literal|"/"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|=
literal|"(ceiling /)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|=
literal|"(floor /)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|=
literal|"(round /)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
operator|=
literal|"%"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|=
literal|"(ceiling %)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|=
literal|"(floor %)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|=
literal|"(round %)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|NEGATE_EXPR
index|]
operator|=
literal|"-"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MIN_EXPR
index|]
operator|=
literal|"<?"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|MAX_EXPR
index|]
operator|=
literal|">?"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ABS_EXPR
index|]
operator|=
literal|"abs"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|FFS_EXPR
index|]
operator|=
literal|"ffs"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
operator|=
literal|"<<"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
operator|=
literal|">>"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
operator|=
literal|"|"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
operator|=
literal|"^"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
operator|=
literal|"&"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_ANDTC_EXPR
index|]
operator|=
literal|"&~"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|BIT_NOT_EXPR
index|]
operator|=
literal|"~"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_ANDIF_EXPR
index|]
operator|=
literal|"&&"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_ORIF_EXPR
index|]
operator|=
literal|"||"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_AND_EXPR
index|]
operator|=
literal|"strict&&"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_OR_EXPR
index|]
operator|=
literal|"strict ||"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TRUTH_NOT_EXPR
index|]
operator|=
literal|"!"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|LT_EXPR
index|]
operator|=
literal|"<"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|LE_EXPR
index|]
operator|=
literal|"<="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|GT_EXPR
index|]
operator|=
literal|">"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|GE_EXPR
index|]
operator|=
literal|">="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|EQ_EXPR
index|]
operator|=
literal|"=="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|NE_EXPR
index|]
operator|=
literal|"!="
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|IN_EXPR
index|]
operator|=
literal|"in"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|SET_LE_EXPR
index|]
operator|=
literal|"subset"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CARD_EXPR
index|]
operator|=
literal|"#"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|RANGE_EXPR
index|]
operator|=
literal|".."
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|CONVERT_EXPR
index|]
operator|=
literal|"(unary +)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|ADDR_EXPR
index|]
operator|=
literal|"(unary&)"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|PREDECREMENT_EXPR
index|]
operator|=
literal|"--"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|PREINCREMENT_EXPR
index|]
operator|=
literal|"++"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|POSTDECREMENT_EXPR
index|]
operator|=
literal|"--"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|POSTINCREMENT_EXPR
index|]
operator|=
literal|"++"
expr_stmt|;
name|opname_tab
index|[
operator|(
name|int
operator|)
name|COMPOUND_EXPR
index|]
operator|=
literal|","
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|NOP_EXPR
index|]
operator|=
literal|"="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|PLUS_EXPR
index|]
operator|=
literal|"+="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MINUS_EXPR
index|]
operator|=
literal|"-="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MULT_EXPR
index|]
operator|=
literal|"*="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_DIV_EXPR
index|]
operator|=
literal|"/="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|CEIL_DIV_EXPR
index|]
operator|=
literal|"(ceiling /=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_DIV_EXPR
index|]
operator|=
literal|"(floor /=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|ROUND_DIV_EXPR
index|]
operator|=
literal|"(round /=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|TRUNC_MOD_EXPR
index|]
operator|=
literal|"%="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|CEIL_MOD_EXPR
index|]
operator|=
literal|"(ceiling %=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|FLOOR_MOD_EXPR
index|]
operator|=
literal|"(floor %=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|ROUND_MOD_EXPR
index|]
operator|=
literal|"(round %=)"
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MIN_EXPR
index|]
operator|=
literal|"<?="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|MAX_EXPR
index|]
operator|=
literal|">?="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|LSHIFT_EXPR
index|]
operator|=
literal|"<<="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|RSHIFT_EXPR
index|]
operator|=
literal|">>="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|BIT_IOR_EXPR
index|]
operator|=
literal|"|="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|BIT_XOR_EXPR
index|]
operator|=
literal|"^="
expr_stmt|;
name|assignop_tab
index|[
operator|(
name|int
operator|)
name|BIT_AND_EXPR
index|]
operator|=
literal|"&="
expr_stmt|;
name|init_filename_times
argument_list|()
expr_stmt|;
define|#
directive|define
name|UNSET_RESERVED_WORD
parameter_list|(
name|STRING
parameter_list|)
define|\
value|do { is_reserved_word (STRING, sizeof (STRING) - 1)->name = ""; } while (0)
if|if
condition|(
operator|!
name|flag_handle_exceptions
condition|)
block|{
comment|/* Easiest way to not reconize exception 	 handling extenions...  */
name|UNSET_RESERVED_WORD
argument_list|(
literal|"all"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"except"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"exception"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"raise"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"raises"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"reraise"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"try"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_no_asm
condition|)
name|UNSET_RESERVED_WORD
argument_list|(
literal|"asm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_no_asm
operator|||
name|flag_traditional
condition|)
name|UNSET_RESERVED_WORD
argument_list|(
literal|"typeof"
argument_list|)
expr_stmt|;
name|token_count
operator|=
name|init_parse
argument_list|()
expr_stmt|;
name|interface_unknown
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reinit_parse_for_function
parameter_list|()
block|{
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|current_member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions and data structures for #pragma interface.     `#pragma implementation' means that the main file being compiled    is considered to implement (provide) the classes that appear in    its main body.  I.e., if this is file "foo.cc", and class `bar'    is defined in "foo.cc", then we say that "foo.cc implements bar".     All main input files "implement" themselves automagically.     `#pragma interface' means that unless this file (of the form "foo.h"    is not presently being included by file "foo.cc", the    CLASSTYPE_INTERFACE_ONLY bit gets set.  The effect is that none    of the vtables nor any of the inline functions defined in foo.h    will every be output.     There are cases when we want to link files such as "defs.h" and    "main.cc".  In this case, we give "defs.h" a `#pragma interface',    and "main.cc" has `#pragma implementation "defs.h"'.  */
end_comment

begin_struct
struct|struct
name|impl_files
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|impl_files
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|impl_files
modifier|*
name|impl_file_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper function to load global variables with interface    information.  */
end_comment

begin_function
specifier|static
name|void
name|extract_interface_info
parameter_list|()
block|{
name|tree
name|fileinfo
init|=
name|get_time_identifier
argument_list|(
name|input_filename
argument_list|)
decl_stmt|;
name|fileinfo
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|fileinfo
argument_list|)
expr_stmt|;
name|interface_only
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|fileinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if S and T are not considered part of an    INTERFACE/IMPLEMENTATION pair.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|interface_strcmp
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Set the interface/implementation bits for this scope.  */
name|struct
name|impl_files
modifier|*
name|ifiles
decl_stmt|;
name|char
modifier|*
name|s1
init|=
name|strrchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|s1
operator|++
operator|==
literal|0
condition|)
name|s1
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
for|for
control|(
name|ifiles
operator|=
name|impl_file_chain
init|;
name|ifiles
condition|;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|t1
init|=
name|ifiles
operator|->
name|filename
decl_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|!=
operator|*
name|t1
operator|||
operator|*
name|s1
operator|==
literal|0
condition|)
continue|continue;
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
operator|&&
operator|*
name|s1
operator|!=
literal|0
condition|)
name|s1
operator|++
operator|,
name|t1
operator|++
expr_stmt|;
comment|/* A match.  */
if|if
condition|(
operator|*
name|s1
operator|==
operator|*
name|t1
condition|)
return|return
literal|0
return|;
comment|/* Don't get faked out by xxx.yyy.cc vs xxx.zzz.cc.  */
if|if
condition|(
name|strchr
argument_list|(
name|s1
argument_list|,
literal|'.'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\0'
operator|||
name|s1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|t1
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
continue|continue;
comment|/* A match.  */
return|return
literal|0
return|;
block|}
comment|/* No matches.  */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|set_typedecl_interface_info
parameter_list|(
name|prev
parameter_list|,
name|vars
parameter_list|)
name|tree
name|prev
decl_stmt|,
name|vars
decl_stmt|;
block|{
name|tree
name|id
init|=
name|get_time_identifier
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|vars
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fileinfo
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|vars
argument_list|)
decl_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_strcmp
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|vars
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_vardecl_interface_info
parameter_list|(
name|prev
parameter_list|,
name|vars
parameter_list|)
name|tree
name|prev
decl_stmt|,
name|vars
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|tree type = DECL_VPARENT (vars);
else|#
directive|else
name|tree
name|type
init|=
name|DECL_CONTEXT
argument_list|(
name|vars
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
condition|)
name|set_typedecl_interface_info
argument_list|(
name|prev
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|vars
argument_list|)
operator|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|vars
argument_list|)
operator|=
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
operator||=
name|TREE_PUBLIC
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called from the top level: if there are any pending inlines to    do, set up to process them now.  */
end_comment

begin_function
name|void
name|do_pending_inlines
parameter_list|()
block|{
if|if
condition|(
name|finput
operator|==
name|finput1
condition|)
block|{
name|struct
name|pending_inline
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|t
init|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_inline
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Record state we were in when we decided to process 	 inline functions instead.  */
name|t
operator|->
name|next
operator|=
name|pending_inlines
expr_stmt|;
name|pending_inlines
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|t
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|t
operator|->
name|fndecl
operator|=
name|NULL_TREE
expr_stmt|;
name|t
operator|->
name|token
operator|=
name|yychar
expr_stmt|;
name|t
operator|->
name|token_value
operator|=
name|yylval
operator|.
name|itype
expr_stmt|;
comment|/* Reverse the pending inline functions, since 	 they were cons'd instead of appended.  */
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|tail
control|)
block|{
name|tail
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|t
expr_stmt|;
block|}
name|pending_inlines
operator|=
name|prev
expr_stmt|;
comment|/* Now start processing the first inline function.  */
name|t
operator|=
name|pending_inlines
expr_stmt|;
name|pending_inlines
operator|=
name|pending_inlines
operator|->
name|next
expr_stmt|;
name|finput
operator|=
name|finput2
expr_stmt|;
name|clearerr
argument_list|(
name|finput2
argument_list|)
expr_stmt|;
name|setvbuf
argument_list|(
name|finput2
argument_list|,
name|t
operator|->
name|buf
argument_list|,
name|_IOFBF
argument_list|,
name|t
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|next_inline_count
operator|=
name|t
operator|->
name|len
operator|-
literal|1
expr_stmt|;
name|lineno
operator|=
name|t
operator|->
name|lineno
expr_stmt|;
name|input_filename
operator|=
name|t
operator|->
name|filename
expr_stmt|;
name|yychar
operator|=
name|PRE_PARSED_FUNCTION_DECL
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|t
operator|->
name|fndecl
expr_stmt|;
if|if
condition|(
name|flag_default_inline
condition|)
name|TREE_INLINE
argument_list|(
name|t
operator|->
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Since inline methods can refer to text which has not yet been seen,    we store the text of the method in a structure which is placed in the    DECL_PENDING_INLINE_INFO field of the FUNCTION_DECL.    After parsing the body of the class definition, the FUNCTION_DECL's are    scanned to see which ones have this field set.  Those are then digested    one at a time.     This function's FUNCTION_DECL will have a bit set in its common so    that we know to watch out for it.  */
end_comment

begin_function
name|void
name|consume_string
parameter_list|(
name|this_obstack
parameter_list|)
specifier|register
name|struct
name|obstack
modifier|*
name|this_obstack
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|obstack_1grow
argument_list|(
name|this_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|obstack_1grow
argument_list|(
name|this_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids newline in string constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
name|this_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\"'
condition|)
do|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|nextchar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nextyychar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|YYSTYPE
name|nextyylval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|nextlastiddecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get input from stream.  When compiling under Cadillac,    the bytes must be coaxed out via their read protocol.    Otherwise, they come easily via standard input interface.  */
end_comment

begin_function
name|int
name|getch
parameter_list|()
block|{
specifier|register
name|int
name|ch
init|=
name|getc
argument_list|(
name|finput
argument_list|)
decl_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* Return next non-whitespace input character, which may come    from `finput', or from `nextchar'.  */
end_comment

begin_function
specifier|static
name|int
name|yynextch
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|nextchar
expr_stmt|;
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
return|return
name|skip_white_space
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Unget character CH from the input stream.    If RESCAN is non-zero, then we want to `see' this    character as the next input token.  */
end_comment

begin_function
name|void
name|yyungetc
parameter_list|(
name|ch
parameter_list|,
name|rescan
parameter_list|)
name|int
name|ch
decl_stmt|;
name|int
name|rescan
decl_stmt|;
block|{
comment|/* Unget a characater from the input stream.  */
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
operator|||
name|rescan
operator|==
literal|0
condition|)
name|ungetc
argument_list|(
name|ch
argument_list|,
name|finput
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|nextyychar
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nextyychar
operator|=
name|yychar
expr_stmt|;
name|nextyylval
operator|=
name|yylval
expr_stmt|;
name|yychar
operator|=
name|ch
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reinit_parse_for_method
parameter_list|(
name|yychar
parameter_list|,
name|decl
parameter_list|)
name|int
name|yychar
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|char
name|c
init|=
literal|0
decl_stmt|;
name|int
name|blev
init|=
literal|1
decl_stmt|;
name|tree
name|fndecl
init|=
name|decl
decl_stmt|;
name|int
name|starting_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|starting_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|yychar
operator|!=
literal|'{'
condition|)
block|{
if|if
condition|(
name|yychar
operator|!=
literal|':'
operator|&&
name|yychar
operator|!=
name|RETURN
condition|)
block|{
name|yyerror
argument_list|(
literal|"parse error in method specification"
argument_list|)
expr_stmt|;
name|yychar
operator|=
literal|'{'
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|>=
literal|0
condition|)
block|{
name|int
name|this_lineno
init|=
name|lineno
decl_stmt|;
name|c
operator|=
name|yynextch
argument_list|()
expr_stmt|;
comment|/* Don't lose our cool if there are lots of comments.  */
if|if
condition|(
name|lineno
operator|-
name|this_lineno
condition|)
if|if
condition|(
name|lineno
operator|-
name|this_lineno
operator|==
literal|1
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n# %d \""
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|input_filename
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* strings must be read differently than text.  */
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|consume_string
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|c
operator|=
name|yynextch
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|>
literal|' '
condition|)
comment|/* ASCII dependent! */
block|{
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
goto|goto
name|main_loop
goto|;
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
name|consume_string
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
name|error
argument_list|(
literal|"function body for constructor missing"
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|starting_filename
argument_list|,
name|starting_lineno
argument_list|,
literal|"parse error in method specification"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|main_loop
label|:
while|while
condition|(
name|c
operator|>=
literal|0
condition|)
block|{
name|int
name|this_lineno
init|=
name|lineno
decl_stmt|;
name|c
operator|=
name|skip_white_space
argument_list|(
name|getc
argument_list|(
name|finput
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't lose our cool if there are lots of comments.  */
if|if
condition|(
name|lineno
operator|-
name|this_lineno
condition|)
if|if
condition|(
name|lineno
operator|-
name|this_lineno
operator|==
literal|1
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n# %d \""
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|input_filename
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|>
literal|' '
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|blev
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
block|{
name|blev
operator|--
expr_stmt|;
if|if
condition|(
name|blev
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
condition|)
name|consume_string
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|current_member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
ifdef|#
directive|ifdef
name|USG_STDIO
name|len
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
comment|/* If the buffer given to setvbuf is shorter than eight bytes long,      setvbuf will (in violation of its man page) ignore the buffer      and call malloc to get a bigger one.  */
while|while
condition|(
name|len
operator|<
literal|8
condition|)
block|{
name|len
operator|++
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|len
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|void_type_node
condition|)
block|{
comment|/* Happens when we get two declarations of the same 	 function in the same scope.  */
name|char
modifier|*
name|buf
init|=
name|obstack_base
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
decl_stmt|;
name|obstack_free
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|struct
name|pending_inline
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|obstack_base
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
decl_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_inline
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|t
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|t
operator|->
name|lineno
operator|=
name|starting_lineno
expr_stmt|;
name|t
operator|->
name|filename
operator|=
name|starting_filename
expr_stmt|;
name|t
operator|->
name|token
operator|=
name|YYEMPTY
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fndecl
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a default function named NAME for type TYPE.    KIND says what to build.  Currently only two kinds of default functions    are recognized:     When KIND == 0, build default X(X&) constructor.    When KIND == 1, build default destructor.  */
end_comment

begin_function
name|tree
name|cons_up_default_function
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|)
name|tree
name|type
decl_stmt|,
name|name
decl_stmt|;
name|int
name|kind
decl_stmt|;
block|{
specifier|extern
name|tree
name|void_list_node
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|args
decl_stmt|;
name|tree
name|argtype
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
literal|0
case|:
comment|/* Destructor.  */
name|name
operator|=
name|build_parse_node
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Fall through...  */
case|case
literal|2
case|:
comment|/* Default constructor.  */
name|args
operator|=
name|void_list_node
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through...  */
case|case
literal|1
case|:
name|argtype
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_tree_list
argument_list|(
name|hash_tree_chain
argument_list|(
name|argtype
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|get_identifier
argument_list|(
literal|"arg"
argument_list|)
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fn
operator|=
name|start_method
argument_list|(
name|NULL_TREE
argument_list|,
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|void_type_node
condition|)
return|return
name|fn
return|;
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG_STDIO
name|len
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|len
operator|++
operator|<
literal|8
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|obstack_1grow
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|current_base_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|current_member_init_list
operator|=
name|NULL_TREE
expr_stmt|;
name|len
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
block|{
name|struct
name|pending_inline
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|obstack_base
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
decl_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|inline_text_obstack
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_inline
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|t
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|t
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|t
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|t
operator|->
name|token
operator|=
name|YYEMPTY
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fn
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* We make this declaration private (static in the C sense).  */
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|finish_method
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_COMPILER_GENERATED_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Heuristic to tell whether the user is missing a semicolon    after a struct or enum declaration.  Emit an error message    if we know the user has blown it.  */
end_comment

begin_function
name|void
name|check_for_missing_semicolon
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|yychar
operator|>
literal|255
operator|&&
name|yychar
operator|!=
name|IDENTIFIER
operator|&&
name|yychar
operator|!=
name|TYPENAME
condition|)
block|{
if|if
condition|(
name|ANON_AGGRNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"semicolon missing after %s declaration"
argument_list|,
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|?
literal|"enum"
else|:
literal|"struct"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"semicolon missing after declaration of `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|shadow_tag
argument_list|(
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Could probably also hack cases where class { ... } f (); appears.  */
block|}
end_function

begin_function
name|void
name|note_got_semicolon
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If C is not whitespace, return C.    Otherwise skip whitespace and return first nonwhite char read.  */
end_comment

begin_function
specifier|static
name|int
name|skip_white_space
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|register int inside;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Don't recognize comments in cc1: all comments are removed by cpp, 	     and cpp output can include / and * consecutively as operators.  */
if|#
directive|if
literal|0
block|case '/': 	  c = getc (finput); 	  if (c != '*'&& c != '/') 	    { 	      ungetc (c, finput); 	      return '/'; 	    }  	  if (c == '/') 	    { 	      while (c != EOF) 		{ 		  c = getch (); 		  if (c == '\n') 		    { 		      ungetc (c, finput); 		      break; 		    } 		} 	      if (c == EOF) 		{ 		  error ("unterminated comment"); 		  return EOF; 		} 	      c = getch (); 	      break; 	    }  	  c = getch ();  	  inside = 1; 	  while (inside) 	    { 	      if (c == '*') 		{ 		  while (c == '*') 		    c = getch ();  		  if (c == '/') 		    { 		      inside = 0; 		      c = getch (); 		    } 		} 	      else if (c == '\n') 		{ 		  lineno++; 		  c = getch (); 		} 	      else if (c == EOF) 		{ 		  error ("unterminated comment"); 		  break; 		} 	      else 		c = getch (); 	    }  	  break;
endif|#
directive|endif
case|case
literal|'\n'
case|:
name|c
operator|=
name|check_newline
argument_list|()
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\b'
case|:
do|do
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
break|break;
case|case
literal|'\\'
case|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
else|else
name|error
argument_list|(
literal|"stray '\\' in program"
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make the token buffer longer, preserving the data in it.    P should point to just beyond the last valid character in the old buffer.    The value we return is a pointer to the new buffer    at a place corresponding to P.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extend_token_buffer
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|offset
init|=
name|p
operator|-
name|token_buffer
decl_stmt|;
name|maxtoken
operator|=
name|maxtoken
operator|*
literal|2
operator|+
literal|10
expr_stmt|;
name|token_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|token_buffer
argument_list|,
name|maxtoken
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|token_buffer
operator|+
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNDUMP
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|MERGED
end_ifndef

begin_comment
comment|/* This includes code from write_segment, stolen from unexec.c */
end_comment

begin_function
name|void
name|dump_data
parameter_list|()
block|{
name|int
name|new
decl_stmt|;
specifier|register
name|caddr_t
name|ptr
decl_stmt|,
name|end
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|nwrite
decl_stmt|,
name|ret
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|char
name|zeros
index|[
literal|128
index|]
decl_stmt|;
specifier|extern
name|int
name|been_here_before
decl_stmt|,
name|just_done_unexec
decl_stmt|,
name|my_edata
decl_stmt|;
specifier|extern
name|char
modifier|*
name|dump_source_name
decl_stmt|;
specifier|extern
name|char
modifier|*
name|asm_file_name
decl_stmt|,
name|previous_asm_file_name
index|[]
decl_stmt|;
name|char
name|dump_file_name
index|[
literal|256
index|]
decl_stmt|;
comment|/* Fixed-sized buffer -- sigh. */
name|caddr_t
name|end_of_data
decl_stmt|,
name|end_of_heap
decl_stmt|;
name|int
name|data_size
decl_stmt|,
name|token
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|bzero
argument_list|(
name|zeros
argument_list|,
sizeof|sizeof
name|zeros
argument_list|)
expr_stmt|;
comment|/* Here we have just seen `#pragma dump '.      The name to dump to, a string constant, may follow.  */
do|do
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
comment|/* If no argument, default to something like "dumped-cc1plus".  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|strcpy
argument_list|(
name|dump_file_name
argument_list|,
literal|"dumped-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|=
name|strrchr
argument_list|(
name|dump_source_name
argument_list|,
literal|'/'
argument_list|)
condition|)
name|dump_source_name
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
name|strcat
argument_list|(
name|dump_file_name
argument_list|,
name|dump_source_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #pragma dump"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|dump_file_name
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|been_here_before
operator|=
literal|1
expr_stmt|;
comment|/* Raise the flag! */
name|strcpy
argument_list|(
name|previous_asm_file_name
argument_list|,
name|asm_file_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nDumping %s to %s...\n"
argument_list|,
name|dump_source_name
argument_list|,
name|dump_file_name
argument_list|)
expr_stmt|;
name|end_of_heap
operator|=
operator|(
name|caddr_t
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|end_of_data
operator|=
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|&
name|my_edata
argument_list|)
operator|&
operator|~
operator|(
name|getpagesize
argument_list|()
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|data_size
operator|=
call|(
name|int
call|)
argument_list|(
name|end_of_heap
operator|-
name|end_of_data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Data size = %d\n"
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
name|new
operator|=
name|creat
argument_list|(
name|dump_file_name
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|end_of_data
expr_stmt|;
name|end
operator|=
name|end_of_heap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ptr
operator|<
name|end
condition|;
control|)
block|{
comment|/* distance to next multiple of 128.  */
name|nwrite
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|ptr
operator|+
literal|128
operator|)
operator|&
operator|-
literal|128
operator|)
operator|-
operator|(
name|int
operator|)
name|ptr
expr_stmt|;
comment|/* But not beyond specified end.  */
if|if
condition|(
name|nwrite
operator|>
name|end
operator|-
name|ptr
condition|)
name|nwrite
operator|=
name|end
operator|-
name|ptr
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|nwrite
argument_list|)
expr_stmt|;
comment|/* If write gets a page fault, it means we reached 	 a gap between the old text segment and the old data segment. 	 This gap has probably been remapped into part of the text segment. 	 So write zeros for it.  */
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EFAULT
condition|)
name|write
argument_list|(
name|new
argument_list|,
name|zeros
argument_list|,
name|nwrite
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nwrite
operator|!=
name|ret
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unexec write failure: addr 0x%x, fileno %d, size 0x%x, wrote 0x%x, errno %d"
argument_list|,
name|ptr
argument_list|,
name|new
argument_list|,
name|nwrite
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|+=
name|nwrite
expr_stmt|;
name|ptr
operator|+=
name|nwrite
expr_stmt|;
block|}
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|just_done_unexec
operator|=
literal|1
expr_stmt|;
comment|/* Tell toplev not to output ending. */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
specifier|static
name|int
name|get_last_nonwhite_on_line
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Is this the last nonwhite stuff on the line?  */
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* At the beginning of a line, increment the line number    and process any #-directive on this line.    If the line is a #-directive, read the entire line and return a newline.    Otherwise, return the line's first non-whitespace character.  */
end_comment

begin_function
name|int
name|check_newline
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|token
decl_stmt|;
name|lineno
operator|++
expr_stmt|;
comment|/* Read first nonwhite char on the line.  */
do|do
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
if|if
condition|(
name|c
operator|!=
literal|'#'
condition|)
block|{
comment|/* If not #, return it so caller will use it.  */
return|return
name|c
return|;
block|}
comment|/* Read first nonwhite char after the `#'.  */
do|do
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
comment|/* If a letter follows, then if the word here is `line', skip      it and ignore it; otherwise, ignore the line, with an error      if the word isn't `pragma'.  */
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'r'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
operator|&&
name|getch
argument_list|()
operator|==
literal|'g'
operator|&&
name|getch
argument_list|()
operator|==
literal|'m'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
condition|)
comment|/* Change by Bryan Boreham, Kewill, Sun Jul 23 15:53:24 1989.    This whole section added to support dumping of    compilations in the middle. */
block|{
comment|/* Read first nonwhite char after the `#pragma'.  */
do|do
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
do|;
ifndef|#
directive|ifndef
name|MERGED
comment|/* See if it is "dump" */
if|if
condition|(
name|c
operator|==
literal|'d'
operator|&&
name|getch
argument_list|()
operator|==
literal|'u'
operator|&&
name|getch
argument_list|()
operator|==
literal|'m'
operator|&&
name|getch
argument_list|()
operator|==
literal|'p'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|HAVE_UNDUMP
empty_stmt|;
comment|/* Are you crazy? */
else|#
directive|else
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|dump_data
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|toplevel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'v'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
operator|&&
name|getch
argument_list|()
operator|==
literal|'b'
operator|&&
name|getch
argument_list|()
operator|==
literal|'l'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
specifier|extern
name|tree
name|pending_vtables
decl_stmt|;
comment|/* More follows: it must be a string constant (class name).  */
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #pragma vtable"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
if|if
condition|(
name|write_virtuals
operator|!=
literal|2
condition|)
block|{
name|warning
argument_list|(
literal|"use `+e2' option to enable #pragma vtable"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|pending_vtables
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
argument_list|,
name|pending_vtables
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|<
literal|0
condition|)
name|nextchar
operator|=
name|getch
argument_list|()
expr_stmt|;
name|c
operator|=
name|nextchar
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|warning
argument_list|(
literal|"trailing characters ignored"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'i'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* More follows: it must be a string constant (unit name).  */
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #pragma unit"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|current_unit_name
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
name|current_unit_language
operator|=
name|current_lang_name
expr_stmt|;
if|if
condition|(
name|nextchar
operator|<
literal|0
condition|)
name|nextchar
operator|=
name|getch
argument_list|()
expr_stmt|;
name|c
operator|=
name|nextchar
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|warning
argument_list|(
literal|"trailing characters ignored"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
condition|)
block|{
name|tree
name|fileinfo
init|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|get_time_identifier
argument_list|(
name|input_filename
argument_list|)
argument_list|)
decl_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'r'
operator|&&
name|getch
argument_list|()
operator|==
literal|'f'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
operator|&&
name|getch
argument_list|()
operator|==
literal|'c'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* read to newline.  */
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|write_virtuals
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|impl_file_chain
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|tree
name|fi
decl_stmt|;
comment|/* If this is zero at this point, then we are 			     auto-implementing.  */
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
name|filename
operator|=
name|strrchr
argument_list|(
name|main_input_filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|++
operator|==
literal|0
condition|)
name|filename
operator|=
name|main_input_filename
expr_stmt|;
name|fi
operator|=
name|get_time_identifier
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|fi
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|fi
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|fi
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Get default.  */
name|impl_file_chain
operator|=
operator|(
expr|struct
name|impl_files
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|impl_files
argument_list|)
argument_list|)
expr_stmt|;
name|impl_file_chain
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|impl_file_chain
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|interface_only
operator|=
name|interface_strcmp
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|interface_unknown
operator|=
literal|0
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_unknown
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'m'
operator|&&
name|getch
argument_list|()
operator|==
literal|'p'
operator|&&
name|getch
argument_list|()
operator|==
literal|'l'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'m'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
name|getch
argument_list|()
operator|==
literal|'a'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
name|getch
argument_list|()
operator|==
literal|'i'
operator|&&
name|getch
argument_list|()
operator|==
literal|'o'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|char
modifier|*
name|main_filename
init|=
name|main_input_filename
condition|?
name|main_input_filename
else|:
name|input_filename
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid `#pragma implementation'"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|main_filename
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|strrchr
argument_list|(
name|main_filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|++
condition|)
name|main_filename
operator|=
name|tmp
expr_stmt|;
comment|/* read to newline.  */
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|==
literal|3
condition|)
block|{
name|struct
name|impl_files
modifier|*
name|ifiles
init|=
name|impl_file_chain
decl_stmt|;
while|while
condition|(
name|ifiles
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifiles
operator|->
name|filename
argument_list|,
name|main_filename
argument_list|)
condition|)
break|break;
name|ifiles
operator|=
name|ifiles
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|ifiles
operator|==
literal|0
condition|)
block|{
name|ifiles
operator|=
operator|(
expr|struct
name|impl_files
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|impl_files
argument_list|)
argument_list|)
expr_stmt|;
name|ifiles
operator|->
name|filename
operator|=
name|main_filename
expr_stmt|;
name|ifiles
operator|->
name|next
operator|=
name|impl_file_chain
expr_stmt|;
name|impl_file_chain
operator|=
name|ifiles
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|main_input_filename
operator|==
name|input_filename
operator|||
operator|!
name|strcmp
argument_list|(
name|input_filename
argument_list|,
name|main_filename
argument_list|)
condition|)
block|{
name|write_virtuals
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|impl_file_chain
operator|==
literal|0
condition|)
block|{
name|impl_file_chain
operator|=
operator|(
expr|struct
name|impl_files
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|impl_files
argument_list|)
argument_list|)
expr_stmt|;
name|impl_file_chain
operator|->
name|filename
operator|=
name|main_filename
expr_stmt|;
name|impl_file_chain
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"`#pragma implementation' can only appear at top-level"
argument_list|)
expr_stmt|;
name|interface_only
operator|=
literal|0
expr_stmt|;
name|interface_unknown
operator|=
literal|0
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|fileinfo
argument_list|)
operator|=
name|interface_unknown
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|skipline
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'i'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
goto|goto
name|linenum
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'d'
operator|&&
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'n'
operator|&&
name|getch
argument_list|()
operator|==
literal|'t'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
comment|/* Conditionally used.  */
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|error
argument_list|(
literal|"ANSI C does not allow #ident"
argument_list|)
expr_stmt|;
comment|/* Here we have just seen `#ident '. 		 A string constant should follow.  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* If no argument, ignore the line.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #ident"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_IDENT
name|ASM_OUTPUT_IDENT
argument_list|(
name|asm_out_file
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Skip the rest of this line.  */
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|getch
argument_list|()
operator|==
literal|'e'
operator|&&
name|getch
argument_list|()
operator|==
literal|'w'
operator|&&
name|getch
argument_list|()
operator|==
literal|'w'
operator|&&
name|getch
argument_list|()
operator|==
literal|'o'
operator|&&
name|getch
argument_list|()
operator|==
literal|'r'
operator|&&
name|getch
argument_list|()
operator|==
literal|'l'
operator|&&
name|getch
argument_list|()
operator|==
literal|'d'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
comment|/* Used to test incremental compilation.  */
name|sorry
argument_list|(
literal|"#pragma newworld"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
block|}
name|error
argument_list|(
literal|"undefined or invalid # directive"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|linenum
label|:
comment|/* Here we have either `#line' or `#<nonletter>'.      In either case, it should be a line number; a digit should follow.  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* If the # is the only nonwhite char on the line,      just ignore it.  Check the new newline.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
comment|/* Something follows the #; read a token.  */
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
comment|/* subtract one, because it is the following line that 	 gets the specified number */
name|int
name|l
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|-
literal|1
decl_stmt|;
name|c
operator|=
name|get_last_nonwhite_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* No more: store the line number and check following line.  */
name|lineno
operator|=
name|l
expr_stmt|;
return|return
name|c
return|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
comment|/* More follows: it must be a string constant (filename).  */
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #line"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
comment|/* Changing files again.  This means currently collected time 	 is charged against header time, and body time starts back 	 at 0.  */
if|if
condition|(
name|flag_detailed_statistics
condition|)
block|{
name|int
name|this_time
init|=
name|my_gettime
argument_list|()
decl_stmt|;
name|tree
name|time_identifier
init|=
name|get_time_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
decl_stmt|;
name|header_time
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|this_filename_time
argument_list|)
argument_list|)
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|this_filename_time
operator|=
name|time_identifier
expr_stmt|;
name|body_time
operator|=
name|this_time
expr_stmt|;
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_note_source
argument_list|()
expr_stmt|;
name|input_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|permalloc
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|input_filename
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|l
expr_stmt|;
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
block|{
specifier|extern
name|int
name|been_here_before
decl_stmt|;
name|struct
name|impl_files
modifier|*
name|ifiles
init|=
name|impl_file_chain
decl_stmt|;
if|if
condition|(
name|ifiles
condition|)
block|{
while|while
condition|(
name|ifiles
operator|->
name|next
condition|)
name|ifiles
operator|=
name|ifiles
operator|->
name|next
expr_stmt|;
name|ifiles
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|strrchr
argument_list|(
name|input_filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifiles
operator|->
name|filename
operator|++
operator|==
literal|0
condition|)
name|ifiles
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
block|}
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|==
literal|3
condition|)
name|walk_vtables
argument_list|(
name|set_typedecl_interface_info
argument_list|,
name|set_vardecl_interface_info
argument_list|)
expr_stmt|;
block|}
name|extract_interface_info
argument_list|()
expr_stmt|;
name|c
operator|=
name|get_last_nonwhite_on_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_switch_source
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
comment|/* `1' after file name means entering new file. 	 `2' after file name means just left a file.  */
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|1
condition|)
block|{
name|struct
name|file_stack
modifier|*
name|p
init|=
operator|(
expr|struct
name|file_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack
argument_list|)
argument_list|)
decl_stmt|;
name|input_file_stack
operator|->
name|line
operator|=
name|old_lineno
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|input_file_stack
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
name|input_file_stack
operator|=
name|p
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_push_source
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_file_stack
operator|->
name|next
condition|)
block|{
name|struct
name|file_stack
modifier|*
name|p
init|=
name|input_file_stack
decl_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_pop_source
argument_list|()
expr_stmt|;
name|input_file_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"#-lines for entering and leaving files don't match"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_switch_source
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If NEXTCHAR is not end of line, we don't care what it is.  */
if|if
condition|(
name|nextchar
operator|==
literal|'\n'
condition|)
return|return
literal|'\n'
return|;
block|}
else|else
name|error
argument_list|(
literal|"invalid #-line"
argument_list|)
expr_stmt|;
comment|/* skip the rest of this line.  */
name|skipline
label|:
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
while|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|isalnum
parameter_list|(
name|char
parameter_list|)
value|(char>= 'a' ? char<= 'z' : char>= '0' ? char<= '9' || (char>= 'A'&& char<= 'Z') : 0)
end_define

begin_define
define|#
directive|define
name|isdigit
parameter_list|(
name|char
parameter_list|)
value|(char>= '0'&& char<= '9')
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ENDFILE
value|-1
end_define

begin_comment
comment|/* token that represents end-of-file */
end_comment

begin_function
specifier|static
name|int
name|readescape
parameter_list|()
block|{
specifier|register
name|int
name|c
init|=
name|getc
argument_list|(
name|finput
argument_list|)
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|,
name|code
decl_stmt|;
name|int
name|firstdig
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
break|break;
block|}
name|code
operator|*=
literal|16
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|firstdig
operator|=
name|code
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"\\x used with no following hex digits"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|||
operator|(
operator|(
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|-
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
operator|)
operator|<=
name|firstdig
operator|)
condition|)
name|warning
argument_list|(
literal|"hex escape out of range"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|<=
literal|'7'
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|count
operator|++
operator|<
literal|3
operator|)
condition|)
block|{
name|code
operator|=
operator|(
name|code
operator|*
literal|8
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
return|return
name|c
return|;
case|case
literal|'\n'
case|:
name|lineno
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|'n'
case|:
return|return
name|TARGET_NEWLINE
return|;
case|case
literal|'t'
case|:
return|return
name|TARGET_TAB
return|;
case|case
literal|'r'
case|:
return|return
name|TARGET_CR
return|;
case|case
literal|'f'
case|:
return|return
name|TARGET_FF
return|;
case|case
literal|'b'
case|:
return|return
name|TARGET_BS
return|;
case|case
literal|'a'
case|:
return|return
name|TARGET_BELL
return|;
case|case
literal|'v'
case|:
return|return
name|TARGET_VT
return|;
case|case
literal|'E'
case|:
return|return
literal|033
return|;
case|case
literal|'?'
case|:
comment|/* `\(', etc, are used at beginning of line to avoid confusing Emacs.  */
case|case
literal|'('
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
return|return
name|c
return|;
block|}
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<=
literal|0177
condition|)
name|warning
argument_list|(
literal|"unknown escape sequence `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"unknown escape sequence: `\\' followed by char code 0x%x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Value is 1 if we should try to make the next identifier look like a    typename (when it may be a local variable or a class variable).    Value is 0 if we treat this name in a default fashion.    Value is -1 if we must not see a type name.  */
end_comment

begin_decl_stmt
name|int
name|looking_for_typename
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dont_see_typename
parameter_list|()
block|{
name|looking_for_typename
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
name|TYPENAME
condition|)
block|{
name|yychar
operator|=
name|IDENTIFIER
expr_stmt|;
name|lastiddecl
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|see_typename
parameter_list|()
block|{
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
name|IDENTIFIER
condition|)
block|{
name|lastiddecl
operator|=
name|lookup_name
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastiddecl
operator|==
literal|0
operator|&&
name|flag_labels_ok
condition|)
name|lastiddecl
operator|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lastiddecl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|lastiddecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|yychar
operator|=
name|TYPENAME
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tree
name|do_identifier
parameter_list|(
name|token
parameter_list|)
specifier|register
name|tree
name|token
decl_stmt|;
block|{
specifier|register
name|tree
name|id
init|=
name|lastiddecl
decl_stmt|;
if|if
condition|(
name|yychar
operator|==
name|YYEMPTY
condition|)
name|yychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
comment|/* Scope class declarations before global      declarations.  */
if|if
condition|(
name|id
operator|==
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|token
argument_list|)
operator|&&
name|current_class_type
operator|!=
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|current_class_type
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Could be from one of the base classes.  */
name|tree
name|field
init|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|token
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
comment|/* We have already generated the error message. 	   But we still want to return this value.  */
name|id
operator|=
name|lookup_field
argument_list|(
name|current_class_type
argument_list|,
name|token
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|id
operator|=
name|field
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
block|{
name|error_with_decl
argument_list|(
name|field
argument_list|,
literal|"invalid use of member `%s' from base class `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|id
return|;
block|}
block|}
if|if
condition|(
operator|!
name|id
operator|||
name|id
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|yychar
operator|==
literal|'('
operator|||
name|yychar
operator|==
name|LEFT_RIGHT
condition|)
block|{
name|id
operator|=
name|implicitly_declare
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|assemble_external
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"`%s' undeclared, outside of functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|token
argument_list|)
operator|!=
name|error_mark_node
operator|||
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|token
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
specifier|extern
name|int
name|undeclared_variable_notice
decl_stmt|;
name|error
argument_list|(
literal|"`%s' undeclared (first use this function)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|undeclared_variable_notice
condition|)
block|{
name|error
argument_list|(
literal|"(Each undeclared identifier is reported only once"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"for each function it appears in.)"
argument_list|)
expr_stmt|;
name|undeclared_variable_notice
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|id
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Prevent repeated error messages.  */
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|token
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|SET_IDENTIFIER_ERROR_LOCUS
argument_list|(
name|token
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* TREE_USED is set in `hack_identifier'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|token
argument_list|)
operator|==
name|id
condition|)
block|{
comment|/* Check visibility.  */
name|enum
name|visibility_type
name|visibility
init|=
name|compute_visibility
argument_list|(
name|CLASSTYPE_AS_LIST
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
name|error_with_decl
argument_list|(
name|id
argument_list|,
literal|"enum `%s' is private"
argument_list|)
expr_stmt|;
comment|/* protected is OK, since it's an enum of `this'.  */
block|}
name|id
operator|=
name|DECL_INITIAL
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
name|id
operator|=
name|hack_identifier
argument_list|(
name|id
argument_list|,
name|token
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
name|int
name|yylex
parameter_list|()
block|{
name|tree
name|tmp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|value
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|int
name|dollar_seen
init|=
literal|0
decl_stmt|;
name|relex
label|:
if|if
condition|(
name|nextyychar
operator|>=
literal|0
condition|)
block|{
name|value
operator|=
name|nextyychar
expr_stmt|;
name|yylval
operator|=
name|nextyylval
expr_stmt|;
name|lastiddecl
operator|=
name|nextlastiddecl
expr_stmt|;
name|nextyychar
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|IDENTIFIER
condition|)
block|{
name|tmp
operator|=
name|yylval
operator|.
name|ttype
expr_stmt|;
goto|goto
name|resume_identifier_processing
goto|;
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* Effectively do c = skip_white_space (c)      but do it faster in the usual cases.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\b'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
case|case
literal|'/'
case|:
case|case
literal|'\\'
case|:
name|c
operator|=
name|skip_white_space
argument_list|(
name|c
argument_list|)
expr_stmt|;
default|default:
goto|goto
name|found_nonwhite
goto|;
block|}
name|found_nonwhite
label|:
name|token_buffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  yylloc.first_line = lineno; */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|pending_inlines
condition|)
block|{
name|struct
name|pending_inline
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|pending_inlines
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_METHODS_THE_OLD_WAY
name|yylval
operator|.
name|itype
operator|=
name|t
operator|->
name|token_value
expr_stmt|;
name|value
operator|=
name|t
operator|->
name|token
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|t
operator|->
name|fndecl
operator|==
literal|0
condition|)
block|{
name|yylval
operator|.
name|itype
operator|=
name|t
operator|->
name|token_value
expr_stmt|;
name|value
operator|=
name|t
operator|->
name|token
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|ttype
operator|=
name|t
operator|->
name|fndecl
expr_stmt|;
name|value
operator|=
name|PRE_PARSED_FUNCTION_DECL
expr_stmt|;
block|}
endif|#
directive|endif
name|lineno
operator|=
name|t
operator|->
name|lineno
expr_stmt|;
comment|/*	    yylloc.first_line = lineno; */
name|input_filename
operator|=
name|t
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|next
condition|)
block|{
comment|/* The buffer we used will be freed at the 		 end of this function.  */
name|pending_inlines
operator|=
name|pending_inlines
operator|->
name|next
expr_stmt|;
name|clearerr
argument_list|(
name|finput2
argument_list|)
expr_stmt|;
name|setvbuf
argument_list|(
name|finput2
argument_list|,
name|t
operator|->
name|buf
argument_list|,
name|_IOFBF
argument_list|,
name|t
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|next_inline_count
operator|=
name|t
operator|->
name|len
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pending_inlines
operator|=
name|NULL
expr_stmt|;
name|finput
operator|=
name|finput1
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|inline_text_obstack
argument_list|,
name|inline_text_firstobj
argument_list|)
expr_stmt|;
block|}
comment|/* The space used by T will be freed after all inline 	     functions have been processed.  */
if|if
condition|(
name|value
operator|<=
literal|0
condition|)
goto|goto
name|relex
goto|;
else|else
goto|goto
name|done
goto|;
block|}
name|end_of_file
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|ENDFILE
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|dollars_in_ident
condition|)
block|{
name|dollar_seen
operator|=
literal|1
expr_stmt|;
goto|goto
name|letter
goto|;
block|}
name|value
operator|=
literal|'$'
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'L'
case|:
comment|/* Capital L may start a wide-string or wide-character constant.  */
block|{
specifier|register
name|int
name|c
init|=
name|getch
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|wide_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|char_constant
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|wide_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|string_constant
goto|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
block|}
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'_'
case|:
name|letter
label|:
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|token_buffer
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
operator|&&
operator|!
name|dollars_in_ident
condition|)
break|break;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|nextchar
operator|=
name|c
expr_stmt|;
name|value
operator|=
name|IDENTIFIER
expr_stmt|;
name|yylval
operator|.
name|itype
operator|=
literal|0
expr_stmt|;
comment|/* Try to recognize a keyword.  Uses minimum-perfect hash function */
block|{
specifier|register
name|struct
name|resword
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|=
name|is_reserved_word
argument_list|(
name|token_buffer
argument_list|,
name|p
operator|-
name|token_buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_lang_name
operator|!=
name|lang_name_cplusplus
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|rid
operator|!=
literal|0
operator|&&
operator|(
name|ptr
operator|->
name|rid
operator|==
name|RID_CLASS
operator|||
name|ptr
operator|->
name|rid
operator|==
name|RID_FRIEND
operator|||
name|ptr
operator|->
name|rid
operator|==
name|RID_VIRTUAL
operator|||
operator|(
name|flag_no_asm
operator|&&
name|ptr
operator|->
name|rid
operator|==
name|RID_INLINE
operator|)
operator|)
condition|)
block|{
name|ptr
operator|=
literal|0
expr_stmt|;
goto|goto
name|not_reserved_word_after_all
goto|;
block|}
if|if
condition|(
name|flag_traditional
operator|&&
operator|(
operator|(
name|int
operator|)
name|ptr
operator|->
name|token
operator|==
name|TYPEOF
operator|||
name|ptr
operator|->
name|rid
operator|==
name|RID_SIGNED
operator|||
name|ptr
operator|->
name|rid
operator|==
name|RID_INLINE
operator|)
condition|)
block|{
name|ptr
operator|=
literal|0
expr_stmt|;
goto|goto
name|not_reserved_word_after_all
goto|;
block|}
block|}
if|if
condition|(
name|ptr
operator|->
name|rid
condition|)
block|{
name|tree
name|old_ttype
init|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|ptr
operator|->
name|rid
index|]
decl_stmt|;
comment|/* If this provides a type for us, then revert lexical 		     state to standard state.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_ttype
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|old_ttype
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|old_ttype
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
comment|/* Check if this is a language-type declaration. 		     Just glimpse the next non-white character.  */
name|nextchar
operator|=
name|skip_white_space
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|'"'
condition|)
block|{
comment|/* We are looking at a string.  Complain 			 if the token before the string is no `extern'. 			  			 Could cheat some memory by placing this string 			 on the temporary_, instead of the saveable_ 			 obstack.  */
if|if
condition|(
name|ptr
operator|->
name|rid
operator|!=
name|RID_EXTERN
condition|)
name|error
argument_list|(
literal|"invalid modifier `%s' for language string"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|value
operator|=
name|EXTERN_LANG_STRING
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|yylval
operator|.
name|ttype
operator|=
name|old_ttype
expr_stmt|;
block|}
name|value
operator|=
operator|(
name|int
operator|)
name|ptr
operator|->
name|token
expr_stmt|;
block|}
name|not_reserved_word_after_all
label|:
empty_stmt|;
block|}
comment|/* If we did not find a keyword, look for an identifier 	   (or a typename).  */
ifdef|#
directive|ifdef
name|FIELD_XREF
if|if
condition|(
name|value
operator|==
name|IDENTIFIER
operator|||
name|value
operator|==
name|TYPESPEC
condition|)
name|FIELD_xref_ref
argument_list|(
name|current_function_decl
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|value
operator|==
name|IDENTIFIER
condition|)
block|{
name|tmp
operator|=
name|get_identifier
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
comment|/* Make sure that user does not collide with our internal 	       naming scheme.  */
if|if
condition|(
name|JOINER
operator|==
literal|'$'
operator|&&
name|dollar_seen
operator|&&
operator|(
name|THIS_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|VPTR_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|DESTRUCTOR_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|WRAPPER_OR_ANTI_WRAPPER_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|OPERATOR_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|VTABLE_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|OPERATOR_TYPENAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|TEMP_NAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|ANON_AGGRNAME_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|ANON_PARMNAME_P
argument_list|(
name|tmp
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"identifier name `%s' conflicts with GNU C++ internal naming strategy"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Come into here if we must reprocess an identifier.  */
name|resume_identifier_processing
label|:
if|if
condition|(
name|looking_for_typename
operator|==
literal|1
operator|&&
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
operator|!=
literal|0
condition|)
name|lastiddecl
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|lastiddecl
operator|=
name|lookup_name
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastiddecl
operator|&&
name|TREE_CODE
argument_list|(
name|lastiddecl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|looking_for_typename
operator|>=
literal|0
condition|)
block|{
comment|/* This call could blow away yylval.  */
name|c
operator|=
name|skip_white_space
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|value
operator|=
name|TYPENAME_SCOPE
expr_stmt|;
block|}
else|else
block|{
name|nextchar
operator|=
name|c
expr_stmt|;
name|value
operator|=
name|TYPENAME_COLON
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
operator|&&
name|current_function_decl
operator|==
name|NULL_TREE
operator|&&
name|current_class_type
operator|==
name|NULL_TREE
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'.'
condition|)
name|error
argument_list|(
literal|"missing '.' in `...'"
argument_list|)
expr_stmt|;
name|value
operator|=
name|TYPENAME_ELLIPSIS
expr_stmt|;
name|tmp
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_tree_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|lastiddecl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextchar
operator|=
name|c
expr_stmt|;
name|warning
argument_list|(
literal|"use of obsolete scope operator `.'; use `::' instead"
argument_list|)
expr_stmt|;
name|value
operator|=
name|TYPENAME_SCOPE
expr_stmt|;
block|}
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nextchar
operator|=
name|c
expr_stmt|;
name|value
operator|=
name|TYPENAME
expr_stmt|;
if|if
condition|(
name|looking_for_typename
operator|==
literal|1
condition|)
block|{
name|looking_for_typename
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|yylval.ttype = TREE_TYPE (lastiddecl); 			break;
endif|#
directive|endif
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|lastiddecl
operator|==
literal|0
operator|&&
name|flag_labels_ok
condition|)
name|lastiddecl
operator|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|NEW
operator|&&
operator|!
name|global_bindings_p
argument_list|()
condition|)
block|{
name|looking_for_typename
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|NEW
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|largest_digit
init|=
literal|0
decl_stmt|;
name|int
name|numdigits
init|=
literal|0
decl_stmt|;
comment|/* for multi-precision arithmetic, 	   we store only 8 live bits in each short, 	   giving us 64 bits of reliable precision */
name|short
name|shorts
index|[
literal|8
index|]
decl_stmt|;
enum|enum
name|anon1
block|{
name|NOT_FLOAT
block|,
name|AFTER_POINT
block|,
name|TOO_MANY_POINTS
block|}
name|floatflag
init|=
name|NOT_FLOAT
enum|;
name|p
operator|=
name|token_buffer
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Optimize for most frequent case.  */
if|if
condition|(
name|c
operator|==
literal|'0'
operator|||
name|c
operator|==
literal|'1'
condition|)
block|{
specifier|register
name|int
name|c1
init|=
name|getch
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c1
argument_list|)
operator|&&
name|c1
operator|!=
literal|'.'
condition|)
block|{
comment|/* Terminate string.  */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|integer_zero_node
expr_stmt|;
else|else
name|yylval
operator|.
name|ttype
operator|=
name|integer_one_node
expr_stmt|;
name|nextchar
operator|=
name|c1
expr_stmt|;
name|value
operator|=
name|CONSTANT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ungetc
argument_list|(
name|c1
argument_list|,
name|finput
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|8
condition|;
name|count
operator|++
control|)
name|shorts
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|numdigits
operator|++
expr_stmt|;
block|}
block|}
comment|/* Read all the digits-and-decimal-points.  */
while|while
condition|(
name|c
operator|==
literal|'.'
operator|||
operator|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|!=
literal|'l'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'L'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'u'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'U'
operator|)
operator|&&
operator|(
name|floatflag
operator|==
name|NOT_FLOAT
operator|||
operator|(
operator|(
name|c
operator|!=
literal|'f'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'F'
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|16
condition|)
name|error
argument_list|(
literal|"floating constant may not be in radix 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|floatflag
operator|==
name|AFTER_POINT
condition|)
block|{
name|error
argument_list|(
literal|"malformed floating constant"
argument_list|)
expr_stmt|;
name|floatflag
operator|=
name|TOO_MANY_POINTS
expr_stmt|;
block|}
else|else
name|floatflag
operator|=
name|AFTER_POINT
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
comment|/* Accept '.' as the start of a floating-point number 		   only when it is followed by a digit. 		   Otherwise, unread the following non-digit 		   and use the '.' as a structural token.  */
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
literal|2
operator|&&
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|ELLIPSIS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nextchar
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|RANGE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nextchar
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
literal|'.'
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* It is not a decimal point. 		   It should be a digit (perhaps a hex digit).  */
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|<=
literal|10
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|&
operator|~
literal|040
operator|)
operator|==
literal|'E'
condition|)
block|{
name|base
operator|=
literal|10
expr_stmt|;
name|floatflag
operator|=
name|AFTER_POINT
expr_stmt|;
break|break;
comment|/* start of exponent */
block|}
name|error
argument_list|(
literal|"nondigits in number and not hexadecimal"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
condition|)
block|{
name|c
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
name|largest_digit
condition|)
name|largest_digit
operator|=
name|c
expr_stmt|;
name|numdigits
operator|++
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|8
condition|;
name|count
operator|++
control|)
block|{
operator|(
name|shorts
index|[
name|count
index|]
operator|*=
name|base
operator|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|shorts
index|[
name|count
index|]
operator|+=
operator|(
name|shorts
index|[
name|count
operator|-
literal|1
index|]
operator|>>
literal|8
operator|)
expr_stmt|;
name|shorts
index|[
name|count
operator|-
literal|1
index|]
operator|&=
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|shorts
index|[
literal|0
index|]
operator|+=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numdigits
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"numeric constant with no digits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|largest_digit
operator|>=
name|base
condition|)
name|error
argument_list|(
literal|"numeric constant contains digits beyond the radix"
argument_list|)
expr_stmt|;
comment|/* Remove terminating char from the token buffer and delimit the string */
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|floatflag
operator|!=
name|NOT_FLOAT
condition|)
block|{
name|tree
name|type
init|=
name|double_type_node
decl_stmt|;
name|char
name|f_seen
init|=
literal|0
decl_stmt|;
name|char
name|l_seen
init|=
literal|0
decl_stmt|;
name|double
name|value
decl_stmt|;
comment|/* Read explicit exponent if any, and put it in tokenbuf.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'E'
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'-'
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"floating constant exponent has no digits"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|atof
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ERANGE
if|if
condition|(
name|errno
operator|==
name|ERANGE
operator|&&
operator|!
name|flag_traditional
condition|)
block|{
name|char
modifier|*
name|p1
init|=
name|token_buffer
decl_stmt|;
comment|/* Check for "0.0" and variants; 		   Sunos 4 spuriously returns ERANGE for them.  */
while|while
condition|(
operator|*
name|p1
operator|==
literal|'0'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|==
literal|'.'
condition|)
name|p1
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|==
literal|'0'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"floating point number exceeds range of `double'"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Read the suffixes to choose a data type.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'f'
operator|||
name|c
operator|==
literal|'F'
condition|)
block|{
if|if
condition|(
name|f_seen
condition|)
name|error
argument_list|(
literal|"two `f's in floating constant"
argument_list|)
expr_stmt|;
name|f_seen
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|float_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|l_seen
condition|)
name|error
argument_list|(
literal|"two `l's in floating constant"
argument_list|)
expr_stmt|;
name|l_seen
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|long_double_type_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"garbage at end of number"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
comment|/* Create a node with determined type and value.  */
name|yylval
operator|.
name|ttype
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
decl_stmt|;
name|int
name|spec_unsigned
init|=
literal|0
decl_stmt|;
name|int
name|spec_long
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
name|spec_unsigned
condition|)
name|error
argument_list|(
literal|"two `u's in integer constant"
argument_list|)
expr_stmt|;
name|spec_unsigned
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|spec_long
condition|)
name|error
argument_list|(
literal|"two `l's in integer constant"
argument_list|)
expr_stmt|;
name|spec_long
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"garbage at end of number"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|shorts
index|[
literal|7
index|]
operator||
name|shorts
index|[
literal|6
index|]
operator||
name|shorts
index|[
literal|5
index|]
operator||
name|shorts
index|[
literal|4
index|]
condition|)
name|warning
argument_list|(
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
comment|/* This is simplified by the fact that our constant 	       is always positive.  */
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
operator|(
name|shorts
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|shorts
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|shorts
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
name|shorts
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spec_long
operator|&&
operator|!
name|spec_unsigned
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|integer_type_node
argument_list|)
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long
operator|&&
name|base
operator|!=
literal|10
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|unsigned_type_node
argument_list|)
condition|)
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_integer_type_node
argument_list|)
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
else|else
block|{
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_unsigned_type_node
argument_list|)
condition|)
name|warning
argument_list|(
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
name|value
operator|=
name|CONSTANT
expr_stmt|;
break|break;
block|}
case|case
literal|'\''
case|:
name|char_constant
label|:
block|{
specifier|register
name|int
name|result
init|=
literal|0
decl_stmt|;
specifier|register
name|num_chars
operator|=
literal|0
expr_stmt|;
name|int
name|width
init|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|int
name|max_chars
decl_stmt|;
if|if
condition|(
name|wide_flag
condition|)
name|width
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|max_chars
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|/
name|width
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tryagain
label|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|readescape
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
goto|goto
name|tryagain
goto|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|unsigned
operator|)
name|c
operator|>=
operator|(
literal|1
operator|<<
name|width
operator|)
condition|)
name|warning
argument_list|(
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids newline in character constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
name|num_chars
operator|++
expr_stmt|;
if|if
condition|(
name|num_chars
operator|>
name|maxtoken
operator|-
literal|4
condition|)
name|extend_token_buffer
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|token_buffer
index|[
name|num_chars
index|]
operator|=
name|c
expr_stmt|;
comment|/* Merge character into result; ignore excess chars.  */
if|if
condition|(
name|num_chars
operator|<
name|max_chars
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
name|result
operator|=
operator|(
name|result
operator|<<
name|width
operator|)
operator||
operator|(
name|c
operator|&
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|result
operator|=
name|c
expr_stmt|;
block|}
block|}
name|token_buffer
index|[
name|num_chars
operator|+
literal|1
index|]
operator|=
literal|'\''
expr_stmt|;
name|token_buffer
index|[
name|num_chars
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\''
condition|)
name|error
argument_list|(
literal|"malformatted character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num_chars
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"empty character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num_chars
operator|>
name|max_chars
condition|)
block|{
name|num_chars
operator|=
name|max_chars
expr_stmt|;
name|error
argument_list|(
literal|"character constant too long"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_chars
operator|!=
literal|1
operator|&&
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"multi-character character constant"
argument_list|)
expr_stmt|;
comment|/* If char type is signed, sign-extend the constant.  */
if|if
condition|(
operator|!
name|wide_flag
condition|)
block|{
name|int
name|num_bits
init|=
name|num_chars
operator|*
name|width
decl_stmt|;
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|char_type_node
argument_list|)
operator|||
operator|(
operator|(
name|result
operator|>>
operator|(
name|num_bits
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
operator|&
operator|(
operator|(
name|unsigned
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_INT
operator|-
name|num_bits
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
operator||
operator|~
operator|(
operator|(
name|unsigned
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_INT
operator|-
name|num_bits
operator|)
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|char_type_node
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
name|value
operator|=
name|CONSTANT
expr_stmt|;
break|break;
block|}
case|case
literal|'"'
case|:
name|string_constant
label|:
block|{
name|int
modifier|*
name|widep
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|p
operator|=
name|token_buffer
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|wide_flag
condition|)
name|widep
operator|=
name|wide_buffer
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|readescape
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
goto|goto
name|skipnewline
goto|;
if|if
condition|(
operator|!
name|wide_flag
operator|&&
name|c
operator|>=
operator|(
literal|1
operator|<<
name|BITS_PER_UNIT
operator|)
condition|)
name|warning
argument_list|(
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids newline in string constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
comment|/* Store the char in C into the appropriate buffer.  */
if|if
condition|(
name|wide_flag
condition|)
block|{
if|if
condition|(
name|widep
operator|==
name|wide_buffer
operator|+
name|max_wide
condition|)
block|{
name|int
name|n
init|=
name|widep
operator|-
name|wide_buffer
decl_stmt|;
name|max_wide
operator|*=
literal|2
expr_stmt|;
name|wide_buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|wide_buffer
argument_list|,
name|max_wide
operator|+
literal|1
argument_list|)
expr_stmt|;
name|widep
operator|=
name|wide_buffer
operator|+
name|n
expr_stmt|;
block|}
operator|*
name|widep
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|skipnewline
label|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|"Unterminated string"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* We have read the entire constant. 	   Construct a STRING_CST for the result.  */
if|if
condition|(
name|wide_flag
condition|)
block|{
comment|/* If this is a L"..." wide-string, make a vector 	       of the ints in wide_buffer.  */
operator|*
name|widep
operator|=
literal|0
expr_stmt|;
comment|/* We have not implemented the case where `int' 	       on the target and on the execution machine differ in size.  */
name|assert
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|build_string
argument_list|(
operator|(
name|widep
operator|-
name|wide_buffer
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|wide_buffer
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|int_array_type_node
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|build_string
argument_list|(
name|p
operator|-
name|token_buffer
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|STRING
expr_stmt|;
break|break;
block|}
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
block|{
specifier|register
name|int
name|c1
decl_stmt|;
name|combine
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|yylval
operator|.
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|yylval
operator|.
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|yylval
operator|.
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|yylval
operator|.
name|code
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|yylval
operator|.
name|code
operator|=
name|TRUNC_MOD_EXPR
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
case|case
name|LSHIFT
case|:
name|yylval
operator|.
name|code
operator|=
name|LSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|RSHIFT
case|:
name|yylval
operator|.
name|code
operator|=
name|RSHIFT_EXPR
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|yylval
operator|.
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|yylval
operator|.
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
block|}
name|token_buffer
index|[
literal|1
index|]
operator|=
name|c1
operator|=
name|getch
argument_list|()
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'='
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|LE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'>'
case|:
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|GE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'!'
case|:
name|value
operator|=
name|EQCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|NE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'='
case|:
name|value
operator|=
name|EQCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|value
operator|=
name|ASSIGN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|c1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|value
operator|=
name|PLUSPLUS
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'-'
case|:
name|value
operator|=
name|MINUSMINUS
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'&'
case|:
name|value
operator|=
name|ANDAND
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'|'
case|:
name|value
operator|=
name|OROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'<'
case|:
name|c
operator|=
name|LSHIFT
expr_stmt|;
goto|goto
name|combine
goto|;
case|case
literal|'>'
case|:
name|c
operator|=
name|RSHIFT
expr_stmt|;
goto|goto
name|combine
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|c1
operator|==
literal|'>'
operator|)
condition|)
block|{
name|nextchar
operator|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|'('
condition|)
block|{
name|int
name|next_c
init|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_c
operator|==
literal|')'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|value
operator|=
name|POINTSAT_LEFT_RIGHT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ungetc
argument_list|(
name|next_c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|POINTSAT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c1
operator|==
literal|'?'
operator|&&
operator|(
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'>'
operator|)
condition|)
block|{
name|token_buffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|c1
operator|=
name|getch
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
operator|(
name|c
operator|==
literal|'<'
condition|?
name|MIN_EXPR
else|:
name|MAX_EXPR
operator|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'='
condition|)
block|{
comment|/*<?= or>?= expression.  */
name|token_buffer
index|[
literal|2
index|]
operator|=
name|c1
expr_stmt|;
name|value
operator|=
name|ASSIGN
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|MIN_MAX
expr_stmt|;
name|nextchar
operator|=
name|c1
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
condition|)
name|error
argument_list|(
literal|"use of `operator %s' is not standard C++"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nextchar
operator|=
name|c1
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'<'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'>'
operator|)
condition|)
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
else|else
name|value
operator|=
name|c
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
literal|':'
case|:
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|SCOPE
expr_stmt|;
name|yylval
operator|.
name|itype
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nextchar
operator|=
name|c
expr_stmt|;
name|value
operator|=
literal|':'
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
comment|/* Don't make yyparse think this is eof.  */
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'('
case|:
comment|/* try, weakly, to handle casts to pointers to functions.  */
name|nextchar
operator|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|'*'
condition|)
block|{
name|int
name|next_c
init|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_c
operator|==
literal|')'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|PAREN_STAR_PAREN
expr_stmt|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|next_c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|value
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* Go down for a (X::*) or (X::&).  */
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|nextchar
argument_list|)
operator|||
name|nextchar
operator|==
literal|'_'
operator|||
name|nextchar
operator|==
literal|'$'
condition|)
block|{
name|YYSTYPE
name|this_yylval
init|=
name|yylval
decl_stmt|;
name|tree
name|this_lastiddecl
init|=
name|lastiddecl
decl_stmt|;
name|nextyychar
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextyychar
operator|==
name|TYPENAME_SCOPE
condition|)
block|{
if|if
condition|(
name|nextchar
operator|<
literal|0
condition|)
name|nextchar
operator|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|'*'
operator|||
name|nextchar
operator|==
literal|'&'
condition|)
block|{
name|int
name|next_c
init|=
name|skip_white_space
argument_list|(
name|getch
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_c
operator|==
literal|')'
condition|)
block|{
name|nextyychar
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|'*'
condition|)
block|{
name|value
operator|=
name|PAREN_X_SCOPE_STAR_PAREN
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|build_parse_node
argument_list|(
name|SCOPE_REF
argument_list|,
name|yylval
operator|.
name|ttype
argument_list|,
name|build_parse_node
argument_list|(
name|INDIRECT_REF
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|PAREN_X_SCOPE_REF_PAREN
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|build_parse_node
argument_list|(
name|SCOPE_REF
argument_list|,
name|yylval
operator|.
name|ttype
argument_list|,
name|build_parse_node
argument_list|(
name|ADDR_EXPR
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|next_c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|nextyylval
operator|=
name|yylval
expr_stmt|;
name|nextlastiddecl
operator|=
name|lastiddecl
expr_stmt|;
name|yylval
operator|=
name|this_yylval
expr_stmt|;
name|lastiddecl
operator|=
name|this_lastiddecl
expr_stmt|;
name|value
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
name|nextyylval
operator|=
name|yylval
expr_stmt|;
name|nextlastiddecl
operator|=
name|lastiddecl
expr_stmt|;
name|yylval
operator|=
name|this_yylval
expr_stmt|;
name|lastiddecl
operator|=
name|this_lastiddecl
expr_stmt|;
name|value
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
name|nextyylval
operator|=
name|yylval
expr_stmt|;
name|nextlastiddecl
operator|=
name|lastiddecl
expr_stmt|;
name|yylval
operator|=
name|this_yylval
expr_stmt|;
name|lastiddecl
operator|=
name|this_lastiddecl
expr_stmt|;
name|value
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nextchar
operator|==
literal|')'
condition|)
block|{
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|NULL_TREE
expr_stmt|;
name|value
operator|=
name|LEFT_RIGHT
expr_stmt|;
block|}
else|else
name|value
operator|=
name|c
expr_stmt|;
break|break;
default|default:
name|value
operator|=
name|c
expr_stmt|;
block|}
name|done
label|:
comment|/*  yylloc.last_line = lineno; */
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|token_count
index|[
name|value
index|]
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|value
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|d_kind
block|,
name|t_kind
block|,
name|s_kind
block|,
name|r_kind
block|,
name|e_kind
block|,
name|c_kind
block|,
name|id_kind
block|,
name|op_id_kind
block|,
name|perm_list_kind
block|,
name|temp_list_kind
block|,
name|x_kind
block|,
name|lang_decl
block|,
name|lang_type
block|,
name|all_kinds
block|}
name|tree_node_kind
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|int
name|tree_node_kinds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tree_node_sizes
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tree_node_kind_names
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place to save freed lang_decls which were allocated on the    permanent_obstack.  @@ Not currently used.  */
end_comment

begin_decl_stmt
name|tree
name|free_lang_decl_chain
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|build_lang_decl
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
ifdef|#
directive|ifdef
name|LANG_DECL_PERMANENT
if|if
condition|(
name|free_lang_decl_chain
operator|&&
name|obstack
operator|==
operator|&
name|permanent_obstack
condition|)
block|{
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|free_lang_decl_chain
expr_stmt|;
name|free_lang_decl_chain
operator|=
name|TREE_CHAIN
argument_list|(
name|free_lang_decl_chain
argument_list|)
expr_stmt|;
block|}
else|else
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|i
operator|>
literal|0
condition|)
name|pi
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
ifdef|#
directive|ifdef
name|LANG_DECL_PERMANENT
name|LANG_DECL_PERMANENT
argument_list|(
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
argument_list|)
operator|=
name|obstack
operator|==
operator|&
name|permanent_obstack
expr_stmt|;
endif|#
directive|endif
name|DECL_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_ORIGINAL_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
block|{
name|DECL_LANGUAGE
argument_list|(
name|t
argument_list|)
operator|=
name|lang_cplusplus
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_AUTO_OVERLOAD
if|if
condition|(
name|code
operator|==
name|FUNCTION_DECL
operator|&&
name|name
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
operator|==
literal|4
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'m'
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
operator|>
literal|10
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|,
literal|"builtin_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|TREE_OVERLOADED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|DECL_LANGUAGE
argument_list|(
name|t
argument_list|)
operator|=
name|lang_c
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_kinds
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|build_lang_field_decl
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|build_decl
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl_flags
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
name|pi
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|tree
name|make_lang_type
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|make_node
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
name|pi
index|[
operator|--
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
operator|(
expr|struct
name|lang_type
operator|*
operator|)
name|pi
expr_stmt|;
name|CLASSTYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
operator|=
name|interface_unknown
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
comment|/* Make sure this is laid out, for ease of use later.      In the presence of parse errors, the normal was of assuring      this might not ever get executed, so we lay it out *immediately*.  */
name|build_pointer_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_kinds
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
name|copy_decl_lang_specific
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
specifier|register
name|int
modifier|*
name|old
init|=
operator|(
name|int
operator|*
operator|)
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|pi
index|[
name|i
index|]
operator|=
name|old
index|[
name|i
index|]
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|pi
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_kinds
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_decl
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|copy_type_lang_specific
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|,
modifier|*
name|saveable_obstack
decl_stmt|;
specifier|register
name|int
modifier|*
name|old
init|=
operator|(
name|int
operator|*
operator|)
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
specifier|register
name|int
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
name|pi
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|pi
index|[
name|i
index|]
operator|=
name|old
index|[
name|i
index|]
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|lang_type
operator|*
operator|)
name|pi
expr_stmt|;
name|CLASSTYPE_AS_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
name|CLASSTYPE_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_copy
argument_list|(
name|obstack
argument_list|,
name|CLASSTYPE_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|,
operator|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_kinds
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
literal|1
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|lang_type
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|tree
name|build_with_cleanup
parameter_list|(
name|exp
parameter_list|,
name|type
parameter_list|,
name|rtl
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|struct
name|rtx_def
modifier|*
name|rtl
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|!=
name|NULL_TREE
operator|||
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|rval
init|=
name|make_node
argument_list|(
name|WITH_CLEANUP_EXPR
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|0
argument_list|)
operator|=
name|exp
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|1
argument_list|)
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|2
argument_list|)
operator|=
name|build_delete
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl
operator|!=
literal|0
condition|)
name|RTL_EXPR_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|rtl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|rval
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|void
name|dump_time_statistics
parameter_list|()
block|{
specifier|register
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|decl
decl_stmt|,
name|next
decl_stmt|;
name|int
name|this_time
init|=
name|my_gettime
argument_list|()
decl_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|this_filename_time
argument_list|)
argument_list|)
operator|+=
name|this_time
operator|-
name|body_time
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"header files (total)"
argument_list|,
name|header_time
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
literal|"main file (total)"
argument_list|,
name|this_time
operator|-
name|body_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ratio = %g : 1\n"
argument_list|,
operator|(
name|double
operator|)
name|header_time
operator|/
call|(
name|double
call|)
argument_list|(
name|this_time
operator|-
name|body_time
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n******\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|filename_times
init|;
name|decl
condition|;
name|decl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|decl
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|decl
expr_stmt|;
block|}
for|for
control|(
name|decl
operator|=
name|prev
init|;
name|decl
condition|;
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|decl
argument_list|)
control|)
name|print_time
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compiler_error
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|v
decl_stmt|,
name|v2
decl_stmt|;
comment|/* @@also used as pointer */
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
name|v
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|error_with_file_and_line
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|"%s (compiler error)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compiler_error_with_decl
parameter_list|(
name|decl
parameter_list|,
name|s
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|count_error
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|report_error_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|lang_printable_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
literal|"((anonymous))"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (compiler error)\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

