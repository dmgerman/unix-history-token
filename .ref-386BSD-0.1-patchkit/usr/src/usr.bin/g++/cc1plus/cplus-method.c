begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle the hair of processing (but not expanding) inline functions.    Also manage function and varaible name overloading.    Copyright (C) 1987 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@mcc.com)     This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Handle method declarations.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cplus-tree.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_comment
comment|/* TREE_LIST of the current inline functions that need to be    processed.  */
end_comment

begin_decl_stmt
name|struct
name|pending_inline
modifier|*
name|pending_inlines
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_INLINE_BUF_SIZE
value|8188
end_define

begin_define
define|#
directive|define
name|OB_INIT
parameter_list|()
value|(inline_bufp = inline_buffer)
end_define

begin_define
define|#
directive|define
name|OB_PUTC
parameter_list|(
name|C
parameter_list|)
value|(*inline_bufp++ = (C))
end_define

begin_define
define|#
directive|define
name|OB_PUTC2
parameter_list|(
name|C1
parameter_list|,
name|C2
parameter_list|)
value|(OB_PUTC (C1), OB_PUTC (C2))
end_define

begin_define
define|#
directive|define
name|OB_PUTS
parameter_list|(
name|S
parameter_list|)
value|(strcpy (inline_bufp, S), inline_bufp += sizeof (S) - 1)
end_define

begin_define
define|#
directive|define
name|OB_PUTCP
parameter_list|(
name|S
parameter_list|)
value|(strcpy (inline_bufp, S), inline_bufp += strlen (S))
end_define

begin_define
define|#
directive|define
name|OB_FINISH
parameter_list|()
value|(*inline_bufp++ = '\0')
end_define

begin_comment
comment|/* Counter to help build parameter names in case they were omitted.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dummy_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_parmlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Just a pointer into INLINE_BUFFER.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inline_bufp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also a pointer into INLINE_BUFFER.  This points to a safe place to    cut back to if we assign it 0, in case of error.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inline_errp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inline_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_type
argument_list|()
decl_stmt|,
name|dump_decl
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_init
argument_list|()
decl_stmt|,
name|dump_unary_op
argument_list|()
decl_stmt|,
name|dump_binary_op
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|wrapper_name
decl_stmt|,
name|wrapper_pred_name
decl_stmt|,
name|anti_wrapper_name
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_AUTO_OVERLOAD
end_ifdef

begin_function_decl
name|int
name|is_overloaded
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|init_method
parameter_list|()
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|ANTI_WRAPPER_NAME_FORMAT
argument_list|)
operator|+
literal|8
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|WRAPPER_NAME_FORMAT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|wrapper_name
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|WRAPPER_PRED_NAME_FORMAT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|wrapper_pred_name
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|ANTI_WRAPPER_NAME_FORMAT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|anti_wrapper_name
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the end of the new text in INLINE_BUFFER.    We cannot use `fatal' or `error' in here because that    might cause an infinite loop.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|new_text_len
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|s
operator|>=
name|inline_buffer
operator|+
name|MAX_INLINE_BUF_SIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recompile c++ with larger MAX_INLINE_BUF_SIZE (%d)"
argument_list|,
name|MAX_INLINE_BUF_SIZE
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|s
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check that we have not overflowed INLINE_BUFFER.    We cannot use `fatal' or `error' in here because that    might cause an infinite loop.  */
end_comment

begin_function
specifier|static
name|void
name|check_text_len
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|>=
name|inline_buffer
operator|+
name|MAX_INLINE_BUF_SIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recompile c++ with larger MAX_INLINE_BUF_SIZE (%d)"
argument_list|,
name|MAX_INLINE_BUF_SIZE
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tree
name|make_anon_parm_name
parameter_list|()
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|ANON_PARMNAME_FORMAT
argument_list|,
name|dummy_name
operator|++
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|clear_anon_parm_name
parameter_list|()
block|{
comment|/* recycle these names.  */
name|dummy_name
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_readonly_or_volatile
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_type_prefix
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|old_p
init|=
literal|0
decl_stmt|;
name|int
name|print_struct
init|=
literal|1
decl_stmt|;
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
name|ANON_PARMNAME_FORMAT
argument_list|,
name|dummy_name
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN_TYPE
case|:
name|OB_PUTS
argument_list|(
literal|"<unknown type>"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TREE_LIST
case|:
name|dump_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|!=
name|void_list_node
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
return|return;
case|case
name|POINTER_TYPE
case|:
operator|*
name|p
operator|+=
literal|1
expr_stmt|;
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile "
argument_list|)
expr_stmt|;
return|return;
case|case
name|OFFSET_TYPE
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_parmlist
condition|)
name|OB_PUTS
argument_list|(
literal|"auto "
argument_list|)
expr_stmt|;
block|}
name|dump_type_prefix
argument_list|(
name|type
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|in_parmlist
condition|)
name|OB_PUTS
argument_list|(
literal|"auto "
argument_list|)
expr_stmt|;
name|dump_type_prefix
argument_list|(
name|type
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|':'
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|REFERENCE_TYPE
case|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
name|in_parmlist
condition|)
name|OB_PUTS
argument_list|(
literal|"auto "
argument_list|)
expr_stmt|;
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
case|case
name|IDENTIFIER_NODE
case|:
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
condition|)
name|print_struct
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_struct
condition|)
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"struct %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"class %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile "
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"union %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"enum %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
comment|/* Normally, `unsigned' is part of the deal.  Not so if it comes 	 with `const' or `volatile'.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|OB_PUTS
argument_list|(
literal|"unsigned "
argument_list|)
expr_stmt|;
comment|/* fall through.  */
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"const "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"volatile "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"%s "
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|inline_bufp
operator|=
name|new_text_len
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_type_suffix
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|old_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
name|ANON_PARMNAME_FORMAT
argument_list|,
name|dummy_name
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN_TYPE
case|:
return|return;
case|case
name|POINTER_TYPE
case|:
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|OFFSET_TYPE
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|#
directive|if
literal|0
block|tree next_arg = TREE_CHAIN (TYPE_ARG_TYPES (type)); 	    OB_PUTC ('('); 	    if (next_arg) 	      { 		if (next_arg != void_list_node) 		  { 		    in_parmlist++; 		    dump_type (next_arg,&old_p); 		    in_parmlist--; 		  } 	      } 	    else OB_PUTS ("..."); 	    OB_PUTC (')'); 	    dump_type_suffix (TREE_TYPE (type), p);
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|next_arg
decl_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|next_arg
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_arg
condition|)
block|{
if|if
condition|(
name|next_arg
operator|!=
name|void_list_node
condition|)
block|{
name|in_parmlist
operator|++
expr_stmt|;
name|dump_type
argument_list|(
name|next_arg
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|in_parmlist
operator|--
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|dump_readonly_or_volatile
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|REFERENCE_TYPE
case|:
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|'['
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
return|return;
case|case
name|FUNCTION_TYPE
case|:
name|OB_PUTC2
argument_list|(
literal|')'
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|!=
name|void_list_node
condition|)
block|{
name|in_parmlist
operator|++
expr_stmt|;
name|dump_type
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
name|in_parmlist
operator|--
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|inline_bufp
operator|=
name|new_text_len
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_type
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|old_p
init|=
literal|0
decl_stmt|;
name|int
name|print_struct
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
name|ANON_PARMNAME_FORMAT
argument_list|,
name|dummy_name
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN_TYPE
case|:
name|OB_PUTS
argument_list|(
literal|"<unknown type>"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TREE_LIST
case|:
name|dump_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|!=
name|void_list_node
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|old_p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
return|return;
case|case
name|POINTER_TYPE
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|p
operator|+=
literal|1
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|-=
literal|1
expr_stmt|;
block|}
return|return;
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|'['
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
return|return;
case|case
name|OFFSET_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
name|dump_type_prefix
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dump_type_suffix
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|IDENTIFIER_NODE
case|:
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
condition|)
name|print_struct
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|t
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_struct
condition|)
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"struct %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"class %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UNION_TYPE
case|:
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|t
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"union %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENUMERAL_TYPE
case|:
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|t
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"enum %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
comment|/* Normally, `unsigned' is part of the deal.  Not so if it comes 	 with `const' or `volatile'.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator||
name|TREE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|OB_PUTS
argument_list|(
literal|"unsigned "
argument_list|)
expr_stmt|;
comment|/* fall through.  */
case|case
name|REAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"%s "
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|inline_bufp
operator|=
name|new_text_len
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_decl
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|strcpy
argument_list|(
name|inline_bufp
argument_list|,
literal|" /* decl error */ "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|dump_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
name|ANON_PARMNAME_FORMAT
argument_list|,
name|dummy_name
operator|++
argument_list|)
expr_stmt|;
break|break;
block|}
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL_EXPR
case|:
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|in_parmlist
operator|++
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|in_parmlist
operator|--
expr_stmt|;
name|t
operator|=
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|t
operator|!=
name|void_list_node
condition|)
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|ARRAY_REF
case|:
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
return|return;
case|case
name|TYPE_DECL
case|:
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_EXPR
case|:
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|OPERATOR_NAME_P
argument_list|(
name|t
argument_list|)
condition|)
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"operator %s "
argument_list|,
name|operator_name_string
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|OPERATOR_TYPENAME_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_NOT_EXPR
case|:
name|OB_PUTC2
argument_list|(
literal|'~'
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCOPE_REF
case|:
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"%s :: "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|inline_bufp
operator|+=
sizeof|sizeof
argument_list|(
literal|"%s :: "
argument_list|)
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|INDIRECT_REF
case|:
name|OB_PUTC
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_EXPR
case|:
name|OB_PUTC
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|inline_bufp
operator|=
name|new_text_len
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_init_list
parameter_list|(
name|l
parameter_list|)
name|tree
name|l
decl_stmt|;
block|{
while|while
condition|(
name|l
condition|)
block|{
name|dump_init
argument_list|(
name|TREE_VALUE
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|l
operator|=
name|TREE_CHAIN
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_init
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|int
name|dummy
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|" ~%s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|OPERATOR_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"operator %s "
argument_list|,
name|operator_name_string
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|OPERATOR_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|dummy
operator|=
literal|0
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
if|else if (WRAPPER_NAME_P (name)) 	  sprintf (inline_bufp, " ()%s ", 		   IDENTIFIER_POINTER (DECL_ORIGINAL_NAME (t))); 	else if (WRAPPER_PRED_NAME_P (name)) 	  sprintf (inline_bufp, " ()?%s ", 		   IDENTIFIER_POINTER (DECL_ORIGINAL_NAME (t))); 	else if (ANTI_WRAPPER_NAME_P (name)) 	  sprintf (inline_bufp, " ~()%s ", 		   IDENTIFIER_POINTER (DECL_ORIGINAL_NAME (t)));
endif|#
directive|endif
else|else
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|" %s "
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST_DECL
case|:
name|dummy
operator|=
literal|0
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|'('
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|INTEGER_CST
case|:
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|" %d "
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|" %g "
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
block|{
name|char
modifier|*
name|p
init|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|check_text_len
argument_list|(
name|inline_bufp
operator|+
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|char
name|c
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|OB_PUTC
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
name|OB_PUTC
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|inline_bufp
operator|=
name|new_text_len
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
block|}
block|}
name|OB_PUTC
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|COMPOUND_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|","
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" ? "
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" : "
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|SAVE_EXPR
case|:
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|dummy
operator|=
literal|0
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|"new "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|PARM_DECL_EXPR
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sorry
argument_list|(
literal|"operand of SAVE_EXPR not understood"
argument_list|)
expr_stmt|;
operator|*
name|inline_errp
operator|=
literal|'\0'
expr_stmt|;
name|inline_bufp
operator|=
name|inline_errp
operator|+
literal|1
expr_stmt|;
block|}
return|return;
case|case
name|NEW_EXPR
case|:
name|strcpy
argument_list|(
name|inline_bufp
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|inline_bufp
operator|=
name|new_text_len
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_init_list
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL_EXPR
case|:
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dump_init_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|MODIFY_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|dump_binary_op
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|t
argument_list|,
name|strlen
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|"/"
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
name|dump_binary_op
argument_list|(
literal|"%"
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|COMPONENT_REF
case|:
name|dump_binary_op
argument_list|(
literal|"."
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONVERT_EXPR
case|:
name|dump_unary_op
argument_list|(
literal|"+"
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dump_unary_op
argument_list|(
literal|"&"
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|INDIRECT_REF
case|:
name|dump_unary_op
argument_list|(
literal|"*"
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
name|dump_unary_op
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|t
argument_list|,
name|strlen
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTCP
argument_list|(
name|opname_tab
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|NOP_EXPR
case|:
name|dummy
operator|=
literal|0
expr_stmt|;
name|OB_PUTC2
argument_list|(
literal|'('
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONSTRUCTOR
case|:
name|OB_PUTC
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|dump_init_list
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return;
comment|/*  This list is incomplete, but should suffice for now. 	  It is very important that `sorry' does not call 	  `report_error_function'.  That could cause an infinite loop.  */
default|default:
name|sorry
argument_list|(
literal|"that operation not supported for default parameters"
argument_list|)
expr_stmt|;
comment|/* fall through to ERROR_MARK...  */
case|case
name|ERROR_MARK
case|:
operator|*
name|inline_errp
operator|=
literal|'\0'
expr_stmt|;
name|inline_bufp
operator|=
name|inline_errp
operator|+
literal|1
expr_stmt|;
return|return;
block|}
name|inline_bufp
operator|=
name|new_text_len
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_binary_op
parameter_list|(
name|opstring
parameter_list|,
name|t
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|opstring
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|" %s "
argument_list|,
name|opstring
argument_list|)
expr_stmt|;
name|inline_bufp
operator|+=
name|len
operator|+
literal|2
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|check_text_len
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_unary_op
parameter_list|(
name|opstring
parameter_list|,
name|t
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|opstring
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|" %s "
argument_list|,
name|opstring
argument_list|)
expr_stmt|;
name|inline_bufp
operator|+=
name|len
operator|+
literal|2
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|check_text_len
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DO_METHODS_THE_OLD_WAY
end_ifdef

begin_comment
comment|/* Process the currently pending inline function definitions.    This entails:    (1) Creating a temporary file which contains return type,        delarator name, and argment names and types of the        function to be inlined.    (2) Reading that file into a buffer which can then be        made to look line another piece of inline code to        process, stuffing that on the top of the inline        stack, then letting the lexer and parser read from those        two. */
end_comment

begin_function
specifier|static
name|struct
name|pending_inline
modifier|*
name|stash_inline_prefix
parameter_list|(
name|cname
parameter_list|,
name|field
parameter_list|)
name|tree
name|cname
decl_stmt|,
name|field
decl_stmt|;
block|{
specifier|extern
name|int
name|lineno
decl_stmt|;
name|struct
name|pending_inline
modifier|*
name|t
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|fndecl
decl_stmt|,
name|fntype
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
name|inline_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|MAX_INLINE_BUF_SIZE
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dummy_name
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|DECL_ORIGINAL_NAME
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|/* We still don't do friends right.  */
name|fndecl
operator|=
name|field
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_INLINE
argument_list|(
name|fndecl
argument_list|)
condition|)
name|strcpy
argument_list|(
name|inline_buffer
argument_list|,
literal|"inline "
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|inline_buffer
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
name|inline_bufp
operator|=
name|inline_buffer
operator|+
name|strlen
argument_list|(
name|inline_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OPERATOR_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|dump_type
argument_list|(
name|cname
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|inline_bufp
index|[
operator|-
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
operator|*
name|inline_bufp
operator|++
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|else if (WRAPPER_NAME_P (DECL_NAME (fndecl))) 	OB_PUTC2 ('(', ')');       else if (WRAPPER_PRED_NAME_P (DECL_NAME (fndecl))) 	OB_PUTS ("()?");       else if (ANTI_WRAPPER_NAME_P (DECL_NAME (fndecl))) 	OB_PUTS ("~()");
endif|#
directive|endif
block|}
name|dump_decl
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|parmlist
init|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|typelist
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|parmlist
operator|=
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|typelist
operator|=
name|TREE_CHAIN
argument_list|(
name|typelist
argument_list|)
expr_stmt|;
block|}
name|in_parmlist
operator|++
expr_stmt|;
while|while
condition|(
name|parmlist
condition|)
block|{
name|dump_decl
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (TREE_PURPOSE (typelist)) 	    { 	      inline_errp = inline_bufp; 	      OB_PUTS (" = ("); 	      dump_init (TREE_PURPOSE (typelist)); 	      OB_PUTC (')'); 	      if (*inline_errp == '\0') 		inline_bufp = inline_errp; 	    }
endif|#
directive|endif
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
condition|)
name|OB_PUTC
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|typelist
operator|=
name|TREE_CHAIN
argument_list|(
name|typelist
argument_list|)
expr_stmt|;
block|}
name|in_parmlist
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|typelist
operator|||
name|typelist
operator|!=
name|void_list_node
condition|)
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OPERATOR_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|{
specifier|extern
name|tree
name|value_identifier
decl_stmt|;
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|value_identifier
condition|)
block|{
name|tree
name|result
init|=
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|OB_PUTS
argument_list|(
literal|"return "
argument_list|)
expr_stmt|;
name|OB_PUTS
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|DECL_INITIAL
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|OB_FINISH
argument_list|()
expr_stmt|;
name|check_text_len
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
expr|struct
name|pending_inline
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_inline
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|len
operator|=
name|inline_bufp
operator|-
name|inline_buffer
expr_stmt|;
name|t
operator|->
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|t
operator|->
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|inline_buffer
argument_list|,
name|t
operator|->
name|buf
argument_list|,
name|t
operator|->
name|len
argument_list|)
expr_stmt|;
name|t
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|t
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|t
operator|->
name|token
operator|=
literal|0
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OVERLOAD_MAX_LEN
value|1024
end_define

begin_comment
comment|/* Pretty printing for announce_function.  If BUF is nonzero, then    the text is written there.  The buffer is assued to be of size    OVERLOAD_MAX_LEN.  CNAME is the name of the class that FNDECL    belongs to, if we could not figure that out from FNDECL    itself.  FNDECL is the declaration of the function we    are interested in seeing.  PRINT_RET_TYPE_P is non-zero if    we should print the type that this function returns.  */
end_comment

begin_function
name|char
modifier|*
name|fndecl_as_string
parameter_list|(
name|buf
parameter_list|,
name|cname
parameter_list|,
name|fndecl
parameter_list|,
name|print_ret_type_p
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|tree
name|cname
decl_stmt|,
name|fndecl
decl_stmt|;
name|int
name|print_ret_type_p
decl_stmt|;
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|parmtypes
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
name|int
name|spaces
init|=
literal|0
decl_stmt|;
name|inline_buffer
operator|=
name|buf
expr_stmt|;
name|OB_INIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|cname
operator|=
name|TYPE_NAME
argument_list|(
name|DECL_STATIC_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cname
operator|&&
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|cname
operator|=
name|TYPE_NAME
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_ret_type_p
operator|&&
operator|!
name|OPERATOR_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|dump_type_prefix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|OB_PUTS
argument_list|(
literal|"static "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cname
condition|)
block|{
name|dump_type
argument_list|(
name|cname
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|inline_bufp
index|[
operator|-
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
operator|*
name|inline_bufp
operator|++
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|parmtypes
condition|)
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_FOR_VBASE_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|OB_PUTC
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
name|dump_decl
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OPERATOR_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"operator %s "
argument_list|,
name|operator_name_string
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|inline_bufp
operator|+=
name|strlen
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OPERATOR_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* This cannot use the hack that the operator's return 	 type is stashed off of its name because it may be 	 used for error reporting.  In the case of conflicting 	 declarations, both will have the same name, yet 	 the types will be different, hence the TREE_TYPE field 	 of the first name will be clobbered by the second.  */
name|OB_PUTS
argument_list|(
literal|"operator "
argument_list|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SOS
if|if
condition|(
name|TYPE_DYNAMIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|OB_PUTS
argument_list|(
literal|"dynamic "
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dump_decl
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip past "in_charge" identifier.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cname
argument_list|)
argument_list|)
condition|)
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|if (WRAPPER_NAME_P (name)) 	OB_PUTC2 ('(', ')');       if (WRAPPER_PRED_NAME_P (name)) 	OB_PUTS ("()?");       else if (ANTI_WRAPPER_NAME_P (name)) 	OB_PUTS ("~()");
endif|#
directive|endif
name|dump_decl
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmtypes
condition|)
block|{
name|in_parmlist
operator|++
expr_stmt|;
if|if
condition|(
name|parmtypes
operator|!=
name|void_list_node
condition|)
name|spaces
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|parmtypes
operator|&&
name|parmtypes
operator|!=
name|void_list_node
condition|)
block|{
name|dump_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|inline_bufp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|inline_bufp
operator|--
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
condition|)
block|{
name|inline_errp
operator|=
name|inline_bufp
expr_stmt|;
name|OB_PUTS
argument_list|(
literal|" (= "
argument_list|)
expr_stmt|;
name|dump_init
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
name|OB_PUTC2
argument_list|(
literal|','
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
name|in_parmlist
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|parmtypes
condition|)
name|inline_bufp
operator|-=
name|spaces
expr_stmt|;
else|else
name|OB_PUTS
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
name|OB_PUTC
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_ret_type_p
operator|&&
operator|!
name|OPERATOR_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|dump_type_suffix
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|dump_readonly_or_volatile
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
name|check_text_len
argument_list|(
name|inline_bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>=
name|OVERLOAD_MAX_LEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fndecl_as_string returns something too large"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FIELD_XREF
end_ifdef

begin_function
name|char
modifier|*
name|type_as_string
parameter_list|(
name|buf
parameter_list|,
name|typ
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|tree
name|typ
decl_stmt|;
block|{
name|int
name|p
init|=
literal|0
decl_stmt|;
name|int
name|spaces
init|=
literal|0
decl_stmt|;
name|inline_buffer
operator|=
name|buf
expr_stmt|;
name|OB_INIT
argument_list|()
expr_stmt|;
name|dump_type
argument_list|(
name|typ
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Move inline function defintions out of structure so that they    can be processed normally.  CNAME is the name of the class    we are working from, METHOD_LIST is the list of method lists    of the structure.  We delete friend methods here, after    saving away their inline function definitions (if any).  */
end_comment

begin_comment
comment|/* Subroutine of `do_inline_function_hair'.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_inline
parameter_list|(
name|cname
parameter_list|,
name|fndecl
parameter_list|)
name|tree
name|cname
decl_stmt|,
name|fndecl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|struct
name|pending_inline
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|t2
operator|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|t2
operator|->
name|next
operator|=
name|pending_inlines
expr_stmt|;
name|t2
operator|->
name|fndecl
operator|=
name|fndecl
expr_stmt|;
name|args
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|args
argument_list|)
operator|=
name|fndecl
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DO_METHODS_THE_OLD_WAY
name|t1
operator|=
name|stash_inline_prefix
argument_list|(
name|cname
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|t1
operator|->
name|next
operator|=
name|t2
expr_stmt|;
else|#
directive|else
name|t1
operator|=
name|t2
expr_stmt|;
endif|#
directive|endif
name|pending_inlines
operator|=
name|t1
expr_stmt|;
comment|/* Allow this decl to be seen in global scope */
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|do_inline_function_hair
parameter_list|(
name|type
parameter_list|,
name|friend_list
parameter_list|)
name|tree
name|type
decl_stmt|,
name|friend_list
decl_stmt|;
block|{
name|tree
name|cname
init|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
name|tree
modifier|*
name|methods
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|end
init|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
while|while
condition|(
name|methods
operator|!=
name|end
condition|)
block|{
comment|/* Do inline member functions.  */
name|tree
name|method
init|=
operator|*
name|methods
decl_stmt|;
while|while
condition|(
name|method
condition|)
block|{
name|prepare_inline
argument_list|(
name|cname
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|method
operator|=
name|TREE_CHAIN
argument_list|(
name|method
argument_list|)
expr_stmt|;
block|}
name|methods
operator|++
expr_stmt|;
block|}
block|}
while|while
condition|(
name|friend_list
condition|)
block|{
name|prepare_inline
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|friend_list
argument_list|)
argument_list|)
expr_stmt|;
name|friend_list
operator|=
name|TREE_CHAIN
argument_list|(
name|friend_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report a argument type mismatch between the best declared function    we could find and the current argument list that we have.  */
end_comment

begin_function
name|void
name|report_type_mismatch
parameter_list|(
name|cp
parameter_list|,
name|parmtypes
parameter_list|,
name|name_kind
parameter_list|,
name|err_name
parameter_list|)
name|struct
name|candidate
modifier|*
name|cp
decl_stmt|;
name|tree
name|parmtypes
decl_stmt|;
name|char
modifier|*
name|name_kind
decl_stmt|,
decl|*
name|err_name
decl_stmt|;
end_function

begin_block
block|{
name|char
name|buf
index|[
name|OVERLOAD_MAX_LEN
index|]
decl_stmt|;
name|int
name|i
init|=
name|cp
operator|->
name|u
operator|.
name|bad_arg
decl_stmt|;
name|tree
name|ttf
decl_stmt|,
name|tta
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|3
condition|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"call to const %s `%s' with non-const object"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"call to non-const %s `%s' with const object"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"too few arguments for %s `%s'"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"too many arguments for %s `%s'"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* Happens when we have an ambiguous base class.  */
name|assert
argument_list|(
name|get_base_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|tta
operator|=
name|parmtypes
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
expr_stmt|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
block|}
name|fndecl_as_string
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|cp
operator|->
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inline_bufp
operator|=
name|inline_buffer
operator|+
name|strlen
argument_list|(
name|inline_buffer
argument_list|)
operator|+
literal|1
expr_stmt|;
name|inline_buffer
operator|=
name|inline_bufp
expr_stmt|;
comment|/* Reset `i' so that type printing routines do the right thing.  */
if|if
condition|(
name|tta
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
name|OB_PUTS
argument_list|(
literal|"(failed type instatiation)"
argument_list|)
expr_stmt|;
else|else
block|{
name|i
operator|=
operator|(
name|code
operator|==
name|FUNCTION_TYPE
operator|||
name|code
operator|==
name|METHOD_TYPE
operator|)
expr_stmt|;
name|dump_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OB_PUTS
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
name|OB_FINISH
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|inline_bufp
argument_list|,
literal|"bad argument %d for function `%s' (type was %s)"
argument_list|,
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|-
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
argument_list|,
name|buf
argument_list|,
name|inline_buffer
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|inline_bufp
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Here is where overload code starts.  */
end_comment

begin_define
define|#
directive|define
name|OVERLOAD_MAX_LEN
value|1024
end_define

begin_comment
comment|/* Array of types seen so far in top-level call to `build_overload_name'.    Allocated and deallocated by caller.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|typevec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of types interned by `build_overload_name' so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of occurances of last type seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nrepeats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should not try folding parameter types.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nofold
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ALLOCATE_TYPEVEC
parameter_list|(
name|PARMTYPES
parameter_list|)
define|\
value|do { maxtype = 0, nrepeats = 0; \        typevec = (tree *)alloca (list_length (PARMTYPES) * sizeof (tree)); } while (0)
end_define

begin_define
define|#
directive|define
name|DEALLOCATE_TYPEVEC
parameter_list|(
name|PARMTYPES
parameter_list|)
define|\
value|do { tree t = (PARMTYPES); \        while (t) { TREE_USED (TREE_VALUE (t)) = 0; t = TREE_CHAIN (t); } \   } while (0)
end_define

begin_comment
comment|/* Code to concatenate an asciified integer to a string,    and return the end of the string.  */
end_comment

begin_function
specifier|static
ifdef|#
directive|ifdef
name|__GNUC__
name|__inline
endif|#
directive|endif
name|char
modifier|*
name|icat
parameter_list|(
name|s
parameter_list|,
name|i
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|<
literal|10
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
name|i
expr_stmt|;
return|return
name|s
return|;
block|}
name|s
operator|=
name|icat
argument_list|(
name|s
argument_list|,
name|i
operator|/
literal|10
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|i
operator|%
literal|10
operator|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
ifdef|#
directive|ifdef
name|__GNUC__
name|__inline
endif|#
directive|endif
name|char
modifier|*
name|flush_repeats
parameter_list|(
name|s
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
name|tindex
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|rval
decl_stmt|;
while|while
condition|(
name|typevec
index|[
name|tindex
index|]
operator|!=
name|type
condition|)
name|tindex
operator|++
expr_stmt|;
if|if
condition|(
name|nrepeats
operator|>
literal|1
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'N'
expr_stmt|;
name|s
operator|=
name|icat
argument_list|(
name|s
argument_list|,
name|nrepeats
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrepeats
operator|>
literal|9
condition|)
operator|*
name|s
operator|++
operator|=
literal|'_'
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|++
operator|=
literal|'T'
expr_stmt|;
name|nrepeats
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
name|icat
argument_list|(
name|s
argument_list|,
name|tindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|tindex
operator|>
literal|9
condition|)
operator|*
name|rval
operator|++
operator|=
literal|'_'
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Given a list of parameters in PARMS, and a buffer in TEXT, of    length LEN bytes, create an unambiguous overload string. Should    distinguish any type that C (or C++) can distinguish. I.e.,    pointers to functions are treated correctly.     Caller must deal with whether a final `e' goes on the end or not.     Any default conversions must take place before this function    is called.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_overload_name
parameter_list|(
name|parmtypes
parameter_list|,
name|text
parameter_list|,
name|text_end
parameter_list|)
name|tree
name|parmtypes
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|,
decl|*
name|text_end
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|textp
init|=
name|text
decl_stmt|;
name|int
name|just_one
decl_stmt|;
name|tree
name|parmtype
decl_stmt|;
if|if
condition|(
name|just_one
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|parmtypes
argument_list|)
operator|!=
name|TREE_LIST
operator|)
condition|)
block|{
name|parmtype
operator|=
name|parmtypes
expr_stmt|;
goto|goto
name|only_one
goto|;
block|}
while|while
condition|(
name|parmtypes
condition|)
block|{
if|if
condition|(
name|text_end
operator|-
name|text
operator|<
literal|4
condition|)
name|fatal
argument_list|(
literal|"Out of string space in build_overload_name!"
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
name|only_one
label|:
if|if
condition|(
operator|!
name|nofold
condition|)
block|{
if|if
condition|(
operator|!
name|just_one
condition|)
comment|/* Every argument gets counted.  */
name|typevec
index|[
name|maxtype
operator|++
index|]
operator|=
name|parmtype
expr_stmt|;
if|if
condition|(
name|TREE_USED
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|just_one
operator|&&
name|parmtype
operator|==
name|typevec
index|[
name|maxtype
operator|-
literal|2
index|]
condition|)
name|nrepeats
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|nrepeats
condition|)
name|textp
operator|=
name|flush_repeats
argument_list|(
name|textp
argument_list|,
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|just_one
operator|&&
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|&&
name|parmtype
operator|==
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
condition|)
name|nrepeats
operator|++
expr_stmt|;
else|else
block|{
name|int
name|tindex
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|typevec
index|[
name|tindex
index|]
operator|!=
name|parmtype
condition|)
name|tindex
operator|++
expr_stmt|;
operator|*
name|textp
operator|++
operator|=
literal|'T'
expr_stmt|;
name|textp
operator|=
name|icat
argument_list|(
name|textp
argument_list|,
name|tindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|tindex
operator|>
literal|9
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'_'
expr_stmt|;
block|}
block|}
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|nrepeats
condition|)
name|textp
operator|=
name|flush_repeats
argument_list|(
name|textp
argument_list|,
name|typevec
index|[
name|maxtype
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|just_one
comment|/* Only cache types which take more than one character.  */
operator|&&
operator|(
name|parmtype
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|!=
name|REAL_TYPE
operator|)
operator|)
condition|)
name|TREE_USED
argument_list|(
name|parmtype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|parmtype
argument_list|)
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'C'
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|parmtype
argument_list|)
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'U'
expr_stmt|;
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|parmtype
argument_list|)
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'V'
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
case|case
name|OFFSET_TYPE
case|:
operator|*
name|textp
operator|++
operator|=
literal|'O'
expr_stmt|;
name|textp
operator|=
name|build_overload_name
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
name|textp
argument_list|,
name|text_end
argument_list|)
expr_stmt|;
operator|*
name|textp
operator|++
operator|=
literal|'_'
expr_stmt|;
name|textp
operator|=
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
name|textp
argument_list|,
name|text_end
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFERENCE_TYPE
case|:
operator|*
name|textp
operator|++
operator|=
literal|'R'
expr_stmt|;
goto|goto
name|more
goto|;
case|case
name|ARRAY_TYPE
case|:
ifdef|#
directive|ifdef
name|PARM_CAN_BE_ARRAY_TYPE
block|{
name|tree
name|length
decl_stmt|;
operator|*
name|textp
operator|++
operator|=
literal|'A'
expr_stmt|;
name|length
operator|=
name|array_type_nelts
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|length
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|textp
operator|=
name|icat
argument_list|(
name|textp
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|textp
operator|++
operator|=
literal|'_'
expr_stmt|;
goto|goto
name|more
goto|;
block|}
else|#
directive|else
operator|*
name|textp
operator|++
operator|=
literal|'P'
expr_stmt|;
goto|goto
name|more
goto|;
endif|#
directive|endif
case|case
name|POINTER_TYPE
case|:
operator|*
name|textp
operator|++
operator|=
literal|'P'
expr_stmt|;
name|more
label|:
name|textp
operator|=
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
name|textp
argument_list|,
name|text_end
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|firstarg
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
comment|/* Otherwise have to implement reentrant typevecs, 	       unmark and remark types, etc.  */
name|int
name|old_nofold
init|=
name|nofold
decl_stmt|;
name|nofold
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nrepeats
condition|)
name|textp
operator|=
name|flush_repeats
argument_list|(
name|textp
argument_list|,
name|typevec
index|[
name|maxtype
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* @@ It may be possible to pass a function type in 	       which is not preceded by a 'P'.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
operator|*
name|textp
operator|++
operator|=
literal|'F'
expr_stmt|;
if|if
condition|(
name|firstarg
operator|==
name|NULL_TREE
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'e'
expr_stmt|;
elseif|else
if|if
condition|(
name|firstarg
operator|==
name|void_list_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'v'
expr_stmt|;
else|else
name|textp
operator|=
name|build_overload_name
argument_list|(
name|firstarg
argument_list|,
name|textp
argument_list|,
name|text_end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|constp
init|=
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|volatilep
init|=
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|textp
operator|++
operator|=
literal|'M'
expr_stmt|;
name|firstarg
operator|=
name|TREE_CHAIN
argument_list|(
name|firstarg
argument_list|)
expr_stmt|;
name|textp
operator|=
name|build_overload_name
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
name|textp
argument_list|,
name|text_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'C'
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'V'
expr_stmt|;
comment|/* For cfront 2.0 compatability.  */
operator|*
name|textp
operator|++
operator|=
literal|'F'
expr_stmt|;
if|if
condition|(
name|firstarg
operator|==
name|NULL_TREE
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'e'
expr_stmt|;
elseif|else
if|if
condition|(
name|firstarg
operator|==
name|void_list_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'v'
expr_stmt|;
else|else
name|textp
operator|=
name|build_overload_name
argument_list|(
name|firstarg
argument_list|,
name|textp
argument_list|,
name|text_end
argument_list|)
expr_stmt|;
block|}
comment|/* Separate args from return type.  */
operator|*
name|textp
operator|++
operator|=
literal|'_'
expr_stmt|;
name|textp
operator|=
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
name|textp
argument_list|,
name|text_end
argument_list|)
expr_stmt|;
name|nofold
operator|=
name|old_nofold
expr_stmt|;
break|break;
block|}
case|case
name|INTEGER_TYPE
case|:
name|parmtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_MODE
argument_list|(
name|parmtype
argument_list|)
condition|)
block|{
case|case
name|TImode
case|:
if|if
condition|(
name|parmtype
operator|==
name|long_integer_type_node
operator|||
name|parmtype
operator|==
name|long_unsigned_type_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'l'
expr_stmt|;
else|else
operator|*
name|textp
operator|++
operator|=
literal|'q'
expr_stmt|;
break|break;
case|case
name|DImode
case|:
if|if
condition|(
name|parmtype
operator|==
name|long_integer_type_node
operator|||
name|parmtype
operator|==
name|long_unsigned_type_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'l'
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|integer_type_node
operator|||
name|parmtype
operator|==
name|unsigned_type_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'i'
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|short_integer_type_node
operator|||
name|parmtype
operator|==
name|short_unsigned_type_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'s'
expr_stmt|;
else|else
operator|*
name|textp
operator|++
operator|=
literal|'x'
expr_stmt|;
break|break;
case|case
name|SImode
case|:
if|if
condition|(
name|parmtype
operator|==
name|long_integer_type_node
operator|||
name|parmtype
operator|==
name|long_unsigned_type_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'l'
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|short_integer_type_node
operator|||
name|parmtype
operator|==
name|short_unsigned_type_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'s'
expr_stmt|;
else|else
operator|*
name|textp
operator|++
operator|=
literal|'i'
expr_stmt|;
break|break;
case|case
name|HImode
case|:
if|if
condition|(
name|parmtype
operator|==
name|integer_type_node
operator|||
name|parmtype
operator|==
name|unsigned_type_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'i'
expr_stmt|;
else|else
operator|*
name|textp
operator|++
operator|=
literal|'s'
expr_stmt|;
break|break;
case|case
name|QImode
case|:
operator|*
name|textp
operator|++
operator|=
literal|'c'
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|REAL_TYPE
case|:
name|parmtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmtype
operator|==
name|long_double_type_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'r'
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|double_type_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'d'
expr_stmt|;
elseif|else
if|if
condition|(
name|parmtype
operator|==
name|float_type_node
condition|)
operator|*
name|textp
operator|++
operator|=
literal|'f'
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
if|if
condition|(
operator|!
name|just_one
condition|)
block|{
if|#
directive|if
literal|0
block|extern tree void_list_node;
comment|/* See if anybody is wasting memory.  */
block|assert (parmtypes == void_list_node);
endif|#
directive|endif
comment|/* This is the end of a parameter list.  */
operator|*
name|textp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|textp
return|;
block|}
operator|*
name|textp
operator|++
operator|=
literal|'v'
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
comment|/* not right, but nothing is anyway */
break|break;
comment|/* have to do these */
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
operator|!
name|just_one
condition|)
comment|/* Make this type signature look incompatible 	       with AT&T.  */
operator|*
name|textp
operator|++
operator|=
literal|'G'
expr_stmt|;
goto|goto
name|common
goto|;
case|case
name|ENUMERAL_TYPE
case|:
name|common
label|:
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
name|textp
operator|=
name|icat
argument_list|(
name|textp
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|textp
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|textp
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UNKNOWN_TYPE
case|:
comment|/* This will take some work.  */
operator|*
name|textp
operator|++
operator|=
literal|'?'
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|next
label|:
if|if
condition|(
name|just_one
condition|)
break|break;
name|parmtypes
operator|=
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|just_one
condition|)
block|{
if|if
condition|(
name|nrepeats
condition|)
name|textp
operator|=
name|flush_repeats
argument_list|(
name|textp
argument_list|,
name|typevec
index|[
name|maxtype
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* To get here, parms must end with `...'. */
operator|*
name|textp
operator|++
operator|=
literal|'e'
expr_stmt|;
block|}
operator|*
name|textp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|textp
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Change the name of a function definition so that it may be    overloaded. NAME is the name of the function to overload,    PARMS is the parameter list (which determines what name the    final function obtains).     FOR_METHOD is 1 if this overload is being performed    for a method, rather than a function type.  It is 2 if    this overload is being performed for a constructor.  */
end_comment

begin_function
name|tree
name|build_decl_overload
parameter_list|(
name|name
parameter_list|,
name|parms
parameter_list|,
name|for_method
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|for_method
decl_stmt|;
block|{
name|int
name|tmp
decl_stmt|;
name|char
name|tname
index|[
name|OVERLOAD_MAX_LEN
index|]
decl_stmt|;
if|if
condition|(
name|for_method
operator|==
literal|2
condition|)
comment|/* We can divine that this is a constructor,        and figure out its name without any extra encoding.  */
name|tmp
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|tname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|strlen
argument_list|(
name|tname
argument_list|)
expr_stmt|;
block|}
name|tname
index|[
name|tmp
operator|++
index|]
operator|=
literal|'_'
expr_stmt|;
name|tname
index|[
name|tmp
operator|++
index|]
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
name|for_method
condition|)
block|{
if|#
directive|if
literal|0
comment|/* We can get away without doing this.  */
block|tname[tmp++] = 'M';
endif|#
directive|endif
name|parms
operator|=
name|temp_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tname
index|[
name|tmp
operator|++
index|]
operator|=
literal|'F'
expr_stmt|;
if|if
condition|(
name|parms
operator|==
name|NULL_TREE
condition|)
name|tname
index|[
name|tmp
operator|++
index|]
operator|=
literal|'e'
operator|,
name|tname
index|[
name|tmp
index|]
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|parms
operator|==
name|void_list_node
condition|)
name|tname
index|[
name|tmp
operator|++
index|]
operator|=
literal|'v'
operator|,
name|tname
index|[
name|tmp
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|ALLOCATE_TYPEVEC
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|nofold
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|for_method
condition|)
block|{
name|tmp
operator|=
name|build_overload_name
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|tname
operator|+
name|tmp
argument_list|,
operator|&
name|tname
index|[
name|OVERLOAD_MAX_LEN
index|]
argument_list|)
operator|-
name|tname
expr_stmt|;
ifndef|#
directive|ifndef
name|LONGERNAMES
name|typevec
index|[
name|maxtype
operator|++
index|]
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
condition|)
name|build_overload_name
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|tname
operator|+
name|tmp
argument_list|,
operator|&
name|tname
index|[
name|OVERLOAD_MAX_LEN
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|tname
index|[
name|tmp
operator|++
index|]
operator|=
literal|'e'
expr_stmt|;
name|tname
index|[
name|tmp
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
name|build_overload_name
argument_list|(
name|parms
argument_list|,
name|tname
operator|+
name|tmp
argument_list|,
operator|&
name|tname
index|[
name|OVERLOAD_MAX_LEN
index|]
argument_list|)
expr_stmt|;
name|DEALLOCATE_TYPEVEC
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
return|return
name|get_identifier
argument_list|(
name|tname
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build an overload name for the type expression TYPE.  */
end_comment

begin_function
name|tree
name|build_typename_overload
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|char
name|tname
index|[
name|OVERLOAD_MAX_LEN
index|]
decl_stmt|;
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
name|OPERATOR_TYPENAME_FORMAT
argument_list|)
operator|-
literal|1
decl_stmt|;
name|sprintf
argument_list|(
name|tname
argument_list|,
name|OPERATOR_TYPENAME_FORMAT
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We can get away without doing this--it really gets      overloaded later.  */
block|tname[i++] = '_';   tname[i++] = '_';   tname[i++] = 'M';
endif|#
directive|endif
name|nofold
operator|=
literal|1
expr_stmt|;
name|build_overload_name
argument_list|(
name|type
argument_list|,
name|tname
operator|+
name|i
argument_list|,
operator|&
name|tname
index|[
name|OVERLOAD_MAX_LEN
index|]
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|tname
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Top-level interface to explicit overload requests. Allow NAME    to be overloaded. Error if NAME is already declared for the current    scope. Warning if function is redundanly overloaded. */
end_comment

begin_function
name|void
name|declare_overloaded
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NO_AUTO_OVERLOAD
if|if
condition|(
name|is_overloaded
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"function `%s' already declared overloaded"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"overloading function `%s' that is already defined"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_OVERLOADED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|name
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
block|{
if|if
condition|(
literal|0
condition|)
name|warning
argument_list|(
literal|"functions are implicitly overloaded in C++"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|error
argument_list|(
literal|"overloading function `%s' cannot be done in C language context"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NO_AUTO_OVERLOAD
end_ifdef

begin_comment
comment|/* Check to see if NAME is overloaded. For first approximation,    check to see if its TREE_OVERLOADED is set.  This is used on    IDENTIFIER nodes.  */
end_comment

begin_function
name|int
name|is_overloaded
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
comment|/* @@ */
return|return
operator|(
name|TREE_OVERLOADED
argument_list|(
name|name
argument_list|)
operator|&&
operator|(
operator|!
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|||
name|current_class_type
operator|==
literal|0
operator|)
operator|&&
operator|!
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Given a tree_code CODE, and some arguments (at least one),    attempt to use an overloaded operator on the arguments.     For unary operators, only the first argument need be checked.    For binary operators, both arguments may need to be checked.     Member functions can convert class references to class pointers,    for one-level deep indirection.  More than that is not supported.    Operators [](), ()(), and ->() must be member functions.     We call function call building calls with nonzero complain if    they are our only hope.  This is true when we see a vanilla operator    applied to something of aggregate type.  If this fails, we are free to    return `error_mark_node', because we will have reported the error.     Operators NEW and DELETE overload in funny ways: operator new takes    a single `size' parameter, and operator delete takes a pointer to the    storage being deleted.  When overloading these operators, success is    assumed.  If there is a failure, report an error message and return    `error_mark_node'.  */
end_comment

begin_comment
comment|/* NOSTRICT */
end_comment

begin_function
name|tree
name|build_opfncall
parameter_list|(
name|code
parameter_list|,
name|flags
parameter_list|,
name|xarg1
parameter_list|,
name|xarg2
parameter_list|,
name|arg3
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xarg1
decl_stmt|,
name|xarg2
decl_stmt|;
name|tree
name|arg3
decl_stmt|;
block|{
name|tree
name|rval
init|=
literal|0
decl_stmt|;
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|tree
name|type1
decl_stmt|,
name|type2
decl_stmt|,
name|fnname
decl_stmt|;
name|tree
name|fields1
init|=
literal|0
decl_stmt|,
name|parms
init|=
literal|0
decl_stmt|;
name|tree
name|global_fn
decl_stmt|;
name|int
name|try_second
decl_stmt|;
name|int
name|binary_is_unary
decl_stmt|;
if|if
condition|(
name|xarg1
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg2
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|arg3
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|COMPONENT_REF
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|xarg1
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
return|return
name|rval
return|;
comment|/* First, see if we can work with the first argument */
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|xarg1
argument_list|)
expr_stmt|;
comment|/* Some tree codes have length> 1, but we really only want to      overload them if their first argument has a user defined type.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
name|code
operator|=
name|POSTINCREMENT_EXPR
expr_stmt|;
name|binary_is_unary
operator|=
literal|1
expr_stmt|;
name|try_second
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|POSTDECREMENT_EXPR
case|:
name|code
operator|=
name|PREDECREMENT_EXPR
expr_stmt|;
name|binary_is_unary
operator|=
literal|1
expr_stmt|;
name|try_second
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
name|binary_is_unary
operator|=
literal|1
expr_stmt|;
name|try_second
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* ARRAY_REFs and CALL_EXPRs must overload successfully. 	 If they do not, return error_mark_node instead of NULL_TREE.  */
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|xarg2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
case|case
name|CALL_EXPR
case|:
name|rval
operator|=
name|error_mark_node
expr_stmt|;
name|binary_is_unary
operator|=
literal|0
expr_stmt|;
name|try_second
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NEW_EXPR
case|:
block|{
comment|/* For operators `new' (`delete'), only check visibility 	   if we are in a constructor (destructor), and we are 	   allocating for that constructor's (destructor's) type.  */
name|fnname
operator|=
name|get_identifier
argument_list|(
name|OPERATOR_NEW_FORMAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
return|return
name|build_overload_call
argument_list|(
name|fnname
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|,
name|arg3
argument_list|)
argument_list|,
name|flags
operator|&
name|LOOKUP_COMPLAIN
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
operator|||
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|||
name|current_class_type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
condition|)
name|flags
operator|=
name|LOOKUP_COMPLAIN
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|xarg1
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
name|fnname
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|,
name|arg3
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
comment|/* User might declare fancy operator new, but invoke it 	     like standard one.  */
return|return
name|rval
return|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|xarg1
expr_stmt|;
name|TREE_CALLS_NEW
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
block|}
break|break;
case|case
name|DELETE_EXPR
case|:
block|{
comment|/* See comment above.  */
name|fnname
operator|=
name|get_identifier
argument_list|(
name|OPERATOR_DELETE_FORMAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
return|return
name|build_overload_call
argument_list|(
name|fnname
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg1
argument_list|)
argument_list|,
name|flags
operator|&
name|LOOKUP_COMPLAIN
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
operator|||
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|||
name|current_class_type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type1
argument_list|)
condition|)
name|flags
operator|=
name|LOOKUP_COMPLAIN
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|xarg1
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
argument_list|,
name|fnname
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg1
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* This happens when the user mis-declares `operator delete'. 	   Should now be impossible.  */
name|assert
argument_list|(
name|rval
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
return|return
name|rval
return|;
block|}
break|break;
default|default:
name|binary_is_unary
operator|=
literal|0
expr_stmt|;
name|try_second
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|2
expr_stmt|;
if|if
condition|(
name|xarg2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
break|break;
block|}
if|if
condition|(
name|try_second
operator|&&
name|xarg2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* What ever it was, we do not know how to deal with it.  */
if|if
condition|(
name|type1
operator|==
name|NULL_TREE
condition|)
return|return
name|rval
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg1
operator|=
name|convert_from_reference
argument_list|(
name|xarg1
argument_list|)
expr_stmt|;
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg1
operator|=
name|xarg1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
condition|)
block|{
comment|/* Try to fail. First, fail if unary */
if|if
condition|(
operator|!
name|try_second
condition|)
return|return
name|rval
return|;
comment|/* Second, see if second argument is non-aggregate. */
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg2
operator|=
name|convert_from_reference
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|xarg2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
condition|)
return|return
name|rval
return|;
name|try_second
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|try_second
condition|)
block|{
comment|/* First arg may succeed; see whether second should.  */
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg2
operator|=
name|convert_from_reference
argument_list|(
name|xarg2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg2
operator|=
name|xarg2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
condition|)
name|try_second
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|type1
operator|==
name|unknown_type_node
operator|||
operator|(
name|try_second
operator|&&
name|TREE_TYPE
argument_list|(
name|xarg2
argument_list|)
operator|==
name|unknown_type_node
operator|)
condition|)
block|{
comment|/* This will not be implemented in the forseeable future.  */
return|return
name|rval
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|op_id
init|=
name|build_opid
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|arg3
argument_list|)
decl_stmt|;
name|fnname
operator|=
name|build_operator_fnname
argument_list|(
operator|&
name|op_id
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|op_id
init|=
name|build_opid
argument_list|(
literal|0
argument_list|,
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|binary_is_unary
condition|)
name|fnname
operator|=
name|build_operator_fnname
argument_list|(
operator|&
name|op_id
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|fnname
operator|=
name|build_operator_fnname
argument_list|(
operator|&
name|op_id
argument_list|,
literal|0
argument_list|,
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
argument_list|)
expr_stmt|;
block|}
name|global_fn
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
comment|/* This is the last point where we will accept failure.  This      may be too eager if we wish an overloaded operator not to match,      but would rather a normal operator be called on a type-converted      argument.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
condition|)
name|fields1
operator|=
name|lookup_fnfields
argument_list|(
name|CLASSTYPE_AS_LIST
argument_list|(
name|type1
argument_list|)
argument_list|,
name|fnname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fields1
operator|==
name|NULL_TREE
operator|&&
name|global_fn
operator|==
name|NULL_TREE
condition|)
return|return
name|rval
return|;
comment|/* If RVAL winds up being `error_mark_node', we will return      that... There is no way that normal semantics of these      operators will succeed.  */
comment|/* This argument may be an uncommited OFFSET_REF.  This is      the case for example when dealing with static class members      which are referenced from their class name rather than      from a class instance.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xarg1
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|xarg1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|xarg1
operator|=
name|TREE_OPERAND
argument_list|(
name|xarg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_second
operator|&&
name|xarg2
operator|&&
name|TREE_CODE
argument_list|(
name|xarg2
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|xarg2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|xarg2
operator|=
name|TREE_OPERAND
argument_list|(
name|xarg2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_fn
condition|)
name|flags
operator||=
name|LOOKUP_GLOBAL
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CALL_EXPR
condition|)
block|{
comment|/* This can only be a member function.  */
return|return
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|xarg2
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|==
literal|1
operator|||
name|binary_is_unary
condition|)
block|{
name|parms
operator|=
name|NULL_TREE
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|COND_EXPR
condition|)
block|{
name|parms
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|xarg2
argument_list|,
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|arg3
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|METHOD_CALL_EXPR
condition|)
block|{
comment|/* must be a member function.  */
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|fields1
condition|)
block|{
name|parms
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|xarg1
argument_list|,
name|fnname
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg1
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|xarg2
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build_overload_call
argument_list|(
name|fnname
argument_list|,
name|parms
argument_list|,
name|flags
operator|&
name|LOOKUP_COMPLAIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we did not win, do not lose yet, since type conversion may work.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rval
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
return|return
name|rval
return|;
return|return
literal|0
return|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function takes an identifier, ID, and attempts to figure out what    it means. There are a number of possible scenarios, presented in increasing    order of hair:     1) not in a class's scope    2) in class's scope, member name of the class's method    3) in class's scope, but not a member name of the class    4) in class's scope, member name of a class's variable     NAME is $1 from the bison rule. It is an IDENTIFIER_NODE.    VALUE is $$ from the bison rule. It is the value returned by lookup_name ($1)    yychar is the pending input character (suitably encoded :-).     As a last ditch, try to look up the name as a label and return that    address.     Values which are declared as being of REFERENCE_TYPE are    automatically dereferenced here (as a hack to make the    compiler faster).  */
end_comment

begin_function
name|tree
name|hack_identifier
parameter_list|(
name|value
parameter_list|,
name|name
parameter_list|,
name|yychar
parameter_list|)
name|tree
name|value
decl_stmt|,
name|name
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|current_class_name
condition|)
block|{
name|tree
name|fields
init|=
name|lookup_fnfields
argument_list|(
name|CLASSTYPE_AS_LIST
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
condition|)
block|{
name|fields
operator|=
name|TREE_VALUE
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|warning
argument_list|(
literal|"methods cannot be converted to function pointers"
argument_list|)
expr_stmt|;
return|return
name|fields
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"ambiguous request for method pointer `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
if|if
condition|(
name|flag_labels_ok
operator|&&
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_NONLOCAL
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|current_class_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"request for member `%s' in static member function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_USED
argument_list|(
name|current_class_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|yychar
operator|==
literal|'('
condition|)
if|if
condition|(
operator|!
operator|(
operator|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|type
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"component `%s' is not a method"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Mark so that if we are in a constructor, and then find that 	     this field was initialized by a base initializer, 	     we can emit an error message.  */
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|C_C_D
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
operator|!=
name|current_class_type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_DECL
operator|)
condition|)
block|{
name|tree
name|path
decl_stmt|;
name|enum
name|visibility_type
name|visibility
decl_stmt|;
name|get_base_distance
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|visibility
operator|=
name|compute_visibility
argument_list|(
name|path
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibility
operator|!=
name|visibility_public
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|error
argument_list|(
literal|"static member `%s' is from private base class"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"enum `%s' is from private base class"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|type
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"request for member `%s' is ambiguous in multiple inheritance lattice"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|value
return|;
block|}
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|value
argument_list|)
condition|)
name|assemble_external
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|RESULT_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_REFERENCE_SLOT
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|DECL_REFERENCE_SLOT
argument_list|(
name|value
argument_list|)
return|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_function
name|tree
name|hack_operator
parameter_list|(
name|op
parameter_list|)
name|tree
name|op
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|==
name|NULL_TREE
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|TYPE_EXPR
condition|)
return|return
name|grokopexpr
argument_list|(
operator|&
name|op
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|op
return|;
block|}
end_function

begin_comment
comment|/* NONWRAPPER is nonzero if this call is not to be wrapped.    TYPE is the type that the wrapper belongs to (in case    it should be non-virtual).    DECL is the function will will be (not be) wrapped.  */
end_comment

begin_function
name|tree
name|hack_wrapper
parameter_list|(
name|nonwrapper
parameter_list|,
name|type
parameter_list|,
name|decl
parameter_list|)
name|int
name|nonwrapper
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|is_aggr_typedef
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nonwrapper
condition|)
block|{
case|case
literal|0
case|:
return|return
name|build_nt
argument_list|(
name|WRAPPER_EXPR
argument_list|,
name|type
argument_list|,
name|decl
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|build_nt
argument_list|(
name|ANTI_WRAPPER_EXPR
argument_list|,
name|type
argument_list|,
name|decl
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|build_nt
argument_list|(
name|WRAPPER_EXPR
argument_list|,
name|type
argument_list|,
name|build_nt
argument_list|(
name|COND_EXPR
argument_list|,
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
return|;
default|default:
name|assert
argument_list|(
literal|0
operator|<=
name|nonwrapper
operator|&&
name|nonwrapper
operator|<=
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an IDENTIFIER which can be used as a name for    anonymous structs and unions.  */
end_comment

begin_function
name|tree
name|make_anon_name
parameter_list|()
block|{
specifier|static
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|ANON_AGGRNAME_FORMAT
argument_list|,
name|cnt
operator|++
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an object OF, and a type conversion operator COMPONENT    build a call to the conversion operator, if a call is requested,    or return the address (as a pointer to member function) if one is not.     OF can be a TYPE_DECL or any kind of datum that would normally    be passed to `build_component_ref'.  It may also be NULL_TREE,    in which case `current_class_type' and `current_class_decl'    provide default values.     BASETYPE_PATH, if non-null, is the path of basetypes    to go through before we get the the instance of interest.     PROTECT says whether we apply C++ scoping rules or not.  */
end_comment

begin_function
name|tree
name|build_component_type_expr
parameter_list|(
name|of
parameter_list|,
name|component
parameter_list|,
name|basetype_path
parameter_list|,
name|protect
parameter_list|)
name|tree
name|of
decl_stmt|,
name|component
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|tree
name|cname
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|tmp
decl_stmt|,
name|last
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|flags
init|=
name|protect
condition|?
name|LOOKUP_NORMAL
else|:
name|LOOKUP_COMPLAIN
decl_stmt|;
name|assert
argument_list|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|of
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|component
argument_list|)
operator|==
name|TYPE_EXPR
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|last
condition|)
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|!=
name|void_list_node
condition|)
block|{
name|error
argument_list|(
literal|"operator<typename> requires empty parameter list"
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|last
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_typename_overload
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|of
operator|&&
name|TREE_CODE
argument_list|(
name|of
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
return|return
name|build_method_call
argument_list|(
name|of
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
return|;
elseif|else
if|if
condition|(
name|of
condition|)
block|{
name|tree
name|this_this
decl_stmt|;
if|if
condition|(
name|current_class_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"object required for `operator<typename>' call"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|this_this
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|of
argument_list|)
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
return|return
name|build_method_call
argument_list|(
name|this_this
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|current_class_decl
condition|)
return|return
name|build_method_call
argument_list|(
name|tmp
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
return|;
name|error
argument_list|(
literal|"object required for `operator<typename>' call"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|ARRAY_REF
case|:
break|break;
case|case
name|SCOPE_REF
case|:
name|assert
argument_list|(
name|cname
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cname
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|last
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|groktypename
argument_list|(
name|build_tree_list
argument_list|(
name|TREE_TYPE
argument_list|(
name|component
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|component
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_typename_overload
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|of
operator|&&
name|TREE_CODE
argument_list|(
name|of
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|cname
operator|==
name|NULL_TREE
condition|)
block|{
name|cname
operator|=
name|DECL_NAME
argument_list|(
name|of
argument_list|)
expr_stmt|;
name|of
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
name|assert
argument_list|(
name|cname
operator|==
name|DECL_NAME
argument_list|(
name|of
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|of
condition|)
block|{
name|tree
name|this_this
decl_stmt|;
if|if
condition|(
name|current_class_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"object required for `operator<typename>' call"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|this_this
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_TYPE
argument_list|(
name|of
argument_list|)
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|this_this
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|protect
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cname
condition|)
return|return
name|build_offset_ref
argument_list|(
name|cname
argument_list|,
name|name
argument_list|)
return|;
elseif|else
if|if
condition|(
name|current_class_name
condition|)
return|return
name|build_offset_ref
argument_list|(
name|current_class_name
argument_list|,
name|name
argument_list|)
return|;
name|error
argument_list|(
literal|"object required for `operator<typename>' member reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

end_unit

