begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions related to building and playing with classes.    Copyright (C) 1987 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@mcc.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cplus-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)< (Y) ? (X) : (Y))
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)> (Y) ? (X) : (Y))
end_define

begin_comment
comment|/* See cplus-decl.c for comment of this variable.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_int_enum_equivalence
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* some statistics gathering help.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_vtables
decl_stmt|,
name|n_vtable_entries
decl_stmt|,
name|n_vtable_searches
decl_stmt|,
name|n_vtable_elems
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_convert_harshness
decl_stmt|,
name|n_compute_conversion_costs
decl_stmt|,
name|n_build_method_call
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_inner_fields_searched
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute the ease with which a conversion can be performed    between an expected and the given type.  */
end_comment

begin_function_decl
specifier|static
name|int
name|convert_harshness
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* in decl.c.  */
end_comment

begin_function_decl
specifier|extern
name|tree
name|lookup_tag_current_binding_level
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* in method.c.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|do_inline_function_hair
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Way of stacking class types.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|current_class_base
decl_stmt|,
modifier|*
name|current_class_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_class_stacksize
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|class_level
block|{
comment|/* The previous class level.  */
name|struct
name|class_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* The class instance variable, as a PARM_DECL.  */
name|tree
name|decl
decl_stmt|;
comment|/* The class instance variable, as an object.  */
name|tree
name|object
decl_stmt|;
comment|/* The virtual function table pointer      for the class instance variable.  */
name|tree
name|vtable_decl
decl_stmt|;
comment|/* Name of the current class.  */
name|tree
name|name
decl_stmt|;
comment|/* Type of the current class.  */
name|tree
name|type
decl_stmt|;
comment|/* Flags for this class level.  */
name|int
name|this_is_variable
decl_stmt|;
name|int
name|memoized_lookups
decl_stmt|;
name|int
name|save_memoized
decl_stmt|;
name|int
name|unused
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|tree
name|current_class_decl
decl_stmt|,
name|C_C_D
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PARM_DECL: the class instance variable */
end_comment

begin_decl_stmt
name|tree
name|current_vtable_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following two can be derived from the previous one */
end_comment

begin_decl_stmt
name|tree
name|current_class_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IDENTIFIER_NODE: name of current class */
end_comment

begin_decl_stmt
name|tree
name|current_class_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _TYPE: the type of the current class */
end_comment

begin_decl_stmt
name|tree
name|prev_class_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _TYPE: the previous type that was a class */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|get_vtable_name
argument_list|()
decl_stmt|,
name|get_vfield_name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|the_null_vtable_entry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Way of stacking langauge names.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|current_lang_base
decl_stmt|,
modifier|*
name|current_lang_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_lang_stacksize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of languages we recognize.  */
end_comment

begin_decl_stmt
name|tree
name|lang_name_c
decl_stmt|,
name|lang_name_cplusplus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|current_lang_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|minus_one_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When layout out an aggregate type, the size of the    basetypes (virtual and non-virtual) is passed to layout_record    via this node.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|base_layout_decl
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Make sure that the tag NAME is defined *in the current binding level*    at least as a forward reference.    CODE says which kind of tag NAME ought to be.     Not used for C++.  Not maintained.  */
end_comment

begin_comment
unit|tree start_struct (code, name)      enum tree_code code;      tree name; {
comment|/* If there is already a tag defined at this binding level      (as a forward reference), just return it.  */
end_comment

begin_comment
unit|register tree ref = 0;    if (name != 0)     ref = lookup_tag (code, name, current_binding_level, 1);   if (ref&& TREE_CODE (ref) == code)     {       if (TYPE_FIELDS (ref)) 	error ((code == UNION_TYPE ? "redefinition of `union %s'" 		: "redefinition of `struct %s'"), 	       IDENTIFIER_POINTER (name));        return ref;     }
comment|/* Otherwise create a forward-reference just so the tag is in scope.  */
end_comment

begin_comment
unit|ref = make_lang_type (code);
comment|/* Must re-synch this with xref_tag if you are going to use it.  */
end_comment

begin_endif
unit|assert (0);   pushtag (name, ref);   return ref; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Virtual baseclass things.  */
end_comment

begin_function
name|tree
name|build_vbase_pointer
parameter_list|(
name|exp
parameter_list|,
name|type
parameter_list|)
name|tree
name|exp
decl_stmt|,
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|VBASE_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
name|VBASE_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|exp
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build multi-level access to EXPR using hierarchy path PATH.    CODE is PLUS_EXPR if we are going with the grain,    and MINUS_EXPR if we are not (in which case, we cannot traverse    virtual baseclass links).     TYPE is the type we want this path to have on exit.     ALIAS_THIS is non-zero if EXPR in an expression involving `this'.  */
end_comment

begin_function
name|tree
name|build_vbase_path
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|expr
parameter_list|,
name|path
parameter_list|,
name|alias_this
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|path
decl_stmt|;
name|int
name|alias_this
decl_stmt|;
block|{
specifier|register
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|,
name|last_virtual
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|fixed_type_p
init|=
literal|0
operator|&&
name|resolves_to_fixed_type_p
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|basetype
decl_stmt|;
name|tree
name|offset
init|=
name|integer_zero_node
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|path
argument_list|)
condition|)
name|path
operator|=
name|nreverse
argument_list|(
name|copy_list
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|last_virtual
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
block|{
name|changed
operator|=
operator|!
name|fixed_type_p
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|expr
operator|=
name|convert_pointer_to
argument_list|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
name|expr
operator|=
name|build_vbase_pointer
argument_list|(
name|build_indirect_ref
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|last_virtual
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|ASSOC_OFFSET
argument_list|(
name|value_member
argument_list|(
name|last_virtual
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Happens in the case of parse errors.  */
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|expr
return|;
block|}
else|else
block|{
name|error_with_aggr_type
argument_list|(
name|last_virtual
argument_list|,
literal|"cannot cast up from virtual baseclass `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|last
operator|=
name|path
expr_stmt|;
name|path
operator|=
name|TREE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* LAST is now the last basetype on the path.  */
name|last
operator|=
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* If we go through any virtual base pointers, make sure that      casts to BASETYPE from the last virtual base class use      the right value for BASETYPE.  */
if|if
condition|(
name|changed
condition|)
block|{
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|last
argument_list|)
condition|)
name|basetype
operator|=
name|intype
expr_stmt|;
else|else
block|{
name|basetype
operator|=
name|get_base_type
argument_list|(
name|last
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|CLASSTYPE_OFFSET
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|last_virtual
operator|&&
name|last
operator|!=
name|last_virtual
condition|)
name|basetype
operator|=
name|get_base_type
argument_list|(
name|last
argument_list|,
name|last_virtual
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|basetype
operator|=
name|last
expr_stmt|;
name|offset
operator|=
name|genop
argument_list|(
name|code
argument_list|,
name|offset
argument_list|,
name|CLASSTYPE_OFFSET
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 900324 JRV: If code was MINUS_EXPR, genop returned a negative 	 offset, so shouldn't the code always be PLUS_EXPR now? */
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
block|}
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|offset
argument_list|)
condition|)
block|{
comment|/* For multiple inheritance: if `this' can be set by 	 any function, then it could be 0 on entry 	 to any function.  Preserve such zeroness here. 	 Otherwise, only in the case of constructors need 	 we worry, and in those cases, it will be zero, 	 or initialized to some legal value to which we may 	 add.  */
name|tree
name|addr
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|?
name|expr
else|:
name|save_expr
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|expr
operator|=
name|build
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias_this
operator|==
literal|0
operator|||
name|flag_this_is_variable
condition|)
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|addr
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|addr
argument_list|)
argument_list|,
name|expr
argument_list|)
return|;
block|}
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Virtual function things.  */
end_comment

begin_comment
comment|/* Virtual functions to be dealt with after laying out our    virtual base classes (only if the type has any).  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|pending_hard_virtuals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The names of the entries in the virtual table structure.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|delta_name
decl_stmt|,
name|pfn_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary assoc list to memoize lookups of the left-most non-virtual    baseclass B in a lattice topped by T.  B can appear multiple times    in the lattice.    TREE_PURPOSE is B's TYPE_MAIN_VARIANT.    TREE_VALUE is the path by which B is reached from T.    TREE_TYPE is B's real type.     If TREE_TYPE is NULL_TREE, it means that B was reached via    a virtual baseclass.    N.B.: This list consists of nodes on the temporary obstack.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|leftmost_baseclasses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Build an entry in the virtual function table.    DELTA is the offset for the `this' pointer.    PFN is an ADDR_EXPR containing a pointer to the virtual function.    Note that the index (DELTA2) in the virtual function table    is always 0.  */
end_comment

begin_function
name|tree
name|build_vtable_entry
parameter_list|(
name|delta
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|delta
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|elems
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|delta
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|pfn
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|entry
init|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|vtable_entry_type
argument_list|,
name|NULL_TREE
argument_list|,
name|elems
argument_list|)
decl_stmt|;
name|TREE_LITERAL
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_entries
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Given an object INSTANCE, return an expression which yields    the virtual function corresponding to INDEX.  There are many special    cases for INSTANCE which we take care of here, mainly to avoid    creating extra tree nodes when we don't have to.  */
end_comment

begin_function
name|tree
name|build_vfn_ref
parameter_list|(
name|ptr_to_instptr
parameter_list|,
name|instance
parameter_list|,
name|index
parameter_list|)
name|tree
modifier|*
name|ptr_to_instptr
decl_stmt|,
name|instance
decl_stmt|;
name|tree
name|index
decl_stmt|;
block|{
specifier|extern
name|int
name|building_cleanup
decl_stmt|;
name|tree
name|vtbl
decl_stmt|,
name|aref
decl_stmt|;
name|tree
name|basetype
init|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|C_C_D
condition|)
block|{
if|if
condition|(
name|current_vtable_decl
operator|==
name|NULL_TREE
operator|||
name|current_vtable_decl
operator|==
name|error_mark_node
operator|||
name|get_base_type
argument_list|(
name|DECL_FCONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|,
name|basetype
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|vtbl
operator|=
name|current_vtable_decl
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|optimize
condition|)
block|{
comment|/* Try to figure out what a reference refers to, and 	     access its virtual function table directly.  */
name|tree
name|ref
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|ref
operator|=
name|instance
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|ref
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|REFERENCE_EXPR
condition|)
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|instance
operator|=
name|init
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|instance
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|vtbl
operator|=
name|CLASS_ASSOC_VTABLE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
else|else
name|vtbl
operator|=
name|build_indirect_ref
argument_list|(
name|build_vfield_ref
argument_list|(
name|instance
argument_list|,
name|basetype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|aref
operator|=
name|build_array_ref
argument_list|(
name|vtbl
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|building_cleanup
operator|&&
name|TREE_CODE
argument_list|(
name|aref
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
operator|=
name|save_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|aref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ptr_to_instptr
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|ptr_to_instptr
argument_list|)
argument_list|,
operator|*
name|ptr_to_instptr
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|delta_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_component_ref
argument_list|(
name|aref
argument_list|,
name|pfn_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a virtual function for type TYPE.    If ASSOC is non-NULL, build the vtable starting with the intial    approximation that it is the same as the one which is the head of    the assocation list.  */
end_comment

begin_function
specifier|static
name|tree
name|build_vtable
parameter_list|(
name|assoc
parameter_list|,
name|type
parameter_list|)
name|tree
name|assoc
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|name
init|=
name|get_vtable_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|virtuals
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|assoc
condition|)
block|{
name|virtuals
operator|=
name|copy_list
argument_list|(
name|ASSOC_VIRTUALS
argument_list|(
name|assoc
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|ASSOC_VTABLE
argument_list|(
name|assoc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|virtuals
operator|=
name|NULL_TREE
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|write_virtuals
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|write_virtuals
operator|>
literal|0
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|write_virtuals
operator|<
literal|0
condition|)
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|decl
operator|=
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Initialize the association list for this type, based      on our first approximation.  */
name|CLASS_ASSOC_VTABLE
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|type
argument_list|)
operator|=
name|virtuals
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assoc
operator|&&
name|write_virtuals
operator|>=
literal|0
condition|)
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Remember which class this vtable is really for.  */
name|DECL_VPARENT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|CLASSTYPE_MARKED3
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_MARKED4
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Give TYPE a new virtual function table which is initialized    with a skeleton-copy of its original initialization.  The only    entry that changes is the `delta' entry, so we can really    share a lot of structure.     FOR_TYPE is the derived type which caused this table to    be needed.     ASSOC is the type association which provided TYPE for FOR_TYPE.     The way we update BASE_ASSOC's vtable information is just to change the    association information in FOR_TYPE's association list.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_fresh_vtable
parameter_list|(
name|assoc
parameter_list|,
name|base_assoc
parameter_list|,
name|for_type
parameter_list|)
name|tree
name|assoc
decl_stmt|,
name|base_assoc
decl_stmt|,
name|for_type
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|ASSOC_TYPE
argument_list|(
name|assoc
argument_list|)
decl_stmt|;
name|tree
name|orig_decl
init|=
name|ASSOC_VTABLE
argument_list|(
name|assoc
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|build_type_pathname
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|,
name|basetype
argument_list|,
name|for_type
argument_list|)
decl_stmt|;
name|tree
name|new_decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|path
decl_stmt|;
name|int
name|result
decl_stmt|;
name|assert
argument_list|(
name|TREE_USED
argument_list|(
name|assoc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Remember which class this vtable is really for.  */
name|DECL_VPARENT
argument_list|(
name|new_decl
argument_list|)
operator|=
name|ASSOC_TYPE
argument_list|(
name|base_assoc
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|new_decl
argument_list|)
operator|=
name|for_type
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ASSOC_VTABLE
argument_list|(
name|assoc
argument_list|)
operator|=
name|pushdecl_top_level
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|new_decl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|orig_decl
argument_list|)
expr_stmt|;
comment|/* Make fresh virtual list, so we can smash it later.  */
name|assert
argument_list|(
name|ASSOC_VIRTUALS
argument_list|(
name|assoc
argument_list|)
argument_list|)
expr_stmt|;
name|ASSOC_VIRTUALS
argument_list|(
name|assoc
argument_list|)
operator|=
name|copy_list
argument_list|(
name|ASSOC_VIRTUALS
argument_list|(
name|assoc
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtables
operator|+=
literal|1
expr_stmt|;
name|n_vtable_elems
operator|+=
name|list_length
argument_list|(
name|ASSOC_VIRTUALS
argument_list|(
name|assoc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set `new_decl's PUBLIC and EXTERNAL bits.  */
if|if
condition|(
name|write_virtuals
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|for_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|new_decl
argument_list|)
operator|=
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|for_type
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|new_decl
argument_list|)
operator|=
operator|!
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|for_type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|write_virtuals
operator|>
literal|0
condition|)
name|TREE_PUBLIC
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|write_virtuals
operator|<
literal|0
condition|)
name|TREE_EXTERNAL
argument_list|(
name|new_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_MARKED3
argument_list|(
name|basetype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_MARKED4
argument_list|(
name|basetype
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark all types between FOR_TYPE and TYPE as having been      touched, so that if we change virtual function table entries,      new vtables will be initialized.  We may reach the virtual      baseclass via ambiguous intervening baseclasses.  This      loop makes sure we get through to the actual baseclass we marked.  */
do|do
block|{
name|result
operator|=
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|for_type
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|for_type
operator|=
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|path
condition|)
block|{
name|CLASSTYPE_MARKED3
argument_list|(
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|path
operator|=
name|TREE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|result
operator|==
operator|-
literal|2
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Access the virtual function table entry that logically    contains BASE_FNDECL.  VIRTUALS is the virtual function table's    initializer.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_entry
parameter_list|(
name|virtuals
parameter_list|,
name|base_fndecl
parameter_list|)
name|tree
name|virtuals
decl_stmt|,
name|base_fndecl
decl_stmt|;
block|{
name|int
name|i
init|=
operator|(
name|HOST_BITS_PER_INT
operator|>=
name|BITS_PER_WORD
ifdef|#
directive|ifdef
name|VTABLE_USES_MASK
operator|&&
literal|0
endif|#
directive|endif
condition|?
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
else|:
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_vtable_searches
operator|+=
name|i
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
return|return
name|virtuals
return|;
block|}
end_function

begin_comment
comment|/* Put new entry ENTRY into virtual function table initializer    VIRTUALS.  The virtual function table is for type CONTEXT.     Also update DECL_VINDEX (FNDECL).  */
end_comment

begin_function
specifier|static
name|void
name|modify_vtable_entry
parameter_list|(
name|old_entry_in_list
parameter_list|,
name|new_entry
parameter_list|,
name|fndecl
parameter_list|,
name|context
parameter_list|)
name|tree
name|old_entry_in_list
decl_stmt|,
name|new_entry
decl_stmt|,
name|fndecl
decl_stmt|,
name|context
decl_stmt|;
block|{
name|tree
name|base_pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|old_entry_in_list
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|vindex
decl_stmt|;
comment|/* We can't put in the really right offset information      here, since we have not yet laid out the class to      take into account virtual base classes.  */
name|TREE_VALUE
argument_list|(
name|old_entry_in_list
argument_list|)
operator|=
name|new_entry
expr_stmt|;
name|vindex
operator|=
name|DECL_VINDEX
argument_list|(
name|TREE_OPERAND
argument_list|(
name|base_pfn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|SET_DECL_VINDEX
argument_list|(
name|fndecl
argument_list|,
name|vindex
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|tree_int_cst_equal
argument_list|(
name|DECL_VINDEX
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|vindex
argument_list|)
condition|)
block|{
name|tree
name|elts
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|new_entry
argument_list|)
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|context
argument_list|)
decl_stmt|;
comment|/* Compute the relative offset of vtable we are really looking for.  */
name|TREE_VALUE
argument_list|(
name|elts
argument_list|)
operator|=
name|genop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|build_int
argument_list|(
name|DECL_OFFSET
argument_list|(
name|vfield
argument_list|)
operator|/
name|DECL_SIZE_UNIT
argument_list|(
name|vfield
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|elts
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Say what index to use when we use that vtable.  */
ifndef|#
directive|ifndef
name|VTABLE_USES_MASK
name|vindex
operator|=
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|vindex
argument_list|)
operator|&
operator|~
operator|(
literal|1
operator|<<
operator|(
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
argument_list|)
operator|=
name|vindex
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Modify virtual function tables in lattice topped by T to    place FNDECL in tables which previously held BASE_FNDECL.    PFN is just FNDECL wrapped in an ADDR_EXPR, so that it    is suitable for placement directly into an initializer.     All distinct virtual function tables that this type uses    must be updated.  */
end_comment

begin_function
specifier|static
name|void
name|modify_vtable_entries
parameter_list|(
name|t
parameter_list|,
name|fndecl
parameter_list|,
name|base_fndecl
parameter_list|,
name|pfn
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|fndecl
decl_stmt|,
name|base_fndecl
decl_stmt|,
name|pfn
decl_stmt|;
block|{
name|tree
name|base_offset
decl_stmt|,
name|offset
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|base_fndecl
argument_list|)
decl_stmt|;
name|tree
name|vfield
init|=
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|vfields
decl_stmt|,
name|vbases
decl_stmt|;
name|DECL_VCONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_VCONTEXT
argument_list|(
name|base_fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|t
operator|||
operator|!
operator|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|offset
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
name|tree
name|assoc
init|=
name|virtual_member
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|assoc
operator|==
name|NULL_TREE
condition|)
name|assoc
operator|=
name|assoc_value
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|assoc
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ASSOC_OFFSET
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
block|}
comment|/* For each layer of base class (i.e., the first base class, and each      virtual base class from that one), modify the virtual function table      of the derived class to contain the new virtual function.      A class has as many vfields as it has virtual base classes (total).  */
for|for
control|(
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
init|;
name|vfields
condition|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
control|)
block|{
name|int
name|normal
init|=
literal|1
decl_stmt|;
name|tree
name|assoc
decl_stmt|,
name|this_offset
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|path
decl_stmt|;
comment|/* Find the right base class for this derived class, call it BASE.  */
name|base
operator|=
name|TREE_VALUE
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|!=
name|context
condition|)
block|{
comment|/* If BASE_FNDECL is not contained in the vtable accessed by 	     the vslot, don't try to modify the vtable. 	      	     Virtual functions from virtual baseclasses are not in derived 	     virtual function tables.  This is an implementation decision; 	     it keeps there from being a combinatorial exposion in the 	     number of different vtables which must be maintained.  */
if|if
condition|(
name|get_base_distance
argument_list|(
name|base
argument_list|,
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* BASE_FNDECL is defined in a class derived from 	     the base class owning this VFIELD.  */
block|}
comment|/* Get the path starting from the deepest base class CONTEXT 	 of T (i.e., first defn of BASE_FNDECL).  */
name|get_base_distance
argument_list|(
name|context
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
comment|/* Get our best approximation of what to use for constructing 	 the virtual function table for T.  */
do|do
block|{
comment|/* Walk from base toward derived, stopping at the 	     most derived baseclass that matters.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|base
operator|=
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|assoc
operator|=
name|value_member
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|base
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|path
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|path
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
operator|)
operator|||
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|path
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|base
operator|=
name|TREE_VALUE
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|assoc
operator|=
name|assoc_value
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|base
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
name|path
operator|=
name|TREE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* Find the right offset for the this pointer based on the base 	 class we just found.  */
name|base_offset
operator|=
name|ASSOC_OFFSET
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_offset
operator|==
name|integer_zero_node
condition|)
name|this_offset
operator|=
name|offset
expr_stmt|;
else|else
name|this_offset
operator|=
name|genop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
comment|/* Make sure we can modify the derived association with immunity.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|CLASSTYPE_ASSOC
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|CLASSTYPE_ASSOC
argument_list|(
name|t
argument_list|)
operator|=
name|copy_assoc
argument_list|(
name|CLASSTYPE_ASSOC
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We call this case NORMAL iff this virtual function table 	 pointer field has its storage reserved in this class. 	 This is normally the case without virtual baseclasses 	 or off-center multiple baseclasses.  */
name|normal
operator|=
operator|(
name|vfield
operator|!=
name|NULL_TREE
operator|&&
name|TREE_VALUE
argument_list|(
name|vfields
argument_list|)
operator|==
name|DECL_FCONTEXT
argument_list|(
name|vfield
argument_list|)
operator|&&
operator|(
name|TREE_PURPOSE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|vfields
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|normal
operator|&&
name|TREE_PURPOSE
argument_list|(
name|vfields
argument_list|)
condition|)
comment|/* Everything looks normal so far...check that we are really 	   working from VFIELD's basetype, and not some other appearance 	   of that basetype in the lattice.  */
name|normal
operator|=
operator|(
name|TREE_PURPOSE
argument_list|(
name|vfields
argument_list|)
operator|==
name|get_base_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|normal
condition|)
block|{
comment|/* In this case, it is *type*'s vtable we are modifying.  */
name|context
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_MARKED4
argument_list|(
name|t
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|assoc
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|assoc
operator|=
name|CLASSTYPE_ASSOC
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is our very own copy of `basetype' to play with.  */
if|if
condition|(
operator|!
name|CLASSTYPE_MARKED4
argument_list|(
name|ASSOC_TYPE
argument_list|(
name|assoc
argument_list|)
argument_list|)
condition|)
name|prepare_fresh_vtable
argument_list|(
name|assoc
argument_list|,
name|CLASSTYPE_ASSOC
argument_list|(
name|base
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|modify_vtable_entry
argument_list|(
name|get_vtable_entry
argument_list|(
name|ASSOC_VIRTUALS
argument_list|(
name|assoc
argument_list|)
argument_list|,
name|base_fndecl
argument_list|)
argument_list|,
name|build_vtable_entry
argument_list|(
name|this_offset
argument_list|,
name|pfn
argument_list|)
argument_list|,
name|fndecl
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|vbases
condition|;
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
control|)
block|{
name|tree
name|this_offset
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|path
decl_stmt|;
if|if
condition|(
operator|!
name|ASSOC_VTABLE
argument_list|(
name|vbases
argument_list|)
condition|)
comment|/* There are only two ways that a type can fail to have 	   virtual functions: neither it nor any of its base 	   types define virtual functions (in which case 	   no updating need be done), or virtual functions 	   accessible to it come from virtual base classes 	   (in which case we have or will get them modified 	   in other passes of this loop).  */
continue|continue;
name|base
operator|=
name|TREE_VALUE
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
name|path
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|base
operator|!=
name|context
operator|&&
name|get_base_distance
argument_list|(
name|context
argument_list|,
name|base
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* Doesn't matter if not actually from this virtual base class,          but shouldn't come from deeper virtual baseclasses.  The enclosing 	 loop should take care of such baseclasses.  */
while|while
condition|(
name|path
condition|)
block|{
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|path
argument_list|)
condition|)
goto|goto
name|skip
goto|;
name|path
operator|=
name|TREE_CHAIN
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|base_offset
operator|=
name|ASSOC_OFFSET
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_offset
operator|==
name|integer_zero_node
condition|)
name|this_offset
operator|=
name|offset
expr_stmt|;
else|else
name|this_offset
operator|=
name|genop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|offset
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
comment|/* Make sure we can modify the derived association with immunity.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|CLASSTYPE_ASSOC
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|CLASSTYPE_ASSOC
argument_list|(
name|t
argument_list|)
operator|=
name|copy_assoc
argument_list|(
name|CLASSTYPE_ASSOC
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is our very own copy of `basetype' to play with.  */
if|if
condition|(
operator|!
name|CLASSTYPE_MARKED4
argument_list|(
name|ASSOC_TYPE
argument_list|(
name|vbases
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|context_assoc
init|=
name|assoc_value
argument_list|(
name|context
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|prepare_fresh_vtable
argument_list|(
name|vbases
argument_list|,
name|context_assoc
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|modify_vtable_entry
argument_list|(
name|get_vtable_entry
argument_list|(
name|ASSOC_VIRTUALS
argument_list|(
name|vbases
argument_list|)
argument_list|,
name|base_fndecl
argument_list|)
argument_list|,
name|build_vtable_entry
argument_list|(
name|this_offset
argument_list|,
name|pfn
argument_list|)
argument_list|,
name|fndecl
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|skip
label|:
block|{}
block|}
block|}
end_function

begin_function
specifier|static
name|tree
name|add_virtual_function
parameter_list|(
name|pending_virtuals
parameter_list|,
name|has_virtual
parameter_list|,
name|x
parameter_list|,
name|first
parameter_list|)
name|tree
name|pending_virtuals
decl_stmt|;
name|int
modifier|*
name|has_virtual
decl_stmt|;
name|tree
name|x
decl_stmt|;
name|int
name|first
decl_stmt|;
block|{
name|int
name|debug_vbase
init|=
literal|1
decl_stmt|;
comment|/* FUNCTION_TYPEs and OFFSET_TYPEs no longer freely      convert to void *.  Make such a conversion here.  */
name|tree
name|vfn
init|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|TREE_LITERAL
argument_list|(
name|vfn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
comment|/* If the virtual function is a redefinition of a prior one,      figure out in which base class the new definition goes,      and if necessary, make a fresh virtual function table      to hold that entry.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|entry
init|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|vfn
argument_list|)
decl_stmt|;
comment|/* Build a new INT_CST for this DECL_VINDEX.  */
ifdef|#
directive|ifdef
name|VTABLE_USES_MASK
name|SET_DECL_VINDEX
argument_list|(
name|x
argument_list|,
name|build_int_2
argument_list|(
operator|++
operator|(
operator|*
name|has_virtual
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_DECL_VINDEX
argument_list|(
name|x
argument_list|,
name|build_int_2
argument_list|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator||
operator|++
operator|(
operator|*
name|has_virtual
operator|)
operator|)
argument_list|,
operator|~
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
argument_list|,
name|entry
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
block|}
comment|/* Happens if declared twice in class.  We will give error      later.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|pending_virtuals
return|;
elseif|else
if|if
condition|(
name|debug_vbase
operator|&&
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
comment|/* Need an entry in some other virtual function table.          Deal with this after we have laid out our virtual base classes.  */
name|pending_hard_virtuals
operator|=
name|temp_tree_cons
argument_list|(
name|x
argument_list|,
name|vfn
argument_list|,
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Need an entry in some other virtual function table.          We can do this now.  */
name|tree
name|base_fndecl_list
init|=
name|DECL_VINDEX
argument_list|(
name|x
argument_list|)
decl_stmt|,
name|base_fndecls
decl_stmt|,
name|prev
init|=
literal|0
decl_stmt|;
name|tree
name|vtable_context
init|=
name|DECL_FCONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|true_base_fndecl
init|=
literal|0
decl_stmt|;
comment|/* First assign DECL_VINDEX from the base vfn with which 	 we share our vtable.  */
name|base_fndecls
operator|=
name|base_fndecl_list
expr_stmt|;
while|while
condition|(
name|base_fndecls
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_FCONTEXT
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|vtable_context
condition|)
block|{
name|true_base_fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
name|modify_vtable_entries
argument_list|(
name|current_class_type
argument_list|,
name|x
argument_list|,
name|true_base_fndecl
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
else|else
name|base_fndecl_list
operator|=
name|prev
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|base_fndecls
expr_stmt|;
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
comment|/* Now fill in the rest of the vtables.  */
name|base_fndecls
operator|=
name|base_fndecl_list
expr_stmt|;
while|while
condition|(
name|base_fndecls
condition|)
block|{
comment|/* If we haven't found one we like, first one wins.  */
if|if
condition|(
name|true_base_fndecl
operator|==
literal|0
condition|)
name|true_base_fndecl
operator|=
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
name|modify_vtable_entries
argument_list|(
name|current_class_type
argument_list|,
name|x
argument_list|,
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
name|DECL_VCONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_VCONTEXT
argument_list|(
name|true_base_fndecl
argument_list|)
expr_stmt|;
block|}
return|return
name|pending_virtuals
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Obstack on which to build the vector of class methods.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|class_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add method METHOD to class TYPE.  This is used when a method    has been defined which did not initially appear in the class definition,    and helps cut down on spurious error messages.     FIELDS is the entry in the METHOD_VEC vector entry of the class type where    the method should be added.  */
end_comment

begin_function
name|void
name|add_method
parameter_list|(
name|type
parameter_list|,
name|fields
parameter_list|,
name|method
parameter_list|)
name|tree
name|type
decl_stmt|,
decl|*
name|fields
decl_stmt|,
name|method
decl_stmt|;
end_function

begin_block
block|{
comment|/* We must make a copy of METHOD here, since we must be sure that      we have exclusive title to this method's TREE_CHAIN.  */
name|int
name|temp
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|temp
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|{
name|decl
operator|=
name|copy_node
argument_list|(
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|make_function_rtl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fields
operator|&&
operator|*
name|fields
condition|)
block|{
comment|/* Take care not to hide destructor.  */
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|fields
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
operator|*
name|fields
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|method_vec
init|=
name|make_node
argument_list|(
name|TREE_VEC
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DECL_ORIGINAL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|obstack_free
argument_list|(
name|current_obstack
argument_list|,
name|method_vec
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
name|current_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
literal|2
expr_stmt|;
name|obstack_finish
argument_list|(
name|current_obstack
argument_list|)
expr_stmt|;
block|}
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|method_vec
expr_stmt|;
block|}
else|else
block|{
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
comment|/* Adding a new ctor or dtor.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DECL_ORIGINAL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|tree
modifier|*
name|end
init|=
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
condition|)
block|{
name|tree
name|tmp_vec
init|=
name|copy_node
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
name|obstack_copy
argument_list|(
name|current_obstack
argument_list|,
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
name|current_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
name|current_obstack
argument_list|)
expr_stmt|;
name|method_vec
operator|=
name|tmp_vec
expr_stmt|;
block|}
else|else
block|{
comment|/* We can easily extend the last such method_vec created.  */
name|obstack_free
argument_list|(
operator|&
name|class_obstack
argument_list|,
name|method_vec
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|class_obstack
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|end
operator|-
operator|(
name|char
operator|*
operator|)
name|method_vec
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|method_vec
operator|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|len
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|method_vec
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* ??? May be better to know whether these can be extended?  */
name|tree
name|baselink_vec
init|=
name|copy_node
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|obstack_copy
argument_list|(
name|current_obstack
argument_list|,
operator|&
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|baselink_vec
argument_list|,
name|len
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|baselink_vec
argument_list|)
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|type
argument_list|)
operator|=
name|baselink_vec
expr_stmt|;
block|}
block|}
block|}
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_VCONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Subroutines of finish_struct.  */
end_comment

begin_comment
comment|/* Look through the list of fields for this struct, deleting    duplicates as we go.  This must be recursive to handle    anonymous unions.     FIELD is the field which may not appear anywhere in FIELDS.    FIELD_PTR, if non-null, is the starting point at which    chained deletions may take place.    The value returned is the first acceptable entry found    in FIELDS.     Note that anonymous fields which are not of UNION_TYPE are    not duplicates, they are just anonymous fields.  This happens    when we have unnamed bitfields, for example.  */
end_comment

begin_function
specifier|static
name|tree
name|delete_duplicate_fields_1
parameter_list|(
name|field
parameter_list|,
name|field_ptr
parameter_list|,
name|fields
parameter_list|)
name|tree
name|field
decl_stmt|,
decl|*
name|field_ptr
decl_stmt|,
name|fields
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|x
decl_stmt|;
name|tree
name|prev
init|=
name|field_ptr
condition|?
operator|*
name|field_ptr
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
return|return
name|fields
return|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|fields
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
name|field_ptr
argument_list|,
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|fields
expr_stmt|;
return|return
name|fields
return|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|prev
operator|=
name|x
operator|,
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
continue|continue;
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|field
argument_list|,
literal|0
argument_list|,
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"duplicate enum value `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|CONST_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"duplicate field `%s' (as enum and non-enum)"
argument_list|)
expr_stmt|;
else|else
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"duplicate member `%s'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|fields
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|delete_duplicate_fields
parameter_list|(
name|fields
parameter_list|)
name|tree
name|fields
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
operator|&&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|delete_duplicate_fields_1
argument_list|(
name|x
argument_list|,
operator|&
name|x
argument_list|,
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add OFFSET to all child types of T.     OFFSET, which is a type offset, is number of bytes.     Note that we don't have to worry about having two paths to the    same base type, since this type owns its association list.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_basetype_offsets
parameter_list|(
name|for_type
parameter_list|,
name|t
parameter_list|,
name|offset
parameter_list|)
name|tree
name|for_type
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baselinks
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baselinks
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|tree
name|basetype
init|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|assoc
init|=
name|assoc_value
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|for_type
argument_list|)
decl_stmt|;
name|tree
name|delta
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<=
name|n_baselinks
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
condition|)
block|{
comment|/* The next basetype offset must take into account the space 		 between the classes, not just the size of each class.  */
name|delta
operator|=
name|genop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|CLASSTYPE_OFFSET
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
name|CLASSTYPE_OFFSET
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|CLASSTYPE_OFFSET
argument_list|(
name|basetype
argument_list|)
operator|==
name|integer_zero_node
condition|)
name|basetype
operator|=
name|build_classtype_variant
argument_list|(
name|basetype
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|basetype
operator|=
name|build_classtype_variant
argument_list|(
name|basetype
argument_list|,
name|genop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|CLASSTYPE_OFFSET
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now make our own copy of this base type we can munge.  */
name|basetype
operator|=
name|copy_node
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|copy_type_lang_specific
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|ASSOC_TYPE
argument_list|(
name|assoc
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|ASSOC_OFFSET
argument_list|(
name|assoc
argument_list|)
operator|=
name|CLASSTYPE_OFFSET
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|=
name|copy_node
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|CLASSTYPE_OFFSET
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|propagate_basetype_offsets
argument_list|(
name|for_type
argument_list|,
name|basetype
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Go to our next class that counts for offset propagation.  */
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<=
name|n_baselinks
condition|)
name|offset
operator|=
name|genop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Change the visibility of T::FDECL to VISIBILITY.    Return 1 if change was legit, otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|alter_visibility
parameter_list|(
name|t
parameter_list|,
name|fdecl
parameter_list|,
name|visibility
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|fdecl
decl_stmt|;
name|enum
name|visibility_type
name|visibility
decl_stmt|;
block|{
name|tree
name|elem
init|=
name|purpose_member
argument_list|(
name|t
argument_list|,
name|DECL_VISIBILITY
argument_list|(
name|fdecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|elem
operator|&&
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
operator|!=
operator|(
name|tree
operator|)
name|visibility
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
argument_list|,
literal|"conflicting visibility specifications for method `%s', ignored"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"conflicting visibility specifications for field `%s', ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fdecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fdecl
argument_list|)
operator|&&
name|visibility
operator|!=
name|visibility_private
condition|)
name|error_with_decl
argument_list|(
name|fdecl
argument_list|,
literal|"cannot make private %s non-private"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fdecl
argument_list|)
operator|&&
name|visibility
operator|==
name|visibility_public
condition|)
name|error_with_decl
argument_list|(
name|fdecl
argument_list|,
literal|"cannot make protected %s public"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|elem
operator|==
name|NULL_TREE
condition|)
block|{
name|DECL_VISIBILITY
argument_list|(
name|fdecl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|t
argument_list|,
operator|(
name|tree
operator|)
name|visibility
argument_list|,
name|DECL_VISIBILITY
argument_list|(
name|fdecl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If FOR_TYPE needs to reinitialize virtual function table pointers    for TYPE's sub-objects, add such reinitializations to BASE_INIT_LIST.    Returns BASE_INIT_LIST appropriately modified.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_fixup_vptrs
parameter_list|(
name|for_type
parameter_list|,
name|type
parameter_list|,
name|base_init_list
parameter_list|)
name|tree
name|for_type
decl_stmt|,
name|type
decl_stmt|,
name|base_init_list
decl_stmt|;
block|{
comment|/* Now reinitialize any slots that don't fall under our virtual      function table pointer.  */
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
name|tree
name|basetype
init|=
name|get_base_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|vfields
argument_list|)
argument_list|,
name|for_type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|(
operator|(
name|DECL_OFFSET
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|+
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|)
operator|!=
name|DECL_OFFSET
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|for_type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|DECL_OFFSET
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|+
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|)
operator|!=
operator|(
name|DECL_OFFSET
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
operator|+
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|error_mark_node
argument_list|,
name|basetype
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
return|return
name|base_init_list
return|;
block|}
end_function

begin_comment
comment|/* If TYPE does not have a constructor, then the compiler must    manually deal with all of the initialization this type requires.     If a base initializer exists only to fill in the virtual function    table pointer, then we mark that fact with the TREE_VIRTUAL bit.    This way, we avoid multiple initializations of the same field by    each virtual function table up the class hierarchy.     Virtual base class pointers are not initialized here.  They are    initialized only at the "top level" of object creation.  If we    initialized them here, we would have to skip a lot of work.  */
end_comment

begin_function
specifier|static
name|void
name|build_class_init_list
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|base_init_list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|member_init_list
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Since we build member_init_list and base_init_list using      tree_cons, backwards fields the all through work.  */
name|tree
name|x
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|member_init_list
operator|=
name|tree_cons
argument_list|(
name|x
argument_list|,
name|type
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
block|}
name|member_init_list
operator|=
name|nreverse
argument_list|(
name|member_init_list
argument_list|)
expr_stmt|;
comment|/* We will end up doing this last.  Need special marker      to avoid infinite regress.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|error_mark_node
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TREE_VALUE
argument_list|(
name|base_init_list
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|base_init_list
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Each base class which needs to have initialization      of some kind gets to make such requests known here.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|blist
decl_stmt|;
comment|/* Don't initialize virtual baseclasses this way.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
comment|/* ...and the last shall come first...  */
name|base_init_list
operator|=
name|maybe_fixup_vptrs
argument_list|(
name|type
argument_list|,
name|basetype
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|basetype
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|blist
operator|=
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|basetype
argument_list|)
operator|)
operator|==
name|NULL_TREE
condition|)
comment|/* Nothing to initialize.  */
continue|continue;
comment|/* ...ditto...  */
name|base_init_list
operator|=
name|maybe_fixup_vptrs
argument_list|(
name|type
argument_list|,
name|basetype
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
comment|/* This is normally true for single inheritance. 	 The win is we can shrink the chain of initializations 	 to be done by only converting to the actual type 	 we are interested in.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
operator|(
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|==
name|DECL_OFFSET
argument_list|(
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|blist
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|base_init_list
condition|)
block|{
comment|/* Does it do more than just fill in a 		 virtual function table pointer?  */
if|if
condition|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|blist
argument_list|)
condition|)
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|blist
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
comment|/* Can we get by just with the virtual function table 		 pointer that it fills in?  */
elseif|else
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|base_init_list
argument_list|)
operator|&&
name|TREE_VALUE
argument_list|(
name|base_init_list
argument_list|)
operator|==
literal|0
condition|)
name|base_init_list
operator|=
name|blist
expr_stmt|;
comment|/* Maybe, but it is not obvious as the previous case.  */
elseif|else
if|if
condition|(
operator|!
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|base_init_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|last
operator|=
name|tree_last
argument_list|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|==
literal|0
condition|)
name|base_init_list
operator|=
name|build_tree_list
argument_list|(
name|blist
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|base_init_list
operator|=
name|blist
expr_stmt|;
block|}
else|else
block|{
comment|/* The function expand_aggr_init knows how to do the 	     initialization of `basetype' without getting 	     an explicit `blist'.  */
if|if
condition|(
name|base_init_list
condition|)
name|base_init_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|basetype
argument_list|,
name|base_init_list
argument_list|)
expr_stmt|;
else|else
name|base_init_list
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base_init_list
condition|)
if|if
condition|(
name|member_init_list
condition|)
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|base_init_list
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
else|else
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|base_init_list
expr_stmt|;
elseif|else
if|if
condition|(
name|member_init_list
condition|)
name|CLASSTYPE_BASE_INIT_LIST
argument_list|(
name|type
argument_list|)
operator|=
name|member_init_list
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|base_info
block|{
name|int
name|has_virtual
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
name|int
name|n_ancestors
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
name|tree
name|vfields
decl_stmt|;
name|char
name|needs_default_ctor
decl_stmt|;
name|char
name|cant_have_default_ctor
decl_stmt|;
name|char
name|needs_const_ctor
decl_stmt|;
name|char
name|cant_have_const_ctor
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record information about type T derived from its base classes.    Store most of that information in T itself, and place the    remaining information in the struct BASE_INFO.     Returns the index of the first base class to have virtual functions,    or zero if no such base class.  */
end_comment

begin_function
specifier|static
name|int
name|finish_base_struct
parameter_list|(
name|t
parameter_list|,
name|b
parameter_list|)
name|tree
name|t
decl_stmt|;
name|struct
name|base_info
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|first_vfn_base_index
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|base_info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|basetype
init|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If the type of basetype is incomplete, then 	 we already complained about that fact 	 (and we should have fixed it up as well).  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* The base type is of incomplete type.  It is 	     probably best to pretend that it does not 	     exist.  */
if|if
condition|(
name|i
operator|==
name|n_baseclasses
condition|)
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|n_baseclasses
operator|-=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|n_baseclasses
condition|;
name|j
operator|++
control|)
block|{
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
operator|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_VIAS
argument_list|(
name|t
argument_list|,
name|j
argument_list|,
name|CLASSTYPE_VIA_PUBLIC
argument_list|(
name|t
argument_list|,
name|j
operator|+
literal|1
argument_list|)
argument_list|,
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|,
name|j
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_WRAP_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|TYPE_WRAP_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_WRAP_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_WRAP_TYPE
argument_list|(
name|basetype
argument_list|)
operator|&&
name|TYPE_WRAP_TYPE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_WRAP_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
comment|/* Must have its own.  */
name|TYPE_WRAP_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|needs_default_ctor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|needs_const_ctor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_GETS_INIT_REF
argument_list|(
name|basetype
argument_list|)
condition|)
name|b
operator|->
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_ALTERS_VISIBILITIES_P
argument_list|(
name|t
argument_list|)
operator||=
name|CLASSTYPE_ALTERS_VISIBILITIES_P
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|n_ancestors
operator|+=
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_ANY_ASSIGNS_THIS
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_ANY_ASSIGNS_THIS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_GETS_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_INIT_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_OFFSET
argument_list|(
name|basetype
argument_list|)
operator|!=
name|integer_zero_node
condition|)
block|{
comment|/* Completely unshare potentially shared data, and 	     update what is ours.  */
name|tree
name|assoc
init|=
name|assoc_value
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|basetype
operator|=
name|copy_node
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|copy_type_lang_specific
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|basetype
expr_stmt|;
name|ASSOC_TYPE
argument_list|(
name|assoc
argument_list|)
operator|=
name|basetype
expr_stmt|;
comment|/* Propagate this offset through all the children.  Do this 	     before uniquizing baseclasses for virtual functions.  */
name|CLASSTYPE_ASSOC
argument_list|(
name|basetype
argument_list|)
operator|=
name|copy_assoc
argument_list|(
name|CLASSTYPE_ASSOC
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|propagate_basetype_offsets
argument_list|(
name|basetype
argument_list|,
name|basetype
argument_list|,
name|CLASSTYPE_OFFSET
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|t
argument_list|)
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
operator|>
name|b
operator|->
name|max_has_virtual
condition|)
name|b
operator|->
name|max_has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* Don't borrow virtuals from virtual baseclasses.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|first_vfn_base_index
operator|==
literal|0
condition|)
block|{
name|first_vfn_base_index
operator|=
name|i
expr_stmt|;
name|b
operator|->
name|has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfield
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfields
operator|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|b
operator|->
name|vfield
expr_stmt|;
block|}
else|else
block|{
comment|/* Only add unique vfields, and flatten them out as we go.  */
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|vfields
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_VIA_VIRTUAL
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|vfields
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|vfields
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|==
name|value
condition|)
name|b
operator|->
name|vfields
operator|=
name|tree_cons
argument_list|(
name|basetype
argument_list|,
name|value
argument_list|,
name|b
operator|->
name|vfields
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|vfields
operator|=
name|tree_cons
argument_list|(
name|get_base_type
argument_list|(
name|value
argument_list|,
name|basetype
argument_list|,
literal|0
argument_list|)
argument_list|,
name|value
argument_list|,
name|b
operator|->
name|vfields
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|vfields
argument_list|)
operator|=
name|basetype
expr_stmt|;
block|}
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|->
name|has_virtual
operator|==
literal|0
condition|)
block|{
name|first_vfn_base_index
operator|=
name|i
expr_stmt|;
name|b
operator|->
name|has_virtual
operator|=
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|b
operator|->
name|vfield
operator|=
name|CLASSTYPE_VFIELD
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|b
operator|->
name|vfield
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|b
operator|->
name|vfield
operator|==
literal|0
condition|)
comment|/* If all virtual functions come only from virtual baseclasses.  */
return|return
literal|0
return|;
return|return
name|first_vfn_base_index
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|typecode_p
parameter_list|(
name|type
parameter_list|,
name|code
parameter_list|)
name|tree
name|type
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|code
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|code
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set memoizing fields and bits of T (and its variants) for later use.    FIRST_VFN_BASE_INDEX is the first baseclass of T with virtual functions.    MAX_HAS_VIRTUAL is the largest size of any T's virtual function tables.  */
end_comment

begin_function
specifier|static
name|void
name|finish_struct_bits
parameter_list|(
name|t
parameter_list|,
name|first_vfn_base_index
parameter_list|,
name|max_has_virtual
parameter_list|)
name|tree
name|t
decl_stmt|;
name|int
name|first_vfn_base_index
decl_stmt|,
name|max_has_virtual
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Fix up variants (if any).  */
name|tree
name|variants
init|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|variants
condition|)
block|{
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|variants
argument_list|)
operator|=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
operator|&&
name|max_has_virtual
condition|)
block|{
comment|/* Done by `finish_struct' for classes without baseclasses.  */
name|int
name|has_abstract_virtuals
init|=
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|has_abstract_virtuals
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
name|has_abstract_virtuals
operator||=
operator|(
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|has_abstract_virtuals
condition|)
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|get_abstract_virtuals
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_baseclasses
condition|)
block|{
comment|/* Notice whether this class has type conversion functions defined. 	 Also report whether joining two types yields an ambiguity in the 	 virtual function table, e.g., 	  	 struct A { virtual int f (); }; 	 struct B { virtual int f (); }; 	 struct C : A, B { / * no f (); * / };	/ / error, ambiguous 	 */
name|tree
name|basetypes
init|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|basetype
decl_stmt|;
name|int
name|n_vbases
init|=
name|list_length
argument_list|(
name|basetypes
argument_list|)
decl_stmt|,
name|j
decl_stmt|;
name|build_mi_virtuals
argument_list|(
name|n_baseclasses
operator|+
operator|(
name|n_vbases
operator|*
name|n_baseclasses
operator|)
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
comment|/* Fill in virutal function table with values which do not come 	 "normal"ly, i.e., those which come from virtual and/or 	 non-leftmost base classes.  */
for|for
control|(
name|i
operator|=
name|n_baseclasses
init|;
name|basetypes
condition|;
name|basetypes
operator|=
name|TREE_CHAIN
argument_list|(
name|basetypes
argument_list|)
control|)
block|{
name|basetype
operator|=
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
name|n_baseclasses
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tree
name|this_base
init|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_base_distance
argument_list|(
name|basetype
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|this_base
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|add_mi_virtuals
argument_list|(
operator|++
name|i
argument_list|,
name|TREE_CHAIN
argument_list|(
name|ASSOC_VIRTUALS
argument_list|(
name|basetypes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|n_baseclasses
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basetype
operator|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|TYPE_HAS_CONVERSION
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype
argument_list|)
condition|)
comment|/* Virtual functions from virtual baseclasses are done above.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|first_vfn_base_index
condition|)
name|add_mi_virtuals
argument_list|(
name|i
argument_list|,
name|TREE_CHAIN
argument_list|(
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|basetype
argument_list|)
operator|!=
literal|0
condition|)
name|add_mi_virtuals
argument_list|(
name|i
argument_list|,
name|TREE_CHAIN
argument_list|(
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|basetype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|report_ambiguous_mi_virtuals
argument_list|(
name|n_baseclasses
operator|+
operator|(
name|n_vbases
operator|*
name|n_baseclasses
operator|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Now that we know what the virtual functiond table looks like, 	 fix up offsets in the presence of virtual base classes.  */
block|if (n_vbases) 	fixup_vbase_offsets (t);
endif|#
directive|endif
block|}
comment|/* Need to test METHOD_VEC here in case all methods      (conversions and otherwise) are inherited.  */
if|if
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|t
argument_list|)
operator|&&
name|method_vec
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|first_conversions
index|[
name|last_conversion_type
index|]
decl_stmt|;
name|tree
name|last_conversions
index|[
name|last_conversion_type
index|]
decl_stmt|;
name|enum
name|conversion_type
name|conv_index
decl_stmt|;
name|tree
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|first_conversions
argument_list|,
sizeof|sizeof
argument_list|(
name|first_conversions
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|1
argument_list|)
init|;
name|tmp
operator|!=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
condition|;
name|tmp
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|OPERATOR_TYPENAME_P
argument_list|(
name|DECL_ORIGINAL_NAME
argument_list|(
operator|*
name|tmp
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|tmp
argument_list|)
decl_stmt|;
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|typecode_p
argument_list|(
name|return_type
argument_list|,
name|POINTER_TYPE
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|return_type
argument_list|)
argument_list|)
condition|)
name|conv_index
operator|=
name|constptr_conv
expr_stmt|;
else|else
name|conv_index
operator|=
name|ptr_conv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typecode_p
argument_list|(
name|return_type
argument_list|,
name|INTEGER_TYPE
argument_list|)
condition|)
block|{
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|conv_index
operator|=
name|int_conv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typecode_p
argument_list|(
name|return_type
argument_list|,
name|REAL_TYPE
argument_list|)
condition|)
block|{
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|conv_index
operator|=
name|real_conv
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
name|first_conversions
index|[
operator|(
name|int
operator|)
name|conv_index
index|]
operator|==
name|NULL_TREE
condition|)
name|first_conversions
index|[
operator|(
name|int
operator|)
name|conv_index
index|]
operator|=
operator|*
name|tmp
expr_stmt|;
name|last_conversions
index|[
operator|(
name|int
operator|)
name|conv_index
index|]
operator|=
operator|*
name|tmp
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|last_conversion_type
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|first_conversions
index|[
name|i
index|]
operator|!=
name|last_conversions
index|[
name|i
index|]
condition|)
name|CLASSTYPE_CONVERSION
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|CLASSTYPE_CONVERSION
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|first_conversions
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* If this type has constructors, force its mode to be BLKmode,      and force its TREE_ADDRESSABLE bit to be nonzero.  */
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|variants
init|=
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|DECL_MODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
while|while
condition|(
name|variants
condition|)
block|{
name|TYPE_MODE
argument_list|(
name|variants
argument_list|)
operator|=
name|BLKmode
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|variants
argument_list|)
operator|=
literal|1
expr_stmt|;
name|variants
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|variants
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration    (or C++ class declaration).     For C++, we must handle the building of derived classes.    Also, C++ allows static class members.  The way that this is    handled is to keep the field name where it is (as the DECL_NAME    of the field), and place the overloaded decl in the DECL_OFFSET    of the field.  layout_record and layout_union will know about this.     More C++ hair: inline functions have text in their    DECL_PENDING_INLINE_INFO nodes which must somehow be parsed into    meaningful tree structure.  After the struct has been laid out, set    things up so that this can happen.     And still more: virtual functions.  In the case of single inheritance,    when a new virtual function is seen which redefines a virtual function    from the base class, the new virtual function is placed into    the virtual function table at exactly the same address that    it had in the base class.  When this is extended to multiple    inheritance, the same thing happens, except that multiple virtual    function tables must be maintained.  The first virtual function    table is treated in exactly the same way as in the case of single    inheritance.  Additional virtual function tables have different    DELTAs, which tell how to adjust `this' to point to the right thing.     LIST_OF_FIELDLISTS is just that.  The elements of the list are    TREE_LIST elements, whose TREE_PURPOSE field tells what visibility    the list has, and the TREE_VALUE slot gives the actual fields.     EMPTY is non-zero if this structure has no declarations following it.     If flag_all_virtual == 1, then we lay all functions into    the virtual function table, as though they were declared    virtual.  Constructors do not lay down in the virtual function table.     If flag_all_virtual == 2, then we lay all functions into    the virtual function table, such that virtual functions    occupy a space by themselves, and then all functions    of the class occupy a space by themselves.  This is illustrated    in the following diagram:     class A; class B : A;  	Class A's vtbl:			Class B's vtbl:     --------------------------------------------------------------------    | A's virtual functions|		| B's virtual funcitions	|    |			  |		| (may inherit some from A).	|     --------------------------------------------------------------------    | All of A's functions |		| All of A's functions		|    | (such as a->A::f).	  |		| (such as b->A::f)		|     -------------------------------------------------------------------- 					| B's new virtual functions	| 					| (not defined in A.)		| 					 ------------------------------- 					| All of B's functions		| 					| (such as b->B::f)		| 					 -------------------------------     this allows the program to make references to any function, virtual    or otherwise in a type-consistant manner.  */
end_comment

begin_function
name|tree
name|finish_struct
parameter_list|(
name|t
parameter_list|,
name|list_of_fieldlists
parameter_list|,
name|empty
parameter_list|,
name|warn_anon
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|list_of_fieldlists
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|int
name|warn_anon
decl_stmt|;
block|{
specifier|extern
name|int
name|interface_only
decl_stmt|,
name|interface_unknown
decl_stmt|;
name|int
name|old
decl_stmt|;
name|int
name|round_up_size
init|=
literal|1
decl_stmt|;
comment|/* Set non-zero to debug using default functions.      Not set by program.  */
specifier|static
name|int
name|debug_default_functions
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|x
decl_stmt|,
name|y
decl_stmt|,
name|method_vec
decl_stmt|;
name|int
name|needs_ctor
init|=
literal|0
decl_stmt|,
name|needs_dtor
init|=
literal|0
decl_stmt|;
name|int
name|members_need_dtors
init|=
literal|0
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|fields
decl_stmt|,
name|fn_fields
decl_stmt|,
name|tail
decl_stmt|;
name|enum
name|visibility_type
name|visibility
decl_stmt|;
name|int
name|all_virtual
decl_stmt|;
name|int
name|has_virtual
decl_stmt|;
name|int
name|max_has_virtual
decl_stmt|;
name|tree
name|pending_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|abstract_virtuals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vfield
decl_stmt|;
name|tree
name|vfields
decl_stmt|;
name|int
name|needs_default_ctor
decl_stmt|;
name|int
name|cant_have_default_ctor
decl_stmt|;
name|int
name|needs_const_ctor
decl_stmt|;
name|int
name|cant_have_const_ctor
decl_stmt|;
comment|/* The index of the first base class which has virtual      functions.  Only applied to non-virtual baseclasses.  */
name|int
name|first_vfn_base_index
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
decl_stmt|;
name|int
name|any_default_members
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|err_name
decl_stmt|;
name|int
name|const_sans_init
init|=
literal|0
decl_stmt|;
name|int
name|ref_sans_init
init|=
literal|0
decl_stmt|;
name|int
name|nonprivate_method
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
specifier|extern
name|int
name|lineno
decl_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|name
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|name
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|err_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_anon
operator|&&
name|code
operator|!=
name|UNION_TYPE
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"un-usable class ignored (anonymous classes and unions are useless)"
argument_list|)
expr_stmt|;
name|err_name
operator|=
literal|"(anon)"
expr_stmt|;
block|}
name|leftmost_baseclasses
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"redefinition of `union %s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|error
argument_list|(
literal|"redefinition of `struct %s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|popclass
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_decl
argument_list|(
name|current_function_decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_GOT_SEMICOLON
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
operator|=
name|interface_unknown
expr_stmt|;
name|old
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
comment|/* Install struct as DECL_FIELD_CONTEXT of each field decl.      Also process specified field sizes.      Set DECL_SIZE_UNIT to the specified size, or 0 if none specified.      The specified size is found in the DECL_INITIAL.      Store 0 there, except for ": 0" fields (so we can find them      and delete them, below).  */
name|n_baseclasses
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_baseclasses
operator|>=
literal|1
condition|)
block|{
name|struct
name|base_info
name|base_info
decl_stmt|;
comment|/* If using multiple inheritance, this may cause variants of our 	 basetypes to be used (instead of their canonical forms).  */
name|fields
operator|=
name|layout_basetypes
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|y
operator|=
name|tree_last
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|first_vfn_base_index
operator|=
name|finish_base_struct
argument_list|(
name|t
argument_list|,
operator|&
name|base_info
argument_list|)
expr_stmt|;
name|has_virtual
operator|=
name|base_info
operator|.
name|has_virtual
expr_stmt|;
name|max_has_virtual
operator|=
name|base_info
operator|.
name|max_has_virtual
expr_stmt|;
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|t
argument_list|)
operator|+=
name|base_info
operator|.
name|n_ancestors
expr_stmt|;
name|vfield
operator|=
name|base_info
operator|.
name|vfield
expr_stmt|;
name|vfields
operator|=
name|base_info
operator|.
name|vfields
expr_stmt|;
name|needs_default_ctor
operator|=
name|base_info
operator|.
name|needs_default_ctor
expr_stmt|;
name|cant_have_default_ctor
operator|=
name|base_info
operator|.
name|cant_have_default_ctor
expr_stmt|;
name|needs_const_ctor
operator|=
name|base_info
operator|.
name|needs_const_ctor
expr_stmt|;
name|cant_have_const_ctor
operator|=
name|base_info
operator|.
name|cant_have_const_ctor
expr_stmt|;
name|n_baseclasses
operator|=
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first_vfn_base_index
operator|=
literal|0
expr_stmt|;
name|has_virtual
operator|=
literal|0
expr_stmt|;
name|max_has_virtual
operator|=
literal|0
expr_stmt|;
name|vfield
operator|=
name|NULL_TREE
expr_stmt|;
name|vfields
operator|=
name|NULL_TREE
expr_stmt|;
name|fields
operator|=
name|NULL_TREE
expr_stmt|;
name|y
operator|=
name|NULL_TREE
expr_stmt|;
name|needs_default_ctor
operator|=
literal|0
expr_stmt|;
name|cant_have_default_ctor
operator|=
literal|0
expr_stmt|;
name|needs_const_ctor
operator|=
literal|0
expr_stmt|;
name|cant_have_const_ctor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|write_virtuals
operator|==
literal|3
operator|&&
operator|!
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|interface_only
expr_stmt|;
name|CLASSTYPE_VTABLE_NEEDS_WRITING
argument_list|(
name|t
argument_list|)
operator|=
operator|!
name|interface_only
expr_stmt|;
block|}
comment|/* The three of these are approximations which may later be      modified.  Needed at this point to make add_virtual_function      and modify_vtable_entries work.  */
name|CLASSTYPE_ASSOC
argument_list|(
name|t
argument_list|)
operator|=
name|make_assoc
argument_list|(
name|integer_zero_node
argument_list|,
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CLASSTYPE_ASSOC
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|vfields
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|fn_fields
operator|=
name|NULL_TREE
expr_stmt|;
name|tail
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|y
operator|&&
name|list_of_fieldlists
condition|)
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOS
if|if
condition|(
name|flag_all_virtual
operator|==
literal|2
condition|)
name|all_virtual
operator|=
literal|2
expr_stmt|;
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|flag_all_virtual
operator|==
literal|1
operator|&&
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|t
argument_list|)
condition|)
name|all_virtual
operator|=
literal|1
expr_stmt|;
else|else
name|all_virtual
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|list_of_fieldlists
operator|&&
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_default
condition|)
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|visibility_public
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|list_of_fieldlists
operator|&&
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|visibility_default
condition|)
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|visibility_private
expr_stmt|;
while|while
condition|(
name|list_of_fieldlists
condition|)
block|{
name|visibility
operator|=
operator|(
expr|enum
name|visibility_type
operator|)
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
operator|=
name|visibility
operator|==
name|visibility_private
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|x
argument_list|)
operator|=
name|visibility
operator|==
name|visibility_protected
expr_stmt|;
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Clear out this flag.  	         @@ Doug may figure out how to break 		 @@ this with nested classes and friends.  */
name|DECL_IN_AGGR_P
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|nonprivate_method
operator||=
operator|!
name|TREE_PRIVATE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this was an evil function, don't keep it in class.  */
if|if
condition|(
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|y
condition|)
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fn_fields
condition|)
name|fn_fields
operator|=
name|x
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|x
expr_stmt|;
name|tail
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
condition|)
continue|continue;
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_VCONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The name of the field is the original field name 		 Save this in auxiliary field for later overloading.  */
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|all_virtual
operator|==
literal|1
operator|&&
operator|!
name|DECL_CONSTRUCTOR_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|pending_virtuals
operator|=
name|add_virtual_function
argument_list|(
name|pending_virtuals
argument_list|,
operator|&
name|has_virtual
argument_list|,
name|x
argument_list|,
name|first_vfn_base_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|abstract_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|abstract_virtuals
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Handle visibility declarations.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|tree
name|fdecl
init|=
name|TREE_OPERAND
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
condition|)
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Make type T see field decl FDECL with 		 the visibility VISIBILITY.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fdecl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|fdecl
operator|=
name|TREE_VALUE
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
while|while
condition|(
name|fdecl
condition|)
block|{
if|if
condition|(
name|alter_visibility
argument_list|(
name|t
argument_list|,
name|fdecl
argument_list|,
name|visibility
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|fdecl
operator|=
name|TREE_CHAIN
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|alter_visibility
argument_list|(
name|t
argument_list|,
name|fdecl
argument_list|,
name|visibility
argument_list|)
expr_stmt|;
name|CLASSTYPE_ALTERS_VISIBILITIES_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Perform error checking that did not get done in grokdeclarator.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"field `%s' invalidly declared function type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"field `%s' invalidly declared method type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"field `%s' invalidly declared offset type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is of reference type, check if it needs an init.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|ref_sans_init
operator|=
literal|1
expr_stmt|;
comment|/* When this goes into scope, it will be a non-local reference.  */
name|TREE_NONLOCAL
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* Never let anything with uninheritable virutals 		 make it through without complaint.  */
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|abstract_virtuals_error
argument_list|(
name|x
argument_list|,
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|needs_default_ctor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|needs_const_ctor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_GETS_INIT_REF
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|cant_have_const_ctor
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
name|cant_have_default_ctor
operator|=
literal|1
expr_stmt|;
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|const_sans_init
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* A field that is pseudo-const makes the structure likewise.  */
name|tree
name|t1
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|t1
argument_list|)
condition|)
block|{
if|if
condition|(
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t1
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t1
argument_list|)
condition|)
name|const_sans_init
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
comment|/* Unions cannot have static members.  */
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"field `%s' declared static in union"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fields
condition|)
name|fields
operator|=
name|x
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_PACKED
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Invalid bit-field size done by grokfield.  */
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' has invalid type"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|pedantic
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|integer_type_node
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|unsigned_type_node
condition|)
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' type invalid in ANSI C"
argument_list|)
expr_stmt|;
comment|/* Detect and ignore out of range field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|register
name|int
name|width
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"negative width in bit-field `%s'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|==
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"zero width for bit-field `%s'"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"width of `%s' exceeds its type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process valid field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|register
name|int
name|width
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
comment|/* field size 0 => mark following field as "aligned" */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_ALIGN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|EMPTY_FIELD_BOUNDARY
argument_list|)
expr_stmt|;
comment|/* field of size 0 at the end => round up the size.  */
else|else
name|round_up_size
operator|=
name|EMPTY_FIELD_BOUNDARY
expr_stmt|;
block|}
else|else
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|x
argument_list|)
operator|=
name|width
expr_stmt|;
name|TREE_PACKED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Traditionally a bit field is unsigned 			 even if declared signed.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
block|}
else|else
comment|/* Non-bit-fields are aligned for their type.  */
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"member %s::%s with constructor not allowed in union"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"member %s::%s with destructor (also) not allowed in union"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
block|{
comment|/* Array of record type doesn't matter for this bit.  */
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|needs_ctor
operator||=
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|needs_dtor
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|members_need_dtors
operator||=
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_GETS_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_INIT_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_GETS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* `build_class_init_list' does not recognize non-FIELD_DECLs.  */
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
operator|&&
name|any_default_members
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"multiple fields in union initialized"
argument_list|)
expr_stmt|;
name|any_default_members
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|y
operator|=
name|x
expr_stmt|;
block|}
name|list_of_fieldlists
operator|=
name|TREE_CHAIN
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
comment|/* link the tail while we have it! */
if|if
condition|(
name|y
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|list_of_fieldlists
operator|&&
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tail
condition|)
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If this type has any constant members which did not come      with their own initialization, mark that fact here.  It is      not an error here, since such types can be saved either by their      constructors, or by fortuitous initialization.  */
name|CLASSTYPE_READONLY_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
name|const_sans_init
expr_stmt|;
name|CLASSTYPE_REF_FIELDS_NEED_INIT
argument_list|(
name|t
argument_list|)
operator|=
name|ref_sans_init
expr_stmt|;
name|CLASSTYPE_ABSTRACT_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|abstract_virtuals
expr_stmt|;
if|if
condition|(
name|vfield
operator|==
literal|0
operator|&&
operator|(
name|has_virtual
ifdef|#
directive|ifdef
name|SOS
operator|||
name|TYPE_DYNAMIC
argument_list|(
name|t
argument_list|)
endif|#
directive|endif
operator|)
condition|)
block|{
comment|/* We build this decl with ptr_type_node, and 	 change the type when we know what it should be.  */
name|vfield
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_vfield_name
argument_list|(
name|t
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|vfield
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|SET_DECL_FCONTEXT
argument_list|(
name|vfield
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|vfield
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
condition|)
block|{
name|assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|y
operator|=
name|vfield
expr_stmt|;
block|}
else|else
name|fields
operator|=
name|vfield
expr_stmt|;
name|vfields
operator|=
name|chainon
argument_list|(
name|vfields
argument_list|,
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now DECL_INITIAL is null on all members except for zero-width bit-fields.      And they have already done their work.       C++: maybe we will support default field initialization some day...  */
comment|/* Delete all zero-width bit-fields from the front of the fieldlist */
while|while
condition|(
name|fields
operator|&&
name|TREE_PACKED
argument_list|(
name|fields
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|fields
argument_list|)
condition|)
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* Delete all such fields from the rest of the fields.  */
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PACKED
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Delete all duplicate fields from the fields */
name|delete_duplicate_fields
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* Now we have the final fieldlist for the data fields.  Record it,      then lay out the structure or union (including the fields).  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fields
expr_stmt|;
comment|/* If there's a :0 field at the end, round the size to the      EMPTY_FIELD_BOUNDARY.  */
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|round_up_size
expr_stmt|;
if|if
condition|(
name|debug_default_functions
condition|)
block|{
if|if
condition|(
operator|(
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|||
name|needs_ctor
operator|)
operator|&&
operator|!
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|default_fn
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|default_fn
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_VCONTEXT
argument_list|(
name|default_fn
argument_list|)
operator|=
name|t
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
name|TYPE_HAS_INIT_REF
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|default_fn
operator|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|default_fn
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_VCONTEXT
argument_list|(
name|default_fn
argument_list|)
operator|=
name|t
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
name|needs_default_ctor
operator|&&
operator|!
name|cant_have_default_ctor
condition|)
block|{
name|tree
name|default_fn
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|default_fn
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|default_fn
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_VCONTEXT
argument_list|(
name|default_fn
argument_list|)
operator|=
name|t
expr_stmt|;
name|fn_fields
operator|=
name|default_fn
expr_stmt|;
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Warn about duplicate methods in fn_fields.  Also compact      method lists so that lookup can be made faster.       Algorithm:  Outer loop builds lists by method name.      Inner loop checks for redundant method names within a list.       Data Structure:  List of method lists.  The outer list      is a TREE_LIST, whose TREE_PURPOSE field is the field name      and the TREE_VALUE is the TREE_CHAIN of the FUNCTION_DECLs.      Friends are chained in the same way as member functions, but      they live in the TREE_TYPE field of the outer list.      That allows them to be quicky deleted, and requires      no extra storage.       If there are any constructors/destructors, they are moved to      the front of the list.  This makes pushclass more efficient.       We also link each field which has shares a name with its      baseclass to the head of the list of fields for that base class.      This allows us to reduce search time in places like `build_method_call'      to consider only reasonably likely functions.  */
if|if
condition|(
name|fn_fields
condition|)
block|{
comment|/* Now prepare to gather fn_fields into vector.  */
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|method_vec
operator|=
name|make_node
argument_list|(
name|TREE_VEC
argument_list|)
expr_stmt|;
comment|/* Room has been saved for constructors and destructors.  */
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
comment|/* Now make this a live vector.  */
name|obstack_free
argument_list|(
operator|&
name|class_obstack
argument_list|,
name|method_vec
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|class_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fn_fields
condition|)
block|{
comment|/* NEXT Pointer, TEST Pointer, and BASE Pointer.  */
name|tree
name|nextp
decl_stmt|,
modifier|*
name|testp
decl_stmt|;
name|nextp
operator|=
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fn_fields
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Constrcutors are handled easily in search routines. 	     Besides, we know we wont find any, so do not bother looking.  */
if|if
condition|(
name|DECL_ORIGINAL_NAME
argument_list|(
name|fn_fields
argument_list|)
operator|==
name|name
operator|&&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
else|else
block|{
name|testp
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|testp
operator|==
name|NULL_TREE
condition|)
name|testp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|int
operator|)
name|testp
operator|<
operator|(
name|int
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
operator|&&
name|DECL_ORIGINAL_NAME
argument_list|(
operator|*
name|testp
argument_list|)
operator|!=
name|DECL_ORIGINAL_NAME
argument_list|(
name|fn_fields
argument_list|)
condition|)
name|testp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|testp
operator|<
operator|(
name|int
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
condition|)
block|{
for|for
control|(
name|x
operator|=
operator|*
name|testp
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fn_fields
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* We complain about multiple destructors on sight, 			     so we do not repeat the warning here.  Friend-friend 			     ambiguities are warned about outside this loop.  */
if|if
condition|(
operator|!
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
condition|)
name|error_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|fn_fields
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|fn_fields
argument_list|)
argument_list|,
literal|"ambiguous method `%s' in structure"
argument_list|,
name|lang_printable_name
argument_list|(
name|fn_fields
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|y
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|0
condition|)
if|if
condition|(
operator|*
name|testp
condition|)
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
operator|=
name|fn_fields
expr_stmt|;
else|else
operator|*
name|testp
operator|=
name|fn_fields
expr_stmt|;
block|}
else|else
block|{
name|obstack_ptr_grow
argument_list|(
operator|&
name|class_obstack
argument_list|,
name|fn_fields
argument_list|)
expr_stmt|;
name|method_vec
operator|=
operator|(
name|tree
operator|)
name|obstack_base
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
block|}
block|}
name|fn_fields
operator|=
name|nextp
expr_stmt|;
block|}
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
operator|(
name|tree
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|class_obstack
argument_list|)
operator|-
operator|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|method_vec
expr_stmt|;
if|if
condition|(
name|nonprivate_method
operator|==
literal|0
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n_baseclasses
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CLASSTYPE_VIA_PUBLIC
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|nonprivate_method
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nonprivate_method
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"all class member functions are private"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|method_vec
operator|=
literal|0
expr_stmt|;
comment|/* Just in case these got accidently 	 filled in by syntax errors.  */
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If there are constructors (and destructors), they are at the      front.  Place destructors at very front.  Also warn if all      constructors and/or destructors are private (in which case this      class is effectively unusable.  */
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|dtor
decl_stmt|,
name|prev
decl_stmt|;
for|for
control|(
name|dtor
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
init|;
name|dtor
condition|;
name|prev
operator|=
name|dtor
operator|,
name|dtor
operator|=
name|TREE_CHAIN
argument_list|(
name|dtor
argument_list|)
control|)
block|{
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|dtor
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|dtor
argument_list|)
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|warning_with_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|"class `%s' only defines a private destructor and has no friends"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Wild parse errors can cause this to happen.  */
if|if
condition|(
name|dtor
operator|==
name|NULL_TREE
condition|)
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dtor
operator|!=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|dtor
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|dtor
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|dtor
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|members_need_dtors
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Here we must cons up a destructor on the fly.  */
name|tree
name|dtor
init|=
name|cons_up_default_function
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we couldn't make it work, then pretend we didn't need it.  */
if|if
condition|(
name|dtor
operator|==
name|void_type_node
condition|)
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|DECL_CONTEXT
argument_list|(
name|dtor
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_VCONTEXT
argument_list|(
name|dtor
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|dtor
argument_list|)
condition|)
name|pending_virtuals
operator|=
name|add_virtual_function
argument_list|(
name|pending_virtuals
argument_list|,
operator|&
name|has_virtual
argument_list|,
name|dtor
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|dtor
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|method_vec
operator|==
literal|0
condition|)
block|{
comment|/* Now prepare to gather fn_fields into vector.  */
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|class_obstack
expr_stmt|;
name|method_vec
operator|=
name|make_node
argument_list|(
name|TREE_VEC
argument_list|)
expr_stmt|;
comment|/* Room has been saved for constructors and destructors.  */
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|method_vec
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
operator|=
name|dtor
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_FRIEND_CLASSES
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_FRIENDLIST
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|int
name|nonprivate_ctor
init|=
literal|0
decl_stmt|;
name|tree
name|ctor
decl_stmt|;
for|for
control|(
name|ctor
operator|=
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
init|;
name|ctor
condition|;
name|ctor
operator|=
name|TREE_CHAIN
argument_list|(
name|ctor
argument_list|)
control|)
if|if
condition|(
operator|!
name|TREE_PRIVATE
argument_list|(
name|ctor
argument_list|)
condition|)
block|{
name|nonprivate_ctor
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nonprivate_ctor
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"class %s only defines private constructors and has no friends"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now for each member function (except for constructors and      destructors), compute where member functions of the same      name reside in base classes.  */
if|if
condition|(
name|n_baseclasses
operator|!=
literal|0
operator|&&
name|method_vec
operator|!=
name|NULL_TREE
operator|&&
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
operator|>
literal|1
condition|)
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|method_vec
argument_list|)
decl_stmt|;
name|tree
name|baselink_vec
init|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|int
name|any_links
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|baselink_vec
argument_list|,
name|i
argument_list|)
operator|=
name|get_baselinks
argument_list|(
name|t
argument_list|,
name|DECL_ORIGINAL_NAME
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|baselink_vec
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|any_links
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|any_links
operator|!=
literal|0
condition|)
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|t
argument_list|)
operator|=
name|baselink_vec
expr_stmt|;
else|else
name|obstack_free
argument_list|(
name|current_obstack
argument_list|,
name|baselink_vec
argument_list|)
expr_stmt|;
block|}
comment|/* We can't know this information until we have seen all of the      constructors.  */
name|TYPE_NONE_ASSIGN_THIS
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Pass layout information about base classes to layout_type, if any.  */
if|if
condition|(
name|n_baseclasses
condition|)
block|{
name|tree
name|pseudo_basetype
init|=
name|TREE_TYPE
argument_list|(
name|base_layout_decl
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|base_layout_decl
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|pseudo_basetype
argument_list|)
operator|=
name|CLASSTYPE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|pseudo_basetype
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|pseudo_basetype
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|pseudo_basetype
argument_list|)
operator|=
name|CLASSTYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|pseudo_basetype
argument_list|)
expr_stmt|;
block|}
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_baseclasses
condition|)
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* C++: do not let empty structures exist.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
comment|/* Set the TYPE_DECL for this type to contain the right      value for DECL_OFFSET, so that we can use it as part      of a COMPONENT_REF for multiple inheritance.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|layout_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vbases
decl_stmt|;
name|max_has_virtual
operator|=
name|layout_vbasetypes
argument_list|(
name|t
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_N_VBASECLASSES
argument_list|(
name|t
argument_list|)
operator|=
name|list_length
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
comment|/* Now fix up any virtual base class types that we 	 left lying around.  We must get these done 	 before we try to lay out the virtual function table.  */
name|pending_hard_virtuals
operator|=
name|nreverse
argument_list|(
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* This loop makes all the entries in the virtual function tables 	 of interest contain the "latest" version of the functions 	 we have defined.  */
while|while
condition|(
name|vbases
condition|)
block|{
name|tree
name|virtuals
init|=
name|ASSOC_VIRTUALS
argument_list|(
name|vbases
argument_list|)
decl_stmt|;
if|if
condition|(
name|virtuals
condition|)
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
while|while
condition|(
name|virtuals
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|pfn
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|virtuals
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|pfn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|get_first_matching_virtual
argument_list|(
name|t
argument_list|,
name|base_fndecl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|!=
name|base_fndecl
operator|&&
name|context
operator|!=
name|t
condition|)
block|{
name|tree
name|assoc
init|=
name|NULL_TREE
decl_stmt|,
name|these_virtuals
decl_stmt|;
name|int
name|i
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|base_fndecl
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|context
argument_list|)
condition|)
name|assoc
operator|=
name|virtual_member
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|base_fndecl
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assoc
operator|==
name|NULL_TREE
condition|)
name|assoc
operator|=
name|assoc_value
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|base_fndecl
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|assoc
operator|!=
name|NULL_TREE
condition|)
block|{
name|these_virtuals
operator|=
name|ASSOC_VIRTUALS
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|these_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|these_virtuals
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|these_virtuals
argument_list|)
argument_list|)
expr_stmt|;
name|modify_vtable_entries
argument_list|(
name|t
argument_list|,
name|decl
argument_list|,
name|base_fndecl
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
name|virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|virtuals
argument_list|)
expr_stmt|;
block|}
name|vbases
operator|=
name|TREE_CHAIN
argument_list|(
name|vbases
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 1 */
while|while
condition|(
name|pending_hard_virtuals
condition|)
block|{
comment|/* Need an entry in some other virtual function table.  */
name|tree
name|base_fndecls
init|=
name|DECL_VINDEX
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|base_fndecls
condition|)
block|{
name|modify_vtable_entries
argument_list|(
name|t
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|base_fndecls
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|pending_hard_virtuals
argument_list|)
argument_list|)
expr_stmt|;
name|base_fndecls
operator|=
name|TREE_CHAIN
argument_list|(
name|base_fndecls
argument_list|)
expr_stmt|;
block|}
name|pending_hard_virtuals
operator|=
name|TREE_CHAIN
argument_list|(
name|pending_hard_virtuals
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|CLASSTYPE_VBASE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
if|if
condition|(
name|pending_virtuals
condition|)
block|{
name|pending_virtuals
operator|=
name|nreverse
argument_list|(
name|pending_virtuals
argument_list|)
expr_stmt|;
comment|/* We must enter these virtuals into the table.  */
if|if
condition|(
name|first_vfn_base_index
operator|==
literal|0
condition|)
block|{
name|pending_virtuals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|the_null_vtable_entry
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
name|build_vtable
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we know enough to change the type of our virtual 	     function table, but we will wait until later this function.  */
if|if
condition|(
operator|!
name|CLASSTYPE_MARKED4
argument_list|(
name|t
argument_list|)
condition|)
name|build_vtable
argument_list|(
name|assoc_value
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|first_vfn_base_index
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If this type has basetypes with constructors, then those 	 constructors might clobber the virtual function table.  But 	 they don't if the derived class shares the exact vtable of the base 	 class.  */
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_vfn_base_index
condition|)
block|{
name|tree
name|basetype
init|=
name|get_base_type
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|assoc
decl_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|basetype
argument_list|)
condition|)
name|assoc
operator|=
name|virtual_member
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|assoc
operator|=
name|assoc_value
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* This class contributes nothing new to the virtual function 	 table.  However, it may have declared functions which 	 went into the virtual function table "inherited" from the 	 base class.  If so, we grab a copy of those updated functions, 	 and pretend they are ours.  */
ifdef|#
directive|ifdef
name|SOS
comment|/* Don't define this ahead of time if we have more 	 fields to add later.  */
if|if
condition|(
name|all_virtual
operator|==
literal|2
operator|&&
name|fn_fields
operator|!=
name|NULL_TREE
condition|)
empty_stmt|;
else|else
endif|#
directive|endif
block|{
comment|/* See if we should steal the virtual info from base class.  */
if|if
condition|(
name|CLASS_ASSOC_VTABLE
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|CLASS_ASSOC_VTABLE
argument_list|(
name|t
argument_list|)
operator|=
name|ASSOC_VTABLE
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|ASSOC_VIRTUALS
argument_list|(
name|assoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CLASS_ASSOC_VTABLE
argument_list|(
name|t
argument_list|)
operator|!=
name|ASSOC_VTABLE
argument_list|(
name|assoc
argument_list|)
condition|)
name|CLASSTYPE_NEEDS_VIRTUAL_REINIT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|has_virtual
operator|>
name|max_has_virtual
condition|)
name|max_has_virtual
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|max_has_virtual
operator|||
name|first_vfn_base_index
condition|)
block|{
ifdef|#
directive|ifdef
name|VTABLE_USES_MASK
if|if
condition|(
name|max_has_virtual
operator|>=
name|VINDEX_MAX
condition|)
block|{
name|error
argument_list|(
literal|"too many virtual functions for class `%s' (VINDEX_MAX< %d)"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|t
argument_list|)
argument_list|,
name|has_virtual
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TYPE_VIRTUAL_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|first_vfn_base_index
condition|)
block|{
if|if
condition|(
name|pending_virtuals
condition|)
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|pending_virtuals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_virtual
condition|)
block|{
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|pending_virtuals
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|>=
literal|0
condition|)
name|DECL_VIRTUAL_P
argument_list|(
name|CLASS_ASSOC_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SOS
if|if
condition|(
name|all_virtual
operator|==
literal|2
operator|&&
operator|(
name|max_has_virtual
operator|||
name|method_vec
operator|)
condition|)
block|{
comment|/* Now that we know the size of the virtual table, lay out 	 the absolute table following it.  */
name|int
name|i
decl_stmt|;
name|tree
name|tmp
decl_stmt|;
name|tree
name|pending_absolutes
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|has_absolute
init|=
name|has_virtual
decl_stmt|;
comment|/* Local variables for building a table filled with strings 	 containing the names of interesting things.  */
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|start
init|=
name|NULL_TREE
decl_stmt|,
name|next
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|outer
init|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|outer
operator|!=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
condition|)
block|{
name|tree
name|inner
decl_stmt|;
for|for
control|(
name|inner
operator|=
operator|*
name|outer
init|;
name|inner
condition|;
name|inner
operator|=
name|TREE_CHAIN
argument_list|(
name|inner
argument_list|)
control|)
block|{
name|tree
name|entry
decl_stmt|;
name|tree
name|fn
decl_stmt|;
comment|/* Don't bother with functions which appear 		 for visibility reasons.  */
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|inner
argument_list|)
operator|!=
name|t
condition|)
continue|continue;
comment|/* Must lay this function into its absolute table as well. 		 This forces an inline function to be written out.  */
name|fn
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|inner
argument_list|)
expr_stmt|;
name|TREE_LITERAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_DINDEX
argument_list|(
name|inner
argument_list|)
operator|=
name|build_int_2
argument_list|(
operator|++
name|has_absolute
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|pending_absolutes
operator|=
name|tree_cons
argument_list|(
name|DECL_DINDEX
argument_list|(
name|inner
argument_list|)
argument_list|,
name|entry
argument_list|,
name|pending_absolutes
argument_list|)
expr_stmt|;
block|}
name|outer
operator|++
expr_stmt|;
block|}
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|CLASS_ASSOC_VIRTUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|nreverse
argument_list|(
name|pending_absolutes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DYNAMIC
argument_list|(
name|t
argument_list|)
condition|)
block|{
for|for
control|(
name|outer
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
init|;
name|outer
operator|!=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
condition|;
name|outer
operator|++
control|)
block|{
name|tree
name|inner
decl_stmt|;
for|for
control|(
name|inner
operator|=
operator|*
name|outer
init|;
name|inner
condition|;
name|inner
operator|=
name|TREE_CHAIN
argument_list|(
name|inner
argument_list|)
control|)
block|{
name|tree
name|str
init|=
name|make_node
argument_list|(
name|STRING_CST
argument_list|)
decl_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|str
argument_list|)
operator|=
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_STRING_POINTER
argument_list|(
name|str
argument_list|)
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|inner
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_LITERAL
argument_list|(
name|str
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|str
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|str
argument_list|)
operator|=
name|build_cplus_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|str
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|next
operator|=
name|start
expr_stmt|;
block|}
block|}
block|}
comment|/* Lay out dynamic link table for SOS.  */
name|decl
operator|=
name|finish_table
argument_list|(
name|get_linktable_name
argument_list|(
name|t
argument_list|)
argument_list|,
name|string_type_node
argument_list|,
name|start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|has_virtual
operator|=
name|has_absolute
expr_stmt|;
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|has_virtual
operator|>
name|max_has_virtual
condition|)
name|max_has_virtual
operator|=
name|has_virtual
expr_stmt|;
if|if
condition|(
name|vfield
operator|==
literal|0
condition|)
block|{
comment|/* We build this decl with ptr_type_node, and 	     change the type when we know what it should be.  */
name|vfield
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_vfield_name
argument_list|(
name|t
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|DECL_VIRTUAL_P
argument_list|(
name|vfield
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|SET_DECL_FCONTEXT
argument_list|(
name|vfield
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|vfield
argument_list|)
operator|=
literal|0
expr_stmt|;
name|y
operator|=
name|tree_last
argument_list|(
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
condition|)
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
operator|=
name|vfield
expr_stmt|;
else|else
name|fields
operator|=
name|vfield
expr_stmt|;
name|vfields
operator|=
name|chainon
argument_list|(
name|vfields
argument_list|,
name|CLASSTYPE_AS_LIST
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Now lay out the virtual function table.  */
if|if
condition|(
name|has_virtual
condition|)
block|{
name|tree
name|atype
decl_stmt|,
name|itype
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|==
name|ptr_type_node
condition|)
block|{
comment|/* We must create a pointer to this table because 	     the one inherited from base class does not exist. 	     We will fill in the type when we know what it 	     should really be.  */
name|itype
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|has_virtual
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|atype
operator|=
name|build_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_virtual
operator|!=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|atype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We must extend (or create) the boundaries on this array, 		 because we picked up virtual functions from multiple 		 base classes.  */
name|itype
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|has_virtual
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|atype
operator|=
name|build_array_type
argument_list|(
name|vtable_entry_type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
name|vfield
operator|=
name|copy_node
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* In the case of single inheritance, we can 		 just move up the tree, since we share the 		 same vptr slot.  */
block|if (TREE_CHAIN (vfields) == NULL_TREE) 		vfields = CLASSTYPE_AS_LIST (t);
endif|#
directive|endif
block|}
block|}
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|CLASS_ASSOC_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|atype
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|CLASS_ASSOC_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|atype
expr_stmt|;
name|layout_decl
argument_list|(
name|CLASS_ASSOC_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|CLASS_ASSOC_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|MAX
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|double_type_node
argument_list|)
argument_list|,
name|DECL_ALIGN
argument_list|(
name|CLASS_ASSOC_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_vfn_base_index
condition|)
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|vfields
expr_stmt|;
comment|/* Set all appropriate CLASSTYPE_... flags for this type      and its variants.  */
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|needs_ctor
operator|||
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
operator||=
operator|(
operator|(
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|)
operator|||
operator|(
name|has_virtual
operator||
name|first_vfn_base_index
operator|)
operator|||
name|any_default_members
operator|)
expr_stmt|;
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
operator||=
name|needs_dtor
operator|||
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|finish_struct_bits
argument_list|(
name|t
argument_list|,
name|first_vfn_base_index
argument_list|,
name|max_has_virtual
argument_list|)
expr_stmt|;
comment|/* Promote each bit-field's type to int if it is narrower than that.      Also warn (or error) if static members are specified for a class      which takes a constructor.  */
for|for
control|(
name|x
operator|=
name|fields
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PACKED
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|x
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|vfields
init|=
name|CLASSTYPE_VFIELDS
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|vfields
condition|)
block|{
comment|/* Mark the fact that constructor for T 	     could affect anybody inheriting from T 	     who wants to initialize vtables for VFIELDS's type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|vfields
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|vfields
argument_list|)
operator|=
literal|1
expr_stmt|;
name|vfields
operator|=
name|TREE_CHAIN
argument_list|(
name|vfields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|any_default_members
operator|!=
literal|0
condition|)
name|build_class_init_list
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|t
argument_list|)
condition|)
name|build_class_init_list
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
block|{
if|if
condition|(
operator|!
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|t
argument_list|)
condition|)
name|embrace_waiting_friends
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Write out inline function definitions.  */
name|do_inline_function_hair
argument_list|(
name|t
argument_list|,
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_INLINE_FRIENDS
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|CLASSTYPE_VSIZE
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|TYPE_NONCOPIED_PARTS
argument_list|(
name|t
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|default_conversion
argument_list|(
name|CLASS_ASSOC_VTABLE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|vfield
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flag_this_is_variable
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|tree
name|vtbl_ptr
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|VPTR_NAME
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|vfield
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_REGDECL
argument_list|(
name|vtbl_ptr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_VTBL_PTR
argument_list|(
name|t
argument_list|)
operator|=
name|vtbl_ptr
expr_stmt|;
block|}
if|if
condition|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|!=
name|t
condition|)
block|{
name|tree
name|assoc
init|=
name|assoc_value
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|tree
name|offset
init|=
name|ASSOC_OFFSET
argument_list|(
name|assoc
argument_list|)
decl_stmt|;
name|vfield
operator|=
name|copy_node
argument_list|(
name|vfield
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|convert_units
argument_list|(
name|offset
argument_list|,
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_OFFSET
argument_list|(
name|vfield
argument_list|)
condition|)
name|offset
operator|=
name|genop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|offset
argument_list|,
name|build_int
argument_list|(
name|DECL_OFFSET
argument_list|(
name|vfield
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|vfield
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_OFFSET
argument_list|(
name|vfield
argument_list|)
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|CLASSTYPE_VFIELD
argument_list|(
name|t
argument_list|)
operator|=
name|vfield
expr_stmt|;
block|}
block|}
comment|/* Make the rtl for any new vtables we have created, and unmark      the base types we marked.  */
name|unmark_finished_struct
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Now out of this class's scope.  However, if this class defined      any new typedefs, then we must export those to the outer      binding level.  This is unpleasant.  */
name|x
operator|=
name|gettags
argument_list|()
expr_stmt|;
name|popclass
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Remove aggregate types from the list of tags,      since these appear at global scope.  */
block|while (x&& IS_AGGR_TYPE (TREE_VALUE (x)))     x = TREE_CHAIN (x);   CLASSTYPE_TAGS (t) = x;   y = x;   while (x)     {       if (IS_AGGR_TYPE (TREE_VALUE (x))) 	TREE_CHAIN (y) = TREE_CHAIN (x);       x = TREE_CHAIN (x);     }
endif|#
directive|endif
name|hack_incomplete_structures
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|resume_momentary
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_struct
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if the effective type of INSTANCE is static.    Used to determine whether the virtual function table is needed    or not.  */
end_comment

begin_function
name|int
name|resolves_to_fixed_type_p
parameter_list|(
name|instance
parameter_list|)
name|tree
name|instance
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
return|return
name|resolves_to_fixed_type_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
comment|/* Don't let pointers to members look like they hold a fixed type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
return|return
literal|0
return|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|NEW_EXPR
case|:
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Ordering function for overload resolution.  */
end_comment

begin_function
name|int
name|rank_for_overload
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|struct
name|candidate
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|y
operator|->
name|evil
operator|-
name|x
operator|->
name|evil
condition|)
return|return
name|y
operator|->
name|evil
operator|-
name|x
operator|->
name|evil
return|;
if|if
condition|(
operator|(
name|y
operator|->
name|harshness
index|[
literal|0
index|]
operator|&
literal|128
operator|)
operator|^
operator|(
name|x
operator|->
name|harshness
index|[
literal|0
index|]
operator|&
literal|128
operator|)
condition|)
return|return
name|y
operator|->
name|harshness
index|[
literal|0
index|]
operator|-
name|x
operator|->
name|harshness
index|[
literal|0
index|]
return|;
if|if
condition|(
name|y
operator|->
name|user
operator|-
name|x
operator|->
name|user
condition|)
return|return
name|y
operator|->
name|user
operator|-
name|x
operator|->
name|user
return|;
if|if
condition|(
name|y
operator|->
name|b_or_d
operator|-
name|x
operator|->
name|b_or_d
condition|)
return|return
name|y
operator|->
name|b_or_d
operator|-
name|x
operator|->
name|b_or_d
return|;
return|return
name|y
operator|->
name|easy
operator|-
name|x
operator|->
name|easy
return|;
block|}
end_block

begin_comment
comment|/* TYPE is the type we wish to convert to.  PARM is the parameter    we have to work with.  We use a somewhat arbitrary cost function    to measure this conversion.  */
end_comment

begin_function
specifier|static
name|int
name|convert_harshness
parameter_list|(
name|type
parameter_list|,
name|parmtype
parameter_list|,
name|parm
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|,
name|parmtype
decl_stmt|;
name|tree
name|parm
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|codel
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|coder
init|=
name|TREE_CODE
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_convert_harshness
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|coder
operator|==
name|ERROR_MARK
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|coder
operator|==
name|METHOD_TYPE
operator|||
name|coder
operator|==
name|FUNCTION_TYPE
operator|)
condition|)
block|{
name|tree
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|int
name|harshness
decl_stmt|,
name|new_harshness
decl_stmt|;
comment|/* Get to the METHOD_TYPE or FUNCTION_TYPE that this might be.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|!=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
name|harshness
operator|=
literal|0
expr_stmt|;
comment|/* We allow the default conversion between function type 	 and pointer-to-function type for free.  */
if|if
condition|(
name|type
operator|==
name|parmtype
condition|)
return|return
literal|0
return|;
comment|/* Compare return types.  */
name|harshness
operator||=
name|convert_harshness
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|harshness
operator|&
literal|1
condition|)
return|return
literal|1
return|;
name|p1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
while|while
condition|(
name|p1
operator|&&
name|p2
condition|)
block|{
name|new_harshness
operator|=
name|convert_harshness
argument_list|(
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_harshness
operator|&
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|new_harshness
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
name|harshness
operator|+=
name|new_harshness
expr_stmt|;
else|else
name|harshness
operator||=
name|new_harshness
expr_stmt|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
name|harshness
return|;
if|if
condition|(
name|p2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p1
condition|)
return|return
name|harshness
operator||
operator|(
name|TREE_PURPOSE
argument_list|(
name|p1
argument_list|)
operator|==
name|NULL_TREE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|int
name|harshness
decl_stmt|;
comment|/* Get to the OFFSET_TYPE that this might be.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|!=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
name|harshness
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parmtype
argument_list|)
condition|)
name|harshness
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|get_base_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|harshness
operator|=
operator|(
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
else|else
return|return
literal|1
return|;
comment|/* Now test the OFFSET_TYPE's target compatability.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coder
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
if|if
condition|(
name|codel
operator|==
name|FUNCTION_TYPE
operator|||
name|codel
operator|==
name|METHOD_TYPE
operator|||
operator|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|coder
operator|==
name|VOID_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|codel
operator|==
name|ENUMERAL_TYPE
operator|||
name|codel
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* Control equivalence of ints an enums.  */
if|if
condition|(
name|codel
operator|==
name|ENUMERAL_TYPE
operator|&&
name|flag_int_enum_equivalence
operator|==
literal|0
condition|)
block|{
comment|/* Enums can be converted to ints, but not vice-versa.  */
if|if
condition|(
name|coder
operator|!=
name|ENUMERAL_TYPE
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* else enums and ints (almost) freely interconvert.  */
if|if
condition|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|int
name|easy
init|=
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|^
name|TREE_UNSIGNED
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|codel
operator|!=
name|coder
condition|)
name|easy
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|parmtype
argument_list|)
condition|)
name|easy
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|easy
operator|<<
literal|4
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|coder
operator|==
name|REAL_TYPE
condition|)
return|return
operator|(
literal|4
operator|<<
literal|4
operator|)
return|;
block|}
if|if
condition|(
name|codel
operator|==
name|REAL_TYPE
condition|)
if|if
condition|(
name|coder
operator|==
name|REAL_TYPE
condition|)
comment|/* Shun converting between float and double if a choice exists.  */
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|parmtype
argument_list|)
condition|)
return|return
operator|(
literal|2
operator|<<
literal|4
operator|)
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
operator|(
literal|4
operator|<<
literal|4
operator|)
return|;
comment|/* convert arrays which have not previously been converted.  */
if|if
condition|(
name|codel
operator|==
name|ARRAY_TYPE
condition|)
name|codel
operator|=
name|POINTER_TYPE
expr_stmt|;
if|if
condition|(
name|coder
operator|==
name|ARRAY_TYPE
condition|)
name|coder
operator|=
name|POINTER_TYPE
expr_stmt|;
comment|/* Conversions among pointers */
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|POINTER_TYPE
condition|)
block|{
specifier|register
name|tree
name|ttl
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parmtype
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|penalty
init|=
literal|4
operator|*
operator|(
name|ttl
operator|!=
name|ttr
operator|)
decl_stmt|;
comment|/* Anything converts to void *.  void * converts to anything. 	 Since these may be `const void *' (etc.) use VOID_TYPE 	 instead of void_type_node. 	 Otherwise, the targets must be the same, 	 except that we do allow (at some cost) conversion 	 between signed and unsinged pointer types.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
name|penalty
operator|<<
literal|4
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|VOID_TYPE
operator|||
operator|(
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
operator|^
name|TREE_UNSIGNED
argument_list|(
name|ttr
argument_list|)
operator|&&
operator|(
name|ttl
operator|=
name|unsigned_type
argument_list|(
name|ttl
argument_list|)
operator|,
name|ttr
operator|=
name|unsigned_type
argument_list|(
name|ttr
argument_list|)
operator|,
name|penalty
operator|=
literal|10
operator|,
literal|0
operator|)
operator|)
operator|||
operator|(
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ttr
operator|==
name|ttl
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttl
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
name|int
name|b_or_d
init|=
name|get_base_distance
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|b_or_d
operator|<<
literal|3
operator|)
operator||
literal|4
return|;
block|}
return|return
operator|(
name|penalty
operator|<<
literal|4
operator|)
return|;
block|}
if|if
condition|(
name|codel
operator|==
name|POINTER_TYPE
operator|&&
name|coder
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* This is not a bad match, but don't let it beat 	 integer-enum combinations.  */
if|if
condition|(
name|parm
operator|&&
name|integer_zerop
argument_list|(
name|parm
argument_list|)
condition|)
return|return
operator|(
literal|4
operator|<<
literal|4
operator|)
return|;
block|}
comment|/* C++: one of the types must be a reference type.  */
block|{
name|tree
name|ttl
decl_stmt|,
name|ttr
decl_stmt|;
specifier|register
name|tree
name|intype
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|parmtype
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
decl_stmt|;
name|int
name|penalty
decl_stmt|;
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
operator|||
name|coder
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|ttl
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|codel
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|ttl
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|form
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttl
operator|==
name|intype
condition|)
return|return
literal|0
return|;
name|penalty
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Can reference be built up?  */
if|if
condition|(
name|ttl
operator|==
name|intype
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
name|penalty
operator|=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|form
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|parm
condition|)
block|{
name|tree
name|tmp
init|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|intype
operator|=
name|parmtype
expr_stmt|;
do|do
block|{
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
do|;
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttl
operator|==
name|intype
condition|)
return|return
literal|0
return|;
else|else
name|penalty
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|ttl
argument_list|)
operator|^
name|TREE_UNSIGNED
argument_list|(
name|intype
argument_list|)
condition|)
block|{
name|ttl
operator|=
name|unsigned_type
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|intype
operator|=
name|unsigned_type
argument_list|(
name|intype
argument_list|)
expr_stmt|;
name|penalty
operator|+=
literal|2
expr_stmt|;
block|}
name|ttr
operator|=
name|intype
expr_stmt|;
comment|/* If the initializer is not an lvalue, then it does not 	   matter if we make life easier for the programmer 	   by creating a temporary variable with which to 	   hold the result.  */
if|if
condition|(
name|parm
operator|&&
operator|(
name|coder
operator|==
name|INTEGER_TYPE
operator|||
name|coder
operator|==
name|ENUMERAL_TYPE
operator|||
name|coder
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|!
name|lvalue_p
argument_list|(
name|parm
argument_list|)
condition|)
return|return
operator|(
name|convert_harshness
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|)
operator||
operator|(
name|penalty
operator|<<
literal|4
operator|)
operator|)
return|;
if|if
condition|(
name|ttl
operator|==
name|ttr
condition|)
return|return
literal|4
return|;
comment|/* Pointers to voids always convert for pointers.  But 	   make them less natural than more specific matches.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ttl
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|ttr
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|ttl
argument_list|)
operator|==
name|void_type_node
operator|||
name|TREE_TYPE
argument_list|(
name|ttr
argument_list|)
operator|==
name|void_type_node
condition|)
return|return
operator|(
operator|(
name|penalty
operator|+
literal|1
operator|)
operator|<<
literal|4
operator|)
return|;
if|if
condition|(
name|parm
operator|&&
name|codel
operator|!=
name|REFERENCE_TYPE
condition|)
return|return
operator|(
name|convert_harshness
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|)
operator||
operator|(
name|penalty
operator|<<
literal|4
operator|)
operator|)
return|;
comment|/* Here it does matter.  If this conversion is from 	   derived to base, allow it.  Otherwise, types must 	   be compatible in the strong sense.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|ttl
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ttr
argument_list|)
condition|)
block|{
name|int
name|b_or_d
init|=
name|get_base_distance
argument_list|(
name|ttl
argument_list|,
name|ttr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|#
directive|if
name|AMBIGUOUS_WORKING
if|if
condition|(
name|ttl
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_GETS_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|(
name|b_or_d
operator|<<
literal|3
operator|)
operator||
literal|6
return|;
endif|#
directive|endif
return|return
operator|(
name|b_or_d
operator|<<
literal|3
operator|)
operator||
literal|4
return|;
block|}
if|if
condition|(
name|comp_target_types
argument_list|(
name|ttl
argument_list|,
name|intype
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|penalty
operator|<<
literal|4
operator|)
return|;
block|}
block|}
if|if
condition|(
name|codel
operator|==
name|RECORD_TYPE
operator|&&
name|coder
operator|==
name|RECORD_TYPE
condition|)
block|{
name|int
name|b_or_d
init|=
name|get_base_distance
argument_list|(
name|type
argument_list|,
name|parmtype
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|b_or_d
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|#
directive|if
name|AMBIGUOUS_WORKING
if|if
condition|(
name|TYPE_GETS_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|(
name|b_or_d
operator|<<
literal|3
operator|)
operator||
literal|6
return|;
endif|#
directive|endif
return|return
operator|(
name|b_or_d
operator|<<
literal|3
operator|)
operator||
literal|4
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Algorithm: Start out with no stikes against.  For each argument    which requires a (subjective) hard conversion (such as between    floating point and integer), issue a strike.  If there are the same    number of formal and actual parameters in the list, there will be at    least on strike, otherwise an exact match would have been found.  If    there are not the same number of arguments in the type lists, we are    not dead yet: a `...' means that we can have more parms then were    declared, and if we wind up in the default argument section of the    list those can be used as well.  If an exact match could be found for    one of those cases, return it immediately.  Otherwise, Rank the fields    so that fields with fewer strikes are tried first.     Conversions between builtin and user-defined types are allowed, but    no function involving such a conversion is prefered to one which    does not require such a conversion.  Furthermore, such conversions    must be unique.  */
end_comment

begin_function
name|void
name|compute_conversion_costs
parameter_list|(
name|function
parameter_list|,
name|tta_in
parameter_list|,
name|cp
parameter_list|,
name|arglen
parameter_list|)
name|tree
name|function
decl_stmt|;
name|tree
name|tta_in
decl_stmt|;
name|struct
name|candidate
modifier|*
name|cp
decl_stmt|;
name|int
name|arglen
decl_stmt|;
block|{
name|tree
name|ttf_in
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ttf
init|=
name|ttf_in
decl_stmt|;
name|tree
name|tta
init|=
name|tta_in
decl_stmt|;
comment|/* Start out with no strikes against.  */
name|int
name|evil_strikes
init|=
literal|0
decl_stmt|;
name|int
name|user_strikes
init|=
literal|0
decl_stmt|;
name|int
name|b_or_d_strikes
init|=
literal|0
decl_stmt|;
name|int
name|easy_strikes
init|=
literal|0
decl_stmt|;
name|int
name|strike_index
init|=
literal|0
decl_stmt|,
name|win
decl_stmt|,
name|lose
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_compute_conversion_costs
operator|++
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|function
operator|=
name|function
expr_stmt|;
name|cp
operator|->
name|arg
operator|=
name|tta
condition|?
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
else|:
name|NULL_TREE
expr_stmt|;
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
literal|0
expr_stmt|;
comment|/* optimistic!  */
name|bzero
argument_list|(
name|cp
operator|->
name|harshness
argument_list|,
operator|(
name|arglen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ttf
operator|&&
name|tta
condition|)
block|{
name|int
name|harshness
decl_stmt|;
if|if
condition|(
name|ttf
operator|==
name|void_list_node
condition|)
break|break;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Must perform some instantiation here.  */
name|tree
name|rhs
init|=
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
decl_stmt|;
comment|/* @@ This is to undo what `grokdeclarator' does to 	     parameter types.  It really should go through 	     something more general.  */
name|TREE_TYPE
argument_list|(
name|tta
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|OP_IDENTIFIER
condition|)
name|rhs
operator|=
name|build_instantiated_decl
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Keep quiet about possible contravariance violations.  */
specifier|extern
name|int
name|inhibit_warnings
decl_stmt|;
name|int
name|old_inhibit_warnings
init|=
name|inhibit_warnings
decl_stmt|;
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
name|rhs
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inhibit_warnings
operator|=
name|old_inhibit_warnings
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ERROR_MARK
condition|)
name|harshness
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|harshness
operator|=
name|convert_harshness
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* harshness |= 2; */
block|}
block|}
else|else
name|harshness
operator|=
name|convert_harshness
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|harshness
index|[
name|strike_index
index|]
operator|=
name|harshness
expr_stmt|;
if|if
condition|(
name|harshness
operator|&
literal|1
condition|)
block|{
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
name|strike_index
expr_stmt|;
name|evil_strikes
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|harshness
operator|&
literal|2
condition|)
block|{
name|user_strikes
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|harshness
operator|&
literal|4
condition|)
block|{
name|b_or_d_strikes
operator|+=
operator|(
name|harshness
operator|>>
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|easy_strikes
operator|+=
name|harshness
operator|>>
literal|4
expr_stmt|;
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
expr_stmt|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
name|strike_index
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tta
condition|)
block|{
comment|/* ran out of formals, and parmlist is fixed size.  */
if|if
condition|(
name|ttf
comment|/* == void_type_node */
condition|)
block|{
name|cp
operator|->
name|evil
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ttf
operator|&&
name|ttf
operator|!=
name|void_list_node
condition|)
block|{
comment|/* ran out of actuals, and no defaults.  */
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|ttf
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|cp
operator|->
name|evil
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
operator|-
literal|2
expr_stmt|;
return|return;
block|}
comment|/* Store index of first default.  */
name|cp
operator|->
name|harshness
index|[
name|arglen
index|]
operator|=
name|strike_index
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|harshness
index|[
name|arglen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Argument list lengths work out, so don't need to check them again.  */
if|if
condition|(
name|evil_strikes
condition|)
block|{
comment|/* We do not check for derived->base conversions here, since in 	 no case would they give evil strike counts, unless such conversions 	 are somehow ambiguous.  */
comment|/* See if any user-defined conversions apply.          But make sure that we do not loop.  */
specifier|static
name|int
name|dont_convert_types
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dont_convert_types
condition|)
block|{
name|cp
operator|->
name|evil
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|win
operator|=
literal|0
expr_stmt|;
comment|/* Only get one chance to win.  */
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|tta
operator|=
name|tta_in
expr_stmt|;
name|strike_index
operator|=
literal|0
expr_stmt|;
name|evil_strikes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ttf
operator|&&
name|tta
condition|)
block|{
if|if
condition|(
name|ttf
operator|==
name|void_list_node
condition|)
break|break;
name|lose
operator|=
name|cp
operator|->
name|harshness
index|[
name|strike_index
index|]
expr_stmt|;
if|if
condition|(
name|lose
operator|&
literal|1
condition|)
block|{
name|tree
name|actual_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|formal_type
init|=
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
decl_stmt|;
name|dont_convert_types
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|formal_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|formal_type
operator|=
name|TREE_TYPE
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|actual_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|actual_type
operator|=
name|TREE_TYPE
argument_list|(
name|actual_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|!=
name|error_mark_node
operator|&&
name|actual_type
operator|!=
name|error_mark_node
condition|)
block|{
name|formal_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
name|actual_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|actual_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|formal_type
argument_list|)
condition|)
block|{
comment|/* If it has a constructor for this type, try to use it.  */
if|if
condition|(
name|convert_to_aggr
argument_list|(
name|formal_type
argument_list|,
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* @@ There is no way to save this result yet. 			     @@ So success is NULL_TREE for now.  */
name|win
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|actual_type
argument_list|)
operator|&&
name|TYPE_HAS_CONVERSION
argument_list|(
name|actual_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|formal_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|actual_type
argument_list|)
condition|)
name|win
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|formal_type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|actual_type
argument_list|)
condition|)
name|win
operator|++
expr_stmt|;
else|else
block|{
name|tree
name|conv
init|=
name|build_type_conversion
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|conv
condition|)
block|{
if|if
condition|(
name|conv
operator|==
name|error_mark_node
condition|)
name|win
operator|+=
literal|2
expr_stmt|;
else|else
name|win
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|conv
operator|=
name|build_type_conversion
argument_list|(
name|CALL_EXPR
argument_list|,
name|formal_type
argument_list|,
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|conv
condition|)
block|{
if|if
condition|(
name|conv
operator|==
name|error_mark_node
condition|)
name|win
operator|+=
literal|2
expr_stmt|;
else|else
name|win
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|dont_convert_types
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|win
operator|==
literal|1
condition|)
block|{
name|user_strikes
operator|+=
literal|1
expr_stmt|;
name|cp
operator|->
name|harshness
index|[
name|strike_index
index|]
operator|=
literal|2
expr_stmt|;
name|win
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|>
name|strike_index
condition|)
name|cp
operator|->
name|u
operator|.
name|bad_arg
operator|=
name|strike_index
expr_stmt|;
name|evil_strikes
operator|=
name|win
condition|?
literal|2
else|:
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
expr_stmt|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
name|strike_index
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Calling a non-const member function from a const member function      is probably invalid, but for now we let it only draw a warning.      We indicate that such a mismatch has occured by setting the      harshness to a maximum value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta_in
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta_in
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|>
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf_in
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|cp
operator|->
name|harshness
index|[
literal|0
index|]
operator||=
literal|128
expr_stmt|;
name|cp
operator|->
name|evil
operator|=
name|evil_strikes
expr_stmt|;
name|cp
operator|->
name|user
operator|=
name|user_strikes
expr_stmt|;
name|cp
operator|->
name|b_or_d
operator|=
name|b_or_d_strikes
expr_stmt|;
name|cp
operator|->
name|easy
operator|=
name|easy_strikes
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|candidate
modifier|*
name|ideal_candidate
parameter_list|(
name|basetype
parameter_list|,
name|candidates
parameter_list|,
name|n_candidates
parameter_list|,
name|parms
parameter_list|,
name|len
parameter_list|)
name|tree
name|basetype
decl_stmt|;
name|struct
name|candidate
modifier|*
name|candidates
decl_stmt|;
name|int
name|n_candidates
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|candidate
modifier|*
name|cp
init|=
name|candidates
operator|+
name|n_candidates
decl_stmt|;
name|int
name|index
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|ttf
decl_stmt|;
name|qsort
argument_list|(
name|candidates
argument_list|,
comment|/* char *base */
name|n_candidates
argument_list|,
comment|/* int nel */
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|,
comment|/* int width */
name|rank_for_overload
argument_list|)
expr_stmt|;
comment|/* int (*compar)() */
comment|/* If the best candidate requires user-defined conversions,      and its user-defined conversions are a strict subset      of all other candidates requiring user-defined conversions,      then it is, in fact, the best.  */
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|cp
operator|+
name|i
operator|!=
name|candidates
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|.
name|user
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
operator|-
literal|1
condition|)
block|{
name|tree
name|ttf0
decl_stmt|;
comment|/* Check that every other candidate requires those conversions 	 as a strict subset of their conversions.  */
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|.
name|user
operator|==
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|user
condition|)
goto|goto
name|non_subset
goto|;
comment|/* Look at subset relationship more closely.  */
while|while
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
name|i
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|,
name|ttf0
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|,
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|len
condition|;
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
operator|,
name|ttf0
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf0
argument_list|)
operator|,
name|index
operator|++
control|)
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|.
name|harshness
index|[
name|index
index|]
operator|&
literal|2
condition|)
block|{
comment|/* If our "best" candidate also needs a conversion, 		   it must be the same one.  */
if|if
condition|(
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|index
index|]
operator|&
literal|2
operator|)
operator|&&
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|ttf0
argument_list|)
condition|)
goto|goto
name|non_subset
goto|;
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* The best was the best.  */
return|return
name|cp
operator|-
literal|1
return|;
name|non_subset
label|:
comment|/* Use other rules for determining "bestness".  */
empty_stmt|;
block|}
comment|/* If the best two candidates we find require user-defined      conversions, we may need to report and error message.  */
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|user
operator|&&
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|user
operator|&&
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|b_or_d
operator|||
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|b_or_d
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* If the best two methods found involved user-defined 	 type conversions, then we must see whether one 	 of them is exactly what we wanted.  If not, then 	 we have an ambiguity.  */
name|int
name|best
init|=
literal|0
decl_stmt|;
name|tree
name|tta
init|=
name|parms
decl_stmt|;
name|tree
name|f1
decl_stmt|,
name|p1
decl_stmt|;
if|#
directive|if
name|AMBIGUOUS_WORKING
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|b_or_d
operator|==
literal|0
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|easy
operator|==
literal|0
operator|&&
operator|(
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|b_or_d
operator||
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|easy
operator|)
operator|>
literal|0
condition|)
return|return
name|cp
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* Stash all of our parameters in safe places 	 so that we can perform type conversions in place.  */
while|while
condition|(
name|tta
condition|)
block|{
name|TREE_PURPOSE
argument_list|(
name|tta
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
expr_stmt|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|int
name|exact_conversions
init|=
literal|0
decl_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
name|tta
operator|=
name|parms
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cp
index|[
name|i
index|]
operator|.
name|function
argument_list|)
condition|)
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
expr_stmt|;
for|for
control|(
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
name|i
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|,
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|len
condition|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
operator|,
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
operator|,
name|index
operator|++
control|)
block|{
if|if
condition|(
name|cp
index|[
name|i
index|]
operator|.
name|harshness
index|[
name|index
index|]
operator|&
literal|2
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
operator|=
name|build_type_conversion
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|tta
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
operator|!=
name|CONVERT_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
operator|!=
name|NOP_EXPR
operator|||
name|comp_target_types
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|exact_conversions
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* To get here we had to have succeeded via 			 a constructor.  */
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|tta
argument_list|)
expr_stmt|;
name|exact_conversions
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|exact_conversions
operator|==
name|cp
index|[
name|i
index|]
operator|.
name|user
condition|)
block|{
if|if
condition|(
name|best
operator|==
literal|0
condition|)
block|{
name|best
operator|=
name|i
expr_stmt|;
name|f1
operator|=
name|cp
index|[
name|best
index|]
operator|.
name|function
expr_stmt|;
name|p1
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't complain if next best is from base class.  */
name|tree
name|f2
init|=
name|cp
index|[
name|i
index|]
operator|.
name|function
decl_stmt|;
name|tree
name|p2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|f1
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|f2
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
operator|(
name|cp
index|[
name|i
index|]
operator|.
name|harshness
index|[
literal|0
index|]
operator|&
literal|4
operator|)
operator|!=
literal|0
operator|&&
name|cp
index|[
name|best
index|]
operator|.
name|harshness
index|[
literal|0
index|]
operator|<
name|cp
index|[
name|i
index|]
operator|.
name|harshness
index|[
literal|0
index|]
condition|)
block|{
if|#
directive|if
literal|0
comment|/* For LUCID.  */
block|if (! compparms (TREE_CHAIN (p1), TREE_CHAIN (p2), 1)) 			goto ret0; 		      else
endif|#
directive|endif
continue|continue;
block|}
else|else
goto|goto
name|ret0
goto|;
block|}
block|}
block|}
do|while
condition|(
name|cp
operator|+
name|i
operator|!=
name|candidates
condition|)
do|;
if|if
condition|(
name|best
condition|)
block|{
name|int
name|exact_conversions
init|=
name|cp
index|[
name|best
index|]
operator|.
name|user
decl_stmt|;
name|tta
operator|=
name|parms
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cp
index|[
name|best
index|]
operator|.
name|function
argument_list|)
condition|)
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
for|for
control|(
name|ttf
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
name|best
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|,
name|index
operator|=
literal|0
init|;
name|exact_conversions
operator|>
literal|0
condition|;
name|tta
operator|=
name|TREE_CHAIN
argument_list|(
name|tta
argument_list|)
operator|,
name|ttf
operator|=
name|TREE_CHAIN
argument_list|(
name|ttf
argument_list|)
operator|,
name|index
operator|++
control|)
block|{
if|if
condition|(
name|cp
index|[
name|best
index|]
operator|.
name|harshness
index|[
name|index
index|]
operator|&
literal|2
condition|)
block|{
comment|/* We must now fill in the slot we left behind. 		     @@ This could be optimized to use the value previously 		     @@ computed by build_type_conversion in some cases.  */
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
operator|=
name|convert
argument_list|(
name|TREE_VALUE
argument_list|(
name|ttf
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|tta
argument_list|)
argument_list|)
expr_stmt|;
name|exact_conversions
operator|-=
literal|1
expr_stmt|;
block|}
else|else
name|TREE_VALUE
argument_list|(
name|tta
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|tta
argument_list|)
expr_stmt|;
block|}
return|return
name|cp
operator|+
name|best
return|;
block|}
goto|goto
name|ret0
goto|;
block|}
comment|/* If the best two candidates we find both use default parameters,      we may need to report and error.  Don't need to worry if next-best      candidate is forced to use user-defined conversion when best is not.  */
if|if
condition|(
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|user
operator|==
literal|0
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|len
index|]
operator|!=
literal|0
operator|&&
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|len
index|]
operator|!=
literal|0
condition|)
block|{
name|tree
name|tt1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tt2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|harshness
index|[
name|len
index|]
decl_stmt|;
if|if
condition|(
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|len
index|]
operator|<
name|i
condition|)
name|i
operator|=
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|harshness
index|[
name|len
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|tt1
argument_list|)
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|tt2
argument_list|)
argument_list|)
condition|)
comment|/* These lists are not identical, so we can choose our best candidate.  */
return|return
name|cp
operator|-
literal|1
return|;
name|tt1
operator|=
name|TREE_CHAIN
argument_list|(
name|tt1
argument_list|)
expr_stmt|;
name|tt2
operator|=
name|TREE_CHAIN
argument_list|(
name|tt2
argument_list|)
expr_stmt|;
block|}
comment|/* To get here, both lists had the same parameters up to the defaults 	 which were used.  This is an ambiguous request.  */
goto|goto
name|ret0
goto|;
block|}
comment|/* Otherwise, return our best candidate.  Note that if we get candidates      from independent base classes, we have an ambiguity, even if one      argument list look a little better than another one.  */
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|b_or_d
operator|&&
name|basetype
operator|&&
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|n_candidates
operator|-
literal|1
decl_stmt|,
name|best
decl_stmt|;
name|tree
name|base1
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|candidates
index|[
name|i
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|cp
operator|-
literal|1
return|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
operator|&&
name|candidates
index|[
name|i
index|]
operator|.
name|user
operator|==
literal|0
operator|&&
name|candidates
index|[
name|i
index|]
operator|.
name|evil
operator|==
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|candidates
index|[
name|i
index|]
operator|.
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|newbase
init|=
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|candidates
index|[
name|i
index|]
operator|.
name|function
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base1
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|newbase
operator|!=
name|base1
operator|&&
operator|!
name|get_base_type
argument_list|(
name|newbase
argument_list|,
name|base1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|8192
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"ambiguous request for function from distinct base classes of type `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"first candidate is `%s'"
argument_list|,
name|fndecl_as_string
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|candidates
index|[
name|best
index|]
operator|.
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"second candidates is `%s'"
argument_list|,
name|fndecl_as_string
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|candidates
index|[
name|i
index|]
operator|.
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cp
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|best
operator|=
name|i
expr_stmt|;
name|base1
operator|=
name|newbase
expr_stmt|;
block|}
block|}
else|else
return|return
name|cp
operator|-
literal|1
return|;
block|}
block|}
if|#
directive|if
name|AMBIGUOUS_WORKING
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|user
operator|==
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|user
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|b_or_d
operator|==
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|b_or_d
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|easy
operator|==
name|cp
index|[
operator|-
literal|2
index|]
operator|.
name|easy
condition|)
goto|goto
name|ret0
goto|;
endif|#
directive|endif
return|return
name|cp
operator|-
literal|1
return|;
name|ret0
label|:
comment|/* In the case where there is no ideal candidate, restore      TREE_VALUE slots of PARMS from TREE_PURPOSE slots.  */
while|while
condition|(
name|parms
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Assume that if the class referred to is not in the    current class hierarchy, that it may be remote.    PARENT is assumed to be of aggregate type here.  */
end_comment

begin_function
specifier|static
name|int
name|may_be_remote
parameter_list|(
name|parent
parameter_list|)
name|tree
name|parent
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|parent
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_class_type
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|parent
operator|==
name|current_class_type
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_base_type
argument_list|(
name|parent
argument_list|,
name|current_class_type
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes that the arglist in PARMS would    occupy on the stack.  */
end_comment

begin_function
name|int
name|get_arglist_len_in_bytes
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
specifier|register
name|tree
name|parm
decl_stmt|;
specifier|register
name|int
name|bytecount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
specifier|register
name|tree
name|pval
init|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
decl_stmt|;
specifier|register
name|int
name|used
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pval
argument_list|)
operator|==
name|ERROR_MARK
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
name|used
operator|=
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|used
operator|=
operator|(
operator|(
operator|(
name|size
operator|+
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|tree
name|size
init|=
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|pval
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|used_t
init|=
name|convert_units
argument_list|(
name|convert_units
argument_list|(
name|size
argument_list|,
name|BITS_PER_UNIT
argument_list|,
name|PARM_BOUNDARY
argument_list|)
argument_list|,
name|PARM_BOUNDARY
argument_list|,
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
name|used
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|used_t
argument_list|)
expr_stmt|;
block|}
name|bytecount
operator|+=
name|used
expr_stmt|;
block|}
return|return
name|bytecount
return|;
block|}
end_function

begin_function
name|tree
name|build_vfield_ref
parameter_list|(
name|datum
parameter_list|,
name|type
parameter_list|)
name|tree
name|datum
decl_stmt|,
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|datum
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|datum
operator|=
name|convert_from_reference
argument_list|(
name|datum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|datum
argument_list|,
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
return|return
name|build_component_ref
argument_list|(
name|datum
argument_list|,
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a call to a member of an object.  I.e., one that overloads    operator ()(), or is a pointer-to-function or pointer-to-method.  */
end_comment

begin_function
specifier|static
name|tree
name|build_field_call
parameter_list|(
name|basetype_path
parameter_list|,
name|instance_ptr
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|,
name|err_name
parameter_list|)
name|tree
name|basetype_path
decl_stmt|;
name|tree
name|instance_ptr
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|;
name|char
modifier|*
name|err_name
decl_stmt|;
block|{
name|tree
name|field
decl_stmt|,
name|instance
decl_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|current_class_decl
condition|)
block|{
comment|/* Check to see if we really have a reference to an instance variable 	 with `operator()()' overloaded.  */
if|#
directive|if
literal|1
name|field
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|field
operator|=
name|identifier_class_value
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|field
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"`this' has no member named `%s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* If it's a field, try overloading operator (), 	     or calling if the field is a pointer-to-function.  */
name|instance
operator|=
name|build_component_ref_1
argument_list|(
name|C_C_D
argument_list|,
name|field
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|instance
argument_list|,
name|parms
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
return|return
name|build_function_call
argument_list|(
name|instance
argument_list|,
name|parms
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
return|return
name|build_function_call
argument_list|(
name|instance
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|current_class_decl
argument_list|,
name|parms
argument_list|)
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* Check to see if this is not really a reference to an instance variable      with `operator()()' overloaded.  */
name|field
operator|=
name|lookup_field
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This can happen if the reference was ambiguous      or for visibility violations.  */
if|if
condition|(
name|field
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|field
condition|)
block|{
name|tree
name|basetype
decl_stmt|;
name|tree
name|ftype
init|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_LANG_SPECIFIC
argument_list|(
name|ftype
argument_list|)
operator|&&
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|ftype
argument_list|)
condition|)
block|{
comment|/* Make the next search for this field very short.  */
name|basetype
operator|=
name|DECL_FIELD_CONTEXT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build_opfncall
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|build_component_ref_1
argument_list|(
name|instance
argument_list|,
name|field
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|parms
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* This is a member which is a pointer to function.  */
name|tree
name|ref
init|=
name|build_component_ref_1
argument_list|(
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|field
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_function_call
argument_list|(
name|ref
argument_list|,
name|parms
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid call via pointer-to-member function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Build a method call of the form `EXP->SCOPES::NAME (PARMS)'.    This is how virtual function calls are avoided.  */
end_comment

begin_function
name|tree
name|build_scoped_method_call
parameter_list|(
name|exp
parameter_list|,
name|scopes
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|tree
name|scopes
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|parms
decl_stmt|;
block|{
comment|/* Because this syntactic form does not allow      a pointer to a base class to be `stolen',      we need not protect the drived->base conversion      that happens here.            @@ But we do have to check visibility privileges later.  */
name|tree
name|basename
init|=
operator|(
name|TREE_CODE
argument_list|(
name|scopes
argument_list|)
operator|==
name|SCOPE_REF
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|scopes
argument_list|,
literal|1
argument_list|)
else|:
name|scopes
decl_stmt|;
name|tree
name|basetype
decl_stmt|,
name|decl
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|is_aggr_typedef
argument_list|(
name|basename
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"base object of scoped method call is not of aggregate type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|basename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|=
name|basetype_or_else
argument_list|(
name|basetype
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|basetype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|decl
operator|=
name|build_indirect_ref
argument_list|(
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
name|build_scoped_ref
argument_list|(
name|exp
argument_list|,
name|scopes
argument_list|)
expr_stmt|;
comment|/* Call to a destructor.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
comment|/* Explicit call to destructor.  */
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"qualified type `%s' does not match destructor type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"type `%s' has no destructor"
argument_list|)
expr_stmt|;
return|return
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Call to a method.  */
return|return
name|build_method_call
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Build something of the form ptr->method (args)    or object.method (args).  This can also build    calls to constructors, and find friends.     Member functions always take their class variable    as a pointer.     INSTANCE is a class instance.     NAME is the NAME field of the struct, union, or class    whose type is that of INSTANCE.     PARMS help to figure out what that NAME really refers to.     BASETYPE_PATH, if non-NULL, tells which basetypes of INSTANCE    we should be traversed before starting our search.  We need    this information to get protected accesses correct.     FLAGS is the logical disjunction of zero or more LOOKUP_    flags.  See cplus-tree.h for more info.     If this is all OK, calls build_function_call with the resolved    member function.     This function must also handle being called to perform    initialization, promotion/coercion of arguments, and    instantiation of default parameters.     Note that NAME may refer to an instance variable name.  If    `operator()()' is defined for the type of that field, then we return    that result.  */
end_comment

begin_function
name|tree
name|build_method_call
parameter_list|(
name|instance
parameter_list|,
name|name
parameter_list|,
name|parms
parameter_list|,
name|basetype_path
parameter_list|,
name|flags
parameter_list|)
name|tree
name|instance
decl_stmt|,
name|name
decl_stmt|,
name|parms
decl_stmt|,
name|basetype_path
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|function
decl_stmt|,
name|fntype
decl_stmt|,
name|value_type
decl_stmt|;
specifier|register
name|tree
name|basetype
decl_stmt|,
name|save_basetype
decl_stmt|;
specifier|register
name|tree
name|baselink
decl_stmt|,
name|result
decl_stmt|,
name|method_name
decl_stmt|,
name|parmtypes
decl_stmt|,
name|parm
decl_stmt|;
name|tree
name|last
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|enum
name|visibility_type
name|visibility
decl_stmt|;
name|int
name|rank_for_overload
parameter_list|()
function_decl|;
comment|/* Range of cases for vtable optimization.  */
enum|enum
name|vtable_needs
block|{
name|not_needed
block|,
name|maybe_needed
block|,
name|unneeded
block|,
name|needed
block|,     }
enum|;
name|enum
name|vtable_needs
name|need_vtbl
init|=
name|not_needed
decl_stmt|;
name|char
modifier|*
name|err_name
decl_stmt|;
name|char
modifier|*
name|name_kind
decl_stmt|;
name|int
name|ever_seen
init|=
literal|0
decl_stmt|;
name|int
name|wrap
decl_stmt|;
name|tree
name|wrap_type
decl_stmt|;
name|tree
name|instance_ptr
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|all_virtual
init|=
name|flag_all_virtual
decl_stmt|;
name|int
name|static_call_context
decl_stmt|;
name|tree
name|saw_private
init|=
literal|0
decl_stmt|;
name|tree
name|saw_protected
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SOS
comment|/* If call is a call to a constructor, then `dtbl'      will first be initialized with the function table pointer      of the appropriate type (calling "sosFindCode" as a last      resort), the the call to the constructor will go through there.  */
name|tree
name|dtbl
init|=
operator|(
name|flags
operator|&
name|LOOKUP_DYNAMIC
operator|)
condition|?
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
comment|/* Flag saying whether or not `dtbl' has been inserted into the      parameter list.  This is needed because we cannot tell (until      we have a match) whether this parameter should go in or not.       If 1, then `dtbl' is living naturally.      If 0, then `dtbl' is not among the parms that we know about.      If -1, the `dtbl' was place into the parms unnaturally.       Note that we may side-effect the parameter list, but in such a way      that the caller of this function would never know.  */
name|int
name|dtbl_inserted
init|=
operator|(
name|flags
operator|&
name|LOOKUP_DYNAMIC
operator|)
decl_stmt|;
endif|#
directive|endif
comment|/* Keep track of `const' and `volatile' objects.  */
name|int
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
comment|/* Know if this is explicit destructor call.  */
name|int
name|dtor_specd
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_build_method_call
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|instance
operator|==
name|error_mark_node
operator|||
name|name
operator|==
name|error_mark_node
operator|||
name|parms
operator|==
name|error_mark_node
operator|||
operator|(
name|instance
operator|!=
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
return|return
name|error_mark_node
return|;
if|#
directive|if
literal|0
comment|/* C++ 2.1 does not allow this, but ANSI probably will.  */
block|if (TREE_CODE (name) == BIT_NOT_EXPR)     {       error ("invalid call to destructor, use qualified name `%s::~%s'", 	     IDENTIFIER_POINTER (name), IDENTIFIER_POINTER (name));       return error_mark_node;     }
else|#
directive|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|flags
operator||=
name|LOOKUP_DESTRUCTOR
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|parms
condition|)
name|error
argument_list|(
literal|"destructors take no parameters"
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"type `%s' has no destructor"
argument_list|)
expr_stmt|;
name|instance
operator|=
name|default_conversion
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|instance_ptr
operator|=
name|instance
expr_stmt|;
else|else
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build_delete
argument_list|(
name|basetype
argument_list|,
name|instance_ptr
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|WRAPPER_EXPR
condition|)
block|{
name|wrap_type
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wrap
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|ANTI_WRAPPER_EXPR
condition|)
block|{
name|wrap_type
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wrap
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|wrap_type
operator|=
name|NULL_TREE
expr_stmt|;
name|wrap
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Initialize name for error reporting.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|OP_IDENTIFIER
condition|)
name|name
operator|=
name|build_operator_fnname
argument_list|(
operator|&
name|name
argument_list|,
name|parms
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPERATOR_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|operator_name_string
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|err_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|err_name
argument_list|,
literal|"operator %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|wrapper_name
condition|)
name|err_name
operator|=
literal|"wrapper"
expr_stmt|;
elseif|else
if|if
condition|(
name|OPERATOR_TYPENAME_P
argument_list|(
name|name
argument_list|)
condition|)
name|err_name
operator|=
literal|"type conversion operator"
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|err_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIELD_XREF
name|FIELD_xref_call
argument_list|(
name|current_function_decl
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wrap
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|err_name
argument_list|)
operator|+
literal|32
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s for `%s'"
argument_list|,
name|wrap
operator|<
literal|0
condition|?
literal|"anti-wrapper"
else|:
literal|"wrapper"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
name|err_name
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|instance
operator|==
name|NULL_TREE
condition|)
block|{
name|static_call_context
operator|=
literal|0
expr_stmt|;
name|basetype
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Check cases where this is really a call to raise 	 an exception.  */
if|if
condition|(
name|current_class_type
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|basetype
operator|=
name|purpose_member
argument_list|(
name|name
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
condition|)
name|basetype
operator|=
name|TREE_VALUE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|basetype
operator|=
name|purpose_member
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
condition|)
name|basetype
operator|=
name|TREE_VALUE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basetype
operator|!=
name|NULL_TREE
condition|)
empty_stmt|;
comment|/* call to a constructor... */
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|typedef_name
init|=
name|lookup_name
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|typedef_name
operator|&&
name|TREE_CODE
argument_list|(
name|typedef_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Cannonicalize the typedef name.  */
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|typedef_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"no constructor named `%s' in visible scope"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|wrap_type
operator|&&
name|wrap_type
operator|!=
name|basetype
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|wrap_type
argument_list|,
literal|"invalid constructor `%s::%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|wrap_type
operator|=
name|basetype
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|non_aggr_error
label|:
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|error
argument_list|(
literal|"request for member `%s' in something not a structure or union"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|instance
operator|==
name|C_C_D
operator|||
name|instance
operator|==
name|current_class_decl
condition|)
block|{
specifier|extern
name|tree
name|ctor_label
decl_stmt|,
name|dtor_label
decl_stmt|;
comment|/* When doing initialization, we side-effect the TREE_TYPE of 	 C_C_D, hence we cannot set up BASETYPE from CURRENT_CLASS_TYPE.  */
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|C_C_D
argument_list|)
expr_stmt|;
comment|/* Anything manifestly `this' in constructors and destructors 	 has a known type, so virtual function tables are not needed.  */
if|if
condition|(
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|wrap_type
operator|==
name|NULL_TREE
condition|)
name|need_vtbl
operator|=
operator|(
name|dtor_label
operator|||
name|ctor_label
operator|)
condition|?
name|unneeded
else|:
name|maybe_needed
expr_stmt|;
name|static_call_context
operator|=
literal|0
expr_stmt|;
name|instance
operator|=
name|C_C_D
expr_stmt|;
name|instance_ptr
operator|=
name|current_class_decl
expr_stmt|;
name|result
operator|=
name|build_field_call
argument_list|(
name|CLASSTYPE_AS_LIST
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
name|static_call_context
operator|=
literal|0
expr_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrap_type
condition|)
block|{
if|if
condition|(
name|basetype_or_else
argument_list|(
name|basetype
argument_list|,
name|wrap_type
argument_list|)
condition|)
name|basetype
operator|=
name|wrap_type
expr_stmt|;
else|else
return|return
name|error_mark_node
return|;
block|}
comment|/* Should we ever have to make a virtual function reference 	 from a RESULT_DECL, know that it must be of fixed type 	 within the scope of this function.  */
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
name|need_vtbl
operator|=
name|maybe_needed
expr_stmt|;
name|instance_ptr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instance
operator|==
name|current_exception_object
condition|)
block|{
name|instance_ptr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|current_exception_type
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|current_exception_object
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|current_exception_object
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_field_call
argument_list|(
name|CLASSTYPE_AS_LIST
argument_list|(
name|current_exception_type
argument_list|)
argument_list|,
name|instance_ptr
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
name|error
argument_list|(
literal|"exception member `%s' cannot be invoked"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
comment|/* The MAIN_VARIANT of the type that `instance_ptr' winds up being.  */
name|tree
name|inst_ptr_basetype
decl_stmt|;
comment|/* from the file "cplus-typeck.c".  */
specifier|extern
name|tree
name|unary_complex_lvalue
parameter_list|()
function_decl|;
name|static_call_context
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
operator|)
expr_stmt|;
comment|/* the base type of an instance variable is pointer to class */
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
goto|goto
name|non_aggr_error
goto|;
comment|/* Call to convert not needed because we are remaining 	     within the same type.  */
name|instance_ptr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|inst_ptr_basetype
operator|=
name|basetype
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|instance
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|basetype
argument_list|)
condition|)
goto|goto
name|non_aggr_error
goto|;
if|if
condition|(
operator|!
name|instance_ptr
condition|)
block|{
if|if
condition|(
operator|(
name|lvalue_p
argument_list|(
name|instance
argument_list|)
operator|&&
operator|(
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|instance_ptr
operator|=
name|unary_complex_lvalue
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
comment|/* A cast is not an lvalue.  Initialize a fresh temp 		     with the value we are casting from, and proceed with 		     that temporary.  We can't cast to a reference type, 		     so that simplifies the initialization to something 		     we can manage.  */
name|tree
name|temp
init|=
name|get_temp_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
condition|)
name|expand_aggr_init
argument_list|(
name|temp
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|store_init_value
argument_list|(
name|temp
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|instance
operator|=
name|temp
expr_stmt|;
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|instance
operator|=
name|build_cplus_new
argument_list|(
name|basetype
argument_list|,
name|instance
argument_list|)
expr_stmt|;
else|else
block|{
name|instance
operator|=
name|get_temp_name
argument_list|(
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|instance
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|instance_ptr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* @@ Should we call comp_target_types here?  */
name|inst_ptr_basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|inst_ptr_basetype
argument_list|)
condition|)
name|basetype
operator|=
name|inst_ptr_basetype
expr_stmt|;
else|else
name|instance_ptr
operator|=
name|convert
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|inst_ptr_basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
condition|)
name|basetype_path
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|inst_ptr_basetype
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_field_call
argument_list|(
name|basetype_path
argument_list|,
name|instance_ptr
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
if|if
condition|(
name|wrap_type
condition|)
block|{
if|if
condition|(
name|basetype_or_else
argument_list|(
name|basetype
argument_list|,
name|wrap_type
argument_list|)
condition|)
name|basetype
operator|=
name|wrap_type
expr_stmt|;
else|else
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|instance_ptr
argument_list|)
condition|)
block|{
comment|/* This action is needed because the instance is needed 		 for providing the base of the virtual function table. 		 Without using a SAVE_EXPR, the function we are building 		 may be called twice, or side effects on the instance 		 variable (such as a post-increment), may happen twice.  */
name|instance_ptr
operator|=
name|save_expr
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* This happens when called for operator new ().  */
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|need_vtbl
operator|=
name|maybe_needed
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is worth complaining about, I think.  */
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"cannot lookup method in incomplete type `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Are we building a non-virtual wrapper?  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
condition|)
block|{
if|if
condition|(
name|all_virtual
condition|)
name|sorry
argument_list|(
literal|"non-virtual call with -fall-virtual"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrap
condition|)
name|wrap_type
operator|=
name|basetype
expr_stmt|;
block|}
name|save_basetype
operator|=
name|basetype
expr_stmt|;
if|if
condition|(
name|all_virtual
operator|==
literal|1
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|OPERATOR_METHOD_FORMAT
argument_list|,
name|OPERATOR_METHOD_LENGTH
argument_list|)
operator|||
name|instance_ptr
operator|==
name|NULL_TREE
operator|||
operator|(
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_NEEDS_WRAPPER
argument_list|(
name|basetype
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|all_virtual
operator|=
literal|0
expr_stmt|;
name|last
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|parmtypes
operator|=
literal|0
operator|,
name|parm
operator|=
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* Convert OFFSET_TYPE entities to their normal selves.  */
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|=
name|resolve_offset_ref
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Perform the conversion from ARRAY_TYPE to POINTER_TYPE in place. 	     This eliminates needless calls to `compute_conversion_costs'.  */
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|=
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|last
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|chainon
argument_list|(
name|parmtypes
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|instance
condition|)
block|{
name|constp
operator|=
name|TREE_READONLY
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Raw constructors are always in charge.  */
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_HAS_IN_CHARGE
operator|)
condition|)
block|{
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_this_is_variable
condition|)
block|{
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|instance_ptr
operator|=
name|build_new
argument_list|(
name|NULL_TREE
argument_list|,
name|basetype
argument_list|,
name|void_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|instance_ptr
operator|=
name|save_expr
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
name|TREE_CALLS_NEW
argument_list|(
name|instance_ptr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|basetype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|)
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL_TREE
condition|)
name|last
operator|=
name|parmtypes
expr_stmt|;
comment|/* Look up function name in the structure type definition.  */
if|if
condition|(
name|wrap
condition|)
block|{
if|if
condition|(
name|wrap
operator|>
literal|0
condition|)
name|name_kind
operator|=
literal|"wrapper"
expr_stmt|;
else|else
name|name_kind
operator|=
literal|"anti-wrapper"
expr_stmt|;
name|baselink
operator|=
name|get_wrapper
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|tmp
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
condition|)
name|tmp
operator|=
name|basetype
expr_stmt|;
else|else
name|tmp
operator|=
name|get_base_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
block|{
name|name_kind
operator|=
literal|"constructor"
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_HAS_IN_CHARGE
operator|)
condition|)
block|{
comment|/* Constructors called for initialization 		     only are never in charge.  */
name|tree
name|tmplist
decl_stmt|;
name|flags
operator||=
name|LOOKUP_HAS_IN_CHARGE
expr_stmt|;
name|tmplist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|tmplist
expr_stmt|;
name|tmplist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|=
name|tmplist
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOS
if|if
condition|(
name|TYPE_DYNAMIC
argument_list|(
name|basetype
argument_list|)
operator|&&
name|dtbl_inserted
operator|==
literal|0
condition|)
block|{
name|tree
name|parm
decl_stmt|,
name|parmtype
decl_stmt|;
name|dtbl
operator|=
name|get_sos_dtable
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|parm
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|dtbl
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|parmtype
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|ptr_type_node
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|parm
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|=
name|parmtype
expr_stmt|;
name|dtbl_inserted
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* constructors are in very specific places.  */
ifdef|#
directive|ifdef
name|SOS
if|if
condition|(
name|dtbl_inserted
operator|==
operator|-
literal|1
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|dtbl_inserted
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|basetype
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|name_kind
operator|=
literal|"method"
expr_stmt|;
block|}
else|else
name|name_kind
operator|=
literal|"method"
expr_stmt|;
if|if
condition|(
name|basetype_path
operator|==
name|NULL_TREE
condition|)
name|basetype_path
operator|=
name|CLASSTYPE_AS_LIST
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|result
operator|=
name|lookup_fnfields
argument_list|(
name|basetype_path
argument_list|,
name|name
argument_list|,
operator|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* Now, go look for this method name. We do not find destructors here.       Putting `void_list_node' on the end of the parmtypes      fakes out `build_decl_overload' into doing the right thing.  */
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
name|method_name
operator|=
name|build_decl_overload
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|parmtypes
argument_list|,
literal|1
operator|+
operator|(
name|name
operator|==
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|save_basetype
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|struct
name|candidate
modifier|*
name|candidates
decl_stmt|;
name|struct
name|candidate
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|best
init|=
literal|2
decl_stmt|;
comment|/* This increments every time we go up the type hierarchy. 	 The idea is to prefer a function of the derived class if possible.  */
name|int
name|b_or_d
decl_stmt|;
name|baselink
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|pass
operator|>
literal|0
condition|)
block|{
name|candidates
operator|=
operator|(
expr|struct
name|candidate
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|ever_seen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|candidates
expr_stmt|;
name|len
operator|=
name|list_length
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|b_or_d
operator|=
literal|0
expr_stmt|;
comment|/* First see if a global function has a shot at it.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
block|{
name|tree
name|friend_parms
decl_stmt|;
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|friend_parms
operator|=
name|parms
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|parm
operator|=
name|build_indirect_ref
argument_list|(
name|parm
argument_list|,
literal|"friendifying parms (compiler error)"
argument_list|)
expr_stmt|;
name|parm
operator|=
name|convert
argument_list|(
name|build_reference_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|friend_parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parm
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|->
name|harshness
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_overload_call
argument_list|(
name|name
argument_list|,
name|friend_parms
argument_list|,
literal|0
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* If it turns out to be the one we were actually looking for 		 (it was probably a friend function), the return the 		 good result.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|CALL_EXPR
condition|)
return|return
name|result
return|;
while|while
condition|(
name|cp
operator|->
name|evil
operator|==
literal|0
condition|)
block|{
comment|/* non-standard uses: set the field to 0 to indicate 		     we are using a non-member function.  */
name|cp
operator|->
name|u
operator|.
name|field
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|harshness
index|[
name|len
index|]
operator|==
literal|0
operator|&&
name|cp
operator|->
name|harshness
index|[
name|len
index|]
operator|==
literal|0
operator|&&
name|cp
operator|->
name|user
operator|==
literal|0
operator|&&
name|cp
operator|->
name|b_or_d
operator|==
literal|0
operator|&&
name|cp
operator|->
name|easy
operator|<
name|best
condition|)
name|best
operator|=
name|cp
operator|->
name|easy
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|baselink
condition|)
block|{
comment|/* We have a hit (of sorts). If the parameter list is 	     "error_mark_node", or some variant thereof, it won't 	     match any methods. Since we have verified that the is 	     some method vaguely matching this one (in name at least), 	     silently return. 	      	     Don't stop for friends, however.  */
name|tree
name|basetypes
init|=
name|TREE_PURPOSE
argument_list|(
name|baselink
argument_list|)
decl_stmt|;
name|function
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TREE_VALUE
argument_list|(
name|basetypes
argument_list|)
expr_stmt|;
comment|/* Cast the instance variable to the approriate type.  */
name|TREE_VALUE
argument_list|(
name|parmtypes
argument_list|)
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|DESTRUCTOR_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
condition|)
name|function
operator|=
name|TREE_CHAIN
argument_list|(
name|function
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|function
condition|;
name|function
operator|=
name|TREE_CHAIN
argument_list|(
name|function
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_inner_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
name|ever_seen
operator|++
expr_stmt|;
comment|/* Not looking for friends here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pass
operator|==
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|function
argument_list|)
operator|==
name|method_name
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_PROTECT
condition|)
block|{
name|visibility
operator|=
name|compute_visibility
argument_list|(
name|basetypes
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
operator|&&
name|flags
operator|&
name|LOOKUP_PROTECTED_OK
condition|)
name|visibility
operator|=
name|visibility_public
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PROTECT
operator|)
operator|==
literal|0
operator|||
name|visibility
operator|==
name|visibility_public
condition|)
goto|goto
name|found_and_ok
goto|;
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
name|saw_private
operator|=
name|function
expr_stmt|;
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
name|saw_protected
operator|=
name|function
expr_stmt|;
comment|/* If we fail on the exact match, we have 		     an immediate failure.  */
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|pass
operator|>
literal|0
condition|)
block|{
name|tree
name|these_parms
init|=
name|parms
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|n_inner_fields_searched
operator|++
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|harshness
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
name|these_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|these_parms
argument_list|)
expr_stmt|;
name|compute_conversion_costs
argument_list|(
name|function
argument_list|,
name|these_parms
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|->
name|b_or_d
operator|+=
name|b_or_d
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|evil
operator|==
literal|0
condition|)
block|{
name|cp
operator|->
name|u
operator|.
name|field
operator|=
name|function
expr_stmt|;
name|cp
operator|->
name|function
operator|=
name|function
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_PROTECT
condition|)
block|{
name|enum
name|visibility_type
name|this_v
decl_stmt|;
name|this_v
operator|=
name|compute_visibility
argument_list|(
name|basetypes
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_v
operator|==
name|visibility_protected
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_PROTECTED_OK
operator|)
condition|)
name|this_v
operator|=
name|visibility_public
expr_stmt|;
if|if
condition|(
name|this_v
operator|!=
name|visibility_public
condition|)
block|{
if|if
condition|(
name|this_v
operator|==
name|visibility_private
condition|)
name|saw_private
operator|=
name|function
expr_stmt|;
else|else
name|saw_protected
operator|=
name|function
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* No "two-level" conversions.  */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_NO_CONVERSION
operator|&&
name|cp
operator|->
name|user
operator|!=
literal|0
condition|)
continue|continue;
comment|/* If we used default parameters, we must 			 check to see whether anyone else might 			 use them also, and report a possible 			 ambiguity.  */
if|if
condition|(
operator|!
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|save_basetype
argument_list|)
operator|&&
name|cp
operator|->
name|harshness
index|[
name|len
index|]
operator|==
literal|0
operator|&&
operator|(
name|cp
operator|->
name|harshness
index|[
literal|0
index|]
operator|&
literal|128
operator|)
operator|==
literal|0
operator|&&
name|cp
operator|->
name|user
operator|==
literal|0
operator|&&
name|cp
operator|->
name|b_or_d
operator|==
literal|0
operator|&&
name|cp
operator|->
name|easy
operator|<
name|best
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|cp
operator|->
name|arg
expr_stmt|;
if|if
condition|(
name|best
operator|==
literal|2
condition|)
goto|goto
name|found_and_maybe_warn
goto|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Now we have run through one link's member functions. 	     arrange to head-insert this link's links.  */
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
name|b_or_d
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
comment|/* No exact match could be found.  Now try to find match 	     using default conversions.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_GLOBAL
operator|)
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|ever_seen
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|ever_seen
operator|+=
name|list_length
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ever_seen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_GLOBAL
condition|)
name|error
argument_list|(
literal|"no global or member function `%s' defined"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
name|error_with_aggr_type
argument_list|(
name|save_basetype
argument_list|,
literal|"no member function `%s::%s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
continue|continue;
block|}
if|if
condition|(
name|cp
operator|-
name|candidates
operator|!=
literal|0
condition|)
block|{
comment|/* Rank from worst to best.  Then cp will point to best one. 	     Private fields have their bits flipped.  For unsigned 	     numbers, this should make them look very large. 	     If the best alternate has a (signed) negative value, 	     then all we ever saw were private members.  */
if|if
condition|(
name|cp
operator|-
name|candidates
operator|>
literal|1
condition|)
block|{
name|cp
operator|=
name|ideal_candidate
argument_list|(
name|save_basetype
argument_list|,
name|candidates
argument_list|,
name|cp
operator|-
name|candidates
argument_list|,
name|parms
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"ambiguous type conversion requested for %s `%s'"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|.
name|evil
operator|==
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"ambiguous type conversion requested for %s `%s'"
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|cp
operator|--
expr_stmt|;
comment|/* The global function was the best, so use it.  */
if|if
condition|(
name|cp
operator|->
name|u
operator|.
name|field
operator|==
literal|0
condition|)
block|{
comment|/* We must convert the instance pointer into a reference type. 		 Global overloaded functions can only either take 		 aggregate objects (which come for free from references) 		 or reference data types anyway.  */
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|copy_node
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|=
name|build_reference_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_function_call
argument_list|(
name|cp
operator|->
name|function
argument_list|,
name|parms
argument_list|)
return|;
block|}
name|function
operator|=
name|cp
operator|->
name|function
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
name|basetype
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|cp
operator|->
name|arg
expr_stmt|;
block|}
goto|goto
name|found_and_maybe_warn
goto|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|~
name|LOOKUP_GLOBAL
operator|)
operator|&
operator|(
name|LOOKUP_COMPLAIN
operator||
name|LOOKUP_SPECULATIVELY
operator|)
condition|)
block|{
name|char
modifier|*
name|tag_name
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_COMPLAIN
operator|)
operator|)
operator|==
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|cp
operator|->
name|function
argument_list|)
condition|)
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|ever_seen
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|saw_protected
operator||
operator|(
name|int
operator|)
name|saw_private
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_SPECULATIVELY
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|static_call_context
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cp
operator|->
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|instance_ptr
argument_list|)
argument_list|)
argument_list|,
literal|"object missing in call to `%s::%s'"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
name|report_type_mismatch
argument_list|(
name|cp
argument_list|,
name|parms
argument_list|,
name|name_kind
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|tree
name|seen
init|=
name|saw_private
decl_stmt|;
if|if
condition|(
name|saw_private
condition|)
if|if
condition|(
name|saw_protected
condition|)
name|msg
operator|=
literal|"%s %%s (and the like) are private or protected"
expr_stmt|;
else|else
name|msg
operator|=
literal|"the %s %%s is private"
expr_stmt|;
else|else
block|{
name|msg
operator|=
literal|"the %s %%s is protected"
expr_stmt|;
name|seen
operator|=
name|saw_protected
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
name|msg
argument_list|,
name|name_kind
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|seen
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"within this context"
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|LOOKUP_SPECULATIVELY
operator||
name|LOOKUP_COMPLAIN
operator|)
operator|)
operator|==
name|LOOKUP_COMPLAIN
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|save_basetype
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|tag_name
operator|=
literal|"structure"
expr_stmt|;
else|else
name|tag_name
operator|=
literal|"union"
expr_stmt|;
if|if
condition|(
name|wrap
condition|)
name|buf
operator|=
literal|"%s has no appropriate wrapper function defined"
expr_stmt|;
else|else
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|30
operator|+
name|strlen
argument_list|(
name|err_name
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"%s has no method named `%s'"
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
name|buf
argument_list|,
name|tag_name
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
continue|continue;
name|found_and_maybe_warn
label|:
if|if
condition|(
name|cp
operator|->
name|harshness
index|[
literal|0
index|]
operator|&
literal|128
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
block|{
name|error_with_decl
argument_list|(
name|cp
operator|->
name|function
argument_list|,
literal|"non-const member function `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"called for const object at this point in file"
argument_list|)
expr_stmt|;
block|}
comment|/* Not good enough for a match.  */
else|else
return|return
name|error_mark_node
return|;
block|}
goto|goto
name|found_and_ok
goto|;
block|}
comment|/* Silently return error_mark_node.  */
return|return
name|error_mark_node
return|;
name|found
label|:
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|error
argument_list|(
name|TREE_PRIVATE
argument_list|(
name|function
argument_list|)
condition|?
literal|"%s `%s' is private"
else|:
literal|"%s `%s' is from private base class"
argument_list|,
name|name_kind
argument_list|,
name|lang_printable_name
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|error
argument_list|(
name|TREE_PROTECTED
argument_list|(
name|function
argument_list|)
condition|?
literal|"%s `%s' is protected"
else|:
literal|"%s `%s' has protected visibility from this point"
argument_list|,
name|name_kind
argument_list|,
name|lang_printable_name
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
name|found_and_ok
label|:
comment|/* From here on down, BASETYPE is the type that INSTANCE_PTR's      type (if it exists) is a pointer to.  */
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
comment|/* If we are referencing a virtual function from an object      of effectively static type, then there is no need      to go through the virtual function table.  */
if|if
condition|(
name|need_vtbl
operator|==
name|maybe_needed
condition|)
block|{
name|int
name|fixed_type
init|=
name|resolves_to_fixed_type_p
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
name|all_virtual
operator|==
literal|1
operator|&&
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
operator|&&
name|may_be_remote
argument_list|(
name|basetype
argument_list|)
condition|)
name|need_vtbl
operator|=
name|needed
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|function
argument_list|)
condition|)
name|need_vtbl
operator|=
name|fixed_type
condition|?
name|unneeded
else|:
name|needed
expr_stmt|;
else|else
name|need_vtbl
operator|=
name|not_needed
expr_stmt|;
if|if
condition|(
name|fixed_type
operator|&&
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|function
argument_list|,
literal|"invalid call to abstract function `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|static_call_context
condition|)
block|{
comment|/* Let's be nice to the user for now, and give reasonable 	 default behavior.  */
name|instance_ptr
operator|=
name|current_class_decl
expr_stmt|;
if|if
condition|(
name|instance_ptr
condition|)
block|{
if|if
condition|(
name|basetype
operator|!=
name|current_class_type
condition|)
block|{
name|basetype
operator|=
name|get_base_type
argument_list|(
name|basetype
argument_list|,
name|current_class_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetype
operator|==
literal|0
condition|)
block|{
name|error_not_base_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|basetype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
name|error_with_aggr_type
argument_list|(
name|basetype
argument_list|,
literal|"cannot call member function `%s::%s' without object"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|value_type
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
else|:
name|void_type_node
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|value_type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LOOKUP_COMPLAIN
condition|)
name|incomplete_type_error
argument_list|(
literal|0
argument_list|,
name|value_type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* We do not pass FUNCTION into `actualparameterlist', because by      now everything should be ok.  If not, then we have a serious error.  */
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|function
argument_list|)
condition|)
name|parms
operator|=
name|actualparameterlist
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|need_vtbl
operator|==
name|unneeded
condition|)
block|{
name|int
name|sub_flags
init|=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|?
name|flags
else|:
name|LOOKUP_NORMAL
decl_stmt|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|(
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|basetype
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
block|{
name|basetype
operator|=
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|instance_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|actualparameterlist
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|sub_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_NONVIRTUAL
operator|)
operator|==
literal|0
condition|)
name|basetype
operator|=
name|DECL_VCONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* First parm could be integer_zerop with casts like 	 ((Object*)0)->Object::IsA()  */
if|if
condition|(
operator|!
name|integer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
block|{
name|instance_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|build_type_variant
argument_list|(
name|basetype
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance_ptr
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|instance_ptr
operator|=
name|save_expr
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|instance_ptr
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance_ptr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|instance_ptr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|instance
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|instance
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|instance
argument_list|)
operator|!=
name|INDIRECT_REF
operator|||
name|TREE_OPERAND
argument_list|(
name|instance
argument_list|,
literal|0
argument_list|)
operator|!=
name|instance_ptr
condition|)
name|instance
operator|=
name|build_indirect_ref
argument_list|(
name|instance_ptr
argument_list|)
expr_stmt|;
block|}
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|instance_ptr
argument_list|,
name|actualparameterlist
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* See if there is a wrapper for this thing.  */
if|if
condition|(
name|wrap
operator|<
literal|0
operator|||
name|static_call_context
operator|||
name|name
operator|==
name|wrapper_name
operator|||
name|name
operator|==
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|wrap
operator|>
literal|0
operator|||
name|TYPE_NEEDS_WRAPPER
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|flags
operator|&=
operator|~
name|LOOKUP_PROTECT
expr_stmt|;
if|if
condition|(
name|wrap
operator|==
literal|0
condition|)
block|{
name|wrap
operator|=
name|TYPE_NEEDS_WRAPPER
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
comment|/* If no wrapper specified, wrapper may be virtual.  */
name|flags
operator|&=
operator|~
name|LOOKUP_NONVIRTUAL
expr_stmt|;
block|}
if|if
condition|(
name|wrap
condition|)
block|{
name|tree
name|wrapped_result
decl_stmt|,
name|unwrapped_result
decl_stmt|;
specifier|register
name|int
name|bytecount
init|=
name|get_arglist_len_in_bytes
argument_list|(
name|parms
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|all_virtual
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|parm
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|basetype
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
name|parm
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_WRAPPER_PRED
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|unwrapped_result
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|default_conversion
argument_list|(
name|function
argument_list|)
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_OPERAND
argument_list|(
name|unwrapped_result
argument_list|,
literal|1
argument_list|)
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|unwrapped_result
argument_list|)
operator|=
name|value_type
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|unwrapped_result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_RAISES
argument_list|(
name|unwrapped_result
argument_list|)
operator|=
operator|!
operator|!
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
block|}
comment|/* If this pointer walked as a result of multiple inheritance, 	     keep its displaced value.  */
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|bytecount
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|parm
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|wrapped_result
operator|=
name|get_wrapper
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|wrapped_result
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|wrapped_result
operator|!=
name|error_mark_node
argument_list|)
expr_stmt|;
comment|/* @@ Should BASETYPE_PATH get TREE_PURPOSE (wrapped_result) here?  */
name|wrapped_result
operator|=
name|build_method_call
argument_list|(
name|instance
argument_list|,
name|DECL_ORIGINAL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|wrapped_result
argument_list|)
argument_list|)
argument_list|,
name|parms
argument_list|,
name|basetype_path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Do this if we want the result of operator->() to inherit 	     the type of the function it is subbing for.  */
block|if (wrapped_result != error_mark_node) 	    TREE_TYPE (wrapped_result) = value_type;
endif|#
directive|endif
if|if
condition|(
name|TYPE_HAS_WRAPPER_PRED
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|result
operator|=
name|build_conditional_expr
argument_list|(
name|build_method_call
argument_list|(
name|instance
argument_list|,
name|wrapper_pred_name
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|parm
argument_list|)
argument_list|,
name|basetype_path
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
argument_list|,
name|wrapped_result
argument_list|,
name|unwrapped_result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|wrapped_result
expr_stmt|;
block|}
name|TREE_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
comment|/* Constructors do not overload method calls.  */
elseif|else
if|if
condition|(
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|basetype
argument_list|)
operator|&&
name|name
operator|!=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|OPERATOR_METHOD_FORMAT
argument_list|,
name|OPERATOR_METHOD_LENGTH
argument_list|)
operator|)
if|#
directive|if
literal|0
expr|&& (may_be_remote (basetype) 	       || (C_C_D ? TREE_TYPE (instance) != current_class_type : 1))
else|#
directive|else
comment|/* This change by Larry Ketcham.  */
operator|&&
operator|(
name|may_be_remote
argument_list|(
name|basetype
argument_list|)
operator|||
name|instance
operator|!=
name|C_C_D
operator|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|ESKIT
specifier|register
name|int
name|bytecount
init|=
literal|0
decl_stmt|;
else|#
directive|else
specifier|register
name|int
name|bytecount
init|=
name|get_arglist_len_in_bytes
argument_list|(
name|parms
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|tree
name|fn_as_int
decl_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|bytecount
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_virtual
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|fn_as_int
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fn_as_int
operator|=
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|default_conversion
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_virtual
operator|==
literal|1
condition|)
name|fn_as_int
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|fn_as_int
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_opfncall
argument_list|(
name|METHOD_CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|instance
argument_list|,
name|fn_as_int
argument_list|,
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL_TREE
condition|)
block|{
name|compiler_error
argument_list|(
literal|"could not overload `operator->()(...)'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|#
directive|if
literal|0
comment|/* Do this if we want the result of operator->() to inherit 	 the type of the function it is subbing for.  */
block|TREE_TYPE (result) = value_type;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ESKIT
block|{
name|int
name|used
decl_stmt|,
name|size
decl_stmt|;
comment|/* Count the number of bytes of arguements to operator->(), 	   not to the method itself.  In the tally, don't count bytes 	   for pointer to member function or for the bytecount.  */
name|parms
operator|=
name|TREE_OPERAND
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bytecount
operator|=
name|get_arglist_len_in_bytes
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|used
operator|=
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
name|size
operator|=
name|PUSH_ROUNDING
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|used
operator|=
operator|(
operator|(
operator|(
name|size
operator|+
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|bytecount
operator|+=
name|used
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|bytecount
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|result
return|;
block|}
if|if
condition|(
name|need_vtbl
operator|==
name|needed
condition|)
block|{
name|function
operator|=
name|build_vfn_ref
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|instance
argument_list|,
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOS
elseif|else
if|if
condition|(
name|basetype
operator|&&
name|TYPE_DYNAMIC
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|function
operator|=
name|build_array_ref
argument_list|(
name|dtbl
argument_list|,
name|DECL_DINDEX
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|TREE_INLINE
argument_list|(
name|function
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|function
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
else|else
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|function
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|value_type
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_RAISES
argument_list|(
name|result
argument_list|)
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
operator|||
operator|(
name|parms
operator|&&
name|TREE_RAISES
argument_list|(
name|parms
argument_list|)
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Similar to `build_method_call', but for overloaded non-member functions.    The name of this function comes through NAME.  The name depends    on PARMS.     Note that this function must handle simple `C' promotions,    as well as variable numbers of arguments (...), and    default arguments to boot.     If the overloading is successful, we return a treenode which    contains the call to the function.     If overloading produces candidates which are probabe, but not definite,    we hold these candidates.  If FINAL_CP is non-zero, then we are free    to assume that final_cp points to enough storage for all candidates that    this function might generate.  The `harshness' array is preallocated for    the first candidate, but not for subsequent ones.     Note that the DECL_RTL of FUNCTION must be made to agree with this    function's new name.  */
end_comment

begin_function
name|tree
name|build_overload_call
parameter_list|(
name|fnname
parameter_list|,
name|parms
parameter_list|,
name|complain
parameter_list|,
name|final_cp
parameter_list|)
name|tree
name|fnname
decl_stmt|,
name|parms
decl_stmt|;
name|int
name|complain
decl_stmt|;
name|struct
name|candidate
modifier|*
name|final_cp
decl_stmt|;
block|{
comment|/* must check for overloading here */
name|tree
name|overload_name
decl_stmt|,
name|functions
decl_stmt|,
name|function
decl_stmt|,
name|parm
decl_stmt|;
name|tree
name|parmtypes
init|=
name|NULL_TREE
decl_stmt|,
name|last
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|outer
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|parmlength
init|=
name|list_length
argument_list|(
name|parms
argument_list|)
decl_stmt|;
name|struct
name|candidate
modifier|*
name|candidates
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|rank_for_overload
parameter_list|()
function_decl|;
if|if
condition|(
name|final_cp
condition|)
block|{
name|final_cp
index|[
literal|0
index|]
operator|.
name|evil
operator|=
literal|0
expr_stmt|;
name|final_cp
index|[
literal|0
index|]
operator|.
name|user
operator|=
literal|0
expr_stmt|;
name|final_cp
index|[
literal|0
index|]
operator|.
name|b_or_d
operator|=
literal|0
expr_stmt|;
name|final_cp
index|[
literal|0
index|]
operator|.
name|easy
operator|=
literal|0
expr_stmt|;
name|final_cp
index|[
literal|0
index|]
operator|.
name|function
operator|=
literal|0
expr_stmt|;
comment|/* end marker.  */
name|final_cp
index|[
literal|1
index|]
operator|.
name|evil
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|parm
operator|=
name|parms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
specifier|register
name|tree
name|t
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
block|{
comment|/* Perform the conversion from ARRAY_TYPE to POINTER_TYPE in place. 	     Also convert OFFSET_TYPE entities to their normal selves. 	     This eliminates needless calls to `compute_conversion_costs'.  */
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|=
name|default_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|chainon
argument_list|(
name|parmtypes
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
else|else
name|parmtypes
operator|=
name|void_list_node
expr_stmt|;
name|overload_name
operator|=
name|build_decl_overload
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|fnname
argument_list|)
argument_list|,
name|parmtypes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now check to see whether or not we can win.      Note that if we are called from `build_method_call',      then we cannot have a mis-match, because we would have      already found such a winning case.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|overload_name
argument_list|)
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|overload_name
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|build_function_call
argument_list|(
name|DECL_MAIN_VARIANT
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|overload_name
argument_list|)
argument_list|)
argument_list|,
name|parms
argument_list|)
return|;
name|functions
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
if|if
condition|(
name|functions
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"only member functions apply"
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_cp
condition|)
name|final_cp
operator|->
name|evil
operator|=
literal|1
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|functions
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|functions
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_cp
condition|)
block|{
comment|/* We are just curious whether this is a viable alternative or not.  */
name|compute_conversion_costs
argument_list|(
name|functions
argument_list|,
name|parms
argument_list|,
name|final_cp
argument_list|,
name|parmlength
argument_list|)
expr_stmt|;
return|return
name|functions
return|;
block|}
else|else
return|return
name|build_function_call
argument_list|(
name|functions
argument_list|,
name|parms
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|functions
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"function `%s' declared overloaded, but no instances of that function declared"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|functions
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|functions
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
specifier|register
name|tree
name|outer
decl_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
comment|/* The list-of-lists should only occur for class things.  */
name|assert
argument_list|(
name|functions
operator|==
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|fnname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|outer
operator|=
name|functions
init|;
name|outer
condition|;
name|outer
operator|=
name|TREE_CHAIN
argument_list|(
name|outer
argument_list|)
control|)
block|{
comment|/* member functions.  */
name|length
operator|+=
name|list_length
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|outer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* friend functions.  */
name|length
operator|+=
name|list_length
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|outer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|length
operator|=
name|list_length
argument_list|(
name|functions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|final_cp
condition|)
name|candidates
operator|=
name|final_cp
expr_stmt|;
else|else
name|candidates
operator|=
operator|(
expr|struct
name|candidate
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|candidates
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|functions
argument_list|)
argument_list|)
operator|!=
name|TREE_LIST
argument_list|)
expr_stmt|;
comment|/* OUTER is the list of FUNCTION_DECLS, in a TREE_LIST.  */
for|for
control|(
name|outer
operator|=
name|functions
init|;
name|outer
condition|;
name|outer
operator|=
name|TREE_CHAIN
argument_list|(
name|outer
argument_list|)
control|)
block|{
name|function
operator|=
name|TREE_VALUE
argument_list|(
name|outer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|error_with_decl
argument_list|(
name|function
argument_list|,
literal|"enumeral value `%s' conflicts with function of same name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|VAR_DECL
condition|)
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|function
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|function
argument_list|,
literal|"variable `%s' conflicts with function of same name"
argument_list|)
expr_stmt|;
else|else
name|error_with_decl
argument_list|(
name|function
argument_list|,
literal|"constant field `%s' conflicts with function of same name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|TYPE_DECL
condition|)
continue|continue;
else|else
name|abort
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"at this point in file"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|function
operator|=
name|DECL_MAIN_VARIANT
argument_list|(
name|function
argument_list|)
expr_stmt|;
comment|/* Can't use alloca here, since result might be 	 passed to calling function.  */
name|cp
operator|->
name|harshness
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|oballoc
argument_list|(
operator|(
name|parmlength
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|compute_conversion_costs
argument_list|(
name|function
argument_list|,
name|parms
argument_list|,
name|cp
argument_list|,
name|parmlength
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|.
name|evil
operator|==
literal|0
condition|)
block|{
name|cp
index|[
literal|1
index|]
operator|.
name|evil
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|final_cp
operator|&&
name|cp
index|[
literal|0
index|]
operator|.
name|user
operator|==
literal|0
operator|&&
name|cp
index|[
literal|0
index|]
operator|.
name|b_or_d
operator|==
literal|0
operator|&&
name|cp
index|[
literal|0
index|]
operator|.
name|easy
operator|<=
literal|1
condition|)
block|{
name|final_cp
index|[
literal|0
index|]
operator|.
name|easy
operator|=
name|cp
index|[
literal|0
index|]
operator|.
name|easy
expr_stmt|;
return|return
name|function
return|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
operator|-
name|candidates
condition|)
block|{
name|tree
name|rval
init|=
name|error_mark_node
decl_stmt|;
comment|/* Leave marker.  */
name|cp
index|[
literal|0
index|]
operator|.
name|evil
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cp
operator|-
name|candidates
operator|>
literal|1
condition|)
block|{
name|struct
name|candidate
modifier|*
name|best_cp
init|=
name|ideal_candidate
argument_list|(
name|NULL_TREE
argument_list|,
name|candidates
argument_list|,
name|cp
operator|-
name|candidates
argument_list|,
name|parms
argument_list|,
name|parmlength
argument_list|)
decl_stmt|;
if|if
condition|(
name|best_cp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"call of overloaded `%s' is ambiguous"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|fnname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|rval
operator|=
name|best_cp
operator|->
name|function
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|evil
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"type conversion ambiguous"
argument_list|)
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|cp
operator|->
name|function
expr_stmt|;
block|}
if|if
condition|(
name|final_cp
condition|)
return|return
name|rval
return|;
return|return
name|build_function_call
argument_list|(
name|rval
argument_list|,
name|parms
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|complain
condition|)
block|{
name|tree
name|name
decl_stmt|;
name|char
modifier|*
name|err_name
decl_stmt|;
comment|/* Initialize name for error reporting.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|functions
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|name
operator|=
name|TREE_PURPOSE
argument_list|(
name|functions
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|DECL_ORIGINAL_NAME
argument_list|(
name|functions
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPERATOR_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|opname
init|=
name|operator_name_string
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|err_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|opname
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|err_name
argument_list|,
literal|"operator %s"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
else|else
name|err_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|report_type_mismatch
argument_list|(
name|cp
argument_list|,
name|parms
argument_list|,
literal|"function"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_function
name|void
name|init_class_processing
parameter_list|()
block|{
name|current_class_stacksize
operator|=
literal|10
expr_stmt|;
name|current_class_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_class_stacksize
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|current_class_stack
operator|=
name|current_class_base
expr_stmt|;
name|current_lang_stacksize
operator|=
literal|10
expr_stmt|;
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xmalloc
argument_list|(
name|current_lang_stacksize
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
expr_stmt|;
name|delta_name
operator|=
name|get_identifier
argument_list|(
name|VTABLE_DELTA_NAME
argument_list|)
expr_stmt|;
name|pfn_name
operator|=
name|get_identifier
argument_list|(
name|VTABLE_PFN_NAME
argument_list|)
expr_stmt|;
comment|/* Keep these values lying around.  */
name|minus_one_node
operator|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|the_null_vtable_entry
operator|=
name|build_vtable_entry
argument_list|(
name|integer_zero_node
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|base_layout_decl
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|base_layout_decl
argument_list|)
operator|=
name|make_node
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|class_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set current scope to NAME. CODE tells us if this is a    STRUCT, UNION, or ENUM environment.     NAME may end up being NULL_TREE if this is an anonymous or    late-bound struct (as in "struct { ... } foo;")  */
end_comment

begin_comment
comment|/* Here's a subroutine we need because C lacks lambdas.  */
end_comment

begin_function
name|void
name|unuse_fields
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|fields
decl_stmt|;
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|TREE_USED
argument_list|(
name|fields
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_ANON_UNION_ELEM
argument_list|(
name|fields
argument_list|)
condition|)
name|unuse_fields
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set global variables CURRENT_CLASS_NAME and CURRENT_CLASS_TYPE to    appropriate values, found by looking up the type definition of    NAME (as a CODE).     If MODIFY is 1, we set IDENTIFIER_CLASS_VALUE's of names    which can be seen locally to the class. They are shadowed by    any subsequent local declaration (including parameter names).     If MODIFY is 2, we set IDENTIFIER_CLASS_VALUE's of names    which have static meaning (i.e., static members, static    member functions, enum declarations, etc).     So that we may avoid calls to lookup_name, we cache the TYPE_DECL    in the TREE_TYPE field of the name.     For multiple inheritance, we perform a two-pass depth-first search    of the type lattice.  The first pass performs a pre-order search,    marking types after the type has had its fields installed in    the appropriate IDENTIFIER_CLASS_VALUE slot.  The second pass merely    unmarks the marked types.  If a field or member function name    appears in an ambiguous way, the IDENTIFIER_CLASS_VALUE of    that name becomes `error_mark_node'.  */
end_comment

begin_function
name|void
name|pushclass
parameter_list|(
name|type
parameter_list|,
name|modify
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|modify
decl_stmt|;
block|{
name|push_memoized_context
argument_list|(
name|type
argument_list|,
name|modify
argument_list|)
expr_stmt|;
operator|*
name|current_class_stack
operator|++
operator|=
name|current_class_name
expr_stmt|;
operator|*
name|current_class_stack
operator|++
operator|=
name|current_class_type
expr_stmt|;
if|if
condition|(
name|current_class_stack
operator|>=
name|current_class_base
operator|+
name|current_class_stacksize
condition|)
block|{
name|current_class_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|current_class_base
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
operator|(
name|current_class_stacksize
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
name|current_class_stack
operator|=
name|current_class_base
operator|+
name|current_class_stacksize
expr_stmt|;
name|current_class_stacksize
operator|+=
literal|10
expr_stmt|;
block|}
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|current_class_name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_class_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|current_class_name
operator|=
name|DECL_NAME
argument_list|(
name|current_class_name
argument_list|)
expr_stmt|;
name|current_class_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|prev_class_type
operator|&&
name|prev_class_type
operator|!=
name|NULL_TREE
operator|&&
name|current_class_stack
operator|==
name|current_class_base
operator|+
literal|2
condition|)
block|{
name|popclass
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|prev_class_type
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|modify
condition|)
block|{
name|tree
name|tags
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|prev_class_type
condition|)
block|{
name|build_mi_matrix
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|push_class_decls
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|free_mi_matrix
argument_list|()
expr_stmt|;
name|prev_class_type
operator|=
name|type
expr_stmt|;
block|}
else|else
name|unuse_fields
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|tags
operator|=
name|CLASSTYPE_TAGS
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|TREE_NONLOCAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushtag
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|pushlevel_class
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_push_class
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current class scope. If we were in a class scope    previously, that is the one popped to.  The flag MODIFY tells    whether the current scope declarations needs to be modified    as a result of popping to the new scope.  */
end_comment

begin_function
name|void
name|popclass
parameter_list|(
name|modify
parameter_list|)
name|int
name|modify
decl_stmt|;
block|{
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_pop_class
argument_list|()
expr_stmt|;
if|if
condition|(
name|modify
operator|<
literal|0
condition|)
block|{
comment|/* Back this old class out completely.  */
name|tree
name|tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|prev_class_type
argument_list|)
decl_stmt|;
name|pop_class_decls
argument_list|(
name|prev_class_type
argument_list|)
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|TREE_NONLOCAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|modify
condition|)
block|{
comment|/* Just remove from this class what didn't make 	 it into IDENTIFIER_CLASS_VALUE.  */
name|tree
name|tags
init|=
name|CLASSTYPE_TAGS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|TREE_NONLOCAL
argument_list|(
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tags
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|poplevel_class
argument_list|()
expr_stmt|;
name|current_class_type
operator|=
operator|*
operator|--
name|current_class_stack
expr_stmt|;
name|current_class_name
operator|=
operator|*
operator|--
name|current_class_stack
expr_stmt|;
if|if
condition|(
name|current_class_type
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_VTBL_PTR
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|current_vtable_decl
operator|=
name|lookup_name
argument_list|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_VTBL_PTR
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_vtable_decl
condition|)
name|current_vtable_decl
operator|=
name|build_indirect_ref
argument_list|(
name|current_vtable_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|current_class_decl
operator|=
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
name|THIS_NAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_class_decl
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* Can't call build_indirect_ref here, because it has special 		 logic to return C_C_D given this argument.  */
name|C_C_D
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|current_class_type
argument_list|,
name|current_class_decl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|C_C_D
argument_list|)
operator|=
name|TREE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|C_C_D
operator|=
name|current_class_decl
expr_stmt|;
block|}
else|else
name|C_C_D
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|current_class_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|current_vtable_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|C_C_D
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|pop_memoized_context
argument_list|(
name|modify
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set global variables CURRENT_LANG_NAME to appropriate value    so that behavior of name-mangline machinery is correct.  */
end_comment

begin_function
name|void
name|push_lang_context
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
operator|*
name|current_lang_stack
operator|++
operator|=
name|current_lang_name
expr_stmt|;
if|if
condition|(
name|current_lang_stack
operator|>=
name|current_lang_base
operator|+
name|current_lang_stacksize
condition|)
block|{
name|current_lang_base
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|current_lang_base
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
operator|(
name|current_lang_stacksize
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
name|current_lang_stack
operator|=
name|current_lang_base
operator|+
name|current_lang_stacksize
expr_stmt|;
name|current_lang_stacksize
operator|+=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|lang_name_cplusplus
condition|)
block|{
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|lang_name_c
condition|)
block|{
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
name|current_lang_name
operator|=
name|name
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"language string `\"%s\"' not recognized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_push_lang
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get out of the current language scope.  */
end_comment

begin_function
name|void
name|pop_lang_context
parameter_list|()
block|{
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_pop_lang
argument_list|()
expr_stmt|;
name|current_lang_name
operator|=
operator|*
operator|--
name|current_lang_stack
expr_stmt|;
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_cplusplus
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_cplusplus
expr_stmt|;
elseif|else
if|if
condition|(
name|current_lang_name
operator|==
name|lang_name_c
condition|)
name|strict_prototype
operator|=
name|strict_prototypes_lang_c
expr_stmt|;
block|}
end_function

begin_function
name|int
name|root_lang_context_p
parameter_list|()
block|{
return|return
name|current_lang_stack
operator|==
name|current_lang_base
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Type instantiation routines.  */
end_comment

begin_comment
comment|/* This function will instantiate the type of the expression given    in RHS to match the type of LHSTYPE.  If LHSTYPE is NULL_TREE,    or other errors exist, the TREE_TYPE of RHS will be ERROR_MARK_NODE.     This function is used in build_modify_expr, actualparameterlist,    build_c_cast, and compute_conversion_costs.  */
end_comment

begin_function
name|tree
name|instantiate_type
parameter_list|(
name|lhstype
parameter_list|,
name|rhs
parameter_list|,
name|complain
parameter_list|)
name|tree
name|lhstype
decl_stmt|,
name|rhs
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|OP_IDENTIFIER
condition|)
return|return
name|build_instantiated_decl
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|!
operator|(
name|type_unknown_p
argument_list|(
name|rhs
argument_list|)
operator|)
condition|)
return|return
name|rhs
return|;
comment|/* This should really only be used when attempting to distinguish      what sort of a pointer to function we have.  For now, any      arithmethic operation which is not supported on pointers      is rejected as an error.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|TYPE_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|BUFFER_REF
case|:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
name|lhstype
operator|=
name|build_pointer_type
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|rhs
return|;
case|case
name|NOP_EXPR
case|:
name|rhs
operator|=
name|copy_node
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|complain
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|tree
name|function
init|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|field
argument_list|,
name|complain
argument_list|)
decl_stmt|;
if|if
condition|(
name|function
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|tree
name|base
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|base_ptr
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|base
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|base_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|base_ptr
operator|=
name|convert_pointer_to
argument_list|(
name|DECL_VCONTEXT
argument_list|(
name|function
argument_list|)
argument_list|,
name|base_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_ptr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_vfn_ref
argument_list|(
operator|&
name|base_ptr
argument_list|,
name|base
argument_list|,
name|DECL_VINDEX
argument_list|(
name|function
argument_list|)
argument_list|)
return|;
block|}
return|return
name|function
return|;
block|}
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
comment|/* First look for an exact match  */
while|while
condition|(
name|field
operator|&&
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|!=
name|lhstype
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|field
expr_stmt|;
return|return
name|rhs
return|;
block|}
comment|/* No exact match found, look for a compatible function.  */
name|field
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|field
operator|&&
operator|!
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|field
expr_stmt|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
while|while
condition|(
name|field
operator|&&
operator|!
name|comptypes
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"ambiguous overload for COMPONENT_REF requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no appropriate overload exists for COMPONENT_REF"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|rhs
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|elem
decl_stmt|,
name|baselink
decl_stmt|,
name|name
decl_stmt|;
name|int
name|globals
init|=
name|overloaded_globals_p
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
comment|/* If there's only one function we know about, return that.  */
if|if
condition|(
name|globals
operator|>
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|rhs
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
return|;
comment|/* First look for an exact match.  Search either overloaded 	   functions or member functions.  May have to undo what 	   `default_conversion' or `datatype' might do to lhstype.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid type combination for overload"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|globals
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"cannot resolve overloaded function `%s' based on non-function type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|globals
operator|>
literal|0
condition|)
block|{
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|elem
operator|=
name|rhs
expr_stmt|;
while|while
condition|(
name|elem
condition|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|!=
name|lhstype
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
else|else
return|return
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
return|;
comment|/* No exact match found, look for a compatible function.  */
name|elem
operator|=
name|rhs
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
operator|!
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
name|tree
name|save_elem
init|=
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
decl_stmt|;
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
operator|!
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"ambiguous overload for overloaded function requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|save_elem
return|;
block|}
if|if
condition|(
name|complain
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|rhs
argument_list|)
condition|)
name|error
argument_list|(
literal|"no appropriate overload for overloaded function `%s' exists"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"function `%s' has inappropriate type signature"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_NONLOCAL
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
comment|/* Got to get it as a baselink.  */
name|rhs
operator|=
name|lookup_fnfields
argument_list|(
name|CLASSTYPE_AS_LIST
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|rhs
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|rhs
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|rhs
operator|=
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|baselink
operator|=
name|rhs
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
name|elem
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
condition|)
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
operator|!=
name|lhstype
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
else|else
return|return
name|elem
return|;
block|}
comment|/* No exact match found, look for a compatible method.  */
for|for
control|(
name|baselink
operator|=
name|rhs
init|;
name|baselink
condition|;
name|baselink
operator|=
name|next_baselink
argument_list|(
name|baselink
argument_list|)
control|)
block|{
name|elem
operator|=
name|TREE_VALUE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
operator|!
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
name|tree
name|save_elem
init|=
name|elem
decl_stmt|;
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
while|while
condition|(
name|elem
operator|&&
operator|!
name|comp_target_types
argument_list|(
name|lhstype
argument_list|,
name|TREE_TYPE
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|elem
operator|=
name|TREE_CHAIN
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"ambiguous overload for overloaded method requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|save_elem
return|;
block|}
name|name
operator|=
name|DECL_ORIGINAL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|globals
operator|<
literal|0
condition|)
block|{
comment|/* Try to instantiate from non-member functions.  */
name|rhs
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* This code seems to be missing a `return'.  */
name|abort
argument_list|()
expr_stmt|;
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|rhs
argument_list|,
name|complain
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no static member functions named `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
case|case
name|CALL_EXPR
case|:
comment|/* This is too hard for now.  */
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|FFS_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"illegal operation on uninstantiated type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|type_unknown_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"not enough type information"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|2
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|MODIFY_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhstype
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"type for resolving address of overloaded function must be pointer type"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
operator|=
name|lhstype
expr_stmt|;
name|lhstype
operator|=
name|TREE_TYPE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|=
name|instantiate_type
argument_list|(
name|lhstype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rhs
return|;
case|case
name|ENTRY_VALUE_EXPR
case|:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is called when we finally know the type of expression    we are looking for.  If the operator encoded by EXP can take an    argument of type TYPE, return the FUNCTION_DECL for that operator.  */
end_comment

begin_function
name|tree
name|build_instantiated_decl
parameter_list|(
name|type
parameter_list|,
name|exp
parameter_list|)
name|tree
name|type
decl_stmt|,
name|exp
decl_stmt|;
block|{
name|tree
name|parmtypes
decl_stmt|,
name|decl
decl_stmt|,
name|name
decl_stmt|;
name|assert
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|OP_IDENTIFIER
argument_list|)
expr_stmt|;
name|type
operator|=
name|datatype
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid type used to resolve overloaded function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Now we know the type of this function, so overload it.  */
name|parmtypes
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_operator_fnname
argument_list|(
operator|&
name|exp
argument_list|,
name|parmtypes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|name
operator|=
name|build_decl_overload
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|parmtypes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|decl
operator|=
name|lookup_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
condition|)
return|return
name|decl
return|;
name|error
argument_list|(
literal|"no suitable declaration of `operator %s' for overloading"
argument_list|,
name|operator_name_string
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the name of the virtual function table (as an IDENTIFIER_NODE)    for the given TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|get_vtable_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|VTABLE_NAME_FORMAT
argument_list|)
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VTABLE_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the virtual function pointer field    (as an IDENTIFIER_NODE) for the given TYPE.  Note that    this may have to look back through base types to find the    ultimate field name.  (For single inheritance, these could    all be the same name.  Who knows for multiple inheritance).  */
end_comment

begin_function
specifier|static
name|tree
name|get_vfield_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_VIRTUAL_P
argument_list|(
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
condition|)
name|type
operator|=
name|CLASSTYPE_BASECLASS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|VFIELD_NAME_FORMAT
argument_list|)
operator|+
name|TYPE_NAME_LENGTH
argument_list|(
name|type
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|VFIELD_NAME_FORMAT
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|print_class_statistics
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"convert_harshness = %d\n"
argument_list|,
name|n_convert_harshness
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compute_conversion_costs = %d\n"
argument_list|,
name|n_compute_conversion_costs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"build_method_call = %d (inner = %d)\n"
argument_list|,
name|n_build_method_call
argument_list|,
name|n_inner_fields_searched
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_vtables
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtables = %d; vtable searches = %d\n"
argument_list|,
name|n_vtables
argument_list|,
name|n_vtable_searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtable entries = %d; vtable elems = %d\n"
argument_list|,
name|n_vtable_entries
argument_list|,
name|n_vtable_elems
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

