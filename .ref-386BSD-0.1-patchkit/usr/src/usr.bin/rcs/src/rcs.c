begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                      RCS create/change operation  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/src/local/bin/rcs/src/RCS/rcs.c,v 4.11 89/05/01 15:12:06 narten Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Walter Tichy.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Report all problems and direct all questions to:  *   rcs-bugs@cs.purdue.edu  *         */
end_comment

begin_comment
comment|/* $Log:	rcs.c,v $  * Revision 4.11  89/05/01  15:12:06  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.10  88/11/08  16:01:54  narten  * didn't install previous patch correctly  *   * Revision 4.9  88/11/08  13:56:01  narten  * removed include<sysexits.h> (not needed)  * minor fix for -A option  *   * Revision 4.8  88/11/08  12:01:58  narten  * changes from  eggert@sm.unisys.com (Paul Eggert)  *   * Revision 4.8  88/08/09  19:12:27  eggert  * Don't access freed storage.  * Use execv(), not system(); yield proper exit status; remove lint.  *   * Revision 4.7  87/12/18  11:37:17  narten  * lint cleanups (Guy Harris)  *   * Revision 4.6  87/10/18  10:28:48  narten  * Updating verison numbers. Changes relative to 1.1 are actually   * relative to 4.3  *   * Revision 1.4  87/09/24  13:58:52  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.3  87/03/27  14:21:55  jenkins  * Port to suns  *   * Revision 1.2  85/12/17  13:59:09  albitz  * Changed setstate to rcs_setstate because of conflict with random.o.  *   * Revision 1.1  84/01/23  14:50:09  kcs  * Initial revision  *   * Revision 4.3  83/12/15  12:27:33  wft  * rcs -u now breaks most recent lock if it can't find a lock by the caller.  *   * Revision 4.2  83/12/05  10:18:20  wft  * Added conditional compilation for sending mail.  * Alternatives: V4_2BSD, V6, USG, and other.  *   * Revision 4.1  83/05/10  16:43:02  wft  * Simplified breaklock(); added calls to findlock() and getcaller().  * Added option -b (default branch). Updated -s and -w for -b.  * Removed calls to stat(); now done by pairfilenames().  * Replaced most catchints() calls with restoreints().  * Removed check for exit status of delivermail().  * Directed all interactive output to stderr.  *   * Revision 3.9.1.1  83/12/02  22:08:51  wft  * Added conditional compilation for 4.2 sendmail and 4.1 delivermail.  *   * Revision 3.9  83/02/15  15:38:39  wft  * Added call to fastcopy() to copy remainder of RCS file.  *  * Revision 3.8  83/01/18  17:37:51  wft  * Changed sendmail(): now uses delivermail, and asks whether to break the lock.  *  * Revision 3.7  83/01/15  18:04:25  wft  * Removed putree(); replaced with puttree() in rcssyn.c.  * Combined putdellog() and scanlogtext(); deleted putdellog().  * Cleaned up diagnostics and error messages. Fixed problem with  * mutilated files in case of deletions in 2 files in a single command.  * Changed marking of selector from 'D' to DELETE.  *  * Revision 3.6  83/01/14  15:37:31  wft  * Added ignoring of interrupts while new RCS file is renamed;  * Avoids deletion of RCS files by interrupts.  *  * Revision 3.5  82/12/10  21:11:39  wft  * Removed unused variables, fixed checking of return code from diff,  * introduced variant COMPAT2 for skipping Suffix on -A files.  *  * Revision 3.4  82/12/04  13:18:20  wft  * Replaced getdelta() with gettree(), changed breaklock to update  * field lockedby, added some diagnostics.  *  * Revision 3.3  82/12/03  17:08:04  wft  * Replaced getlogin() with getpwuid(), flcose() with ffclose(),  * /usr/ucb/Mail with macro MAIL. Removed handling of Suffix (-x).  * fixed -u for missing revno. Disambiguated structure members.  *  * Revision 3.2  82/10/18  21:05:07  wft  * rcs -i now generates a file mode given by the umask minus write permission;  * otherwise, rcs keeps the mode, but removes write permission.  * I added a check for write error, fixed call to getlogin(), replaced  * curdir() with getfullRCSname(), cleaned up handling -U/L, and changed  * conflicting, long identifiers.  *  * Revision 3.1  82/10/13  16:11:07  wft  * fixed type of variables receiving from getc() (char -> int).  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsbaseid
index|[]
init|=
name|RCSBASE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|bindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|expandsym
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* get numeric revision name        */
end_comment

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|getnum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|lock
modifier|*
name|addlock
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* add a lock                       */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getid
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
name|Klog
index|[]
decl_stmt|,
name|Khead
index|[]
decl_stmt|,
name|Kaccess
index|[]
decl_stmt|,
name|Kbranch
index|[]
decl_stmt|,
name|Ktext
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT2
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|Ksuffix
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|getcaller
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* get login of caller              */
end_comment

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|findlock
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* find and remove lock             */
end_comment

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|genrevs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|checkid
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* check an identifier              */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getfullRCSname
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* get full path name of RCS file   */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktempfile
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* temporary file name generator    */
end_comment

begin_extern
extern|extern free(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|void
name|catchints
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ignoreints
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|nerror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counter for errors               */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|quietflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* diagnoses suppressed if true     */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|curlogmsg
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current log message              */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|resultfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filename for fcopy		    */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|fcopy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result file during editing       */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RCS input file                   */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new RCS file                     */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rewriteflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether input should be*/
end_comment

begin_comment
comment|/* echoed to frewrite               */
end_comment

begin_decl_stmt
name|char
modifier|*
name|newRCSfilename
decl_stmt|,
modifier|*
name|diffilename
decl_stmt|,
modifier|*
name|cutfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|RCSfilename
decl_stmt|,
modifier|*
name|workfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|stat
name|RCSstat
decl_stmt|,
name|workstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file status of RCS and work file   */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|haveRCSstat
decl_stmt|,
name|haveworkstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status indicators                  */
end_comment

begin_decl_stmt
name|char
name|accessorlst
index|[
name|strtsize
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fcut
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary file to rebuild delta tree                 */
end_comment

begin_decl_stmt
name|int
name|oldumask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* save umask                                           */
end_comment

begin_decl_stmt
name|int
name|initflag
decl_stmt|,
name|strictlock
decl_stmt|,
name|strict_selected
decl_stmt|,
name|textflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|textfile
decl_stmt|,
modifier|*
name|accessfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|caller
decl_stmt|,
name|numrev
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* caller's login;               */
end_comment

begin_decl_stmt
name|struct
name|access
modifier|*
name|newaccessor
decl_stmt|,
modifier|*
name|rmvaccessor
decl_stmt|,
modifier|*
name|rplaccessor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|access
modifier|*
name|curaccess
decl_stmt|,
modifier|*
name|rmaccess
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|gendeltas
index|[
name|hshsize
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Lockrev
block|{
name|char
modifier|*
name|revno
decl_stmt|;
name|struct
name|Lockrev
modifier|*
name|nextrev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Symrev
block|{
name|char
modifier|*
name|revno
decl_stmt|;
name|char
modifier|*
name|ssymbol
decl_stmt|;
name|int
name|override
decl_stmt|;
name|struct
name|Symrev
modifier|*
name|nextsym
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Status
block|{
name|char
modifier|*
name|revno
decl_stmt|;
name|char
modifier|*
name|status
decl_stmt|;
name|struct
name|Status
modifier|*
name|nextstatus
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|delrevpair
block|{
name|char
modifier|*
name|strt
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|Lockrev
modifier|*
name|newlocklst
decl_stmt|,
modifier|*
name|rmvlocklst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Symrev
modifier|*
name|assoclst
decl_stmt|,
modifier|*
name|lastassoc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Status
modifier|*
name|statelst
decl_stmt|,
modifier|*
name|laststate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delrevpair
modifier|*
name|delrev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|cuthead
decl_stmt|,
modifier|*
name|cuttail
decl_stmt|,
modifier|*
name|delstrt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|branchnum
index|[
name|revlength
index|]
decl_stmt|,
modifier|*
name|branchsym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hshentry
name|branchdummy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|commsyml
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|headstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lockhead
decl_stmt|,
name|unlockcaller
decl_stmt|,
name|chgheadstate
decl_stmt|,
name|branchflag
decl_stmt|,
name|commentflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delaccessflag
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|stringwork
block|{
name|copy
block|,
name|edit
block|,
name|empty
block|}
enum|;
end_enum

begin_comment
comment|/* expand and edit_expand not needed */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|comdusge
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|access
modifier|*
name|removeaccess
argument_list|()
decl_stmt|,
modifier|*
name|getaccessor
argument_list|()
decl_stmt|;
name|struct
name|Lockrev
modifier|*
name|rmnewlocklst
parameter_list|()
function_decl|;
name|struct
name|Lockrev
modifier|*
name|curlock
decl_stmt|,
modifier|*
name|rmvlock
decl_stmt|,
modifier|*
name|lockpt
decl_stmt|;
name|struct
name|Status
modifier|*
name|curstate
decl_stmt|;
name|struct
name|access
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temptr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|nerror
operator|=
literal|0
expr_stmt|;
name|catchints
argument_list|()
expr_stmt|;
name|cmdid
operator|=
literal|"rcs"
expr_stmt|;
name|quietflag
operator|=
name|false
expr_stmt|;
name|comdusge
operator|=
literal|"command format:\nrcs -i -alogins -Alogins -e[logins] -b[rev] -c[commentleader] -l[rev] -u[rev] -L -U -nname[:rev] -Nname[:rev] -orange -sstate[:rev] -t[textfile] file...."
expr_stmt|;
name|rplaccessor
operator|=
name|nil
expr_stmt|;
name|delstrt
operator|=
name|nil
expr_stmt|;
name|accessfile
operator|=
name|textfile
operator|=
name|caller
operator|=
name|nil
expr_stmt|;
name|branchflag
operator|=
name|commentflag
operator|=
name|chgheadstate
operator|=
name|false
expr_stmt|;
name|lockhead
operator|=
name|false
expr_stmt|;
name|unlockcaller
operator|=
name|false
expr_stmt|;
name|initflag
operator|=
name|textflag
operator|=
name|false
expr_stmt|;
name|strict_selected
operator|=
literal|0
expr_stmt|;
name|caller
operator|=
name|getcaller
argument_list|()
expr_stmt|;
name|laststate
operator|=
name|statelst
operator|=
name|nil
expr_stmt|;
name|lastassoc
operator|=
name|assoclst
operator|=
name|nil
expr_stmt|;
name|curlock
operator|=
name|rmvlock
operator|=
name|newlocklst
operator|=
name|rmvlocklst
operator|=
name|nil
expr_stmt|;
name|curaccess
operator|=
name|rmaccess
operator|=
name|rmvaccessor
operator|=
name|newaccessor
operator|=
name|nil
expr_stmt|;
name|delaccessflag
operator|=
name|false
expr_stmt|;
comment|/*  preprocessing command options    */
while|while
condition|(
operator|--
name|argc
operator|,
operator|++
name|argv
operator|,
name|argc
operator|>=
literal|1
operator|&&
operator|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'i'
case|:
comment|/*  initail version  */
name|initflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* change default branch */
if|if
condition|(
name|branchflag
condition|)
name|warn
argument_list|(
literal|"Redfinition of option -b"
argument_list|)
expr_stmt|;
name|branchflag
operator|=
name|true
expr_stmt|;
name|branchsym
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/*  change comment symbol   */
if|if
condition|(
name|commentflag
condition|)
name|warn
argument_list|(
literal|"Redefinition of option -c"
argument_list|)
expr_stmt|;
name|commentflag
operator|=
name|true
expr_stmt|;
name|commsyml
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/*  add new accessor   */
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"Login name missing after -a"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|temp
operator|=
name|getaccessor
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|newaccessor
condition|)
name|curaccess
operator|->
name|nextaccess
operator|=
name|temp
operator|->
name|nextaccess
expr_stmt|;
else|else
name|newaccessor
operator|=
name|temp
operator|->
name|nextaccess
expr_stmt|;
name|temp
operator|->
name|nextaccess
operator|=
name|nil
expr_stmt|;
name|curaccess
operator|=
name|temp
expr_stmt|;
block|}
break|break;
case|case
literal|'A'
case|:
comment|/*  append access list according to accessfile  */
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"Missing file name after -A"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|accessfile
condition|)
name|warn
argument_list|(
literal|"Redefinition of option -A"
argument_list|)
expr_stmt|;
operator|*
name|argv
operator|=
operator|*
name|argv
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|pairfilenames
argument_list|(
literal|1
argument_list|,
name|argv
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|>
literal|0
condition|)
block|{
name|releaselst
argument_list|(
name|newaccessor
argument_list|)
expr_stmt|;
name|newaccessor
operator|=
name|curaccess
operator|=
name|nil
expr_stmt|;
name|releaselst
argument_list|(
name|rmvaccessor
argument_list|)
expr_stmt|;
name|rmvaccessor
operator|=
name|rmaccess
operator|=
name|nil
expr_stmt|;
name|accessfile
operator|=
name|RCSfilename
expr_stmt|;
block|}
else|else
name|accessfile
operator|=
name|nil
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/*  remove accessors   */
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|delaccessflag
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|temp
operator|=
name|getaccessor
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|rmvaccessor
condition|)
name|rmaccess
operator|->
name|nextaccess
operator|=
name|temp
operator|->
name|nextaccess
expr_stmt|;
else|else
name|rmvaccessor
operator|=
name|temp
operator|->
name|nextaccess
expr_stmt|;
name|temptr
operator|=
name|temp
operator|->
name|nextaccess
expr_stmt|;
name|temp
operator|->
name|nextaccess
operator|=
name|nil
expr_stmt|;
name|rmaccess
operator|=
name|temp
expr_stmt|;
while|while
condition|(
name|temptr
condition|)
block|{
name|newaccessor
operator|=
name|removeaccess
argument_list|(
name|temptr
argument_list|,
name|newaccessor
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|temptr
operator|=
name|temptr
operator|->
name|nextaccess
expr_stmt|;
block|}
name|curaccess
operator|=
name|temp
operator|=
name|newaccessor
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|curaccess
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|nextaccess
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'l'
case|:
comment|/*   lock a revision if it is unlocked   */
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* lock head or def. branch */
name|lockhead
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|lockpt
operator|=
operator|(
expr|struct
name|Lockrev
operator|*
operator|)
name|talloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Lockrev
argument_list|)
argument_list|)
expr_stmt|;
name|lockpt
operator|->
name|revno
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
name|lockpt
operator|->
name|nextrev
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|curlock
condition|)
name|curlock
operator|->
name|nextrev
operator|=
name|lockpt
expr_stmt|;
else|else
name|newlocklst
operator|=
name|lockpt
expr_stmt|;
name|curlock
operator|=
name|lockpt
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/*  release lock of a locked revision   */
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/*  unlock head  */
name|unlockcaller
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|lockpt
operator|=
operator|(
expr|struct
name|Lockrev
operator|*
operator|)
name|talloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Lockrev
argument_list|)
argument_list|)
expr_stmt|;
name|lockpt
operator|->
name|revno
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
name|lockpt
operator|->
name|nextrev
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|rmvlock
condition|)
name|rmvlock
operator|->
name|nextrev
operator|=
name|lockpt
expr_stmt|;
else|else
name|rmvlocklst
operator|=
name|lockpt
expr_stmt|;
name|rmvlock
operator|=
name|lockpt
expr_stmt|;
name|curlock
operator|=
name|rmnewlocklst
argument_list|(
name|lockpt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/*  set strict locking */
if|if
condition|(
name|strict_selected
operator|++
condition|)
block|{
comment|/* Already selected L or U? */
if|if
condition|(
operator|!
name|strictlock
condition|)
comment|/* Already selected -U? */
name|warn
argument_list|(
literal|"Option -L overrides -U"
argument_list|)
expr_stmt|;
block|}
name|strictlock
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/*  release strict locking */
if|if
condition|(
name|strict_selected
operator|++
condition|)
block|{
comment|/* Already selected L or U? */
if|if
condition|(
name|strictlock
condition|)
comment|/* Already selected -L? */
name|warn
argument_list|(
literal|"Option -L overrides -U"
argument_list|)
expr_stmt|;
block|}
else|else
name|strictlock
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/*  add new association: error, if name exists */
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"Missing symbolic name after -n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getassoclst
argument_list|(
name|false
argument_list|,
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/*  add or change association   */
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"Missing symbolic name after -N"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getassoclst
argument_list|(
name|true
argument_list|,
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/*  delete revisins  */
if|if
condition|(
name|delrev
condition|)
name|warn
argument_list|(
literal|"Redefinition of option -o"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"Missing revision range after -o"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getdelrev
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/*  change state attribute of a revision  */
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"State missing after -s"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getstates
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/*  change descriptive text   */
name|textflag
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|textfile
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of -t option"
argument_list|)
expr_stmt|;
name|textfile
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|faterror
argument_list|(
literal|"Unknown option: %s\n%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|comdusge
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end processing of options */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"No input file\n%s"
argument_list|,
name|comdusge
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerror
condition|)
block|{
comment|/*  exit, if any error in command options  */
name|diagnose
argument_list|(
literal|"%s aborted"
argument_list|,
name|cmdid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|accessfile
condition|)
comment|/*  get replacement for access list   */
name|getrplaccess
argument_list|()
expr_stmt|;
if|if
condition|(
name|nerror
condition|)
block|{
name|diagnose
argument_list|(
literal|"%s aborted"
argument_list|,
name|cmdid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* now handle all filenames */
do|do
block|{
name|rewriteflag
operator|=
name|false
expr_stmt|;
name|finptr
operator|=
name|frewrite
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|initflag
condition|)
block|{
switch|switch
condition|(
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
break|break;
comment|/*  not exist; ok */
case|case
literal|0
case|:
continue|continue;
comment|/*  error         */
case|case
literal|1
case|:
name|error
argument_list|(
literal|"file %s exists already"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
name|VOID
name|fclose
argument_list|(
name|finptr
argument_list|)
decl_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
continue|continue;
comment|/*  not exist      */
case|case
literal|0
case|:
continue|continue;
comment|/*  errors         */
case|case
literal|1
case|:
break|break;
comment|/*  file exists; ok*/
block|}
block|}
comment|/* now RCSfilename contains the name of the RCS file, and          * workfilename contains the name of the working file.          * if !initflag, finptr contains the file descriptor for the          * RCS file. The admin node is initialized.          */
name|diagnose
argument_list|(
literal|"RCS file: %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|trydiraccess
argument_list|(
name|RCSfilename
argument_list|)
condition|)
continue|continue;
comment|/* give up */
if|if
condition|(
operator|!
name|initflag
operator|&&
operator|!
name|checkaccesslist
argument_list|(
name|caller
argument_list|)
condition|)
continue|continue;
comment|/* give up */
if|if
condition|(
operator|!
name|trysema
argument_list|(
name|RCSfilename
argument_list|,
name|true
argument_list|)
condition|)
continue|continue;
comment|/* give up */
name|gettree
argument_list|()
expr_stmt|;
comment|/* read in delta tree */
comment|/*  update admin. node    */
if|if
condition|(
name|strict_selected
condition|)
name|StrictLocks
operator|=
name|strictlock
expr_stmt|;
if|if
condition|(
name|commentflag
condition|)
name|Comment
operator|=
name|commsyml
expr_stmt|;
comment|/* update default branch */
if|if
condition|(
name|branchflag
operator|&&
name|expandsym
argument_list|(
name|branchsym
argument_list|,
name|branchnum
argument_list|)
condition|)
block|{
if|if
condition|(
name|countnumflds
argument_list|(
name|branchnum
argument_list|)
operator|>
literal|0
condition|)
block|{
name|branchdummy
operator|.
name|num
operator|=
name|branchnum
expr_stmt|;
name|Dbranch
operator|=
operator|&
name|branchdummy
expr_stmt|;
block|}
else|else
name|Dbranch
operator|=
name|nil
expr_stmt|;
block|}
comment|/*  update access list   */
if|if
condition|(
name|delaccessflag
condition|)
name|AccessList
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|accessfile
condition|)
block|{
name|temp
operator|=
name|rplaccessor
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|temptr
operator|=
name|temp
operator|->
name|nextaccess
expr_stmt|;
if|if
condition|(
name|addnewaccess
argument_list|(
name|temp
argument_list|)
condition|)
name|temp
operator|->
name|nextaccess
operator|=
name|nil
expr_stmt|;
name|temp
operator|=
name|temptr
expr_stmt|;
block|}
block|}
name|temp
operator|=
name|rmvaccessor
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
comment|/*  remove accessors from accesslist   */
name|AccessList
operator|=
name|removeaccess
argument_list|(
name|temp
argument_list|,
name|AccessList
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|nextaccess
expr_stmt|;
block|}
name|temp
operator|=
name|newaccessor
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
comment|/*  add new accessors   */
name|temptr
operator|=
name|temp
operator|->
name|nextaccess
expr_stmt|;
if|if
condition|(
name|addnewaccess
argument_list|(
name|temp
argument_list|)
condition|)
name|temp
operator|->
name|nextaccess
operator|=
name|nil
expr_stmt|;
name|temp
operator|=
name|temptr
expr_stmt|;
block|}
name|updateassoc
argument_list|()
expr_stmt|;
comment|/*  update association list   */
name|updatelocks
argument_list|()
expr_stmt|;
comment|/*  update locks              */
comment|/*  update state attribution  */
if|if
condition|(
name|chgheadstate
condition|)
block|{
comment|/* change state of default branch or head */
if|if
condition|(
name|Dbranch
operator|==
name|nil
condition|)
block|{
if|if
condition|(
name|Head
operator|==
name|nil
condition|)
name|warn
argument_list|(
literal|"Can't change states in an empty tree"
argument_list|)
expr_stmt|;
else|else
name|Head
operator|->
name|state
operator|=
name|headstate
expr_stmt|;
block|}
else|else
block|{
name|rcs_setstate
argument_list|(
name|Dbranch
operator|->
name|num
argument_list|,
name|headstate
argument_list|)
expr_stmt|;
comment|/* Can't set directly */
block|}
block|}
name|curstate
operator|=
name|statelst
expr_stmt|;
while|while
condition|(
name|curstate
condition|)
block|{
name|rcs_setstate
argument_list|(
name|curstate
operator|->
name|revno
argument_list|,
name|curstate
operator|->
name|status
argument_list|)
expr_stmt|;
name|curstate
operator|=
name|curstate
operator|->
name|nextstatus
expr_stmt|;
block|}
name|cuthead
operator|=
name|cuttail
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|delrev
operator|&&
name|removerevs
argument_list|()
condition|)
block|{
comment|/*  rebuild delta tree if some deltas are deleted   */
if|if
condition|(
name|cuttail
condition|)
name|VOID
name|genrevs
argument_list|(
name|cuttail
operator|->
name|num
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|gendeltas
argument_list|)
decl_stmt|;
name|buildtree
argument_list|()
expr_stmt|;
block|}
comment|/* prepare for rewriting the RCS file */
name|newRCSfilename
operator|=
name|mktempfile
argument_list|(
name|RCSfilename
argument_list|,
name|NEWRCSFILE
argument_list|)
expr_stmt|;
name|oldumask
operator|=
name|umask
argument_list|(
literal|0222
argument_list|)
expr_stmt|;
comment|/* turn off write bits */
if|if
condition|(
operator|(
name|frewrite
operator|=
name|fopen
argument_list|(
name|newRCSfilename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|VOID
name|fclose
argument_list|(
name|finptr
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"Can't open file %s"
argument_list|,
name|newRCSfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|VOID
name|umask
argument_list|(
name|oldumask
argument_list|)
decl_stmt|;
name|putadmin
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|Head
condition|)
name|puttree
argument_list|(
name|Head
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|putdesc
argument_list|(
name|initflag
argument_list|,
name|textflag
argument_list|,
name|textfile
argument_list|,
name|quietflag
argument_list|)
expr_stmt|;
name|rewriteflag
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|Head
condition|)
block|{
if|if
condition|(
operator|!
name|delrev
condition|)
block|{
comment|/* no revision deleted */
name|fastcopy
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cuttail
condition|)
name|buildeltatext
argument_list|(
name|gendeltas
argument_list|)
expr_stmt|;
else|else
name|scanlogtext
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|,
name|empty
argument_list|)
expr_stmt|;
comment|/* copy rest of delta text nodes that are not deleted      */
block|}
block|}
name|ffclose
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
name|frewrite
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|nerror
condition|)
block|{
comment|/*  move temporary file to RCS file if no error */
name|ignoreints
argument_list|()
expr_stmt|;
comment|/* ignore interrupts */
if|if
condition|(
name|rename
argument_list|(
name|newRCSfilename
argument_list|,
name|RCSfilename
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't create RCS file %s; saved in %s"
argument_list|,
name|RCSfilename
argument_list|,
name|newRCSfilename
argument_list|)
expr_stmt|;
name|newRCSfilename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*  avoid deletion by cleanup  */
name|restoreints
argument_list|()
expr_stmt|;
name|VOID
name|cleanup
parameter_list|()
function_decl|;
break|break;
block|}
name|newRCSfilename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* avoid re-unlinking by cleanup()*/
comment|/* update mode */
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|initflag
condition|)
comment|/* preserve mode bits */
name|result
operator|=
name|chmod
argument_list|(
name|RCSfilename
argument_list|,
name|RCSstat
operator|.
name|st_mode
operator|&
operator|~
literal|0222
argument_list|)
expr_stmt|;
name|elsif
argument_list|(
argument|haveworkstat==
literal|0
argument_list|)
comment|/* initialization, and work file exists */
name|result
operator|=
name|chmod
argument_list|(
name|RCSfilename
argument_list|,
name|workstat
operator|.
name|st_mode
operator|&
operator|~
literal|0222
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"Can't set mode of %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
name|restoreints
argument_list|()
expr_stmt|;
comment|/* catch them all again */
name|diagnose
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diagnose
argument_list|(
literal|"%s aborted; %s unchanged."
argument_list|,
name|cmdid
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
name|nerror
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of main (rcs) */
end_comment

begin_macro
name|getassoclst
argument_list|(
argument|flag
argument_list|,
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Function:   associate a symbolic name to a revision or branch,      */
end_comment

begin_comment
comment|/*              and store in assoclst                                   */
end_comment

begin_block
block|{
name|struct
name|Symrev
modifier|*
name|pt
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temp2
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|temp
operator|=
name|sp
expr_stmt|;
name|temp2
operator|=
name|checkid
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/*  check for invalid symbolic name  */
name|sp
operator|=
name|temp2
expr_stmt|;
name|c
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|':'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"Invalid string %s after option -n or -N"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|pt
operator|=
operator|(
expr|struct
name|Symrev
operator|*
operator|)
name|talloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Symrev
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|->
name|ssymbol
operator|=
name|temp
expr_stmt|;
name|pt
operator|->
name|override
operator|=
name|flag
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
comment|/*  delete symbol  */
name|pt
operator|->
name|revno
operator|=
name|nil
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|pt
operator|->
name|revno
operator|=
name|nil
expr_stmt|;
else|else
name|pt
operator|->
name|revno
operator|=
name|sp
expr_stmt|;
block|}
name|pt
operator|->
name|nextsym
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|lastassoc
condition|)
name|lastassoc
operator|->
name|nextsym
operator|=
name|pt
expr_stmt|;
else|else
name|assoclst
operator|=
name|pt
expr_stmt|;
name|lastassoc
operator|=
name|pt
expr_stmt|;
return|return;
block|}
end_block

begin_function
name|struct
name|access
modifier|*
name|getaccessor
parameter_list|(
name|sp
parameter_list|)
name|char
modifier|*
name|sp
decl_stmt|;
comment|/*   Function:  get the accessor list of options -e and -a,     */
comment|/*              and store in curpt                              */
block|{
name|struct
name|access
modifier|*
name|curpt
decl_stmt|,
modifier|*
name|pt
decl_stmt|,
modifier|*
name|pre
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|','
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"Missing login name after option -a or -e"
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
name|curpt
operator|=
name|pt
operator|=
name|nil
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|temp
operator|=
name|checkid
argument_list|(
name|sp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pt
operator|=
operator|(
expr|struct
name|access
operator|*
operator|)
name|talloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|access
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|->
name|login
operator|=
name|sp
expr_stmt|;
if|if
condition|(
name|curpt
condition|)
name|pre
operator|->
name|nextaccess
operator|=
name|pt
expr_stmt|;
else|else
name|curpt
operator|=
name|pt
expr_stmt|;
name|pt
operator|->
name|nextaccess
operator|=
name|curpt
expr_stmt|;
name|pre
operator|=
name|pt
expr_stmt|;
name|sp
operator|=
name|temp
expr_stmt|;
name|c
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|','
condition|)
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
expr_stmt|;
block|}
return|return
name|pt
return|;
block|}
end_function

begin_macro
name|getstates
argument_list|(
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   Function:  get one state attribute and the corresponding   */
end_comment

begin_comment
comment|/*              revision and store in statelst                  */
end_comment

begin_block
block|{
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temp2
decl_stmt|;
name|struct
name|Status
modifier|*
name|pt
decl_stmt|;
specifier|register
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|temp
operator|=
name|sp
expr_stmt|;
name|temp2
operator|=
name|checkid
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/* check for invalid state attribute */
name|sp
operator|=
name|temp2
expr_stmt|;
name|c
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/*  change state of def. branch or Head  */
name|chgheadstate
operator|=
name|true
expr_stmt|;
name|headstate
operator|=
name|temp
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
block|{
name|error
argument_list|(
literal|"Missing ':' after state in option -s"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|pt
operator|=
operator|(
expr|struct
name|Status
operator|*
operator|)
name|talloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Status
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|->
name|status
operator|=
name|temp
expr_stmt|;
name|pt
operator|->
name|revno
operator|=
name|sp
expr_stmt|;
name|pt
operator|->
name|nextstatus
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|laststate
condition|)
name|laststate
operator|->
name|nextstatus
operator|=
name|pt
expr_stmt|;
else|else
name|statelst
operator|=
name|pt
expr_stmt|;
name|laststate
operator|=
name|pt
expr_stmt|;
block|}
end_block

begin_macro
name|getrplaccess
argument_list|()
end_macro

begin_comment
comment|/*   Function : get the accesslist of the 'accessfile'  */
end_comment

begin_comment
comment|/*              and place in rplaccessor                */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|nextp
decl_stmt|;
name|struct
name|access
modifier|*
name|newaccess
decl_stmt|,
modifier|*
name|oldaccess
decl_stmt|;
if|if
condition|(
operator|(
name|finptr
operator|=
name|fopen
argument_list|(
name|accessfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|faterror
argument_list|(
literal|"Can't open file %s"
argument_list|,
name|accessfile
argument_list|)
expr_stmt|;
block|}
name|Lexinit
argument_list|()
expr_stmt|;
name|nextp
operator|=
operator|&
name|accessorlst
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Khead
argument_list|)
condition|)
name|faterror
argument_list|(
literal|"Missing head in %s"
argument_list|,
name|accessfile
argument_list|)
expr_stmt|;
name|VOID
name|getnum
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after head in %s"
argument_list|,
name|accessfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|getkey
argument_list|(
name|Kbranch
argument_list|)
condition|)
block|{
comment|/* optional */
name|Dbranch
operator|=
name|getnum
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after branch list"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COMPAT2
comment|/* read suffix. Only in release 2 format */
if|if
condition|(
name|getkey
argument_list|(
name|Ksuffix
argument_list|)
condition|)
block|{
if|if
condition|(
name|nexttok
operator|==
name|STRING
condition|)
block|{
name|readstring
argument_list|()
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
comment|/*through away the suffix*/
block|}
name|elsif
argument_list|(
argument|nexttok==ID
argument_list|)
block|{
name|nextlex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after suffix in %s"
argument_list|,
name|accessfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Kaccess
argument_list|)
condition|)
name|fatserror
argument_list|(
literal|"Missing access list in %s"
argument_list|,
name|accessfile
argument_list|)
expr_stmt|;
name|oldaccess
operator|=
name|nil
expr_stmt|;
while|while
condition|(
name|id
operator|=
name|getid
argument_list|()
condition|)
block|{
name|newaccess
operator|=
operator|(
expr|struct
name|access
operator|*
operator|)
name|talloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|access
argument_list|)
argument_list|)
expr_stmt|;
name|newaccess
operator|->
name|login
operator|=
name|nextp
expr_stmt|;
name|newaccess
operator|->
name|nextaccess
operator|=
name|nil
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|nextp
operator|++
operator|=
operator|*
name|id
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
name|oldaccess
condition|)
name|oldaccess
operator|->
name|nextaccess
operator|=
name|newaccess
expr_stmt|;
else|else
name|rplaccessor
operator|=
name|newaccess
expr_stmt|;
name|oldaccess
operator|=
name|newaccess
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|serror
argument_list|(
literal|"Missing ';' after access list in %s"
argument_list|,
name|accessfile
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|getdelrev
argument_list|(
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   Function:  get revision range or branch to be deleted,     */
end_comment

begin_comment
comment|/*              and place in delrev                             */
end_comment

begin_block
block|{
name|int
name|c
decl_stmt|;
name|struct
name|delrevpair
modifier|*
name|pt
decl_stmt|;
if|if
condition|(
name|delrev
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|delrev
argument_list|)
expr_stmt|;
name|pt
operator|=
operator|(
expr|struct
name|delrevpair
operator|*
operator|)
name|talloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|delrevpair
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
comment|/*  -o  -rev  or<rev  */
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
name|pt
operator|->
name|strt
operator|=
name|sp
expr_stmt|;
name|pt
operator|->
name|code
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
name|pt
operator|->
name|end
operator|=
name|nil
expr_stmt|;
name|delrev
operator|=
name|pt
expr_stmt|;
return|return;
block|}
else|else
block|{
name|pt
operator|->
name|strt
operator|=
name|sp
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|'<'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/*   -o rev or branch   */
name|pt
operator|->
name|end
operator|=
name|nil
expr_stmt|;
name|pt
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|delrev
operator|=
name|pt
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|'<'
condition|)
block|{
name|faterror
argument_list|(
literal|"Invalid range %s %s after -o"
argument_list|,
name|pt
operator|->
name|strt
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/*  -o   rev-   or   rev<   */
name|pt
operator|->
name|end
operator|=
name|nil
expr_stmt|;
name|pt
operator|->
name|code
operator|=
literal|2
expr_stmt|;
name|delrev
operator|=
name|pt
expr_stmt|;
return|return;
block|}
block|}
comment|/*   -o   rev1-rev2    or   rev1<rev2   */
name|pt
operator|->
name|end
operator|=
name|sp
expr_stmt|;
name|pt
operator|->
name|code
operator|=
literal|3
expr_stmt|;
name|delrev
operator|=
name|pt
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_macro
name|scanlogtext
argument_list|(
argument|delta
argument_list|,
argument|func
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|stringwork
name|func
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Scans delta text nodes up to and including the one given  * by delta, or up to last one present, if delta==nil.  * For the one given by delta (if delta!=nil), the log message is saved into  * curlogmsg and the text is processed according to parameter func.  * Assumes the initial lexeme must be read in first.  * Does not advance nexttok after it is finished, except if delta==nil.  */
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|nextdelta
decl_stmt|;
do|do
block|{
name|rewriteflag
operator|=
name|false
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nextdelta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|delta
condition|)
name|faterror
argument_list|(
literal|"Can't find delta for revision %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
else|else
return|return;
comment|/* no more delta text nodes */
block|}
if|if
condition|(
name|nextdelta
operator|->
name|selector
operator|!=
name|DELETE
condition|)
block|{
name|rewriteflag
operator|=
name|true
expr_stmt|;
name|VOID
name|fprintf
parameter_list|(
name|frewrite
parameter_list|,
name|DELNUMFORM
parameter_list|,
name|nextdelta
operator|->
name|num
parameter_list|,
name|Klog
parameter_list|)
function_decl|;
block|}
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Klog
argument_list|)
operator|||
name|nexttok
operator|!=
name|STRING
condition|)
name|serror
argument_list|(
literal|"Missing log entry"
argument_list|)
expr_stmt|;
name|elsif
argument_list|(
argument|delta==nextdelta
argument_list|)
block|{
name|VOID
name|savestring
parameter_list|(
name|curlogmsg
parameter_list|,
name|logsize
parameter_list|)
function_decl|;
name|delta
operator|->
name|log
operator|=
name|curlogmsg
expr_stmt|;
block|}
else|else
block|{
name|readstring
argument_list|()
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
name|nil
condition|)
name|delta
operator|->
name|log
operator|=
literal|""
expr_stmt|;
block|}
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getkey
argument_list|(
name|Ktext
argument_list|)
operator|||
name|nexttok
operator|!=
name|STRING
condition|)
name|fatserror
argument_list|(
literal|"Missing delta text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
name|nextdelta
condition|)
comment|/* got the one we're looking for */
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|copy
case|:
name|copystring
argument_list|()
expr_stmt|;
break|break;
case|case
name|edit
case|:
name|editstring
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
break|break;
default|default:
name|faterror
argument_list|(
literal|"Wrong scanlogtext"
argument_list|)
expr_stmt|;
block|}
else|else
name|readstring
argument_list|()
expr_stmt|;
comment|/* skip over it */
block|}
do|while
condition|(
name|delta
operator|!=
name|nextdelta
condition|)
do|;
block|}
end_block

begin_macro
name|releaselst
argument_list|(
argument|sourcelst
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|access
modifier|*
name|sourcelst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   Function:  release the storages whose address are in sourcelst   */
end_comment

begin_block
block|{
name|struct
name|access
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|sourcelst
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
name|struct
name|access
modifier|*
name|pn
init|=
name|pt
operator|->
name|nextaccess
decl_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pn
expr_stmt|;
block|}
block|}
end_block

begin_function
name|struct
name|Lockrev
modifier|*
name|rmnewlocklst
parameter_list|(
name|which
parameter_list|)
name|struct
name|Lockrev
modifier|*
name|which
decl_stmt|;
comment|/*   Function:  remove lock to revision which->revno from newlocklst   */
block|{
name|struct
name|Lockrev
modifier|*
name|pt
decl_stmt|,
modifier|*
name|pre
decl_stmt|;
while|while
condition|(
name|newlocklst
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|newlocklst
operator|->
name|revno
argument_list|,
name|which
operator|->
name|revno
argument_list|)
operator|)
condition|)
block|{
name|struct
name|Lockrev
modifier|*
name|pn
init|=
name|newlocklst
operator|->
name|nextrev
decl_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newlocklst
argument_list|)
expr_stmt|;
name|newlocklst
operator|=
name|pn
expr_stmt|;
block|}
name|pt
operator|=
name|pre
operator|=
name|newlocklst
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pt
operator|->
name|revno
argument_list|,
name|which
operator|->
name|revno
argument_list|)
condition|)
block|{
name|pre
operator|->
name|nextrev
operator|=
name|pt
operator|->
name|nextrev
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pre
operator|->
name|nextrev
expr_stmt|;
block|}
else|else
block|{
name|pre
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|nextrev
expr_stmt|;
block|}
block|}
return|return
name|pre
return|;
block|}
end_function

begin_function
name|struct
name|access
modifier|*
name|removeaccess
parameter_list|(
name|who
parameter_list|,
name|sourcelst
parameter_list|,
name|flag
parameter_list|)
name|struct
name|access
modifier|*
name|who
decl_stmt|,
decl|*
name|sourcelst
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   Function:  remove the accessor-- who from sourcelst     */
end_comment

begin_block
block|{
name|struct
name|access
modifier|*
name|pt
decl_stmt|,
modifier|*
name|pre
decl_stmt|;
name|pt
operator|=
name|sourcelst
expr_stmt|;
while|while
condition|(
name|pt
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|who
operator|->
name|login
argument_list|,
name|pt
operator|->
name|login
argument_list|)
operator|)
condition|)
block|{
name|pre
operator|=
name|pt
operator|->
name|nextaccess
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pre
expr_stmt|;
name|flag
operator|=
name|false
expr_stmt|;
block|}
name|pre
operator|=
name|sourcelst
operator|=
name|pt
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|who
operator|->
name|login
argument_list|,
name|pt
operator|->
name|login
argument_list|)
condition|)
block|{
name|pre
operator|->
name|nextaccess
operator|=
name|pt
operator|->
name|nextaccess
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pre
operator|->
name|nextaccess
expr_stmt|;
name|flag
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|pre
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|nextaccess
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag
condition|)
name|warn
argument_list|(
literal|"Can't remove a nonexisting accessor %s"
argument_list|,
name|who
operator|->
name|login
argument_list|)
expr_stmt|;
return|return
name|sourcelst
return|;
block|}
end_block

begin_function
name|int
name|addnewaccess
parameter_list|(
name|who
parameter_list|)
name|struct
name|access
modifier|*
name|who
decl_stmt|;
comment|/*   Function:  add new accessor-- who into AccessList    */
block|{
name|struct
name|access
modifier|*
name|pt
decl_stmt|,
modifier|*
name|pre
decl_stmt|;
name|pre
operator|=
name|pt
operator|=
name|AccessList
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|who
operator|->
name|login
argument_list|,
name|pt
operator|->
name|login
argument_list|)
condition|)
block|{
name|pre
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|nextaccess
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pre
operator|==
name|pt
condition|)
name|AccessList
operator|=
name|who
expr_stmt|;
else|else
name|pre
operator|->
name|nextaccess
operator|=
name|who
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|sendmail
argument_list|(
argument|Delta
argument_list|,
argument|who
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|Delta
decl_stmt|,
modifier|*
name|who
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   Function:  mail to who, informing him that his lock on delta was  *   broken by caller. Ask first whether to go ahead. Return false on  *   error or if user decides not to break the lock.  */
end_comment

begin_block
block|{
name|char
modifier|*
name|messagefile
decl_stmt|;
name|int
name|old1
decl_stmt|,
name|old2
decl_stmt|,
name|c
decl_stmt|,
name|response
decl_stmt|;
name|FILE
modifier|*
name|mailmess
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Revision %s is already locked by %s.\n"
argument_list|,
name|Delta
argument_list|,
name|who
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Do you want to break the lock? [ny](n): "
argument_list|)
decl_stmt|;
name|response
operator|=
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip to end of line*/
if|if
condition|(
name|response
operator|==
literal|'\n'
operator|||
name|response
operator|==
literal|'n'
operator|||
name|response
operator|==
literal|'N'
condition|)
return|return
name|false
return|;
comment|/* go ahead with breaking  */
name|messagefile
operator|=
name|mktempfile
argument_list|(
literal|"/tmp/"
argument_list|,
literal|"RCSmailXXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mailmess
operator|=
name|fopen
argument_list|(
name|messagefile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|faterror
argument_list|(
literal|"Can't open file %s"
argument_list|,
name|messagefile
argument_list|)
expr_stmt|;
block|}
name|VOID
name|fprintf
argument_list|(
name|mailmess
argument_list|,
literal|"Subject: Broken lock on %s\n\n"
argument_list|,
name|bindex
argument_list|(
name|RCSfilename
argument_list|,
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|mailmess
argument_list|,
literal|"Your lock on revision %s of file %s\n"
argument_list|,
name|Delta
argument_list|,
name|getfullRCSname
argument_list|()
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|mailmess
argument_list|,
literal|"has been broken by %s for the following reason:\n"
argument_list|,
name|caller
argument_list|)
decl_stmt|;
name|VOID
name|fputs
argument_list|(
literal|"State the reason for breaking the lock:\n"
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
name|VOID
name|fputs
argument_list|(
literal|"(terminate with ^D or single '.')\n>> "
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
name|old1
operator|=
literal|'\n'
expr_stmt|;
name|old2
operator|=
literal|' '
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|mailmess
argument_list|,
literal|"%c\n"
argument_list|,
name|old1
argument_list|)
decl_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|old1
operator|==
literal|'.'
operator|&&
name|old2
operator|==
literal|'\n'
condition|)
break|break;
else|else
block|{
name|VOID
name|fputc
parameter_list|(
name|old1
parameter_list|,
name|mailmess
parameter_list|)
function_decl|;
name|old2
operator|=
name|old1
expr_stmt|;
name|old1
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|VOID
name|fputs
argument_list|(
literal|">> "
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
block|}
block|}
name|ffclose
argument_list|(
name|mailmess
argument_list|)
expr_stmt|;
comment|/* ignore the exit status, even if delivermail unsuccessful */
name|VOID
name|run
argument_list|(
name|messagefile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|_PATH_SENDMAIL
argument_list|,
name|who
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|)
decl_stmt|;
name|VOID
name|unlink
parameter_list|(
name|messagefile
parameter_list|)
function_decl|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|breaklock
argument_list|(
argument|who
argument_list|,
argument|delta
argument_list|)
name|char
operator|*
name|who
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function: Finds the lock held by who on delta,  * and removes it.  * Sends mail if a lock different from the caller's is broken.  * Prints an error message if there is no such lock or error.  */
end_comment

begin_block
block|{
specifier|register
name|struct
name|lock
modifier|*
name|next
decl_stmt|,
modifier|*
name|trail
decl_stmt|;
name|char
modifier|*
name|num
decl_stmt|;
name|struct
name|lock
name|dummy
decl_stmt|;
name|int
name|whor
decl_stmt|,
name|numr
decl_stmt|;
name|num
operator|=
name|delta
operator|->
name|num
expr_stmt|;
name|dummy
operator|.
name|nextlock
operator|=
name|next
operator|=
name|Locks
expr_stmt|;
name|trail
operator|=
operator|&
name|dummy
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|num
operator|!=
name|nil
condition|)
name|numr
operator|=
name|strcmp
argument_list|(
name|num
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|whor
operator|=
name|strcmp
argument_list|(
name|who
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
if|if
condition|(
name|whor
operator|==
literal|0
operator|&&
name|numr
operator|==
literal|0
condition|)
break|break;
comment|/* exact match */
if|if
condition|(
name|numr
operator|==
literal|0
operator|&&
name|whor
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|sendmail
argument_list|(
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
condition|)
block|{
name|diagnose
argument_list|(
literal|"%s still locked by %s"
argument_list|,
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
comment|/* continue after loop */
block|}
name|trail
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
comment|/*found one */
name|diagnose
argument_list|(
literal|"%s unlocked"
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|trail
operator|->
name|nextlock
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
name|next
operator|->
name|delta
operator|->
name|lockedby
operator|=
name|nil
expr_stmt|;
name|Locks
operator|=
name|dummy
operator|.
name|nextlock
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"no lock set on revision %s"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|struct
name|hshentry
modifier|*
name|searchcutpt
parameter_list|(
name|object
parameter_list|,
name|length
parameter_list|,
name|store
parameter_list|)
name|char
modifier|*
name|object
decl_stmt|;
name|int
name|length
decl_stmt|;
name|struct
name|hshentry
modifier|*
modifier|*
name|store
decl_stmt|;
comment|/*   Function:  Search store and return entry with number being object. */
comment|/*              cuttail = nil, if the entry is Head; otherwise, cuttail */
comment|/*              is the entry point to the one with number being object  */
block|{
while|while
condition|(
name|compartial
argument_list|(
operator|(
operator|*
name|store
operator|++
operator|)
operator|->
name|num
argument_list|,
name|object
argument_list|,
name|length
argument_list|)
condition|)
empty_stmt|;
name|store
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|store
operator|==
name|Head
condition|)
name|cuthead
operator|=
name|nil
expr_stmt|;
else|else
name|cuthead
operator|=
operator|*
operator|(
name|store
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|*
name|store
return|;
block|}
end_function

begin_function
name|int
name|branchpoint
parameter_list|(
name|strt
parameter_list|,
name|tail
parameter_list|)
name|struct
name|hshentry
modifier|*
name|strt
decl_stmt|,
decl|*
name|tail
decl_stmt|;
end_function

begin_comment
comment|/*   Function: check whether the deltas between strt and tail	*/
end_comment

begin_comment
comment|/*		are locked or branch point, return 1 if any is  */
end_comment

begin_comment
comment|/*		locked or branch point; otherwise, return 0 and */
end_comment

begin_comment
comment|/*              mark DELETE on selector                         */
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|pt
decl_stmt|;
name|struct
name|lock
modifier|*
name|lockpt
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|pt
operator|=
name|strt
expr_stmt|;
name|flag
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|pt
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|branches
condition|)
block|{
comment|/*  a branch point  */
name|flag
operator|=
name|true
expr_stmt|;
name|error
argument_list|(
literal|"Can't remove branch point %s"
argument_list|,
name|pt
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|lockpt
operator|=
name|Locks
expr_stmt|;
while|while
condition|(
name|lockpt
operator|&&
name|lockpt
operator|->
name|delta
operator|!=
name|pt
condition|)
name|lockpt
operator|=
name|lockpt
operator|->
name|nextlock
expr_stmt|;
if|if
condition|(
name|lockpt
condition|)
block|{
name|flag
operator|=
name|true
expr_stmt|;
name|error
argument_list|(
literal|"Can't remove locked revision %s"
argument_list|,
name|pt
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|pt
operator|=
name|pt
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag
condition|)
block|{
name|pt
operator|=
name|strt
expr_stmt|;
while|while
condition|(
name|pt
operator|!=
name|tail
condition|)
block|{
name|pt
operator|->
name|selector
operator|=
name|DELETE
expr_stmt|;
name|diagnose
argument_list|(
literal|"deleting revision %s "
argument_list|,
name|pt
operator|->
name|num
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|flag
return|;
block|}
end_block

begin_macro
name|removerevs
argument_list|()
end_macro

begin_comment
comment|/*   Function:  get the revision range to be removed, and place the     */
end_comment

begin_comment
comment|/*              first revision removed in delstrt, the revision before  */
end_comment

begin_comment
comment|/*              delstrt in cuthead( nil, if delstrt is head), and the   */
end_comment

begin_comment
comment|/*              revision after the last removed revision in cuttail(nil */
end_comment

begin_comment
comment|/*              if the last is a leaf                                   */
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|,
modifier|*
name|target2
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
modifier|*
name|searchcutpt
argument_list|()
decl_stmt|;
name|int
name|length
decl_stmt|,
name|flag
decl_stmt|;
name|flag
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|delrev
operator|->
name|strt
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|target
operator|=
name|genrevs
argument_list|(
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
condition|)
name|flag
operator|=
name|true
expr_stmt|;
name|length
operator|=
name|countnumflds
argument_list|(
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|delrev
operator|->
name|code
operator|==
literal|0
condition|)
block|{
comment|/*  -o  rev    or    -o  branch   */
if|if
condition|(
name|length
operator|%
literal|2
condition|)
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
operator|+
literal|1
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
condition|)
block|{
name|error
argument_list|(
literal|"Revision %s does not exist"
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|temp
operator|=
name|searchcutpt
argument_list|(
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
name|nil
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
comment|/* first revision to be removed   */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|length
operator|%
literal|2
condition|)
block|{
comment|/*  invalid branch after -o   */
name|error
argument_list|(
literal|"Invalid branch range %s after -o"
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|delrev
operator|->
name|code
operator|==
literal|1
condition|)
block|{
comment|/*  -o  -rev   */
if|if
condition|(
name|length
operator|>
literal|2
condition|)
block|{
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
operator|-
literal|1
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target
expr_stmt|;
while|while
condition|(
name|cuttail
operator|&&
operator|!
name|cmpnumfld
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|cuttail
operator|->
name|num
argument_list|,
literal|1
argument_list|)
condition|)
name|cuttail
operator|=
name|cuttail
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
name|nil
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|delrev
operator|->
name|code
operator|==
literal|2
condition|)
block|{
comment|/*  -o  rev-   */
if|if
condition|(
name|length
operator|==
literal|2
condition|)
block|{
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
literal|1
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|cuttail
operator|=
name|target
expr_stmt|;
else|else
name|cuttail
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flag
condition|)
block|{
name|cuthead
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|temp
operator|=
name|target
operator|->
name|next
operator|)
condition|)
return|return
literal|0
return|;
block|}
else|else
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|getbranchno
argument_list|(
name|temp
operator|->
name|num
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/*  get branch number  */
name|target
operator|=
name|genrevs
argument_list|(
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
name|nil
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*   -o   rev1-rev2   */
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|delrev
operator|->
name|end
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|length
operator|!=
name|countnumflds
argument_list|(
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Invalid revision range %s-%s"
argument_list|,
name|target
operator|->
name|num
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|length
operator|>
literal|2
operator|&&
name|compartial
argument_list|(
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|,
name|target
operator|->
name|num
argument_list|,
name|length
operator|-
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Invalid revision range %s-%s"
argument_list|,
name|target
operator|->
name|num
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|target2
operator|=
name|genrevs
argument_list|(
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target2
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|length
operator|>
literal|2
condition|)
block|{
comment|/* delete revisions on branches  */
if|if
condition|(
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cmpnum
argument_list|(
name|target2
operator|->
name|num
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
condition|)
name|flag
operator|=
name|true
expr_stmt|;
else|else
name|flag
operator|=
name|false
expr_stmt|;
name|temp
operator|=
name|target
expr_stmt|;
name|target
operator|=
name|target2
expr_stmt|;
name|target2
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
operator|!
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Revisions %s-%s don't exist"
argument_list|,
name|delrev
operator|->
name|strt
argument_list|,
name|delrev
operator|->
name|end
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cuthead
operator|=
name|target
expr_stmt|;
name|temp
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target2
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/*  delete revisions on trunk  */
if|if
condition|(
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
name|target
expr_stmt|;
name|target
operator|=
name|target2
expr_stmt|;
name|target2
operator|=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmpnum
argument_list|(
name|target2
operator|->
name|num
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
condition|)
name|flag
operator|=
name|true
expr_stmt|;
else|else
name|flag
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
operator|!
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Revisions %s-%s don't exist"
argument_list|,
name|delrev
operator|->
name|strt
argument_list|,
name|delrev
operator|->
name|end
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cuttail
operator|=
name|target2
expr_stmt|;
block|}
else|else
name|cuttail
operator|=
name|target2
operator|->
name|next
expr_stmt|;
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
name|nil
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_macro
name|updateassoc
argument_list|()
end_macro

begin_comment
comment|/*   Function: add or delete(if revno is nil) association	*/
end_comment

begin_comment
comment|/*		which is stored in assoclst			*/
end_comment

begin_block
block|{
name|struct
name|Symrev
modifier|*
name|curassoc
decl_stmt|;
name|struct
name|assoc
modifier|*
name|pre
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
comment|/*  add new associations   */
name|curassoc
operator|=
name|assoclst
expr_stmt|;
while|while
condition|(
name|curassoc
condition|)
block|{
if|if
condition|(
name|curassoc
operator|->
name|revno
operator|==
name|nil
condition|)
block|{
comment|/* delete symbol  */
name|pre
operator|=
name|pt
operator|=
name|Symbols
expr_stmt|;
while|while
condition|(
name|pt
operator|&&
name|strcmp
argument_list|(
name|pt
operator|->
name|symbol
argument_list|,
name|curassoc
operator|->
name|ssymbol
argument_list|)
condition|)
block|{
name|pre
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|nextassoc
expr_stmt|;
block|}
if|if
condition|(
name|pt
condition|)
if|if
condition|(
name|pre
operator|==
name|pt
condition|)
name|Symbols
operator|=
name|pt
operator|->
name|nextassoc
expr_stmt|;
else|else
name|pre
operator|->
name|nextassoc
operator|=
name|pt
operator|->
name|nextassoc
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"Can't delete nonexisting symbol %s"
argument_list|,
name|curassoc
operator|->
name|ssymbol
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expandsym
argument_list|(
name|curassoc
operator|->
name|revno
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/*   add symbol  */
name|target
operator|=
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|talloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hshentry
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|->
name|num
operator|=
operator|&
name|numrev
index|[
literal|0
index|]
expr_stmt|;
name|VOID
name|addsymbol
parameter_list|(
name|target
parameter_list|,
name|curassoc
operator|->
name|ssymbol
parameter_list|,
name|curassoc
operator|->
name|override
parameter_list|)
function_decl|;
block|}
name|curassoc
operator|=
name|curassoc
operator|->
name|nextsym
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|updatelocks
argument_list|()
end_macro

begin_comment
comment|/* Function: remove lock for caller or first lock if unlockcaller==true;  *           remove locks which are stored in rmvlocklst,  *           add new locks which are stored in newlocklst,  *           add lock for Dbranch or Head if lockhead==true.  */
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|struct
name|Lockrev
modifier|*
name|lockpt
decl_stmt|;
if|if
condition|(
name|unlockcaller
operator|==
name|true
condition|)
block|{
comment|/*  find lock for caller  */
if|if
condition|(
name|Head
condition|)
block|{
if|if
condition|(
name|Locks
condition|)
block|{
name|target
operator|=
name|findlock
argument_list|(
name|caller
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|nil
condition|)
block|{
name|breaklock
argument_list|(
name|caller
argument_list|,
name|Locks
operator|->
name|delta
argument_list|)
expr_stmt|;
comment|/* remove most recent lock */
block|}
else|else
block|{
name|diagnose
argument_list|(
literal|"%s unlocked"
argument_list|,
name|target
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|warn
argument_list|(
literal|"There are no locks set."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|warn
argument_list|(
literal|"Can't unlock an empty tree"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  remove locks which are stored in rmvlocklst   */
name|lockpt
operator|=
name|rmvlocklst
expr_stmt|;
while|while
condition|(
name|lockpt
condition|)
block|{
if|if
condition|(
name|expandsym
argument_list|(
name|lockpt
operator|->
name|revno
argument_list|,
name|numrev
argument_list|)
condition|)
block|{
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
if|if
condition|(
operator|!
operator|(
name|countnumflds
argument_list|(
name|numrev
argument_list|)
operator|%
literal|2
operator|)
operator|&&
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|numrev
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't unlock nonexisting revision %s"
argument_list|,
name|lockpt
operator|->
name|revno
argument_list|)
expr_stmt|;
else|else
name|breaklock
argument_list|(
name|caller
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* breaklock does its own diagnose */
block|}
name|lockpt
operator|=
name|lockpt
operator|->
name|nextrev
expr_stmt|;
block|}
comment|/*  add new locks which stored in newlocklst  */
name|lockpt
operator|=
name|newlocklst
expr_stmt|;
while|while
condition|(
name|lockpt
condition|)
block|{
name|setlock
argument_list|(
name|lockpt
operator|->
name|revno
argument_list|,
name|caller
argument_list|)
expr_stmt|;
name|lockpt
operator|=
name|lockpt
operator|->
name|nextrev
expr_stmt|;
block|}
if|if
condition|(
name|lockhead
operator|==
name|true
condition|)
block|{
comment|/*  lock default branch or head  */
if|if
condition|(
name|Dbranch
condition|)
block|{
name|setlock
argument_list|(
name|Dbranch
operator|->
name|num
argument_list|,
name|caller
argument_list|)
expr_stmt|;
block|}
name|elsif
argument_list|(
argument|Head
argument_list|)
block|{
if|if
condition|(
name|addlock
argument_list|(
name|Head
argument_list|,
name|caller
argument_list|)
condition|)
name|diagnose
argument_list|(
literal|"%s locked"
argument_list|,
name|Head
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warn
argument_list|(
literal|"Can't lock an empty tree"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|setlock
argument_list|(
argument|rev
argument_list|,
argument|who
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|rev
decl_stmt|,
modifier|*
name|who
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Given a revision or branch number, finds the correponding  * delta and locks it for who.  */
end_comment

begin_block
block|{
name|struct
name|lock
modifier|*
name|lpt
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|expandsym
argument_list|(
name|rev
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|target
operator|=
name|genrevs
argument_list|(
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
if|if
condition|(
operator|!
operator|(
name|countnumflds
argument_list|(
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
operator|%
literal|2
operator|)
operator|&&
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't lock nonexisting revision %s"
argument_list|,
name|numrev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lpt
operator|=
name|addlock
argument_list|(
name|target
argument_list|,
name|who
argument_list|)
condition|)
name|diagnose
argument_list|(
literal|"%s locked"
argument_list|,
name|lpt
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rcs_setstate
argument_list|(
argument|rev
argument_list|,
argument|status
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|rev
decl_stmt|,
modifier|*
name|status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Given a revision or branch number, finds the corresponding delta  * and sets its state to status.  */
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|expandsym
argument_list|(
name|rev
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|target
operator|=
name|genrevs
argument_list|(
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
if|if
condition|(
operator|!
operator|(
name|countnumflds
argument_list|(
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
operator|%
literal|2
operator|)
operator|&&
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
operator|&
name|numrev
index|[
literal|0
index|]
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't set state of nonexisting revision %s to %s"
argument_list|,
name|numrev
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|else
name|target
operator|->
name|state
operator|=
name|status
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|buildeltatext
argument_list|(
argument|deltas
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
modifier|*
name|deltas
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   Function:  put the delta text on frewrite and make necessary   */
end_comment

begin_comment
comment|/*              change to delta text                                */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|exit_stats
decl_stmt|;
name|cuttail
operator|->
name|selector
operator|=
name|DELETE
expr_stmt|;
name|initeditfiles
argument_list|(
literal|"/tmp/"
argument_list|)
expr_stmt|;
name|scanlogtext
argument_list|(
name|deltas
index|[
literal|0
index|]
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cuthead
condition|)
block|{
name|cutfilename
operator|=
name|mktempfile
argument_list|(
literal|"/tmp/"
argument_list|,
literal|"RCScutXXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fcut
operator|=
name|fopen
argument_list|(
name|cutfilename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|faterror
argument_list|(
literal|"Can't open temporary file %s"
argument_list|,
name|cutfilename
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|deltas
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|cuthead
condition|)
block|{
name|scanlogtext
argument_list|(
name|deltas
index|[
name|i
operator|++
index|]
argument_list|,
name|edit
argument_list|)
expr_stmt|;
block|}
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|fcopy
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fcopy
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|VOID
name|putc
parameter_list|(
name|c
parameter_list|,
name|fcut
parameter_list|)
function_decl|;
name|swapeditfiles
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|ffclose
argument_list|(
name|fcut
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|deltas
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|cuttail
condition|)
name|scanlogtext
argument_list|(
name|deltas
index|[
name|i
operator|++
index|]
argument_list|,
name|edit
argument_list|)
expr_stmt|;
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
name|ffclose
argument_list|(
name|fcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|cuthead
condition|)
block|{
name|diffilename
operator|=
name|mktempfile
argument_list|(
literal|"/tmp/"
argument_list|,
literal|"RCSdifXXXXXX"
argument_list|)
expr_stmt|;
name|exit_stats
operator|=
name|run
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|diffilename
argument_list|,
name|DIFF
argument_list|,
literal|"-n"
argument_list|,
name|cutfilename
argument_list|,
name|resultfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_stats
operator|!=
literal|0
operator|&&
name|exit_stats
operator|!=
operator|(
literal|1
operator|<<
name|BYTESIZ
operator|)
condition|)
name|faterror
argument_list|(
literal|"diff failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putdtext
argument_list|(
name|cuttail
operator|->
name|num
argument_list|,
name|curlogmsg
argument_list|,
name|diffilename
argument_list|,
name|frewrite
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|putdtext
argument_list|(
name|cuttail
operator|->
name|num
argument_list|,
name|curlogmsg
argument_list|,
name|resultfile
argument_list|,
name|frewrite
argument_list|)
condition|)
return|return;
name|scanlogtext
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|,
name|empty
argument_list|)
expr_stmt|;
comment|/* read the rest of the deltas */
block|}
end_block

begin_macro
name|buildtree
argument_list|()
end_macro

begin_comment
comment|/*   Function:  actually removes revisions whose selector field  */
end_comment

begin_comment
comment|/*              is DELETE, and rebuilds  the linkage of deltas.  */
end_comment

begin_comment
comment|/*              asks for reconfirmation if deleting last revision*/
end_comment

begin_block
block|{
name|int
name|c
decl_stmt|,
name|response
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|Delta
decl_stmt|;
name|struct
name|branchhead
modifier|*
name|pt
decl_stmt|,
modifier|*
name|pre
decl_stmt|;
if|if
condition|(
name|cuthead
condition|)
if|if
condition|(
name|cuthead
operator|->
name|next
operator|==
name|delstrt
condition|)
name|cuthead
operator|->
name|next
operator|=
name|cuttail
expr_stmt|;
else|else
block|{
name|pre
operator|=
name|pt
operator|=
name|cuthead
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|pt
operator|&&
name|pt
operator|->
name|hsh
operator|!=
name|delstrt
condition|)
block|{
name|pre
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|nextbranch
expr_stmt|;
block|}
if|if
condition|(
name|cuttail
condition|)
name|pt
operator|->
name|hsh
operator|=
name|cuttail
expr_stmt|;
elseif|else
if|if
condition|(
name|pt
operator|==
name|pre
condition|)
name|cuthead
operator|->
name|branches
operator|=
name|pt
operator|->
name|nextbranch
expr_stmt|;
else|else
name|pre
operator|->
name|nextbranch
operator|=
name|pt
operator|->
name|nextbranch
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cuttail
operator|==
name|nil
operator|&&
operator|!
name|quietflag
condition|)
block|{
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Do you really want to delete all revisions ?[ny](n): "
argument_list|)
decl_stmt|;
name|c
operator|=
name|response
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|response
operator|!=
literal|'y'
operator|&&
name|response
operator|!=
literal|'Y'
condition|)
block|{
name|diagnose
argument_list|(
literal|"No revision deleted"
argument_list|)
expr_stmt|;
name|Delta
operator|=
name|delstrt
expr_stmt|;
while|while
condition|(
name|Delta
condition|)
block|{
name|Delta
operator|->
name|selector
operator|=
literal|'S'
expr_stmt|;
name|Delta
operator|=
name|Delta
operator|->
name|next
expr_stmt|;
block|}
return|return;
block|}
block|}
name|Head
operator|=
name|cuttail
expr_stmt|;
block|}
return|return;
block|}
end_block

end_unit

