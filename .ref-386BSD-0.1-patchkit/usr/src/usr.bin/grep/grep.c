begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* grep - print lines matching an extended regular expression    Copyright (C) 1988 Free Software Foundation, Inc.                       Written June, 1988 by Mike Haertel 	              BMG speedups added July, 1988 			by James A. Woods and Arthur David Olson  		       NO WARRANTY    BECAUSE THIS PROGRAM IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY NO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC, RICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE THIS PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M. STALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY WHO MAY MODIFY AND REDISTRIBUTE THIS PROGRAM AS PERMITTED BELOW, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) THIS PROGRAM, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.  		GENERAL PUBLIC LICENSE TO COPY    1. You may copy and distribute verbatim copies of this source file as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy a valid copyright notice "Copyright  (C) 1988 Free Software Foundation, Inc."; and include following the copyright notice a verbatim copy of the above disclaimer of warranty and of this License.  You may charge a distribution fee for the physical act of transferring a copy.    2. You may modify your copy or copies of this source file or any portion of it, and copy and distribute such modifications under the terms of Paragraph 1 above, provided that you also do the following:      a) cause the modified files to carry prominent notices stating     that you changed the files and the date of any change; and      b) cause the whole of any work that you distribute or publish,     that in whole or in part contains or is a derivative of this     program or any part thereof, to be licensed at no charge to all     third parties on terms identical to those contained in this     License Agreement (except that you may choose to grant more extensive     warranty protection to some or all third parties, at your option).      c) You may charge a distribution fee for the physical act of     transferring a copy, and you may at your option offer warranty     protection in exchange for a fee.  Mere aggregation of another unrelated program with this program (or its derivative) on a volume of a storage or distribution medium does not bring the other program under the scope of these terms.    3. You may copy and distribute this program or any portion of it in compiled, executable or object code form under the terms of Paragraphs 1 and 2 above provided that you do the following:      a) accompany it with the complete corresponding machine-readable     source code, which must be distributed under the terms of     Paragraphs 1 and 2 above; or,      b) accompany it with a written offer, valid for at least three     years, to give any third party free (except for a nominal     shipping charge) a complete machine-readable copy of the     corresponding source code, to be distributed under the terms of     Paragraphs 1 and 2 above; or,      c) accompany it with the information you received as to where the     corresponding source code may be obtained.  (This alternative is     allowed only for noncommercial distribution and only if you     received the program in object code or executable form alone.)  For an executable file, complete source code means all the source code for all modules it contains; but, as a special exception, it need not include source code for modules which are standard libraries that accompany the operating system on which the executable file runs.    4. You may not copy, sublicense, distribute or transfer this program except as expressly provided under this License Agreement.  Any attempt otherwise to copy, sublicense, distribute or transfer this program is void and your rights to use the program under this License agreement shall be automatically terminated.  However, parties who have received computer software programs from you with this License Agreement will not have their licenses terminated so long as such parties remain in full compliance.    5. If you wish to incorporate parts of this program into other free programs whose distribution conditions are different, write to the Free Software Foundation at 675 Mass Ave, Cambridge, MA 02139.  We have not yet worked out a simple rule that can be stated here, but we will often permit this.  We will be guided by the two goals of preserving the free status of all derivatives our free software and of promoting the sharing and reuse of software.   In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dfa.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_comment
comment|/*extern getopt(int, char **, const char *); extern read(int, void *, int); extern open(const char *, int, ...); extern void close();*/
end_comment

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|strrchr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern optind
operator|,
extern|opterr;
end_extern

begin_extern
extern|extern errno;
end_extern

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_comment
comment|/* Exit status codes. */
end_comment

begin_define
define|#
directive|define
name|MATCHES_FOUND
value|0
end_define

begin_comment
comment|/* Exit 0 if no errors and matches found. */
end_comment

begin_define
define|#
directive|define
name|NO_MATCHES_FOUND
value|1
end_define

begin_comment
comment|/* Exit 1 if no matches were found. */
end_comment

begin_define
define|#
directive|define
name|ERROR
value|2
end_define

begin_comment
comment|/* Exit 2 if some error occurred. */
end_comment

begin_comment
comment|/* Error is set true if something awful happened. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The program name for error messages. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We do all our own buffering by hand for efficiency. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The buffer itself, grown as needed. */
end_comment

begin_expr_stmt
specifier|static
name|bufbytes
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of bytes in the buffer. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|bufalloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes allocated to the buffer. */
end_comment

begin_expr_stmt
specifier|static
name|bufprev
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of bytes that have been forgotten. 				   This is used to get byte offsets from the 				   beginning of the file. */
end_comment

begin_expr_stmt
specifier|static
name|bufread
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of bytes to get with each read(). */
end_comment

begin_function
specifier|static
name|void
name|initialize_buffer
parameter_list|()
block|{
name|bufread
operator|=
literal|8192
expr_stmt|;
name|bufalloc
operator|=
name|bufread
operator|+
name|bufread
operator|/
literal|2
expr_stmt|;
name|buffer
operator|=
name|malloc
argument_list|(
name|bufalloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Memory exhausted (%s)\n"
argument_list|,
name|prog
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The current input file. */
end_comment

begin_expr_stmt
specifier|static
name|fd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|eof
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Fill the buffer retaining the last n bytes at the beginning of the    newly filled buffer (for backward context).  Returns the number of new    bytes read from disk. */
end_comment

begin_expr_stmt
specifier|static
name|fill_buffer_retaining
argument_list|(
argument|n
argument_list|)
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* See if we need to grow the buffer. */
if|if
condition|(
name|bufalloc
operator|-
name|n
operator|<=
name|bufread
condition|)
block|{
while|while
condition|(
name|bufalloc
operator|-
name|n
operator|<=
name|bufread
condition|)
block|{
name|bufalloc
operator|*=
literal|2
expr_stmt|;
name|bufread
operator|*=
literal|2
expr_stmt|;
block|}
name|buffer
operator|=
name|realloc
argument_list|(
name|buffer
argument_list|,
name|bufalloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Memory exhausted (%s)\n"
argument_list|,
name|prog
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
block|}
name|bufprev
operator|+=
name|bufbytes
operator|-
name|n
expr_stmt|;
comment|/* Shift stuff down. */
for|for
control|(
name|i
operator|=
name|n
operator|,
name|p
operator|=
name|buffer
operator|,
name|q
operator|=
name|p
operator|+
name|bufbytes
operator|-
name|n
init|;
name|i
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
name|bufbytes
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|eof
condition|)
return|return
literal|0
return|;
comment|/* Read in new stuff. */
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
operator|+
name|bufbytes
argument_list|,
name|bufread
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read on %s failed (%s)\n"
argument_list|,
name|prog
argument_list|,
name|filename
condition|?
name|filename
else|:
literal|"<stdin>"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Kludge to pretend every nonempty file ends with a newline. */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|bufbytes
operator|>
literal|0
operator|&&
name|buffer
index|[
name|bufbytes
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|eof
operator|=
name|i
operator|=
literal|1
expr_stmt|;
name|buffer
index|[
name|bufbytes
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
name|bufbytes
operator|+=
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Various flags set according to the argument switches. */
end_comment

begin_expr_stmt
specifier|static
name|trailing_context
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Lines of context to show after matches. */
end_comment

begin_expr_stmt
specifier|static
name|leading_context
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Lines of context to show before matches. */
end_comment

begin_expr_stmt
specifier|static
name|byte_count
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Precede output lines the byte count of the 				   first character on the line. */
end_comment

begin_expr_stmt
specifier|static
name|no_filenames
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Do not display filenames. */
end_comment

begin_expr_stmt
specifier|static
name|line_numbers
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Precede output lines with line numbers. */
end_comment

begin_expr_stmt
specifier|static
name|silent
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Produce no output at all.  This switch 				   is bogus, ever hear of /dev/null? */
end_comment

begin_expr_stmt
specifier|static
name|nonmatching_lines
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Print lines that don't match the regexp. */
end_comment

begin_expr_stmt
specifier|static
name|bmgexec
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Invoke Boyer-Moore-Gosper routines */
end_comment

begin_comment
comment|/* The compiled regular expression lives here. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|regexp
name|reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The compiled regular expression for the backtracking matcher lives here. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|regex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer in the buffer after the last character printed. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|printed_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True when printed_limit has been artifically advanced without printing    anything. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|printed_limit_fake
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a line at the given line number, returning the number of    characters actually printed.  Matching is true if the line is to    be considered a "matching line".  This is only meaningful if    surrounding context is turned on. */
end_comment

begin_expr_stmt
specifier|static
name|print_line
argument_list|(
argument|p
argument_list|,
argument|number
argument_list|,
argument|matching
argument_list|)
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|matching
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|silent
condition|)
block|{
do|do
operator|++
name|count
expr_stmt|;
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
do|;
name|printed_limit_fake
operator|=
literal|0
expr_stmt|;
name|printed_limit
operator|=
name|p
expr_stmt|;
return|return
name|count
return|;
block|}
if|if
condition|(
name|filename
operator|&&
operator|!
name|no_filenames
condition|)
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|filename
argument_list|,
name|matching
condition|?
literal|':'
else|:
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_count
condition|)
name|printf
argument_list|(
literal|"%d%c"
argument_list|,
name|p
operator|-
name|buffer
operator|+
name|bufprev
argument_list|,
name|matching
condition|?
literal|':'
else|:
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_numbers
condition|)
name|printf
argument_list|(
literal|"%d%c"
argument_list|,
name|number
argument_list|,
name|matching
condition|?
literal|':'
else|:
literal|'-'
argument_list|)
expr_stmt|;
do|do
block|{
operator|++
name|count
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
do|;
name|printed_limit_fake
operator|=
literal|0
expr_stmt|;
name|printed_limit
operator|=
name|p
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_comment
comment|/* Print matching or nonmatching lines from the current file.  Returns a    count of matching or nonmatching lines. */
end_comment

begin_expr_stmt
specifier|static
name|grep
argument_list|()
block|{
name|int
name|retain
operator|=
literal|0
block|;
comment|/* Number of bytes to retain on next call 				   to fill_buffer_retaining(). */
name|char
operator|*
name|search_limit
block|;
comment|/* Pointer to the character after the last 				   newline in the buffer. */
name|char
name|saved_char
block|;
comment|/* Character after the last newline. */
name|char
operator|*
name|resume
block|;
comment|/* Pointer to where to resume search. */
name|int
name|resume_index
operator|=
literal|0
block|;
comment|/* Count of characters to ignore after 				   refilling the buffer. */
name|int
name|line_count
operator|=
literal|1
block|;
comment|/* Line number. */
name|int
name|try_backref
block|;
comment|/* Set to true if we need to verify the 				   match with a backtracking matcher. */
name|int
name|initial_line_count
block|;
comment|/* Line count at beginning of last search. */
name|char
operator|*
name|match
block|;
comment|/* Pointer to the first character after the 				   string matching the regexp. */
name|int
name|match_count
operator|=
literal|0
block|;
comment|/* Count of matching lines. */
name|char
operator|*
name|matching_line
block|;
comment|/* Pointer to first character of the matching 				   line, or of the first line of context to 				   print if context is turned on. */
name|char
operator|*
name|real_matching_line
block|;
comment|/* Pointer to the first character of the 				   real matching line. */
name|char
operator|*
name|next_line
block|;
comment|/* Pointer to first character of the line 				   following the matching line. */
name|int
name|pending_lines
operator|=
literal|0
block|;
comment|/* Lines of context left over from last match 				   that we have to print. */
specifier|static
name|first_match
operator|=
literal|1
block|;
comment|/* True when nothing has been printed. */
name|int
name|i
block|;
name|char
operator|*
name|tmp
block|;
name|char
operator|*
name|execute
argument_list|()
block|;
name|printed_limit_fake
operator|=
literal|0
block|;
while|while
condition|(
name|fill_buffer_retaining
argument_list|(
name|retain
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Find the last newline in the buffer. */
name|search_limit
operator|=
name|buffer
operator|+
name|bufbytes
expr_stmt|;
while|while
condition|(
name|search_limit
operator|>
name|buffer
operator|&&
name|search_limit
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|--
name|search_limit
expr_stmt|;
if|if
condition|(
name|search_limit
operator|==
name|buffer
condition|)
block|{
name|retain
operator|=
name|bufbytes
expr_stmt|;
continue|continue;
block|}
comment|/* Save the character after the last newline so regexecute can write 	 its own sentinel newline. */
name|saved_char
operator|=
operator|*
name|search_limit
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Search the buffer for a match. */
end_comment

begin_expr_stmt
name|printed_limit
operator|=
name|buffer
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|resume
operator|=
name|buffer
operator|+
name|resume_index
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|initial_line_count
operator|=
name|line_count
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|match
operator|=
name|execute
argument_list|(
operator|&
name|reg
argument_list|,
name|resume
argument_list|,
name|search_limit
argument_list|,
literal|0
argument_list|,
operator|&
name|line_count
argument_list|,
operator|&
name|try_backref
argument_list|)
condition|)
block|{
operator|++
name|match_count
expr_stmt|;
comment|/* Find the beginning of the matching line. */
name|matching_line
operator|=
name|match
expr_stmt|;
while|while
condition|(
name|matching_line
operator|>
name|resume
operator|&&
name|matching_line
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|--
name|matching_line
expr_stmt|;
name|real_matching_line
operator|=
name|matching_line
expr_stmt|;
comment|/* Find the beginning of the next line. */
name|next_line
operator|=
name|match
expr_stmt|;
while|while
condition|(
name|next_line
operator|<
name|search_limit
operator|&&
operator|*
name|next_line
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* If a potential backreference is indicated, try it out with 	     a backtracking matcher to make sure the line is a match. */
if|if
condition|(
name|try_backref
operator|&&
name|re_search
argument_list|(
operator|&
name|regex
argument_list|,
name|matching_line
argument_list|,
name|next_line
operator|-
name|matching_line
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|next_line
operator|-
name|matching_line
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|resume
operator|=
name|next_line
expr_stmt|;
if|if
condition|(
name|resume
operator|==
name|search_limit
condition|)
break|break;
else|else
continue|continue;
block|}
comment|/* Print leftover lines from last time.  If nonmatching_lines is 	     turned on, print these as if they were matching lines. */
while|while
condition|(
name|resume
operator|<
name|matching_line
operator|&&
name|pending_lines
condition|)
block|{
name|resume
operator|+=
name|print_line
argument_list|(
name|resume
argument_list|,
name|initial_line_count
operator|++
argument_list|,
name|nonmatching_lines
argument_list|)
expr_stmt|;
operator|--
name|pending_lines
expr_stmt|;
block|}
comment|/* Print out the matching or nonmatching lines as necessary. */
if|if
condition|(
operator|!
name|nonmatching_lines
condition|)
block|{
comment|/* Back up over leading context if necessary. */
for|for
control|(
name|i
operator|=
name|leading_context
init|;
name|matching_line
operator|>
name|printed_limit
operator|&&
name|i
condition|;
operator|--
name|i
control|)
block|{
while|while
condition|(
name|matching_line
operator|>
name|printed_limit
operator|&&
operator|(
operator|--
name|matching_line
operator|)
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
empty_stmt|;
operator|--
name|line_count
expr_stmt|;
block|}
comment|/* If context is enabled, we may have to print a separator. */
if|if
condition|(
operator|(
name|leading_context
operator|||
name|trailing_context
operator|)
operator|&&
operator|!
name|silent
operator|&&
operator|!
name|first_match
operator|&&
operator|(
name|printed_limit_fake
operator|||
name|matching_line
operator|>
name|printed_limit
operator|)
condition|)
name|printf
argument_list|(
literal|"----------\n"
argument_list|)
expr_stmt|;
name|first_match
operator|=
literal|0
expr_stmt|;
comment|/* Print the matching line and its leading context. */
while|while
condition|(
name|matching_line
operator|<
name|real_matching_line
condition|)
name|matching_line
operator|+=
name|print_line
argument_list|(
name|matching_line
argument_list|,
name|line_count
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|matching_line
operator|+=
name|print_line
argument_list|(
name|matching_line
argument_list|,
name|line_count
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If there's trailing context, leave some lines pending until 		 next time. */
name|pending_lines
operator|=
name|trailing_context
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matching_line
operator|>
name|resume
condition|)
block|{
name|char
modifier|*
name|real_resume
init|=
name|resume
decl_stmt|;
comment|/* Back up over leading context if necessary. */
for|for
control|(
name|i
operator|=
name|leading_context
init|;
name|resume
operator|>
name|printed_limit
operator|&&
name|i
condition|;
operator|--
name|i
control|)
block|{
while|while
condition|(
name|resume
operator|>
name|printed_limit
operator|&&
operator|(
operator|--
name|resume
operator|)
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
empty_stmt|;
operator|--
name|initial_line_count
expr_stmt|;
block|}
comment|/* If context is enabled, we may have to print a separator. */
if|if
condition|(
operator|(
name|leading_context
operator|||
name|trailing_context
operator|)
operator|&&
operator|!
name|silent
operator|&&
operator|!
name|first_match
operator|&&
operator|(
name|printed_limit_fake
operator|||
name|resume
operator|>
name|printed_limit
operator|)
condition|)
name|printf
argument_list|(
literal|"----------\n"
argument_list|)
expr_stmt|;
name|first_match
operator|=
literal|0
expr_stmt|;
comment|/* Print out the presumably matching leading context. */
while|while
condition|(
name|resume
operator|<
name|real_resume
condition|)
name|resume
operator|+=
name|print_line
argument_list|(
name|resume
argument_list|,
name|initial_line_count
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Print out the nonmatching lines prior to the matching line. */
while|while
condition|(
name|resume
operator|<
name|matching_line
condition|)
name|resume
operator|+=
name|print_line
argument_list|(
name|resume
argument_list|,
name|initial_line_count
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Deal with trailing context. */
if|if
condition|(
name|trailing_context
condition|)
block|{
name|print_line
argument_list|(
name|matching_line
argument_list|,
name|line_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending_lines
operator|=
name|trailing_context
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Count the current line. */
operator|++
name|line_count
expr_stmt|;
block|}
else|else
block|{
comment|/* The line immediately after a matching line has to be printed 		 because it was pending. */
if|if
condition|(
name|pending_lines
operator|>
literal|0
condition|)
block|{
operator|--
name|pending_lines
expr_stmt|;
name|print_line
argument_list|(
name|matching_line
argument_list|,
name|line_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|++
name|line_count
expr_stmt|;
block|}
comment|/* Resume searching at the beginning of the next line. */
name|initial_line_count
operator|=
name|line_count
expr_stmt|;
name|resume
operator|=
name|next_line
expr_stmt|;
if|if
condition|(
name|resume
operator|==
name|search_limit
condition|)
break|break;
block|}
end_while

begin_comment
comment|/* Restore the saved character. */
end_comment

begin_expr_stmt
operator|*
name|search_limit
operator|=
name|saved_char
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|nonmatching_lines
condition|)
block|{
while|while
condition|(
name|resume
operator|<
name|search_limit
operator|&&
name|pending_lines
condition|)
block|{
name|resume
operator|+=
name|print_line
argument_list|(
name|resume
argument_list|,
name|initial_line_count
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|pending_lines
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|search_limit
operator|>
name|resume
condition|)
block|{
name|char
modifier|*
name|initial_resume
init|=
name|resume
decl_stmt|;
comment|/* Back up over leading context if necessary. */
for|for
control|(
name|i
operator|=
name|leading_context
init|;
name|resume
operator|>
name|printed_limit
operator|&&
name|i
condition|;
operator|--
name|i
control|)
block|{
while|while
condition|(
name|resume
operator|>
name|printed_limit
operator|&&
operator|(
operator|--
name|resume
operator|)
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
empty_stmt|;
operator|--
name|initial_line_count
expr_stmt|;
block|}
comment|/* If context is enabled, we may have to print a separator. */
if|if
condition|(
operator|(
name|leading_context
operator|||
name|trailing_context
operator|)
operator|&&
operator|!
name|silent
operator|&&
operator|!
name|first_match
operator|&&
operator|(
name|printed_limit_fake
operator|||
name|resume
operator|>
name|printed_limit
operator|)
condition|)
name|printf
argument_list|(
literal|"----------\n"
argument_list|)
expr_stmt|;
name|first_match
operator|=
literal|0
expr_stmt|;
comment|/* Print out all the nonmatching lines up to the search limit. */
while|while
condition|(
name|resume
operator|<
name|initial_resume
condition|)
name|resume
operator|+=
name|print_line
argument_list|(
name|resume
argument_list|,
name|initial_line_count
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|resume
operator|<
name|search_limit
condition|)
name|resume
operator|+=
name|print_line
argument_list|(
name|resume
argument_list|,
name|initial_line_count
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_lines
operator|=
name|trailing_context
expr_stmt|;
name|resume_index
operator|=
literal|0
expr_stmt|;
name|retain
operator|=
name|bufbytes
operator|-
operator|(
name|search_limit
operator|-
name|buffer
operator|)
expr_stmt|;
continue|continue;
block|}
end_if

begin_comment
comment|/* Save the trailing end of the buffer for possible use as leading 	 context in the future. */
end_comment

begin_expr_stmt
name|i
operator|=
name|leading_context
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tmp
operator|=
name|search_limit
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|tmp
operator|>
name|printed_limit
operator|&&
name|i
operator|--
condition|)
while|while
condition|(
name|tmp
operator|>
name|printed_limit
operator|&&
operator|(
operator|--
name|tmp
operator|)
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
empty_stmt|;
end_while

begin_expr_stmt
name|resume_index
operator|=
name|search_limit
operator|-
name|tmp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|retain
operator|=
name|bufbytes
operator|-
operator|(
name|tmp
operator|-
name|buffer
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|tmp
operator|>
name|printed_limit
condition|)
name|printed_limit_fake
operator|=
literal|1
expr_stmt|;
end_if

begin_expr_stmt
unit|}    return
name|nonmatching_lines
condition|?
operator|(
name|line_count
operator|-
literal|1
operator|)
operator|-
name|match_count
else|:
name|match_count
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_macro
unit|void
name|usage_and_die
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-CVbchilnsvwx] [-<num>] [-AB<num>] [-f file] [-e] expr [files]\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|version
index|[]
init|=
literal|"GNU e?grep, version 1.5"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|ignore_case
init|=
literal|0
decl_stmt|;
comment|/* Compile the regexp to ignore case. */
name|char
modifier|*
name|the_regexp
init|=
literal|0
decl_stmt|;
comment|/* The regular expression. */
name|int
name|regexp_len
decl_stmt|;
comment|/* Length of the regular expression. */
name|char
modifier|*
name|regexp_file
init|=
literal|0
decl_stmt|;
comment|/* File containing parallel regexps. */
name|int
name|count_lines
init|=
literal|0
decl_stmt|;
comment|/* Display only a count of matching lines. */
name|int
name|list_files
init|=
literal|0
decl_stmt|;
comment|/* Display only the names of matching files. */
name|int
name|whole_word
init|=
literal|0
decl_stmt|;
comment|/* Insist that the regexp match a word only. */
name|int
name|whole_line
init|=
literal|0
decl_stmt|;
comment|/* Insist on matching only whole lines. */
name|int
name|line_count
init|=
literal|0
decl_stmt|;
comment|/* Count of matching lines for a file. */
name|int
name|matches_found
init|=
literal|0
decl_stmt|;
comment|/* True if matches were found. */
name|char
modifier|*
name|regex_errmesg
decl_stmt|;
comment|/* Error message from regex routines. */
name|char
name|translate
index|[
name|_NOTCHAR
index|]
decl_stmt|;
comment|/* Translate table for case conversion 				   (needed by the backtracking matcher). */
if|if
condition|(
name|prog
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|++
name|prog
expr_stmt|;
else|else
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"0123456789A:B:CVbce:f:hilnsvwx"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
name|usage_and_die
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|trailing_context
operator|=
literal|10
operator|*
name|trailing_context
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|leading_context
operator|=
literal|10
operator|*
name|leading_context
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|trailing_context
argument_list|)
operator|||
name|trailing_context
operator|<
literal|0
condition|)
name|usage_and_die
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|leading_context
argument_list|)
operator|||
name|leading_context
operator|<
literal|0
condition|)
name|usage_and_die
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|trailing_context
operator|=
name|leading_context
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|byte_count
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|count_lines
operator|=
literal|1
expr_stmt|;
name|silent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* It doesn't make sense to mix -f and -e. */
if|if
condition|(
name|regexp_file
condition|)
name|usage_and_die
argument_list|()
expr_stmt|;
name|the_regexp
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* It doesn't make sense to mix -f and -e. */
if|if
condition|(
name|the_regexp
condition|)
name|usage_and_die
argument_list|()
expr_stmt|;
name|regexp_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|no_filenames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|ignore_case
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|_NOTCHAR
condition|;
operator|++
name|c
control|)
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|translate
index|[
name|c
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|translate
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|regex
operator|.
name|translate
operator|=
name|translate
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|list_files
operator|=
literal|1
expr_stmt|;
name|silent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|line_numbers
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|silent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|nonmatching_lines
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|whole_word
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|whole_line
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* This can't happen. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: getopt(3) let one by!\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|usage_and_die
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Set the syntax depending on whether we are EGREP or not. */
ifdef|#
directive|ifdef
name|EGREP
name|regsyntax
argument_list|(
name|RE_SYNTAX_EGREP
argument_list|,
name|ignore_case
argument_list|)
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_EGREP
argument_list|)
expr_stmt|;
else|#
directive|else
name|regsyntax
argument_list|(
name|RE_SYNTAX_GREP
argument_list|,
name|ignore_case
argument_list|)
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_GREP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compile the regexp according to all the options. */
if|if
condition|(
name|regexp_file
condition|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|regexp_file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|int
name|len
init|=
literal|256
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|prog
argument_list|,
name|regexp_file
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
name|the_regexp
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|the_regexp
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|len
condition|)
name|the_regexp
operator|=
name|realloc
argument_list|(
name|the_regexp
argument_list|,
name|len
operator|*=
literal|2
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Nuke the concluding newline so we won't match the empty string. */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|the_regexp
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|--
name|i
expr_stmt|;
name|regexp_len
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|the_regexp
condition|)
block|{
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
name|usage_and_die
argument_list|()
expr_stmt|;
name|the_regexp
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|regexp_len
operator|=
name|strlen
argument_list|(
name|the_regexp
argument_list|)
expr_stmt|;
block|}
else|else
name|regexp_len
operator|=
name|strlen
argument_list|(
name|the_regexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|whole_word
operator|||
name|whole_line
condition|)
block|{
name|char
modifier|*
name|n
init|=
name|malloc
argument_list|(
name|regexp_len
operator|+
literal|8
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|whole_line
condition|)
name|n
index|[
name|i
operator|++
index|]
operator|=
literal|'^'
expr_stmt|;
else|else
name|n
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
operator|,
name|n
index|[
name|i
operator|++
index|]
operator|=
literal|'<'
expr_stmt|;
ifndef|#
directive|ifndef
name|EGREP
name|n
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
endif|#
directive|endif
name|n
index|[
name|i
operator|++
index|]
operator|=
literal|'('
expr_stmt|;
name|memcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
name|the_regexp
argument_list|,
name|regexp_len
argument_list|)
expr_stmt|;
name|i
operator|+=
name|regexp_len
expr_stmt|;
ifndef|#
directive|ifndef
name|EGREP
name|n
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
endif|#
directive|endif
name|n
index|[
name|i
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
if|if
condition|(
name|whole_line
condition|)
name|n
index|[
name|i
operator|++
index|]
operator|=
literal|'$'
expr_stmt|;
else|else
name|n
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
operator|,
name|n
index|[
name|i
operator|++
index|]
operator|=
literal|'>'
expr_stmt|;
name|the_regexp
operator|=
name|n
expr_stmt|;
name|regexp_len
operator|=
name|i
expr_stmt|;
block|}
name|regcompile
argument_list|(
name|the_regexp
argument_list|,
name|regexp_len
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|regex_errmesg
operator|=
name|re_compile_pattern
argument_list|(
name|the_regexp
argument_list|,
name|regexp_len
argument_list|,
operator|&
name|regex
argument_list|)
condition|)
name|regerror
argument_list|(
name|regex_errmesg
argument_list|)
expr_stmt|;
comment|/*     Find the longest metacharacter-free string which must occur in the     regexpr, before short-circuiting regexecute() with Boyer-Moore-Gosper.     (Conjecture:  The problem in general is NP-complete.)  If there is no     such string (like for many alternations), then default to full automaton     search.  regmust() code and heuristics [see dfa.c] courtesy     Arthur David Olson.     */
if|if
condition|(
name|line_numbers
operator|==
literal|0
operator|&&
name|nonmatching_lines
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|.
name|mustn
operator|==
literal|0
operator|||
name|reg
operator|.
name|mustn
operator|==
name|MUST_MAX
operator|||
name|strchr
argument_list|(
name|reg
operator|.
name|must
argument_list|,
literal|'\0'
argument_list|)
operator|!=
name|reg
operator|.
name|must
operator|+
name|reg
operator|.
name|mustn
condition|)
name|bmgexec
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|reg
operator|.
name|must
index|[
name|reg
operator|.
name|mustn
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"MUSTDEBUG"
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"must have: \"%s\"\n"
argument_list|,
name|reg
operator|.
name|must
argument_list|)
expr_stmt|;
name|bmg_setup
argument_list|(
name|reg
operator|.
name|must
argument_list|,
name|ignore_case
argument_list|)
expr_stmt|;
name|bmgexec
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|-
name|optind
operator|<
literal|2
condition|)
name|no_filenames
operator|=
literal|1
expr_stmt|;
name|initialize_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|>
name|optind
condition|)
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|bufprev
operator|=
name|eof
operator|=
literal|0
expr_stmt|;
name|filename
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|prog
argument_list|,
name|filename
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|line_count
operator|=
name|grep
argument_list|()
condition|)
name|matches_found
operator|=
literal|1
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_lines
condition|)
if|if
condition|(
operator|!
name|no_filenames
condition|)
name|printf
argument_list|(
literal|"%s:%d\n"
argument_list|,
name|filename
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|list_files
operator|&&
name|line_count
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|line_count
operator|=
name|grep
argument_list|()
condition|)
name|matches_found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|count_lines
condition|)
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|list_files
operator|&&
name|line_count
condition|)
name|printf
argument_list|(
literal|"<stdin>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches_found
condition|)
name|exit
argument_list|(
name|MATCHES_FOUND
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|NO_MATCHES_FOUND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Needed by the regexp routines.  This could be fancier, especially when    dealing with parallel regexps in files. */
end_comment

begin_function
name|void
name|regerror
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|prog
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    bmg_setup() and bmg_search() adapted from:      Boyer/Moore/Gosper-assisted 'egrep' search, with delta0 table as in      original paper (CACM, October, 1977).  No delta1 or delta2.  According to      experiment (Horspool, Soft. Prac. Exp., 1982), delta2 is of minimal      practical value.  However, to improve for worst case input, integrating      the improved Galil strategies (Apostolico/Giancarlo, Siam. J. Comput.,      February 1986) deserves consideration.       James A. Woods				Copyleft (C) 1986, 1988      NASA Ames Research Center */
end_comment

begin_function
name|char
modifier|*
name|execute
parameter_list|(
name|r
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|,
name|newline
parameter_list|,
name|count
parameter_list|,
name|try_backref
parameter_list|)
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|begin
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|newline
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
name|int
modifier|*
name|try_backref
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|match
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|begin
decl_stmt|;
name|char
name|save
decl_stmt|;
comment|/* regexecute() sentinel */
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|bmg_search
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|bmgexec
condition|)
comment|/* full automaton search */
return|return
operator|(
name|regexecute
argument_list|(
name|r
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|newline
argument_list|,
name|count
argument_list|,
name|try_backref
argument_list|)
operator|)
return|;
else|else
block|{
name|len
operator|=
name|end
operator|-
name|begin
expr_stmt|;
while|while
condition|(
operator|(
name|match
operator|=
name|bmg_search
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|start
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|match
expr_stmt|;
comment|/* narrow search range to submatch line */
while|while
condition|(
name|p
operator|>
name|begin
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|--
expr_stmt|;
name|s
operator|=
name|match
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|end
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|save
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|match
operator|=
name|regexecute
argument_list|(
name|r
argument_list|,
name|p
argument_list|,
name|s
argument_list|,
name|newline
argument_list|,
name|count
argument_list|,
name|try_backref
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|save
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|match
operator|)
return|;
else|else
block|{
name|start
operator|=
name|s
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|start
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
name|int
name|delta0
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|cmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (un)folded characters */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|pattern
index|[
literal|5000
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|patlen
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|bmg_search
parameter_list|(
name|buffer
parameter_list|,
name|buflen
parameter_list|)
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|buflen
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|k
decl_stmt|,
modifier|*
name|strend
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|buflim
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|patlen
operator|>
name|buflen
condition|)
return|return
name|NULL
return|;
name|buflim
operator|=
name|buffer
operator|+
name|buflen
expr_stmt|;
if|if
condition|(
name|buflen
operator|>
name|patlen
operator|*
literal|4
condition|)
name|strend
operator|=
name|buflim
operator|-
name|patlen
operator|*
literal|4
expr_stmt|;
else|else
name|strend
operator|=
name|buffer
expr_stmt|;
name|s
operator|=
name|buffer
expr_stmt|;
name|k
operator|=
name|buffer
operator|+
name|patlen
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* The dreaded inner loop, revisited. */
while|while
condition|(
name|k
operator|<
name|strend
operator|&&
operator|(
name|t
operator|=
name|delta0
index|[
operator|*
name|k
index|]
operator|)
condition|)
block|{
name|k
operator|+=
name|t
expr_stmt|;
name|k
operator|+=
name|delta0
index|[
operator|*
name|k
index|]
expr_stmt|;
name|k
operator|+=
name|delta0
index|[
operator|*
name|k
index|]
expr_stmt|;
block|}
while|while
condition|(
name|k
operator|<
name|buflim
operator|&&
name|delta0
index|[
operator|*
name|k
index|]
condition|)
operator|++
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|buflim
condition|)
break|break;
name|j
operator|=
name|patlen
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|k
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
operator|&&
name|cmap
index|[
operator|*
operator|--
name|s
index|]
operator|==
name|pattern
index|[
name|j
index|]
condition|)
empty_stmt|;
comment|/*  	delta-less shortcut for literati, but  	short shrift for genetic engineers.       */
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
name|k
operator|++
expr_stmt|;
else|else
comment|/* submatch */
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|k
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|bmg_setup
argument_list|(
argument|pat
argument_list|,
argument|folded
argument_list|)
end_macro

begin_comment
comment|/* compute "boyer-moore" delta table */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|folded
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* ... HAKMEM lives ... */
name|int
name|j
decl_stmt|;
name|patlen
operator|=
name|strlen
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
condition|)
comment|/* fold case while saving pattern */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|patlen
condition|;
name|j
operator|++
control|)
name|pattern
index|[
name|j
index|]
operator|=
operator|(
name|isupper
argument_list|(
operator|(
name|int
operator|)
name|pat
index|[
name|j
index|]
argument_list|)
condition|?
operator|(
name|char
operator|)
name|tolower
argument_list|(
operator|(
name|int
operator|)
name|pat
index|[
name|j
index|]
argument_list|)
else|:
name|pat
index|[
name|j
index|]
operator|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|pattern
argument_list|,
name|pat
argument_list|,
name|patlen
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|delta0
index|[
name|j
index|]
operator|=
name|patlen
expr_stmt|;
name|cmap
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|)
name|j
expr_stmt|;
comment|/* could be done at compile time */
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|patlen
operator|-
literal|1
condition|;
name|j
operator|++
control|)
name|delta0
index|[
name|pattern
index|[
name|j
index|]
index|]
operator|=
name|patlen
operator|-
name|j
operator|-
literal|1
expr_stmt|;
name|delta0
index|[
name|pattern
index|[
name|patlen
operator|-
literal|1
index|]
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|folded
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|patlen
operator|-
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|(
name|int
operator|)
name|pattern
index|[
name|j
index|]
argument_list|)
condition|)
name|delta0
index|[
name|toupper
argument_list|(
operator|(
name|int
operator|)
name|pattern
index|[
name|j
index|]
argument_list|)
index|]
operator|=
name|patlen
operator|-
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
operator|(
name|int
operator|)
name|pattern
index|[
name|patlen
operator|-
literal|1
index|]
argument_list|)
condition|)
name|delta0
index|[
name|toupper
argument_list|(
operator|(
name|int
operator|)
name|pattern
index|[
name|patlen
operator|-
literal|1
index|]
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|'A'
init|;
name|j
operator|<=
literal|'Z'
condition|;
name|j
operator|++
control|)
name|cmap
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
operator|(
name|int
operator|)
name|j
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|nope
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_comment
comment|/* (groan) compatibility */
end_comment

begin_function
name|char
modifier|*
name|strchr
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|index
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|strrchr
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|rindex
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|memcpy
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|d
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
return|return
name|bcopy
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_function
name|char
modifier|*
name|index
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|strchr
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|d
decl_stmt|;
end_function

begin_block
block|{
return|return
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|bzero
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|memset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_macro
name|bcmp
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|memcmp
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

