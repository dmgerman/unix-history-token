begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* File I/O for GNU DIFF.    Copyright (C) 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU DIFF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_comment
comment|/* Rotate a value n bits to the left. */
end_comment

begin_define
define|#
directive|define
name|UINT_BIT
value|(sizeof (unsigned) * CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|ROL
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|((v)<< (n) | (v)>> UINT_BIT - (n))
end_define

begin_comment
comment|/* Given a hash value and a new character, return a new hash value. */
end_comment

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|h
parameter_list|,
name|c
parameter_list|)
value|((c) + ROL (h, 7))
end_define

begin_comment
comment|/* Current file under consideration. */
end_comment

begin_decl_stmt
name|struct
name|file_data
modifier|*
name|current
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Check for binary files and compare them for exact identity.  */
end_comment

begin_comment
comment|/* Return 1 if BUF contains a non text character.    SIZE is the number of characters in BUF.  */
end_comment

begin_function
specifier|static
name|int
name|binary_file_p
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|textchar
index|[]
init|=
block|{
comment|/* ISO 8859 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,   }
decl_stmt|;
while|while
condition|(
operator|--
name|size
operator|>=
literal|0
condition|)
if|if
condition|(
operator|!
name|textchar
index|[
operator|*
name|buf
operator|++
operator|&
literal|0377
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|int
name|binary_file_threshold
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Slurp the current file completely into core.    Return nonzero if it appears to be a binary file.  */
end_comment

begin_function
specifier|static
name|int
name|slurp
parameter_list|()
block|{
comment|/* If we have a nonexistent file at this stage, treat it as empty.  */
if|if
condition|(
name|current
operator|->
name|desc
operator|<
literal|0
condition|)
block|{
name|current
operator|->
name|bufsize
operator|=
literal|0
expr_stmt|;
name|current
operator|->
name|buffered_chars
operator|=
literal|0
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If it's a regular file, we can just get the size out of the stat      block and slurp it in all at once. */
comment|/* In all cases, we leave room in the buffer for 2 extra chars      beyond those that current->bufsize describes:      one for a newline (in case the text does not end with one)      and one for a sentinel in find_identical_ends.  */
elseif|else
if|if
condition|(
operator|(
name|current
operator|->
name|stat
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
block|{
name|current
operator|->
name|bufsize
operator|=
name|current
operator|->
name|stat
operator|.
name|st_size
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|current
operator|->
name|bufsize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffered_chars
operator|=
name|read
argument_list|(
name|current
operator|->
name|desc
argument_list|,
name|current
operator|->
name|buffer
argument_list|,
name|current
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|buffered_chars
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|current
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|cc
decl_stmt|;
name|current
operator|->
name|bufsize
operator|=
literal|4096
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|current
operator|->
name|bufsize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffered_chars
operator|=
literal|0
expr_stmt|;
comment|/* Not a regular file; read it in a little at a time, growing the 	 buffer as necessary. */
while|while
condition|(
operator|(
name|cc
operator|=
name|read
argument_list|(
name|current
operator|->
name|desc
argument_list|,
name|current
operator|->
name|buffer
operator|+
name|current
operator|->
name|buffered_chars
argument_list|,
name|current
operator|->
name|bufsize
operator|-
name|current
operator|->
name|buffered_chars
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|current
operator|->
name|buffered_chars
operator|+=
name|cc
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|buffered_chars
operator|==
name|current
operator|->
name|bufsize
condition|)
block|{
name|current
operator|->
name|bufsize
operator|=
name|current
operator|->
name|bufsize
operator|*
literal|2
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|current
operator|->
name|buffer
argument_list|,
name|current
operator|->
name|bufsize
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|current
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Check first part of file to see if it's a binary file.  */
if|if
condition|(
operator|!
name|always_text_flag
operator|&&
name|binary_file_p
argument_list|(
name|current
operator|->
name|buffer
argument_list|,
name|min
argument_list|(
name|current
operator|->
name|buffered_chars
argument_list|,
name|binary_file_threshold
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If not binary, make sure text ends in a newline,      but remember that we had to add one unless -B is in effect.  */
if|if
condition|(
name|current
operator|->
name|buffered_chars
operator|>
literal|0
operator|&&
name|current
operator|->
name|buffer
index|[
name|current
operator|->
name|buffered_chars
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|current
operator|->
name|missing_newline
operator|=
operator|!
name|ignore_blank_lines_flag
expr_stmt|;
name|current
operator|->
name|buffer
index|[
name|current
operator|->
name|buffered_chars
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
name|current
operator|->
name|missing_newline
operator|=
literal|0
expr_stmt|;
comment|/* Don't use uninitialized storage. */
if|if
condition|(
name|current
operator|->
name|buffer
operator|!=
literal|0
condition|)
name|current
operator|->
name|buffer
index|[
name|current
operator|->
name|buffered_chars
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split the file into lines, simultaneously computing the hash codes for    each line. */
end_comment

begin_function
name|void
name|find_and_hash_each_line
parameter_list|()
block|{
name|unsigned
name|h
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|current
operator|->
name|prefix_end
decl_stmt|,
modifier|*
name|ip
decl_stmt|,
name|c
decl_stmt|;
comment|/* Attempt to get a good initial guess as to the number of lines. */
name|current
operator|->
name|linbufsize
operator|=
name|current
operator|->
name|buffered_chars
operator|/
literal|50
operator|+
literal|5
expr_stmt|;
name|current
operator|->
name|linbuf
operator|=
operator|(
expr|struct
name|line_def
operator|*
operator|)
name|xmalloc
argument_list|(
name|current
operator|->
name|linbufsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line_def
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_regexp
operator|||
name|output_style
operator|==
name|OUTPUT_IFDEF
condition|)
block|{
comment|/* If the -C, -D or -F option is used, we need to find the lines 	 of the matching prefix.  At least we will need to find the last few, 	 but since we don't know how many, it's easiest to find them all. 	 If -D is specified, we need all the lines of the first file.  */
name|current
operator|->
name|buffered_lines
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|current
operator|->
name|buffer
expr_stmt|;
block|}
else|else
block|{
comment|/* Skip the identical prefixes, except be prepared to handle context. 	 In fact, handle 1 more preceding line than the context says, 	 in case shift_boundaries moves things backwards in this file.  */
name|current
operator|->
name|buffered_lines
operator|=
name|current
operator|->
name|prefix_lines
operator|-
name|context
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|buffered_lines
operator|<
literal|0
condition|)
name|current
operator|->
name|buffered_lines
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|context
operator|+
literal|1
condition|;
operator|++
name|i
control|)
comment|/* Unless we are at the beginning, */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|p
operator|!=
name|current
operator|->
name|buffer
condition|)
comment|/* Back up at least 1 char until at the start of a line.  */
while|while
condition|(
operator|(
name|char
operator|*
operator|)
operator|--
name|p
operator|!=
name|current
operator|->
name|buffer
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
while|while
condition|(
operator|(
name|char
operator|*
operator|)
name|p
operator|<
name|current
operator|->
name|suffix_begin
condition|)
block|{
name|h
operator|=
literal|0
expr_stmt|;
name|ip
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|prefix_end
operator|<=
operator|(
name|char
operator|*
operator|)
name|p
condition|)
block|{
comment|/* Hash this line until we find a newline. */
if|if
condition|(
name|ignore_case_flag
condition|)
block|{
if|if
condition|(
name|ignore_all_space_flag
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ignore_space_change_flag
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* C is now the first non-space.  */
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ignore_all_space_flag
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ignore_space_change_flag
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* C is not the first non-space.  */
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\n'
condition|)
block|{
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* This line is part of the matching prefix, 	   so we don't need to hash it.  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Maybe increase the size of the line table. */
if|if
condition|(
name|current
operator|->
name|buffered_lines
operator|>=
name|current
operator|->
name|linbufsize
condition|)
block|{
while|while
condition|(
name|current
operator|->
name|buffered_lines
operator|>=
name|current
operator|->
name|linbufsize
condition|)
name|current
operator|->
name|linbufsize
operator|*=
literal|2
expr_stmt|;
name|current
operator|->
name|linbuf
operator|=
operator|(
expr|struct
name|line_def
operator|*
operator|)
name|xrealloc
argument_list|(
name|current
operator|->
name|linbuf
argument_list|,
name|current
operator|->
name|linbufsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line_def
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|current
operator|->
name|linbuf
index|[
name|current
operator|->
name|buffered_lines
index|]
operator|.
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
expr_stmt|;
name|current
operator|->
name|linbuf
index|[
name|current
operator|->
name|buffered_lines
index|]
operator|.
name|length
operator|=
name|p
operator|-
name|ip
operator|+
literal|1
expr_stmt|;
name|current
operator|->
name|linbuf
index|[
name|current
operator|->
name|buffered_lines
index|]
operator|.
name|hash
operator|=
name|h
expr_stmt|;
operator|++
name|current
operator|->
name|buffered_lines
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|context
operator|||
name|output_style
operator|==
name|OUTPUT_IFDEF
operator|)
operator|&&
operator|(
name|char
operator|*
operator|)
name|p
operator|<
name|current
operator|->
name|buffer
operator|+
name|current
operator|->
name|buffered_chars
condition|)
block|{
name|ip
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* Maybe increase the size of the line table. */
if|if
condition|(
name|current
operator|->
name|buffered_lines
operator|>=
name|current
operator|->
name|linbufsize
condition|)
block|{
while|while
condition|(
name|current
operator|->
name|buffered_lines
operator|>=
name|current
operator|->
name|linbufsize
condition|)
name|current
operator|->
name|linbufsize
operator|*=
literal|2
expr_stmt|;
name|current
operator|->
name|linbuf
operator|=
operator|(
expr|struct
name|line_def
operator|*
operator|)
name|xrealloc
argument_list|(
name|current
operator|->
name|linbuf
argument_list|,
name|current
operator|->
name|linbufsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line_def
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|current
operator|->
name|linbuf
index|[
name|current
operator|->
name|buffered_lines
index|]
operator|.
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
expr_stmt|;
name|current
operator|->
name|linbuf
index|[
name|current
operator|->
name|buffered_lines
index|]
operator|.
name|length
operator|=
name|p
operator|-
name|ip
expr_stmt|;
name|current
operator|->
name|linbuf
index|[
name|current
operator|->
name|buffered_lines
index|]
operator|.
name|hash
operator|=
literal|0
expr_stmt|;
operator|++
name|current
operator|->
name|buffered_lines
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|ROBUST_OUTPUT_STYLE
argument_list|(
name|output_style
argument_list|)
operator|&&
name|current
operator|->
name|missing_newline
operator|&&
name|current
operator|->
name|suffix_begin
operator|==
name|current
operator|->
name|buffer
operator|+
name|current
operator|->
name|buffered_chars
condition|)
operator|--
name|current
operator|->
name|linbuf
index|[
name|current
operator|->
name|buffered_lines
operator|-
literal|1
index|]
operator|.
name|length
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a vector of two file_data objects, find the identical    prefixes and suffixes of each object. */
end_comment

begin_function
specifier|static
name|void
name|find_identical_ends
parameter_list|(
name|filevec
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|end0
decl_stmt|,
modifier|*
name|beg0
decl_stmt|;
name|int
name|lines
decl_stmt|;
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|==
literal|0
operator|||
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
operator|==
literal|0
condition|)
block|{
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_end
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_lines
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_lines
operator|=
literal|0
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|suffix_begin
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
operator|+
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|suffix_begin
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|suffix_lines
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|suffix_lines
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Find identical prefix.  */
name|p0
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
expr_stmt|;
name|p1
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
expr_stmt|;
name|lines
operator|=
literal|0
expr_stmt|;
comment|/* Insert end "sentinels", in this case characters that are guaranteed      to make the equality test false, and thus terminate the loop.  */
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|<
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
condition|)
name|p0
index|[
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
index|]
operator|=
operator|~
name|p1
index|[
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
index|]
expr_stmt|;
else|else
name|p1
index|[
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
index|]
operator|=
operator|~
name|p0
index|[
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
index|]
expr_stmt|;
comment|/* Loop until first mismatch, or to the sentinel characters.  */
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|c
init|=
operator|*
name|p0
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|*
name|p1
operator|++
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|lines
expr_stmt|;
block|}
comment|/* Don't count missing newline as part of prefix in RCS mode. */
if|if
condition|(
name|ROBUST_OUTPUT_STYLE
argument_list|(
name|output_style
argument_list|)
operator|&&
operator|(
operator|(
name|filevec
index|[
literal|0
index|]
operator|.
name|missing_newline
operator|&&
name|p0
operator|-
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
operator|>
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|)
operator|||
operator|(
name|filevec
index|[
literal|1
index|]
operator|.
name|missing_newline
operator|&&
name|p1
operator|-
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
operator|>
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
operator|)
operator|)
condition|)
operator|--
name|p0
operator|,
operator|--
name|p1
operator|,
operator|--
name|lines
expr_stmt|;
comment|/* If the sentinel was passed, and lengths are equal, the      files are identical.  */
if|if
condition|(
name|p0
operator|-
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
operator|>
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|&&
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|==
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
condition|)
block|{
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
operator|=
name|p0
operator|-
literal|1
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_end
operator|=
name|p1
operator|-
literal|1
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_lines
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_lines
operator|=
name|lines
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|suffix_begin
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|suffix_begin
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|suffix_lines
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|suffix_lines
operator|=
name|lines
expr_stmt|;
return|return;
block|}
comment|/* Point at first nonmatching characters.  */
operator|--
name|p0
operator|,
operator|--
name|p1
expr_stmt|;
comment|/* Skip back to last line-beginning in the prefix.  */
while|while
condition|(
name|p0
operator|!=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
operator|&&
name|p0
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|--
name|p0
operator|,
operator|--
name|p1
expr_stmt|;
comment|/* Record the prefix.  */
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
operator|=
name|p0
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_end
operator|=
name|p1
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_lines
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_lines
operator|=
name|lines
expr_stmt|;
comment|/* Find identical suffix.  */
comment|/* P0 and P1 point beyond the last chars not yet compared.  */
name|p0
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
operator|+
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
expr_stmt|;
name|p1
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
expr_stmt|;
name|lines
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ROBUST_OUTPUT_STYLE
argument_list|(
name|output_style
argument_list|)
operator|||
name|filevec
index|[
literal|0
index|]
operator|.
name|missing_newline
operator|==
name|filevec
index|[
literal|1
index|]
operator|.
name|missing_newline
condition|)
block|{
name|end0
operator|=
name|p0
expr_stmt|;
comment|/* Addr of last char in file 0.  */
comment|/* Get value of P0 at which we should stop scanning backward: 	 this is when either P0 or P1 points just past the last char 	 of the identical prefix.  */
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|<
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
condition|)
name|beg0
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
expr_stmt|;
else|else
comment|/* Figure out where P0 will be when P1 is at the end of the prefix. 	   Thus we only need to test P0.  */
name|beg0
operator|=
operator|(
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
operator|+
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
operator|-
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
operator|)
expr_stmt|;
comment|/* Scan back until chars don't match or we reach that point.  */
while|while
condition|(
name|p0
operator|!=
name|beg0
condition|)
block|{
name|char
name|c
init|=
operator|*
operator|--
name|p0
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|*
operator|--
name|p1
condition|)
block|{
comment|/* Point at the first char of the matching suffix.  */
operator|++
name|p0
operator|,
operator|++
name|p1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|++
name|lines
expr_stmt|;
block|}
comment|/* Are we at a line-beginning in both files?  */
if|if
condition|(
name|p0
operator|!=
name|end0
operator|&&
operator|!
operator|(
operator|(
name|p0
operator|==
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
operator|||
name|p0
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
name|p1
operator|==
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
operator|||
name|p1
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|)
condition|)
block|{
comment|/* No.  We counted one line too many.  */
operator|--
name|lines
expr_stmt|;
comment|/* Advance to next place that is a line-beginning in both files.  */
do|do
block|{
operator|++
name|p0
operator|,
operator|++
name|p1
expr_stmt|;
block|}
do|while
condition|(
name|p0
operator|!=
name|end0
operator|&&
name|p0
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
do|;
block|}
block|}
comment|/* Record the suffix.  */
name|filevec
index|[
literal|0
index|]
operator|.
name|suffix_begin
operator|=
name|p0
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|suffix_begin
operator|=
name|p1
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|suffix_lines
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|suffix_lines
operator|=
name|lines
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lines are put into equivalence classes (of lines that match in line_cmp).    Each equivalence class is represented by one of these structures,    but only while the classes are being computed.    Afterward, each class is represented by a number.  */
end_comment

begin_struct
struct|struct
name|equivclass
block|{
name|struct
name|equivclass
modifier|*
name|next
decl_stmt|;
comment|/* Next item in this bucket. */
name|struct
name|line_def
name|line
decl_stmt|;
comment|/* A line that fits this class. */
block|}
struct|;
end_struct

begin_comment
comment|/* Hash-table: array of buckets, each being a chain of equivalence classes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|equivclass
modifier|*
modifier|*
name|buckets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the bucket array. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nbuckets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array in which the equivalence classes are allocated.    The bucket-chains go through the elements in this array.    The number of an equivalence class is its index in this array.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|equivclass
modifier|*
name|equivs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of first free element in the array `equivs'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|equivs_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size allocated to the array `equivs'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|equivs_alloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Largest primes less than some power of two, for nbuckets.  Values range    from useful to preposterous.  If one of these numbers isn't prime    after all, don't blame it on me, blame it on primes (6) . . . */
end_comment

begin_decl_stmt
specifier|static
name|int
name|primes
index|[]
init|=
block|{
literal|509
block|,
literal|1021
block|,
literal|2039
block|,
literal|4093
block|,
literal|8191
block|,
literal|16381
block|,
literal|32749
block|,
literal|65521
block|,
literal|131071
block|,
literal|262139
block|,
literal|524287
block|,
literal|1048573
block|,
literal|2097143
block|,
literal|4194301
block|,
literal|8388593
block|,
literal|16777213
block|,
literal|33554393
block|,
literal|67108859
block|,
comment|/* Preposterously large . . . */
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of current nbuckets in primes. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|primes_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the equiv class associated with line N of the current file.  */
end_comment

begin_function
specifier|static
name|int
name|find_equiv_class
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|int
name|bucket
decl_stmt|;
name|struct
name|equivclass
modifier|*
name|b
decl_stmt|,
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
comment|/* Equivalence class 0 is permanently allocated to lines that were      not hashed because they were parts of identical prefixes or      suffixes. */
if|if
condition|(
name|n
operator|<
name|current
operator|->
name|prefix_lines
operator|||
name|current
operator|->
name|linbuf
index|[
name|n
index|]
operator|.
name|text
operator|>=
name|current
operator|->
name|suffix_begin
condition|)
return|return
literal|0
return|;
comment|/* Check through the appropriate bucket to see if there isn't already      an equivalence class for this line. */
name|bucket
operator|=
name|current
operator|->
name|linbuf
index|[
name|n
index|]
operator|.
name|hash
operator|%
name|nbuckets
expr_stmt|;
name|b
operator|=
name|buckets
index|[
name|bucket
index|]
expr_stmt|;
while|while
condition|(
name|b
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|line
operator|.
name|hash
operator|==
name|current
operator|->
name|linbuf
index|[
name|n
index|]
operator|.
name|hash
operator|&&
operator|(
name|b
operator|->
name|line
operator|.
name|length
operator|==
name|current
operator|->
name|linbuf
index|[
name|n
index|]
operator|.
name|length
comment|/* Lines of different lengths can match with certain options.  */
operator|||
name|length_varies
operator|)
operator|&&
operator|!
name|line_cmp
argument_list|(
operator|&
name|b
operator|->
name|line
argument_list|,
operator|&
name|current
operator|->
name|linbuf
index|[
name|n
index|]
argument_list|)
condition|)
return|return
name|b
operator|-
name|equivs
return|;
name|p
operator|=
name|b
operator|,
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
comment|/* Create a new equivalence class in this bucket. */
name|p
operator|=
operator|&
name|equivs
index|[
name|equivs_index
operator|++
index|]
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|buckets
index|[
name|bucket
index|]
expr_stmt|;
name|buckets
index|[
name|bucket
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|line
operator|=
name|current
operator|->
name|linbuf
index|[
name|n
index|]
expr_stmt|;
return|return
name|equivs_index
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a vector of two file_data objects, read the file associated    with each one, and build the table of equivalence classes.    Return nonzero if either file appears to be a binary file.  */
end_comment

begin_function
name|int
name|read_files
parameter_list|(
name|filevec
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|binary
init|=
literal|0
decl_stmt|;
name|int
name|this_binary
decl_stmt|;
name|current
operator|=
operator|&
name|filevec
index|[
literal|0
index|]
expr_stmt|;
name|binary
operator|=
name|this_binary
operator|=
name|slurp
argument_list|()
expr_stmt|;
name|current
operator|=
operator|&
name|filevec
index|[
literal|1
index|]
expr_stmt|;
name|this_binary
operator|=
name|slurp
argument_list|()
expr_stmt|;
if|if
condition|(
name|binary
operator|||
name|this_binary
condition|)
return|return
literal|1
return|;
name|find_identical_ends
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|current
operator|=
operator|&
name|filevec
index|[
name|i
index|]
expr_stmt|;
name|find_and_hash_each_line
argument_list|()
expr_stmt|;
block|}
comment|/* This is guaranteed to be enough space.  */
name|equivs_alloc
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_lines
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_lines
operator|+
literal|1
expr_stmt|;
name|equivs
operator|=
operator|(
expr|struct
name|equivclass
operator|*
operator|)
name|xmalloc
argument_list|(
name|equivs_alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|equivclass
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Equivalence class 0 is permanently safe for lines that were not      hashed.  Real equivalence classes start at 1. */
name|equivs_index
operator|=
literal|1
expr_stmt|;
name|primes_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|primes
index|[
name|primes_index
index|]
operator|<
name|equivs_alloc
operator|/
literal|3
condition|)
name|primes_index
operator|++
expr_stmt|;
name|buckets
operator|=
operator|(
expr|struct
name|equivclass
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|primes
index|[
name|primes_index
index|]
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|equivclass
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buckets
argument_list|,
name|primes
index|[
name|primes_index
index|]
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|equivclass
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|nbuckets
operator|=
name|primes
index|[
name|primes_index
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|current
operator|=
operator|&
name|filevec
index|[
name|i
index|]
expr_stmt|;
name|current
operator|->
name|equivs
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|current
operator|->
name|buffered_lines
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|current
operator|->
name|buffered_lines
condition|;
operator|++
name|j
control|)
name|current
operator|->
name|equivs
index|[
name|j
index|]
operator|=
name|find_equiv_class
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
name|filevec
index|[
literal|0
index|]
operator|.
name|equiv_max
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|equiv_max
operator|=
name|equivs_index
expr_stmt|;
name|free
argument_list|(
name|equivs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

