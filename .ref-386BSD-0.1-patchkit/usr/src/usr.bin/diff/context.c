begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Context-format output routines for GNU DIFF.    Copyright (C) 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU DIFF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_function_decl
specifier|static
name|void
name|pr_context_hunk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pr_unidiff_hunk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|change
modifier|*
name|find_hunk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_ignorable
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_function
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Last place find_function started searching from.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|find_function_last_search
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value find_function returned when it started searching there.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|find_function_last_match
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print a label for a context diff, with a file name and date or a label.  */
end_comment

begin_function
specifier|static
name|void
name|print_context_label
parameter_list|(
name|mark
parameter_list|,
name|inf
parameter_list|,
name|label
parameter_list|)
specifier|const
name|char
modifier|*
name|mark
decl_stmt|;
name|struct
name|file_data
modifier|*
name|inf
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
block|{
if|if
condition|(
name|label
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s %s\n"
argument_list|,
name|mark
argument_list|,
name|label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|inf
operator|->
name|stat
operator|.
name|st_mtime
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s %s\t%s"
argument_list|,
name|mark
argument_list|,
name|inf
operator|->
name|name
argument_list|,
name|ctime
argument_list|(
operator|&
name|inf
operator|->
name|stat
operator|.
name|st_mtime
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Don't pretend that standard input is ancient.  */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s %s\n"
argument_list|,
name|mark
argument_list|,
name|inf
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a header for a context diff, with the file names and dates.  */
end_comment

begin_function
name|void
name|print_context_header
parameter_list|(
name|inf
parameter_list|,
name|unidiff_flag
parameter_list|)
name|struct
name|file_data
modifier|*
name|inf
decl_stmt|;
name|int
name|unidiff_flag
decl_stmt|;
block|{
if|if
condition|(
name|unidiff_flag
condition|)
block|{
name|print_context_label
argument_list|(
literal|"---"
argument_list|,
operator|&
name|inf
index|[
literal|0
index|]
argument_list|,
name|file_label
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|print_context_label
argument_list|(
literal|"+++"
argument_list|,
operator|&
name|inf
index|[
literal|1
index|]
argument_list|,
name|file_label
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_context_label
argument_list|(
literal|"***"
argument_list|,
operator|&
name|inf
index|[
literal|0
index|]
argument_list|,
name|file_label
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|print_context_label
argument_list|(
literal|"---"
argument_list|,
operator|&
name|inf
index|[
literal|1
index|]
argument_list|,
name|file_label
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print an edit script in context format.  */
end_comment

begin_function
name|void
name|print_context_script
parameter_list|(
name|script
parameter_list|,
name|unidiff_flag
parameter_list|)
name|struct
name|change
modifier|*
name|script
decl_stmt|;
name|int
name|unidiff_flag
decl_stmt|;
block|{
if|if
condition|(
name|ignore_blank_lines_flag
operator|||
name|ignore_regexp
condition|)
name|mark_ignorable
argument_list|(
name|script
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|change
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|script
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|link
control|)
name|e
operator|->
name|ignore
operator|=
literal|0
expr_stmt|;
block|}
name|find_function_last_search
operator|=
literal|0
expr_stmt|;
name|find_function_last_match
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|unidiff_flag
condition|)
name|print_script
argument_list|(
name|script
argument_list|,
name|find_hunk
argument_list|,
name|pr_unidiff_hunk
argument_list|)
expr_stmt|;
else|else
name|print_script
argument_list|(
name|script
argument_list|,
name|find_hunk
argument_list|,
name|pr_context_hunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a pair of line numbers with a comma, translated for file FILE.    If the second number is not greater, use the first in place of it.     Args A and B are internal line numbers.    We print the translated (real) line numbers.  */
end_comment

begin_function
specifier|static
name|void
name|print_context_number_range
parameter_list|(
name|file
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|file_data
modifier|*
name|file
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|int
name|trans_a
decl_stmt|,
name|trans_b
decl_stmt|;
name|translate_range
argument_list|(
name|file
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|trans_a
argument_list|,
operator|&
name|trans_b
argument_list|)
expr_stmt|;
comment|/* Note: we can have B< A in the case of a range of no lines.      In this case, we should print the line number before the range,      which is B.  */
if|if
condition|(
name|trans_b
operator|>
name|trans_a
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d,%d"
argument_list|,
name|trans_a
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d"
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a portion of an edit script in context format.    HUNK is the beginning of the portion to be printed.    The end is marked by a `link' that has been nulled out.     Prints out lines from both files, and precedes each    line with the appropriate flag-character.  */
end_comment

begin_function
specifier|static
name|void
name|pr_context_hunk
parameter_list|(
name|hunk
parameter_list|)
name|struct
name|change
modifier|*
name|hunk
decl_stmt|;
block|{
name|int
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|,
name|show_from
decl_stmt|,
name|show_to
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|change
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|function
decl_stmt|;
name|int
name|function_length
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|,
operator|&
name|show_from
argument_list|,
operator|&
name|show_to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|show_from
operator|&&
operator|!
name|show_to
condition|)
return|return;
comment|/* Include a context's width before and after.  */
name|first0
operator|=
name|max
argument_list|(
name|first0
operator|-
name|context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|first1
operator|=
name|max
argument_list|(
name|first1
operator|-
name|context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last0
operator|=
name|min
argument_list|(
name|last0
operator|+
name|context
argument_list|,
name|files
index|[
literal|0
index|]
operator|.
name|buffered_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|last1
operator|=
name|min
argument_list|(
name|last1
operator|+
name|context
argument_list|,
name|files
index|[
literal|1
index|]
operator|.
name|buffered_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If desired, find the preceding function definition line in file 0.  */
name|function
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|function_regexp
condition|)
name|find_function
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|first0
argument_list|,
operator|&
name|function
argument_list|,
operator|&
name|function_length
argument_list|)
expr_stmt|;
comment|/* If we looked for and found a function this is part of,      include its name in the header of the diff section.  */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"***************"
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|function
argument_list|,
literal|1
argument_list|,
name|min
argument_list|(
name|function_length
operator|-
literal|1
argument_list|,
literal|40
argument_list|)
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n*** "
argument_list|)
expr_stmt|;
name|print_context_number_range
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|first0
argument_list|,
name|last0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" ****\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_from
condition|)
block|{
name|next
operator|=
name|hunk
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first0
init|;
name|i
operator|<=
name|last0
condition|;
name|i
operator|++
control|)
block|{
comment|/* Skip past changes that apply (in file 0) 	     only to lines before line I.  */
while|while
condition|(
name|next
operator|&&
name|next
operator|->
name|line0
operator|+
name|next
operator|->
name|deleted
operator|<=
name|i
condition|)
name|next
operator|=
name|next
operator|->
name|link
expr_stmt|;
comment|/* Compute the marking for line I.  */
name|prefix
operator|=
literal|" "
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|next
operator|->
name|line0
operator|<=
name|i
condition|)
comment|/* The change NEXT covers this line. 	       If lines were inserted here in file 1, this is "changed". 	       Otherwise it is "deleted".  */
name|prefix
operator|=
operator|(
name|next
operator|->
name|inserted
operator|>
literal|0
condition|?
literal|"!"
else|:
literal|"-"
operator|)
expr_stmt|;
name|print_1_line
argument_list|(
name|prefix
argument_list|,
operator|&
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"--- "
argument_list|)
expr_stmt|;
name|print_context_number_range
argument_list|(
operator|&
name|files
index|[
literal|1
index|]
argument_list|,
name|first1
argument_list|,
name|last1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" ----\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_to
condition|)
block|{
name|next
operator|=
name|hunk
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first1
init|;
name|i
operator|<=
name|last1
condition|;
name|i
operator|++
control|)
block|{
comment|/* Skip past changes that apply (in file 1) 	     only to lines before line I.  */
while|while
condition|(
name|next
operator|&&
name|next
operator|->
name|line1
operator|+
name|next
operator|->
name|inserted
operator|<=
name|i
condition|)
name|next
operator|=
name|next
operator|->
name|link
expr_stmt|;
comment|/* Compute the marking for line I.  */
name|prefix
operator|=
literal|" "
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|next
operator|->
name|line1
operator|<=
name|i
condition|)
comment|/* The change NEXT covers this line. 	       If lines were deleted here in file 0, this is "changed". 	       Otherwise it is "inserted".  */
name|prefix
operator|=
operator|(
name|next
operator|->
name|deleted
operator|>
literal|0
condition|?
literal|"!"
else|:
literal|"+"
operator|)
expr_stmt|;
name|print_1_line
argument_list|(
name|prefix
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a pair of line numbers with a comma, translated for file FILE.    If the second number is smaller, use the first in place of it.    If the numbers are equal, print just one number.     Args A and B are internal line numbers.    We print the translated (real) line numbers.  */
end_comment

begin_function
specifier|static
name|void
name|print_unidiff_number_range
parameter_list|(
name|file
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|file_data
modifier|*
name|file
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|int
name|trans_a
decl_stmt|,
name|trans_b
decl_stmt|;
name|translate_range
argument_list|(
name|file
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|trans_a
argument_list|,
operator|&
name|trans_b
argument_list|)
expr_stmt|;
comment|/* Note: we can have B< A in the case of a range of no lines.      In this case, we should print the line number before the range,      which is B.  */
if|if
condition|(
name|trans_b
operator|<=
name|trans_a
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|trans_b
operator|==
name|trans_a
condition|?
literal|"%d"
else|:
literal|"%d,0"
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d,%d"
argument_list|,
name|trans_a
argument_list|,
name|trans_b
operator|-
name|trans_a
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a portion of an edit script in unidiff format.    HUNK is the beginning of the portion to be printed.    The end is marked by a `link' that has been nulled out.     Prints out lines from both files, and precedes each    line with the appropriate flag-character.  */
end_comment

begin_function
specifier|static
name|void
name|pr_unidiff_hunk
parameter_list|(
name|hunk
parameter_list|)
name|struct
name|change
modifier|*
name|hunk
decl_stmt|;
block|{
name|int
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|,
name|show_from
decl_stmt|,
name|show_to
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|struct
name|change
modifier|*
name|next
decl_stmt|;
name|int
name|lastline
decl_stmt|;
name|char
modifier|*
name|function
decl_stmt|;
name|int
name|function_length
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|,
operator|&
name|show_from
argument_list|,
operator|&
name|show_to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|show_from
operator|&&
operator|!
name|show_to
condition|)
return|return;
comment|/* Include a context's width before and after.  */
name|first0
operator|=
name|max
argument_list|(
name|first0
operator|-
name|context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|first1
operator|=
name|max
argument_list|(
name|first1
operator|-
name|context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last0
operator|=
name|min
argument_list|(
name|last0
operator|+
name|context
argument_list|,
name|files
index|[
literal|0
index|]
operator|.
name|buffered_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|last1
operator|=
name|min
argument_list|(
name|last1
operator|+
name|context
argument_list|,
name|files
index|[
literal|1
index|]
operator|.
name|buffered_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If desired, find the preceding function definition line in file 0.  */
name|function
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|function_regexp
condition|)
name|find_function
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|first0
argument_list|,
operator|&
name|function
argument_list|,
operator|&
name|function_length
argument_list|)
expr_stmt|;
comment|/* If we looked for and found a function this is part of,      include its name in the header of the diff section.  */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"@@ -"
argument_list|)
expr_stmt|;
name|print_unidiff_number_range
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|first0
argument_list|,
name|last0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" +"
argument_list|)
expr_stmt|;
name|print_unidiff_number_range
argument_list|(
operator|&
name|files
index|[
literal|1
index|]
argument_list|,
name|first1
argument_list|,
name|last1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" @@"
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|function
argument_list|,
literal|1
argument_list|,
name|min
argument_list|(
name|function_length
operator|-
literal|1
argument_list|,
literal|40
argument_list|)
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|next
operator|=
name|hunk
expr_stmt|;
name|i
operator|=
name|first0
expr_stmt|;
name|j
operator|=
name|first1
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|last0
operator|||
name|j
operator|<=
name|last1
condition|)
block|{
comment|/* If the line isn't a difference, output the context from file 0. */
if|if
condition|(
operator|!
name|next
operator|||
name|i
operator|<
name|next
operator|->
name|line0
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_1_line
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* For each difference, first output the deleted part. */
name|k
operator|=
name|next
operator|->
name|deleted
expr_stmt|;
while|while
condition|(
name|k
operator|--
condition|)
block|{
name|putc
argument_list|(
literal|'-'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_1_line
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Then output the inserted part. */
name|k
operator|=
name|next
operator|->
name|inserted
expr_stmt|;
while|while
condition|(
name|k
operator|--
condition|)
block|{
name|putc
argument_list|(
literal|'+'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_1_line
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|j
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* We're done with this hunk, so on to the next! */
name|next
operator|=
name|next
operator|->
name|link
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan a (forward-ordered) edit script for the first place that at least    2*CONTEXT unchanged lines appear, and return a pointer    to the `struct change' for the last change before those lines.  */
end_comment

begin_function
specifier|static
name|struct
name|change
modifier|*
name|find_hunk
parameter_list|(
name|start
parameter_list|)
name|struct
name|change
modifier|*
name|start
decl_stmt|;
block|{
name|struct
name|change
modifier|*
name|prev
decl_stmt|;
name|int
name|top0
decl_stmt|,
name|top1
decl_stmt|;
name|int
name|thresh
decl_stmt|;
do|do
block|{
comment|/* Computer number of first line in each file beyond this changed.  */
name|top0
operator|=
name|start
operator|->
name|line0
operator|+
name|start
operator|->
name|deleted
expr_stmt|;
name|top1
operator|=
name|start
operator|->
name|line1
operator|+
name|start
operator|->
name|inserted
expr_stmt|;
name|prev
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|start
operator|->
name|link
expr_stmt|;
comment|/* Threshold distance is 2*CONTEXT between two non-ignorable changes, 	 but only CONTEXT if one is ignorable.  */
name|thresh
operator|=
operator|(
operator|(
name|prev
operator|->
name|ignore
operator|||
operator|(
name|start
operator|&&
name|start
operator|->
name|ignore
operator|)
operator|)
condition|?
name|context
else|:
literal|2
operator|*
name|context
operator|)
expr_stmt|;
comment|/* It is not supposed to matter which file we check in the end-test. 	 If it would matter, crash.  */
if|if
condition|(
name|start
operator|&&
name|start
operator|->
name|line0
operator|-
name|top0
operator|!=
name|start
operator|->
name|line1
operator|-
name|top1
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|start
comment|/* Keep going if less than THRESH lines 		elapse before the affected line.  */
operator|&&
name|start
operator|->
name|line0
operator|<
name|top0
operator|+
name|thresh
condition|)
do|;
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Set the `ignore' flag properly in each change in SCRIPT.    It should be 1 if all the lines inserted or deleted in that change    are ignorable lines.  */
end_comment

begin_function
specifier|static
name|void
name|mark_ignorable
parameter_list|(
name|script
parameter_list|)
name|struct
name|change
modifier|*
name|script
decl_stmt|;
block|{
while|while
condition|(
name|script
condition|)
block|{
name|struct
name|change
modifier|*
name|next
init|=
name|script
operator|->
name|link
decl_stmt|;
name|int
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|,
name|deletes
decl_stmt|,
name|inserts
decl_stmt|;
comment|/* Turn this change into a hunk: detach it from the others.  */
name|script
operator|->
name|link
operator|=
literal|0
expr_stmt|;
comment|/* Determine whether this change is ignorable.  */
name|analyze_hunk
argument_list|(
name|script
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|,
operator|&
name|deletes
argument_list|,
operator|&
name|inserts
argument_list|)
expr_stmt|;
comment|/* Reconnect the chain as before.  */
name|script
operator|->
name|link
operator|=
name|next
expr_stmt|;
comment|/* If the change is ignorable, mark it.  */
name|script
operator|->
name|ignore
operator|=
operator|(
operator|!
name|deletes
operator|&&
operator|!
name|inserts
operator|)
expr_stmt|;
comment|/* Advance to the following change.  */
name|script
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the last function-header line in FILE prior to line number LINENUM.    This is a line containing a match for the regexp in `function_regexp'.    Store the address of the line text into LINEP and the length of the    line into LENP.    Do not store anything if no function-header is found.  */
end_comment

begin_function
specifier|static
name|void
name|find_function
parameter_list|(
name|file
parameter_list|,
name|linenum
parameter_list|,
name|linep
parameter_list|,
name|lenp
parameter_list|)
name|struct
name|file_data
modifier|*
name|file
decl_stmt|;
name|int
name|linenum
decl_stmt|;
name|char
modifier|*
modifier|*
name|linep
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
block|{
name|int
name|i
init|=
name|linenum
decl_stmt|;
name|int
name|last
init|=
name|find_function_last_search
decl_stmt|;
name|find_function_last_search
operator|=
name|i
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
name|last
condition|)
block|{
comment|/* See if this line is what we want.  */
if|if
condition|(
literal|0
operator|<=
name|re_search
argument_list|(
operator|&
name|function_regexp_compiled
argument_list|,
name|file
operator|->
name|linbuf
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|file
operator|->
name|linbuf
index|[
name|i
index|]
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|file
operator|->
name|linbuf
index|[
name|i
index|]
operator|.
name|length
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|linep
operator|=
name|file
operator|->
name|linbuf
index|[
name|i
index|]
operator|.
name|text
expr_stmt|;
operator|*
name|lenp
operator|=
name|file
operator|->
name|linbuf
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|find_function_last_match
operator|=
name|i
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we search back to where we started searching the previous time,      find the line we found last time.  */
if|if
condition|(
name|find_function_last_match
operator|>=
literal|0
condition|)
block|{
name|i
operator|=
name|find_function_last_match
expr_stmt|;
operator|*
name|linep
operator|=
name|file
operator|->
name|linbuf
index|[
name|i
index|]
operator|.
name|text
expr_stmt|;
operator|*
name|lenp
operator|=
name|file
operator|->
name|linbuf
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
return|return;
block|}
return|return;
block|}
end_function

end_unit

