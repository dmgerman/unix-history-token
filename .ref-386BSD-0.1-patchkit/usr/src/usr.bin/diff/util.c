begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for GNU DIFF.    Copyright (C) 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU DIFF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_comment
comment|/* Use when a system call returns non-zero status.    TEXT should normally be the file name.  */
end_comment

begin_function
name|void
name|perror_with_name
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use when a system call returns non-zero status and that is fatal.  */
end_comment

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|print_message_queue
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message from the format-string FORMAT    with args ARG1 and ARG2.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|format
parameter_list|,
name|arg
parameter_list|,
name|arg1
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message containing the string TEXT, then exit.  */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|message
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|print_message_queue
argument_list|()
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like printf, except if -l in effect then save the message and print later.    This is used for things like "binary files differ" and "Only in ...".  */
end_comment

begin_function
name|void
name|message
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|paginate_flag
condition|)
block|{
name|struct
name|msg
modifier|*
name|new
init|=
operator|(
expr|struct
name|msg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg_chain_end
operator|==
literal|0
condition|)
name|msg_chain
operator|=
name|msg_chain_end
operator|=
name|new
expr_stmt|;
else|else
block|{
name|msg_chain_end
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|msg_chain_end
operator|=
name|new
expr_stmt|;
block|}
name|new
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|new
operator|->
name|arg1
operator|=
name|concat
argument_list|(
name|arg1
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|new
operator|->
name|arg2
operator|=
name|concat
argument_list|(
name|arg2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Output all the messages that were saved up by calls to `message'.  */
end_comment

begin_function
name|void
name|print_message_queue
parameter_list|()
block|{
name|struct
name|msg
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|msg_chain
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
name|printf
argument_list|(
name|m
operator|->
name|format
argument_list|,
name|m
operator|->
name|arg1
argument_list|,
name|m
operator|->
name|arg2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call before outputting the results of comparing files NAME0 and NAME1    to set up OUTFILE, the stdio stream for the output to go to.     Usually, OUTFILE is just stdout.  But when -l was specified    we fork off a `pr' and make OUTFILE a pipe to it.    `pr' then outputs to our stdout.  */
end_comment

begin_function
name|void
name|setup_output
parameter_list|(
name|name0
parameter_list|,
name|name1
parameter_list|,
name|depth
parameter_list|)
name|char
modifier|*
name|name0
decl_stmt|,
decl|*
name|name1
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Construct the header of this piece of diff.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name0
argument_list|)
operator|+
name|strlen
argument_list|(
name|name1
argument_list|)
operator|+
name|strlen
argument_list|(
name|switch_string
argument_list|)
operator|+
literal|15
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"diff"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|switch_string
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|name0
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|name1
argument_list|)
expr_stmt|;
if|if
condition|(
name|paginate_flag
condition|)
block|{
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|desc
decl_stmt|;
comment|/* For a `pr' and make OUTFILE a pipe to it.  */
if|if
condition|(
name|pipe
argument_list|(
name|pipes
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|desc
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipes
index|[
literal|0
index|]
operator|!=
name|fileno
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|,
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|execl
argument_list|(
name|PR_FILE_NAME
argument_list|,
name|PR_FILE_NAME
argument_list|,
literal|"-f"
argument_list|,
literal|"-h"
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|PR_FILE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|fdopen
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If -l was not specified, output the diff straight to `stdout'.  */
name|outfile
operator|=
name|stdout
expr_stmt|;
comment|/* If handling multiple files (because scanning a directory), 	 print which files the following output is about.  */
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Call after the end of output of diffs for one file.    Close OUTFILE and get rid of the `pr' subfork.  */
end_comment

begin_function
name|void
name|finish_output
parameter_list|()
block|{
if|if
condition|(
name|outfile
operator|!=
name|stdout
condition|)
block|{
name|fclose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two lines (typically one from each input file)    according to the command line options.    Each line is described by a `struct line_def'.    Return 1 if the lines differ, like `bcmp'.  */
end_comment

begin_function
name|int
name|line_cmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|struct
name|line_def
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
specifier|register
name|char
name|end_char
init|=
name|line_end_char
decl_stmt|;
name|int
name|savechar
decl_stmt|;
comment|/* Check first for exact identity.      If that is true, return 0 immediately.      This detects the common case of exact identity      faster than complete comparison would.  */
name|t1
operator|=
name|s1
operator|->
name|text
expr_stmt|;
name|t2
operator|=
name|s2
operator|->
name|text
expr_stmt|;
comment|/* Alter the character following line 2 so it doesn't      match that following line 1.      (We used to alter the character after line 1,      but that caused trouble if line 2 directly follows line 1.)  */
name|savechar
operator|=
name|s2
operator|->
name|text
index|[
name|s2
operator|->
name|length
index|]
expr_stmt|;
name|s2
operator|->
name|text
index|[
name|s2
operator|->
name|length
index|]
operator|=
name|s1
operator|->
name|text
index|[
name|s1
operator|->
name|length
index|]
operator|+
literal|1
expr_stmt|;
comment|/* Now find the first mismatch; this won't go past the      character we just changed.  */
while|while
condition|(
operator|*
name|t1
operator|++
operator|==
operator|*
name|t2
operator|++
condition|)
empty_stmt|;
comment|/* Undo the alteration.  */
name|s2
operator|->
name|text
index|[
name|s2
operator|->
name|length
index|]
operator|=
name|savechar
expr_stmt|;
comment|/* If the comparison stopped at the alteration,      the two lines are identical.  */
if|if
condition|(
name|t2
operator|==
name|s2
operator|->
name|text
operator|+
name|s2
operator|->
name|length
operator|+
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Not exactly identical, but perhaps they match anyway      when case or whitespace is ignored.  */
if|if
condition|(
name|ignore_case_flag
operator|||
name|ignore_space_change_flag
operator|||
name|ignore_all_space_flag
condition|)
block|{
name|t1
operator|=
name|s1
operator|->
name|text
expr_stmt|;
name|t2
operator|=
name|s2
operator|->
name|text
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|char
name|c1
init|=
operator|*
name|t1
operator|++
decl_stmt|;
specifier|register
name|char
name|c2
init|=
operator|*
name|t2
operator|++
decl_stmt|;
comment|/* Ignore horizontal whitespace if -b or -w is specified.  */
if|if
condition|(
name|ignore_all_space_flag
condition|)
block|{
comment|/* For -w, just skip past any spaces or tabs.  */
while|while
condition|(
name|c1
operator|==
literal|' '
operator|||
name|c1
operator|==
literal|'\t'
condition|)
name|c1
operator|=
operator|*
name|t1
operator|++
expr_stmt|;
while|while
condition|(
name|c2
operator|==
literal|' '
operator|||
name|c2
operator|==
literal|'\t'
condition|)
name|c2
operator|=
operator|*
name|t2
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ignore_space_change_flag
condition|)
block|{
comment|/* For -b, advance past any sequence of whitespace in line 1 		 and consider it just one Space, or nothing at all 		 if it is at the end of the line.  */
if|if
condition|(
name|c1
operator|==
literal|' '
operator|||
name|c1
operator|==
literal|'\t'
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|c1
operator|=
operator|*
name|t1
operator|++
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|end_char
condition|)
break|break;
if|if
condition|(
name|c1
operator|!=
literal|' '
operator|&&
name|c1
operator|!=
literal|'\t'
condition|)
block|{
operator|--
name|t1
expr_stmt|;
name|c1
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Likewise for line 2.  */
if|if
condition|(
name|c2
operator|==
literal|' '
operator|||
name|c2
operator|==
literal|'\t'
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|c2
operator|=
operator|*
name|t2
operator|++
expr_stmt|;
if|if
condition|(
name|c2
operator|==
name|end_char
condition|)
break|break;
if|if
condition|(
name|c2
operator|!=
literal|' '
operator|&&
name|c2
operator|!=
literal|'\t'
condition|)
block|{
operator|--
name|t2
expr_stmt|;
name|c2
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Upcase all letters if -i is specified.  */
if|if
condition|(
name|ignore_case_flag
condition|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|c1
argument_list|)
condition|)
name|c1
operator|=
name|toupper
argument_list|(
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|c2
argument_list|)
condition|)
name|c2
operator|=
name|toupper
argument_list|(
name|c2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
if|if
condition|(
name|c1
operator|==
name|end_char
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Find the consecutive changes at the start of the script START.    Return the last link before the first gap.  */
end_comment

begin_function
name|struct
name|change
modifier|*
name|find_change
parameter_list|(
name|start
parameter_list|)
name|struct
name|change
modifier|*
name|start
decl_stmt|;
block|{
return|return
name|start
return|;
block|}
end_function

begin_function
name|struct
name|change
modifier|*
name|find_reverse_change
parameter_list|(
name|start
parameter_list|)
name|struct
name|change
modifier|*
name|start
decl_stmt|;
block|{
return|return
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Divide SCRIPT into pieces by calling HUNKFUN and    print each piece with PRINTFUN.    Both functions take one arg, an edit script.     HUNKFUN is called with the tail of the script    and returns the last link that belongs together with the start    of the tail.     PRINTFUN takes a subscript which belongs together (with a null    link at the end) and prints it.  */
end_comment

begin_decl_stmt
name|void
name|print_script
argument_list|(
name|script
argument_list|,
name|hunkfun
argument_list|,
name|printfun
argument_list|)
decl|struct
name|change
modifier|*
name|script
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|change
modifier|*
function_decl|(
modifier|*
name|hunkfun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|printfun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|change
modifier|*
name|next
init|=
name|script
decl_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|struct
name|change
modifier|*
name|this
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* Find a set of changes that belong together.  */
name|this
operator|=
name|next
expr_stmt|;
name|end
operator|=
call|(
modifier|*
name|hunkfun
call|)
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Disconnect them from the rest of the changes, 	 making them a hunk, and remember the rest for next iteration.  */
name|next
operator|=
name|end
operator|->
name|link
expr_stmt|;
name|end
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug_script
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Print this hunk.  */
call|(
modifier|*
name|printfun
call|)
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|/* Reconnect the script so it will all be freed properly.  */
name|end
operator|->
name|link
operator|=
name|next
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Print the text of a single line LINE,    flagging it with the characters in LINE_FLAG (which say whether    the line is inserted, deleted, changed, etc.).  */
end_comment

begin_function
name|void
name|print_1_line
parameter_list|(
name|line_flag
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|line_flag
decl_stmt|;
name|struct
name|line_def
modifier|*
name|line
decl_stmt|;
block|{
name|int
name|length
init|=
name|line
operator|->
name|length
decl_stmt|;
comment|/* must be nonzero */
specifier|const
name|char
modifier|*
name|text
init|=
name|line
operator|->
name|text
decl_stmt|;
comment|/* Help the compiler.  */
name|FILE
modifier|*
name|out
init|=
name|outfile
decl_stmt|;
comment|/* Help the compiler some more.  */
comment|/* If -T was specified, use a Tab between the line-flag and the text.      Otherwise use a Space (as Unix diff does).      Print neither space nor tab if line-flags are empty.  */
if|if
condition|(
name|line_flag
operator|!=
name|NULL
operator|&&
name|line_flag
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
name|tab_align_flag
condition|?
literal|"%s\t"
else|:
literal|"%s "
argument_list|,
name|line_flag
argument_list|)
expr_stmt|;
comment|/* Now output the contents of the line.      If -t was specified, expand tabs to spaces.      Otherwise output verbatim.  */
if|if
condition|(
name|tab_expand_flag
condition|)
block|{
specifier|register
name|int
name|column
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|line
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|char
name|c
init|=
name|line
operator|->
name|text
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
name|column
operator|++
expr_stmt|;
while|while
condition|(
name|column
operator|&
literal|7
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
name|c
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|column
operator|--
expr_stmt|;
break|break;
default|default:
name|column
operator|++
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fwrite
argument_list|(
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|length
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|line_flag
operator|==
name|NULL
operator|||
name|line_flag
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
operator|&&
name|text
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|&&
name|line_end_char
operator|==
literal|'\n'
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n\\ No newline at end of file\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|change_letter
argument_list|(
argument|inserts
argument_list|,
argument|deletes
argument_list|)
end_macro

begin_decl_stmt
name|int
name|inserts
decl_stmt|,
name|deletes
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|inserts
condition|)
return|return
literal|'d'
return|;
elseif|else
if|if
condition|(
operator|!
name|deletes
condition|)
return|return
literal|'a'
return|;
else|else
return|return
literal|'c'
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Translate an internal line number (an index into diff's table of lines)    into an actual line number in the input file.    The internal line number is LNUM.  FILE points to the data on the file.     Internal line numbers count from 0 within the current chunk.    Actual line numbers count from 1 within the entire file;    in addition, they include lines ignored for comparison purposes.     The `ltran' feature is no longer in use.  */
end_comment

begin_function
name|int
name|translate_line_number
parameter_list|(
name|file
parameter_list|,
name|lnum
parameter_list|)
name|struct
name|file_data
modifier|*
name|file
decl_stmt|;
name|int
name|lnum
decl_stmt|;
block|{
return|return
name|lnum
operator|+
literal|1
return|;
block|}
end_function

begin_function
name|void
name|translate_range
parameter_list|(
name|file
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|aptr
parameter_list|,
name|bptr
parameter_list|)
name|struct
name|file_data
modifier|*
name|file
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|int
modifier|*
name|aptr
decl_stmt|,
decl|*
name|bptr
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|aptr
operator|=
name|translate_line_number
argument_list|(
name|file
argument_list|,
name|a
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|bptr
operator|=
name|translate_line_number
argument_list|(
name|file
argument_list|,
name|b
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print a pair of line numbers with SEPCHAR, translated for file FILE.    If the two numbers are identical, print just one number.     Args A and B are internal line numbers.    We print the translated (real) line numbers.  */
end_comment

begin_function
name|void
name|print_number_range
parameter_list|(
name|sepchar
parameter_list|,
name|file
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
name|char
name|sepchar
decl_stmt|;
name|struct
name|file_data
modifier|*
name|file
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|int
name|trans_a
decl_stmt|,
name|trans_b
decl_stmt|;
name|translate_range
argument_list|(
name|file
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|trans_a
argument_list|,
operator|&
name|trans_b
argument_list|)
expr_stmt|;
comment|/* Note: we can have B< A in the case of a range of no lines.      In this case, we should print the line number before the range,      which is B.  */
if|if
condition|(
name|trans_b
operator|>
name|trans_a
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d%c%d"
argument_list|,
name|trans_a
argument_list|,
name|sepchar
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d"
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a hunk of edit script and report the range of lines in each file    that it applies to.  HUNK is the start of the hunk, which is a chain    of `struct change'.  The first and last line numbers of file 0 are stored in    *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.     Note that these are internal line numbers that count from 0.     If no lines from file 0 are deleted, then FIRST0 is LAST0+1.     Also set *DELETES nonzero if any lines of file 0 are deleted    and set *INSERTS nonzero if any lines of file 1 are inserted.    If only ignorable lines are inserted or deleted, both are    set to 0.  */
end_comment

begin_function
name|void
name|analyze_hunk
parameter_list|(
name|hunk
parameter_list|,
name|first0
parameter_list|,
name|last0
parameter_list|,
name|first1
parameter_list|,
name|last1
parameter_list|,
name|deletes
parameter_list|,
name|inserts
parameter_list|)
name|struct
name|change
modifier|*
name|hunk
decl_stmt|;
name|int
modifier|*
name|first0
decl_stmt|,
decl|*
name|last0
decl_stmt|,
modifier|*
name|first1
decl_stmt|,
modifier|*
name|last1
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|deletes
decl_stmt|,
modifier|*
name|inserts
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|f0
decl_stmt|,
name|l0
decl_stmt|,
name|f1
decl_stmt|,
name|l1
decl_stmt|,
name|show_from
decl_stmt|,
name|show_to
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nontrivial
init|=
operator|!
operator|(
name|ignore_blank_lines_flag
operator|||
name|ignore_regexp
operator|)
decl_stmt|;
name|struct
name|change
modifier|*
name|next
decl_stmt|;
name|show_from
operator|=
name|show_to
operator|=
literal|0
expr_stmt|;
name|f0
operator|=
name|hunk
operator|->
name|line0
expr_stmt|;
name|f1
operator|=
name|hunk
operator|->
name|line1
expr_stmt|;
for|for
control|(
name|next
operator|=
name|hunk
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|link
control|)
block|{
name|l0
operator|=
name|next
operator|->
name|line0
operator|+
name|next
operator|->
name|deleted
operator|-
literal|1
expr_stmt|;
name|l1
operator|=
name|next
operator|->
name|line1
operator|+
name|next
operator|->
name|inserted
operator|-
literal|1
expr_stmt|;
name|show_from
operator|+=
name|next
operator|->
name|deleted
expr_stmt|;
name|show_to
operator|+=
name|next
operator|->
name|inserted
expr_stmt|;
for|for
control|(
name|i
operator|=
name|next
operator|->
name|line0
init|;
name|i
operator|<=
name|l0
operator|&&
operator|!
name|nontrivial
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|!
name|ignore_blank_lines_flag
operator|||
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
index|]
operator|.
name|length
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|!
name|ignore_regexp
operator|||
literal|0
operator|>
name|re_search
argument_list|(
operator|&
name|ignore_regexp_compiled
argument_list|,
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
index|]
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
index|]
operator|.
name|length
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|nontrivial
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|next
operator|->
name|line1
init|;
name|i
operator|<=
name|l1
operator|&&
operator|!
name|nontrivial
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|!
name|ignore_blank_lines_flag
operator|||
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
operator|.
name|length
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|!
name|ignore_regexp
operator|||
literal|0
operator|>
name|re_search
argument_list|(
operator|&
name|ignore_regexp_compiled
argument_list|,
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
operator|.
name|length
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|nontrivial
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|first0
operator|=
name|f0
expr_stmt|;
operator|*
name|last0
operator|=
name|l0
expr_stmt|;
operator|*
name|first1
operator|=
name|f1
expr_stmt|;
operator|*
name|last1
operator|=
name|l1
expr_stmt|;
comment|/* If all inserted or deleted lines are ignorable,      tell the caller to ignore this hunk.  */
if|if
condition|(
operator|!
name|nontrivial
condition|)
name|show_from
operator|=
name|show_to
operator|=
literal|0
expr_stmt|;
operator|*
name|deletes
operator|=
name|show_from
expr_stmt|;
operator|*
name|inserts
operator|=
name|show_to
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* malloc a block of memory, with fatal error message if we can't do it. */
end_comment

begin_function
name|VOID
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|VOID
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|value
operator|=
operator|(
name|VOID
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* realloc a block of memory, with fatal error message if we can't do it. */
end_comment

begin_function
name|VOID
modifier|*
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|VOID
modifier|*
name|old
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|VOID
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|value
operator|=
operator|(
name|VOID
operator|*
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Concatenate three strings, returning a newly malloc'd string.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|s3
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|debug_script
argument_list|(
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|change
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3d %3d delete %d insert %d\n"
argument_list|,
name|sp
operator|->
name|line0
argument_list|,
name|sp
operator|->
name|line1
argument_list|,
name|sp
operator|->
name|deleted
argument_list|,
name|sp
operator|->
name|inserted
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

