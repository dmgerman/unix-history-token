begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** rexp1.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/*$Log:	rexp1.c,v $  * Revision 3.4  92/02/20  16:08:12  brennan  * change new_TWO() to work around sun acc bug  *   * Revision 3.3  91/10/29  10:54:01  brennan  * SIZE_T  *   * Revision 3.2  91/08/13  09:10:11  brennan  * VERSION .9994  *   * Revision 3.1  91/06/07  10:33:22  brennan  * VERSION 0.995  *  */
end_comment

begin_comment
comment|/*  re machine  operations  */
end_comment

begin_include
include|#
directive|include
file|"rexp.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|new_TWO
argument_list|,
operator|(
name|int
operator|,
name|MACHINE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialize a two state machine */
end_comment

begin_function
specifier|static
name|void
name|new_TWO
parameter_list|(
name|type
parameter_list|,
name|mp
parameter_list|)
name|int
name|type
decl_stmt|;
name|MACHINE
modifier|*
name|mp
decl_stmt|;
comment|/* init mp-> */
block|{
name|mp
operator|->
name|start
operator|=
operator|(
name|STATE
operator|*
operator|)
name|RE_malloc
argument_list|(
literal|2
operator|*
name|STATESZ
argument_list|)
expr_stmt|;
name|mp
operator|->
name|stop
operator|=
name|mp
operator|->
name|start
operator|+
literal|1
expr_stmt|;
name|mp
operator|->
name|start
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|mp
operator|->
name|stop
operator|->
name|type
operator|=
name|M_ACCEPT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  build a machine that recognizes any  */
end_comment

begin_function
name|MACHINE
name|RE_any
parameter_list|()
block|{
name|MACHINE
name|x
decl_stmt|;
name|new_TWO
argument_list|(
name|M_ANY
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/*  build a machine that recognizes the start of string  */
end_comment

begin_function
name|MACHINE
name|RE_start
parameter_list|()
block|{
name|MACHINE
name|x
decl_stmt|;
name|new_TWO
argument_list|(
name|M_START
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|MACHINE
name|RE_end
parameter_list|()
block|{
name|MACHINE
name|x
decl_stmt|;
name|new_TWO
argument_list|(
name|M_END
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/*  build a machine that recognizes a class  */
end_comment

begin_function
name|MACHINE
name|RE_class
parameter_list|(
name|bvp
parameter_list|)
name|BV
modifier|*
name|bvp
decl_stmt|;
block|{
name|MACHINE
name|x
decl_stmt|;
name|new_TWO
argument_list|(
name|M_CLASS
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|x
operator|.
name|start
operator|->
name|data
operator|.
name|bvp
operator|=
name|bvp
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|MACHINE
name|RE_u
parameter_list|()
block|{
name|MACHINE
name|x
decl_stmt|;
name|new_TWO
argument_list|(
name|M_U
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|MACHINE
name|RE_str
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|MACHINE
name|x
decl_stmt|;
name|new_TWO
argument_list|(
name|M_STR
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|x
operator|.
name|start
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|x
operator|.
name|start
operator|->
name|data
operator|.
name|str
operator|=
name|str
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/*  replace m and n by a machine that recognizes  mn   */
end_comment

begin_function
name|void
name|RE_cat
parameter_list|(
name|mp
parameter_list|,
name|np
parameter_list|)
name|MACHINE
modifier|*
name|mp
decl_stmt|,
decl|*
name|np
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|sz1
decl_stmt|,
name|sz2
decl_stmt|,
name|sz
decl_stmt|;
name|sz1
operator|=
name|mp
operator|->
name|stop
operator|-
name|mp
operator|->
name|start
expr_stmt|;
name|sz2
operator|=
name|np
operator|->
name|stop
operator|-
name|np
operator|->
name|start
operator|+
literal|1
expr_stmt|;
name|sz
operator|=
name|sz1
operator|+
name|sz2
expr_stmt|;
name|mp
operator|->
name|start
operator|=
operator|(
name|STATE
operator|*
operator|)
name|RE_realloc
argument_list|(
name|mp
operator|->
name|start
argument_list|,
name|sz
operator|*
name|STATESZ
argument_list|)
expr_stmt|;
name|mp
operator|->
name|stop
operator|=
name|mp
operator|->
name|start
operator|+
operator|(
name|sz
operator|-
literal|1
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|mp
operator|->
name|start
operator|+
name|sz1
argument_list|,
name|np
operator|->
name|start
argument_list|,
name|SIZE_T
argument_list|(
name|sz2
operator|*
name|STATESZ
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  replace m by a machine that recognizes m|n  */
end_comment

begin_function
name|void
name|RE_or
parameter_list|(
name|mp
parameter_list|,
name|np
parameter_list|)
name|MACHINE
modifier|*
name|mp
decl_stmt|,
decl|*
name|np
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|STATE
modifier|*
name|p
decl_stmt|;
name|unsigned
name|szm
decl_stmt|,
name|szn
decl_stmt|;
name|szm
operator|=
name|mp
operator|->
name|stop
operator|-
name|mp
operator|->
name|start
operator|+
literal|1
expr_stmt|;
name|szn
operator|=
name|np
operator|->
name|stop
operator|-
name|np
operator|->
name|start
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|STATE
operator|*
operator|)
name|RE_malloc
argument_list|(
operator|(
name|szm
operator|+
name|szn
operator|+
literal|1
operator|)
operator|*
name|STATESZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|mp
operator|->
name|start
argument_list|,
name|SIZE_T
argument_list|(
name|szm
operator|*
name|STATESZ
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
operator|->
name|start
argument_list|)
expr_stmt|;
name|mp
operator|->
name|start
operator|=
name|p
expr_stmt|;
operator|(
name|mp
operator|->
name|stop
operator|=
name|p
operator|+
name|szm
operator|+
name|szn
operator|)
operator|->
name|type
operator|=
name|M_ACCEPT
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|M_2JA
expr_stmt|;
name|p
operator|->
name|data
operator|.
name|jump
operator|=
name|szm
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
operator|+
name|szm
operator|+
literal|1
argument_list|,
name|np
operator|->
name|start
argument_list|,
name|SIZE_T
argument_list|(
name|szn
operator|*
name|STATESZ
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
operator|->
name|start
argument_list|)
expr_stmt|;
operator|(
name|p
operator|+=
name|szm
operator|)
operator|->
name|type
operator|=
name|M_1J
expr_stmt|;
name|p
operator|->
name|data
operator|.
name|jump
operator|=
name|szn
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  UNARY  OPERATIONS     */
end_comment

begin_comment
comment|/*  replace m by m*   */
end_comment

begin_function
name|void
name|RE_close
parameter_list|(
name|mp
parameter_list|)
name|MACHINE
modifier|*
name|mp
decl_stmt|;
block|{
specifier|register
name|STATE
modifier|*
name|p
decl_stmt|;
name|unsigned
name|sz
decl_stmt|;
name|sz
operator|=
name|mp
operator|->
name|stop
operator|-
name|mp
operator|->
name|start
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|STATE
operator|*
operator|)
name|RE_malloc
argument_list|(
operator|(
name|sz
operator|+
literal|2
operator|)
operator|*
name|STATESZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|mp
operator|->
name|start
argument_list|,
name|SIZE_T
argument_list|(
name|sz
operator|*
name|STATESZ
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
operator|->
name|start
argument_list|)
expr_stmt|;
name|mp
operator|->
name|start
operator|=
name|p
expr_stmt|;
name|mp
operator|->
name|stop
operator|=
name|p
operator|+
operator|(
name|sz
operator|+
literal|1
operator|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|M_2JA
expr_stmt|;
name|p
operator|->
name|data
operator|.
name|jump
operator|=
name|sz
operator|+
literal|1
expr_stmt|;
operator|(
name|p
operator|+=
name|sz
operator|)
operator|->
name|type
operator|=
name|M_2JB
expr_stmt|;
name|p
operator|->
name|data
operator|.
name|jump
operator|=
operator|-
operator|(
name|sz
operator|-
literal|1
operator|)
expr_stmt|;
operator|(
name|p
operator|+
literal|1
operator|)
operator|->
name|type
operator|=
name|M_ACCEPT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  replace m  by  m+  (positive closure)   */
end_comment

begin_function
name|void
name|RE_poscl
parameter_list|(
name|mp
parameter_list|)
name|MACHINE
modifier|*
name|mp
decl_stmt|;
block|{
specifier|register
name|STATE
modifier|*
name|p
decl_stmt|;
name|unsigned
name|sz
decl_stmt|;
name|sz
operator|=
name|mp
operator|->
name|stop
operator|-
name|mp
operator|->
name|start
operator|+
literal|1
expr_stmt|;
name|mp
operator|->
name|start
operator|=
name|p
operator|=
operator|(
name|STATE
operator|*
operator|)
name|RE_realloc
argument_list|(
name|mp
operator|->
name|start
argument_list|,
operator|(
name|sz
operator|+
literal|1
operator|)
operator|*
name|STATESZ
argument_list|)
expr_stmt|;
name|mp
operator|->
name|stop
operator|=
name|p
operator|+
name|sz
expr_stmt|;
name|p
operator|+=
operator|--
name|sz
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|M_2JB
expr_stmt|;
name|p
operator|->
name|data
operator|.
name|jump
operator|=
operator|-
name|sz
expr_stmt|;
operator|(
name|p
operator|+
literal|1
operator|)
operator|->
name|type
operator|=
name|M_ACCEPT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* replace  m  by  m? (zero or one)  */
end_comment

begin_function
name|void
name|RE_01
parameter_list|(
name|mp
parameter_list|)
name|MACHINE
modifier|*
name|mp
decl_stmt|;
block|{
name|unsigned
name|sz
decl_stmt|;
specifier|register
name|STATE
modifier|*
name|p
decl_stmt|;
name|sz
operator|=
name|mp
operator|->
name|stop
operator|-
name|mp
operator|->
name|start
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|STATE
operator|*
operator|)
name|RE_malloc
argument_list|(
operator|(
name|sz
operator|+
literal|1
operator|)
operator|*
name|STATESZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|mp
operator|->
name|start
argument_list|,
name|SIZE_T
argument_list|(
name|sz
operator|*
name|STATESZ
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
operator|->
name|start
argument_list|)
expr_stmt|;
name|mp
operator|->
name|start
operator|=
name|p
expr_stmt|;
name|mp
operator|->
name|stop
operator|=
name|p
operator|+
name|sz
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|M_2JB
expr_stmt|;
name|p
operator|->
name|data
operator|.
name|jump
operator|=
name|sz
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=================================== MEMORY  ALLOCATION  *==============================*/
end_comment

begin_function
name|VOID
modifier|*
name|RE_malloc
parameter_list|(
name|sz
parameter_list|)
name|unsigned
name|sz
decl_stmt|;
block|{
specifier|register
name|VOID
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|malloc
argument_list|(
name|SIZE_T
argument_list|(
name|sz
argument_list|)
argument_list|)
operator|)
condition|)
name|RE_error_trap
argument_list|(
name|MEMORY_FAILURE
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|VOID
modifier|*
name|RE_realloc
parameter_list|(
name|p
parameter_list|,
name|sz
parameter_list|)
specifier|register
name|VOID
modifier|*
name|p
decl_stmt|;
name|unsigned
name|sz
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|SIZE_T
argument_list|(
name|sz
argument_list|)
argument_list|)
operator|)
condition|)
name|RE_error_trap
argument_list|(
name|MEMORY_FAILURE
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

end_unit

