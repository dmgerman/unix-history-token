begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** array.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/* $Log:	array.c,v $  * Revision 5.1  91/12/05  07:55:32  brennan  * 1.1 pre-release  *  */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"symtype.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"field.h"
end_include

begin_include
include|#
directive|include
file|"bi_vars.h"
end_include

begin_comment
comment|/* convert doubles to string for array indexing */
end_comment

begin_define
define|#
directive|define
name|NO_MOVE
value|2
end_define

begin_define
define|#
directive|define
name|NO_IVAL
value|(-1)
end_define

begin_decl_stmt
specifier|static
name|ANODE
modifier|*
name|PROTO
argument_list|(
name|find_by_sval
argument_list|,
operator|(
name|ARRAY
operator|,
name|STRING
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ANODE
modifier|*
name|PROTO
argument_list|(
name|find_by_index
argument_list|,
operator|(
name|ARRAY
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ANODE
modifier|*
name|PROTO
argument_list|(
name|find_by_dval
argument_list|,
operator|(
name|ARRAY
operator|,
name|double
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|load_array_ov
argument_list|,
operator|(
name|ARRAY
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|unsigned
name|hash
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* An array A is a pointer to an array of struct array,    which is two hash tables in one.  One for strings    and one for non-negative integers (this is much simplier    and works just as well as previous versions)     Each array is of size A_HASH_PRIME.     When an index is deleted via  delete A[i], the    ANODE is not removed from the hash chain.  A[i].cp    and A[i].sval are both freed and sval is set NULL.    This method of deletion simplifies for( i in A ) loops.  */
end_comment

begin_function
specifier|static
name|ANODE
modifier|*
name|find_by_sval
parameter_list|(
name|A
parameter_list|,
name|sval
parameter_list|,
name|cflag
parameter_list|)
name|ARRAY
name|A
decl_stmt|;
name|STRING
modifier|*
name|sval
decl_stmt|;
name|int
name|cflag
decl_stmt|;
comment|/* create if on */
block|{
name|char
modifier|*
name|s
init|=
name|sval
operator|->
name|str
decl_stmt|;
name|unsigned
name|h
init|=
name|hash
argument_list|(
name|s
argument_list|)
operator|%
name|A_HASH_PRIME
decl_stmt|;
specifier|register
name|ANODE
modifier|*
name|p
init|=
name|A
index|[
name|h
index|]
operator|.
name|link
decl_stmt|;
name|ANODE
modifier|*
name|q
init|=
literal|0
decl_stmt|;
comment|/* holds first deleted ANODE */
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|sval
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|sval
operator|->
name|str
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
block|}
elseif|else
comment|/* its deleted, mark with q */
if|if
condition|(
operator|!
name|q
condition|)
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
comment|/* not there */
if|if
condition|(
name|cflag
condition|)
block|{
if|if
condition|(
name|q
condition|)
name|p
operator|=
name|q
expr_stmt|;
comment|/* reuse the deleted node q */
else|else
block|{
name|p
operator|=
operator|(
name|ANODE
operator|*
operator|)
name|zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ANODE
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|link
operator|=
name|A
index|[
name|h
index|]
operator|.
name|link
expr_stmt|;
name|A
index|[
name|h
index|]
operator|.
name|link
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|->
name|ival
operator|=
name|NO_IVAL
expr_stmt|;
name|p
operator|->
name|sval
operator|=
name|sval
expr_stmt|;
name|sval
operator|->
name|ref_cnt
operator|++
expr_stmt|;
name|p
operator|->
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|cp
operator|->
name|type
operator|=
name|C_NOINIT
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|ANODE
modifier|*
name|find_by_index
parameter_list|(
name|A
parameter_list|,
name|index
parameter_list|,
name|ival
parameter_list|,
name|flag
parameter_list|)
name|ARRAY
name|A
decl_stmt|;
name|int
name|index
decl_stmt|,
name|ival
decl_stmt|,
name|flag
decl_stmt|;
block|{
specifier|register
name|ANODE
modifier|*
name|p
init|=
name|A
index|[
name|index
index|]
operator|.
name|ilink
decl_stmt|;
name|ANODE
modifier|*
name|q
init|=
literal|0
decl_stmt|;
comment|/* trails p */
while|while
condition|(
name|p
condition|)
if|if
condition|(
name|p
operator|->
name|ival
operator|==
name|ival
condition|)
comment|/* found */
if|if
condition|(
operator|!
name|q
operator|||
name|flag
operator|==
name|NO_MOVE
condition|)
return|return
name|p
return|;
else|else
comment|/* delete to put at front */
block|{
name|q
operator|->
name|ilink
operator|=
name|p
operator|->
name|ilink
expr_stmt|;
goto|goto
name|found
goto|;
block|}
else|else
block|{
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|ilink
expr_stmt|;
block|}
comment|/* not there, still need to look by sval */
block|{
name|char
name|xbuff
index|[
literal|16
index|]
decl_stmt|;
name|STRING
modifier|*
name|sval
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|xbuff
operator|+
literal|14
decl_stmt|;
name|int
name|x
init|=
name|ival
decl_stmt|;
name|xbuff
index|[
literal|15
index|]
operator|=
literal|0
expr_stmt|;
do|do
block|{
operator|*
name|s
operator|--
operator|=
name|x
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|x
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|x
condition|)
do|;
name|sval
operator|=
name|new_STRING
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|find_by_sval
argument_list|(
name|A
argument_list|,
name|sval
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|sval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
name|ANODE
operator|*
operator|)
literal|0
return|;
name|p
operator|->
name|ival
operator|=
name|ival
expr_stmt|;
name|found
label|:
comment|/* put p at front */
name|p
operator|->
name|ilink
operator|=
name|A
index|[
name|index
index|]
operator|.
name|ilink
expr_stmt|;
name|A
index|[
name|index
index|]
operator|.
name|ilink
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|ANODE
modifier|*
name|find_by_dval
parameter_list|(
name|A
parameter_list|,
name|d
parameter_list|,
name|flag
parameter_list|)
name|ARRAY
name|A
decl_stmt|;
name|double
name|d
decl_stmt|;
block|{
name|int
name|ival
decl_stmt|;
name|ANODE
modifier|*
name|p
decl_stmt|;
name|char
name|xbuff
index|[
literal|260
index|]
decl_stmt|;
name|STRING
modifier|*
name|sval
decl_stmt|;
if|if
condition|(
call|(
name|double
call|)
argument_list|(
name|ival
operator|=
operator|(
name|int
operator|)
name|d
argument_list|)
operator|==
name|d
condition|)
comment|/* integer valued */
block|{
if|if
condition|(
name|ival
operator|>=
literal|0
condition|)
return|return
name|find_by_index
argument_list|(
name|A
argument_list|,
name|ival
operator|%
name|A_HASH_PRIME
argument_list|,
name|ival
argument_list|,
name|flag
argument_list|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xbuff
argument_list|,
literal|"%d"
argument_list|,
name|ival
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xbuff
argument_list|,
name|string
argument_list|(
name|CONVFMT
argument_list|)
operator|->
name|str
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|sval
operator|=
name|new_STRING
argument_list|(
name|xbuff
argument_list|)
expr_stmt|;
name|p
operator|=
name|find_by_sval
argument_list|(
name|A
argument_list|,
name|sval
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|sval
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|CELL
modifier|*
name|array_find
parameter_list|(
name|A
parameter_list|,
name|cp
parameter_list|,
name|create_flag
parameter_list|)
name|ARRAY
name|A
decl_stmt|;
name|CELL
modifier|*
name|cp
decl_stmt|;
name|int
name|create_flag
decl_stmt|;
block|{
name|ANODE
modifier|*
name|ap
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_DOUBLE
case|:
name|ap
operator|=
name|find_by_dval
argument_list|(
name|A
argument_list|,
name|cp
operator|->
name|dval
argument_list|,
name|create_flag
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_NOINIT
case|:
name|ap
operator|=
name|find_by_sval
argument_list|(
name|A
argument_list|,
operator|&
name|null_str
argument_list|,
name|create_flag
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|ap
operator|=
name|find_by_sval
argument_list|(
name|A
argument_list|,
name|string
argument_list|(
name|cp
argument_list|)
argument_list|,
name|create_flag
argument_list|)
expr_stmt|;
break|break ;
block|}
return|return
name|ap
condition|?
name|ap
operator|->
name|cp
else|:
operator|(
name|CELL
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|void
name|array_delete
parameter_list|(
name|A
parameter_list|,
name|cp
parameter_list|)
name|ARRAY
name|A
decl_stmt|;
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
name|ANODE
modifier|*
name|ap
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_DOUBLE
case|:
name|ap
operator|=
name|find_by_dval
argument_list|(
name|A
argument_list|,
name|cp
operator|->
name|dval
argument_list|,
name|NO_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|&&
name|ap
operator|->
name|ival
operator|>=
literal|0
condition|)
comment|/* must be at front */
name|A
index|[
name|ap
operator|->
name|ival
operator|%
name|A_HASH_PRIME
index|]
operator|.
name|ilink
operator|=
name|ap
operator|->
name|ilink
expr_stmt|;
break|break ;
case|case
name|C_NOINIT
case|:
name|ap
operator|=
name|find_by_sval
argument_list|(
name|A
argument_list|,
operator|&
name|null_str
argument_list|,
name|NO_CREATE
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|ap
operator|=
name|find_by_sval
argument_list|(
name|A
argument_list|,
name|string
argument_list|(
name|cp
argument_list|)
argument_list|,
name|NO_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|&&
name|ap
operator|->
name|ival
operator|>=
literal|0
condition|)
block|{
name|int
name|index
init|=
name|ap
operator|->
name|ival
operator|%
name|A_HASH_PRIME
decl_stmt|;
name|ap
operator|=
name|find_by_index
argument_list|(
name|A
argument_list|,
name|index
argument_list|,
name|ap
operator|->
name|ival
argument_list|,
name|NO_CREATE
argument_list|)
expr_stmt|;
name|A
index|[
name|index
index|]
operator|.
name|ilink
operator|=
name|ap
operator|->
name|ilink
expr_stmt|;
block|}
break|break ;
block|}
if|if
condition|(
name|ap
condition|)
block|{
name|free_STRING
argument_list|(
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
name|ap
operator|->
name|sval
operator|=
operator|(
name|STRING
operator|*
operator|)
literal|0
expr_stmt|;
name|cell_destroy
argument_list|(
name|ap
operator|->
name|cp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|ap
operator|->
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* load into an array from the split_ov_list */
end_comment

begin_function
specifier|static
name|void
name|load_array_ov
parameter_list|(
name|A
parameter_list|)
name|ARRAY
name|A
decl_stmt|;
block|{
specifier|register
name|SPLIT_OV
modifier|*
name|p
decl_stmt|;
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
name|SPLIT_OV
modifier|*
name|q
decl_stmt|;
name|int
name|cnt
init|=
name|MAX_SPLIT
operator|+
literal|1
decl_stmt|;
name|int
name|index
init|=
operator|(
name|MAX_SPLIT
operator|+
literal|1
operator|)
operator|%
name|A_HASH_PRIME
decl_stmt|;
name|p
operator|=
name|split_ov_list
expr_stmt|;
name|split_ov_list
operator|=
operator|(
name|SPLIT_OV
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|p
condition|)
name|bozo
argument_list|(
literal|"array_ov"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
name|cp
operator|=
name|find_by_index
argument_list|(
name|A
argument_list|,
name|index
argument_list|,
name|cnt
argument_list|,
name|NO_MOVE
argument_list|)
operator|->
name|cp
expr_stmt|;
name|cell_destroy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_MBSTRN
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|p
operator|->
name|sval
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|zfree
argument_list|(
name|q
argument_list|,
sizeof|sizeof
argument_list|(
name|SPLIT_OV
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
break|break ;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|index
operator|==
name|A_HASH_PRIME
condition|)
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* this is called by bi_split()    to load strings into an array */
end_comment

begin_function
name|void
name|load_array
parameter_list|(
name|A
parameter_list|,
name|cnt
parameter_list|)
name|ARRAY
name|A
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
block|{
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
if|if
condition|(
name|cnt
operator|>
name|MAX_SPLIT
condition|)
block|{
name|load_array_ov
argument_list|(
name|A
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|MAX_SPLIT
expr_stmt|;
block|}
name|index
operator|=
name|cnt
operator|%
name|A_HASH_PRIME
expr_stmt|;
while|while
condition|(
name|cnt
condition|)
block|{
name|cp
operator|=
name|find_by_index
argument_list|(
name|A
argument_list|,
name|index
argument_list|,
name|cnt
argument_list|,
name|NO_MOVE
argument_list|)
operator|->
name|cp
expr_stmt|;
name|cell_destroy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_MBSTRN
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|split_buff
index|[
operator|--
name|cnt
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|index
operator|<
literal|0
condition|)
name|index
operator|=
name|A_HASH_PRIME
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* cat together cnt elements on the eval stack to form    an array index using SUBSEP */
end_comment

begin_function
name|CELL
modifier|*
name|array_cat
parameter_list|(
name|sp
parameter_list|,
name|cnt
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
specifier|register
name|CELL
modifier|*
name|p
decl_stmt|;
comment|/* walks the stack */
name|CELL
name|subsep
decl_stmt|;
comment|/* a copy of SUBSEP */
name|unsigned
name|subsep_len
decl_stmt|;
name|char
modifier|*
name|subsep_str
decl_stmt|;
name|unsigned
name|total_len
decl_stmt|;
comment|/* length of cat'ed expression */
name|CELL
modifier|*
name|top
decl_stmt|;
comment|/* sp at entry */
name|char
modifier|*
name|t
decl_stmt|;
comment|/* target ptr when catting */
name|STRING
modifier|*
name|sval
decl_stmt|;
comment|/* build new STRING here */
comment|/* get a copy of subsep, we may need to cast */
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
operator|&
name|subsep
argument_list|,
name|SUBSEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|subsep
operator|.
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
operator|&
name|subsep
argument_list|)
expr_stmt|;
name|subsep_len
operator|=
name|string
argument_list|(
operator|&
name|subsep
argument_list|)
operator|->
name|len
expr_stmt|;
name|subsep_str
operator|=
name|string
argument_list|(
operator|&
name|subsep
argument_list|)
operator|->
name|str
expr_stmt|;
name|total_len
operator|=
operator|--
name|cnt
operator|*
name|subsep_len
expr_stmt|;
name|top
operator|=
name|sp
expr_stmt|;
name|sp
operator|-=
name|cnt
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sp
init|;
name|p
operator|<=
name|top
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|total_len
operator|+=
name|string
argument_list|(
name|p
argument_list|)
operator|->
name|len
expr_stmt|;
block|}
name|sval
operator|=
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
name|t
operator|=
name|sval
operator|->
name|str
expr_stmt|;
comment|/* put the pieces together */
for|for
control|(
name|p
operator|=
name|sp
init|;
name|p
operator|<
name|top
condition|;
name|p
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|t
argument_list|,
name|string
argument_list|(
name|p
argument_list|)
operator|->
name|str
argument_list|,
name|SIZE_T
argument_list|(
name|string
argument_list|(
name|p
argument_list|)
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|t
operator|+=
name|string
argument_list|(
name|p
argument_list|)
operator|->
name|len
argument_list|,
name|subsep_str
argument_list|,
name|SIZE_T
argument_list|(
name|subsep_len
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
name|subsep_len
expr_stmt|;
block|}
comment|/* p == top */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|t
argument_list|,
name|string
argument_list|(
name|p
argument_list|)
operator|->
name|str
argument_list|,
name|SIZE_T
argument_list|(
name|string
argument_list|(
name|p
argument_list|)
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* done, now cleanup */
name|free_STRING
argument_list|(
name|string
argument_list|(
operator|&
name|subsep
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|>=
name|sp
condition|)
block|{
name|free_STRING
argument_list|(
name|string
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
name|sp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|sval
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* free all memory used by an array,    only used for arrays local to a function call */
end_comment

begin_function
name|void
name|array_free
parameter_list|(
name|A
parameter_list|)
name|ARRAY
name|A
decl_stmt|;
block|{
specifier|register
name|ANODE
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ANODE
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|A_HASH_PRIME
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|A
index|[
name|i
index|]
operator|.
name|link
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
comment|/* check its not a deleted node */
if|if
condition|(
name|p
operator|->
name|sval
condition|)
block|{
name|free_STRING
argument_list|(
name|p
operator|->
name|sval
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|p
operator|->
name|cp
argument_list|)
expr_stmt|;
name|free_CELL
argument_list|(
name|p
operator|->
name|cp
argument_list|)
expr_stmt|;
block|}
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|zfree
argument_list|(
name|q
argument_list|,
sizeof|sizeof
argument_list|(
name|ANODE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|zfree
argument_list|(
name|A
argument_list|,
sizeof|sizeof
argument_list|(
name|A
index|[
literal|0
index|]
argument_list|)
operator|*
name|A_HASH_PRIME
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|inc_aloop_state
parameter_list|(
name|ap
parameter_list|)
name|ALOOP_STATE
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|ANODE
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ARRAY
name|A
init|=
name|ap
operator|->
name|A
decl_stmt|;
name|CELL
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|ap
operator|->
name|index
operator|)
operator|==
operator|-
literal|1
condition|)
name|p
operator|=
name|A
index|[
operator|++
name|i
index|]
operator|.
name|link
expr_stmt|;
else|else
name|p
operator|=
name|ap
operator|->
name|ptr
operator|->
name|link
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
if|if
condition|(
operator|++
name|i
operator|==
name|A_HASH_PRIME
condition|)
return|return
literal|0
return|;
else|else
block|{
name|p
operator|=
name|A
index|[
name|i
index|]
operator|.
name|link
expr_stmt|;
continue|continue ;
block|}
if|if
condition|(
name|p
operator|->
name|sval
condition|)
comment|/* found one */
block|{
name|cp
operator|=
name|ap
operator|->
name|var
expr_stmt|;
name|cell_destroy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|p
operator|->
name|sval
expr_stmt|;
name|p
operator|->
name|sval
operator|->
name|ref_cnt
operator|++
expr_stmt|;
comment|/* save the state */
name|ap
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|ap
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
comment|/* its deleted */
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
block|}
end_function

end_unit

