begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** code.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/* $Log:	code.c,v $  * Revision 5.1  91/12/05  07:55:43  brennan  * 1.1 pre-release  *  */
end_comment

begin_comment
comment|/*  code.c  */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"code.h"
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"jmp.h"
end_include

begin_include
include|#
directive|include
file|"field.h"
end_include

begin_define
define|#
directive|define
name|MAIN_CODE_SZ
value|(MAIN_PAGE_SZ*sizeof(INST))
end_define

begin_decl_stmt
name|INST
modifier|*
name|code_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|INST
modifier|*
name|main_start
decl_stmt|,
modifier|*
name|main_code_ptr
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|INST *begin_start , *begin_code_ptr ; INST *end_start , *end_code_ptr ;
endif|#
directive|endif
end_endif

begin_decl_stmt
name|unsigned
name|main_size
comment|/*, begin_size, end_size*/
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* when the code is done executing its freed,        that's why this is global */
end_comment

begin_decl_stmt
name|struct
name|be_code
name|begin_code
decl_stmt|,
name|end_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|PROTO
argument_list|(
name|fdump
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|be_expand
parameter_list|(
name|p
parameter_list|)
name|struct
name|be_code
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|delta
decl_stmt|;
name|main_code_ptr
operator|=
name|code_ptr
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|start
condition|)
block|{
name|delta
operator|=
name|p
operator|->
name|ptr
operator|-
name|p
operator|->
name|start
expr_stmt|;
name|p
operator|->
name|start
operator|=
operator|(
name|INST
operator|*
operator|)
name|zrealloc
argument_list|(
name|p
operator|->
name|start
argument_list|,
name|INST_BYTES
argument_list|(
name|p
operator|->
name|size
argument_list|)
argument_list|,
name|INST_BYTES
argument_list|(
name|PAGE_SZ
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|start
operator|=
operator|(
name|INST
operator|*
operator|)
name|zmalloc
argument_list|(
name|INST_BYTES
argument_list|(
name|PAGE_SZ
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|size
operator|=
name|PAGE_SZ
expr_stmt|;
name|code_ptr
operator|=
name|p
operator|->
name|start
operator|+
name|delta
expr_stmt|;
block|}
end_function

begin_function
name|void
name|be_shrink
parameter_list|(
name|p
parameter_list|)
name|struct
name|be_code
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|delta
init|=
name|code_ptr
operator|-
name|p
operator|->
name|start
decl_stmt|;
name|code_ptr
operator|=
name|main_code_ptr
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|p
operator|->
name|size
condition|)
name|overflow
argument_list|(
name|p
operator|==
operator|&
name|begin_code
condition|?
literal|"BEGIN code"
else|:
literal|"END code"
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|->
name|start
operator|=
operator|(
name|INST
operator|*
operator|)
name|zrealloc
argument_list|(
name|p
operator|->
name|start
argument_list|,
name|INST_BYTES
argument_list|(
name|p
operator|->
name|size
argument_list|)
argument_list|,
name|INST_BYTES
argument_list|(
name|delta
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ptr
operator|=
name|p
operator|->
name|start
operator|+
name|delta
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|delta
operator|+
literal|2
expr_stmt|;
block|}
end_function

begin_function
name|void
name|code_init
parameter_list|()
block|{
name|code_ptr
operator|=
name|main_code_ptr
operator|=
name|main_start
operator|=
operator|(
name|INST
operator|*
operator|)
name|zmalloc
argument_list|(
name|MAIN_CODE_SZ
argument_list|)
expr_stmt|;
name|code1
argument_list|(
name|_OMAIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|code_cleanup
parameter_list|()
block|{
name|int
name|some_code_flag
init|=
literal|0
decl_stmt|;
comment|/* might only have functions */
comment|/* set the END code */
if|if
condition|(
name|end_code
operator|.
name|start
condition|)
block|{
name|end_code
operator|.
name|ptr
operator|++
operator|->
name|op
operator|=
name|_EXIT0
expr_stmt|;
name|end_code
operator|.
name|ptr
operator|++
operator|->
name|op
operator|=
name|_HALT
expr_stmt|;
name|end_code
operator|.
name|size
operator|=
name|INST_BYTES
argument_list|(
name|end_code
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* set the main code */
if|if
condition|(
name|end_code
operator|.
name|start
operator|||
name|code_ptr
operator|-
name|main_start
operator|>
literal|1
condition|)
block|{
name|int
name|gl_offset
init|=
name|code_ptr
operator|-
name|main_start
decl_stmt|;
specifier|extern
name|INST
modifier|*
name|next_label
decl_stmt|;
specifier|extern
name|int
name|NR_flag
decl_stmt|;
if|if
condition|(
name|NR_flag
condition|)
name|code1
argument_list|(
name|OL_GL_NR
argument_list|)
expr_stmt|;
else|else
name|code1
argument_list|(
name|OL_GL
argument_list|)
expr_stmt|;
name|code1
argument_list|(
name|_HALT
argument_list|)
expr_stmt|;
name|main_size
operator|=
name|code_ptr
operator|-
name|main_start
expr_stmt|;
if|if
condition|(
name|main_size
operator|>
name|MAIN_PAGE_SZ
condition|)
name|overflow
argument_list|(
literal|"MAIN code"
argument_list|,
name|MAIN_PAGE_SZ
argument_list|)
expr_stmt|;
name|main_size
operator|*=
sizeof|sizeof
argument_list|(
name|INST
argument_list|)
expr_stmt|;
name|code_ptr
operator|=
name|main_start
operator|=
operator|(
name|INST
operator|*
operator|)
name|zrealloc
argument_list|(
name|main_start
argument_list|,
name|MAIN_CODE_SZ
argument_list|,
name|main_size
argument_list|)
expr_stmt|;
name|next_label
operator|=
name|main_start
operator|+
name|gl_offset
expr_stmt|;
name|some_code_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* only BEGIN */
block|{
name|zfree
argument_list|(
name|main_start
argument_list|,
name|MAIN_CODE_SZ
argument_list|)
expr_stmt|;
name|main_start
operator|=
operator|(
name|INST
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* set the BEGIN code */
if|if
condition|(
name|begin_code
operator|.
name|start
condition|)
block|{
name|some_code_flag
operator|=
literal|1
expr_stmt|;
name|begin_code
operator|.
name|ptr
operator|++
operator|->
name|op
operator|=
name|main_start
condition|?
name|_JMAIN
else|:
name|_EXIT0
expr_stmt|;
name|begin_code
operator|.
name|ptr
operator|++
operator|->
name|op
operator|=
name|_HALT
expr_stmt|;
name|begin_code
operator|.
name|size
operator|=
name|INST_BYTES
argument_list|(
name|begin_code
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* execution starts at code_ptr */
name|code_ptr
operator|=
name|begin_code
operator|.
name|start
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|SM_DOS
if|if
condition|(
name|dump_code
condition|)
block|{
name|fdump
argument_list|()
expr_stmt|;
comment|/* dumps all user functions */
if|if
condition|(
name|begin_code
operator|.
name|start
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BEGIN\n"
argument_list|)
expr_stmt|;
name|da
argument_list|(
name|begin_code
operator|.
name|start
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end_code
operator|.
name|start
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"END\n"
argument_list|)
expr_stmt|;
name|da
argument_list|(
name|end_code
operator|.
name|start
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|main_start
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MAIN\n"
argument_list|)
expr_stmt|;
name|da
argument_list|(
name|main_start
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|some_code_flag
operator|==
literal|0
condition|)
name|mawk_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

