begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** print.c copyright 1992, 1991.  Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/* $Log:	print.c,v $  * Revision 5.2  92/02/24  10:52:16  brennan  * printf and sprintf() can now have more args than % conversions  * removed HAVE_PRINTF_HD -- it was too obscure  *   * Revision 5.1  91/12/05  07:56:22  brennan  * 1.1 pre-release  *  */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"bi_vars.h"
end_include

begin_include
include|#
directive|include
file|"bi_funct.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"field.h"
end_include

begin_include
include|#
directive|include
file|"scan.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|print_cell
argument_list|,
operator|(
name|CELL
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|STRING
modifier|*
name|PROTO
argument_list|(
name|do_printf
argument_list|,
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
operator|,
name|CELL
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|bad_conversion
argument_list|,
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this can be moved and enlarged  by -W sprintf=num  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sprintf_buff
init|=
name|string_buff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sprintf_limit
init|=
name|string_buff
operator|+
name|SPRINTF_SZ
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|print_cell
parameter_list|(
name|p
parameter_list|,
name|fp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|p
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
break|break ;
case|case
name|C_MBSTRN
case|:
case|case
name|C_STRING
case|:
case|case
name|C_STRNUM
case|:
switch|switch
condition|(
name|len
operator|=
name|string
argument_list|(
name|p
argument_list|)
operator|->
name|len
condition|)
block|{
case|case
literal|0
case|:
break|break ;
case|case
literal|1
case|:
name|putc
argument_list|(
name|string
argument_list|(
name|p
argument_list|)
operator|->
name|str
index|[
literal|0
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|fwrite
argument_list|(
name|string
argument_list|(
name|p
argument_list|)
operator|->
name|str
argument_list|,
name|SIZE_T
argument_list|(
literal|1
argument_list|)
argument_list|,
name|SIZE_T
argument_list|(
name|len
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
break|break ;
case|case
name|C_DOUBLE
case|:
if|if
condition|(
call|(
name|double
call|)
argument_list|(
name|len
operator|=
operator|(
name|int
operator|)
name|p
operator|->
name|dval
argument_list|)
operator|==
name|p
operator|->
name|dval
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
name|string
argument_list|(
name|OFMT
argument_list|)
operator|->
name|str
argument_list|,
name|p
operator|->
name|dval
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|bozo
argument_list|(
literal|"bad cell passed to print_cell"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* on entry to bi_print or bi_printf the stack is:     sp[0] = an integer k        if ( k< 0 )  output is to a file with name in sp[-1]        { so open file and sp -= 2 }     sp[0] = k>= 0 is the number of print args    sp[-k]   holds the first argument  */
end_comment

begin_function
name|CELL
modifier|*
name|bi_print
parameter_list|(
name|sp
parameter_list|)
name|CELL
modifier|*
name|sp
decl_stmt|;
comment|/* stack ptr passed in */
block|{
specifier|register
name|CELL
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|sp
operator|->
name|type
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|--
name|sp
operator|)
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|(
name|FILE
operator|*
operator|)
name|file_find
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
operator|--
name|sp
operator|)
operator|->
name|type
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|k
condition|)
block|{
name|p
operator|=
name|sp
operator|-
name|k
expr_stmt|;
comment|/* clear k variables off the stack */
name|sp
operator|=
name|p
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|k
operator|--
operator|>
literal|1
condition|)
block|{
name|print_cell
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|print_cell
argument_list|(
name|OFS
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|print_cell
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|--
expr_stmt|;
name|print_cell
argument_list|(
operator|&
name|field
index|[
literal|0
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|print_cell
argument_list|(
name|ORS
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/*---------- types and defs for doing printf and sprintf----*/
end_comment

begin_define
define|#
directive|define
name|PF_C
value|0
end_define

begin_define
define|#
directive|define
name|PF_S
value|1
end_define

begin_define
define|#
directive|define
name|PF_D
value|2
end_define

begin_comment
comment|/* int conversion */
end_comment

begin_define
define|#
directive|define
name|PF_LD
value|3
end_define

begin_comment
comment|/* long int */
end_comment

begin_define
define|#
directive|define
name|PF_F
value|4
end_define

begin_comment
comment|/* float conversion */
end_comment

begin_comment
comment|/* for switch on number of '*' and type */
end_comment

begin_define
define|#
directive|define
name|AST
parameter_list|(
name|num
parameter_list|,
name|type
parameter_list|)
value|(5*(num)+(type))
end_define

begin_comment
comment|/* some picky ANSI compilers go berserk without this */
end_comment

begin_if
if|#
directive|if
name|HAVE_PROTOS
end_if

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|PRINTER
function_decl|)
parameter_list|(
name|PTR
parameter_list|,
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|PRINTER
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|bad_conversion
parameter_list|(
name|cnt
parameter_list|,
name|who
parameter_list|,
name|format
parameter_list|)
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|who
decl_stmt|,
decl|*
name|format
decl_stmt|;
end_function

begin_block
block|{
name|rt_error
argument_list|(
literal|"improper conversion(number %d) in %s(\"%s\")"
argument_list|,
name|cnt
argument_list|,
name|who
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* the contents of format are preserved,    caller does CELL cleanup      This routine does both printf and sprintf (if fp==0) */
end_comment

begin_function
specifier|static
name|STRING
modifier|*
name|do_printf
parameter_list|(
name|fp
parameter_list|,
name|format
parameter_list|,
name|argcnt
parameter_list|,
name|cp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|CELL
modifier|*
name|cp
decl_stmt|;
comment|/* ptr to an array of arguments ( on the eval stack) */
name|unsigned
name|argcnt
decl_stmt|;
comment|/* number of args on eval stack */
block|{
name|char
name|save
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
init|=
name|format
decl_stmt|;
specifier|register
name|char
modifier|*
name|target
decl_stmt|;
name|int
name|l_flag
decl_stmt|,
name|h_flag
decl_stmt|;
comment|/* seen %ld or %hd  */
name|int
name|ast_cnt
decl_stmt|;
name|int
name|ast
index|[
literal|2
index|]
decl_stmt|;
name|long
name|lval
decl_stmt|;
name|int
name|ival
decl_stmt|;
comment|/* caters to MSDOS */
name|int
name|num_conversion
init|=
literal|0
decl_stmt|;
comment|/* for error messages */
name|char
modifier|*
name|who
decl_stmt|;
comment|/*ditto*/
name|int
name|pf_type
decl_stmt|;
comment|/* conversion type */
name|PRINTER
name|printer
decl_stmt|;
comment|/* pts at fprintf() or sprintf() */
if|if
condition|(
name|fp
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
comment|/* doing sprintf */
block|{
name|target
operator|=
name|sprintf_buff
expr_stmt|;
name|printer
operator|=
operator|(
name|PRINTER
operator|)
name|sprintf
expr_stmt|;
name|who
operator|=
literal|"sprintf"
expr_stmt|;
block|}
else|else
comment|/* doing printf */
block|{
name|target
operator|=
operator|(
name|char
operator|*
operator|)
name|fp
expr_stmt|;
comment|/* will never change */
name|printer
operator|=
operator|(
name|PRINTER
operator|)
name|fprintf
expr_stmt|;
name|who
operator|=
literal|"printf"
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|fp
condition|)
comment|/* printf */
block|{
while|while
condition|(
operator|*
name|q
operator|!=
literal|'%'
condition|)
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
return|return
operator|(
name|STRING
operator|*
operator|)
literal|0
return|;
else|else
block|{
name|putc
argument_list|(
operator|*
name|q
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
block|}
else|else
comment|/* sprintf */
block|{
while|while
condition|(
operator|*
name|q
operator|!=
literal|'%'
condition|)
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|target
operator|>
name|sprintf_limit
condition|)
comment|/* damaged */
block|{
comment|/* hope this works */
name|rt_overflow
argument_list|(
literal|"sprintf buffer"
argument_list|,
name|sprintf_limit
operator|-
name|sprintf_buff
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* really done */
block|{
name|STRING
modifier|*
name|retval
decl_stmt|;
name|int
name|len
init|=
name|target
operator|-
name|sprintf_buff
decl_stmt|;
name|retval
operator|=
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|retval
operator|->
name|str
argument_list|,
name|sprintf_buff
argument_list|,
name|SIZE_T
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
else|else
operator|*
name|target
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
block|}
name|num_conversion
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|q
operator|==
literal|'%'
condition|)
comment|/* %% */
block|{
if|if
condition|(
name|fp
condition|)
name|putc
argument_list|(
operator|*
name|q
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
operator|*
name|target
operator|++
operator|=
operator|*
name|q
expr_stmt|;
name|q
operator|++
expr_stmt|;
continue|continue ;
block|}
comment|/* mark the '%' with p */
name|p
operator|=
name|q
operator|-
literal|1
expr_stmt|;
comment|/* eat the flags */
while|while
condition|(
operator|*
name|q
operator|==
literal|'-'
operator|||
operator|*
name|q
operator|==
literal|'+'
operator|||
operator|*
name|q
operator|==
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'#'
operator|||
operator|*
name|q
operator|==
literal|'0'
condition|)
name|q
operator|++
expr_stmt|;
name|ast_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ast
index|[
name|ast_cnt
operator|++
index|]
operator|=
operator|(
name|int
operator|)
name|cp
operator|++
operator|->
name|dval
expr_stmt|;
name|argcnt
operator|--
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
else|else
while|while
condition|(
name|scan_code
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|q
index|]
operator|==
name|SC_DIGIT
condition|)
name|q
operator|++
expr_stmt|;
comment|/* width is done */
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
condition|)
comment|/* have precision */
block|{
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ast
index|[
name|ast_cnt
operator|++
index|]
operator|=
operator|(
name|int
operator|)
name|cp
operator|++
operator|->
name|dval
expr_stmt|;
name|argcnt
operator|--
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
else|else
while|while
condition|(
name|scan_code
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|q
index|]
operator|==
name|SC_DIGIT
condition|)
name|q
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argcnt
operator|<=
literal|0
condition|)
name|rt_error
argument_list|(
literal|"not enough arguments passed to %s(\"%s\")"
argument_list|,
name|who
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|l_flag
operator|=
name|h_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'l'
condition|)
block|{
name|q
operator|++
expr_stmt|;
name|l_flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'h'
condition|)
block|{
name|q
operator|++
expr_stmt|;
name|h_flag
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|q
operator|++
condition|)
block|{
case|case
literal|'s'
case|:
if|if
condition|(
name|l_flag
operator|+
name|h_flag
condition|)
name|bad_conversion
argument_list|(
name|num_conversion
argument_list|,
name|who
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|pf_type
operator|=
name|PF_S
expr_stmt|;
break|break ;
case|case
literal|'c'
case|:
if|if
condition|(
name|l_flag
operator|+
name|h_flag
condition|)
name|bad_conversion
argument_list|(
name|num_conversion
argument_list|,
name|who
argument_list|,
name|format
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
name|ival
operator|=
literal|0
expr_stmt|;
break|break ;
case|case
name|C_STRNUM
case|:
case|case
name|C_DOUBLE
case|:
name|ival
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|dval
expr_stmt|;
break|break ;
case|case
name|C_STRING
case|:
name|ival
operator|=
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|str
index|[
literal|0
index|]
expr_stmt|;
break|break ;
case|case
name|C_MBSTRN
case|:
name|check_strnum
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ival
operator|=
name|cp
operator|->
name|type
operator|==
name|C_STRING
condition|?
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|str
index|[
literal|0
index|]
else|:
operator|(
name|int
operator|)
name|cp
operator|->
name|dval
expr_stmt|;
break|break ;
default|default :
name|bozo
argument_list|(
literal|"printf %c"
argument_list|)
expr_stmt|;
block|}
name|pf_type
operator|=
name|PF_C
expr_stmt|;
break|break ;
case|case
literal|'d'
case|:
case|case
literal|'o'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'i'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|lval
operator|=
operator|(
name|long
operator|)
name|cp
operator|->
name|dval
expr_stmt|;
if|if
condition|(
name|h_flag
condition|)
name|lval
operator|&=
literal|0xffff
expr_stmt|;
name|pf_type
operator|=
name|l_flag
condition|?
name|PF_LD
else|:
name|PF_D
expr_stmt|;
break|break ;
case|case
literal|'e'
case|:
case|case
literal|'g'
case|:
case|case
literal|'f'
case|:
case|case
literal|'E'
case|:
case|case
literal|'G'
case|:
if|if
condition|(
name|h_flag
operator|+
name|l_flag
condition|)
name|bad_conversion
argument_list|(
name|num_conversion
argument_list|,
name|who
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|pf_type
operator|=
name|PF_F
expr_stmt|;
break|break ;
default|default :
name|bad_conversion
argument_list|(
name|num_conversion
argument_list|,
name|who
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
name|save
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
comment|/* ready to call printf() */
switch|switch
condition|(
name|AST
argument_list|(
name|ast_cnt
argument_list|,
name|pf_type
argument_list|)
condition|)
block|{
case|case
name|AST
argument_list|(
literal|0
argument_list|,
name|PF_C
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|ival
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|1
argument_list|,
name|PF_C
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|ast
index|[
literal|0
index|]
argument_list|,
name|ival
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|2
argument_list|,
name|PF_C
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|ast
index|[
literal|0
index|]
argument_list|,
name|ast
index|[
literal|1
index|]
argument_list|,
name|ival
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|0
argument_list|,
name|PF_S
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|str
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|1
argument_list|,
name|PF_S
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|ast
index|[
literal|0
index|]
argument_list|,
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|str
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|2
argument_list|,
name|PF_S
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|ast
index|[
literal|0
index|]
argument_list|,
name|ast
index|[
literal|1
index|]
argument_list|,
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|str
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|0
argument_list|,
name|PF_D
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
operator|(
name|int
operator|)
name|lval
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|1
argument_list|,
name|PF_D
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|ast
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|)
name|lval
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|2
argument_list|,
name|PF_D
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|ast
index|[
literal|0
index|]
argument_list|,
name|ast
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|lval
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|0
argument_list|,
name|PF_LD
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|lval
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|1
argument_list|,
name|PF_LD
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|ast
index|[
literal|0
index|]
argument_list|,
name|lval
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|2
argument_list|,
name|PF_LD
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|ast
index|[
literal|0
index|]
argument_list|,
name|ast
index|[
literal|1
index|]
argument_list|,
name|lval
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|0
argument_list|,
name|PF_F
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|cp
operator|->
name|dval
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|1
argument_list|,
name|PF_F
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|ast
index|[
literal|0
index|]
argument_list|,
name|cp
operator|->
name|dval
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AST
argument_list|(
literal|2
argument_list|,
name|PF_F
argument_list|)
case|:
call|(
modifier|*
name|printer
call|)
argument_list|(
operator|(
name|PTR
operator|)
name|target
argument_list|,
name|p
argument_list|,
name|ast
index|[
literal|0
index|]
argument_list|,
name|ast
index|[
literal|1
index|]
argument_list|,
name|cp
operator|->
name|dval
argument_list|)
expr_stmt|;
break|break ;
block|}
if|if
condition|(
name|fp
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
while|while
condition|(
operator|*
name|target
condition|)
name|target
operator|++
expr_stmt|;
operator|*
name|q
operator|=
name|save
expr_stmt|;
name|argcnt
operator|--
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_printf
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|CELL
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|sp
operator|->
name|type
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|--
name|sp
operator|)
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|(
name|FILE
operator|*
operator|)
name|file_find
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
operator|--
name|sp
operator|)
operator|->
name|type
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|stdout
expr_stmt|;
name|sp
operator|-=
name|k
operator|--
expr_stmt|;
comment|/* sp points at the format string */
if|if
condition|(
name|sp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|do_printf
argument_list|(
name|fp
argument_list|,
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
argument_list|,
name|k
argument_list|,
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sp
operator|+
literal|1
init|;
name|k
operator|--
condition|;
name|p
operator|++
control|)
name|cell_destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|--
name|sp
return|;
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_sprintf
parameter_list|(
name|sp
parameter_list|)
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|CELL
modifier|*
name|p
decl_stmt|;
name|int
name|argcnt
init|=
name|sp
operator|->
name|type
decl_stmt|;
name|STRING
modifier|*
name|sval
decl_stmt|;
name|sp
operator|-=
name|argcnt
operator|--
expr_stmt|;
comment|/* sp points at the format string */
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sval
operator|=
name|do_printf
argument_list|(
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
argument_list|,
name|argcnt
argument_list|,
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|sval
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sp
operator|+
literal|1
init|;
name|argcnt
operator|--
condition|;
name|p
operator|++
control|)
name|cell_destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

end_unit

