begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** field.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/* $Log:	field.c,v $  * Revision 5.1  91/12/05  07:55:57  brennan  * 1.1 pre-release  *  */
end_comment

begin_comment
comment|/* field.c */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"field.h"
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"scan.h"
end_include

begin_include
include|#
directive|include
file|"bi_vars.h"
end_include

begin_include
include|#
directive|include
file|"repl.h"
end_include

begin_include
include|#
directive|include
file|"regexp.h"
end_include

begin_decl_stmt
name|CELL
name|field
index|[
name|FBANK_SZ
operator|+
name|NUM_PFIELDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CELL
modifier|*
name|fbank
index|[
name|NUM_FBANK
index|]
init|=
block|{
name|field
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_field
init|=
name|MAX_SPLIT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum field actually created*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|build_field0
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|set_rs_shadow
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|load_pfield
argument_list|,
operator|(
name|char
operator|*
operator|,
name|CELL
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|load_field_ov
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a description of how to split based on RS.    If RS is changed, so is rs_shadow */
end_comment

begin_decl_stmt
name|SEPARATOR
name|rs_shadow
init|=
block|{
name|SEP_CHAR
block|,
literal|'\n'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a splitting CELL version of FS */
end_comment

begin_decl_stmt
name|CELL
name|fs_shadow
init|=
block|{
name|C_SPACE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nf holds the true value of NF.  If nf< 0 , then      NF has not been computed, i.e., $0 has not been split   */
end_comment

begin_function
specifier|static
name|void
name|set_rs_shadow
parameter_list|()
block|{
name|CELL
name|c
decl_stmt|;
name|STRING
modifier|*
name|sval
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
if|if
condition|(
name|posix_space_flag
operator|&&
name|mawk_state
operator|==
name|EXECUTION
condition|)
name|scan_code
index|[
literal|'\n'
index|]
operator|=
name|SC_UNEXPECTED
expr_stmt|;
if|if
condition|(
name|rs_shadow
operator|.
name|type
operator|==
name|SEP_STR
condition|)
name|free_STRING
argument_list|(
operator|(
name|STRING
operator|*
operator|)
name|rs_shadow
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|cast_for_split
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|c
argument_list|,
name|RS
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|.
name|type
condition|)
block|{
case|case
name|C_RE
case|:
if|if
condition|(
name|s
operator|=
name|is_string_split
argument_list|(
name|c
operator|.
name|ptr
argument_list|,
operator|&
name|len
argument_list|)
condition|)
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|rs_shadow
operator|.
name|type
operator|=
name|SEP_CHAR
expr_stmt|;
name|rs_shadow
operator|.
name|c
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|rs_shadow
operator|.
name|type
operator|=
name|SEP_STR
expr_stmt|;
name|rs_shadow
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rs_shadow
operator|.
name|type
operator|=
name|SEP_RE
expr_stmt|;
name|rs_shadow
operator|.
name|ptr
operator|=
name|c
operator|.
name|ptr
expr_stmt|;
block|}
break|break ;
case|case
name|C_SPACE
case|:
name|rs_shadow
operator|.
name|type
operator|=
name|SEP_CHAR
expr_stmt|;
name|rs_shadow
operator|.
name|c
operator|=
literal|' '
expr_stmt|;
break|break ;
case|case
name|C_SNULL
case|:
comment|/* RS becomes one or more blank lines */
if|if
condition|(
name|mawk_state
operator|==
name|EXECUTION
condition|)
name|scan_code
index|[
literal|'\n'
index|]
operator|=
name|SC_SPACE
expr_stmt|;
name|rs_shadow
operator|.
name|type
operator|=
name|SEP_MLR
expr_stmt|;
name|sval
operator|=
name|new_STRING
argument_list|(
literal|"\n\n+"
argument_list|)
expr_stmt|;
name|rs_shadow
operator|.
name|ptr
operator|=
name|re_compile
argument_list|(
name|sval
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|sval
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|bozo
argument_list|(
literal|"bad cell in set_rs_shadow"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|load_pfield
parameter_list|(
name|name
parameter_list|,
name|cp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
name|SYMTAB
modifier|*
name|stp
decl_stmt|;
name|stp
operator|=
name|insert
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stp
operator|->
name|type
operator|=
name|ST_FIELD
expr_stmt|;
name|stp
operator|->
name|stval
operator|.
name|cp
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initialize $0 and the pseudo fields */
end_comment

begin_function
name|void
name|field_init
parameter_list|()
block|{
name|field
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|C_STRING
expr_stmt|;
name|field
index|[
literal|0
index|]
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
name|load_pfield
argument_list|(
literal|"NF"
argument_list|,
name|NF
argument_list|)
expr_stmt|;
name|NF
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|NF
operator|->
name|dval
operator|=
literal|0.0
expr_stmt|;
name|load_pfield
argument_list|(
literal|"RS"
argument_list|,
name|RS
argument_list|)
expr_stmt|;
name|RS
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|RS
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* rs_shadow already set */
name|load_pfield
argument_list|(
literal|"FS"
argument_list|,
name|FS
argument_list|)
expr_stmt|;
name|FS
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|FS
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
comment|/* fs_shadow is already set */
name|load_pfield
argument_list|(
literal|"OFMT"
argument_list|,
name|OFMT
argument_list|)
expr_stmt|;
name|OFMT
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|OFMT
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
literal|"%.6g"
argument_list|)
expr_stmt|;
name|load_pfield
argument_list|(
literal|"CONVFMT"
argument_list|,
name|CONVFMT
argument_list|)
expr_stmt|;
name|CONVFMT
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|CONVFMT
operator|->
name|ptr
operator|=
name|OFMT
operator|->
name|ptr
expr_stmt|;
name|string
argument_list|(
name|OFMT
argument_list|)
operator|->
name|ref_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_field0
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|cell_destroy
argument_list|(
operator|&
name|field
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|nf
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|field
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|C_MBSTRN
expr_stmt|;
name|field
index|[
literal|0
index|]
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|string
argument_list|(
operator|&
name|field
index|[
literal|0
index|]
argument_list|)
operator|->
name|str
argument_list|,
name|s
argument_list|,
name|SIZE_T
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|field
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|C_STRING
expr_stmt|;
name|field
index|[
literal|0
index|]
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* split field[0] into $1, $2 ... and set NF  */
end_comment

begin_function
name|void
name|split_field0
parameter_list|()
block|{
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
name|CELL
name|c
decl_stmt|;
comment|/* copy field[0] here if not string */
if|if
condition|(
name|field
index|[
literal|0
index|]
operator|.
name|type
operator|<
name|C_STRING
condition|)
block|{
name|cast1_to_s
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|c
argument_list|,
name|field
operator|+
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|c
expr_stmt|;
block|}
else|else
name|cp
operator|=
operator|&
name|field
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|len
operator|==
literal|0
condition|)
name|nf
operator|=
literal|0
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|fs_shadow
operator|.
name|type
condition|)
block|{
case|case
name|C_SNULL
case|:
comment|/* FS == "" */
name|nf
operator|=
literal|1
expr_stmt|;
name|cell_destroy
argument_list|(
name|NF
argument_list|)
expr_stmt|;
name|NF
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|NF
operator|->
name|dval
operator|=
literal|1.0
expr_stmt|;
name|field
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|C_MBSTRN
expr_stmt|;
name|field
index|[
literal|1
index|]
operator|.
name|ptr
operator|=
name|cp
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|field
condition|)
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|ref_cnt
operator|++
expr_stmt|;
comment|/* else we gain one ref_cnt and lose one for a wash */
return|return ;
case|case
name|C_SPACE
case|:
name|nf
operator|=
name|space_split
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|str
argument_list|,
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|len
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|nf
operator|=
name|re_split
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|str
argument_list|,
name|fs_shadow
operator|.
name|ptr
argument_list|)
expr_stmt|;
break|break ;
block|}
block|}
name|cell_destroy
argument_list|(
name|NF
argument_list|)
expr_stmt|;
name|NF
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|NF
operator|->
name|dval
operator|=
operator|(
name|double
operator|)
name|nf
expr_stmt|;
if|if
condition|(
name|nf
operator|>
name|MAX_SPLIT
condition|)
block|{
name|cnt
operator|=
name|MAX_SPLIT
expr_stmt|;
name|load_field_ov
argument_list|()
expr_stmt|;
block|}
else|else
name|cnt
operator|=
name|nf
expr_stmt|;
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|cell_destroy
argument_list|(
name|field
operator|+
name|cnt
argument_list|)
expr_stmt|;
name|field
index|[
name|cnt
index|]
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|split_buff
index|[
name|cnt
operator|-
literal|1
index|]
expr_stmt|;
name|field
index|[
name|cnt
operator|--
index|]
operator|.
name|type
operator|=
name|C_MBSTRN
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
operator|&
name|c
condition|)
name|free_STRING
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   assign CELL *cp to field or pseudo field   and take care of all side effects */
end_comment

begin_function
name|void
name|field_assign
parameter_list|(
name|fp
parameter_list|,
name|cp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|fp
decl_stmt|;
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
name|CELL
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* the most common case first */
if|if
condition|(
name|fp
operator|==
name|field
condition|)
block|{
name|cell_destroy
argument_list|(
name|field
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|fp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|nf
operator|=
operator|-
literal|1
expr_stmt|;
return|return ;
block|}
comment|/* its not important to do any of this fast */
if|if
condition|(
name|nf
operator|<
literal|0
condition|)
name|split_field0
argument_list|()
expr_stmt|;
if|#
directive|if
name|LM_DOS
if|if
condition|(
operator|!
name|SAMESEG
argument_list|(
name|fp
argument_list|,
name|field
argument_list|)
condition|)
goto|goto
name|lm_dos_label
goto|;
endif|#
directive|endif
switch|switch
condition|(
name|i
operator|=
operator|(
name|fp
operator|-
name|field
operator|)
condition|)
block|{
case|case
name|NF_field
case|:
name|cell_destroy
argument_list|(
name|NF
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|NF
argument_list|,
name|cellcpy
argument_list|(
operator|&
name|c
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
operator|(
name|int
operator|)
name|c
operator|.
name|dval
operator|)
operator|<
literal|0
condition|)
name|rt_error
argument_list|(
literal|"negative value assigned to NF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|nf
condition|)
for|for
control|(
name|i
operator|=
name|nf
operator|+
literal|1
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|=
name|field_ptr
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
block|}
name|nf
operator|=
name|j
expr_stmt|;
name|build_field0
argument_list|()
expr_stmt|;
break|break ;
case|case
name|RS_field
case|:
name|cell_destroy
argument_list|(
name|RS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|RS
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|set_rs_shadow
argument_list|()
expr_stmt|;
break|break ;
case|case
name|FS_field
case|:
name|cell_destroy
argument_list|(
name|FS
argument_list|)
expr_stmt|;
name|cast_for_split
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|fs_shadow
argument_list|,
name|cellcpy
argument_list|(
name|FS
argument_list|,
name|cp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|OFMT_field
case|:
case|case
name|CONVFMT_field
case|:
comment|/* If the user does something stupid with OFMT or CONVFMT, 	   we could crash.            We'll make an attempt to protect ourselves here.  This is            why OFMT and CONVFMT are pseudo fields.             The ptrs of OFMT and CONVFMT always have a valid STRING, 	   even if assigned a DOUBLE or NOINIT         */
name|free_STRING
argument_list|(
name|string
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|fp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|type
operator|<
name|C_STRING
condition|)
comment|/* !! */
name|fp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
literal|"%.6g"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|==
name|CONVFMT
condition|)
block|{
comment|/* It's a string, but if it's really goofy and CONVFMT, 	     it could still damage us. Test it . 	  */
name|string_buff
index|[
literal|256
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string_buff
argument_list|,
name|string
argument_list|(
name|fp
argument_list|)
operator|->
name|str
argument_list|,
literal|3.1459
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_buff
index|[
literal|256
index|]
condition|)
name|rt_error
argument_list|(
literal|"CONVFMT assigned unusable value"
argument_list|)
expr_stmt|;
block|}
break|break ;
if|#
directive|if
name|LM_DOS
name|lm_dos_label
label|:
endif|#
directive|endif
default|default:
comment|/* $1 or $2 or ... */
name|cell_destroy
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|fp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MAX_SPLIT
condition|)
name|i
operator|=
name|field_addr_to_index
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|nf
condition|)
block|{
for|for
control|(
name|j
operator|=
name|nf
operator|+
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|cp
operator|=
name|field_ptr
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
block|}
name|nf
operator|=
name|i
expr_stmt|;
name|cell_destroy
argument_list|(
name|NF
argument_list|)
expr_stmt|;
name|NF
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|NF
operator|->
name|dval
operator|=
operator|(
name|double
operator|)
name|i
expr_stmt|;
block|}
name|build_field0
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* construct field[0] from the other fields */
end_comment

begin_function
specifier|static
name|void
name|build_field0
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|nf
operator|<
literal|0
condition|)
name|bozo
argument_list|(
literal|"nf<0 in build_field0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cell_destroy
argument_list|(
name|field
operator|+
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|==
literal|0
condition|)
block|{
name|field
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|C_STRING
expr_stmt|;
name|field
index|[
literal|0
index|]
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nf
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|field
argument_list|,
name|field
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|CELL
name|c
decl_stmt|;
name|STRING
modifier|*
name|ofs
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|CELL
modifier|*
modifier|*
name|fbp
decl_stmt|,
modifier|*
name|cp_limit
decl_stmt|;
name|cast1_to_s
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|c
argument_list|,
name|OFS
argument_list|)
argument_list|)
expr_stmt|;
name|ofs
operator|=
operator|(
name|STRING
operator|*
operator|)
name|c
operator|.
name|ptr
expr_stmt|;
name|cast1_to_s
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|c
argument_list|,
name|field_ptr
argument_list|(
name|nf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tail
operator|=
operator|(
name|STRING
operator|*
operator|)
name|c
operator|.
name|ptr
expr_stmt|;
name|cnt
operator|=
name|nf
operator|-
literal|1
expr_stmt|;
name|len
operator|=
name|cnt
operator|*
name|ofs
operator|->
name|len
operator|+
name|tail
operator|->
name|len
expr_stmt|;
name|fbp
operator|=
name|fbank
expr_stmt|;
name|cp_limit
operator|=
name|field
operator|+
name|FBANK_SZ
expr_stmt|;
name|cp
operator|=
name|field
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|type
operator|<
name|C_STRING
condition|)
block|{
comment|/* use the string field temporarily */
if|if
condition|(
name|cp
operator|->
name|type
operator|==
name|C_NOINIT
condition|)
block|{
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
block|}
else|else
comment|/* its a double */
block|{
name|int
name|ival
decl_stmt|;
if|if
condition|(
call|(
name|double
call|)
argument_list|(
name|ival
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|dval
argument_list|)
operator|==
name|cp
operator|->
name|dval
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string_buff
argument_list|,
literal|"%d"
argument_list|,
name|ival
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string_buff
argument_list|,
name|string
argument_list|(
name|CONVFMT
argument_list|)
operator|->
name|str
argument_list|,
name|cp
operator|->
name|dval
argument_list|)
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|string_buff
argument_list|)
expr_stmt|;
block|}
block|}
name|len
operator|+=
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|len
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|==
name|cp_limit
condition|)
block|{
name|cp
operator|=
operator|*
operator|++
name|fbp
expr_stmt|;
name|cp_limit
operator|=
name|cp
operator|+
name|FBANK_SZ
expr_stmt|;
block|}
block|}
name|field
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|C_STRING
expr_stmt|;
name|field
index|[
literal|0
index|]
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
name|string
argument_list|(
name|field
argument_list|)
operator|->
name|str
expr_stmt|;
comment|/* walk it again , putting things together */
name|cnt
operator|=
name|nf
operator|-
literal|1
expr_stmt|;
name|fbp
operator|=
name|fbank
expr_stmt|;
name|cp
operator|=
name|field
operator|+
literal|1
expr_stmt|;
name|cp_limit
operator|=
name|field
operator|+
name|FBANK_SZ
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|str
argument_list|,
name|SIZE_T
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|len
expr_stmt|;
comment|/* if not really string, free temp use of ptr */
if|if
condition|(
name|cp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|free_STRING
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|==
name|cp_limit
condition|)
block|{
name|cp
operator|=
operator|*
operator|++
name|fbp
expr_stmt|;
name|cp_limit
operator|=
name|cp
operator|+
name|FBANK_SZ
expr_stmt|;
block|}
comment|/* add the separator */
name|q
operator|=
name|ofs
operator|->
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
block|}
comment|/* tack tail on the end */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|tail
operator|->
name|str
argument_list|,
name|SIZE_T
argument_list|(
name|tail
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cleanup */
name|free_STRING
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|ofs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We are assigning to a CELL and we aren't sure if its    a field */
end_comment

begin_function
name|void
name|slow_cell_assign
parameter_list|(
name|target
parameter_list|,
name|source
parameter_list|)
specifier|register
name|CELL
modifier|*
name|target
decl_stmt|;
name|CELL
modifier|*
name|source
decl_stmt|;
block|{
if|if
condition|(
if|#
directive|if
name|LM_DOS
comment|/* the dreaded segment nonsense */
name|SAMESEG
argument_list|(
name|target
argument_list|,
name|field
argument_list|)
operator|&&
endif|#
directive|endif
name|target
operator|>=
name|field
operator|&&
name|target
operator|<=
name|LAST_PFIELD
condition|)
name|field_assign
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
block|{
name|CELL
modifier|*
modifier|*
name|p
init|=
name|fbank
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
if|#
directive|if
name|LM_DOS
name|SAMESEG
argument_list|(
name|target
argument_list|,
operator|*
name|p
argument_list|)
operator|&&
endif|#
directive|endif
name|target
operator|>=
operator|*
name|p
operator|&&
name|target
operator|<
operator|*
name|p
operator|+
name|FBANK_SZ
condition|)
block|{
name|field_assign
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return ;
block|}
name|p
operator|++
expr_stmt|;
block|}
comment|/* its not a field */
name|cell_destroy
argument_list|(
name|target
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|field_addr_to_index
parameter_list|(
name|cp
parameter_list|)
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
name|CELL
modifier|*
modifier|*
name|p
init|=
name|fbank
decl_stmt|;
while|while
condition|(
if|#
directive|if
name|LM_DOS
operator|!
name|SAMESEG
argument_list|(
name|cp
argument_list|,
operator|*
name|p
argument_list|)
operator|||
endif|#
directive|endif
name|cp
operator|<
operator|*
name|p
operator|||
name|cp
operator|>=
operator|*
name|p
operator|+
name|FBANK_SZ
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
operator|(
name|p
operator|-
name|fbank
operator|)
operator|<<
name|FB_SHIFT
operator|)
operator|+
operator|(
name|cp
operator|-
operator|*
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------- more than 1 fbank needed  ------------*/
end_comment

begin_comment
comment|/*   compute the address of a field with index> MAX_SPLIT */
end_comment

begin_function
name|CELL
modifier|*
name|slow_field_ptr
parameter_list|(
name|i
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|>
name|max_field
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|i
operator|>
name|MAX_FIELD
condition|)
name|rt_overflow
argument_list|(
literal|"maximum number of fields"
argument_list|,
name|MAX_FIELD
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|fbank
index|[
name|j
index|]
condition|)
name|j
operator|++
expr_stmt|;
do|do
block|{
name|fbank
index|[
name|j
index|]
operator|=
operator|(
name|CELL
operator|*
operator|)
name|zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
operator|*
name|FBANK_SZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|fbank
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|,
name|SIZE_T
argument_list|(
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
operator|*
name|FBANK_SZ
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|max_field
operator|+=
name|FBANK_SZ
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|>
name|max_field
condition|)
do|;
block|}
return|return
operator|&
name|fbank
index|[
name|i
operator|>>
name|FB_SHIFT
index|]
index|[
name|i
operator|&
operator|(
name|FBANK_SZ
operator|-
literal|1
operator|)
index|]
return|;
block|}
end_function

begin_comment
comment|/*   $0 split into more than MAX_SPLIT fields,    $(MAX_FIELD+1) ... are on the split_ov_list.   Copy into fields which start at fbank[1] */
end_comment

begin_function
specifier|static
name|void
name|load_field_ov
parameter_list|()
block|{
specifier|register
name|SPLIT_OV
modifier|*
name|p
decl_stmt|;
comment|/* walks split_ov_list */
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
comment|/* target of copy */
name|int
name|j
decl_stmt|;
comment|/* current fbank[] */
name|CELL
modifier|*
name|cp_limit
decl_stmt|;
comment|/* change fbank[] */
name|SPLIT_OV
modifier|*
name|q
decl_stmt|;
comment|/* trails p */
comment|/* make sure the fields are allocated */
operator|(
name|void
operator|)
name|slow_field_ptr
argument_list|(
name|nf
argument_list|)
expr_stmt|;
name|p
operator|=
name|split_ov_list
expr_stmt|;
name|split_ov_list
operator|=
operator|(
name|SPLIT_OV
operator|*
operator|)
literal|0
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|fbank
index|[
name|j
index|]
expr_stmt|;
name|cp_limit
operator|=
name|cp
operator|+
name|FBANK_SZ
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|cell_destroy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_MBSTRN
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|p
operator|->
name|sval
expr_stmt|;
if|if
condition|(
operator|++
name|cp
operator|==
name|cp_limit
condition|)
block|{
name|cp
operator|=
name|fbank
index|[
operator|++
name|j
index|]
expr_stmt|;
name|cp_limit
operator|=
name|cp
operator|+
name|FBANK_SZ
expr_stmt|;
block|}
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|ZFREE
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|MSDOS
operator|&&
name|NO_BINMODE
operator|==
literal|0
end_if

begin_function
name|int
name|binmode
parameter_list|()
comment|/* read current value of BINMODE */
block|{
name|CELL
name|c
decl_stmt|;
name|cast1_to_d
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|c
argument_list|,
name|BINMODE
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|c
operator|.
name|dval
return|;
block|}
end_function

begin_comment
comment|/* set BINMODE and RS and ORS     from environment or -W binmode=   */
end_comment

begin_function
name|void
name|set_binmode
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
name|CELL
name|c
decl_stmt|;
comment|/* set RS */
name|c
operator|.
name|type
operator|=
name|C_STRING
expr_stmt|;
name|c
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
operator|(
name|x
operator|&
literal|1
operator|)
condition|?
literal|"\r\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
name|field_assign
argument_list|(
name|RS
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
operator|&
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set ORS */
name|cell_destroy
argument_list|(
name|ORS
argument_list|)
expr_stmt|;
name|ORS
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|ORS
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
operator|(
name|x
operator|&
literal|2
operator|)
condition|?
literal|"\r\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|BINMODE
argument_list|)
expr_stmt|;
name|BINMODE
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|BINMODE
operator|->
name|dval
operator|=
operator|(
name|double
operator|)
name|x
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

end_unit

