begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** cast.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/*   $Log:	cast.c,v $  * Revision 5.1  91/12/05  07:55:41  brennan  * 1.1 pre-release  *  */
end_comment

begin_comment
comment|/*  cast.c  */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"field.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"scan.h"
end_include

begin_include
include|#
directive|include
file|"repl.h"
end_include

begin_decl_stmt
name|int
name|pow2
index|[
name|NUM_CELL_TYPES
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|256
block|,
literal|512
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|cast1_to_d
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
name|cp
operator|->
name|dval
operator|=
literal|0.0
expr_stmt|;
break|break ;
case|case
name|C_DOUBLE
case|:
return|return ;
case|case
name|C_MBSTRN
case|:
case|case
name|C_STRING
case|:
block|{
specifier|register
name|STRING
modifier|*
name|s
init|=
operator|(
name|STRING
operator|*
operator|)
name|cp
operator|->
name|ptr
decl_stmt|;
if|#
directive|if
name|FPE_TRAPS_ON
comment|/* look for overflow error */
name|errno
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|dval
operator|=
name|strtod
argument_list|(
name|s
operator|->
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|&&
name|cp
operator|->
name|dval
operator|!=
literal|0.0
condition|)
comment|/* ignore underflow */
name|rt_error
argument_list|(
literal|"overflow converting %s to double"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|cp
operator|->
name|dval
operator|=
name|strtod
argument_list|(
name|s
operator|->
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_STRING
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break ;
case|case
name|C_STRNUM
case|:
comment|/* don't need to convert, but do need to free the STRING part */
name|free_STRING
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|bozo
argument_list|(
literal|"cast on bad type"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast2_to_d
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|STRING
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
name|cp
operator|->
name|dval
operator|=
literal|0.0
expr_stmt|;
break|break ;
case|case
name|C_DOUBLE
case|:
goto|goto
name|two
goto|;
case|case
name|C_STRNUM
case|:
name|free_STRING
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_MBSTRN
case|:
case|case
name|C_STRING
case|:
name|s
operator|=
operator|(
name|STRING
operator|*
operator|)
name|cp
operator|->
name|ptr
expr_stmt|;
if|#
directive|if
name|FPE_TRAPS_ON
comment|/* look for overflow error */
name|errno
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|dval
operator|=
name|strtod
argument_list|(
name|s
operator|->
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|&&
name|cp
operator|->
name|dval
operator|!=
literal|0.0
condition|)
comment|/* ignore underflow */
name|rt_error
argument_list|(
literal|"overflow converting %s to double"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|cp
operator|->
name|dval
operator|=
name|strtod
argument_list|(
name|s
operator|->
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_STRING
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|bozo
argument_list|(
literal|"cast on bad type"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|two
label|:
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
name|cp
operator|->
name|dval
operator|=
literal|0.0
expr_stmt|;
break|break ;
case|case
name|C_DOUBLE
case|:
return|return ;
case|case
name|C_STRNUM
case|:
name|free_STRING
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_MBSTRN
case|:
case|case
name|C_STRING
case|:
name|s
operator|=
operator|(
name|STRING
operator|*
operator|)
name|cp
operator|->
name|ptr
expr_stmt|;
if|#
directive|if
name|FPE_TRAPS_ON
comment|/* look for overflow error */
name|errno
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|dval
operator|=
name|strtod
argument_list|(
name|s
operator|->
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|&&
name|cp
operator|->
name|dval
operator|!=
literal|0.0
condition|)
comment|/* ignore underflow */
name|rt_error
argument_list|(
literal|"overflow converting %s to double"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|cp
operator|->
name|dval
operator|=
name|strtod
argument_list|(
name|s
operator|->
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_STRING
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|bozo
argument_list|(
literal|"cast on bad type"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast1_to_s
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|ival
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
break|break ;
case|case
name|C_DOUBLE
case|:
if|if
condition|(
call|(
name|double
call|)
argument_list|(
name|ival
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|dval
argument_list|)
operator|==
name|cp
operator|->
name|dval
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string_buff
argument_list|,
literal|"%d"
argument_list|,
name|ival
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string_buff
argument_list|,
name|string
argument_list|(
name|CONVFMT
argument_list|)
operator|->
name|str
argument_list|,
name|cp
operator|->
name|dval
argument_list|)
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|string_buff
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_STRING
case|:
return|return ;
case|case
name|C_MBSTRN
case|:
case|case
name|C_STRNUM
case|:
break|break ;
default|default :
name|bozo
argument_list|(
literal|"bad type on cast"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast2_to_s
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|ival
decl_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
break|break ;
case|case
name|C_DOUBLE
case|:
if|if
condition|(
call|(
name|double
call|)
argument_list|(
name|ival
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|dval
argument_list|)
operator|==
name|cp
operator|->
name|dval
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string_buff
argument_list|,
literal|"%d"
argument_list|,
name|ival
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string_buff
argument_list|,
name|string
argument_list|(
name|CONVFMT
argument_list|)
operator|->
name|str
argument_list|,
name|cp
operator|->
name|dval
argument_list|)
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|string_buff
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_STRING
case|:
goto|goto
name|two
goto|;
case|case
name|C_MBSTRN
case|:
case|case
name|C_STRNUM
case|:
break|break ;
default|default :
name|bozo
argument_list|(
literal|"bad type on cast"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|two
label|:
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
break|break ;
case|case
name|C_DOUBLE
case|:
if|if
condition|(
call|(
name|double
call|)
argument_list|(
name|ival
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|dval
argument_list|)
operator|==
name|cp
operator|->
name|dval
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string_buff
argument_list|,
literal|"%d"
argument_list|,
name|ival
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string_buff
argument_list|,
name|string
argument_list|(
name|CONVFMT
argument_list|)
operator|->
name|str
argument_list|,
name|cp
operator|->
name|dval
argument_list|)
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|string_buff
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_STRING
case|:
return|return ;
case|case
name|C_MBSTRN
case|:
case|case
name|C_STRNUM
case|:
break|break ;
default|default :
name|bozo
argument_list|(
literal|"bad type on cast"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_to_RE
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|PTR
name|p
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|p
operator|=
name|re_compile
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_RE
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cast_for_split
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|static
name|char
name|meta
index|[]
init|=
literal|"^$.*+?|[]()"
decl_stmt|;
specifier|static
name|char
name|xbuff
index|[]
init|=
literal|"\\X"
decl_stmt|;
name|int
name|c
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|len
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|str
index|[
literal|0
index|]
operator|)
operator|==
literal|' '
condition|)
block|{
name|free_STRING
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_SPACE
expr_stmt|;
return|return ;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|meta
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|xbuff
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|xbuff
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|free_STRING
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_SNULL
expr_stmt|;
return|return ;
block|}
name|cast_to_RE
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* input: cp-> a CELL of type C_MBSTRN (maybe strnum)    test it -- casting it to the appropriate type    which is C_STRING or C_STRNUM */
end_comment

begin_function
name|void
name|check_strnum
parameter_list|(
name|cp
parameter_list|)
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
name|char
modifier|*
name|test
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
comment|/* assume not C_STRNUM */
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|str
expr_stmt|;
name|q
operator|=
name|s
operator|+
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|scan_code
index|[
operator|*
name|s
index|]
operator|==
name|SC_SPACE
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|q
condition|)
return|return ;
while|while
condition|(
name|scan_code
index|[
name|q
index|[
operator|-
literal|1
index|]
index|]
operator|==
name|SC_SPACE
condition|)
name|q
operator|--
expr_stmt|;
if|if
condition|(
name|scan_code
index|[
name|q
index|[
operator|-
literal|1
index|]
index|]
operator|!=
name|SC_DIGIT
operator|&&
name|q
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
return|return ;
switch|switch
condition|(
name|scan_code
index|[
operator|*
name|s
index|]
condition|)
block|{
case|case
name|SC_DIGIT
case|:
case|case
name|SC_PLUS
case|:
case|case
name|SC_MINUS
case|:
case|case
name|SC_DOT
case|:
if|#
directive|if
name|FPE_TRAPS_ON
name|errno
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|dval
operator|=
name|strtod
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
operator|&
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|&&
name|cp
operator|->
name|dval
operator|!=
literal|0.0
condition|)
name|rt_error
argument_list|(
literal|"overflow converting %s to double"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|cp
operator|->
name|dval
operator|=
name|strtod
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
operator|&
name|test
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|q
operator|<=
name|test
condition|)
name|cp
operator|->
name|type
operator|=
name|C_STRNUM
expr_stmt|;
comment|/*<= instead of == , for some buggy strtod 		 e.g. Apple Unix */
block|}
block|}
end_function

begin_comment
comment|/* cast a CELL to a replacement cell */
end_comment

begin_function
name|void
name|cast_to_REPL
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|STRING
modifier|*
name|sval
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sval
operator|=
operator|(
name|STRING
operator|*
operator|)
name|cp
operator|->
name|ptr
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|cp
argument_list|,
name|repl_compile
argument_list|(
name|sval
argument_list|)
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|sval
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_STRTOD
operator|==
literal|0
end_if

begin_comment
comment|/* don't use this unless you really don't have strtod() because    (1) its probably slower than your real strtod()    (2) atof() may call the real strtod()  */
end_comment

begin_function
name|double
name|strtod
parameter_list|(
name|s
parameter_list|,
name|endptr
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
modifier|*
name|endptr
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|double
name|atof
parameter_list|()
function_decl|;
if|if
condition|(
name|endptr
condition|)
block|{
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|scan_code
index|[
operator|*
name|p
index|]
operator|==
name|SC_DIGIT
condition|)
block|{
name|flag
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|scan_code
index|[
operator|*
name|p
index|]
operator|==
name|SC_DIGIT
condition|)
block|{
name|flag
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
comment|/* done with number part */
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
block|{
comment|/* no number part */
operator|*
name|endptr
operator|=
name|s
expr_stmt|;
return|return
literal|0.0
return|;
block|}
else|else
operator|*
name|endptr
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
comment|/* now look for exponent */
if|if
condition|(
operator|*
name|p
operator|==
literal|'e'
operator|||
operator|*
name|p
operator|==
literal|'E'
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|scan_code
index|[
operator|*
name|p
index|]
operator|==
name|SC_DIGIT
condition|)
block|{
name|flag
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
operator|*
name|endptr
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
block|}
block|}
return|return
name|atof
argument_list|(
name|s
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRTOD==0 */
end_comment

begin_if
if|#
directive|if
name|HAVE_FMOD
operator|==
literal|0
end_if

begin_if
if|#
directive|if
name|SW_FP_CHECK
end_if

begin_comment
comment|/* this is V7 and XNX23A specific */
end_comment

begin_function
name|double
name|fmod
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|double
name|modf
parameter_list|()
function_decl|;
name|double
name|dtmp
decl_stmt|,
name|ipart
decl_stmt|;
name|clrerr
argument_list|()
expr_stmt|;
name|dtmp
operator|=
name|x
operator|/
name|y
expr_stmt|;
name|fpcheck
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|modf
argument_list|(
name|dtmp
argument_list|,
operator|&
name|ipart
argument_list|)
expr_stmt|;
return|return
name|x
operator|-
name|ipart
operator|*
name|y
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|double
name|fmod
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|double
name|modf
parameter_list|()
function_decl|;
name|double
name|ipart
decl_stmt|;
operator|(
name|void
operator|)
name|modf
argument_list|(
name|x
operator|/
name|y
argument_list|,
operator|&
name|ipart
argument_list|)
expr_stmt|;
return|return
name|x
operator|-
name|ipart
operator|*
name|y
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

