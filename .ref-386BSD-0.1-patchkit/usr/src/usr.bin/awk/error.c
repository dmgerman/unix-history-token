begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** error.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/* $Log:	error.c,v $  * Revision 5.1  91/12/05  07:55:48  brennan  * 1.1 pre-release  *  */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"scan.h"
end_include

begin_include
include|#
directive|include
file|"bi_vars.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|EOF
end_ifndef

begin_define
define|#
directive|define
name|EOF
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* statics */
end_comment

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|rt_where
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|unexpected_char
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|missing
argument_list|,
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|PROTO
argument_list|(
name|type_to_str
argument_list|,
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|NR_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* on if tracking NR */
end_comment

begin_struct
specifier|static
struct|struct
name|token_str
block|{
name|short
name|token
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|}
name|token_str
index|[]
init|=
block|{
name|EOF
block|,
literal|"end of file"
block|,
name|NL
block|,
literal|"end of line"
block|,
name|SEMI_COLON
block|,
literal|";"
block|,
name|LBRACE
block|,
literal|"{"
block|,
name|RBRACE
block|,
literal|"}"
block|,
name|SC_FAKE_SEMI_COLON
block|,
literal|"}"
block|,
name|LPAREN
block|,
literal|"("
block|,
name|RPAREN
block|,
literal|")"
block|,
name|LBOX
block|,
literal|"["
block|,
name|RBOX
block|,
literal|"]"
block|,
name|QMARK
block|,
literal|"?"
block|,
name|COLON
block|,
literal|":"
block|,
name|OR
block|,
literal|"||"
block|,
name|AND
block|,
literal|"&&"
block|,
name|ASSIGN
block|,
literal|"="
block|,
name|ADD_ASG
block|,
literal|"+="
block|,
name|SUB_ASG
block|,
literal|"-="
block|,
name|MUL_ASG
block|,
literal|"*="
block|,
name|DIV_ASG
block|,
literal|"/="
block|,
name|MOD_ASG
block|,
literal|"%="
block|,
name|POW_ASG
block|,
literal|"^="
block|,
name|EQ
block|,
literal|"=="
block|,
name|NEQ
block|,
literal|"!="
block|,
name|LT
block|,
literal|"<"
block|,
name|LTE
block|,
literal|"<="
block|,
name|GT
block|,
literal|">"
block|,
name|GTE
block|,
literal|">="
block|,
name|MATCH
block|,
name|string_buff
block|,
name|PLUS
block|,
literal|"+"
block|,
name|MINUS
block|,
literal|"-"
block|,
name|MUL
block|,
literal|"*"
block|,
name|DIV
block|,
literal|"/"
block|,
name|MOD
block|,
literal|"%"
block|,
name|POW
block|,
literal|"^"
block|,
name|NOT
block|,
literal|"!"
block|,
name|COMMA
block|,
literal|","
block|,
name|INC_or_DEC
block|,
name|string_buff
block|,
name|DOUBLE
block|,
name|string_buff
block|,
name|STRING_
block|,
name|string_buff
block|,
name|ID
block|,
name|string_buff
block|,
name|FUNCT_ID
block|,
name|string_buff
block|,
name|BUILTIN
block|,
name|string_buff
block|,
name|IO_OUT
block|,
name|string_buff
block|,
name|IO_IN
block|,
literal|"<"
block|,
name|PIPE
block|,
literal|"|"
block|,
name|DOLLAR
block|,
literal|"$"
block|,
name|FIELD
block|,
literal|"$"
block|,
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
struct|;
end_struct

begin_comment
comment|/* if paren_cnt>0 and we see one of these, we are missing a ')' */
end_comment

begin_decl_stmt
specifier|static
name|int
name|missing_rparen
index|[]
init|=
block|{
name|EOF
block|,
name|NL
block|,
name|SEMI_COLON
block|,
name|SC_FAKE_SEMI_COLON
block|,
name|RBRACE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ditto for '}' */
end_comment

begin_decl_stmt
specifier|static
name|int
name|missing_rbrace
index|[]
init|=
block|{
name|EOF
block|,
name|BEGIN
block|,
name|END
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|missing
parameter_list|(
name|c
parameter_list|,
name|n
parameter_list|,
name|ln
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
name|int
name|ln
decl_stmt|;
block|{
name|char
modifier|*
name|s0
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
if|if
condition|(
name|pfile_name
condition|)
block|{
name|s0
operator|=
name|pfile_name
expr_stmt|;
name|s1
operator|=
literal|": "
expr_stmt|;
block|}
else|else
name|s0
operator|=
name|s1
operator|=
literal|""
expr_stmt|;
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"%s%sline %u: missing %c near %s"
argument_list|,
name|s0
argument_list|,
name|s1
argument_list|,
name|ln
argument_list|,
name|c
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|yyerror
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
comment|/* we won't use s as input    (yacc and bison force this).   We will use s for storage to keep lint or the compiler   off our back */
block|{
name|struct
name|token_str
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|token_str
init|;
name|p
operator|->
name|token
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|current_token
operator|==
name|p
operator|->
name|token
condition|)
block|{
name|s
operator|=
name|p
operator|->
name|str
expr_stmt|;
break|break ;
block|}
if|if
condition|(
operator|!
name|s
condition|)
comment|/* search the keywords */
name|s
operator|=
name|find_kw_str
argument_list|(
name|current_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|paren_cnt
condition|)
for|for
control|(
name|ip
operator|=
name|missing_rparen
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
if|if
condition|(
operator|*
name|ip
operator|==
name|current_token
condition|)
block|{
name|missing
argument_list|(
literal|')'
argument_list|,
name|s
argument_list|,
name|token_lineno
argument_list|)
expr_stmt|;
name|paren_cnt
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|brace_cnt
condition|)
for|for
control|(
name|ip
operator|=
name|missing_rbrace
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
if|if
condition|(
operator|*
name|ip
operator|==
name|current_token
condition|)
block|{
name|missing
argument_list|(
literal|'}'
argument_list|,
name|s
argument_list|,
name|token_lineno
argument_list|)
expr_stmt|;
name|brace_cnt
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|compile_error
argument_list|(
literal|"syntax error at or near %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* special cases */
switch|switch
condition|(
name|current_token
condition|)
block|{
case|case
name|UNEXPECTED
case|:
name|unexpected_char
argument_list|()
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|BAD_DECIMAL
case|:
name|compile_error
argument_list|(
literal|"syntax error in decimal constant %s"
argument_list|,
name|string_buff
argument_list|)
expr_stmt|;
break|break ;
case|case
name|RE
case|:
name|compile_error
argument_list|(
literal|"syntax error at or near /%s/"
argument_list|,
name|string_buff
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|compile_error
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
break|break ;
block|}
return|return ;
name|done
label|:
if|if
condition|(
operator|++
name|compile_error_count
operator|==
name|MAX_COMPILE_ERRORS
condition|)
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* system provided errnos and messages */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS_MSC
end_ifndef

begin_comment
comment|/* don't need the declarations */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|THINK_C
end_ifndef

begin_comment
comment|/* don't WANT the declarations */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STDARG_H
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_comment
comment|/* generic error message with a hook into the system error     messages if errnum> 0 */
end_comment

begin_function
name|void
name|errmsg
parameter_list|(
name|int
name|errnum
parameter_list|,
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THINK_C
if|if
condition|(
name|errnum
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)"
argument_list|,
name|strerror
argument_list|(
name|errnum
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|errnum
operator|>
literal|0
operator|&&
name|errnum
operator|<
name|sys_nerr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)"
argument_list|,
name|sys_errlist
index|[
name|errnum
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compile_error
parameter_list|(
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|s0
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
comment|/* with multiple program files put program name in      error message */
if|if
condition|(
name|pfile_name
condition|)
block|{
name|s0
operator|=
name|pfile_name
expr_stmt|;
name|s1
operator|=
literal|": "
expr_stmt|;
block|}
else|else
block|{
name|s0
operator|=
name|s1
operator|=
literal|""
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s%sline %u: "
argument_list|,
name|progname
argument_list|,
name|s0
argument_list|,
name|s1
argument_list|,
name|token_lineno
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|compile_error_count
operator|==
name|MAX_COMPILE_ERRORS
condition|)
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rt_error
parameter_list|(
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: run time error: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|rt_where
argument_list|()
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_comment
comment|/*  void errmsg(errnum, format, ...) */
end_comment

begin_function
name|void
name|errmsg
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|errnum
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|errnum
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|THINK_C
if|if
condition|(
name|errnum
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)"
argument_list|,
name|strerror
argument_list|(
name|errnum
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|errnum
operator|>
literal|0
operator|&&
name|errnum
operator|<
name|sys_nerr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%s)"
argument_list|,
name|sys_errlist
index|[
name|errnum
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compile_error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|char
modifier|*
name|s0
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
if|if
condition|(
name|pfile_name
condition|)
comment|/* print program filename too */
block|{
name|s0
operator|=
name|pfile_name
expr_stmt|;
name|s1
operator|=
literal|": "
expr_stmt|;
block|}
else|else
name|s0
operator|=
name|s1
operator|=
literal|""
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s%sline %u: "
argument_list|,
name|progname
argument_list|,
name|s0
argument_list|,
name|s1
argument_list|,
name|token_lineno
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|compile_error_count
operator|==
name|MAX_COMPILE_ERRORS
condition|)
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rt_error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: run time error: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|rt_where
argument_list|()
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|bozo
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"bozo: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|overflow
parameter_list|(
name|s
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"program limit exceeded: %s size=%u"
argument_list|,
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print as much as we know about where a rt error occured */
end_comment

begin_function
specifier|static
name|void
name|rt_where
parameter_list|()
block|{
if|if
condition|(
name|FILENAME
operator|->
name|type
operator|!=
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|FILENAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|NR
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|NR
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tFILENAME=\"%s\""
argument_list|,
name|string
argument_list|(
name|FILENAME
argument_list|)
operator|->
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|NR_flag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" FNR=%g NR=%g"
argument_list|,
name|FNR
operator|->
name|dval
argument_list|,
name|NR
operator|->
name|dval
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* run time */
end_comment

begin_function
name|void
name|rt_overflow
parameter_list|(
name|s
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"program limit exceeded: %s size=%u"
argument_list|,
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|rt_where
argument_list|()
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unexpected_char
parameter_list|()
block|{
name|int
name|c
init|=
name|yylval
operator|.
name|ival
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %u: "
argument_list|,
name|progname
argument_list|,
name|token_lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|' '
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexpected character '%c'\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexpected character 0x%02x\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|type_to_str
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|retval
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ST_VAR
case|:
name|retval
operator|=
literal|"variable"
expr_stmt|;
break|break ;
case|case
name|ST_ARRAY
case|:
name|retval
operator|=
literal|"array"
expr_stmt|;
break|break ;
case|case
name|ST_FUNCT
case|:
name|retval
operator|=
literal|"function"
expr_stmt|;
break|break ;
case|case
name|ST_LOCAL_VAR
case|:
name|retval
operator|=
literal|"local variable"
expr_stmt|;
break|break ;
case|case
name|ST_LOCAL_ARRAY
case|:
name|retval
operator|=
literal|"local array"
expr_stmt|;
break|break ;
default|default :
name|bozo
argument_list|(
literal|"type_to_str"
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* emit an error message about a type clash */
end_comment

begin_function
name|void
name|type_error
parameter_list|(
name|p
parameter_list|)
name|SYMTAB
modifier|*
name|p
decl_stmt|;
block|{
name|compile_error
argument_list|(
literal|"illegal reference to %s %s"
argument_list|,
name|type_to_str
argument_list|(
name|p
operator|->
name|type
argument_list|)
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

