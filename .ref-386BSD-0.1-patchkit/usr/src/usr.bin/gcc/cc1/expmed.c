begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Medium-level subroutines: convert bit-field store and extract    and shifts, multiplies and divides to rtl instructions.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_function_decl
specifier|static
name|rtx
name|extract_split_bit_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|extract_fixed_bit_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_split_bit_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_fixed_bit_field
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return an rtx representing minus the value of X.    MODE is the intended mode of the result,    useful if X is a CONST_INT.  */
end_comment

begin_function
name|rtx
name|negate_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|val
init|=
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|HOST_BITS_PER_INT
condition|)
block|{
comment|/* Sign extend the value from the bits that are significant.  */
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|val
operator||=
operator|(
operator|-
literal|1
operator|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|val
operator|&=
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|val
argument_list|)
return|;
block|}
else|else
return|return
name|expand_unop
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|neg_optab
argument_list|,
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to store value from rtx VALUE    into a bit-field within structure STR_RTX    containing BITSIZE bits starting at bit BITNUM.    FIELDMODE is the machine-mode of the FIELD_DECL node for this field.    ALIGN is the alignment that STR_RTX is known to have, measured in bytes.    TOTAL_SIZE is the size of the structure in bytes, or -1 if unknown.  */
end_comment

begin_function
name|rtx
name|store_bit_field
parameter_list|(
name|str_rtx
parameter_list|,
name|bitsize
parameter_list|,
name|bitnum
parameter_list|,
name|fieldmode
parameter_list|,
name|value
parameter_list|,
name|align
parameter_list|,
name|total_size
parameter_list|)
name|rtx
name|str_rtx
decl_stmt|;
specifier|register
name|int
name|bitsize
decl_stmt|;
name|int
name|bitnum
decl_stmt|;
name|enum
name|machine_mode
name|fieldmode
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|total_size
decl_stmt|;
block|{
name|int
name|unit
init|=
operator|(
name|GET_CODE
argument_list|(
name|str_rtx
argument_list|)
operator|==
name|MEM
operator|)
condition|?
name|BITS_PER_UNIT
else|:
name|BITS_PER_WORD
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|bitnum
operator|/
name|unit
decl_stmt|;
specifier|register
name|int
name|bitpos
init|=
name|bitnum
operator|%
name|unit
decl_stmt|;
specifier|register
name|rtx
name|op0
init|=
name|str_rtx
decl_stmt|;
name|rtx
name|value1
decl_stmt|;
comment|/* At this point, BITPOS counts within UNIT for a memref.      For a register or a subreg, it actually counts within the width      of the mode of OP0.  However, BITNUM never exceeds that width,      so the % operation above never really does anything.       We will adjust BITPOS later to count properly within UNIT      in the case of a register.  */
comment|/* Discount the part of the structure before the desired byte.      We need to know how many bytes are safe to reference after it.  */
if|if
condition|(
name|total_size
operator|>=
literal|0
condition|)
name|total_size
operator|-=
operator|(
name|bitpos
operator|/
name|BIGGEST_ALIGNMENT
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* Keep BITPOS counting within the size of op0.  */
name|bitpos
operator|+=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|protect_from_queue
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|value
operator|=
name|force_not_mem
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|fieldmode
argument_list|)
operator|>=
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|fieldmode
argument_list|)
operator|==
name|bitsize
operator|&&
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Storing in a full-word or multi-word field in a register 	 can be done with just SUBREG.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|fieldmode
condition|)
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|fieldmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* If OP0 is a register, BITPOS must count within UNIT, which should be SI.      But as we have it, it counts within whatever size OP0 now has.      These are not the same, so convert if big-endian.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|&&
name|unit
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
name|bitpos
operator|+=
name|unit
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Change the mode now so we don't adjust BITPOS again.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|PUT_MODE
argument_list|(
name|op0
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Storing an lsb-aligned field in a register      can be done with a movestrict instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
operator|&&
name|bitpos
operator|+
name|bitsize
operator|==
name|unit
else|#
directive|else
operator|&&
name|bitpos
operator|==
literal|0
endif|#
directive|endif
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|fieldmode
operator|||
operator|(
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|fieldmode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
block|{
comment|/* Get appropriate low part of the value being stored.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
condition|)
name|value
operator|=
name|gen_lowpart
argument_list|(
name|fieldmode
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST
operator|)
condition|)
name|value
operator|=
name|convert_to_mode
argument_list|(
name|fieldmode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|fieldmode
condition|)
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|PUT_MODE
argument_list|(
name|op0
argument_list|,
name|fieldmode
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|fieldmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|fieldmode
index|]
operator|.
name|insn_code
argument_list|)
argument_list|(
name|op0
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/* Handle fields bigger than a word.  */
if|if
condition|(
name|bitsize
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|int
name|low_size
init|=
name|BITS_PER_WORD
decl_stmt|;
name|int
name|low_pos
init|=
name|bitpos
operator|+
name|offset
operator|*
name|unit
decl_stmt|;
name|int
name|high_size
init|=
name|bitsize
operator|-
name|low_size
decl_stmt|;
name|int
name|high_pos
decl_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
name|high_pos
operator|=
name|low_pos
expr_stmt|;
name|low_pos
operator|+=
name|high_size
expr_stmt|;
else|#
directive|else
name|high_pos
operator|=
name|low_pos
operator|+
name|low_size
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|store_bit_field
argument_list|(
name|op0
argument_list|,
name|low_size
argument_list|,
name|low_pos
argument_list|,
name|SImode
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|value
argument_list|)
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
name|store_bit_field
argument_list|(
name|op0
argument_list|,
name|high_size
argument_list|,
name|high_pos
argument_list|,
name|SImode
argument_list|,
name|gen_highpart
argument_list|(
name|SImode
argument_list|,
name|value
argument_list|)
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* From here on we can assume that the field to be stored in is an integer,      since it is shorter than a word.  */
comment|/* OFFSET is the number of words or bytes (UNIT says which)      from STR_RTX to the first word or byte containing part of the field.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* If not in memory, merge in the offset now.  */
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
operator|+=
name|offset
expr_stmt|;
else|else
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now OFFSET is nonzero only if OP0 is memory      and is therefore always measured in bytes.  */
ifdef|#
directive|ifdef
name|HAVE_insv
if|if
condition|(
name|HAVE_insv
operator|&&
operator|!
operator|(
name|bitsize
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
block|{
name|int
name|xbitpos
init|=
name|bitpos
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
comment|/* If this machine's insv can only insert into a register, 	 copy OP0 into a register and save it back later.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|rtx
name|tempreg
decl_stmt|;
name|enum
name|machine_mode
name|trymode
decl_stmt|,
name|bestmode
init|=
name|VOIDmode
decl_stmt|,
name|insn_mode
decl_stmt|;
comment|/* Don't use a mode bigger than the one of the value to be stored. 	     That mode must be okay, since a bit field can be that big.  */
name|int
name|maxsize
init|=
name|GET_MODE_SIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
comment|/* This used to use the mode desired for operand 0, 	     but that is normally QImode on most machines, 	     and QImode won't work for fields that cross byte 	     boundaries.  */
comment|/* Also don't use a mode bigger than the structure.  */
if|if
condition|(
name|total_size
operator|>=
literal|0
operator|&&
name|maxsize
operator|>
name|total_size
condition|)
name|maxsize
operator|=
name|total_size
expr_stmt|;
comment|/* Find biggest machine mode we can safely use 	     to fetch from this structure. 	     But don't use a bigger mode than the insn wants.  */
for|for
control|(
name|trymode
operator|=
name|QImode
init|;
name|trymode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|trymode
argument_list|)
operator|<=
name|maxsize
condition|;
name|trymode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|trymode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|trymode
argument_list|)
operator|<=
name|align
operator|||
name|align
operator|==
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|bestmode
operator|=
name|trymode
expr_stmt|;
if|if
condition|(
operator|!
name|bestmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Adjust address to point to the containing unit of that mode.  */
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
comment|/* Compute offset as multiple of this unit, counting in bytes.  */
name|offset
operator|=
operator|(
name|bitnum
operator|/
name|unit
operator|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|bitnum
operator|%
name|unit
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|bestmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch that unit, store the bitfield in it, then store the unit.  */
name|tempreg
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* To actually store in TEMPREG, 	     look at it in the mode this insn calls for. 	     (Probably SImode.)  */
name|insn_mode
operator|=
name|SImode
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|insn_mode
argument_list|)
operator|>
name|unit
condition|)
name|bitpos
operator|+=
name|GET_MODE_BITSIZE
argument_list|(
name|insn_mode
argument_list|)
operator|-
name|unit
expr_stmt|;
endif|#
directive|endif
name|store_bit_field
argument_list|(
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|insn_mode
argument_list|,
name|tempreg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|fieldmode
argument_list|,
name|value
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* Add OFFSET into OP0's address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|MEM
condition|)
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If xop0 is a register, we need it in SImode 	 to make it acceptable to the format of insv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
condition|)
name|PUT_MODE
argument_list|(
name|xop0
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|SImode
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
name|xbitpos
operator|+=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|xop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Convert VALUE to SImode (which insv insn wants) in VALUE1.  */
name|value1
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|SImode
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>=
name|bitsize
condition|)
block|{
comment|/* Optimization: Don't bother really extending VALUE 		 if it has all the bits we will actually use.  */
comment|/* Avoid making subreg of a subreg, or of a mem.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value1
argument_list|)
operator|!=
name|REG
condition|)
name|value1
operator|=
name|copy_to_reg
argument_list|(
name|value1
argument_list|)
expr_stmt|;
name|value1
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|value1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|value
argument_list|)
condition|)
comment|/* Parse phase is supposed to make VALUE's data type 	       match that of the component reference, which is a type 	       at least as wide as the field; so VALUE should have 	       a mode that corresponds to that type.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this machine's insv insists on a register, 	 get VALUE1 into a register.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|3
index|]
call|)
argument_list|(
name|value1
argument_list|,
name|SImode
argument_list|)
condition|)
name|value1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|value1
argument_list|)
expr_stmt|;
comment|/* On big-endian machines, we count bits from the most significant. 	 If the bit field insn does not, we must invert.  */
if|#
directive|if
name|defined
argument_list|(
name|BITS_BIG_ENDIAN
argument_list|)
operator|!=
name|defined
argument_list|(
name|BYTES_BIG_ENDIAN
argument_list|)
name|xbitpos
operator|=
name|unit
operator|-
literal|1
operator|-
name|xbitpos
expr_stmt|;
endif|#
directive|endif
name|pat
operator|=
name|gen_insv
argument_list|(
name|xop0
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|bitsize
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|xbitpos
argument_list|)
argument_list|,
name|value1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
else|else
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|store_fixed_bit_field
argument_list|(
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|value
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* Insv is not available; store using shifts and boolean ops.  */
name|store_fixed_bit_field
argument_list|(
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|value
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use shifts and boolean operations to store VALUE    into a bit field of width BITSIZE    in a memory location specified by OP0 except offset by OFFSET bytes.      (OFFSET must be 0 if OP0 is a register.)    The field starts at position BITPOS within the byte.     (If OP0 is a register, it may be SImode or a narrower mode,      but BITPOS still counts within a full word,      which is significant on bigendian machines.)    STRUCT_ALIGN is the alignment the structure is known to have (in bytes).     Note that protect_from_queue has already been done on OP0 and VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|store_fixed_bit_field
parameter_list|(
name|op0
parameter_list|,
name|offset
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|value
parameter_list|,
name|struct_align
parameter_list|)
specifier|register
name|rtx
name|op0
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|,
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
specifier|register
name|rtx
name|value
decl_stmt|;
name|int
name|struct_align
decl_stmt|;
block|{
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|total_bits
init|=
name|BITS_PER_WORD
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|;
name|int
name|all_zero
init|=
literal|0
decl_stmt|;
name|int
name|all_one
init|=
literal|0
decl_stmt|;
comment|/* Add OFFSET to OP0's address (if it is in memory)      and if a single byte contains the whole bit field      change OP0 to a byte.  */
comment|/* There is a case not handled here:      a structure with a known alignment of just a halfword      and a field split across two aligned halfwords within the structure.      Or likewise a structure with a known alignment of just a byte      and a field split across two bytes.      Such cases are not supposed to be able to occur.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Special treatment for a bit field split across two registers.  */
if|if
condition|(
name|bitsize
operator|+
name|bitpos
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|store_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|value
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|bitsize
operator|+
name|bitpos
operator|<=
name|BITS_PER_UNIT
operator|&&
operator|(
operator|!
name|SLOW_BYTE_ACCESS
operator|||
operator|(
name|struct_align
operator|==
literal|1
operator|&&
name|BIGGEST_ALIGNMENT
operator|>
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* It fits in one byte, and either bytes are fast 	 or the alignment won't let us use anything bigger.  */
name|total_bits
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bitsize
operator|+
name|bitpos
operator|+
operator|(
name|offset
operator|%
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
operator|)
operator|*
name|BITS_PER_UNIT
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|)
comment|/* If halfwords are fast, use them whenever valid.  */
operator|&&
operator|(
operator|!
name|SLOW_BYTE_ACCESS
comment|/* Use halfwords if larger is invalid due to alignment.  */
operator|||
operator|(
name|struct_align
operator|==
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
operator|&&
name|BIGGEST_ALIGNMENT
operator|>
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* It fits in an aligned halfword within the structure, 	 and either halfwords are fast 	 or the alignment won't let us use anything bigger.  */
name|total_bits
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
comment|/* Get ref to halfword containing the field.  */
name|bitpos
operator|+=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|offset
operator|-=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Get ref to an aligned word containing the field.  */
comment|/* Adjust BITPOS to be position within a word, 	 and OFFSET to be the offset of that word. 	 Then alter OP0 to refer to that word.  */
name|bitpos
operator|+=
operator|(
name|offset
operator|%
operator|(
name|BITS_PER_WORD
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|offset
operator|-=
operator|(
name|offset
operator|%
operator|(
name|BITS_PER_WORD
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Special treatment for a bit field split across two aligned words.  */
if|if
condition|(
name|bitsize
operator|+
name|bitpos
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|store_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|value
argument_list|,
name|struct_align
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* Now MODE is either QImode, HImode or SImode for a MEM as OP0,      or is SImode for a REG as OP0.  TOTAL_BITS corresponds.      The bit field is contained entirely within OP0.      BITPOS is the starting bit number within OP0.      (OP0's mode may actually be narrower than MODE.)  */
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* BITPOS is the distance between our msb      and that of the containing datum.      Convert it to the distance from the lsb.  */
name|bitpos
operator|=
name|total_bits
operator|-
name|bitsize
operator|-
name|bitpos
expr_stmt|;
endif|#
directive|endif
comment|/* Now BITPOS is always the distance between our lsb      and that of OP0.  */
comment|/* Shift VALUE left by BITPOS bits.  If VALUE is not constant,      we must first convert its mode to MODE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
specifier|register
name|int
name|v
init|=
name|INTVAL
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitsize
operator|<
name|HOST_BITS_PER_INT
condition|)
name|v
operator|&=
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|all_zero
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|bitsize
operator|<
name|HOST_BITS_PER_INT
operator|&&
name|v
operator|==
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
condition|)
name|all_one
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|v
operator|<<
name|bitpos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|must_and
init|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|bitsize
operator|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|mode
condition|)
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|must_and
operator|&&
name|bitsize
operator|<
name|HOST_BITS_PER_INT
condition|)
name|value
operator|=
name|expand_bit_and
argument_list|(
name|mode
argument_list|,
name|value
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|>
literal|0
condition|)
name|value
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|build_int_2
argument_list|(
name|bitpos
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now clear the chosen bits in OP0,      except that if VALUE is -1 we need not bother.  */
name|subtarget
operator|=
name|op0
expr_stmt|;
if|if
condition|(
operator|!
name|all_one
condition|)
name|subtarget
operator|=
name|expand_bit_and
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
operator|~
operator|(
operator|(
operator|(
name|unsigned
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_INT
operator|-
name|bitsize
operator|)
operator|)
operator|<<
name|bitpos
operator|)
operator|)
operator|&
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|==
name|HOST_BITS_PER_INT
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|)
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
comment|/* Now logical-or VALUE into OP0, unless it is zero.  */
if|if
condition|(
operator|!
name|all_zero
condition|)
name|subtarget
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|subtarget
argument_list|,
name|value
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|subtarget
condition|)
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store a bit field that is split across two words.     OP0 is the REG, SUBREG or MEM rtx for the first of the two words.    BITSIZE is the field width; BITPOS the position of its first bit    (within the word).    VALUE is the value to store.  */
end_comment

begin_function
specifier|static
name|void
name|store_split_bit_field
parameter_list|(
name|op0
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|value
parameter_list|,
name|align
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
comment|/* BITSIZE_1 is size of the part in the first word.  */
name|int
name|bitsize_1
init|=
name|BITS_PER_WORD
operator|-
name|bitpos
decl_stmt|;
comment|/* BITSIZE_2 is size of the rest (in the following word).  */
name|int
name|bitsize_2
init|=
name|bitsize
operator|-
name|bitsize_1
decl_stmt|;
name|rtx
name|part1
decl_stmt|,
name|part2
decl_stmt|;
comment|/* Alignment of VALUE, after conversion.  */
name|int
name|valalign
init|=
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|value
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|value
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|value
operator|=
name|copy_to_reg
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Split the value into two parts:      PART1 gets that which goes in the first word; PART2 the other.  */
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* PART1 gets the more significant part.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|part1
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>>
name|bitsize_2
argument_list|)
expr_stmt|;
name|part2
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bitsize_2
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|part1
operator|=
name|extract_fixed_bit_field
argument_list|(
name|SImode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|bitsize_1
argument_list|,
name|BITS_PER_WORD
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|valalign
argument_list|)
expr_stmt|;
name|part2
operator|=
name|extract_fixed_bit_field
argument_list|(
name|SImode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|bitsize_2
argument_list|,
name|BITS_PER_WORD
operator|-
name|bitsize_2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|valalign
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* PART1 gets the less significant part.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|part1
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bitsize_1
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|part2
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>>
name|bitsize_1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|part1
operator|=
name|extract_fixed_bit_field
argument_list|(
name|SImode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|bitsize_1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|valalign
argument_list|)
expr_stmt|;
name|part2
operator|=
name|extract_fixed_bit_field
argument_list|(
name|SImode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|bitsize_2
argument_list|,
name|bitsize_1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|valalign
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Store PART1 into the first word.  */
name|store_fixed_bit_field
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|,
name|bitsize_1
argument_list|,
name|bitpos
argument_list|,
name|part1
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Offset op0 to get to the following word.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Store PART2 into the second word.  */
name|store_fixed_bit_field
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|,
name|bitsize_2
argument_list|,
literal|0
argument_list|,
name|part2
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to extract a byte-field from STR_RTX    containing BITSIZE bits, starting at BITNUM,    and put it in TARGET if possible (if TARGET is nonzero).    Regardless of TARGET, we return the rtx for where the value is placed.    It may be a QUEUED.     STR_RTX is the structure containing the byte (a REG or MEM).    UNSIGNEDP is nonzero if this is an unsigned bit field.    MODE is the natural mode of the field value once extracted.    TMODE is the mode the caller would like the value to have;    but the value may be returned with type MODE instead.     ALIGN is the alignment that STR_RTX is known to have, measured in bytes.    TOTAL_SIZE is the total size in bytes of the structure, if known.    Otherwise it is -1.     If a TARGET is specified and we can store in it at no extra cost,    we do so, and return TARGET.    Otherwise, we return a REG of mode TMODE or MODE, with TMODE preferred    if they are equally easy.  */
end_comment

begin_function
name|rtx
name|extract_bit_field
parameter_list|(
name|str_rtx
parameter_list|,
name|bitsize
parameter_list|,
name|bitnum
parameter_list|,
name|unsignedp
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|,
name|tmode
parameter_list|,
name|align
parameter_list|,
name|total_size
parameter_list|)
name|rtx
name|str_rtx
decl_stmt|;
specifier|register
name|int
name|bitsize
decl_stmt|;
name|int
name|bitnum
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|tmode
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|total_size
decl_stmt|;
block|{
name|int
name|unit
init|=
operator|(
name|GET_CODE
argument_list|(
name|str_rtx
argument_list|)
operator|==
name|MEM
operator|)
condition|?
name|BITS_PER_UNIT
else|:
name|BITS_PER_WORD
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|bitnum
operator|/
name|unit
decl_stmt|;
specifier|register
name|int
name|bitpos
init|=
name|bitnum
operator|%
name|unit
decl_stmt|;
specifier|register
name|rtx
name|op0
init|=
name|str_rtx
decl_stmt|;
name|rtx
name|spec_target
init|=
name|target
decl_stmt|;
name|rtx
name|bitsize_rtx
decl_stmt|,
name|bitpos_rtx
decl_stmt|;
name|rtx
name|spec_target_subreg
init|=
literal|0
decl_stmt|;
comment|/* Discount the part of the structure before the desired byte.      We need to know how many bytes are safe to reference after it.  */
if|if
condition|(
name|total_size
operator|>=
literal|0
condition|)
name|total_size
operator|-=
operator|(
name|bitpos
operator|/
name|BIGGEST_ALIGNMENT
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|tmode
operator|==
name|VOIDmode
condition|)
name|tmode
operator|=
name|mode
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* Keep BITPOS counting within the size of op0.  */
name|bitpos
operator|+=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* If OP0 is a register, BITPOS must count within a word.      But as we have it, it counts within whatever size OP0 now has.      On a bigendian machine, these are not the same, so convert.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|&&
name|unit
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
block|{
name|bitpos
operator|+=
name|unit
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Change the mode now so we don't adjust BITPOS again.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|PUT_MODE
argument_list|(
name|op0
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Extracting a full-word or multi-word value      from a structure in a register.      This can be done with just SUBREG.      So too extracting a subword value in      the least significant part of the register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|bitsize
operator|>=
name|BITS_PER_WORD
operator|&&
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|||
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
operator|||
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
operator|&&
name|bitpos
operator|+
name|bitsize
operator|==
name|BITS_PER_WORD
else|#
directive|else
operator|&&
name|bitpos
operator|==
literal|0
endif|#
directive|endif
operator|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|mode1
init|=
name|mode
decl_stmt|;
if|if
condition|(
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
condition|)
name|mode1
operator|=
name|QImode
expr_stmt|;
if|if
condition|(
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
condition|)
name|mode1
operator|=
name|HImode
expr_stmt|;
if|if
condition|(
name|mode1
operator|!=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|PUT_MODE
argument_list|(
name|op0
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode1
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode1
operator|!=
name|mode
condition|)
return|return
name|convert_to_mode
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
return|;
return|return
name|op0
return|;
block|}
comment|/* Handle fields bigger than a word.  */
if|if
condition|(
name|bitsize
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|int
name|low_size
init|=
name|BITS_PER_WORD
decl_stmt|;
name|int
name|low_pos
init|=
name|bitpos
operator|+
name|offset
operator|*
name|unit
decl_stmt|;
name|rtx
name|target_low_part
decl_stmt|,
name|low_part
decl_stmt|;
name|int
name|high_size
init|=
name|bitsize
operator|-
name|low_size
decl_stmt|;
name|int
name|high_pos
decl_stmt|;
name|rtx
name|target_high_part
decl_stmt|,
name|high_part
decl_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
name|high_pos
operator|=
name|low_pos
expr_stmt|;
name|low_pos
operator|+=
name|high_size
expr_stmt|;
else|#
directive|else
name|high_pos
operator|=
name|low_pos
operator|+
name|low_size
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Extract the low part of the bitfield, and make sure 	 to store it in the low part of TARGET.  */
name|target_low_part
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|low_part
operator|=
name|extract_bit_field
argument_list|(
name|op0
argument_list|,
name|low_size
argument_list|,
name|low_pos
argument_list|,
literal|1
argument_list|,
name|target_low_part
argument_list|,
name|SImode
argument_list|,
name|SImode
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|low_part
operator|!=
name|target_low_part
condition|)
name|emit_move_insn
argument_list|(
name|target_low_part
argument_list|,
name|low_part
argument_list|)
expr_stmt|;
comment|/* Likewise for the high part.  */
name|target_high_part
operator|=
name|gen_highpart
argument_list|(
name|SImode
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|high_part
operator|=
name|extract_bit_field
argument_list|(
name|op0
argument_list|,
name|high_size
argument_list|,
name|high_pos
argument_list|,
name|unsignedp
argument_list|,
name|target_high_part
argument_list|,
name|SImode
argument_list|,
name|SImode
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|high_part
operator|!=
name|target_high_part
condition|)
name|emit_move_insn
argument_list|(
name|target_high_part
argument_list|,
name|high_part
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* From here on we know the desired field is smaller than a word      so we can assume it is an integer.  So we can safely extract it as one      size of integer, if necessary, and then truncate or extend      to the size that is wanted.  */
comment|/* OFFSET is the number of words or bytes (UNIT says which)      from STR_RTX to the first word or byte containing part of the field.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* If not in memory, merge in the offset now.  */
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
operator|+=
name|offset
expr_stmt|;
else|else
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|str_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now OFFSET is nonzero only for memory operands.  */
if|if
condition|(
name|unsignedp
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_extzv
if|if
condition|(
name|HAVE_extzv
condition|)
block|{
name|int
name|xbitpos
init|=
name|bitpos
decl_stmt|,
name|xoffset
init|=
name|offset
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
name|rtx
name|xtarget
init|=
name|target
decl_stmt|;
name|rtx
name|xspec_target
init|=
name|spec_target
decl_stmt|;
name|rtx
name|xspec_target_subreg
init|=
name|spec_target_subreg
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Is the memory operand acceptable?  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xop0
argument_list|,
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* No, load into a reg and extract from there.  */
name|enum
name|machine_mode
name|bestmode
init|=
name|VOIDmode
decl_stmt|,
name|trymode
decl_stmt|;
comment|/* Don't use a mode bigger than the one of the value 		     to be fetched.  That mode must be okay, 		     since a bit field can be that big.  */
name|int
name|maxsize
init|=
name|GET_MODE_SIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* This used to use the mode desired for operand 1, 		     but that is normally QImode on most machines, 		     and QImode won't work for fields that cross byte 		     boundaries.  */
comment|/* Also don't use a mode bigger than the structure.  */
if|if
condition|(
name|total_size
operator|>=
literal|0
operator|&&
name|maxsize
operator|>
name|total_size
condition|)
name|maxsize
operator|=
name|total_size
expr_stmt|;
comment|/* Find biggest machine mode we can safely use 		     to fetch from this structure. 		     But don't use a bigger mode than the insn wants.  */
for|for
control|(
name|trymode
operator|=
name|QImode
init|;
name|trymode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|trymode
argument_list|)
operator|<=
name|maxsize
condition|;
name|trymode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|trymode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|trymode
argument_list|)
operator|<=
name|align
operator|||
name|align
operator|==
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|bestmode
operator|=
name|trymode
expr_stmt|;
if|if
condition|(
operator|!
name|bestmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
comment|/* Compute offset as multiple of this unit, 		     counting in bytes.  */
name|xoffset
operator|=
operator|(
name|bitnum
operator|/
name|unit
operator|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|xbitpos
operator|=
name|bitnum
operator|%
name|unit
expr_stmt|;
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|bestmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch it to a register in that size.  */
name|xop0
operator|=
name|force_reg
argument_list|(
name|bestmode
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
comment|/* Now ref the register in the mode extzv wants.  */
comment|/* We used to use the mode from operand 1 in the md, 		     but that is often QImode because that's needed for MEM. 		     Here we need SImode instead.  */
if|if
condition|(
name|bestmode
operator|!=
name|SImode
condition|)
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|xop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|>
name|unit
condition|)
name|xbitpos
operator|+=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|-
name|unit
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* Get ref to first byte containing part of the field.  */
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If op0 is a register, we need it in SImode 	     to make it acceptable to the format of extzv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|SImode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|SImode
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
name|xbitpos
operator|+=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|xop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xtarget
operator|==
literal|0
operator|||
operator|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|xtarget
operator|=
name|xspec_target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xtarget
argument_list|)
operator|!=
name|SImode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|REG
condition|)
name|xspec_target_subreg
operator|=
name|xtarget
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|xtarget
argument_list|)
expr_stmt|;
else|else
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
block|}
comment|/* If this machine's extzv insists on a register target, 	     make sure we have one.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|xtarget
argument_list|,
name|SImode
argument_list|)
condition|)
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
comment|/* On big-endian machines, we count bits from the most significant. 	     If the bit field insn does not, we must invert.  */
if|#
directive|if
name|defined
argument_list|(
name|BITS_BIG_ENDIAN
argument_list|)
operator|!=
name|defined
argument_list|(
name|BYTES_BIG_ENDIAN
argument_list|)
name|xbitpos
operator|=
name|unit
operator|-
literal|1
operator|-
name|xbitpos
expr_stmt|;
endif|#
directive|endif
name|bitsize_rtx
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
name|bitpos_rtx
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|xbitpos
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_extzv
argument_list|(
name|protect_from_queue
argument_list|(
name|xtarget
argument_list|,
literal|1
argument_list|)
argument_list|,
name|xop0
argument_list|,
name|bitsize_rtx
argument_list|,
name|bitpos_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|target
operator|=
name|xtarget
expr_stmt|;
name|spec_target
operator|=
name|xspec_target
expr_stmt|;
name|spec_target_subreg
operator|=
name|xspec_target_subreg
expr_stmt|;
block|}
else|else
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extv
if|if
condition|(
name|HAVE_extv
condition|)
block|{
name|int
name|xbitpos
init|=
name|bitpos
decl_stmt|,
name|xoffset
init|=
name|offset
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xtarget
init|=
name|target
decl_stmt|;
name|rtx
name|xspec_target
init|=
name|spec_target
decl_stmt|;
name|rtx
name|xspec_target_subreg
init|=
name|spec_target_subreg
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Is the memory operand acceptable?  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xop0
argument_list|,
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* No, load into a reg and extract from there.  */
name|enum
name|machine_mode
name|bestmode
init|=
name|VOIDmode
decl_stmt|,
name|trymode
decl_stmt|;
comment|/* Don't use a mode bigger than the one of the value 		     to be fetched.  That mode must be okay, 		     since a bit field can be that big.  */
name|int
name|maxsize
init|=
name|GET_MODE_SIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* This used to use the mode desired for operand 1, 		     but that is normally QImode on most machines, 		     and QImode won't work for fields that cross byte 		     boundaries.  */
comment|/* Also don't use a mode bigger than the structure.  */
if|if
condition|(
name|total_size
operator|>=
literal|0
operator|&&
name|maxsize
operator|>
name|total_size
condition|)
name|maxsize
operator|=
name|total_size
expr_stmt|;
comment|/* Find biggest machine mode we can safely use 		     to fetch from this structure. 		     But don't use a bigger mode than the insn wants.  */
for|for
control|(
name|trymode
operator|=
name|QImode
init|;
name|trymode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|trymode
argument_list|)
operator|<=
name|maxsize
condition|;
name|trymode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|trymode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|trymode
argument_list|)
operator|<=
name|align
operator|||
name|align
operator|==
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|bestmode
operator|=
name|trymode
expr_stmt|;
if|if
condition|(
operator|!
name|bestmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
comment|/* Compute offset as multiple of this unit, 		     counting in bytes.  */
name|xoffset
operator|=
operator|(
name|bitnum
operator|/
name|unit
operator|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|xbitpos
operator|=
name|bitnum
operator|%
name|unit
expr_stmt|;
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|bestmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch it to a register in that size.  */
name|xop0
operator|=
name|force_reg
argument_list|(
name|bestmode
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
comment|/* Now ref the register in the mode extv wants.  */
comment|/* We used to use the mode from operand 1 in the md, 		     but that is often QImode because that's needed for MEM. 		     Here we need SImode instead.  */
if|if
condition|(
name|bestmode
operator|!=
name|SImode
condition|)
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|xop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|>
name|unit
condition|)
name|xbitpos
operator|+=
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|-
name|unit
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* Get ref to first byte containing part of the field.  */
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If op0 is a register, we need it in SImode 	     to make it acceptable to the format of extv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|SImode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|SImode
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
name|xbitpos
operator|+=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|xop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xtarget
operator|==
literal|0
operator|||
operator|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|xtarget
operator|=
name|xspec_target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xtarget
argument_list|)
operator|!=
name|SImode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|REG
condition|)
name|xspec_target_subreg
operator|=
name|xtarget
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|xtarget
argument_list|)
expr_stmt|;
else|else
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
block|}
comment|/* If this machine's extv insists on a register target, 	     make sure we have one.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|xtarget
argument_list|,
name|SImode
argument_list|)
condition|)
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
comment|/* On big-endian machines, we count bits from the most significant. 	     If the bit field insn does not, we must invert.  */
if|#
directive|if
name|defined
argument_list|(
name|BITS_BIG_ENDIAN
argument_list|)
operator|!=
name|defined
argument_list|(
name|BYTES_BIG_ENDIAN
argument_list|)
name|xbitpos
operator|=
name|unit
operator|-
literal|1
operator|-
name|xbitpos
expr_stmt|;
endif|#
directive|endif
name|bitsize_rtx
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
name|bitpos_rtx
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|xbitpos
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_extv
argument_list|(
name|protect_from_queue
argument_list|(
name|xtarget
argument_list|,
literal|1
argument_list|)
argument_list|,
name|xop0
argument_list|,
name|bitsize_rtx
argument_list|,
name|bitpos_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|target
operator|=
name|xtarget
expr_stmt|;
name|spec_target
operator|=
name|xspec_target
expr_stmt|;
name|spec_target_subreg
operator|=
name|xspec_target_subreg
expr_stmt|;
block|}
else|else
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|==
name|spec_target
condition|)
return|return
name|target
return|;
if|if
condition|(
name|target
operator|==
name|spec_target_subreg
condition|)
return|return
name|spec_target
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|convert_to_mode
argument_list|(
name|tmode
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract a bit field using shifts and boolean operations    Returns an rtx to represent the value.    OP0 addresses a register (word) or memory (byte).    BITPOS says which bit within the word or byte the bit field starts in.    OFFSET says how many bytes farther the bit field starts;     it is 0 if OP0 is a register.    BITSIZE says how many bits long the bit field is.     (If OP0 is a register, it may be narrower than SImode,      but BITPOS still counts within a full word,      which is significant on bigendian machines.)     UNSIGNEDP is nonzero for an unsigned bit field (don't sign-extend value).    If TARGET is nonzero, attempts to store the value there    and return TARGET, but this is not guaranteed.    If TARGET is not used, create a pseudo-reg of mode TMODE for the value.     ALIGN is the alignment that STR_RTX is known to have, measured in bytes.  */
end_comment

begin_function
specifier|static
name|rtx
name|extract_fixed_bit_field
parameter_list|(
name|tmode
parameter_list|,
name|op0
parameter_list|,
name|offset
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|)
name|enum
name|machine_mode
name|tmode
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|target
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|,
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|int
name|total_bits
init|=
name|BITS_PER_WORD
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Special treatment for a bit field split across two registers.  */
if|if
condition|(
name|bitsize
operator|+
name|bitpos
operator|>
name|BITS_PER_WORD
condition|)
return|return
name|extract_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
name|align
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|bitsize
operator|+
name|bitpos
operator|<=
name|BITS_PER_UNIT
operator|&&
operator|(
operator|!
name|SLOW_BYTE_ACCESS
operator|||
operator|(
name|align
operator|==
literal|1
operator|&&
name|BIGGEST_ALIGNMENT
operator|>
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* It fits in one byte, and either bytes are fast 	 or the alignment won't let us use anything bigger.  */
name|total_bits
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bitsize
operator|+
name|bitpos
operator|+
operator|(
name|offset
operator|%
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
operator|)
operator|*
name|BITS_PER_UNIT
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|)
comment|/* If halfwords are fast, use them whenever valid.  */
operator|&&
operator|(
operator|!
name|SLOW_BYTE_ACCESS
comment|/* Use halfwords if larger is invalid due to alignment.  */
operator|||
operator|(
name|align
operator|==
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
operator|&&
name|BIGGEST_ALIGNMENT
operator|>
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* It fits in an aligned halfword, and either halfwords are fast 	 or the alignment won't let us use anything bigger.  */
name|total_bits
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
comment|/* Get ref to halfword containing the field.  */
name|bitpos
operator|+=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|offset
operator|-=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Get ref to word containing the field.  */
comment|/* Adjust BITPOS to be position within a word, 	 and OFFSET to be the offset of that word.  */
name|bitpos
operator|+=
operator|(
name|offset
operator|%
operator|(
name|BITS_PER_WORD
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|offset
operator|-=
operator|(
name|offset
operator|%
operator|(
name|BITS_PER_WORD
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Special treatment for a bit field split across two words.  */
if|if
condition|(
name|bitsize
operator|+
name|bitpos
operator|>
name|BITS_PER_WORD
condition|)
return|return
name|extract_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
name|align
argument_list|)
return|;
block|}
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* BITPOS is the distance between our msb and that of OP0.      Convert it to the distance from the lsb.  */
name|bitpos
operator|=
name|total_bits
operator|-
name|bitsize
operator|-
name|bitpos
expr_stmt|;
endif|#
directive|endif
comment|/* Now BITPOS is always the distance between the field's lsb and that of OP0.      We have reduced the big-endian case to the little-endian case.  */
if|if
condition|(
name|unsignedp
condition|)
block|{
if|if
condition|(
name|bitpos
condition|)
block|{
comment|/* If the field does not already start at the lsb, 	     shift it so it does.  */
name|tree
name|amount
init|=
name|build_int_2
argument_list|(
name|bitpos
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Maybe propagate the target for the shift.  */
comment|/* But not if we will return it--could confuse integrate.c.  */
name|rtx
name|subtarget
init|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|target
argument_list|)
condition|?
name|target
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|tmode
operator|!=
name|mode
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|amount
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the value to the desired mode.  */
if|if
condition|(
name|mode
operator|!=
name|tmode
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Unless the msb of the field used to be the msb when we shifted, 	 mask out the upper bits.  */
if|if
condition|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|!=
name|bitpos
operator|+
name|bitsize
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|SLOW_ZERO_EXTEND
comment|/* Always generate an `and' if 	      we just zero-extended op0 and SLOW_ZERO_EXTEND, since it 	      will combine fruitfully with the zero-extend. */
expr||| tmode != mode
endif|#
directive|endif
endif|#
directive|endif
operator|)
operator|&&
name|bitsize
operator|<
name|HOST_BITS_PER_INT
condition|)
return|return
name|expand_bit_and
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
name|target
argument_list|)
return|;
return|return
name|op0
return|;
block|}
comment|/* To extract a signed bit-field, first shift its msb to the msb of the word,      then arithmetic-shift its lsb to the lsb of the word.  */
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|tmode
condition|)
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
operator|>=
name|bitsize
operator|+
name|bitpos
condition|)
name|mode
operator|=
name|QImode
operator|,
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|QImode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
operator|>=
name|bitsize
operator|+
name|bitpos
condition|)
name|mode
operator|=
name|HImode
operator|,
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|HImode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|!=
operator|(
name|bitsize
operator|+
name|bitpos
operator|)
condition|)
block|{
name|tree
name|amount
init|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
operator|(
name|bitsize
operator|+
name|bitpos
operator|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Maybe propagate the target for the shift.  */
comment|/* But not if we will return the result--could confuse integrate.c.  */
name|rtx
name|subtarget
init|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|target
argument_list|)
condition|?
name|target
else|:
literal|0
operator|)
decl_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|amount
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract a bit field that is split across two words    and return an RTX for the result.     OP0 is the REG, SUBREG or MEM rtx for the first of the two words.    BITSIZE is the field width; BITPOS, position of its first bit, in the word.    UNSIGNEDP is 1 if should zero-extend the contents; else sign-extend.  */
end_comment

begin_function
specifier|static
name|rtx
name|extract_split_bit_field
parameter_list|(
name|op0
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|,
name|unsignedp
decl_stmt|,
name|align
decl_stmt|;
block|{
comment|/* BITSIZE_1 is size of the part in the first word.  */
name|int
name|bitsize_1
init|=
name|BITS_PER_WORD
operator|-
name|bitpos
decl_stmt|;
comment|/* BITSIZE_2 is size of the rest (in the following word).  */
name|int
name|bitsize_2
init|=
name|bitsize
operator|-
name|bitsize_1
decl_stmt|;
name|rtx
name|part1
decl_stmt|,
name|part2
decl_stmt|,
name|result
decl_stmt|;
comment|/* Get the part of the bit field from the first word.  */
name|part1
operator|=
name|extract_fixed_bit_field
argument_list|(
name|SImode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|,
name|bitsize_1
argument_list|,
name|bitpos
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Offset op0 by 1 word to get to the following one.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Get the part of the bit field from the second word.  */
name|part2
operator|=
name|extract_fixed_bit_field
argument_list|(
name|SImode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|,
name|bitsize_2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Shift the more significant part up to fit above the other part.  */
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
name|part1
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|SImode
argument_list|,
name|part1
argument_list|,
name|build_int_2
argument_list|(
name|bitsize_2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|part2
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|SImode
argument_list|,
name|part2
argument_list|,
name|build_int_2
argument_list|(
name|bitsize_1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Combine the two parts with bitwise or.  This works      because we extracted both parts as unsigned bit fields.  */
name|result
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Unsigned bit field: we are done.  */
if|if
condition|(
name|unsignedp
condition|)
return|return
name|result
return|;
comment|/* Signed bit field: sign-extend with two arithmetic shifts.  */
name|result
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|SImode
argument_list|,
name|result
argument_list|,
name|build_int_2
argument_list|(
name|BITS_PER_WORD
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|SImode
argument_list|,
name|result
argument_list|,
name|build_int_2
argument_list|(
name|BITS_PER_WORD
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add INC into TARGET.  */
end_comment

begin_function
name|void
name|expand_inc
parameter_list|(
name|target
parameter_list|,
name|inc
parameter_list|)
name|rtx
name|target
decl_stmt|,
name|inc
decl_stmt|;
block|{
name|rtx
name|value
init|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|add_optab
argument_list|,
name|target
argument_list|,
name|inc
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subtract INC from TARGET.  */
end_comment

begin_function
name|void
name|expand_dec
parameter_list|(
name|target
parameter_list|,
name|dec
parameter_list|)
name|rtx
name|target
decl_stmt|,
name|dec
decl_stmt|;
block|{
name|rtx
name|value
init|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|target
argument_list|,
name|dec
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a shift instruction for expression code CODE,    with SHIFTED being the rtx for the value to shift,    and AMOUNT the tree for the amount to shift by.    Store the result in the rtx TARGET, if that is convenient.    If UNSIGNEDP is nonzero, do a logical shift; otherwise, arithmetic.    Return the rtx for where the value is.  */
end_comment

begin_comment
comment|/* Pastel, for shifts, converts shift count to SImode here    independent of the mode being shifted.    Should that be done in an earlier pass?    It turns out not to matter for C.  */
end_comment

begin_function
name|rtx
name|expand_shift
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|shifted
parameter_list|,
name|amount
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|shifted
decl_stmt|;
name|tree
name|amount
decl_stmt|;
specifier|register
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
specifier|register
name|rtx
name|op1
decl_stmt|,
name|temp
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|left
init|=
operator|(
name|code
operator|==
name|LSHIFT_EXPR
operator|||
name|code
operator|==
name|LROTATE_EXPR
operator|)
decl_stmt|;
name|int
name|try
decl_stmt|;
name|int
name|rotate
init|=
name|code
operator|==
name|LROTATE_EXPR
operator|||
name|code
operator|==
name|RROTATE_EXPR
decl_stmt|;
name|rtx
name|last
decl_stmt|;
comment|/* Previously detected shift-counts computed by NEGATE_EXPR      and shifted in the other direction; but that does not work      on all machines.  */
name|op1
operator|=
name|expand_expr
argument_list|(
name|amount
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
for|for
control|(
name|try
operator|=
literal|0
init|;
name|temp
operator|==
literal|0
operator|&&
name|try
operator|<
literal|3
condition|;
name|try
operator|++
control|)
block|{
name|enum
name|optab_methods
name|methods
decl_stmt|;
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|try
operator|==
literal|0
condition|)
name|methods
operator|=
name|OPTAB_DIRECT
expr_stmt|;
elseif|else
if|if
condition|(
name|try
operator|==
literal|1
condition|)
name|methods
operator|=
name|OPTAB_WIDEN
expr_stmt|;
else|else
name|methods
operator|=
name|OPTAB_LIB_WIDEN
expr_stmt|;
if|if
condition|(
name|rotate
condition|)
block|{
comment|/* Widening does not work for rotation.  */
if|if
condition|(
name|methods
operator|!=
name|OPTAB_DIRECT
condition|)
name|methods
operator|=
name|OPTAB_LIB
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|left
condition|?
name|rotl_optab
else|:
name|rotr_optab
argument_list|,
name|shifted
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
operator|-
literal|1
argument_list|,
name|methods
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unsignedp
condition|)
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|left
condition|?
name|lshl_optab
else|:
name|lshr_optab
argument_list|,
name|shifted
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
operator|&&
name|left
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashl_optab
argument_list|,
name|shifted
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
block|}
comment|/* Do arithmetic shifts. 	 Also, if we are going to widen the operand, we can just as well 	 use an arithmetic right-shift instead of a logical one.  */
if|if
condition|(
operator|!
name|rotate
operator|&&
operator|(
operator|!
name|unsignedp
operator|||
operator|(
operator|!
name|left
operator|&&
name|methods
operator|==
name|OPTAB_WIDEN
operator|)
operator|)
condition|)
block|{
name|enum
name|optab_methods
name|methods1
init|=
name|methods
decl_stmt|;
comment|/* If trying to widen a log shift to an arithmetic shift, 	     don't accept an arithmetic shift of the same size.  */
if|if
condition|(
name|unsignedp
condition|)
name|methods1
operator|=
name|OPTAB_MUST_WIDEN
expr_stmt|;
comment|/* Arithmetic shift */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|left
condition|?
name|ashl_optab
else|:
name|ashr_optab
argument_list|,
name|shifted
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
block|}
if|if
condition|(
name|unsignedp
condition|)
block|{
comment|/* No logical shift insn in either direction => 	     try a bit-field extract instruction if we have one.  */
ifdef|#
directive|ifdef
name|HAVE_extzv
ifndef|#
directive|ifndef
name|BITS_BIG_ENDIAN
if|if
condition|(
name|HAVE_extzv
operator|&&
operator|!
name|left
operator|&&
operator|(
operator|(
name|methods
operator|==
name|OPTAB_DIRECT
operator|&&
name|mode
operator|==
name|SImode
operator|)
operator|||
operator|(
name|methods
operator|==
name|OPTAB_WIDEN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|shifted1
init|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|shifted
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|target1
init|=
name|target
decl_stmt|;
comment|/* If -fforce-mem, don't let the operand be in memory.  */
if|if
condition|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|shifted1
argument_list|)
operator|==
name|MEM
condition|)
name|shifted1
operator|=
name|force_not_mem
argument_list|(
name|shifted1
argument_list|)
expr_stmt|;
comment|/* If this machine's extzv insists on a register for 		 operand 1, arrange for that.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|shifted1
argument_list|,
name|SImode
argument_list|)
operator|)
condition|)
name|shifted1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|shifted1
argument_list|)
expr_stmt|;
comment|/* If we don't have or cannot use a suggested target, 		 make a place for the result, in the proper mode.  */
if|if
condition|(
name|methods
operator|==
name|OPTAB_WIDEN
operator|||
name|target1
operator|==
literal|0
operator|||
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|target1
argument_list|,
name|SImode
argument_list|)
operator|)
condition|)
name|target1
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|op1
operator|=
name|convert_to_mode
argument_list|(
name|SImode
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this machine's extzv insists on a register for 		 operand 3, arrange for that.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|3
index|]
call|)
argument_list|(
name|op1
argument_list|,
name|SImode
argument_list|)
operator|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|protect_from_queue
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* TEMP gets the width of the bit field to extract: 		 wordsize minus # bits to shift by.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|temp
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|sub_optab
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
name|op1
argument_list|,
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Now extract with width TEMP, omitting OP1 least sig bits.  */
name|emit_insn
argument_list|(
name|gen_extzv
argument_list|(
name|protect_from_queue
argument_list|(
name|target1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|protect_from_queue
argument_list|(
name|shifted1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|target1
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* Can also do logical shift with signed bit-field extract 	     followed by inserting the bit-field at a different position. 	     That strategy is not yet implemented.  */
endif|#
directive|endif
comment|/* not BITS_BIG_ENDIAN */
endif|#
directive|endif
comment|/* HAVE_extzv */
comment|/* We have failed to generate the logical shift and will abort.  */
block|}
block|}
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an instruction or two to bitwise-and OP0 with OP1    in mode MODE, with output to TARGET if convenient and TARGET is not zero.    Returns where the result is.  */
end_comment

begin_comment
comment|/* This function used to do more; now it could be eliminated.  */
end_comment

begin_function
name|rtx
name|expand_bit_and
parameter_list|(
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
comment|/* First try to open-code it directly.  */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a multiplication and return an rtx for the result.    MODE is mode of value; OP0 and OP1 are what to multiply (rtx's);    TARGET is a suggestion for where to store the result (an rtx).     We check specially for a constant integer as OP1.    If you want this check for OP0 as well, then before calling    you should swap the two operands if OP0 would be constant.  */
end_comment

begin_function
name|rtx
name|expand_mult
parameter_list|(
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
comment|/* Don't use the function value register as a target      since we have to read it as well as write it,      and function-inlining gets confused by this.  */
if|if
condition|(
name|target
operator|&&
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|target
argument_list|)
condition|)
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
specifier|register
name|int
name|foo
decl_stmt|;
name|int
name|bar
decl_stmt|;
name|int
name|negate
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
decl_stmt|;
name|int
name|absval
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|*
operator|(
name|negate
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
decl_stmt|;
comment|/* Is multiplier a power of 2, or minus that?  */
name|foo
operator|=
name|exact_log2
argument_list|(
name|absval
argument_list|)
expr_stmt|;
if|if
condition|(
name|foo
operator|>=
literal|0
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|foo
operator|==
literal|0
condition|)
name|tem
operator|=
name|op0
expr_stmt|;
else|else
name|tem
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|negate
condition|?
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|tem
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
else|:
name|tem
operator|)
return|;
block|}
comment|/* Is multiplier a sum of two powers of 2, or minus that?  */
name|bar
operator|=
name|floor_log2
argument_list|(
name|absval
argument_list|)
expr_stmt|;
name|foo
operator|=
name|exact_log2
argument_list|(
name|absval
operator|-
operator|(
literal|1
operator|<<
name|bar
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bar
operator|>=
literal|0
operator|&&
name|foo
operator|>=
literal|0
condition|)
block|{
name|rtx
name|tem
init|=
name|force_operand
argument_list|(
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|bar
operator|-
name|foo
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|)
argument_list|,
operator|(
operator|(
name|foo
operator|==
literal|0
operator|&&
operator|!
name|negate
operator|)
condition|?
name|target
else|:
literal|0
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|foo
operator|!=
literal|0
condition|)
name|tem
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|build_int_2
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
argument_list|,
name|negate
condition|?
literal|0
else|:
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|negate
condition|?
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|tem
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
else|:
name|tem
return|;
block|}
block|}
comment|/* This used to use umul_optab if unsigned,      but I think that for non-widening multiply there is no difference      between signed and unsigned.  */
name|op0
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|smul_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|op0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit the code to divide OP0 by OP1, putting the result in TARGET    if that is convenient, and returning where the result is.    You may request either the quotient or the remainder as the result;    specify REM_FLAG nonzero to get the remainder.     CODE is the expression code for which kind of division this is;    it controls how rounding is done.  MODE is the machine mode to use.    UNSIGNEDP nonzero means do unsigned division.  */
end_comment

begin_comment
comment|/* ??? For CEIL_MOD_EXPR, can compute incorrect remainder with ANDI    and then correct it by or'ing in missing high bits    if result of ANDI is nonzero.    For ROUND_MOD_EXPR, can use ANDI and then sign-extend the result.    This could optimize to a bfexts instruction.    But C doesn't use these operations, so their optimizations are    left for later.  */
end_comment

begin_function
name|rtx
name|expand_divmod
parameter_list|(
name|rem_flag
parameter_list|,
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|int
name|rem_flag
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
name|int
name|log
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|can_clobber_op0
decl_stmt|;
name|int
name|mod_insn_no_good
init|=
literal|0
decl_stmt|;
name|rtx
name|adjusted_op0
init|=
name|op0
decl_stmt|;
comment|/* Don't use the function value register as a target      since we have to read it as well as write it,      and function-inlining gets confused by this.  */
if|if
condition|(
name|target
operator|&&
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|target
argument_list|)
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* Don't clobber an operand while doing a multi-step calculation.  */
if|if
condition|(
name|target
condition|)
if|if
condition|(
operator|(
name|rem_flag
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|)
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|target
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|can_clobber_op0
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
name|op0
operator|==
name|target
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|log
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If log is>= 0, we are dividing by 2**log, and will do it by shifting,      which is really floor-division.  Otherwise we will really do a divide,      and we assume that is trunc-division.       We must correct the dividend by adding or subtracting something      based on the divisor, in order to do the kind of rounding specified      by CODE.  The correction depends on what kind of rounding is actually      available, and that depends on whether we will shift or divide.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
if|if
condition|(
name|log
operator|>=
literal|0
operator|&&
operator|!
name|unsignedp
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|can_clobber_op0
condition|)
name|adjusted_op0
operator|=
name|copy_to_suggested_reg
argument_list|(
name|adjusted_op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|plus_constant
argument_list|(
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|mod_insn_no_good
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
if|if
condition|(
name|log
operator|<
literal|0
operator|&&
operator|!
name|unsignedp
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|can_clobber_op0
condition|)
name|adjusted_op0
operator|=
name|copy_to_suggested_reg
argument_list|(
name|adjusted_op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|adjusted_op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|mod_insn_no_good
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
if|if
condition|(
operator|!
name|can_clobber_op0
condition|)
name|adjusted_op0
operator|=
name|copy_to_suggested_reg
argument_list|(
name|adjusted_op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|<
literal|0
condition|)
block|{
name|rtx
name|label
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|unsignedp
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_ble
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|adjusted_op0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unsignedp
condition|)
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adjusted_op0
operator|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|add_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|plus_constant
argument_list|(
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
name|mod_insn_no_good
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
if|if
condition|(
operator|!
name|can_clobber_op0
condition|)
name|adjusted_op0
operator|=
name|copy_to_suggested_reg
argument_list|(
name|adjusted_op0
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|<
literal|0
condition|)
block|{
name|op1
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op1
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unsignedp
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_cmp_insn
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|op1
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op1
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
name|mod_insn_no_good
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rem_flag
operator|&&
operator|!
name|mod_insn_no_good
condition|)
block|{
comment|/* Try to produce the remainder directly */
if|if
condition|(
name|log
operator|>=
literal|0
condition|)
block|{
return|return
name|expand_bit_and
argument_list|(
name|mode
argument_list|,
name|adjusted_op0
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|target
argument_list|)
return|;
block|}
else|else
block|{
comment|/* See if we can do remainder without a library call.  */
name|temp
operator|=
name|sign_expand_binop
argument_list|(
name|mode
argument_list|,
name|umod_optab
argument_list|,
name|smod_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
comment|/* No luck there. 	     Can we do remainder and divide at once without a library call?  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand_twoval_binop
argument_list|(
name|unsignedp
condition|?
name|udivmod_optab
else|:
name|sdivmod_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
condition|)
return|return
name|temp
return|;
name|temp
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Produce the quotient.  */
if|if
condition|(
name|log
operator|>=
literal|0
condition|)
name|temp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|adjusted_op0
argument_list|,
name|build_int_2
argument_list|(
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rem_flag
operator|&&
operator|!
name|mod_insn_no_good
condition|)
comment|/* If producing quotient in order to subtract for remainder,        and a remainder subroutine would be ok,        don't use a divide subroutine.  */
name|temp
operator|=
name|sign_expand_binop
argument_list|(
name|mode
argument_list|,
name|udiv_optab
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Try a quotient insn, but not a library call.  */
name|temp
operator|=
name|sign_expand_binop
argument_list|(
name|mode
argument_list|,
name|udiv_optab
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
block|{
comment|/* No luck there.  Try a quotient-and-remainder insn, 	     keeping the quotient alone.  */
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_twoval_binop
argument_list|(
name|unsignedp
condition|?
name|udivmod_optab
else|:
name|sdivmod_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|unsignedp
argument_list|)
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If still no luck, use a library call.  */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|sign_expand_binop
argument_list|(
name|mode
argument_list|,
name|udiv_optab
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* If we really want the remainder, get it by subtraction.  */
if|if
condition|(
name|rem_flag
condition|)
block|{
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
block|{
comment|/* No divide instruction either.  Use library for remainder.  */
name|temp
operator|=
name|sign_expand_binop
argument_list|(
name|mode
argument_list|,
name|umod_optab
argument_list|,
name|smod_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We divided.  Now finish doing X - Y * (X / Y).  */
name|temp
operator|=
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|,
name|temp
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|sub_optab
argument_list|,
name|op0
argument_list|,
name|temp
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree node with data type TYPE, describing the value of X.    Usually this is an RTL_EXPR, if there is no obvious better choice.  */
end_comment

begin_function
specifier|static
name|tree
name|make_tree
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|)
name|tree
name|type
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|fold
argument_list|(
name|t
argument_list|)
return|;
default|default:
name|t
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* There are no insns to be output 	 when this rtl_expr is used.  */
name|RTL_EXPR_SEQUENCE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return an rtx representing the value of X * MULT + ADD.    MODE is the machine mode for the computation.    UNSIGNEDP is non-zero to do unsigned multiplication.    This may emit insns.  */
end_comment

begin_function
name|rtx
name|expand_mult_add
parameter_list|(
name|x
parameter_list|,
name|mult
parameter_list|,
name|add
parameter_list|,
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|mult
decl_stmt|,
name|add
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|type_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
name|tree
name|prod
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|mult
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|sum
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|prod
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|add
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|sum
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

end_unit

