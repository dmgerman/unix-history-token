begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output sdb-format symbol table information from GNU compiler.    Copyright (C) 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_define
define|#
directive|define
name|MAYBE
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MIPS_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|<syms.h>
end_include

begin_comment
comment|/* #include<storclass.h>  used to be this instead of syms.h.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* For cross compilation, use the portable defintions from the COFF    documentation.  */
end_comment

begin_define
define|#
directive|define
name|C_EFCN
value|-1
end_define

begin_define
define|#
directive|define
name|C_NULL
value|0
end_define

begin_define
define|#
directive|define
name|C_AUTO
value|1
end_define

begin_define
define|#
directive|define
name|C_EXT
value|2
end_define

begin_define
define|#
directive|define
name|C_STAT
value|3
end_define

begin_define
define|#
directive|define
name|C_REG
value|4
end_define

begin_define
define|#
directive|define
name|C_EXTDEF
value|5
end_define

begin_define
define|#
directive|define
name|C_LABEL
value|6
end_define

begin_define
define|#
directive|define
name|C_ULABEL
value|7
end_define

begin_define
define|#
directive|define
name|C_MOS
value|8
end_define

begin_define
define|#
directive|define
name|C_ARG
value|9
end_define

begin_define
define|#
directive|define
name|C_STRTAG
value|10
end_define

begin_define
define|#
directive|define
name|C_MOU
value|11
end_define

begin_define
define|#
directive|define
name|C_UNTAG
value|12
end_define

begin_define
define|#
directive|define
name|C_TPDEF
value|13
end_define

begin_define
define|#
directive|define
name|C_USTATIC
value|14
end_define

begin_define
define|#
directive|define
name|C_ENTAG
value|15
end_define

begin_define
define|#
directive|define
name|C_MOE
value|16
end_define

begin_define
define|#
directive|define
name|C_REGPARM
value|17
end_define

begin_define
define|#
directive|define
name|C_FIELD
value|18
end_define

begin_define
define|#
directive|define
name|C_BLOCK
value|100
end_define

begin_define
define|#
directive|define
name|C_FCN
value|101
end_define

begin_define
define|#
directive|define
name|C_EOS
value|102
end_define

begin_define
define|#
directive|define
name|C_FILE
value|103
end_define

begin_define
define|#
directive|define
name|C_LINE
value|104
end_define

begin_define
define|#
directive|define
name|C_ALIAS
value|105
end_define

begin_define
define|#
directive|define
name|C_HIDDEN
value|106
end_define

begin_define
define|#
directive|define
name|T_NULL
value|0
end_define

begin_define
define|#
directive|define
name|T_ARG
value|1
end_define

begin_define
define|#
directive|define
name|T_CHAR
value|2
end_define

begin_define
define|#
directive|define
name|T_SHORT
value|3
end_define

begin_define
define|#
directive|define
name|T_INT
value|4
end_define

begin_define
define|#
directive|define
name|T_LONG
value|5
end_define

begin_define
define|#
directive|define
name|T_FLOAT
value|6
end_define

begin_define
define|#
directive|define
name|T_DOUBLE
value|7
end_define

begin_define
define|#
directive|define
name|T_STRUCT
value|8
end_define

begin_define
define|#
directive|define
name|T_UNION
value|9
end_define

begin_define
define|#
directive|define
name|T_ENUM
value|10
end_define

begin_define
define|#
directive|define
name|T_MOE
value|11
end_define

begin_define
define|#
directive|define
name|T_UCHAR
value|12
end_define

begin_define
define|#
directive|define
name|T_USHORT
value|13
end_define

begin_define
define|#
directive|define
name|T_UINT
value|14
end_define

begin_define
define|#
directive|define
name|T_ULONG
value|15
end_define

begin_define
define|#
directive|define
name|DT_NON
value|0
end_define

begin_define
define|#
directive|define
name|DT_PTR
value|1
end_define

begin_define
define|#
directive|define
name|DT_FCN
value|2
end_define

begin_define
define|#
directive|define
name|DT_ARY
value|3
end_define

begin_define
define|#
directive|define
name|N_BTMASK
value|017
end_define

begin_define
define|#
directive|define
name|N_TMASK
value|060
end_define

begin_define
define|#
directive|define
name|N_TMASK1
value|0300
end_define

begin_define
define|#
directive|define
name|N_TMASK2
value|0360
end_define

begin_define
define|#
directive|define
name|N_BTSHFT
value|4
end_define

begin_define
define|#
directive|define
name|N_TSHIFT
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Line number of beginning of current function, minus one.    Negative means not in a function or not using sdb.  */
end_comment

begin_decl_stmt
name|int
name|sdb_begin_function_line
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter to generate unique "names" for nameless struct members.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unnamed_struct_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|sdbout_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sdbout_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sdbout_tags
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sdbout_types
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_syms
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sdbout_one_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|plain_type_1
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Random macros describing parts of SDB data.  */
end_comment

begin_comment
comment|/* Put something here if lines get too long */
end_comment

begin_define
define|#
directive|define
name|CONTIN
end_define

begin_comment
comment|/* Maximum number of dimensions the assembler will allow.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SDB_MAX_DIM
end_ifndef

begin_define
define|#
directive|define
name|SDB_MAX_DIM
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_SCL
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_SCL
parameter_list|(
name|a
parameter_list|)
value|fprintf(asm_out_file, "\t.scl\t%d;", (a))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_INT_VAL
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_INT_VAL
parameter_list|(
name|a
parameter_list|)
value|fprintf (asm_out_file, "\t.val\t%d;", (a))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_VAL
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_VAL
parameter_list|(
name|a
parameter_list|)
define|\
value|( fputs ("\t.val\t", asm_out_file),		\   output_addr_const (asm_out_file, (a)),	\   fputc (';', asm_out_file))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_DEF
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_DEF
parameter_list|(
name|a
parameter_list|)
define|\
value|do { fprintf (asm_out_file, "\t.def\t");	\      ASM_OUTPUT_LABELREF (asm_out_file, a); 	\      fprintf (asm_out_file, ";"); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_PLAIN_DEF
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_PLAIN_DEF
parameter_list|(
name|a
parameter_list|)
value|fprintf(asm_out_file,"\t.def\t.%s;",a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_ENDEF
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_ENDEF
value|fputs("\t.endef\n", asm_out_file)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_TYPE
parameter_list|(
name|a
parameter_list|)
value|fprintf(asm_out_file, "\t.type\t0%o;", a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_SIZE
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_SIZE
parameter_list|(
name|a
parameter_list|)
value|fprintf(asm_out_file, "\t.size\t%d;", a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_START_DIM
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_START_DIM
value|fprintf(asm_out_file, "\t.dim\t")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_NEXT_DIM
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_NEXT_DIM
parameter_list|(
name|a
parameter_list|)
value|fprintf(asm_out_file, "%d,", a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_LAST_DIM
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_LAST_DIM
parameter_list|(
name|a
parameter_list|)
value|fprintf(asm_out_file, "%d;", a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_TAG
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_TAG
parameter_list|(
name|a
parameter_list|)
define|\
value|do { fprintf (asm_out_file, "\t.tag\t");	\      ASM_OUTPUT_LABELREF (asm_out_file, a);	\      fprintf (asm_out_file, ";"); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_BLOCK_START
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_BLOCK_START
parameter_list|(
name|LINE
parameter_list|)
define|\
value|fprintf (asm_out_file,			\ 	   "\t.def\t.bb;\t.val\t.;\t.scl\t100;\t.line\t%d;\t.endef\n",	\ 	   (LINE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_BLOCK_END
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_BLOCK_END
parameter_list|(
name|LINE
parameter_list|)
define|\
value|fprintf (asm_out_file,			\ 	   "\t.def\t.eb;.val\t.;\t.scl\t100;\t.line\t%d;\t.endef\n",	\ 	   (LINE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_FUNCTION_START
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_FUNCTION_START
parameter_list|(
name|LINE
parameter_list|)
define|\
value|fprintf (asm_out_file,			\ 	   "\t.def\t.bf;\t.val\t.;\t.scl\t101;\t.line\t%d;\t.endef\n",	\ 	   (LINE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_FUNCTION_END
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_FUNCTION_END
parameter_list|(
name|LINE
parameter_list|)
define|\
value|fprintf (asm_out_file,			\ 	   "\t.def\t.ef;\t.val\t.;\t.scl\t101;\t.line\t%d;\t.endef\n",	\ 	   (LINE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUT_SDB_EPILOGUE_END
end_ifndef

begin_define
define|#
directive|define
name|PUT_SDB_EPILOGUE_END
parameter_list|(
name|NAME
parameter_list|)
define|\
value|fprintf (asm_out_file,			\ 	   "\t.def\t%s;\t.val\t.;\t.scl\t-1;\t.endef\n",	\ 	   (NAME))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SDB_GENERATE_FAKE
end_ifndef

begin_define
define|#
directive|define
name|SDB_GENERATE_FAKE
parameter_list|(
name|BUFFER
parameter_list|,
name|NUMBER
parameter_list|)
define|\
value|sprintf ((BUFFER), ".%dfake", (NUMBER));
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the sdb tag identifier string for TYPE    if TYPE has already been defined; otherwise return a null pointer.   */
end_comment

begin_define
define|#
directive|define
name|KNOWN_TYPE_TAG
parameter_list|(
name|type
parameter_list|)
value|(char *)(TYPE_SYMTAB_ADDRESS (type))
end_define

begin_comment
comment|/* Set the sdb tag identifier string for TYPE to NAME.  */
end_comment

begin_define
define|#
directive|define
name|SET_KNOWN_TYPE_TAG
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|)
define|\
value|(TYPE_SYMTAB_ADDRESS (TYPE) = (int)(NAME))
end_define

begin_comment
comment|/* Return the name (a string) of the struct, union or enum tag    described by the TREE_LIST node LINK.  This is 0 for an anonymous one.  */
end_comment

begin_define
define|#
directive|define
name|TAG_NAME
parameter_list|(
name|link
parameter_list|)
define|\
value|(((link)&& TREE_PURPOSE ((link)) \&& IDENTIFIER_POINTER (TREE_PURPOSE ((link)))) \    ? IDENTIFIER_POINTER (TREE_PURPOSE ((link))) : (char *) 0)
end_define

begin_comment
comment|/* Ensure we don't output a negative line number.  */
end_comment

begin_define
define|#
directive|define
name|MAKE_LINE_SAFE
parameter_list|(
name|line
parameter_list|)
define|\
value|if (line<= sdb_begin_function_line) line = sdb_begin_function_line + 1
end_define

begin_escape
end_escape

begin_comment
comment|/* Tell the assembler the source file name.    On systems that use SDB, this is done whether or not -g,    so it is called by ASM_FILE_START.     ASM_FILE is the assembler code output file,    INPUT_NAME is the name of the main input file.  */
end_comment

begin_function
name|void
name|sdbout_filename
parameter_list|(
name|asm_file
parameter_list|,
name|input_name
parameter_list|)
name|FILE
modifier|*
name|asm_file
decl_stmt|;
name|char
modifier|*
name|input_name
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|input_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|na
init|=
name|input_name
operator|+
name|len
decl_stmt|;
comment|/* NA gets INPUT_NAME sans directory names.  */
while|while
condition|(
name|na
operator|>
name|input_name
condition|)
block|{
if|if
condition|(
name|na
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
name|na
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_FILENAME
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|asm_file
argument_list|,
name|na
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_file
argument_list|,
literal|"\t.file\t\"%s\"\n"
argument_list|,
name|na
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Set up for SDB output at the start of compilation.  */
end_comment

begin_function
name|void
name|sdbout_init
parameter_list|()
block|{
comment|/* Output all the initial permanent types.  */
name|sdbout_types
argument_list|(
name|nreverse
argument_list|(
name|get_permanent_types
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* return the tag identifier for type  */
end_comment

begin_endif
unit|{ char * tag_of_ru_type (type,link)      tree type,link; {   if (TYPE_SYMTAB_ADDRESS (type))     return (char *)TYPE_SYMTAB_ADDRESS (type);   if (link&&       TREE_PURPOSE (link)&& IDENTIFIER_POINTER (TREE_PURPOSE (link)))     TYPE_SYMTAB_ADDRESS (type) =       (int)IDENTIFIER_POINTER (TREE_PURPOSE (link));   else     return (char *) TYPE_SYMTAB_ADDRESS (type); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a unique string to name an anonymous type.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gen_fake_label
parameter_list|()
block|{
name|char
name|label
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|labelstr
decl_stmt|;
name|SDB_GENERATE_FAKE
argument_list|(
name|label
argument_list|,
name|unnamed_struct_number
argument_list|)
expr_stmt|;
name|unnamed_struct_number
operator|++
expr_stmt|;
name|labelstr
operator|=
operator|(
name|char
operator|*
operator|)
name|permalloc
argument_list|(
name|strlen
argument_list|(
name|label
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|labelstr
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|labelstr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number which describes TYPE for SDB.    For pointers, etc., this function is recursive.    Each record, union or enumeral type must already have had a    tag number output.  */
end_comment

begin_comment
comment|/* The number is given by d6d5d4d3d2d1bbbb     where bbbb is 4 bit basic type, and di indicate  one of notype,ptr,fn,array.    Thus, char *foo () has bbbb=T_CHAR 			  d1=D_FCN 			  d2=D_PTR  N_BTMASK=     017       1111     basic type field.  N_TSHIFT=       2                derived type shift  N_BTSHFT=       4                Basic type shift */
end_comment

begin_comment
comment|/* Produce the number that describes a pointer, function or array type.    PREV is the number describing the target, value or element type.    DT_type describes how to transform that type.  */
end_comment

begin_define
define|#
directive|define
name|PUSH_DERIVED_LEVEL
parameter_list|(
name|DT_type
parameter_list|,
name|PREV
parameter_list|)
define|\
value|((((PREV)&~N_BTMASK)<<N_TSHIFT)|(DT_type<<N_BTSHFT)|(PREV&N_BTMASK))
end_define

begin_comment
comment|/* Number of elements used in sdb_dims.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sdb_n_dims
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of array dimensions of current type.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sdb_dims
index|[
name|SDB_MAX_DIM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of outermost array currently being processed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sdb_type_size
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|plain_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|val
init|=
name|plain_type_1
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* If we have already saved up some array dimensions, print them now.  */
if|if
condition|(
name|sdb_n_dims
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|PUT_SDB_START_DIM
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sdb_n_dims
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|PUT_SDB_NEXT_DIM
argument_list|(
name|sdb_dims
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|PUT_SDB_LAST_DIM
argument_list|(
name|sdb_dims
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sdb_n_dims
operator|=
literal|0
expr_stmt|;
name|sdb_type_size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Don't kill sdb if type is not laid out or has variable size.  */
if|if
condition|(
name|sdb_type_size
operator|<
literal|0
condition|)
name|sdb_type_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we have computed the size of an array containing this type,      print it now.  */
if|if
condition|(
name|sdb_type_size
operator|>=
literal|0
condition|)
block|{
name|PUT_SDB_SIZE
argument_list|(
name|sdb_type_size
argument_list|)
expr_stmt|;
name|sdb_type_size
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdbout_record_type_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|t
init|=
literal|0
decl_stmt|;
comment|/* Find the IDENTIFIER_NODE for the type name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|t
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now get the name as a string, or invent one.  */
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|name
operator|=
name|gen_fake_label
argument_list|()
expr_stmt|;
name|SET_KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|plain_type_1
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|type
operator|=
name|void_type_node
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
return|return
name|T_INT
return|;
case|case
name|INTEGER_TYPE
case|:
switch|switch
condition|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|T_UINT
else|:
name|T_INT
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|T_UCHAR
else|:
name|T_CHAR
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
name|T_USHORT
else|:
name|T_SHORT
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
case|case
name|REAL_TYPE
case|:
switch|switch
condition|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
return|return
name|T_FLOAT
return|;
default|default:
return|return
name|T_DOUBLE
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|int
name|m
decl_stmt|;
name|m
operator|=
name|plain_type_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdb_n_dims
operator|<
name|SDB_MAX_DIM
condition|)
name|sdb_dims
index|[
name|sdb_n_dims
operator|++
index|]
operator|=
operator|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|?
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|PUSH_DERIVED_LEVEL
argument_list|(
name|DT_ARY
argument_list|,
name|m
argument_list|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
block|{
name|char
modifier|*
name|tag
decl_stmt|;
name|sdbout_record_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
ifdef|#
directive|ifdef
name|MAYBE
operator|&&
name|KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|)
endif|#
directive|endif
condition|)
block|{
comment|/* Output the referenced structure tag name 	       only if the .def has already been output. 	       At least on 386, the Unix assembler 	       cannot handle forward references to tags.  */
name|tag
operator|=
name|KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|PUT_SDB_TAG
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
name|sdb_type_size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdb_type_size
operator|<
literal|0
condition|)
name|sdb_type_size
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|?
name|T_STRUCT
else|:
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|?
name|T_UNION
else|:
name|T_ENUM
operator|)
return|;
block|}
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
block|{
name|int
name|m
init|=
name|plain_type_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|PUSH_DERIVED_LEVEL
argument_list|(
name|DT_PTR
argument_list|,
name|m
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|int
name|m
init|=
name|plain_type_1
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|PUSH_DERIVED_LEVEL
argument_list|(
name|DT_FCN
argument_list|,
name|m
argument_list|)
return|;
block|}
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the symbols defined in block number DO_BLOCK.    Set NEXT_BLOCK_NUMBER to 0 before calling.     This function works by walking the tree structure,    counting blocks, until it finds the desired block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_block
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|next_block_number
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sdbout_block
parameter_list|(
name|stmt
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
block|{
while|while
condition|(
name|stmt
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_STMT
case|:
case|case
name|LOOP_STMT
case|:
name|sdbout_block
argument_list|(
name|STMT_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF_STMT
case|:
name|sdbout_block
argument_list|(
name|STMT_THEN
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|sdbout_block
argument_list|(
name|STMT_ELSE
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LET_STMT
case|:
comment|/* Ignore LET_STMTs for blocks never really used to make RTL.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
condition|)
break|break;
comment|/* When we reach the specified block, output its symbols.  */
if|if
condition|(
name|next_block_number
operator|==
name|do_block
condition|)
block|{
name|sdbout_tags
argument_list|(
name|STMT_TYPE_TAGS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|sdbout_syms
argument_list|(
name|STMT_VARS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we are past the specified block, stop the scan.  */
if|if
condition|(
name|next_block_number
operator|>
name|do_block
condition|)
return|return;
name|next_block_number
operator|++
expr_stmt|;
comment|/* Scan the blocks within this block.  */
name|sdbout_block
argument_list|(
name|STMT_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|=
name|TREE_CHAIN
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call sdbout_symbol on each decl in the chain SYMS.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_syms
parameter_list|(
name|syms
parameter_list|)
name|tree
name|syms
decl_stmt|;
block|{
while|while
condition|(
name|syms
condition|)
block|{
name|sdbout_symbol
argument_list|(
name|syms
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|syms
operator|=
name|TREE_CHAIN
argument_list|(
name|syms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output SDB information for a symbol described by DECL.    LOCAL is nonzero if the symbol is not file-scope.  */
end_comment

begin_function
name|void
name|sdbout_symbol
parameter_list|(
name|decl
parameter_list|,
name|local
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|local
decl_stmt|;
block|{
name|int
name|letter
init|=
literal|0
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|rtx
name|value
decl_stmt|;
comment|/* If global, first output all types and all      struct, enum and union tags that have been created      and not yet output.  */
if|if
condition|(
name|local
operator|==
literal|0
condition|)
block|{
name|sdbout_tags
argument_list|(
name|gettags
argument_list|()
argument_list|)
expr_stmt|;
name|sdbout_types
argument_list|(
name|nreverse
argument_list|(
name|get_permanent_types
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAYBE
name|sdbout_one_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|CONST_DECL
case|:
comment|/* Enum values are defined by defining the enum type.  */
return|return;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return;
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_VAL
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|?
name|C_EXT
else|:
name|C_STAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* Output typedef name.  */
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_TPDEF
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
comment|/* Parm decls go in their own separate chains 	 and are output by sdbout_reg_parms and sdbout_parms.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|VAR_DECL
case|:
comment|/* Don't mention a variable that is external. 	 Let the file that defines it describe it.  */
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|value
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Don't mention a variable at all 	 if it was completely optimized into nothingness.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|value
argument_list|)
operator|<
literal|0
operator|||
name|REGNO
argument_list|(
name|value
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
return|return;
comment|/* Ok, start a symtab entry and output the variable name.  */
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|PUT_SDB_VAL
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_EXT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_SDB_VAL
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_STAT
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
condition|)
block|{
name|PUT_SDB_INT_VAL
argument_list|(
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_REG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|PUT_SDB_INT_VAL
argument_list|(
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|value
argument_list|)
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_REG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
operator|)
operator|)
condition|)
comment|/* If the value is indirect by memory or by a register 	   that isn't the frame pointer 	   then it means the object is variable-sized and address through 	   that register or stack slot.  DBX has no way to represent this 	   so all we can do is output the variable as a pointer.  */
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|PUT_SDB_INT_VAL
argument_list|(
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_REG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* DECL_RTL looks like (MEM (MEM (PLUS (REG...) 		 (CONST_INT...)))). 		 We want the value of that CONST_INT.  */
comment|/* Encore compiler hates a newline in a macro arg, it seems.  */
name|PUT_SDB_INT_VAL
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_AUTO
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))). 	     We want the value of that CONST_INT.  */
name|PUT_SDB_INT_VAL
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_AUTO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It is something we don't know how to represent for SDB.  */
block|}
break|break;
block|}
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a list of TREE_LIST nodes that point at types,    output those types for SDB.    We must check to include those that have been mentioned already with    only a cross-reference.  */
end_comment

begin_function
name|void
name|sdbout_tags
parameter_list|(
name|tags
parameter_list|)
name|tree
name|tags
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|tags
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|sdbout_one_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a chain of ..._TYPE nodes, all of which have names,    output definitions of those names, as typedefs.  */
end_comment

begin_function
name|void
name|sdbout_types
parameter_list|(
name|types
parameter_list|)
specifier|register
name|tree
name|types
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|types
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|sdbout_one_type
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdbout_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|tree
name|tem
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output types of the fields of type TYPE, if they are structs.    Formerly did not chase through pointer types, since that could be circular.    They must come before TYPE, since forward refs are not allowed.    Now james@bigtex.cactus.org says to try them.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_field_types
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|MAYBE
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|sdbout_one_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sdbout_one_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Use this to put out the top level defined record and union types    for later reference.  If this is a struct with a name, then put that    name out.  Other unnamed structs will have .xxfake labels generated so    that they may be referred to later.    The label will be stored in the KNOWN_TYPE_TAG slot of a type.    It may NOT be called recursively.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_one_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|text_section
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Don't output a type twice.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
return|return;
comment|/* Output nothing if type is not yet defined.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|MAYBE
comment|/* Before really doing anything, output types we want to refer to.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|sdbout_field_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sdbout_record_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Output a structure type.  */
block|{
name|int
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|member_scl
decl_stmt|;
name|tree
name|tem
decl_stmt|;
name|PUT_SDB_DEF
argument_list|(
name|KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|UNION_TYPE
case|:
name|PUT_SDB_SCL
argument_list|(
name|C_UNTAG
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|T_UNION
argument_list|)
expr_stmt|;
name|member_scl
operator|=
name|C_MOU
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
name|PUT_SDB_SCL
argument_list|(
name|C_STRTAG
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|T_STRUCT
argument_list|)
expr_stmt|;
name|member_scl
operator|=
name|C_MOS
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|PUT_SDB_SCL
argument_list|(
name|C_ENTAG
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|T_ENUM
argument_list|)
expr_stmt|;
name|member_scl
operator|=
name|C_MOE
expr_stmt|;
break|break;
block|}
name|PUT_SDB_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
comment|/* output the individual fields */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
for|for
control|(
name|tem
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
block|{
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_MOE
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|T_MOE
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
else|else
comment|/* record or union type */
for|for
control|(
name|tem
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
comment|/* Output the name, type, position (in bits), size (in bits) 	       of each field.  */
comment|/* Omit here the nameless fields that are used to skip bits.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|CONTIN
expr_stmt|;
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PACKED
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|PUT_SDB_INT_VAL
argument_list|(
name|DECL_OFFSET
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_FIELD
argument_list|)
expr_stmt|;
name|sdbout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SIZE
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_SDB_INT_VAL
argument_list|(
name|DECL_OFFSET
argument_list|(
name|tem
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|member_scl
argument_list|)
expr_stmt|;
name|sdbout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
comment|/* output end of a structure,union, or enumeral definition */
name|PUT_SDB_PLAIN_DEF
argument_list|(
literal|"eos"
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_EOS
argument_list|)
expr_stmt|;
name|PUT_SDB_TAG
argument_list|(
name|KNOWN_TYPE_TAG
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SIZE
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output definitions of all parameters, referring when possible to the    place where the parameters were passed rather than the copies used    within the function.     This is done as part of starting the function.    PARMS is a chain of PARM_DECL nodes.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_parms
parameter_list|(
name|parms1
parameter_list|)
name|tree
name|parms1
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|parms
decl_stmt|;
for|for
control|(
name|parms
operator|=
name|parms1
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|int
name|current_sym_value
init|=
name|DECL_OFFSET
argument_list|(
name|parms
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PUT_SDB_DEF
argument_list|(
name|gen_fake_label
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|type
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This is the case where the parm is passed as an int or double 	     and it is converted to a char, short or float and stored back 	     in the parmlist.  In this case, describe the parm 	     with the variable's declared type, and adjust the address 	     if the least significant bytes (which we are using) are not 	     the first ones.  */
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|!=
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
condition|)
name|current_sym_value
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|current_sym_value
operator|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
else|else
block|{
name|current_sym_value
operator|=
name|DECL_OFFSET
argument_list|(
name|parms
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|type
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
name|PUT_SDB_INT_VAL
argument_list|(
name|current_sym_value
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_ARG
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output definitions, referring to registers,    of all the parms in PARMS which are stored in registers during the function.    PARMS is a chain of PARM_DECL nodes.    This is done as part of starting the function.  */
end_comment

begin_function
specifier|static
name|void
name|sdbout_reg_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
while|while
condition|(
name|parms
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_REG
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|offset
init|=
name|DECL_OFFSET
argument_list|(
name|parms
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
comment|/* A parm declared char is really passed as an int, 	     so it occupies the least significant bytes. 	     On a big-endian machine those are not the low-numbered ones.  */
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|!=
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
condition|)
name|offset
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|offset
condition|)
block|{
name|PUT_SDB_DEF
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_INT_VAL
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_SCL
argument_list|(
name|C_AUTO
argument_list|)
expr_stmt|;
name|PUT_SDB_TYPE
argument_list|(
name|plain_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_SDB_ENDEF
expr_stmt|;
block|}
block|}
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Describe the beginning of an internal block within a function.    Also output descriptions of variables defined in this block.     N is the number of the block, by order of beginning, counting from 1,    and not counting the outermost (function top-level) block.    The blocks match the LET_STMTS in DECL_INITIAL (current_function_decl),    if the count starts at 0 for the outermost one.  */
end_comment

begin_function
name|void
name|sdbout_begin_block
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|n
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|current_function_decl
decl_stmt|;
name|MAKE_LINE_SAFE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|PUT_SDB_BLOCK_START
argument_list|(
name|line
operator|-
name|sdb_begin_function_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
comment|/* Include the outermost LET_STMT's variables in block 1.  */
name|next_block_number
operator|=
literal|0
expr_stmt|;
name|do_block
operator|=
literal|0
expr_stmt|;
name|sdbout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|next_block_number
operator|=
literal|0
expr_stmt|;
name|do_block
operator|=
name|n
expr_stmt|;
name|sdbout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Describe the end line-number of an internal block within a function.  */
end_comment

begin_function
name|void
name|sdbout_end_block
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|MAKE_LINE_SAFE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|PUT_SDB_BLOCK_END
argument_list|(
name|line
operator|-
name|sdb_begin_function_line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output sdb info for the current function name.    Called from assemble_function.  */
end_comment

begin_function
name|void
name|sdbout_mark_begin_function
parameter_list|()
block|{
name|sdbout_symbol
argument_list|(
name|current_function_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at beginning of function body (after prologue).    Record the function's starting line number, so we can output    relative line numbers for the other lines.    Describe beginning of outermost block.    Also describe the parameter list.  */
end_comment

begin_function
name|void
name|sdbout_begin_function
parameter_list|(
name|line
parameter_list|)
name|int
name|line
decl_stmt|;
block|{
name|sdb_begin_function_line
operator|=
name|line
operator|-
literal|1
expr_stmt|;
name|PUT_SDB_FUNCTION_START
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sdbout_parms
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|sdbout_reg_parms
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at end of function (before epilogue).    Describe end of outermost block.  */
end_comment

begin_function
name|void
name|sdbout_end_function
parameter_list|(
name|line
parameter_list|)
name|int
name|line
decl_stmt|;
block|{
name|MAKE_LINE_SAFE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|PUT_SDB_FUNCTION_END
argument_list|(
name|line
operator|-
name|sdb_begin_function_line
argument_list|)
expr_stmt|;
comment|/* Indicate we are between functions, for line-number output.  */
name|sdb_begin_function_line
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output sdb info for the absolute end of a function.    Called after the epilogue is output.  */
end_comment

begin_function
name|void
name|sdbout_end_epilogue
parameter_list|()
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
name|PUT_SDB_EPILOGUE_END
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SDB_DEBUGGING_INFO */
end_comment

end_unit

