begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Allocate, read and print RTL for C-Compiler    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Obstack used for allocating RTL objects.    Between functions, this is the permanent_obstack.    While parsing and expanding a function, this is maybepermanent_obstack    so we can save it if it is an inline function.    During optimization and output, this is temporary_obstack.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x< y) ? x : y)
end_define

begin_function_decl
specifier|extern
name|long
name|ftell
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Indexed by rtx code, gives number of operands for an rtx with that code.    Does NOT include rtx header data (code and links).    This array is initialized in init_rtl.  */
end_comment

begin_decl_stmt
name|int
name|rtx_length
index|[
name|NUM_RTX_CODE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by rtx code, gives the name of that kind of rtx, as a C string.  */
end_comment

begin_define
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|)
value|NAME ,
end_define

begin_decl_stmt
name|char
modifier|*
name|rtx_name
index|[]
init|=
block|{
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_RTL_EXPR
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the name of that machine mode.    This name does not include the letters "mode".  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
name|char
modifier|*
name|mode_name
index|[]
init|=
block|{
include|#
directive|include
file|"machmode.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the length of the mode, in bytes.    GET_MODE_CLASS uses this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
value|CLASS,
end_define

begin_decl_stmt
name|enum
name|mode_class
name|mode_class
index|[]
init|=
block|{
include|#
directive|include
file|"machmode.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the length of the mode, in bytes.    GET_MODE_SIZE uses this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
define|\
value|(SIZE*UNITS_PER_WORD+3)/4,
end_define

begin_decl_stmt
name|int
name|mode_size
index|[]
init|=
block|{
include|#
directive|include
file|"machmode.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the length of the mode's subunit.    GET_MODE_UNIT_SIZE uses this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
define|\
value|(UNIT*UNITS_PER_WORD+3)/4,
end_define

begin_decl_stmt
name|int
name|mode_unit_size
index|[]
init|=
block|{
include|#
directive|include
file|"machmode.def"
comment|/* machine modes are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives next wider natural mode    (QI -> HI -> SI -> DI, etc.)  Widening multiply instructions    use this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
define|\
value|(enum machine_mode) WIDER,
end_define

begin_decl_stmt
name|enum
name|machine_mode
name|mode_wider_mode
index|[]
init|=
block|{
include|#
directive|include
file|"machmode.def"
comment|/* machine modes are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by rtx code, gives a sequence of operand-types for    rtx's of that code.  The sequence is a C string in which    each charcter describes one operand.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rtx_format
index|[]
init|=
block|{
comment|/* "*" undefined.          can cause a warning message      "0" field is unused (or used in a phase-dependent manner)          prints nothing      "i" an integer          prints the integer      "s" a pointer to a string          prints the string      "S" like "s", but optional: 	 the containing rtx may end before this operand      "e" a pointer to an rtl expression          prints the expression      "E" a pointer to a vector that points to a number of rtl expressions          prints a list of the rtl expressions      "u" a pointer to another insn          prints the uid of the insn.  */
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|)
value|FORMAT ,
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are defined here */
undef|#
directive|undef
name|DEF_RTL_EXPR
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names for kinds of NOTEs and REG_NOTEs.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|note_insn_name
index|[]
init|=
block|{
literal|"NOTE_INSN_FUNCTION_BEG"
block|,
literal|"NOTE_INSN_DELETED"
block|,
literal|"NOTE_INSN_BLOCK_BEG"
block|,
literal|"NOTE_INSN_BLOCK_END"
block|,
literal|"NOTE_INSN_LOOP_BEG"
block|,
literal|"NOTE_INSN_LOOP_END"
block|,
literal|"NOTE_INSN_FUNCTION_END"
block|,
literal|"NOTE_INSN_SETJMP"
block|,
literal|"NOTE_INSN_LOOP_CONT"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|reg_note_name
index|[]
init|=
block|{
literal|""
block|,
literal|"REG_DEAD"
block|,
literal|"REG_INC"
block|,
literal|"REG_EQUIV"
block|,
literal|"REG_WAS_0"
block|,
literal|"REG_EQUAL"
block|,
literal|"REG_RETVAL"
block|,
literal|"REG_LIBCALL"
block|,
literal|"REG_NONNEG"
block|,
literal|"REG_ASM_LINE"
block|,
literal|"REG_ASM_FILE"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate an rtx vector of N elements.    Store the length, and initialize all elements to zero.  */
end_comment

begin_function
name|rtvec
name|rtvec_alloc
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|rtvec
name|rt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rt
operator|=
operator|(
name|rtvec
operator|)
name|obstack_alloc
argument_list|(
name|rtl_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rtvec_def
argument_list|)
operator|+
operator|(
operator|(
name|n
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* clear out the vector */
name|PUT_NUM_ELEM
argument_list|(
name|rt
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|elem
index|[
name|i
index|]
operator|.
name|rtvec
operator|=
name|NULL
expr_stmt|;
comment|/* @@ not portable due to rtunion */
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/* Allocate an rtx of code CODE.  The CODE is stored in the rtx;    all the rest is initialized to zero.  */
end_comment

begin_function
name|rtx
name|rtx_alloc
parameter_list|(
name|code
parameter_list|)
name|RTX_CODE
name|code
decl_stmt|;
block|{
name|rtx
name|rt
decl_stmt|;
specifier|register
name|int
name|nelts
init|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|length
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_def
argument_list|)
operator|+
operator|(
name|nelts
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
decl_stmt|;
name|rt
operator|=
operator|(
name|rtx
operator|)
name|obstack_alloc
argument_list|(
name|rtl_obstack
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|rt
operator|=
literal|0
expr_stmt|;
name|PUT_CODE
argument_list|(
name|rt
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new copy of an rtx.    Recursively copies the operands of the rtx,    except for those few rtx codes that are sharable.  */
end_comment

begin_function
name|rtx
name|copy_rtx
parameter_list|(
name|orig
parameter_list|)
specifier|register
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|copy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|orig
return|;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|copy
operator|->
name|integrated
operator|=
name|orig
operator|->
name|integrated
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Printing rtl for debugging dumps.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|spaces
index|[]
init|=
literal|"                                                                                                                                                                "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sawclose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print IN_RTX onto OUTFILE.  This is the recursive part of printing.  */
end_comment

begin_function
specifier|static
name|void
name|print_rtx
parameter_list|(
name|in_rtx
parameter_list|)
specifier|register
name|rtx
name|in_rtx
decl_stmt|;
block|{
specifier|static
name|int
name|indent
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|sawclose
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n%s"
argument_list|,
operator|(
name|spaces
operator|+
operator|(
sizeof|sizeof
name|spaces
operator|-
name|indent
operator|*
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|in_rtx
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"(nil)"
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* print name of expression code */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"(%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_rtx
operator|->
name|in_struct
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"/s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_rtx
operator|->
name|volatil
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"/v"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_rtx
operator|->
name|unchanging
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"/u"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_rtx
operator|->
name|integrated
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"/i"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|in_rtx
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* Print REG_NOTE names for EXPR_LIST and INSN_LIST.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|EXPR_LIST
operator|||
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|INSN_LIST
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|":%s"
argument_list|,
name|GET_REG_NOTE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|":%s"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
name|XSTR
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" \"\""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" (\"%s\")"
argument_list|,
name|XSTR
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* 0 indicates a field for internal use that should not be printed.  */
case|case
literal|'0'
case|:
break|break;
case|case
literal|'e'
case|:
name|indent
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|sawclose
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|print_rtx
argument_list|(
name|XEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|indent
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|sawclose
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n%s"
argument_list|,
operator|(
name|spaces
operator|+
operator|(
sizeof|sizeof
name|spaces
operator|-
name|indent
operator|*
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"[ "
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|XVEC
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|indent
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|)
name|sawclose
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|print_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|sawclose
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n%s"
argument_list|,
operator|(
name|spaces
operator|+
operator|(
sizeof|sizeof
name|spaces
operator|-
name|indent
operator|*
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"] "
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|1
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d"
argument_list|,
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Print NOTE_INSN names rather than integer codes.  */
case|case
literal|'n'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
operator|<=
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %s"
argument_list|,
name|GET_NOTE_INSN_NAME
argument_list|(
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d"
argument_list|,
name|XINT
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" 0"
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"switch format wrong in rtl.print_rtx(). format was: %c.\n"
argument_list|,
name|format_ptr
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|sawclose
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this function from the debugger to see what X looks like.  */
end_comment

begin_function
name|void
name|debug_rtx
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|outfile
operator|=
name|stderr
expr_stmt|;
name|print_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* External entry point for printing a chain of insns    starting with RTX_FIRST onto file OUTF.    A blank line separates insns.     If RTX_FIRST is not an insn, then it alone is printed, with no newline.  */
end_comment

begin_function
name|void
name|print_rtl
parameter_list|(
name|outf
parameter_list|,
name|rtx_first
parameter_list|)
name|FILE
modifier|*
name|outf
decl_stmt|;
name|rtx
name|rtx_first
decl_stmt|;
block|{
specifier|register
name|rtx
name|tmp_rtx
decl_stmt|;
name|outfile
operator|=
name|outf
expr_stmt|;
name|sawclose
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtx_first
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|NOTE
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
for|for
control|(
name|tmp_rtx
operator|=
name|rtx_first
init|;
name|NULL
operator|!=
name|tmp_rtx
condition|;
name|tmp_rtx
operator|=
name|NEXT_INSN
argument_list|(
name|tmp_rtx
argument_list|)
control|)
block|{
name|print_rtx
argument_list|(
name|tmp_rtx
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|print_rtx
argument_list|(
name|rtx_first
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of read_rtx.  */
end_comment

begin_comment
comment|/* Dump code after printing a message.  Used when read_rtx finds    invalid data.  */
end_comment

begin_function
specifier|static
name|void
name|dump_and_abort
parameter_list|(
name|expected_c
parameter_list|,
name|actual_c
parameter_list|,
name|infile
parameter_list|)
name|int
name|expected_c
decl_stmt|,
name|actual_c
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|expected_c
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected character %c.  Found character %c."
argument_list|,
name|expected_c
argument_list|,
name|actual_c
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  At file position: %ld\n"
argument_list|,
name|ftell
argument_list|(
name|infile
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Following characters are:\n\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|EOF
operator|==
name|c
condition|)
break|break;
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Aborting.\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read chars from INFILE until a non-whitespace char    and return that.  Comments, both Lisp style and C style,    are treated as whitespace.    Tools such as genflags use this function.  */
end_comment

begin_function
name|int
name|read_skip_spaces
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\f'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
specifier|register
name|int
name|prevc
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
condition|)
name|dump_and_abort
argument_list|(
literal|'*'
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|prevc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
condition|)
block|{
if|if
condition|(
name|prevc
operator|==
literal|'*'
operator|&&
name|c
operator|==
literal|'/'
condition|)
break|break;
name|prevc
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Read an rtx code name into the buffer STR[].    It is terminated by any of the punctuation chars of rtx printed syntax.  */
end_comment

begin_function
specifier|static
name|void
name|read_name
parameter_list|(
name|str
parameter_list|,
name|infile
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|p
operator|=
name|str
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\f'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'/'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|'['
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|str
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"missing name or number"
argument_list|)
expr_stmt|;
name|dump_and_abort
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read an rtx in printed representation from INFILE    and return an actual rtx in core constructed accordingly.    read_rtx is not used in the compiler proper, but rather in    the utilities gen*.c that construct C code from machine descriptions.  */
end_comment

begin_function
name|rtx
name|read_rtx
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|list_counter
decl_stmt|;
name|RTX_CODE
name|tmp_code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
comment|/* tmp_char is a buffer used for reading decimal integers      and names of rtx types and machine modes.      Therefore, 256 must be enough.  */
name|char
name|tmp_char
index|[
literal|256
index|]
decl_stmt|;
name|rtx
name|return_rtx
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|tmp_int
decl_stmt|;
comment|/* Linked list structure for making RTXs: */
struct|struct
name|rtx_list
block|{
name|struct
name|rtx_list
modifier|*
name|next
decl_stmt|;
name|rtx
name|value
decl_stmt|;
comment|/* Value of this node...		*/
block|}
struct|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Should be open paren.  */
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
name|dump_and_abort
argument_list|(
literal|'('
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|tmp_code
operator|=
name|UNKNOWN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
comment|/* @@ might speed this search up */
block|{
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|tmp_char
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tmp_code
operator|=
operator|(
name|RTX_CODE
operator|)
name|i
expr_stmt|;
comment|/* get value for name */
break|break;
block|}
block|}
if|if
condition|(
name|tmp_code
operator|==
name|UNKNOWN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown rtx read in rtl.read_rtx(). Code name was %s ."
argument_list|,
name|tmp_char
argument_list|)
expr_stmt|;
block|}
comment|/* (NIL) stands for an expression that isn't there.  */
if|if
condition|(
name|tmp_code
operator|==
name|NIL
condition|)
block|{
comment|/* Discard the closeparen.  */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|&&
name|c
operator|!=
literal|')'
condition|)
empty_stmt|;
return|return
literal|0
return|;
block|}
name|return_rtx
operator|=
name|rtx_alloc
argument_list|(
name|tmp_code
argument_list|)
expr_stmt|;
comment|/* if we end up with an insn expression 				       then we free this space below.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|return_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If what follows is `: mode ', read it and      store the mode in the rtx.  */
name|i
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|':'
condition|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_MACHINE_MODES
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|GET_MODE_NAME
argument_list|(
name|k
argument_list|)
argument_list|,
name|tmp_char
argument_list|)
condition|)
break|break;
name|PUT_MODE
argument_list|(
name|return_rtx
argument_list|,
operator|(
expr|enum
name|machine_mode
operator|)
name|k
argument_list|)
expr_stmt|;
block|}
else|else
name|ungetc
argument_list|(
name|i
argument_list|,
name|infile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|return_rtx
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
comment|/* 0 means a field for internal use only. 	   Don't expect it to be present in the input.  */
case|case
literal|'0'
case|:
break|break;
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|XEXP
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
block|{
specifier|register
name|struct
name|rtx_list
modifier|*
name|next_rtx
decl_stmt|,
modifier|*
name|rtx_list_link
decl_stmt|;
name|struct
name|rtx_list
modifier|*
name|list_rtx
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'['
condition|)
name|dump_and_abort
argument_list|(
literal|'['
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* add expressions to a list, while keeping a count */
name|next_rtx
operator|=
name|NULL
expr_stmt|;
name|list_counter
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
operator|)
operator|&&
name|c
operator|!=
literal|']'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|list_counter
operator|++
expr_stmt|;
name|rtx_list_link
operator|=
operator|(
expr|struct
name|rtx_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_list
argument_list|)
argument_list|)
expr_stmt|;
name|rtx_list_link
operator|->
name|value
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_rtx
operator|==
literal|0
condition|)
name|list_rtx
operator|=
name|rtx_list_link
expr_stmt|;
else|else
name|next_rtx
operator|->
name|next
operator|=
name|rtx_list_link
expr_stmt|;
name|next_rtx
operator|=
name|rtx_list_link
expr_stmt|;
name|rtx_list_link
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
comment|/* get vector length and allocate it */
name|XVEC
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
operator|(
name|list_counter
condition|?
name|rtvec_alloc
argument_list|(
name|list_counter
argument_list|)
else|:
operator|(
expr|struct
name|rtvec_def
operator|*
operator|)
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|list_counter
operator|>
literal|0
condition|)
block|{
name|next_rtx
operator|=
name|list_rtx
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|list_counter
condition|;
name|j
operator|++
operator|,
name|next_rtx
operator|=
name|next_rtx
operator|->
name|next
control|)
name|XVECEXP
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|next_rtx
operator|->
name|value
expr_stmt|;
block|}
comment|/* close bracket gotten */
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* 'S' is an optional string: if a closeparen follows, 	   just store NULL for this element.  */
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
name|XSTR
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
literal|'s'
case|:
block|{
name|int
name|saw_paren
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|stringbuf
decl_stmt|;
name|int
name|stringbufsize
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|saw_paren
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
name|dump_and_abort
argument_list|(
literal|'"'
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|stringbufsize
operator|=
literal|10
expr_stmt|;
name|stringbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|stringbufsize
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|j
operator|>=
name|stringbufsize
operator|-
literal|4
condition|)
block|{
name|stringbufsize
operator|*=
literal|2
expr_stmt|;
name|stringbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|stringbuf
argument_list|,
name|stringbufsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|stringbuf
index|[
name|j
index|]
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Read the string  */
if|if
condition|(
name|stringbuf
index|[
name|j
index|]
operator|==
literal|'\\'
condition|)
block|{
name|stringbuf
index|[
name|j
index|]
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Read the string  */
comment|/* \; makes stuff for a C string constant containing 		     newline and tab.  */
if|if
condition|(
name|stringbuf
index|[
name|j
index|]
operator|==
literal|';'
condition|)
block|{
name|strcpy
argument_list|(
operator|&
name|stringbuf
index|[
name|j
index|]
argument_list|,
literal|"\\n\\t"
argument_list|)
expr_stmt|;
name|j
operator|+=
literal|3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stringbuf
index|[
name|j
index|]
operator|==
literal|'"'
condition|)
break|break;
name|j
operator|++
expr_stmt|;
block|}
name|stringbuf
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* NUL terminate the string  */
name|stringbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|stringbuf
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|saw_paren
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|dump_and_abort
argument_list|(
literal|')'
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
block|}
name|XSTR
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|stringbuf
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|tmp_int
operator|=
name|atoi
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|tmp_int
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"switch format wrong in rtl.read_rtx(). format was: %c.\n"
argument_list|,
name|format_ptr
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfile position: %ld\n"
argument_list|,
name|ftell
argument_list|(
name|infile
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|dump_and_abort
argument_list|(
literal|')'
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
return|return
name|return_rtx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called once per compilation, before any rtx's are constructed.    It initializes the vector `rtx_length'.  */
end_comment

begin_function
name|void
name|init_rtl
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
name|rtx_length
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|rtx_format
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Make CONST_DOUBLE bigger, if real values are bigger than      it normally expects to have room for.      Note that REAL_VALUE_TYPE is not defined by default,      since tree.h is not included.  But the default dfn as `double'      would do no harm.  */
ifdef|#
directive|ifdef
name|REAL_VALUE_TYPE
name|i
operator|=
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|rtx_length
index|[
operator|(
name|int
operator|)
name|CONST_DOUBLE
index|]
operator|<
name|i
condition|)
block|{
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|rtx_length
index|[
operator|(
name|int
operator|)
name|CONST_DOUBLE
index|]
operator|=
name|i
expr_stmt|;
name|rtx_format
index|[
operator|(
name|int
operator|)
name|CONST_DOUBLE
index|]
operator|=
name|s
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'e'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
comment|/* Set the GET_RTX_FORMAT of CONST_DOUBLE to a string 	 of as many `i's as we now have elements.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rtx_length
index|[
operator|(
name|int
operator|)
name|CONST_DOUBLE
index|]
condition|;
name|i
operator|++
control|)
operator|*
name|s
operator|++
operator|=
literal|'i'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

