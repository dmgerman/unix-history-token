begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Allocate registers for pseudo-registers that span basic blocks.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_comment
comment|/* This pass of the compiler performs global register allocation.    It assigns hard register numbers to all the pseudo registers    that were not handled in local_alloc.  Assignments are recorded    in the vector reg_renumber, not by changing the rtl code.    (Such changes are made by final).  The entry point is    the function global_alloc.     After allocation is complete, the reload pass is run as a subroutine    of this pass, so that when a pseudo reg loses its hard reg due to    spilling it is possible to make a second attempt to find a hard    reg for it.  The reload pass is independent in other respects    and it is run even when stupid register allocation is in use.     1. count the pseudo-registers still needing allocation    and assign allocation-numbers (allocnos) to them.    Set up tables reg_allocno and allocno_reg to map     reg numbers to allocnos and vice versa.    max_allocno gets the number of allocnos in use.     2. Allocate a max_allocno by max_allocno conflict bit matrix and clear it.    Allocate a max_allocno by FIRST_PSEUDO_REGISTER conflict matrix    for conflicts between allocnos and explicit hard register use    (which includes use of pseudo-registers allocated by local_alloc).     3. for each basic block     walk forward through the block, recording which     unallocated registers and which hardware registers are live.     Build the conflict matrix between the unallocated registers     and another of unallocated registers versus hardware registers.     Also record the preferred hardware registers     for each unallocated one.     4. Sort a table of the allocnos into order of    desirability of the variables.     5. Allocate the variables in that order; each if possible into    a preferred register, else into another register.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Number of pseudo-registers still requiring allocation    (not allocated by local_allocate).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_allocno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by (pseudo) reg number, gives the allocno, or -1    for pseudo registers already allocated by local_allocate.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_allocno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by allocno, gives the reg number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocno_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector of the integers from 0 to max_allocno-1,    sorted in the order of first-to-be-allocated first.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocno_order
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by an allocno, gives the number of consecutive    hard registers needed by that pseudo reg.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocno_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max_allocno by max_allocno array of bits,    recording whether two allocno's conflict (can't go in the same    hardware register).     `conflicts' is not symmetric; a conflict between allocno's i and j    is recorded either in element i,j or in element j,i.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|conflicts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of ints require to hold max_allocno bits.    This is the length of a row in `conflicts'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocno_row_words
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two macros to test or store 1 in an element of `conflicts'.  */
end_comment

begin_define
define|#
directive|define
name|CONFLICTP
parameter_list|(
name|I
parameter_list|,
name|J
parameter_list|)
define|\
value|(conflicts[(I) * allocno_row_words + (J) / INT_BITS]	\& (1<< ((J) % INT_BITS)))
end_define

begin_define
define|#
directive|define
name|SET_CONFLICT
parameter_list|(
name|I
parameter_list|,
name|J
parameter_list|)
define|\
value|(conflicts[(I) * allocno_row_words + (J) / INT_BITS]	\   |= (1<< ((J) % INT_BITS)))
end_define

begin_comment
comment|/* Set of hard regs currently live (during scan of all insns).  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, set of hard regs conflicting with allocno N.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|hard_reg_conflicts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, set of hard regs preferred by allocno N.    This is used to make allocnos go into regs that are copied to or from them,    when possible, to reduce register shuffling.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|hard_reg_preferences
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of registers that some allocno has a preference for.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|regs_someone_prefers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of registers that global-alloc isn't supposed to use.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|no_global_alloc_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test a bit in TABLE, a vector of HARD_REG_SETs,    for vector element I, and hard register number J.  */
end_comment

begin_define
define|#
directive|define
name|REGBITP
parameter_list|(
name|TABLE
parameter_list|,
name|I
parameter_list|,
name|J
parameter_list|)
value|TEST_HARD_REG_BIT (TABLE[I], J)
end_define

begin_comment
comment|/* Set to 1 a bit in a vector of HARD_REG_SETs.  Works like REGBITP.  */
end_comment

begin_define
define|#
directive|define
name|SET_REGBIT
parameter_list|(
name|TABLE
parameter_list|,
name|I
parameter_list|,
name|J
parameter_list|)
value|SET_HARD_REG_BIT (TABLE[I], J)
end_define

begin_comment
comment|/* Bit mask for allocnos live at current point in the scan.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|allocnos_live
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INT_BITS
value|HOST_BITS_PER_INT
end_define

begin_comment
comment|/* Test, set or clear bit number I in allocnos_live,    a bit vector indexed by allocno.  */
end_comment

begin_define
define|#
directive|define
name|ALLOCNO_LIVE_P
parameter_list|(
name|I
parameter_list|)
define|\
value|(allocnos_live[(I) / INT_BITS]& (1<< ((I) % INT_BITS)))
end_define

begin_define
define|#
directive|define
name|SET_ALLOCNO_LIVE
parameter_list|(
name|I
parameter_list|)
define|\
value|(allocnos_live[(I) / INT_BITS] |= (1<< ((I) % INT_BITS)))
end_define

begin_define
define|#
directive|define
name|CLEAR_ALLOCNO_LIVE
parameter_list|(
name|I
parameter_list|)
define|\
value|(allocnos_live[(I) / INT_BITS]&= ~(1<< ((I) % INT_BITS)))
end_define

begin_comment
comment|/* Record all regs that are set in any one insn.    Communication from mark_reg_{store,clobber} and global_conflicts.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|regs_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_regs_set
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|allocno_compare
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_store
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_clobber
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_live_nc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_death
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_conflicts
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|global_conflicts
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_conflicts
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_preference
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Perform allocation of pseudo-registers not allocated by local_alloc.    FILE is a file to output debugging information on,    or zero if such output is not desired.  */
end_comment

begin_function
name|void
name|global_alloc
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|max_allocno
operator|=
literal|0
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|regs_someone_prefers
argument_list|)
expr_stmt|;
comment|/* A machine may have certain hard registers that      are safe to use only within a basic block.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|no_global_alloc_regs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OVERLAPPING_REGNO_P
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|OVERLAPPING_REGNO_P
argument_list|(
name|i
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|no_global_alloc_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Establish mappings from register number to allocation number      and vice versa.  In the process, count the allocnos.  */
name|reg_allocno
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_allocno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
comment|/* Note that reg_live_length[i]< 0 indicates a "constant" reg        that we are supposed to refrain from putting in a hard reg.        -2 means do make an allocno but don't allocate it.  */
if|if
condition|(
name|reg_n_refs
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_live_length
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|reg_allocno
index|[
name|i
index|]
operator|=
name|max_allocno
operator|++
expr_stmt|;
if|if
condition|(
name|reg_live_length
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|reg_allocno
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|allocno_reg
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|allocno_size
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|allocno_size
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_allocno
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|allocno_reg
index|[
name|reg_allocno
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
name|allocno_size
index|[
name|reg_allocno
index|[
name|i
index|]
index|]
operator|=
name|PSEUDO_REGNO_SIZE
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the space for the conflict tables.  */
name|hard_reg_conflicts
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hard_reg_conflicts
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|hard_reg_preferences
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hard_reg_preferences
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|allocno_row_words
operator|=
operator|(
name|max_allocno
operator|+
name|INT_BITS
operator|-
literal|1
operator|)
operator|/
name|INT_BITS
expr_stmt|;
name|conflicts
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
name|allocno_row_words
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|conflicts
argument_list|,
name|max_allocno
operator|*
name|allocno_row_words
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|allocnos_live
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|allocno_row_words
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is work to be done (at least one reg to allocate),      perform global conflict analysis and allocate the regs.  */
if|if
condition|(
name|max_allocno
operator|>
literal|0
condition|)
block|{
comment|/* Scan all the insns and compute the conflicts among allocnos 	 and between allocnos and hard regs.  */
name|global_conflicts
argument_list|()
expr_stmt|;
comment|/* Determine the order to allocate the remaining pseudo registers.  */
name|allocno_order
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
name|allocno_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Default the size to 1, since allocno_compare uses it to divide by.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|allocno_size
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|allocno_size
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|qsort
argument_list|(
name|allocno_order
argument_list|,
name|max_allocno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|allocno_compare
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_conflicts
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Try allocating them, one by one, in that order, 	 except for parameters marked with reg_live_length[regno] == -2.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_live_length
index|[
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
index|]
operator|>=
literal|0
condition|)
block|{
comment|/* If we have more than one register class, 	       first try allocating in the class that is cheapest 	       for this pseudo-reg.  If that fails, try any reg.  */
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
block|{
name|find_reg
argument_list|(
name|allocno_order
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hard_reg_preferences
index|[
name|allocno_order
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
index|]
operator|>=
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
name|reg_preferred_or_nothing
argument_list|(
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
argument_list|)
condition|)
name|find_reg
argument_list|(
name|allocno_order
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|hard_reg_preferences
index|[
name|allocno_order
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do the reloads now while the allocno data still exist, so that we can      try to assign new hard regs to any pseudo regs that are spilled.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
name|reload
argument_list|(
name|basic_block_head
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sort predicate for ordering the allocnos.    Returns -1 (1) if *v1 should be allocated before (after) *v2.  */
end_comment

begin_function
specifier|static
name|int
name|allocno_compare
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|int
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|r1
init|=
name|allocno_reg
index|[
operator|*
name|v1
index|]
decl_stmt|;
specifier|register
name|int
name|r2
init|=
name|allocno_reg
index|[
operator|*
name|v2
index|]
decl_stmt|;
comment|/* Note that the quotient will never be bigger than      the value of floor_log2 times the maximum number of      times a register can occur in one insn (surely less than 100).      Multiplying this by 10000 can't overflow.  */
specifier|register
name|int
name|pri1
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|reg_n_refs
index|[
name|r1
index|]
argument_list|)
operator|*
name|reg_n_refs
index|[
name|r1
index|]
argument_list|)
operator|/
operator|(
name|reg_live_length
index|[
name|r1
index|]
operator|*
name|allocno_size
index|[
operator|*
name|v1
index|]
operator|)
operator|)
operator|*
literal|10000
operator|)
decl_stmt|;
specifier|register
name|int
name|pri2
init|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|floor_log2
argument_list|(
name|reg_n_refs
index|[
name|r2
index|]
argument_list|)
operator|*
name|reg_n_refs
index|[
name|r2
index|]
argument_list|)
operator|/
operator|(
name|reg_live_length
index|[
name|r2
index|]
operator|*
name|allocno_size
index|[
operator|*
name|v2
index|]
operator|)
operator|)
operator|*
literal|10000
operator|)
decl_stmt|;
if|if
condition|(
name|pri2
operator|-
name|pri1
condition|)
return|return
name|pri2
operator|-
name|pri1
return|;
comment|/* If regs are equally good, sort by allocno,      so that the results of qsort leave nothing to chance.  */
return|return
operator|*
name|v1
operator|-
operator|*
name|v2
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Scan the rtl code and record all conflicts in the conflict matrices.  */
end_comment

begin_function
specifier|static
name|void
name|global_conflicts
parameter_list|()
block|{
specifier|register
name|int
name|b
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
name|short
modifier|*
name|block_start_allocnos
decl_stmt|;
comment|/* Make a vector that mark_reg_{store,clobber} will store in.  */
name|regs_set
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_parallel
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|block_start_allocnos
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
name|bzero
argument_list|(
name|allocnos_live
argument_list|,
name|allocno_row_words
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize table of registers currently live 	 to the state at the beginning of this basic block. 	 This also marks the conflicts among them.  	 For pseudo-regs, there is only one bit for each one 	 no matter how many hard regs it occupies. 	 This is ok; we know the size from PSEUDO_REGNO_SIZE. 	 For explicit hard regs, we cannot know the size that way 	 since one hard reg can be used with various sizes. 	 Therefore, we must require that all the hard regs 	 implicitly live as part of a multi-word hard reg 	 are explicitly marked in basic_block_live_at_start.  */
block|{
specifier|register
name|int
name|offset
decl_stmt|,
name|bit
decl_stmt|;
specifier|register
name|regset
name|old
init|=
name|basic_block_live_at_start
index|[
name|b
index|]
decl_stmt|;
name|int
name|ax
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
name|hard_regs_live
operator|=
name|old
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|COPY_HARD_REG_SET
argument_list|(
name|hard_regs_live
argument_list|,
name|old
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|offset
operator|<
name|regset_size
condition|;
name|offset
operator|++
control|)
if|if
condition|(
name|old
index|[
name|offset
index|]
operator|==
literal|0
condition|)
name|i
operator|+=
name|HOST_BITS_PER_INT
expr_stmt|;
else|else
for|for
control|(
name|bit
operator|=
literal|1
init|;
name|bit
condition|;
name|bit
operator|<<=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|max_regno
condition|)
break|break;
if|if
condition|(
name|old
index|[
name|offset
index|]
operator|&
name|bit
condition|)
block|{
specifier|register
name|int
name|a
init|=
name|reg_allocno
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|)
block|{
name|SET_ALLOCNO_LIVE
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|block_start_allocnos
index|[
name|ax
operator|++
index|]
operator|=
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|a
operator|=
name|reg_renumber
index|[
name|i
index|]
operator|)
operator|>=
literal|0
condition|)
name|mark_reg_live_nc
argument_list|(
name|a
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record that each allocno now live conflicts with each other 	   allocno now live, and with each hard reg now live.  */
name|record_conflicts
argument_list|(
name|block_start_allocnos
argument_list|,
name|ax
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|basic_block_head
index|[
name|b
index|]
expr_stmt|;
comment|/* Scan the code of this basic block, noting which allocnos 	 and hard regs are born or die.  When one is born, 	 record a conflict with all others currently live.  */
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|link
decl_stmt|;
comment|/* Make regs_set an empty set.  */
name|n_regs_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* Mark any registers clobbered by INSN as live, 		 so they conflict with the inputs.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_reg_clobber
argument_list|)
expr_stmt|;
comment|/* Mark any registers dead after INSN as dead now.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|mark_reg_death
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark any registers set in INSN as live, 		 and mark them as conflicting with all other live regs. 		 Clobbers are processed again, so they conflict with 		 the registers that are set.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_reg_store
argument_list|)
expr_stmt|;
comment|/* Mark any registers both set and dead after INSN as dead. 		 This is not redundant! 		 A register may be set and killed in the same insn. 		 It is necessary to mark them as live, above, to get 		 the right conflicts within the insn.  */
while|while
condition|(
name|n_regs_set
operator|>
literal|0
condition|)
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|regs_set
index|[
operator|--
name|n_regs_set
index|]
argument_list|)
argument_list|)
condition|)
name|mark_reg_death
argument_list|(
name|regs_set
index|[
name|n_regs_set
index|]
argument_list|)
expr_stmt|;
comment|/* Likewise for regs set by incrementation.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|mark_reg_death
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|b
index|]
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assign a hard register to ALLOCNO; look for one that is the beginning    of a long enough stretch of hard regs none of which conflicts with ALLOCNO.    The registers marked in PREFREGS are tried first.     If ALL_REGS_P is zero, consider only the preferred class of ALLOCNO's reg.    Otherwise ignore that preferred class.     If ACCEPT_CALL_CLOBBERED is nonzero, accept a call-clobbered hard reg that    will have to be saved and restored at calls.     If we find one, record it in reg_renumber.    If not, do nothing.  */
end_comment

begin_function
specifier|static
name|void
name|find_reg
parameter_list|(
name|allocno
parameter_list|,
name|losers
parameter_list|,
name|all_regs_p
parameter_list|,
name|accept_call_clobbered
parameter_list|,
name|prefregs
parameter_list|)
name|int
name|allocno
decl_stmt|;
specifier|register
name|short
modifier|*
name|losers
decl_stmt|;
name|int
name|all_regs_p
decl_stmt|;
name|int
name|accept_call_clobbered
decl_stmt|;
name|HARD_REG_SET
name|prefregs
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|prefreg
decl_stmt|,
name|pass
decl_stmt|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare it register if it's a scalar.  */
endif|#
directive|endif
name|HARD_REG_SET
name|used
decl_stmt|;
name|enum
name|reg_class
name|class
init|=
name|all_regs_p
condition|?
name|GENERAL_REGS
else|:
name|reg_preferred_class
argument_list|(
name|allocno_reg
index|[
name|allocno
index|]
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|PSEUDO_REGNO_MODE
argument_list|(
name|allocno_reg
index|[
name|allocno
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|accept_call_clobbered
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_n_calls_crossed
index|[
name|allocno_reg
index|[
name|allocno
index|]
index|]
operator|==
literal|0
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
else|else
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
comment|/* Some registers should not be allocated in global-alloc.  */
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|no_global_alloc_regs
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|hard_reg_conflicts
index|[
name|allocno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|prefregs
argument_list|,
name|used
argument_list|)
expr_stmt|;
comment|/* Try to find a register from the preferred set first. */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|prefreg
operator|=
literal|0
init|;
name|prefreg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|prefreg
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|prefregs
argument_list|,
name|prefreg
argument_list|)
operator|&&
operator|(
name|losers
operator|==
literal|0
operator|||
name|losers
index|[
name|prefreg
index|]
operator|<
literal|0
operator|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|prefreg
argument_list|,
name|mode
argument_list|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|prefreg
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|prefreg
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|prefreg
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|lim
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
name|losers
operator|==
literal|0
operator|||
name|losers
index|[
name|j
index|]
operator|<
literal|0
operator|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|lim
condition|)
block|{
name|i
operator|=
name|prefreg
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Otherwise try each hard reg to see if it fits.  Do this in two passes.      In the first pass, skip registers that are prefered by some pseudo to      give it a better chance of getting one of those registers.  Only if      we can't get a register when excluding those do we take one of them.  */
comment|/* This is turned off because it makes worse allocation on the 68020.  */
block|for (pass = 0; pass<= 1&& i< 0; pass++)
endif|#
directive|endif
name|pass
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|regno
argument_list|)
operator|&&
operator|(
name|losers
operator|==
literal|0
operator|||
name|losers
index|[
name|regno
index|]
operator|<
literal|0
operator|)
operator|&&
operator|(
name|pass
operator|==
literal|1
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_someone_prefers
argument_list|,
name|regno
argument_list|)
operator|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|lim
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|regno
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|lim
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
name|losers
operator|==
literal|0
operator|||
name|losers
index|[
name|j
index|]
operator|<
literal|0
operator|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|lim
condition|)
block|{
name|i
operator|=
name|regno
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|REG_ALLOC_ORDER
name|i
operator|=
name|j
expr_stmt|;
comment|/* Skip starting points we know will lose */
endif|#
directive|endif
block|}
block|}
comment|/* Did we find a register?  */
if|if
condition|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
specifier|register
name|int
name|lim
decl_stmt|,
name|j
decl_stmt|;
name|HARD_REG_SET
name|this_reg
decl_stmt|;
comment|/* Yes.  Record it as the hard register of this pseudo-reg.  */
name|reg_renumber
index|[
name|allocno_reg
index|[
name|allocno
index|]
index|]
operator|=
name|i
expr_stmt|;
comment|/* For each other pseudo-reg conflicting with this one, 	 mark it as conflicting with the hard regs this one occupies.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|this_reg
argument_list|)
expr_stmt|;
name|lim
operator|=
name|i
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|lim
condition|;
name|j
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|this_reg
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|lim
operator|=
name|allocno
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_allocno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|CONFLICTP
argument_list|(
name|lim
argument_list|,
name|j
argument_list|)
operator|||
name|CONFLICTP
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
condition|)
block|{
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_conflicts
index|[
name|j
index|]
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flag_caller_saves
condition|)
block|{
comment|/* Did not find a register.  If it would be profitable to 	 allocate a call-clobbered register and save and restore it 	 around calls, do that.  */
if|if
condition|(
operator|!
name|accept_call_clobbered
operator|&&
name|reg_n_calls_crossed
index|[
name|allocno_reg
index|[
name|allocno
index|]
index|]
operator|!=
literal|0
operator|&&
name|CALLER_SAVE_PROFITABLE
argument_list|(
name|reg_n_refs
index|[
name|allocno_reg
index|[
name|allocno
index|]
index|]
argument_list|,
name|reg_n_calls_crossed
index|[
name|allocno_reg
index|[
name|allocno
index|]
index|]
argument_list|)
condition|)
block|{
name|find_reg
argument_list|(
name|allocno
argument_list|,
name|losers
argument_list|,
name|all_regs_p
argument_list|,
literal|1
argument_list|,
name|prefregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|allocno_reg
index|[
name|allocno
index|]
index|]
operator|>=
literal|0
condition|)
name|caller_save_needed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called from `reload' to look for a hard reg to put pseudo reg REGNO in.    Perhaps it had previously seemed not worth a hard reg,    or perhaps its old hard reg has been commandeered for reloads.    FORBIDDEN_REGS is a vector that indicates certain hard regs    that may not be used, even if they do not appear to be allocated.    A nonnegative element means the corresponding hard reg is forbidden.    If FORBIDDEN_REGS is zero, no regs are forbidden.  */
end_comment

begin_function
name|void
name|retry_global_alloc
parameter_list|(
name|regno
parameter_list|,
name|forbidden_regs
parameter_list|)
name|int
name|regno
decl_stmt|;
name|short
modifier|*
name|forbidden_regs
decl_stmt|;
block|{
name|int
name|allocno
init|=
name|reg_allocno
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|allocno
operator|>=
literal|0
condition|)
block|{
comment|/* If we have more than one register class, 	 first try allocating in the class that is cheapest 	 for this pseudo-reg.  If that fails, try any reg.  */
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
name|find_reg
argument_list|(
name|allocno
argument_list|,
name|forbidden_regs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hard_reg_preferences
index|[
name|allocno
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
operator|!
name|reg_preferred_or_nothing
argument_list|(
name|regno
argument_list|)
condition|)
name|find_reg
argument_list|(
name|allocno
argument_list|,
name|forbidden_regs
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|hard_reg_preferences
index|[
name|allocno
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from reload pass to see if current function's pseudo regs    require a frame pointer to be allocated and set up.     Return 1 if so, 0 otherwise.    We may alter the hard-reg allocation of the pseudo regs    in order to make the frame pointer unnecessary.    However, if the value is 1, nothing has been altered.     Args grant access to some tables used in reload1.c.    See there for info on them.  */
end_comment

begin_function
name|int
name|check_frame_pointer_required
parameter_list|(
name|reg_equiv_constant
parameter_list|,
name|reg_equiv_mem
parameter_list|,
name|reg_equiv_address
parameter_list|)
name|rtx
modifier|*
name|reg_equiv_constant
decl_stmt|,
decl|*
name|reg_equiv_mem
decl_stmt|,
modifier|*
name|reg_equiv_address
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|old_hard_reg_conflicts
decl_stmt|;
name|short
modifier|*
name|old_reg_renumber
decl_stmt|;
name|char
name|old_regs_ever_live
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
comment|/* If any pseudo reg has no hard reg and no equivalent,      we must have a frame pointer.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_n_refs
index|[
name|i
index|]
operator|>
literal|0
operator|&&
name|reg_equiv_mem
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reg_equiv_address
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* If we might not need a frame pointer,      try finding a hard reg for any pseudo that has a memory equivalent.      That is because the memory equivalent probably refers to a frame      pointer.  */
name|old_reg_renumber
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|old_hard_reg_conflicts
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|reg_renumber
argument_list|,
name|old_reg_renumber
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hard_reg_conflicts
argument_list|,
name|old_hard_reg_conflicts
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs_ever_live
argument_list|,
name|old_regs_ever_live
argument_list|,
sizeof|sizeof
name|regs_ever_live
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
operator|(
operator|(
name|reg_equiv_mem
index|[
name|i
index|]
operator|&&
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|reg_equiv_mem
index|[
name|i
index|]
argument_list|)
operator|)
operator|||
operator|(
name|reg_equiv_address
index|[
name|i
index|]
operator|&&
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|reg_equiv_address
index|[
name|i
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|retry_global_alloc
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we can't find a hard reg for ALL of them, 	   or if a previously unneeded hard reg is used that requires saving, 	   we fail: set all those pseudos back as they were.  */
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|||
operator|(
operator|!
name|old_regs_ever_live
index|[
name|reg_renumber
index|[
name|i
index|]
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg_renumber
index|[
name|i
index|]
index|]
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|old_reg_renumber
argument_list|,
name|reg_renumber
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|old_hard_reg_conflicts
argument_list|,
name|hard_reg_conflicts
argument_list|,
name|max_allocno
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|old_regs_ever_live
argument_list|,
name|regs_ever_live
argument_list|,
sizeof|sizeof
name|regs_ever_live
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|mark_home_live
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Record a conflict between register REGNO    and everything currently live.    REGNO must not be a pseudo reg that was allocated    by local_alloc; such numbers must be translated through    reg_renumber before calling here.  */
end_comment

begin_function
specifier|static
name|void
name|record_one_conflict
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
comment|/* When a hard register becomes live,        record conflicts with live pseudo regs.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_allocno
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ALLOCNO_LIVE_P
argument_list|(
name|j
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|hard_reg_conflicts
index|[
name|j
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* When a pseudo-register becomes live,        record conflicts first with hard regs,        then with other pseudo regs.  */
block|{
specifier|register
name|int
name|ialloc
init|=
name|reg_allocno
index|[
name|regno
index|]
decl_stmt|;
specifier|register
name|int
name|ialloc_prod
init|=
name|ialloc
operator|*
name|allocno_row_words
decl_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_conflicts
index|[
name|ialloc
index|]
argument_list|,
name|hard_regs_live
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|allocno_row_words
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|conflicts
index|[
name|ialloc_prod
operator|+
name|j
index|]
operator||=
name|allocnos_live
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record all allocnos currently live as conflicting    with each other and with all hard regs currently live.    ALLOCNO_VEC is a vector of LEN allocnos, all allocnos that    are currently live.  Their bits are also flagged in allocnos_live.  */
end_comment

begin_function
specifier|static
name|void
name|record_conflicts
parameter_list|(
name|allocno_vec
parameter_list|,
name|len
parameter_list|)
specifier|register
name|short
modifier|*
name|allocno_vec
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|allocno
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|ialloc_prod
decl_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|allocno
operator|=
name|allocno_vec
index|[
name|len
index|]
expr_stmt|;
name|ialloc_prod
operator|=
name|allocno
operator|*
name|allocno_row_words
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|hard_reg_conflicts
index|[
name|allocno
index|]
argument_list|,
name|hard_regs_live
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|allocno_row_words
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|conflicts
index|[
name|ialloc_prod
operator|+
name|j
index|]
operator||=
name|allocnos_live
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the case where REG is set by the insn being scanned,    during the forward scan to accumulate conflicts.    Store a 1 in regs_live or allocnos_live for this register, record how many    consecutive hardware registers it actually needs,    and record a conflict with all other registers already live.     Note that even if REG does not remain alive after this insn,    we must mark it here as live, to ensure a conflict between    REG and any other regs set in this insn that really do live.    This is because those other regs could be considered after this.     REG might actually be something other than a register;    if so, we do nothing.     CLOBBERs are processed here by calling mark_reg_clobber.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_store
parameter_list|(
name|orig_reg
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|orig_reg
decl_stmt|,
name|setter
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|orig_reg
decl_stmt|;
comment|/* WORD is which word of a multi-register group is being stored.      For the case where the store is actually into a SUBREG of REG.      Except we don't use it; I believe the entire REG needs to be      made live.  */
name|int
name|word
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|word
operator|=
name|SUBREG_WORD
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|!=
name|SET
condition|)
block|{
comment|/* A clobber of a register should be processed here too.  */
name|mark_reg_clobber
argument_list|(
name|orig_reg
argument_list|,
name|setter
argument_list|)
expr_stmt|;
return|return;
block|}
name|regs_set
index|[
name|n_regs_set
operator|++
index|]
operator|=
name|reg
expr_stmt|;
name|set_preference
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|setter
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
comment|/* + word */
expr_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is or has a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
block|{
name|SET_ALLOCNO_LIVE
argument_list|(
name|reg_allocno
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
elseif|else
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
specifier|register
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like mark_reg_set except notice just CLOBBERs; ignore SETs.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_clobber
parameter_list|(
name|reg
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|setter
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
comment|/* WORD is which word of a multi-register group is being stored.      For the case where the store is actually into a SUBREG of REG.      Except we don't use it; I believe the entire REG needs to be      made live.  */
name|int
name|word
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|word
operator|=
name|SUBREG_WORD
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regs_set
index|[
name|n_regs_set
operator|++
index|]
operator|=
name|reg
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
comment|/* + word */
expr_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is or has a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
block|{
name|SET_ALLOCNO_LIVE
argument_list|(
name|reg_allocno
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
elseif|else
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
specifier|register
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|record_one_conflict
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mark REG as being dead (following the insn being scanned now).    Store a 0 in regs_live or allocnos_live for this register.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_death
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
comment|/* For pseudo reg, see if it has been assigned a hardware reg.  */
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
comment|/* Either this is one of the max_allocno pseudo regs not allocated,      or it is a hardware reg.  First handle the pseudo-regs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_allocno
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|CLEAR_ALLOCNO_LIVE
argument_list|(
name|reg_allocno
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
elseif|else
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
block|{
comment|/* Pseudo regs already assigned hardware regs are treated 	 almost the same as explicit hardware regs.  */
specifier|register
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark hard reg REGNO as currently live, assuming machine mode MODE    for the value stored in it.  MODE determines how many consecutive    registers are actually in use.  Do not record conflicts;    it is assumed that the caller will do that.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_live_nc
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to set a preference for an allocno to a hard register.    We are passed DEST and SRC which are the operands of a SET.  It is known    that SRC is a register.  If SRC or the first operand of SRC is a register,    try to set a preference.  If one of the two is a hard register and the other    is a pseudo-register, mark the preference.        Note that we are not as agressive as local-alloc in trying to tie a    pseudo-register to a hard register.  */
end_comment

begin_function
specifier|static
name|void
name|set_preference
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|;
block|{
name|int
name|src_regno
decl_stmt|,
name|dest_regno
decl_stmt|;
comment|/* Amount to add to the hard regno for SRC, or subtract from that for DEST,      to compensate for subregs in SRC or DEST.  */
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get the reg number for both SRC and DEST.      If neither is a reg, give up.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|-=
name|SUBREG_WORD
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
comment|/* Convert either or both to hard reg numbers.  */
if|if
condition|(
name|reg_renumber
index|[
name|src_regno
index|]
operator|>=
literal|0
condition|)
name|src_regno
operator|=
name|reg_renumber
index|[
name|src_regno
index|]
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|dest_regno
index|]
operator|>=
literal|0
condition|)
name|dest_regno
operator|=
name|reg_renumber
index|[
name|dest_regno
index|]
expr_stmt|;
comment|/* Now if one is a hard reg and the other is a global pseudo      then give the other a preference.  */
if|if
condition|(
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|src_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_allocno
index|[
name|src_regno
index|]
operator|>=
literal|0
condition|)
block|{
name|dest_regno
operator|-=
name|offset
expr_stmt|;
if|if
condition|(
name|dest_regno
operator|>=
literal|0
operator|&&
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|SET_REGBIT
argument_list|(
name|hard_reg_preferences
argument_list|,
name|reg_allocno
index|[
name|src_regno
index|]
argument_list|,
name|dest_regno
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regs_someone_prefers
argument_list|,
name|dest_regno
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|dest_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_allocno
index|[
name|dest_regno
index|]
operator|>=
literal|0
condition|)
block|{
name|src_regno
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|src_regno
operator|>=
literal|0
operator|&&
name|src_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|SET_REGBIT
argument_list|(
name|hard_reg_preferences
argument_list|,
name|reg_allocno
index|[
name|dest_regno
index|]
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|regs_someone_prefers
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print debugging trace information if -greg switch is given,    showing the information on which the allocation decisions are based.  */
end_comment

begin_function
specifier|static
name|void
name|dump_conflicts
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d regs to allocate:"
argument_list|,
name|max_allocno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|allocno_reg
index|[
name|allocno_order
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocno_size
index|[
name|allocno_order
index|[
name|i
index|]
index|]
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (%d)"
argument_list|,
name|allocno_size
index|[
name|allocno_order
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_allocno
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d conflicts:"
argument_list|,
name|allocno_reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_allocno
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|CONFLICTP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
operator|||
name|CONFLICTP
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|allocno_reg
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_reg_conflicts
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_global_regs
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Register dispositions:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d in %d "
argument_list|,
name|i
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n;; Hard regs used: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

