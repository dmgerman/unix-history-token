begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)printcmd.c	6.5 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Print values for GNU debugger GDB.    Copyright (C) 1986, 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_struct
struct|struct
name|format_data
block|{
name|int
name|count
decl_stmt|;
name|char
name|format
decl_stmt|;
name|char
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Last specified output format.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|last_format
init|=
literal|'x'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last specified examination size.  'b', 'h', 'w' or `q'.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|last_size
init|=
literal|'w'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default address to examine next.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|next_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last address examined.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|last_examine_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contents of last address examined.    This is not valid past the end of the `x' command!  */
end_comment

begin_decl_stmt
specifier|static
name|value
name|last_examine_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of auto-display expression currently being displayed.    So that we can deleted it if we get an error or a signal within it.    -1 when not doing one.  */
end_comment

begin_decl_stmt
name|int
name|current_display_number
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|do_one_display
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|do_displays
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_address
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_floating
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_scalar_formatted
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_formatted_address
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Decode a format specification.  *STRING_PTR should point to it.    OFORMAT and OSIZE are used as defaults for the format and size    if none are given in the format specification.    If OSIZE is zero, then the size field of the returned value    should be set only if a size is explicitly specified by the    user.    The structure returned describes all the data    found in the specification.  In addition, *STRING_PTR is advanced    past the specification and past all whitespace following it.  */
end_comment

begin_function
name|struct
name|format_data
name|decode_format
parameter_list|(
name|string_ptr
parameter_list|,
name|oformat
parameter_list|,
name|osize
parameter_list|)
name|char
modifier|*
modifier|*
name|string_ptr
decl_stmt|;
name|char
name|oformat
decl_stmt|;
name|char
name|osize
decl_stmt|;
block|{
name|struct
name|format_data
name|val
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
operator|*
name|string_ptr
decl_stmt|;
name|val
operator|.
name|format
operator|=
literal|'?'
expr_stmt|;
name|val
operator|.
name|size
operator|=
literal|'?'
expr_stmt|;
name|val
operator|.
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|val
operator|.
name|count
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Now process size or format letters that follow.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'b'
operator|||
operator|*
name|p
operator|==
literal|'h'
operator|||
operator|*
name|p
operator|==
literal|'w'
operator|||
operator|*
name|p
operator|==
literal|'g'
condition|)
name|val
operator|.
name|size
operator|=
operator|*
name|p
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LONG_LONG
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'l'
condition|)
block|{
name|val
operator|.
name|size
operator|=
literal|'g'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|)
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
operator|)
condition|)
name|val
operator|.
name|format
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|else
break|break;
block|}
ifndef|#
directive|ifndef
name|LONG_LONG
comment|/* Make sure 'g' size is not used on integer types.      Well, actually, we can handle hex.  */
if|if
condition|(
name|val
operator|.
name|size
operator|==
literal|'g'
operator|&&
name|val
operator|.
name|format
operator|!=
literal|'f'
operator|&&
name|val
operator|.
name|format
operator|!=
literal|'x'
condition|)
name|val
operator|.
name|size
operator|=
literal|'w'
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|string_ptr
operator|=
name|p
expr_stmt|;
comment|/* Set defaults for format and size if not specified.  */
if|if
condition|(
name|val
operator|.
name|format
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|val
operator|.
name|size
operator|==
literal|'?'
condition|)
block|{
comment|/* Neither has been specified.  */
name|val
operator|.
name|format
operator|=
name|oformat
expr_stmt|;
name|val
operator|.
name|size
operator|=
name|osize
expr_stmt|;
block|}
else|else
comment|/* If a size is specified, any format makes a reasonable 	   default except 'i'.  */
name|val
operator|.
name|format
operator|=
name|oformat
operator|==
literal|'i'
condition|?
literal|'x'
else|:
name|oformat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|.
name|size
operator|==
literal|'?'
condition|)
switch|switch
condition|(
name|val
operator|.
name|format
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'s'
case|:
case|case
literal|'A'
case|:
comment|/* Addresses must be words.  */
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'w'
else|:
name|osize
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Floating point has to be word or giantword.  */
if|if
condition|(
name|osize
operator|==
literal|'w'
operator|||
name|osize
operator|==
literal|'g'
condition|)
name|val
operator|.
name|size
operator|=
name|osize
expr_stmt|;
else|else
comment|/* Default it to giantword if the last used size is not 	     appropriate.  */
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'g'
else|:
name|osize
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Characters default to one byte.  */
name|val
operator|.
name|size
operator|=
name|osize
condition|?
literal|'b'
else|:
name|osize
expr_stmt|;
break|break;
default|default:
comment|/* The default is the size most recently specified.  */
name|val
operator|.
name|size
operator|=
name|osize
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print value VAL on stdout according to FORMAT, a letter or 0.    Do not end with a newline.    0 means print VAL according to its own type.    SIZE is the letter for the size of datum being printed.    This is used to pad hex numbers so they line up.  */
end_comment

begin_function
specifier|static
name|void
name|print_formatted
parameter_list|(
name|val
parameter_list|,
name|format
parameter_list|,
name|size
parameter_list|)
specifier|register
name|value
name|val
decl_stmt|;
specifier|register
name|char
name|format
decl_stmt|;
name|char
name|size
decl_stmt|;
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|==
name|lval_memory
condition|)
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|len
expr_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'s'
case|:
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|value_print
argument_list|(
name|value_addr
argument_list|(
name|val
argument_list|)
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|print_insn
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|format
operator|==
literal|0
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|||
name|VALUE_REPEATED
argument_list|(
name|val
argument_list|)
condition|)
name|value_print
argument_list|(
name|val
argument_list|,
name|stdout
argument_list|,
name|format
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
else|else
name|print_scalar_formatted
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|format
argument_list|,
name|size
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a scalar of data of type TYPE, pointed to in GDB by VALADDR,    according to letters FORMAT and SIZE on STREAM.    FORMAT may not be zero.  Formats s and i are not supported at this level.     This is how the elements of an array or structure are printed    with a format.  */
end_comment

begin_function
name|void
name|print_scalar_formatted
parameter_list|(
name|valaddr
parameter_list|,
name|type
parameter_list|,
name|format
parameter_list|,
name|size
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|valaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
name|format
decl_stmt|;
name|int
name|size
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|LONGEST
name|val_long
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|'g'
operator|&&
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|<
literal|8
operator|&&
name|format
operator|==
literal|'x'
condition|)
block|{
comment|/* ok, we're going to have to get fancy here.  Assumption: a          long is four bytes.  */
name|unsigned
name|long
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|tmp
decl_stmt|;
name|v1
operator|=
name|unpack_long
argument_list|(
name|builtin_type_long
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
name|v2
operator|=
name|unpack_long
argument_list|(
name|builtin_type_long
argument_list|,
name|valaddr
operator|+
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
else|#
directive|else
comment|/* Little endian -- swap the two for printing */
name|tmp
operator|=
name|v1
expr_stmt|;
name|v1
operator|=
name|v2
expr_stmt|;
name|v2
operator|=
name|tmp
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'x'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%08x%08x"
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Output size \"g\" unimplemented for format \"%c\"."
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|val_long
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
comment|/* If value is unsigned, truncate it in case negative.  */
if|if
condition|(
name|format
operator|!=
literal|'d'
condition|)
block|{
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
name|val_long
operator|&=
operator|(
literal|1
operator|<<
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
name|val_long
operator|&=
operator|(
literal|1
operator|<<
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|val_long
operator|&=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|'x'
case|:
ifdef|#
directive|ifdef
name|LONG_LONG
if|if
condition|(
operator|!
name|size
condition|)
name|size
operator|=
operator|(
name|len
operator|<
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|?
literal|'w'
else|:
literal|'g'
operator|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|'b'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%02llx"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%04llx"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* no size specified, like in print */
case|case
literal|'w'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%08llx"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%016llx"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Undefined output size \"%c\"."
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|'b'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%02x"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%04x"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* no size specified, like in print */
case|case
literal|'w'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%08x"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%o16x"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Undefined output size \"%c\"."
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not LONG_LONG */
break|break;
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|LONG_LONG
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%lld"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'u'
case|:
ifdef|#
directive|ifdef
name|LONG_LONG
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%llu"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%u"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|val_long
condition|)
ifdef|#
directive|ifdef
name|LONG_LONG
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0%llo"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0%o"
argument_list|,
name|val_long
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|print_address
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|val_long
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|print_formatted_address
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|val_long
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|value_print
argument_list|(
name|value_from_long
argument_list|(
name|builtin_type_char
argument_list|,
name|val_long
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_float
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_double
expr_stmt|;
name|print_floating
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|abort
argument_list|()
expr_stmt|;
default|default:
name|error
argument_list|(
literal|"Undefined output format \"%c\"."
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a floating point value of type TYPE, pointed to in GDB by VALADDR,    on STREAM.  */
end_comment

begin_function
name|void
name|print_floating
parameter_list|(
name|valaddr
parameter_list|,
name|type
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|valaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|double
name|doub
decl_stmt|;
name|int
name|inv
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|doub
operator|=
name|unpack_double
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
operator|&
name|inv
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Invalid float value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|doub
operator|!=
name|doub
condition|)
block|{
comment|/* Surely it is an IEEE floating point NaN. */
name|long
name|low
decl_stmt|,
name|high
decl_stmt|,
modifier|*
name|arg
init|=
operator|(
name|long
operator|*
operator|)
name|valaddr
decl_stmt|;
comment|/* ASSUMED 32 BITS */
name|int
name|nonneg
decl_stmt|;
if|if
condition|(
name|len
operator|<=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
block|{
comment|/* It's single precision. */
name|low
operator|=
operator|*
name|arg
expr_stmt|;
name|nonneg
operator|=
name|low
operator|>=
literal|0
expr_stmt|;
name|low
operator|&=
literal|0x7fffff
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* It's double precision. 	     Get the high and low words of the fraction. 	     Distinguish big and little-endian machines.  */
ifdef|#
directive|ifdef
name|WORDS_BIG_ENDIAN
name|low
operator|=
name|arg
index|[
literal|1
index|]
operator|,
name|high
operator|=
name|arg
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|low
operator|=
name|arg
index|[
literal|0
index|]
operator|,
name|high
operator|=
name|arg
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
name|nonneg
operator|=
name|high
operator|>=
literal|0
expr_stmt|;
name|high
operator|&=
literal|0xfffff
expr_stmt|;
block|}
if|if
condition|(
name|high
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"-NaN(0x%lx%.8lx)"
operator|+
name|nonneg
argument_list|,
name|high
argument_list|,
name|low
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"-NaN(0x%lx)"
operator|+
name|nonneg
argument_list|,
name|low
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|len
operator|<=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|?
literal|"%.6g"
else|:
literal|"%.17g"
argument_list|,
name|doub
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify default address for `x' command.    `info lines' uses this.  */
end_comment

begin_function
name|void
name|set_next_address
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|next_address
operator|=
name|addr
expr_stmt|;
comment|/* Make address available to the user as $_.  */
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_"
argument_list|)
argument_list|,
name|value_from_long
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Optionally print address ADDR symbolically as<SYMBOL+OFFSET> on STREAM. */
end_comment

begin_function
name|void
name|print_address_symbolic
parameter_list|(
name|addr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|name_location
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|find_pc_misc_function
argument_list|(
name|addr
argument_list|)
decl_stmt|;
comment|/* If nothing comes out, don't print anything symbolic.  */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return;
name|name_location
operator|=
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|address
expr_stmt|;
if|if
condition|(
name|addr
operator|-
name|name_location
condition|)
name|format
operator|=
literal|"<%s+%d>"
expr_stmt|;
else|else
name|format
operator|=
literal|"<%s>"
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|addr
operator|-
name|name_location
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print address ADDR symbolically on STREAM.    First print it as a number.  Then perhaps print<SYMBOL + OFFSET> after the number.  */
end_comment

begin_function
name|void
name|print_address
parameter_list|(
name|addr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|print_address_symbolic
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like print_address but opnly prints symbolically. */
end_comment

begin_function
name|void
name|print_formatted_address
parameter_list|(
name|addr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|format
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|fs
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|name_location
decl_stmt|;
name|i
operator|=
name|find_pc_partial_function
argument_list|(
name|addr
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|name_location
argument_list|)
expr_stmt|;
comment|/* If nothing comes out, don't print anything symbolic.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|-
name|name_location
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s+%d"
argument_list|,
name|name
argument_list|,
name|addr
operator|-
name|name_location
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Examine data at address ADDR in format FMT.    Fetch it from memory and print on stdout.  */
end_comment

begin_function
specifier|static
name|void
name|do_examine
parameter_list|(
name|fmt
parameter_list|,
name|addr
parameter_list|)
name|struct
name|format_data
name|fmt
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
specifier|register
name|char
name|format
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|size
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|1
decl_stmt|;
name|struct
name|type
modifier|*
name|val_type
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|maxelts
decl_stmt|;
name|format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
name|size
operator|=
name|fmt
operator|.
name|size
expr_stmt|;
name|count
operator|=
name|fmt
operator|.
name|count
expr_stmt|;
name|next_address
operator|=
name|addr
expr_stmt|;
comment|/* String or instruction format implies fetch single bytes      regardless of the specified size.  */
if|if
condition|(
name|format
operator|==
literal|'s'
operator|||
name|format
operator|==
literal|'i'
condition|)
name|size
operator|=
literal|'b'
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|'b'
condition|)
name|val_type
operator|=
name|builtin_type_char
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|'h'
condition|)
name|val_type
operator|=
name|builtin_type_short
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|'w'
condition|)
name|val_type
operator|=
name|builtin_type_long
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|'g'
condition|)
ifndef|#
directive|ifndef
name|LONG_LONG
name|val_type
operator|=
name|builtin_type_double
expr_stmt|;
else|#
directive|else
name|val_type
operator|=
name|builtin_type_long_long
expr_stmt|;
endif|#
directive|endif
name|maxelts
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|'w'
condition|)
name|maxelts
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|'g'
condition|)
name|maxelts
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|'s'
operator|||
name|format
operator|==
literal|'i'
condition|)
name|maxelts
operator|=
literal|1
expr_stmt|;
comment|/* Print as many objects as specified in COUNT, at most maxelts per line,      with the address of the next one at the start of each line.  */
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|print_address
argument_list|(
name|next_address
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|maxelts
init|;
name|i
operator|>
literal|0
operator|&&
name|count
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|count
operator|--
control|)
block|{
name|printf_filtered
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
comment|/* Note that print_formatted sets next_address for the next 	     object.  */
name|last_examine_address
operator|=
name|next_address
expr_stmt|;
name|last_examine_value
operator|=
name|value_at
argument_list|(
name|val_type
argument_list|,
name|next_address
argument_list|)
expr_stmt|;
name|print_formatted
argument_list|(
name|last_examine_value
argument_list|,
name|format
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|validate_format
parameter_list|(
name|fmt
parameter_list|,
name|cmdname
parameter_list|)
name|struct
name|format_data
name|fmt
decl_stmt|;
name|char
modifier|*
name|cmdname
decl_stmt|;
block|{
if|if
condition|(
name|fmt
operator|.
name|size
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Size letters are meaningless in \"%s\" command."
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|count
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Item count other than 1 is meaningless in \"%s\" command."
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|format
operator|==
literal|'i'
operator|||
name|fmt
operator|.
name|format
operator|==
literal|'s'
condition|)
name|error
argument_list|(
literal|"Format letter \"%c\" is meaningless in \"%s\" command."
argument_list|,
name|fmt
operator|.
name|format
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_command
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|format
init|=
literal|0
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
name|struct
name|format_data
name|fmt
decl_stmt|;
name|int
name|histindex
decl_stmt|;
name|int
name|cleanup
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
name|last_format
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_format
argument_list|(
name|fmt
argument_list|,
literal|"print"
argument_list|)
expr_stmt|;
name|last_format
operator|=
name|format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
condition|)
block|{
name|expr
operator|=
name|parse_c_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|cleanup
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|access_value_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|histindex
operator|=
name|record_latest_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|histindex
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"$%d = "
argument_list|,
name|histindex
argument_list|)
expr_stmt|;
name|print_formatted
argument_list|(
name|val
argument_list|,
name|format
argument_list|,
name|fmt
operator|.
name|size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup
condition|)
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_command
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
specifier|register
name|char
name|format
init|=
literal|0
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
name|struct
name|format_data
name|fmt
decl_stmt|;
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_format
argument_list|(
name|fmt
argument_list|,
literal|"print"
argument_list|)
expr_stmt|;
name|format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
block|}
name|expr
operator|=
name|parse_c_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|print_formatted
argument_list|(
name|val
argument_list|,
name|format
argument_list|,
name|fmt
operator|.
name|size
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_command
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
init|=
name|parse_c_expression
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
decl_stmt|;
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|address_info
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|CORE_ADDR
name|val
decl_stmt|;
name|int
name|is_a_field_of_this
decl_stmt|;
comment|/* C++: lookup_symbol sets this to nonzero 				   if exp is a field of `this'. */
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Argument required."
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|exp
argument_list|,
name|get_selected_block
argument_list|()
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|&
name|is_a_field_of_this
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|is_a_field_of_this
condition|)
block|{
name|printf
argument_list|(
literal|"Symbol \"%s\" is a field of the local class variable `this'\n"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|misc_function_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|exp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|misc_function_count
condition|)
name|printf
argument_list|(
literal|"Symbol \"%s\" is at 0x%x in a file compiled without -g.\n"
argument_list|,
name|exp
argument_list|,
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|address
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No symbol \"%s\" in current context."
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Symbol \"%s\" is "
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
case|case
name|LOC_CONST_BYTES
case|:
name|printf
argument_list|(
literal|"constant"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LABEL
case|:
name|printf
argument_list|(
literal|"a label at address 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
name|printf
argument_list|(
literal|"a variable in register %s"
argument_list|,
name|reg_names
index|[
name|val
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_STATIC
case|:
name|printf
argument_list|(
literal|"static at address 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM
case|:
name|printf
argument_list|(
literal|"an argument in register %s"
argument_list|,
name|reg_names
index|[
name|val
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
name|printf
argument_list|(
literal|"an argument at offset %d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
name|printf
argument_list|(
literal|"a local variable at frame offset %d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|printf
argument_list|(
literal|"a reference argument at offset %d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|printf
argument_list|(
literal|"a typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|printf
argument_list|(
literal|"a function at address 0x%x"
argument_list|,
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|x_command
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
name|struct
name|format_data
name|fmt
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|fmt
operator|.
name|format
operator|=
name|last_format
expr_stmt|;
name|fmt
operator|.
name|size
operator|=
name|last_size
expr_stmt|;
name|fmt
operator|.
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|exp
operator|&&
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
name|last_format
argument_list|,
name|last_size
argument_list|)
expr_stmt|;
name|last_size
operator|=
name|fmt
operator|.
name|size
expr_stmt|;
name|last_format
operator|=
name|fmt
operator|.
name|format
expr_stmt|;
block|}
comment|/* If we have an expression, evaluate it and use it as the address.  */
if|if
condition|(
name|exp
operator|!=
literal|0
operator|&&
operator|*
name|exp
operator|!=
literal|0
condition|)
block|{
name|expr
operator|=
name|parse_c_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Cause expression not to be there any more 	 if this command is repeated with Newline. 	 But don't clobber a user-defined command's definition.  */
if|if
condition|(
name|from_tty
condition|)
operator|*
name|exp
operator|=
literal|0
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_expression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* In rvalue contexts, such as this, functions are coerced into 	 pointers to functions.  This makes "x/i main" work.  */
if|if
condition|(
comment|/* last_format == 'i'&& */
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
operator|&&
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|==
name|lval_memory
condition|)
name|next_address
operator|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|next_address
operator|=
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|do_examine
argument_list|(
name|fmt
argument_list|,
name|next_address
argument_list|)
expr_stmt|;
comment|/* Set a couple of internal variables if appropriate. */
if|if
condition|(
name|last_examine_value
condition|)
block|{
comment|/* Make last address examined available to the user as $_.  */
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_"
argument_list|)
argument_list|,
name|value_from_long
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|last_examine_address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make contents of last address examined available to the user as $__.*/
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"__"
argument_list|)
argument_list|,
name|last_examine_value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Commands for printing types of things.  */
end_comment

begin_function
specifier|static
name|void
name|whatis_command
parameter_list|(
name|exp
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|exp
condition|)
block|{
name|expr
operator|=
name|parse_c_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|val
operator|=
name|evaluate_type
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|access_value_history
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"type = "
argument_list|)
expr_stmt|;
comment|/* Most of the time users do not want to see all the fields      in a structure.  If they do they can use the "ptype" command.      Hence the "-1" below.  */
name|type_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stdout
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ptype_command
parameter_list|(
name|typename
parameter_list|)
name|char
modifier|*
name|typename
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|typename
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|extern
name|struct
name|block
modifier|*
name|get_current_block
parameter_list|()
function_decl|;
specifier|register
name|struct
name|block
modifier|*
name|b
init|=
operator|(
name|have_inferior_p
argument_list|()
operator|||
name|have_core_file_p
argument_list|()
operator|)
condition|?
name|get_current_block
argument_list|()
else|:
literal|0
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|typename
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"type name"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|typename
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|6
operator|&&
operator|!
name|strncmp
argument_list|(
name|typename
argument_list|,
literal|"struct"
argument_list|,
literal|6
argument_list|)
condition|)
name|type
operator|=
name|lookup_struct
argument_list|(
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|5
operator|&&
operator|!
name|strncmp
argument_list|(
name|typename
argument_list|,
literal|"union"
argument_list|,
literal|5
argument_list|)
condition|)
name|type
operator|=
name|lookup_union
argument_list|(
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
name|typename
argument_list|,
literal|"enum"
argument_list|,
literal|4
argument_list|)
condition|)
name|type
operator|=
name|lookup_enum
argument_list|(
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|lookup_typename
argument_list|(
name|typename
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
name|lookup_symbol
argument_list|(
name|typename
argument_list|,
name|b
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No type named %s."
argument_list|,
name|typename
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"No type named %s, but there is a "
argument_list|,
name|typename
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
name|printf_filtered
argument_list|(
literal|"struct"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNION
case|:
name|printf_filtered
argument_list|(
literal|"union"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
name|printf_filtered
argument_list|(
literal|"enum"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|" %s.  Type \"help ptype\".\n"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stdout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_enum
enum|enum
name|display_status
block|{
name|disabled
block|,
name|enabled
block|}
enum|;
end_enum

begin_struct
struct|struct
name|display
block|{
comment|/* Chain link to next auto-display item.  */
name|struct
name|display
modifier|*
name|next
decl_stmt|;
comment|/* Expression to be evaluated and displayed.  */
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
comment|/* Item number of this auto-display item.  */
name|int
name|number
decl_stmt|;
comment|/* Display format specified.  */
name|struct
name|format_data
name|format
decl_stmt|;
comment|/* Innermost block required by this expression when evaluated */
name|struct
name|block
modifier|*
name|block
decl_stmt|;
comment|/* Status of this display (enabled or disabled) */
name|enum
name|display_status
name|status
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chain of expressions whose values should be displayed    automatically each time the program stops.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|display
modifier|*
name|display_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|display_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add an expression to the auto-display chain.    Specify the expression.  */
end_comment

begin_function
specifier|static
name|void
name|display_command
parameter_list|(
name|exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|format_data
name|fmt
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|expr
decl_stmt|;
specifier|register
name|struct
name|display
modifier|*
name|new
decl_stmt|;
specifier|extern
name|struct
name|block
modifier|*
name|innermost_block
decl_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
name|do_displays
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|exp
operator|==
literal|'/'
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|fmt
operator|=
name|decode_format
argument_list|(
operator|&
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|size
operator|&&
name|fmt
operator|.
name|format
operator|==
literal|0
condition|)
name|fmt
operator|.
name|format
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|format
operator|==
literal|'i'
operator|||
name|fmt
operator|.
name|format
operator|==
literal|'s'
condition|)
name|fmt
operator|.
name|size
operator|=
literal|'b'
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|.
name|format
operator|=
literal|0
expr_stmt|;
name|fmt
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|fmt
operator|.
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|innermost_block
operator|=
literal|0
expr_stmt|;
name|expr
operator|=
name|parse_c_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|display
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|display
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|exp
operator|=
name|expr
expr_stmt|;
name|new
operator|->
name|block
operator|=
name|innermost_block
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|display_chain
expr_stmt|;
name|new
operator|->
name|number
operator|=
operator|++
name|display_number
expr_stmt|;
name|new
operator|->
name|format
operator|=
name|fmt
expr_stmt|;
name|new
operator|->
name|status
operator|=
name|enabled
expr_stmt|;
name|display_chain
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|from_tty
operator|&&
name|have_inferior_p
argument_list|()
condition|)
name|do_one_display
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_display
parameter_list|(
name|d
parameter_list|)
name|struct
name|display
modifier|*
name|d
decl_stmt|;
block|{
name|free
argument_list|(
name|d
operator|->
name|exp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out the display_chain.    Done when new symtabs are loaded, since this invalidates    the types stored in many expressions.  */
end_comment

begin_function
name|void
name|clear_displays
parameter_list|()
block|{
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
while|while
condition|(
name|d
operator|=
name|display_chain
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|exp
argument_list|)
expr_stmt|;
name|display_chain
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete the auto-display number NUM.  */
end_comment

begin_function
name|void
name|delete_display
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|struct
name|display
modifier|*
name|d1
decl_stmt|,
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|display_chain
condition|)
name|error
argument_list|(
literal|"No display number %d."
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_chain
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d1
operator|=
name|display_chain
expr_stmt|;
name|display_chain
operator|=
name|d1
operator|->
name|next
expr_stmt|;
name|free_display
argument_list|(
name|d1
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|d
operator|=
name|display_chain
init|;
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|next
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No display number %d."
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|next
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d1
operator|=
name|d
operator|->
name|next
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|d1
operator|->
name|next
expr_stmt|;
name|free_display
argument_list|(
name|d1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete some values from the auto-display chain.    Specify the element numbers.  */
end_comment

begin_function
specifier|static
name|void
name|undisplay_command
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|,
modifier|*
name|d1
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"Delete all auto-display expressions? "
argument_list|)
condition|)
name|clear_displays
argument_list|()
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be display numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|delete_display
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display a single auto-display.      Do nothing if the display cannot be printed in the current context,    or if the display is disabled. */
end_comment

begin_function
specifier|static
name|void
name|do_one_display
parameter_list|(
name|d
parameter_list|)
name|struct
name|display
modifier|*
name|d
decl_stmt|;
block|{
name|int
name|within_current_scope
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|status
operator|==
name|disabled
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|block
condition|)
name|within_current_scope
operator|=
name|contained_in
argument_list|(
name|get_selected_block
argument_list|()
argument_list|,
name|d
operator|->
name|block
argument_list|)
expr_stmt|;
else|else
name|within_current_scope
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|within_current_scope
condition|)
return|return;
name|current_display_number
operator|=
name|d
operator|->
name|number
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d: "
argument_list|,
name|d
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|size
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"x/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|count
operator|!=
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"%d"
argument_list|,
name|d
operator|->
name|format
operator|.
name|count
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|format
operator|!=
literal|'i'
operator|&&
name|d
operator|->
name|format
operator|.
name|format
operator|!=
literal|'s'
condition|)
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|d
operator|->
name|format
operator|.
name|size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|count
operator|!=
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|do_examine
argument_list|(
name|d
operator|->
name|format
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|evaluate_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|format
condition|)
name|printf_filtered
argument_list|(
literal|"/%c "
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|print_formatted
argument_list|(
name|evaluate_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|)
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|,
name|d
operator|->
name|format
operator|.
name|size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|current_display_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display all of the values on the auto-display chain which can be    evaluated in the current scope.  */
end_comment

begin_function
name|void
name|do_displays
parameter_list|()
block|{
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|do_one_display
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete the auto-display which we were in the process of displaying.    This is done when there is an error or a signal.  */
end_comment

begin_function
name|void
name|disable_display
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|d
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d
operator|->
name|status
operator|=
name|disabled
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"No display number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|disable_current_display
parameter_list|()
block|{
if|if
condition|(
name|current_display_number
operator|>=
literal|0
condition|)
block|{
name|disable_display
argument_list|(
name|current_display_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Disabling display %d to avoid infinite recursion.\n"
argument_list|,
name|current_display_number
argument_list|)
expr_stmt|;
block|}
name|current_display_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|display_info
parameter_list|()
block|{
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|display_chain
condition|)
name|printf
argument_list|(
literal|"There are no auto-display expressions now.\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Auto-display expressions now in effect:\n\ Num Enb Expression\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%d:   %c  "
argument_list|,
name|d
operator|->
name|number
argument_list|,
literal|"ny"
index|[
operator|(
name|int
operator|)
name|d
operator|->
name|status
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|size
condition|)
name|printf_filtered
argument_list|(
literal|"/%d%c%c "
argument_list|,
name|d
operator|->
name|format
operator|.
name|count
argument_list|,
name|d
operator|->
name|format
operator|.
name|size
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|format
operator|.
name|format
condition|)
name|printf_filtered
argument_list|(
literal|"/%c "
argument_list|,
name|d
operator|->
name|format
operator|.
name|format
argument_list|)
expr_stmt|;
name|print_expression
argument_list|(
name|d
operator|->
name|exp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|block
operator|&&
operator|!
name|contained_in
argument_list|(
name|get_selected_block
argument_list|()
argument_list|,
name|d
operator|->
name|block
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|" (cannot be evaluated in the current context)"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|enable_display
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|d
operator|->
name|status
operator|=
name|enabled
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be display numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|d
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|d
operator|->
name|status
operator|=
name|enabled
expr_stmt|;
goto|goto
name|win
goto|;
block|}
name|printf
argument_list|(
literal|"No display number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|win
label|:
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|disable_display_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|struct
name|display
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|d
operator|=
name|display_chain
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
name|d
operator|->
name|status
operator|=
name|disabled
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be display numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|disable_display
argument_list|(
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the value in stack frame FRAME of a variable    specified by a struct symbol.  */
end_comment

begin_function
name|void
name|print_variable_value
parameter_list|(
name|var
parameter_list|,
name|frame
parameter_list|,
name|stream
parameter_list|)
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|value
name|val
init|=
name|read_var_value
argument_list|(
name|var
argument_list|,
name|frame
argument_list|)
decl_stmt|;
name|value_print
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_ints
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
name|int
modifier|*
name|i
decl_stmt|,
decl|*
name|j
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|*
name|i
operator|-
operator|*
name|j
return|;
block|}
end_block

begin_comment
comment|/* Print the arguments of a stack frame, given the function FUNC    running in that frame (as a symbol), the info on the frame,    and the number of args according to the stack frame (or -1 if unknown).  */
end_comment

begin_function_decl
specifier|static
name|void
name|print_frame_nameless_args
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|print_frame_args
parameter_list|(
name|func
parameter_list|,
name|fi
parameter_list|,
name|num
parameter_list|,
name|stream
parameter_list|)
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|num
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|last_regparm
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|lastsym
decl_stmt|,
modifier|*
name|sym
decl_stmt|,
modifier|*
name|nextsym
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
comment|/* Offset of stack argument that is at the highest offset.      -1 if we haven't come to a stack argument yet.  */
name|CORE_ADDR
name|highest_offset
init|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
decl_stmt|;
specifier|register
name|CORE_ADDR
name|addr
init|=
name|FRAME_ARGS_ADDRESS
argument_list|(
name|fi
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
condition|)
block|{
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REGPARM
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_ARG
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_REF_ARG
condition|)
continue|continue;
comment|/* Print the next arg.  */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGPARM
condition|)
name|val
operator|=
name|value_from_register
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|FRAME_INFO_ID
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|current_offset
init|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|int
name|arg_size
init|=
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REF_ARG
condition|)
name|val
operator|=
name|value_at
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|read_memory_integer
argument_list|(
name|addr
operator|+
name|current_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|value_at
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|addr
operator|+
name|current_offset
argument_list|)
expr_stmt|;
comment|/* Round up address of next arg to multiple of size of int.  */
name|current_offset
operator|=
operator|(
operator|(
operator|(
name|current_offset
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
expr_stmt|;
comment|/* If this is the highest offset seen yet, set highest_offset.  */
if|if
condition|(
name|highest_offset
operator|==
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
operator|||
operator|(
operator|(
name|current_offset
operator|+
operator|(
name|arg_size
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
literal|3
operator|)
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|)
operator|>
name|highest_offset
operator|)
condition|)
name|highest_offset
operator|=
name|current_offset
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"="
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Nonzero if a LOC_ARG which is a struct is useless.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|STRUCT_ARG_SYM_GARBAGE
argument_list|)
define|#
directive|define
name|STRUCT_ARG_SYM_GARBAGE
parameter_list|(
name|gcc_p
parameter_list|)
value|0
endif|#
directive|endif
if|if
condition|(
name|STRUCT_ARG_SYM_GARBAGE
argument_list|(
name|b
operator|->
name|gcc_compile_flag
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_ARG
condition|)
block|{
comment|/* Try looking up that name.  SunOS4 puts out a usable 	     symbol as a local variable (in addition to the one 	     for the arg).  */
name|struct
name|symbol
modifier|*
name|sym2
init|=
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|b
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym2
operator|!=
name|NULL
condition|)
name|val
operator|=
name|value_of_variable
argument_list|(
name|sym2
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs_filtered
argument_list|(
literal|"?"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
name|value_print
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Don't print nameless args in situations where we don't know      enough about the stack to find them.  */
if|if
condition|(
name|num
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|highest_offset
operator|!=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
operator|&&
name|num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|FRAME_ARGS_SKIP
operator|>
name|highest_offset
condition|)
name|print_frame_nameless_args
argument_list|(
name|fi
argument_list|,
name|addr
argument_list|,
name|highest_offset
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|FRAME_ARGS_SKIP
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|print_frame_nameless_args
argument_list|(
name|fi
argument_list|,
name|addr
argument_list|,
name|FRAME_ARGS_SKIP
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|FRAME_ARGS_SKIP
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_frame_nameless_args
parameter_list|(
name|fi
parameter_list|,
name|argsaddr
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|stream
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|CORE_ADDR
name|argsaddr
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|extern
name|void
function_decl|(
modifier|*
name|default_scalar_print
function_decl|)
parameter_list|()
function_decl|;
name|LONGEST
name|v
decl_stmt|;
name|int
name|p
init|=
name|start
decl_stmt|;
name|char
modifier|*
name|s
init|=
literal|""
decl_stmt|;
for|for
control|(
name|p
operator|=
name|start
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|QUIT
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NAMELESS_ARG
argument_list|)
name|v
operator|=
name|NAMELESS_ARG
argument_list|(
name|fi
argument_list|,
operator|(
name|p
operator|-
name|start
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|v
operator|=
name|read_memory_integer
argument_list|(
name|argsaddr
operator|+
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
literal|", "
expr_stmt|;
call|(
modifier|*
name|default_scalar_print
call|)
argument_list|(
name|stream
argument_list|,
name|builtin_type_int
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|printf_command
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|value
modifier|*
name|val_args
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
name|int
name|allocated_args
init|=
literal|20
decl_stmt|;
name|char
modifier|*
name|arg_bytes
decl_stmt|;
name|val_args
operator|=
operator|(
name|value
operator|*
operator|)
name|xmalloc
argument_list|(
name|allocated_args
operator|*
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"format-control string and values to print"
argument_list|)
expr_stmt|;
comment|/* Skip white space before format string */
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* A format string should follow, enveloped in double quotes */
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'"'
condition|)
name|error
argument_list|(
literal|"Bad format string, missing '\"'."
argument_list|)
expr_stmt|;
comment|/* Parse the format-control string and copy it into the string STRING,      processing some kinds of escape sequence.  */
name|f
operator|=
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'"'
condition|)
block|{
name|int
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
name|error
argument_list|(
literal|"Bad format string, non-terminated '\"'."
argument_list|)
expr_stmt|;
comment|/* doesn't return */
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|f
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
operator|*
name|f
operator|++
operator|=
literal|'"'
expr_stmt|;
break|break;
default|default:
comment|/* ??? TODO: handle other escape sequences */
name|error
argument_list|(
literal|"Unrecognized \\ escape character in format string."
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
operator|*
name|f
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* Skip over " and following space and comma.  */
name|s
operator|++
expr_stmt|;
operator|*
name|f
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
name|s
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid argument syntax"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
block|{
comment|/* Now scan the string for %-specs and see what kinds of args they want.        argclass[I] classifies the %-specs so we can give vprintf something        of the right size.  */
enum|enum
name|argclass
block|{
name|int_arg
block|,
name|string_arg
block|,
name|double_arg
block|,
name|long_long_arg
block|}
enum|;
name|enum
name|argclass
modifier|*
name|argclass
decl_stmt|;
name|int
name|nargs_wanted
decl_stmt|;
name|int
name|argindex
decl_stmt|;
name|int
name|lcount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|argclass
operator|=
operator|(
expr|enum
name|argclass
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|argclass
argument_list|)
expr_stmt|;
name|nargs_wanted
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|f
condition|)
if|if
condition|(
operator|*
name|f
operator|++
operator|==
literal|'%'
condition|)
block|{
name|lcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|index
argument_list|(
literal|"0123456789.hlL-+ #"
argument_list|,
operator|*
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|f
operator|==
literal|'l'
operator|||
operator|*
name|f
operator|==
literal|'L'
condition|)
name|lcount
operator|++
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|f
operator|==
literal|'s'
condition|)
name|argclass
index|[
name|nargs_wanted
operator|++
index|]
operator|=
name|string_arg
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|f
operator|==
literal|'e'
operator|||
operator|*
name|f
operator|==
literal|'f'
operator|||
operator|*
name|f
operator|==
literal|'g'
condition|)
name|argclass
index|[
name|nargs_wanted
operator|++
index|]
operator|=
name|double_arg
expr_stmt|;
elseif|else
if|if
condition|(
name|lcount
operator|>
literal|1
condition|)
name|argclass
index|[
name|nargs_wanted
operator|++
index|]
operator|=
name|long_long_arg
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|f
operator|!=
literal|'%'
condition|)
name|argclass
index|[
name|nargs_wanted
operator|++
index|]
operator|=
name|int_arg
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
comment|/* Now, parse all arguments and evaluate them.        Store the VALUEs in VAL_ARGS.  */
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
if|if
condition|(
name|nargs
operator|==
name|allocated_args
condition|)
name|val_args
operator|=
operator|(
name|value
operator|*
operator|)
name|xrealloc
argument_list|(
name|val_args
argument_list|,
operator|(
name|allocated_args
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
name|val_args
index|[
name|nargs
index|]
operator|=
name|parse_to_comma_and_eval
argument_list|(
operator|&
name|s1
argument_list|)
expr_stmt|;
comment|/* If format string wants a float, unchecked-convert the value to 	   floating point of the same size */
if|if
condition|(
name|argclass
index|[
name|nargs
index|]
operator|==
name|double_arg
condition|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val_args
index|[
name|nargs
index|]
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
name|VALUE_TYPE
argument_list|(
name|val_args
index|[
name|nargs
index|]
argument_list|)
operator|=
name|builtin_type_float
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val_args
index|[
name|nargs
index|]
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|VALUE_TYPE
argument_list|(
name|val_args
index|[
name|nargs
index|]
argument_list|)
operator|=
name|builtin_type_double
expr_stmt|;
block|}
name|nargs
operator|++
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nargs
operator|!=
name|nargs_wanted
condition|)
name|error
argument_list|(
literal|"Wrong number of arguments for specified format-string"
argument_list|)
expr_stmt|;
comment|/* Now lay out an argument-list containing the arguments        as doubles, integers and C pointers.  */
name|arg_bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
name|argindex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argclass
index|[
name|i
index|]
operator|==
name|string_arg
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|tem
decl_stmt|,
name|j
decl_stmt|;
name|tem
operator|=
name|value_as_long
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* This is a %s argument.  Find the length of the string.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
name|char
name|c
decl_stmt|;
name|QUIT
expr_stmt|;
name|read_memory
argument_list|(
name|tem
operator|+
name|j
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Copy the string contents into a string inside GDB.  */
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|tem
argument_list|,
name|str
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|str
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Pass address of internal copy as the arg to vprintf.  */
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|arg_bytes
index|[
name|argindex
index|]
operator|)
operator|=
operator|(
name|int
operator|)
name|str
expr_stmt|;
name|argindex
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VALUE_TYPE
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
operator|->
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
operator|&
name|arg_bytes
index|[
name|argindex
index|]
operator|)
operator|=
name|value_as_double
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|argindex
operator|+=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|LONG_LONG
if|if
condition|(
name|argclass
index|[
name|i
index|]
operator|==
name|long_long_arg
condition|)
block|{
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|&
name|arg_bytes
index|[
name|argindex
index|]
operator|=
name|value_as_long
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|argindex
operator|+=
expr|sizeof
operator|(
name|long
name|long
operator|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|arg_bytes
index|[
name|argindex
index|]
operator|)
operator|=
name|value_as_long
argument_list|(
name|val_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|argindex
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|vprintf
argument_list|(
name|string
argument_list|,
name|arg_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for asdump_command.  Finds the bounds of a function    for a specified section of text.  PC is an address within the    function which you want bounds for; *LOW and *HIGH are set to the    beginning (inclusive) and end (exclusive) of the function.  This    function returns 1 on success and 0 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|containing_function_bounds
parameter_list|(
name|pc
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|,
decl|*
name|low
decl_stmt|,
modifier|*
name|high
decl_stmt|;
end_function

begin_block
block|{
name|int
name|scan
decl_stmt|;
if|if
condition|(
operator|!
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|low
argument_list|)
condition|)
return|return
literal|0
return|;
name|scan
operator|=
operator|*
name|low
expr_stmt|;
do|do
block|{
name|scan
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|find_pc_partial_function
argument_list|(
name|scan
argument_list|,
literal|0
argument_list|,
name|high
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
do|while
condition|(
operator|*
name|low
operator|==
operator|*
name|high
condition|)
do|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Dump a specified section of assembly code.  With no command line    arguments, this command will dump the assembly code for the    function surrounding the pc value in the selected frame.  With one    argument, it will dump the assembly code surrounding that pc value.    Two arguments are interpeted as bounds within which to dump    assembly.  */
end_comment

begin_function
specifier|static
name|void
name|disassemble_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|CORE_ADDR
name|low
decl_stmt|,
name|high
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|char
modifier|*
name|space_index
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
block|{
if|if
condition|(
operator|!
name|selected_frame
condition|)
name|error
argument_list|(
literal|"No frame selected.\n"
argument_list|)
expr_stmt|;
name|pc
operator|=
name|get_frame_pc
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|containing_function_bounds
argument_list|(
name|pc
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
condition|)
name|error
argument_list|(
literal|"No function contains pc specified by selected frame.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|space_index
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|arg
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
block|{
comment|/* One argument.  */
name|pc
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|containing_function_bounds
argument_list|(
name|pc
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
condition|)
name|error
argument_list|(
literal|"No function contains specified pc.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Two arguments.  */
operator|*
name|space_index
operator|=
literal|'\0'
expr_stmt|;
name|low
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|high
operator|=
name|parse_and_eval_address
argument_list|(
name|space_index
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Dump of assembler code "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|space_index
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"for function %s:\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"from 0x%x to 0x%x:\n"
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
comment|/* Dump the specified range.  */
for|for
control|(
name|pc
operator|=
name|low
init|;
name|pc
operator|<
name|high
condition|;
control|)
block|{
name|QUIT
expr_stmt|;
name|print_address
argument_list|(
name|pc
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":\t"
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|print_insn
argument_list|(
name|pc
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"End of assembler dump.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|enablelist
decl_stmt|,
modifier|*
name|disablelist
decl_stmt|,
modifier|*
name|deletelist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|,
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_printcmd
parameter_list|()
block|{
name|current_display_number
operator|=
operator|-
literal|1
expr_stmt|;
name|add_info
argument_list|(
literal|"address"
argument_list|,
name|address_info
argument_list|,
literal|"Describe where variable VAR is stored."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"x"
argument_list|,
name|class_vars
argument_list|,
name|x_command
argument_list|,
literal|"Examine memory: x/FMT ADDRESS.\n\ ADDRESS is an expression for the memory address to examine.\n\ FMT is a repeat count followed by a format letter and a size letter.\n\ Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),\n\  f(float), a(address), i(instruction), c(char) and s(string).\n\ Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).\n\   g is meaningful only with f, for type double.\n\ The specified number of objects of the specified size are printed\n\ according to the format.\n\n\ Defaults for format and size letters are those previously used.\n\ Default count is 1.  Default address is following last thing printed\n\ with this command or \"print\"."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"disassemble"
argument_list|,
name|class_vars
argument_list|,
name|disassemble_command
argument_list|,
literal|"Disassemble a specified section of memory.\n\ Default is the function surrounding the pc of the selected frame.\n\ With a single argument, the function surrounding that address is dumped.\n\ Two arguments are taken as a range of memory to dump."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"ptype"
argument_list|,
name|class_vars
argument_list|,
name|ptype_command
argument_list|,
literal|"Print definition of type TYPE.\n\ Argument may be a type name defined by typedef, or \"struct STRUCTNAME\"\n\ or \"union UNIONNAME\" or \"enum ENUMNAME\".\n\ The selected stack frame's lexical context is used to look up the name."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"whatis"
argument_list|,
name|class_vars
argument_list|,
name|whatis_command
argument_list|,
literal|"Print data type of expression EXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"display"
argument_list|,
name|display_info
argument_list|,
literal|"Expressions to display when program stops, with code numbers."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"undisplay"
argument_list|,
name|class_vars
argument_list|,
name|undisplay_command
argument_list|,
literal|"Cancel some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to stop displaying.\n\ No argument means cancel all automatic-display expressions.\n\ \"delete display\" has the same effect as this command.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|display_command
argument_list|,
literal|"Print value of expression EXP each time the program stops.\n\ /FMT may be used before EXP as in the \"print\" command.\n\ /FMT \"i\" or \"s\" or including a size-letter is allowed,\n\ as in the \"x\" command, and then EXP is used to get the address to examine\n\ and examining is done as in the \"x\" command.\n\n\ With no argument, display all currently requested auto-display expressions.\n\ Use \"undisplay\" to cancel display requests previously made."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|enable_display
argument_list|,
literal|"Enable some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to resume displaying.\n\ No argument means enable all automatic-display expressions.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|disable_display_command
argument_list|,
literal|"Disable some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to stop displaying.\n\ No argument means disable all automatic-display expressions.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|disablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"display"
argument_list|,
name|class_vars
argument_list|,
name|undisplay_command
argument_list|,
literal|"Cancel some expressions to be displayed when program stops.\n\ Arguments are the code numbers of the expressions to stop displaying.\n\ No argument means cancel all automatic-display expressions.\n\ Do \"info display\" to see current list of code numbers."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"printf"
argument_list|,
name|class_vars
argument_list|,
name|printf_command
argument_list|,
literal|"printf \"printf format string\", arg1, arg2, arg3, ..., argn\n\ This is useful for formatted output in user-defined commands."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"output"
argument_list|,
name|class_vars
argument_list|,
name|output_command
argument_list|,
literal|"Like \"print\" but don't put in value history and don't print newline.\n\ This is useful in user-defined commands."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"set"
argument_list|,
name|class_vars
argument_list|,
name|set_command
argument_list|,
literal|"Perform an assignment VAR = EXP.\n\ You must type the \"=\".  VAR may be a debugger \"convenience\" variable\n\ (names starting with $), a register (a few standard names starting with $),\n\ or an actual variable in the program being debugged.  EXP is any expression.\n\ Use \"set variable\" for variables with names identical to set subcommands.\n\ \nWith a subcommand, this command modifies parts of the gdb environment"
argument_list|,
operator|&
name|setlist
argument_list|,
literal|"set "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"variable"
argument_list|,
name|class_vars
argument_list|,
name|set_command
argument_list|,
literal|"Perform an assignment VAR = EXP.\n\ You must type the \"=\".  VAR may be a debugger \"convenience\" variable\n\ (names starting with $), a register (a few standard names starting with $),\n\ or an actual variable in the program being debugged.  EXP is any expression.\n\ This may usually be abbreviated to simply \"set\"."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"print"
argument_list|,
name|class_vars
argument_list|,
name|print_command
argument_list|,
name|concat
argument_list|(
literal|"Print value of expression EXP.\n\ Variables accessible are those of the lexical environment of the selected\n\ stack frame, plus all those whose scope is global or an entire file.\n\ \n\ $NUM gets previous value number NUM.  $ and $$ are the last two values.\n\ $$NUM refers to NUM'th value back from the last one.\n\ Names starting with $ refer to registers (with the values they would have\n\ if the program were to return to the stack frame now selected, restoring\n\ all registers saved by frames farther in) or else to debugger\n\ \"convenience\" variables (any such name not a known register).\n\ Use assignment expressions to give values to convenience variables.\n"
argument_list|,
literal|"\n\ \{TYPE}ADREXP refers to a datum of data type TYPE, located at address ADREXP.\n\ @ is a binary operator for treating consecutive data objects\n\ anywhere in memory as an array.  FOO@NUM gives an array whose first\n\ element is FOO, whose second element is stored in the space following\n\ where FOO is stored, etc.  FOO must be an expression whose value\n\ resides in memory.\n"
argument_list|,
literal|"\n\ EXP may be preceded with /FMT, where FMT is a format letter\n\ but no count or size letter (see \"x\" command)."
argument_list|)
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"p"
argument_list|,
literal|"print"
argument_list|,
name|class_vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

