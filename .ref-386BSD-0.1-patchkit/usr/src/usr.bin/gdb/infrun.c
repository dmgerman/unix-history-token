begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)infrun.c	6.4 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Start and stop the inferior process, for GDB.    Copyright (C) 1986, 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Notes on the algorithm used in wait_for_inferior to determine if we    just did a subroutine call when stepping.  We have the following    information at that point:                    Current and previous (just before this step) pc. 		  Current and previous sp. 		  Current and previous start of current function.     If the start's of the functions don't match, then     	a) We did a subroutine call.     In this case, the pc will be at the beginning of a function.  	b) We did a subroutine return.     Otherwise.  	c) We did a longjmp.     If we did a longjump, we were doing "nexti", since a next would    have attempted to skip over the assembly language routine in which    the longjmp is coded and would have simply been the equivalent of a    continue.  I consider this ok behaivior.  We'd like one of two    things to happen if we are doing a nexti through the longjmp()    routine: 1) It behaves as a stepi, or 2) It acts like a continue as    above.  Given that this is a special case, and that anybody who    thinks that the concept of sub calls is meaningful in the context    of a longjmp, I'll take either one.  Let's see what happens.       Acts like a subroutine return.  I can handle that with no problem    at all.     -->So: If the current and previous beginnings of the current    function don't match, *and* the pc is at the start of a function,    we've done a subroutine call.  If the pc is not at the start of a    function, we *didn't* do a subroutine call.       -->If the beginnings of the current and previous function do match,    either:      	a) We just did a recursive call.  	   In this case, we would be at the very beginning of a 	   function and 1) it will have a prologue (don't jump to 	   before prologue, or 2) (we assume here that it doesn't have 	   a prologue) there will have been a change in the stack 	   pointer over the last instruction.  (Ie. it's got to put 	   the saved pc somewhere.  The stack is the usual place.  In 	   a recursive call a register is only an option if there's a 	   prologue to do something with it.  This is even true on 	   register window machines; the prologue sets up the new 	   window.  It might not be true on a register window machine 	   where the call instruction moved the register window 	   itself.  Hmmm.  One would hope that the stack pointer would 	   also change.  If it doesn't, somebody send me a note, and 	   I'll work out a more general theory. 	   randy@wheaties.ai.mit.edu).  This is true (albeit slipperly 	   so) on all machines I'm aware of:  	      m68k:	Call changes stack pointer.  Regular jumps don't.  	      sparc:	Recursive calls must have frames and therefor, 	                prologues.  	      vax:	All calls have frames and hence change the 	                stack pointer.  	b) We did a return from a recursive call.  I don't see that we 	   have either the ability or the need to distinguish this 	   from an ordinary jump.  The stack frame will be printed 	   when and if the frame pointer changes; if we are in a 	   function without a frame pointer, it's the users own 	   lookout.  	c) We did a jump within a function.  We assume that this is 	   true if we didn't do a recursive call.  	d) We are in no-man's land ("I see no symbols here").  We 	   don't worry about this; it will make calls look like simple 	   jumps (and the stack frames will be printed when the frame 	   pointer moves), which is a reasonably non-violent response.  #if 0     We skip this; it causes more problems than it's worth. #ifdef SUN4_COMPILER_FEATURE     We do a special ifdef for the sun 4, forcing it to single step   into calls which don't have prologues.  This means that we can't   nexti over leaf nodes, we can probably next over them (since they   won't have debugging symbols, usually), and we can next out of   functions returning structures (with a "call .stret4" at the end). #endif #endif */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* unistd.h is needed to #define X_OK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UMAX_PTRACE
end_ifdef

begin_include
include|#
directive|include
file|<aouthdr.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UMAX_PTRACE */
end_comment

begin_comment
comment|/* Required by<sys/user.h>.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* Required by<sys/user.h>, at least on system V.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_comment
comment|/* Needed by IN_SIGTRAMP on some machines (e.g. vax).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* Needed by IN_SIGTRAMP on some machines (e.g. vax).  */
end_comment

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sigtramp is a routine that the kernel calls (which then calls the    signal handler).  On most machines it is a library routine that    is linked into the executable.     This macro, given a program counter value and the name of the    function in which that PC resides (which can be null if the    name is not known), returns nonzero if the PC and name show    that we are in sigtramp.     On most machines just see if the name is sigtramp (and if we have    no name, assume we are not in sigtramp).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IN_SIGTRAMP
argument_list|)
end_if

begin_define
define|#
directive|define
name|IN_SIGTRAMP
parameter_list|(
name|pc
parameter_list|,
name|name
parameter_list|)
define|\
value|name&& !strcmp ("_sigtramp", name)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Tables of how to react to signals; the user sets them.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|signal_stop
index|[
name|NSIG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|signal_print
index|[
name|NSIG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|signal_program
index|[
name|NSIG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if breakpoints are now inserted in the inferior.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoints_inserted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function inferior was in as of last step command.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|step_start_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the sequence of bytes we insert for a breakpoint.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|break_insn
index|[]
init|=
name|BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero => address for special breakpoint for resuming stepping.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|step_resume_break_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Original contents of the byte where the special breakpoint is.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|step_resume_break_shadow
index|[
sizeof|sizeof
name|break_insn
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means the special breakpoint is a duplicate    so it has not itself been inserted.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|step_resume_break_duplicate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are expecting a trace trap and should proceed from it.    2 means expecting 2 trace traps and should continue both times.    That occurs when we tell sh to exec the program: we will get    a trap after the exec of sh and a second when the program is exec'd.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trap_expected
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the next time we try to continue the inferior, it will    step one instruction and generate a spurious trace trap.    This is used to compensate for a bug in HP-UX.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trap_expected_after_continue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means expecting a trace trap    and should stop the inferior and return silently when it happens.  */
end_comment

begin_decl_stmt
name|int
name|stop_after_trap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means expecting a trace trap due to attaching to a process.  */
end_comment

begin_decl_stmt
name|int
name|stop_after_attach
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if pc has been changed by the debugger    since the inferior stopped.  */
end_comment

begin_decl_stmt
name|int
name|pc_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if debugging a remote machine via a serial link or ethernet.  */
end_comment

begin_decl_stmt
name|int
name|remote_debugging
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if program stopped due to error trying to insert breakpoints.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoints_failed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if inferior is in sh before our program got exec'd.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|running_in_shell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero after stop if current stack frame should be printed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_print_frame
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|one_stepped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From machine dependent code */
end_comment

begin_function_decl
specifier|extern
name|void
name|single_step
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Same. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_SINGLE_STEP */
end_comment

begin_function_decl
specifier|static
name|void
name|insert_step_breakpoint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_step_breakpoint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wait_for_inferior
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|normal_stop
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Clear out all variables saying what to do when inferior is continued.    First do this, then set the ones you want, then call `proceed'.  */
end_comment

begin_function
name|void
name|clear_proceed_status
parameter_list|()
block|{
name|trap_expected
operator|=
literal|0
expr_stmt|;
name|step_range_start
operator|=
literal|0
expr_stmt|;
name|step_range_end
operator|=
literal|0
expr_stmt|;
name|step_frame_address
operator|=
literal|0
expr_stmt|;
name|step_over_calls
operator|=
operator|-
literal|1
expr_stmt|;
name|step_resume_break_address
operator|=
literal|0
expr_stmt|;
name|stop_after_trap
operator|=
literal|0
expr_stmt|;
name|stop_after_attach
operator|=
literal|0
expr_stmt|;
comment|/* Discard any remaining commands left by breakpoint we had stopped at.  */
name|clear_breakpoint_commands
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Basic routine for continuing the program in various fashions.     ADDR is the address to resume at, or -1 for resume where stopped.    SIGNAL is the signal to give it, or 0 for none,      or -1 for act according to how it stopped.    STEP is nonzero if should trap after one instruction.      -1 means return after that and print nothing.      You should probably set various step_... variables      before calling here, if you are stepping.     You should call clear_proceed_status before calling proceed.  */
end_comment

begin_function
name|void
name|proceed
parameter_list|(
name|addr
parameter_list|,
name|signal
parameter_list|,
name|step
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|signal
decl_stmt|;
name|int
name|step
decl_stmt|;
block|{
name|int
name|oneproc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|step
operator|>
literal|0
condition|)
name|step_start_function
operator|=
name|find_pc_function
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|<
literal|0
condition|)
name|stop_after_trap
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* If there is a breakpoint at the address we will resume at, 	 step one instruction before inserting breakpoints 	 so that we do not stop right away.  */
if|if
condition|(
operator|!
name|pc_changed
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|oneproc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NPC_REGNUM
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
name|addr
operator|+
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|trap_expected_after_continue
condition|)
block|{
comment|/* If (step == 0), a trap will be automatically generated after 	 the first instruction is executed.  Force step one 	 instruction to clear this condition.  This should not occur 	 if step is nonzero, but it is harmless in that case.  */
name|oneproc
operator|=
literal|1
expr_stmt|;
name|trap_expected_after_continue
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|oneproc
condition|)
comment|/* We will get a trace trap after one instruction.        Continue it automatically and insert breakpoints then.  */
name|trap_expected
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|temp
init|=
name|insert_breakpoints
argument_list|()
decl_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"ptrace"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Cannot insert breakpoints.\n\ The same program may be running in another process."
argument_list|)
expr_stmt|;
block|}
name|breakpoints_inserted
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Install inferior's terminal modes.  */
name|terminal_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|signal
operator|>=
literal|0
condition|)
name|stop_signal
operator|=
name|signal
expr_stmt|;
comment|/* If this signal should not be seen by program,      give it zero.  Used for debugging signals.  */
elseif|else
if|if
condition|(
name|stop_signal
operator|<
name|NSIG
operator|&&
operator|!
name|signal_program
index|[
name|stop_signal
index|]
condition|)
name|stop_signal
operator|=
literal|0
expr_stmt|;
comment|/* Resume inferior.  */
name|resume
argument_list|(
name|oneproc
operator|||
name|step
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
comment|/* Wait for it to stop (if not standalone)      and in any case decode why it stopped, and act accordingly.  */
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Writing the inferior pc as a register calls this function    to inform infrun that the pc has been set in the debugger.  */
end_comment

begin_function
name|void
name|writing_pc
parameter_list|(
name|val
parameter_list|)
name|CORE_ADDR
name|val
decl_stmt|;
block|{
name|stop_pc
operator|=
name|val
expr_stmt|;
name|pc_changed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an inferior process for the first time.    Actually it was started by the fork that created it,    but it will have stopped one instruction after execing sh.    Here we must get it up to actual execution of the real program.  */
end_comment

begin_function
name|void
name|start_inferior
parameter_list|()
block|{
comment|/* We will get a trace trap after one instruction.      Continue it automatically.  Eventually (after shell does an exec)      it will get another trace trap.  Then insert breakpoints and continue.  */
ifdef|#
directive|ifdef
name|START_INFERIOR_TRAPS_EXPECTED
name|trap_expected
operator|=
name|START_INFERIOR_TRAPS_EXPECTED
expr_stmt|;
else|#
directive|else
name|trap_expected
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
name|running_in_shell
operator|=
literal|0
expr_stmt|;
comment|/* Set to 1 at first SIGTRAP, 0 at second.  */
name|trap_expected_after_continue
operator|=
literal|0
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|mark_breakpoints_out
argument_list|()
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|terminal_init_inferior
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|terminal_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
block|{
name|trap_expected
operator|=
literal|0
expr_stmt|;
name|fetch_inferior_registers
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|stop_frame_address
operator|=
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|insert_breakpoints
argument_list|()
condition|)
name|fatal
argument_list|(
literal|"Can't insert breakpoints"
argument_list|)
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|1
expr_stmt|;
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Start or restart remote-debugging of a machine over a serial link.  */
end_comment

begin_function
name|void
name|restart_remote
parameter_list|()
block|{
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|running_in_shell
operator|=
literal|0
expr_stmt|;
name|trap_expected
operator|=
literal|0
expr_stmt|;
name|stop_after_attach
operator|=
literal|1
expr_stmt|;
name|inferior_pid
operator|=
literal|3
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|start_remote
parameter_list|()
block|{
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|mark_breakpoints_out
argument_list|()
expr_stmt|;
name|restart_remote
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATTACH_DETACH
end_ifdef

begin_comment
comment|/* Attach to process PID, then initialize for debugging it    and wait for the trace-trap that results from attaching.  */
end_comment

begin_function
name|void
name|attach_program
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|mark_breakpoints_out
argument_list|()
expr_stmt|;
name|terminal_init_inferior
argument_list|()
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_after_attach
operator|=
literal|1
expr_stmt|;
comment|/*proceed (-1, 0, -2);*/
name|terminal_inferior
argument_list|()
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTACH_DETACH */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Wait for control to return from inferior to debugger.    If inferior gets a signal, we may decide to start it up again    instead of returning.  That is why there is a loop in this function.    When this function actually returns it means the inferior    should be left stopped and GDB should read more commands.  */
end_comment

begin_function
specifier|static
name|void
name|wait_for_inferior
parameter_list|()
block|{
specifier|register
name|int
name|pid
decl_stmt|;
name|WAITTYPE
name|w
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|int
name|another_trap
decl_stmt|;
name|int
name|random_signal
decl_stmt|;
name|CORE_ADDR
name|stop_sp
decl_stmt|,
name|prev_sp
decl_stmt|;
name|CORE_ADDR
name|prev_func_start
decl_stmt|,
name|stop_func_start
decl_stmt|;
name|char
modifier|*
name|prev_func_name
decl_stmt|,
modifier|*
name|stop_func_name
decl_stmt|;
name|CORE_ADDR
name|prologue_pc
decl_stmt|;
name|int
name|stop_step_resume_break
decl_stmt|;
name|CORE_ADDR
name|step_resume_break_sp
decl_stmt|;
name|int
name|newmisc
decl_stmt|;
name|int
name|newfun_pc
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|int
name|prev_pc
decl_stmt|;
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
name|int
name|remove_breakpoints_on_following_step
init|=
literal|0
decl_stmt|;
name|prev_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|find_pc_partial_function
argument_list|(
name|prev_pc
argument_list|,
operator|&
name|prev_func_name
argument_list|,
operator|&
name|prev_func_start
argument_list|)
expr_stmt|;
name|prev_func_start
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|prev_sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Clean up saved state that will become invalid.  */
name|pc_changed
operator|=
literal|0
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
name|remote_wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
else|else
block|{
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
continue|continue;
block|}
comment|/* See if the process still exists; clean up if it doesn't.  */
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|terminal_ours_for_output
argument_list|()
expr_stmt|;
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\nProgram exited with code 0%o.\n"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\nProgram exited normally.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|inferior_died
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
name|one_stepped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|kill_inferior
argument_list|()
expr_stmt|;
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
name|stop_signal
operator|=
name|WTERMSIG
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\nProgram terminated with signal %d, %s\n"
argument_list|,
name|stop_signal
argument_list|,
name|stop_signal
operator|<
name|NSIG
condition|?
name|sys_siglist
index|[
name|stop_signal
index|]
else|:
literal|"(undocumented)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The inferior process no longer exists.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
name|one_stepped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
if|if
condition|(
name|one_stepped
condition|)
name|single_step
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This actually cleans up the ss */
endif|#
directive|endif
comment|/* NO_SINGLE_STEP */
name|fetch_inferior_registers
argument_list|()
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|stop_frame_address
operator|=
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|stop_sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|stop_func_start
operator|=
literal|0
expr_stmt|;
name|stop_func_name
operator|=
literal|0
expr_stmt|;
comment|/* Don't care about return value; stop_func_start and stop_func_name 	 will both be 0 if it doesn't work.  */
operator|(
name|void
operator|)
name|find_pc_partial_function
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|stop_func_name
argument_list|,
operator|&
name|stop_func_start
argument_list|)
expr_stmt|;
name|stop_func_start
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|another_trap
operator|=
literal|0
expr_stmt|;
name|stop_breakpoint
operator|=
literal|0
expr_stmt|;
name|stop_step
operator|=
literal|0
expr_stmt|;
name|stop_stack_dummy
operator|=
literal|0
expr_stmt|;
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
name|stop_step_resume_break
operator|=
literal|0
expr_stmt|;
name|random_signal
operator|=
literal|0
expr_stmt|;
name|stopped_by_random_signal
operator|=
literal|0
expr_stmt|;
name|breakpoints_failed
operator|=
literal|0
expr_stmt|;
comment|/* Look at the cause of the stop, and decide what to do. 	 The alternatives are: 	 1) break; to really stop and return to the debugger, 	 2) drop through to start up again 	 (set another_trap to 1 to single step once) 	 3) set random_signal to 1, and the decision between 1 and 2 	 will be made according to the signal handling tables.  */
name|stop_signal
operator|=
name|WSTOPSIG
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* First, distinguish signals caused by the debugger from signals 	 that have to do with the program's own actions. 	 Note that breakpoint insns may cause SIGTRAP or SIGILL 	 or SIGEMT, depending on the operating system version. 	 Here we detect when a SIGILL or SIGEMT is really a breakpoint 	 and change it to SIGTRAP.  */
if|if
condition|(
name|stop_signal
operator|==
name|SIGTRAP
operator|||
operator|(
name|breakpoints_inserted
operator|&&
operator|(
name|stop_signal
operator|==
name|SIGILL
operator|||
name|stop_signal
operator|==
name|SIGEMT
operator|)
operator|)
operator|||
name|stop_after_attach
condition|)
block|{
if|if
condition|(
name|stop_signal
operator|==
name|SIGTRAP
operator|&&
name|stop_after_trap
condition|)
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stop_after_attach
condition|)
break|break;
comment|/* Don't even think about breakpoints 	     if still running the shell that will exec the program 	     or if just proceeded over a breakpoint.  */
if|if
condition|(
name|stop_signal
operator|==
name|SIGTRAP
operator|&&
name|trap_expected
condition|)
name|stop_breakpoint
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* See if there is a breakpoint at the current PC.  */
if|#
directive|if
name|DECR_PC_AFTER_BREAK
comment|/* Notice the case of stepping through a jump 		 that leads just after a breakpoint. 		 Don't confuse that with hitting the breakpoint. 		 What we check for is that 1) stepping is going on 		 and 2) the pc before the last insn does not match 		 the address of the breakpoint before the current pc.  */
if|if
condition|(
operator|!
operator|(
name|prev_pc
operator|!=
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
operator|&&
name|step_range_end
operator|&&
operator|!
name|step_resume_break_address
operator|)
condition|)
endif|#
directive|endif
comment|/* DECR_PC_AFTER_BREAK not zero */
block|{
comment|/* See if we stopped at the special breakpoint for 		     stepping over a subroutine call.  */
if|if
condition|(
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
operator|==
name|step_resume_break_address
condition|)
block|{
name|stop_step_resume_break
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECR_PC_AFTER_BREAK
condition|)
block|{
name|stop_pc
operator|-=
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|stop_pc
argument_list|)
expr_stmt|;
name|pc_changed
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|stop_breakpoint
operator|=
name|breakpoint_stop_status
argument_list|(
name|stop_pc
argument_list|,
name|stop_frame_address
argument_list|)
expr_stmt|;
comment|/* Following in case break condition called a 			 function.  */
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stop_breakpoint
operator|&&
name|DECR_PC_AFTER_BREAK
condition|)
block|{
name|stop_pc
operator|-=
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|stop_pc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NPC_REGNUM
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
name|stop_pc
operator|+
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pc_changed
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|stop_signal
operator|==
name|SIGTRAP
condition|)
name|random_signal
operator|=
operator|!
operator|(
name|stop_breakpoint
operator|||
name|trap_expected
operator|||
name|stop_step_resume_break
ifndef|#
directive|ifndef
name|CANNOT_EXECUTE_STACK
operator|||
operator|(
name|stop_sp
name|INNER_THAN
name|stop_pc
operator|&&
name|stop_pc
name|INNER_THAN
name|stop_frame_address
operator|)
else|#
directive|else
operator|||
name|stop_pc
operator|==
name|text_end
operator|-
literal|2
endif|#
directive|endif
operator|||
operator|(
name|step_range_end
operator|&&
operator|!
name|step_resume_break_address
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|random_signal
operator|=
operator|!
operator|(
name|stop_breakpoint
operator|||
name|stop_step_resume_break
ifdef|#
directive|ifdef
name|sony_news
operator|||
operator|(
name|stop_sp
name|INNER_THAN
name|stop_pc
operator|&&
name|stop_pc
name|INNER_THAN
name|stop_frame_address
operator|)
endif|#
directive|endif
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|random_signal
condition|)
name|stop_signal
operator|=
name|SIGTRAP
expr_stmt|;
block|}
block|}
else|else
name|random_signal
operator|=
literal|1
expr_stmt|;
comment|/* For the program's own signals, act according to 	 the signal handling tables.  */
if|if
condition|(
name|random_signal
operator|&&
operator|!
operator|(
name|running_in_shell
operator|&&
name|stop_signal
operator|==
name|SIGSEGV
operator|)
condition|)
block|{
comment|/* Signal not for debugging purposes.  */
name|int
name|printed
init|=
literal|0
decl_stmt|;
name|stopped_by_random_signal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stop_signal
operator|>=
name|NSIG
operator|||
name|signal_print
index|[
name|stop_signal
index|]
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\nProgram received signal %d, %s\n"
argument_list|,
name|stop_signal
argument_list|,
name|stop_signal
operator|<
name|NSIG
condition|?
name|sys_siglist
index|[
name|stop_signal
index|]
else|:
literal|"(undocumented)"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stop_signal
operator|>=
name|NSIG
operator|||
name|signal_stop
index|[
name|stop_signal
index|]
condition|)
break|break;
comment|/* If not going to stop, give terminal back 	     if we took it away.  */
elseif|else
if|if
condition|(
name|printed
condition|)
name|terminal_inferior
argument_list|()
expr_stmt|;
block|}
comment|/* Handle cases caused by hitting a breakpoint.  */
if|if
condition|(
operator|!
name|random_signal
operator|&&
operator|(
name|stop_breakpoint
operator|||
name|stop_step_resume_break
operator|)
condition|)
block|{
comment|/* Does a breakpoint want us to stop?  */
if|if
condition|(
name|stop_breakpoint
operator|&&
name|stop_breakpoint
operator|!=
operator|-
literal|1
operator|&&
name|stop_breakpoint
operator|!=
operator|-
literal|0x1000001
condition|)
block|{
comment|/* 0x1000000 is set in stop_breakpoint as returned by 		 breakpoint_stop_status to indicate a silent 		 breakpoint.  */
if|if
condition|(
operator|(
name|stop_breakpoint
operator|>
literal|0
condition|?
name|stop_breakpoint
else|:
operator|-
name|stop_breakpoint
operator|)
operator|&
literal|0x1000000
condition|)
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stop_breakpoint
operator|>
literal|0
condition|)
name|stop_breakpoint
operator|-=
literal|0x1000000
expr_stmt|;
else|else
name|stop_breakpoint
operator|+=
literal|0x1000000
expr_stmt|;
block|}
break|break;
block|}
comment|/* But if we have hit the step-resumption breakpoint, 	     remove it.  It has done its job getting us here. 	     The sp test is to make sure that we don't get hung 	     up in recursive calls in functions without frame 	     pointers.  If the stack pointer isn't outside of 	     where the breakpoint was set (within a routine to be 	     stepped over), we're in the middle of a recursive 	     call. Not true for reg window machines (sparc) 	     because the must change frames to call things and 	     the stack pointer doesn't have to change if it 	     the bp was set in a routine without a frame (pc can 	     be stored in some other window). 	      	     The removal of the sp test is to allow calls to 	     alloca.  Nasty things were happening.  Oh, well, 	     gdb can only handle one level deep of lack of 	     frame pointer. */
if|if
condition|(
name|stop_step_resume_break
operator|&&
operator|(
name|step_frame_address
operator|==
literal|0
operator|||
operator|(
name|stop_frame_address
operator|==
name|step_frame_address
operator|)
operator|)
condition|)
block|{
name|remove_step_breakpoint
argument_list|()
expr_stmt|;
name|step_resume_break_address
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Otherwise, must remove breakpoints and single-step 	     to get us past the one we hit.  */
else|else
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|remove_step_breakpoint
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|another_trap
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We come here if we hit a breakpoint but should not 	     stop for it.  Possibly we also were stepping 	     and should stop for that.  So fall through and 	     test for stepping.  But, if not stepping, 	     do not stop.  */
block|}
comment|/* If this is the breakpoint at the end of a stack dummy, 	 just stop silently.  */
ifndef|#
directive|ifndef
name|CANNOT_EXECUTE_STACK
if|if
condition|(
name|stop_sp
name|INNER_THAN
name|stop_pc
operator|&&
name|stop_pc
name|INNER_THAN
name|stop_frame_address
condition|)
else|#
directive|else
if|if
condition|(
name|stop_pc
operator|==
name|text_end
operator|-
literal|2
condition|)
endif|#
directive|endif
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
name|stop_stack_dummy
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_OS_BUG
name|trap_expected_after_continue
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|step_resume_break_address
condition|)
comment|/* Having a step-resume breakpoint overrides anything 	   else having to do with stepping commands until 	   that breakpoint is reached.  */
empty_stmt|;
comment|/* If stepping through a line, keep going if still within it.  */
elseif|else
if|if
condition|(
operator|!
name|random_signal
operator|&&
name|step_range_end
operator|&&
name|stop_pc
operator|>=
name|step_range_start
operator|&&
name|stop_pc
operator|<
name|step_range_end
comment|/* The step range might include the start of the 		  function, so if we are at the start of the 		  step range and either the stack or frame pointers 		  just changed, we've stepped outside */
operator|&&
operator|!
operator|(
name|stop_pc
operator|==
name|step_range_start
operator|&&
name|stop_frame_address
operator|&&
operator|(
name|stop_sp
name|INNER_THAN
name|prev_sp
operator|||
name|stop_frame_address
operator|!=
name|step_frame_address
operator|)
operator|)
condition|)
block|{
comment|/* Don't step through the return from a function 	     unless that is the first instruction stepped through.  */
if|if
condition|(
name|ABOUT_TO_RETURN
argument_list|(
name|stop_pc
argument_list|)
condition|)
block|{
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* We stepped out of the stepping range.  See if that was due 	 to a subroutine call that we should proceed to the end of.  */
elseif|else
if|if
condition|(
operator|!
name|random_signal
operator|&&
name|step_range_end
condition|)
block|{
if|if
condition|(
name|stop_func_start
condition|)
block|{
name|prologue_pc
operator|=
name|stop_func_start
expr_stmt|;
name|SKIP_PROLOGUE
argument_list|(
name|prologue_pc
argument_list|)
expr_stmt|;
block|}
comment|/* Did we just take a signal?  */
if|if
condition|(
name|IN_SIGTRAMP
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
operator|&&
operator|!
name|IN_SIGTRAMP
argument_list|(
name|prev_pc
argument_list|,
name|prev_func_name
argument_list|)
condition|)
block|{
comment|/* This code is needed at least in the following case: 		 The user types "next" and then a signal arrives (before 		 the "next" is done).  */
comment|/* We've just taken a signal; go until we are back to 		 the point where we took it and one more.  */
name|step_resume_break_address
operator|=
name|prev_pc
expr_stmt|;
name|step_resume_break_duplicate
operator|=
name|breakpoint_here_p
argument_list|(
name|step_resume_break_address
argument_list|)
expr_stmt|;
name|step_resume_break_sp
operator|=
name|stop_sp
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_step_breakpoint
argument_list|()
expr_stmt|;
comment|/* Make sure that the stepping range gets us past 		 that instruction.  */
if|if
condition|(
name|step_range_end
operator|==
literal|1
condition|)
name|step_range_end
operator|=
operator|(
name|step_range_start
operator|=
name|prev_pc
operator|)
operator|+
literal|1
expr_stmt|;
name|remove_breakpoints_on_following_step
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ==> See comments at top of file on this algorithm.<==*/
elseif|else
if|if
condition|(
name|stop_pc
operator|==
name|stop_func_start
operator|&&
operator|(
name|stop_func_start
operator|!=
name|prev_func_start
operator|||
name|prologue_pc
operator|!=
name|stop_func_start
operator|||
name|stop_sp
operator|!=
name|prev_sp
operator|)
condition|)
block|{
comment|/* It's a subroutine call */
if|if
condition|(
name|step_over_calls
operator|>
literal|0
operator|||
operator|(
name|step_over_calls
operator|&&
name|find_pc_function
argument_list|(
name|stop_pc
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* A subroutine call has happened.  */
comment|/* Set a special breakpoint after the return */
name|step_resume_break_address
operator|=
name|SAVED_PC_AFTER_CALL
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|step_resume_break_duplicate
operator|=
name|breakpoint_here_p
argument_list|(
name|step_resume_break_address
argument_list|)
expr_stmt|;
name|step_resume_break_sp
operator|=
name|stop_sp
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_step_breakpoint
argument_list|()
expr_stmt|;
block|}
comment|/* Subroutine call with source code we should not step over. 		 Do step to the first line of code in it.  */
elseif|else
if|if
condition|(
name|step_over_calls
condition|)
block|{
name|SKIP_PROLOGUE
argument_list|(
name|stop_func_start
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|stop_func_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use the step_resume_break to step until 		     the end of the prologue, even if that involves jumps 		     (as it seems to on the vax under 4.2).  */
comment|/* If the prologue ends in the middle of a source line, 		     continue to the end of that source line. 		     Otherwise, just go to end of prologue.  */
ifdef|#
directive|ifdef
name|PROLOGUE_FIRSTLINE_OVERLAP
comment|/* no, don't either.  It skips any code that's 		     legitimately on the first line.  */
else|#
directive|else
if|if
condition|(
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|pc
operator|!=
name|stop_func_start
condition|)
name|stop_func_start
operator|=
name|sal
operator|.
name|end
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stop_func_start
operator|==
name|stop_pc
condition|)
block|{
comment|/* We are already there: stop now.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
comment|/* Put the step-breakpoint there and go until there. */
block|{
name|step_resume_break_address
operator|=
name|stop_func_start
expr_stmt|;
name|step_resume_break_sp
operator|=
name|stop_sp
expr_stmt|;
name|step_resume_break_duplicate
operator|=
name|breakpoint_here_p
argument_list|(
name|step_resume_break_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_step_breakpoint
argument_list|()
expr_stmt|;
comment|/* Do not specify what the fp should be when we stop 			 since on some machines the prologue 			 is where the new fp value is established.  */
name|step_frame_address
operator|=
literal|0
expr_stmt|;
comment|/* And make sure stepping stops right away then.  */
name|step_range_end
operator|=
name|step_range_start
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We get here only if step_over_calls is 0 and we 		     just stepped into a subroutine.  I presume 		     that step_over_calls is only 0 when we're 		     supposed to be stepping at the assembly 		     language level.*/
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* No subroutince call; stop now.  */
else|else
block|{
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Save the pc before execution, to compare with pc after stop.  */
name|prev_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
comment|/* Might have been DECR_AFTER_BREAK */
name|prev_func_start
operator|=
name|stop_func_start
expr_stmt|;
comment|/* Ok, since if DECR_PC_AFTER 					  BREAK is defined, the 					  original pc would not have 					  been at the start of a 					  function. */
name|prev_func_name
operator|=
name|stop_func_name
expr_stmt|;
name|prev_sp
operator|=
name|stop_sp
expr_stmt|;
comment|/* If we did not do break;, it means we should keep 	 running the inferior and not return to debugger.  */
comment|/* If trap_expected is 2, it means continue once more 	 and insert breakpoints at the next trap. 	 If trap_expected is 1 and the signal was SIGSEGV, it means 	 the shell is doing some memory allocation--just resume it 	 with SIGSEGV. 	 Otherwise insert breakpoints now, and possibly single step.  */
if|if
condition|(
name|trap_expected
operator|>
literal|1
condition|)
block|{
name|trap_expected
operator|--
expr_stmt|;
name|running_in_shell
operator|=
literal|1
expr_stmt|;
name|resume
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|running_in_shell
operator|&&
name|stop_signal
operator|==
name|SIGSEGV
condition|)
block|{
name|resume
argument_list|(
literal|0
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trap_expected
operator|&&
name|stop_signal
operator|!=
name|SIGTRAP
condition|)
block|{
comment|/* We took a signal which we are supposed to pass through to 	     the inferior and we haven't yet gotten our trap.  Simply 	     continue.  */
name|resume
argument_list|(
operator|(
name|step_range_end
operator|&&
operator|!
name|step_resume_break_address
operator|)
operator|||
name|trap_expected
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here, we are not awaiting another exec to get 	     the program we really want to debug. 	     Insert breakpoints now, unless we are trying 	     to one-proceed past a breakpoint.  */
name|running_in_shell
operator|=
literal|0
expr_stmt|;
comment|/* If we've just finished a special step resume and we don't 	     want to hit a breakpoint, pull em out.  */
if|if
condition|(
operator|!
name|step_resume_break_address
operator|&&
name|remove_breakpoints_on_following_step
condition|)
block|{
name|remove_breakpoints_on_following_step
operator|=
literal|0
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|breakpoints_inserted
operator|&&
operator|!
name|another_trap
condition|)
block|{
name|insert_step_breakpoint
argument_list|()
expr_stmt|;
name|breakpoints_failed
operator|=
name|insert_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|breakpoints_failed
condition|)
break|break;
name|breakpoints_inserted
operator|=
literal|1
expr_stmt|;
block|}
name|trap_expected
operator|=
name|another_trap
expr_stmt|;
if|if
condition|(
name|stop_signal
operator|==
name|SIGTRAP
condition|)
name|stop_signal
operator|=
literal|0
expr_stmt|;
name|resume
argument_list|(
operator|(
name|step_range_end
operator|&&
operator|!
name|step_resume_break_address
operator|)
operator|||
name|trap_expected
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here to return control to GDB when the inferior stops for real.    Print appropriate messages, remove breakpoints, give terminal our modes.     RUNNING_IN_SHELL nonzero means the shell got a signal before    exec'ing the program we wanted to run.    STOP_PRINT_FRAME nonzero means print the executing frame    (pc, function, args, file, line number and line text).    BREAKPOINTS_FAILED nonzero means stop was due to error    attempting to insert breakpoints.  */
end_comment

begin_function
specifier|static
name|void
name|normal_stop
parameter_list|()
block|{
comment|/* Make sure that the current_frame's pc is correct.  This      is a correction for setting up the frame info before doing      DECR_PC_AFTER_BREAK */
if|if
condition|(
name|inferior_pid
condition|)
operator|(
name|get_current_frame
argument_list|()
operator|)
operator|->
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
if|if
condition|(
name|breakpoints_failed
condition|)
block|{
name|terminal_ours_for_output
argument_list|()
expr_stmt|;
name|print_sys_errmsg
argument_list|(
literal|"ptrace"
argument_list|,
name|breakpoints_failed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Stopped; cannot insert breakpoints.\n\ The same program may be running in another process.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inferior_pid
condition|)
name|remove_step_breakpoint
argument_list|()
expr_stmt|;
if|if
condition|(
name|inferior_pid
operator|&&
name|breakpoints_inserted
condition|)
if|if
condition|(
name|remove_breakpoints
argument_list|()
condition|)
block|{
name|terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Cannot remove breakpoints because program is no longer writable.\n\ It must be running in another process.\n\ Further execution is probably impossible.\n"
argument_list|)
expr_stmt|;
block|}
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
comment|/* Delete the breakpoint we stopped at, if it wants to be deleted.      Delete any breakpoint that is to be deleted at the next stop.  */
name|breakpoint_auto_delete
argument_list|(
name|stop_breakpoint
argument_list|)
expr_stmt|;
comment|/* If an auto-display called a function and that got a signal,      delete that auto-display to avoid an infinite recursion.  */
if|if
condition|(
name|stopped_by_random_signal
condition|)
name|disable_current_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|step_multi
operator|&&
name|stop_step
condition|)
return|return;
name|terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|running_in_shell
condition|)
block|{
if|if
condition|(
name|stop_signal
operator|==
name|SIGSEGV
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|access
argument_list|(
name|exec_file
argument_list|,
name|X_OK
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"The file \"%s\" is not executable.\n"
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
else|else
comment|/* I don't think we should ever get here. 	       wait_for_inferior now ignores SIGSEGV's which happen in 	       the shell (since the Bourne shell (/bin/sh) has some 	       rather, er, uh, *unorthodox* memory management 	       involving catching SIGSEGV).  */
name|printf
argument_list|(
literal|"\ You have just encountered a bug in \"sh\".  GDB starts your program\n\ by running \"sh\" with a command to exec your program.\n\ This is so that \"sh\" will process wildcards and I/O redirection.\n\ This time, \"sh\" crashed.\n\ \n\ One known bug in \"sh\" bites when the environment takes up a lot of space.\n\ Try \"info env\" to see the environment; then use \"delete env\" to kill\n\ some variables whose values are large; then do \"run\" again.\n\ \n\ If that works, you might want to put those \"delete env\" commands\n\ into a \".gdbinit\" file in this directory so they will happen every time.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Don't confuse user with his program's symbols on sh's data.  */
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
comment|/* Select innermost stack frame except on return from a stack dummy routine,      or if the program has exited.  */
if|if
condition|(
operator|!
name|stop_stack_dummy
condition|)
block|{
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_print_frame
condition|)
block|{
if|if
condition|(
name|stop_breakpoint
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\nBpt %d, "
argument_list|,
name|stop_breakpoint
argument_list|)
expr_stmt|;
name|print_sel_frame
argument_list|(
name|stop_step
operator|&&
name|step_frame_address
operator|==
name|stop_frame_address
operator|&&
name|step_start_function
operator|==
name|find_pc_function
argument_list|(
name|stop_pc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Display the auto-display expressions.  */
name|do_displays
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stop_stack_dummy
condition|)
block|{
comment|/* Pop the empty frame that contains the stack dummy.          POP_FRAME ends with a setting of the current frame, so we 	 can use that next. */
ifndef|#
directive|ifndef
name|NEW_CALL_FUNCTION
name|POP_FRAME
expr_stmt|;
endif|#
directive|endif
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|insert_step_breakpoint
parameter_list|()
block|{
if|if
condition|(
name|step_resume_break_address
operator|&&
operator|!
name|step_resume_break_duplicate
condition|)
block|{
name|read_memory
argument_list|(
name|step_resume_break_address
argument_list|,
name|step_resume_break_shadow
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|step_resume_break_address
argument_list|,
name|break_insn
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remove_step_breakpoint
parameter_list|()
block|{
if|if
condition|(
name|step_resume_break_address
operator|&&
operator|!
name|step_resume_break_duplicate
condition|)
name|write_memory
argument_list|(
name|step_resume_break_address
argument_list|,
name|step_resume_break_shadow
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Specify how various signals in the inferior should be handled.  */
end_comment

begin_function
specifier|static
name|void
name|handle_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|int
name|signum
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|digits
decl_stmt|,
name|wordlen
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"signal to handle"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
comment|/* Find the end of the next word in the args.  */
for|for
control|(
name|wordlen
operator|=
literal|0
init|;
name|p
index|[
name|wordlen
index|]
operator|&&
name|p
index|[
name|wordlen
index|]
operator|!=
literal|' '
operator|&&
name|p
index|[
name|wordlen
index|]
operator|!=
literal|'\t'
condition|;
name|wordlen
operator|++
control|)
empty_stmt|;
for|for
control|(
name|digits
operator|=
literal|0
init|;
name|p
index|[
name|digits
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
name|digits
index|]
operator|<=
literal|'9'
condition|;
name|digits
operator|++
control|)
empty_stmt|;
comment|/* If it is all digits, it is signal number to operate on.  */
if|if
condition|(
name|digits
operator|==
name|wordlen
condition|)
block|{
name|signum
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|signum
operator|<=
literal|0
operator|||
name|signum
operator|>=
name|NSIG
condition|)
block|{
name|p
index|[
name|wordlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"Invalid signal %s given as argument to \"handle\"."
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signum
operator|==
name|SIGTRAP
operator|||
name|signum
operator|==
name|SIGINT
condition|)
block|{
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Signal %d is used by the debugger.\nAre you sure you want to change it? "
argument_list|,
name|signum
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|signum
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"First argument is not a signal number."
argument_list|)
expr_stmt|;
comment|/* Else, if already got a signal number, look for flag words 	 saying what to do for it.  */
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"stop"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|signal_stop
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
name|signal_print
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"print"
argument_list|,
name|wordlen
argument_list|)
condition|)
name|signal_print
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"pass"
argument_list|,
name|wordlen
argument_list|)
condition|)
name|signal_program
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"ignore"
argument_list|,
name|wordlen
argument_list|)
condition|)
name|signal_program
index|[
name|signum
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"nostop"
argument_list|,
name|wordlen
argument_list|)
condition|)
name|signal_stop
index|[
name|signum
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"noprint"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|signal_print
index|[
name|signum
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|signum
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"nopass"
argument_list|,
name|wordlen
argument_list|)
condition|)
name|signal_program
index|[
name|signum
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"noignore"
argument_list|,
name|wordlen
argument_list|)
condition|)
name|signal_program
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Not a number and not a recognized flag word => complain.  */
else|else
block|{
name|p
index|[
name|wordlen
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"Unrecognized flag word: \"%s\"."
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Find start of next word.  */
name|p
operator|+=
name|wordlen
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
block|{
comment|/* Show the results.  */
name|printf
argument_list|(
literal|"Number\tStop\tPrint\tPass to program\tDescription\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d\t"
argument_list|,
name|signum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_stop
index|[
name|signum
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_print
index|[
name|signum
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\t\t"
argument_list|,
name|signal_program
index|[
name|signum
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sys_siglist
index|[
name|signum
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print current contents of the tables set by the handle command.  */
end_comment

begin_function
specifier|static
name|void
name|signals_info
parameter_list|(
name|signum_exp
parameter_list|)
name|char
modifier|*
name|signum_exp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"Number\tStop\tPrint\tPass to program\tDescription\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|signum_exp
condition|)
block|{
name|i
operator|=
name|parse_and_eval_address
argument_list|(
name|signum_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|NSIG
operator|||
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Signal number out of bounds."
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d\t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_stop
index|[
name|i
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_print
index|[
name|i
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t\t"
argument_list|,
name|signal_program
index|[
name|i
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|sys_siglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d\t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_stop
index|[
name|i
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_print
index|[
name|i
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t\t"
argument_list|,
name|signal_program
index|[
name|i
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|sys_siglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\nUse the \"handle\" command to change these tables.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save all of the information associated with the inferior<==>gdb    connection.  INF_STATUS is a pointer to a "struct inferior_status"    (defined in inferior.h).  */
end_comment

begin_function_decl
name|struct
name|command_line
modifier|*
name|get_breakpoint_commands
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|save_inferior_status
parameter_list|(
name|inf_status
parameter_list|,
name|restore_stack_info
parameter_list|)
name|struct
name|inferior_status
modifier|*
name|inf_status
decl_stmt|;
name|int
name|restore_stack_info
decl_stmt|;
block|{
name|inf_status
operator|->
name|pc_changed
operator|=
name|pc_changed
expr_stmt|;
name|inf_status
operator|->
name|stop_signal
operator|=
name|stop_signal
expr_stmt|;
name|inf_status
operator|->
name|stop_pc
operator|=
name|stop_pc
expr_stmt|;
name|inf_status
operator|->
name|stop_frame_address
operator|=
name|stop_frame_address
expr_stmt|;
name|inf_status
operator|->
name|stop_breakpoint
operator|=
name|stop_breakpoint
expr_stmt|;
name|inf_status
operator|->
name|stop_step
operator|=
name|stop_step
expr_stmt|;
name|inf_status
operator|->
name|stop_stack_dummy
operator|=
name|stop_stack_dummy
expr_stmt|;
name|inf_status
operator|->
name|stopped_by_random_signal
operator|=
name|stopped_by_random_signal
expr_stmt|;
name|inf_status
operator|->
name|trap_expected
operator|=
name|trap_expected
expr_stmt|;
name|inf_status
operator|->
name|step_range_start
operator|=
name|step_range_start
expr_stmt|;
name|inf_status
operator|->
name|step_range_end
operator|=
name|step_range_end
expr_stmt|;
name|inf_status
operator|->
name|step_frame_address
operator|=
name|step_frame_address
expr_stmt|;
name|inf_status
operator|->
name|step_over_calls
operator|=
name|step_over_calls
expr_stmt|;
name|inf_status
operator|->
name|step_resume_break_address
operator|=
name|step_resume_break_address
expr_stmt|;
name|inf_status
operator|->
name|stop_after_trap
operator|=
name|stop_after_trap
expr_stmt|;
name|inf_status
operator|->
name|stop_after_attach
operator|=
name|stop_after_attach
expr_stmt|;
name|inf_status
operator|->
name|breakpoint_commands
operator|=
name|get_breakpoint_commands
argument_list|()
expr_stmt|;
name|inf_status
operator|->
name|restore_stack_info
operator|=
name|restore_stack_info
expr_stmt|;
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|inf_status
operator|->
name|register_context
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|record_selected_frame
argument_list|(
operator|&
operator|(
name|inf_status
operator|->
name|selected_frame_address
operator|)
argument_list|,
operator|&
operator|(
name|inf_status
operator|->
name|selected_level
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|restore_inferior_status
parameter_list|(
name|inf_status
parameter_list|)
name|struct
name|inferior_status
modifier|*
name|inf_status
decl_stmt|;
block|{
name|FRAME
name|fid
decl_stmt|;
name|int
name|level
init|=
name|inf_status
operator|->
name|selected_level
decl_stmt|;
name|pc_changed
operator|=
name|inf_status
operator|->
name|pc_changed
expr_stmt|;
name|stop_signal
operator|=
name|inf_status
operator|->
name|stop_signal
expr_stmt|;
name|stop_pc
operator|=
name|inf_status
operator|->
name|stop_pc
expr_stmt|;
name|stop_frame_address
operator|=
name|inf_status
operator|->
name|stop_frame_address
expr_stmt|;
name|stop_breakpoint
operator|=
name|inf_status
operator|->
name|stop_breakpoint
expr_stmt|;
name|stop_step
operator|=
name|inf_status
operator|->
name|stop_step
expr_stmt|;
name|stop_stack_dummy
operator|=
name|inf_status
operator|->
name|stop_stack_dummy
expr_stmt|;
name|stopped_by_random_signal
operator|=
name|inf_status
operator|->
name|stopped_by_random_signal
expr_stmt|;
name|trap_expected
operator|=
name|inf_status
operator|->
name|trap_expected
expr_stmt|;
name|step_range_start
operator|=
name|inf_status
operator|->
name|step_range_start
expr_stmt|;
name|step_range_end
operator|=
name|inf_status
operator|->
name|step_range_end
expr_stmt|;
name|step_frame_address
operator|=
name|inf_status
operator|->
name|step_frame_address
expr_stmt|;
name|step_over_calls
operator|=
name|inf_status
operator|->
name|step_over_calls
expr_stmt|;
name|step_resume_break_address
operator|=
name|inf_status
operator|->
name|step_resume_break_address
expr_stmt|;
name|stop_after_trap
operator|=
name|inf_status
operator|->
name|stop_after_trap
expr_stmt|;
name|stop_after_attach
operator|=
name|inf_status
operator|->
name|stop_after_attach
expr_stmt|;
name|set_breakpoint_commands
argument_list|(
name|inf_status
operator|->
name|breakpoint_commands
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
literal|0
argument_list|,
name|inf_status
operator|->
name|register_context
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* The inferior can be gone if the user types "print exit(0)"      (and perhaps other times).  */
if|if
condition|(
name|have_inferior_p
argument_list|()
operator|&&
name|inf_status
operator|->
name|restore_stack_info
condition|)
block|{
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fid
operator|=
name|find_relative_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
operator|&
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|fid
operator|==
literal|0
operator|||
name|FRAME_FP
argument_list|(
name|fid
argument_list|)
operator|!=
name|inf_status
operator|->
name|selected_frame_address
operator|||
name|level
operator|!=
literal|0
condition|)
block|{
comment|/* I'm not sure this error message is a good idea.  I have 	     only seen it occur after "Can't continue previously 	     requested operation" (we get called from do_cleanups), in 	     which case it just adds insult to injury (one confusing 	     error message after another.  Besides which, does the 	     user really care if we can't restore the previously 	     selected frame?  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to restore previously selected frame.\n"
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|select_frame
argument_list|(
name|fid
argument_list|,
name|inf_status
operator|->
name|selected_level
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_infrun
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|add_info
argument_list|(
literal|"signals"
argument_list|,
name|signals_info
argument_list|,
literal|"What debugger does when program gets various signals.\n\ Specify a signal number as argument to print info on that signal only."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"handle"
argument_list|,
name|class_run
argument_list|,
name|handle_command
argument_list|,
literal|"Specify how to handle a signal.\n\ Args are signal number followed by flags.\n\ Flags allowed are \"stop\", \"print\", \"pass\",\n\  \"nostop\", \"noprint\" or \"nopass\".\n\ Print means print a message if this signal happens.\n\ Stop means reenter debugger if this signal happens (implies print).\n\ Pass means let program see this signal; otherwise program doesn't know.\n\ Pass and Stop may be combined."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
block|{
name|signal_stop
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|signal_print
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|signal_program
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Signals caused by debugger's own actions      should not be given to the program afterwards.  */
name|signal_program
index|[
name|SIGTRAP
index|]
operator|=
literal|0
expr_stmt|;
name|signal_program
index|[
name|SIGINT
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Signals that are not errors should not normally enter the debugger.  */
ifdef|#
directive|ifdef
name|SIGALRM
name|signal_stop
index|[
name|SIGALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGALRM
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGALRM */
ifdef|#
directive|ifdef
name|SIGVTALRM
name|signal_stop
index|[
name|SIGVTALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGVTALRM
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGVTALRM */
ifdef|#
directive|ifdef
name|SIGPROF
name|signal_stop
index|[
name|SIGPROF
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGPROF
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGPROF */
ifdef|#
directive|ifdef
name|SIGCHLD
name|signal_stop
index|[
name|SIGCHLD
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGCHLD
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGCHLD */
ifdef|#
directive|ifdef
name|SIGCLD
name|signal_stop
index|[
name|SIGCLD
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGCLD
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGCLD */
ifdef|#
directive|ifdef
name|SIGIO
name|signal_stop
index|[
name|SIGIO
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGIO
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGIO */
ifdef|#
directive|ifdef
name|SIGURG
name|signal_stop
index|[
name|SIGURG
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|SIGURG
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SIGURG */
block|}
end_function

end_unit

