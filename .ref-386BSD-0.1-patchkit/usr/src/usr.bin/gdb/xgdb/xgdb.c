begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  *  * static char rcsid[] = "$Header: xgdb.c,v 1.9 90/12/16 16:01:05 van Exp $";  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)xgdb.c	6.3 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Interface from GDB to X windows. Copyright (C) 1987 Free Software  * Foundation, Inc.  *   * GDB is distributed in the hope that it will be useful, but WITHOUT ANY  * WARRANTY.  No author or distributor accepts responsibility to anyone for  * the consequences of using it or for whether it serves any particular  * purpose or works at all, unless he says so in writing. Refer to the GDB  * General Public License for full details.  *   * Everyone is granted permission to copy, modify and redistribute GDB, but only  * under the conditions described in the GDB General Public License.  A copy  * of this license is supposed to have been given to you along with GDB so  * you can know your rights and responsibilities.  It should be in a file  * named COPYING.  Among other things, the copyright notice and this notice  * must be preserved on all copies.  *   * In other words, go ahead and share GDB, but don't try to stop anyone else  * from sharing it farther.  Help stamp out software hoarding!  */
end_comment

begin_comment
comment|/*  * Original version was contributed by Derek Beatty, 30 June 87.  * This version is essentially a re-write of the original by Van  * Jacobson (van@helios.ee.lbl.gov), Nov, 90.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|stop_breakpoint
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<X11/IntrinsicP.h>
end_include

begin_include
include|#
directive|include
file|<X11/StringDefs.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xaw/AsciiSink.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xaw/AsciiText.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xaw/Box.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xaw/Command.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xaw/Label.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xaw/Paned.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xaw/Text.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bcopy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|select
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|get_filename_and_charpos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|source_line_charpos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|source_charpos_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|execute_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|error_no_arg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|add_com
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The X display where the window appears.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|displayname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Display
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XtAppContext
name|app_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Windows manipulated by this package.  */
end_comment

begin_decl_stmt
specifier|static
name|Widget
name|main_widget
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Widget
name|containing_widget
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Widget
name|source_name_widget
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Widget
name|source_text_widget
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Widget
name|button_box_widget
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Source text display.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frame_info
modifier|*
name|last_fi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|last_pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|last_cur_symtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_cur_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|source_window_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|source_window_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|source_window_symtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|version_label
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
specifier|static
name|Widget
name|create_text_widget
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|safe_strcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|b
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|a
operator|&&
name|b
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|&&
operator|!
name|b
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|strcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Display an appropriate piece of source code in the source window.  */
end_comment

begin_function
name|void
name|xgdb_display_source
parameter_list|()
block|{
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|struct
name|symtab_and_line
name|get_selected_frame_sal
parameter_list|()
function_decl|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
comment|/* Do nothing if called before we are initialized */
if|if
condition|(
operator|!
name|containing_widget
condition|)
return|return;
comment|/* 	 * Figure out what to display (the appropriate hooks to tell 	 * us don't exist so we guess):  If there's a current frame 	 * and it or its pc changed from the last time we were here, 	 * display appropriate source line.  Otherwise if the current 	 * source symtab or line is different, display that line. 	 * Otherwise nothing changed so leave the display alone. 	 */
name|fi
operator|=
name|get_frame_info
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|&&
operator|(
name|fi
operator|!=
name|last_fi
operator|||
name|fi
operator|->
name|pc
operator|!=
name|last_pc
operator|)
condition|)
block|{
name|last_fi
operator|=
name|fi
expr_stmt|;
name|last_pc
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
name|sal
operator|.
name|symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|current_source_line
expr_stmt|;
block|}
name|current_source_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
name|current_source_line
operator|=
name|sal
operator|.
name|line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_source_symtab
operator|!=
name|last_cur_symtab
operator|||
name|current_source_line
operator|!=
name|last_cur_line
condition|)
block|{
name|sal
operator|.
name|symtab
operator|=
name|last_cur_symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|last_cur_line
operator|=
name|current_source_line
expr_stmt|;
block|}
else|else
return|return;
comment|/* 	 * Do a path search and get the exact filename of this source file. 	 * Also scan it and find its source lines if not already done. 	 */
if|if
condition|(
name|sal
operator|.
name|symtab
operator|&&
name|filename
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|get_filename_and_charpos
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
operator|&
name|filename
argument_list|)
condition|)
comment|/* line numbers may have changed - force highlight */
name|source_window_line
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * If the source window is wrong, destroy it and make a new one. 	 */
if|if
condition|(
name|safe_strcmp
argument_list|(
name|filename
argument_list|,
name|source_window_file
argument_list|)
condition|)
block|{
name|Arg
name|args
index|[
literal|1
index|]
decl_stmt|;
name|Widget
name|src
init|=
name|XawTextGetSource
argument_list|(
name|source_text_widget
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
condition|)
block|{
name|XtSetArg
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|XtNstring
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|XtSetValues
argument_list|(
name|src
argument_list|,
name|args
argument_list|,
name|XtNumber
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|.
name|name
operator|=
name|XtNlabel
expr_stmt|;
name|XtSetValues
argument_list|(
name|source_name_widget
argument_list|,
name|args
argument_list|,
name|XtNumber
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XtSetArg
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|XtNstring
argument_list|,
literal|"/dev/null"
argument_list|)
expr_stmt|;
name|XtSetValues
argument_list|(
name|src
argument_list|,
name|args
argument_list|,
name|XtNumber
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|XtSetArg
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|XtNlabel
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|XtSetValues
argument_list|(
name|source_name_widget
argument_list|,
name|args
argument_list|,
name|XtNumber
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source_window_file
condition|)
name|free
argument_list|(
name|source_window_file
argument_list|)
expr_stmt|;
name|source_window_file
operator|=
name|filename
expr_stmt|;
name|source_window_line
operator|=
name|sal
operator|.
name|line
operator|+
literal|1
expr_stmt|;
comment|/* force highlight */
block|}
if|if
condition|(
name|sal
operator|.
name|symtab
operator|&&
name|source_window_line
operator|!=
name|sal
operator|.
name|line
condition|)
block|{
comment|/* 		 * Update display and cursor positions as necessary. 		 * Cursor should be placed on line sal.line. 		 */
name|XawTextPosition
name|l
decl_stmt|,
name|r
decl_stmt|;
name|source_window_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
name|source_window_line
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|l
operator|=
name|source_line_charpos
argument_list|(
name|source_window_symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|r
operator|=
name|source_line_charpos
argument_list|(
name|source_window_symtab
argument_list|,
name|sal
operator|.
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|l
condition|)
name|r
operator|=
name|l
operator|+
literal|1
expr_stmt|;
name|XawTextSetSelection
argument_list|(
name|source_text_widget
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|XawTextScrollToLine
argument_list|(
name|source_text_widget
argument_list|,
name|l
argument_list|,
literal|10
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|XawTextSetInsertionPoint
argument_list|(
name|source_text_widget
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handlers for buttons.  */
end_comment

begin_function
specifier|static
name|int
name|current_lineno
parameter_list|()
block|{
name|XawTextPosition
name|start
decl_stmt|,
name|finish
decl_stmt|;
name|XawTextGetSelectionPos
argument_list|(
name|source_text_widget
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|finish
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>=
name|finish
condition|)
name|start
operator|=
name|XawTextGetInsertionPoint
argument_list|(
name|source_text_widget
argument_list|)
expr_stmt|;
return|return
operator|(
name|source_charpos_line
argument_list|(
name|source_window_symtab
argument_list|,
name|start
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|append_selection
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|XawTextPosition
name|l
decl_stmt|,
name|r
decl_stmt|;
name|XawTextGetSelectionPos
argument_list|(
name|source_text_widget
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|r
operator|-
name|l
operator|)
operator|>
literal|0
condition|)
block|{
name|Widget
name|src
init|=
name|XawTextGetSource
argument_list|(
name|source_text_widget
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|XawTextBlock
name|tb
decl_stmt|;
name|XawTextSourceRead
argument_list|(
name|src
argument_list|,
name|l
argument_list|,
operator|&
name|tb
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tb
operator|.
name|ptr
argument_list|,
name|cp
argument_list|,
name|tb
operator|.
name|length
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|tb
operator|.
name|length
expr_stmt|;
name|len
operator|-=
name|tb
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
operator|--
name|cp
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|append_selection_word
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|XawTextPosition
name|l
decl_stmt|,
name|r
decl_stmt|;
name|XawTextBlock
name|tb
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|Widget
name|src
init|=
name|XawTextGetSource
argument_list|(
name|source_text_widget
argument_list|)
decl_stmt|;
name|XawTextGetSelectionPos
argument_list|(
name|source_text_widget
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|r
operator|-
name|l
operator|)
operator|<=
literal|0
condition|)
block|{
name|l
operator|=
name|XawTextGetInsertionPoint
argument_list|(
name|source_text_widget
argument_list|)
expr_stmt|;
name|len
operator|=
literal|128
expr_stmt|;
comment|/* XXX */
comment|/* might have clicked in middle of word -- back up to start */
for|for
control|(
init|;
name|l
operator|>
literal|0
condition|;
operator|--
name|l
control|)
block|{
name|XawTextSourceRead
argument_list|(
name|src
argument_list|,
name|l
operator|-
literal|1
argument_list|,
operator|&
name|tb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|tb
operator|.
name|ptr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
break|break;
block|}
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|XawTextSourceRead
argument_list|(
name|src
argument_list|,
name|l
argument_list|,
operator|&
name|tb
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|tb
operator|.
name|ptr
operator|,
name|i
operator|=
name|tb
operator|.
name|length
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
return|return
operator|(
name|cp
operator|)
return|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|len
operator|-=
name|tb
operator|.
name|length
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|append_selection_expr
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|XawTextPosition
name|l
decl_stmt|,
name|r
decl_stmt|;
name|Widget
name|src
init|=
name|XawTextGetSource
argument_list|(
name|source_text_widget
argument_list|)
decl_stmt|;
name|XawTextBlock
name|tb
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|XawTextGetSelectionPos
argument_list|(
name|source_text_widget
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
name|l
condition|)
return|return
operator|(
name|append_selection
argument_list|(
name|cp
argument_list|)
operator|)
return|;
name|l
operator|=
name|XawTextGetInsertionPoint
argument_list|(
name|source_text_widget
argument_list|)
expr_stmt|;
comment|/* might have clicked in middle of word -- back up to start */
for|for
control|(
init|;
name|l
operator|>
literal|0
condition|;
operator|--
name|l
control|)
block|{
name|XawTextSourceRead
argument_list|(
name|src
argument_list|,
name|l
operator|-
literal|1
argument_list|,
operator|&
name|tb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|tb
operator|.
name|ptr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
break|break;
block|}
name|len
operator|=
literal|128
expr_stmt|;
comment|/* XXX */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|pstack
index|[
literal|64
index|]
decl_stmt|;
name|int
name|pcnt
init|=
literal|0
decl_stmt|;
name|XawTextSourceRead
argument_list|(
name|src
argument_list|,
name|l
argument_list|,
operator|&
name|tb
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|tb
operator|.
name|ptr
operator|,
name|i
operator|=
name|tb
operator|.
name|length
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|sp
operator|++
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|';'
case|:
return|return
operator|(
name|cp
operator|)
return|;
case|case
literal|'='
case|:
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'='
condition|)
return|return
operator|(
name|cp
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|len
operator|==
literal|128
condition|)
return|return
operator|(
name|cp
operator|)
return|;
break|break;
case|case
literal|','
case|:
if|if
condition|(
name|pcnt
operator|<=
literal|0
condition|)
return|return
operator|(
name|cp
operator|)
return|;
break|break;
case|case
literal|'('
case|:
name|pstack
index|[
name|pcnt
index|]
operator|=
literal|')'
expr_stmt|;
if|if
condition|(
operator|++
name|pcnt
operator|>=
sizeof|sizeof
argument_list|(
name|pstack
argument_list|)
condition|)
return|return
operator|(
name|cp
operator|)
return|;
break|break;
case|case
literal|'['
case|:
name|pstack
index|[
name|pcnt
index|]
operator|=
literal|']'
expr_stmt|;
if|if
condition|(
operator|++
name|pcnt
operator|>=
sizeof|sizeof
argument_list|(
name|pstack
argument_list|)
condition|)
return|return
operator|(
name|cp
operator|)
return|;
break|break;
case|case
literal|')'
case|:
case|case
literal|']'
case|:
if|if
condition|(
operator|--
name|pcnt
operator|<
literal|0
operator|||
name|pstack
index|[
name|pcnt
index|]
operator|!=
name|c
condition|)
return|return
operator|(
name|cp
operator|)
return|;
break|break;
block|}
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|len
operator|-=
name|tb
operator|.
name|length
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|input_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX kluge: do_command sets this when command 			 * data from button is avaialble to force top level 			 * to break out of its loop. */
end_comment

begin_comment
comment|/*  * Handle a button by running the command COMMAND.  */
end_comment

begin_function
specifier|static
name|void
name|do_command
parameter_list|(
name|w
parameter_list|,
name|command
parameter_list|,
name|call_data
parameter_list|)
name|Widget
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|command
decl_stmt|;
name|caddr_t
name|call_data
decl_stmt|;
block|{
name|char
name|cmd_line
index|[
literal|256
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|out
init|=
name|cmd_line
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|extern
name|char
modifier|*
name|finish_command_input
parameter_list|()
function_decl|;
while|while
condition|(
name|c
operator|=
operator|*
name|command
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
operator|*
name|command
operator|++
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* current selection */
name|out
operator|=
name|append_selection
argument_list|(
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* 1st selected "word" at curor */
name|out
operator|=
name|append_selection_word
argument_list|(
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* echo cmd before executing */
break|break;
case|case
literal|'E'
case|:
comment|/* 1st selected expression at curor */
name|out
operator|=
name|append_selection_expr
argument_list|(
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* current line number */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|current_lineno
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|c
operator|=
operator|*
name|cp
operator|++
condition|;
operator|*
name|out
operator|++
operator|=
name|c
control|)
empty_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* line we're stopped at */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|source_window_line
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|c
operator|=
operator|*
name|cp
operator|++
condition|;
operator|*
name|out
operator|++
operator|=
name|c
control|)
empty_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* current file name */
for|for
control|(
name|cp
operator|=
name|source_window_symtab
operator|->
name|filename
init|;
name|c
operator|=
operator|*
name|cp
operator|++
condition|;
operator|*
name|out
operator|++
operator|=
name|c
control|)
empty_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* break # we're stopped at */
if|if
condition|(
name|stop_breakpoint
operator|<=
literal|0
condition|)
comment|/* if no breakpoint, don't do cmd */
return|return;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|stop_breakpoint
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|c
operator|=
operator|*
name|cp
operator|++
condition|;
operator|*
name|out
operator|++
operator|=
name|c
control|)
empty_stmt|;
break|break;
block|}
block|}
else|else
operator|*
name|out
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|out
operator|=
literal|0
expr_stmt|;
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
comment|/* have to exit via readline or tty modes stay messed up */
for|for
control|(
name|cp
operator|=
name|cmd_line
init|;
name|c
operator|=
operator|*
name|cp
operator|++
condition|;
control|)
name|rl_stuff_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rl_stuff_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|input_avail
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Define and display all the buttons.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|addbutton
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|function
argument_list|,
name|closure
argument_list|)
name|Widget
name|parent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|caddr_t
name|closure
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|XtCallbackRec
name|Callback
index|[]
init|=
block|{
block|{
name|NULL
block|,
operator|(
name|caddr_t
operator|)
name|NULL
block|}
block|,
block|{
name|NULL
block|,
operator|(
name|caddr_t
operator|)
name|NULL
block|}
block|, 	}
decl_stmt|;
specifier|static
name|Arg
name|commandArgs
index|[]
init|=
block|{
block|{
name|XtNlabel
block|,
operator|(
name|XtArgVal
operator|)
name|NULL
block|}
block|,
block|{
name|XtNcallback
block|,
operator|(
name|XtArgVal
operator|)
name|Callback
block|}
block|, 	}
decl_stmt|;
name|Widget
name|w
decl_stmt|;
name|char
name|wname
index|[
literal|128
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|strcpy
argument_list|(
name|wname
argument_list|,
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|wname
argument_list|,
literal|'*'
argument_list|)
operator|)
operator|||
operator|(
name|cp
operator|=
name|index
argument_list|(
name|wname
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|-=
literal|0x10
expr_stmt|;
if|if
condition|(
name|w
operator|=
name|XtNameToWidget
argument_list|(
name|parent
argument_list|,
name|wname
argument_list|)
condition|)
name|XtDestroyWidget
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|Callback
index|[
literal|0
index|]
operator|.
name|callback
operator|=
operator|(
name|XtCallbackProc
operator|)
name|function
expr_stmt|;
name|Callback
index|[
literal|0
index|]
operator|.
name|closure
operator|=
operator|(
name|caddr_t
operator|)
name|closure
expr_stmt|;
name|commandArgs
index|[
literal|0
index|]
operator|.
name|value
operator|=
operator|(
name|XtArgVal
operator|)
name|name
expr_stmt|;
name|XtCreateManagedWidget
argument_list|(
name|wname
argument_list|,
name|commandWidgetClass
argument_list|,
name|parent
argument_list|,
name|commandArgs
argument_list|,
name|XtNumber
argument_list|(
name|commandArgs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Create the button windows and store them in `buttons'.  */
end_comment

begin_function
specifier|static
name|void
name|create_buttons
parameter_list|(
name|parent
parameter_list|)
name|Widget
name|parent
decl_stmt|;
block|{
name|addbutton
argument_list|(
name|parent
argument_list|,
literal|"quit"
argument_list|,
name|do_command
argument_list|,
literal|"quit"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|button_command
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"button label and command"
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
init|;
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|arg
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|;
operator|--
name|len
control|)
empty_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"button label and command"
argument_list|)
expr_stmt|;
name|arg
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* make a copy of button label& command for toolkit to use */
name|label
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|label
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* find the end of the label */
if|if
condition|(
operator|*
name|label
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
operator|(
name|arg
operator|=
name|index
argument_list|(
operator|++
name|label
argument_list|,
literal|'"'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"button label missing closing quote\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|arg
operator|++
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|=
name|index
argument_list|(
name|label
argument_list|,
literal|' '
argument_list|)
condition|)
operator|*
name|arg
operator|++
operator|=
literal|0
expr_stmt|;
else|else
name|arg
operator|=
name|label
expr_stmt|;
while|while
condition|(
operator|*
name|arg
operator|&&
name|isspace
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
operator|++
name|arg
expr_stmt|;
name|addbutton
argument_list|(
name|button_box_widget
argument_list|,
name|label
argument_list|,
name|do_command
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|button_delete_command
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|unsigned
name|int
name|len
decl_stmt|;
name|Widget
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"button name"
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
init|;
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|arg
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|;
operator|--
name|len
control|)
empty_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"button name"
argument_list|)
expr_stmt|;
name|arg
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* find the end of the label */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
operator|++
name|arg
argument_list|,
literal|'"'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"button label missing closing quote\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|arg
argument_list|,
literal|'*'
argument_list|)
operator|)
operator|||
operator|(
name|cp
operator|=
name|index
argument_list|(
name|arg
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|-=
literal|0x10
expr_stmt|;
if|if
condition|(
name|w
operator|=
name|XtNameToWidget
argument_list|(
name|button_box_widget
argument_list|,
name|arg
argument_list|)
condition|)
name|XtDestroyWidget
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a "label window" that just displays the string LABEL.  */
end_comment

begin_function
specifier|static
name|Widget
name|create_label
parameter_list|(
name|name
parameter_list|,
name|label
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|label
decl_stmt|;
end_function

begin_block
block|{
name|Arg
name|args
index|[
literal|1
index|]
decl_stmt|;
name|Widget
name|w
decl_stmt|;
name|XtSetArg
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|XtNlabel
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|w
operator|=
name|XtCreateManagedWidget
argument_list|(
name|name
argument_list|,
name|labelWidgetClass
argument_list|,
name|containing_widget
argument_list|,
name|args
argument_list|,
name|XtNumber
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|w
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Create a subwindow of PARENT that displays and scrolls the contents of  * file FILENAME.  */
end_comment

begin_function
specifier|static
name|Widget
name|create_text_widget
parameter_list|(
name|parent
parameter_list|,
name|filename
parameter_list|)
name|Widget
name|parent
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|static
name|Arg
name|arg
index|[]
init|=
block|{
block|{
name|XtNstring
block|,
name|NULL
block|}
block|,
block|{
name|XtNtype
block|,
name|XawAsciiFile
block|}
block|,
block|{
name|XtNcursor
block|,
name|None
block|}
block|, 	}
decl_stmt|;
name|Widget
name|text_widget
decl_stmt|;
name|arg
index|[
literal|0
index|]
operator|.
name|value
operator|=
operator|(
name|XtArgVal
operator|)
name|filename
expr_stmt|;
name|text_widget
operator|=
name|XtCreateManagedWidget
argument_list|(
literal|"src"
argument_list|,
name|asciiTextWidgetClass
argument_list|,
name|parent
argument_list|,
name|arg
argument_list|,
name|XtNumber
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|text_widget
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Entry point to create the widgets representing our display.  */
end_comment

begin_function
name|void
name|xgdb_create_window
parameter_list|()
block|{
comment|/* initialize toolkit, setup defaults */
ifdef|#
directive|ifdef
name|notyet
name|main_widget
operator|=
name|XtAppInitialize
argument_list|(
operator|&
name|app_context
argument_list|,
literal|"Xgdb"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|argcptr
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|dummy_argv
index|[]
init|=
block|{
literal|"xgdb"
block|,
literal|0
block|}
decl_stmt|;
name|int
name|dummy_argc
init|=
literal|1
decl_stmt|;
name|main_widget
operator|=
name|XtAppInitialize
argument_list|(
operator|&
name|app_context
argument_list|,
literal|"Xgdb"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|dummy_argc
argument_list|,
name|dummy_argv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|display
operator|=
name|XtDisplay
argument_list|(
name|main_widget
argument_list|)
expr_stmt|;
name|containing_widget
operator|=
name|XtCreateManagedWidget
argument_list|(
literal|"frame"
argument_list|,
name|panedWidgetClass
argument_list|,
name|main_widget
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|version_label
argument_list|,
literal|"XGDB %s"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|button_box_widget
operator|=
name|XtCreateManagedWidget
argument_list|(
literal|"buttons"
argument_list|,
name|boxWidgetClass
argument_list|,
name|containing_widget
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|create_buttons
argument_list|(
name|button_box_widget
argument_list|)
expr_stmt|;
name|source_name_widget
operator|=
name|create_label
argument_list|(
literal|"srcLabel"
argument_list|,
literal|"No source file yet."
argument_list|)
expr_stmt|;
name|source_text_widget
operator|=
name|create_text_widget
argument_list|(
name|containing_widget
argument_list|,
literal|"/dev/null"
argument_list|)
expr_stmt|;
name|XtRealizeWidget
argument_list|(
name|main_widget
argument_list|)
expr_stmt|;
name|XFlush
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If we use an X window, the readline input loop is told to call  * this function before reading a character from stdin.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|xgdb_window_hook
parameter_list|()
block|{
specifier|register
name|int
name|inmask
init|=
literal|1
operator|<<
name|fileno
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
specifier|register
name|int
name|xmask
init|=
literal|1
operator|<<
name|ConnectionNumber
argument_list|(
name|display
argument_list|)
decl_stmt|;
specifier|register
name|int
name|nfds
decl_stmt|,
name|pend
decl_stmt|;
name|int
name|input_rfds
decl_stmt|;
name|XEvent
name|ev
decl_stmt|;
comment|/* 	 * Display our current idea of the `interesting' source file then 	 * loop, dispatching window events until data is available on 	 * stdin. Then return so the input data can be processed. 	 */
name|input_avail
operator|=
literal|0
expr_stmt|;
name|xgdb_display_source
argument_list|()
expr_stmt|;
name|input_rfds
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|input_avail
operator|==
literal|0
operator|&&
operator|(
name|input_rfds
operator|&
name|inmask
operator|)
operator|==
literal|0
condition|)
block|{
name|pend
operator|=
name|XPending
argument_list|(
name|display
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pend
condition|)
block|{
name|input_rfds
operator|=
name|inmask
operator||
name|xmask
expr_stmt|;
name|nfds
operator|=
name|select
argument_list|(
literal|32
argument_list|,
operator|&
name|input_rfds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfds
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
block|}
if|if
condition|(
name|pend
operator|||
operator|(
name|input_rfds
operator|&
name|xmask
operator|)
condition|)
block|{
name|XNextEvent
argument_list|(
name|display
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
name|XtDispatchEvent
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|_initialize_xgdb
parameter_list|()
block|{
specifier|extern
name|void
function_decl|(
modifier|*
name|window_hook
function_decl|)
parameter_list|()
function_decl|;
specifier|extern
name|int
name|inhibit_windows
decl_stmt|;
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|deletelist
decl_stmt|;
if|if
condition|(
name|inhibit_windows
condition|)
return|return;
if|if
condition|(
operator|!
name|displayname
condition|)
block|{
name|displayname
operator|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|displayname
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"xgdb: no display name\n"
argument_list|)
expr_stmt|;
name|inhibit_windows
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|xgdb_create_window
argument_list|()
expr_stmt|;
name|window_hook
operator|=
name|xgdb_window_hook
expr_stmt|;
name|add_com
argument_list|(
literal|"button"
argument_list|,
name|class_support
argument_list|,
name|button_command
argument_list|,
literal|"Add command button to xgdb window.  First argument is button\n\ label, second is command associated with button.  Command can\n\ include printf-like escapes:\n\    %s for current selection,\n\    %S for first 'word' of current selection,\n\    %e for current selection or expression at insertion pt,\n\    %E for current selection or expression at insertion pt,\n\    %l for current line number,\n\    %L for line program stopped at,\n\    %f for current file name,\n\    %b for current breakpoint number."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"button"
argument_list|,
name|class_support
argument_list|,
name|button_delete_command
argument_list|,
literal|"Delete a button from the xgdb window.\n\ Argument is name of button to be deleted."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

