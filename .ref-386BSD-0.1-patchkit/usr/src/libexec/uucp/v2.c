begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* v2.c    Read V2 configuration files.  Much of this file is identical to bnu.c,    and they really should be partially merged.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: v2.c,v $    Revision 1.15  1992/03/12  19:54:43  ian    Debugging based on types rather than number     Revision 1.14  1992/03/10  21:47:39  ian    Added protocol command for ports     Revision 1.13  1992/03/04  02:09:36  ian    Jeff Putsch: infinite loop when parsing time string     Revision 1.12  1992/02/24  20:36:27  ian    Roberto Biancardi: skip spaces after strtok (NULL, "")     Revision 1.11  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.10  1992/01/15  07:06:29  ian    Set configuration directory in Makefile rather than sysdep.h     Revision 1.9  1992/01/05  04:30:45  ian    Set chat script correctly     Revision 1.8  1991/12/28  03:49:23  ian    Added HAVE_MEMFNS and HAVE_BFNS; changed uses of memset to bzero     Revision 1.7  1991/12/01  19:35:38  ian    David Nugent: read V2 and BNU files by default even with TAYLOR_CONFIG     Revision 1.6  1991/11/26  01:04:04  ian    Marty Shannon: initialize ireliable for BNU and V2 configuration files     Revision 1.5  1991/11/14  03:20:13  ian    Added seven-bit and reliable commands to help when selecting protocols     Revision 1.4  1991/11/13  20:38:00  ian    Added TCP port type for connections over TCP     Revision 1.3  1991/11/11  16:59:05  ian    Eliminate fread_port_info, allow NULL pflock arg to ffind_port     Revision 1.2  1991/09/19  02:22:44  ian    Chip Salzenberg's patch to allow ";retrytime" at the end of a time string     Revision 1.1  1991/09/10  19:40:31  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|HAVE_V2_CONFIG
end_if

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|v2_rcsid
index|[]
init|=
literal|"$Id: v2.c,v 1.15 1992/03/12 19:54:43 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Whether to use V2 configuration files.  */
end_comment

begin_decl_stmt
name|boolean
name|fV2
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* A little routine to add a grade and a time string to a system.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|uvadd_time
name|P
argument_list|(
operator|(
expr|struct
name|ssysteminfo
operator|*
name|q
operator|,
name|int
name|bgrade
operator|,
specifier|const
name|char
operator|*
name|ztime
operator|,
name|int
name|cretry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|uvadd_time
parameter_list|(
name|q
parameter_list|,
name|bgrade
parameter_list|,
name|ztime
parameter_list|,
name|cretry
parameter_list|)
name|struct
name|ssysteminfo
modifier|*
name|q
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztime
decl_stmt|;
name|int
name|cretry
decl_stmt|;
block|{
name|char
modifier|*
name|zset
decl_stmt|;
name|zset
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|ztime
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|cretry
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|"%c%s"
argument_list|,
name|bgrade
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|"%c%s;%d"
argument_list|,
name|bgrade
argument_list|,
name|ztime
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
name|uadd_string
argument_list|(
operator|&
name|q
operator|->
name|ztime
argument_list|,
name|zset
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read V2 system information.  This means reading the L.sys file and    the USERFILE file.  */
end_comment

begin_function
name|void
name|uv2_read_systems
parameter_list|(
name|pc
parameter_list|,
name|ppas
parameter_list|)
name|int
modifier|*
name|pc
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
modifier|*
name|ppas
decl_stmt|;
block|{
name|int
name|calc
decl_stmt|;
name|char
name|ab
index|[
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|V2_SYSTEMS
operator|-
literal|1
index|]
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
operator|*
name|pc
operator|=
literal|0
expr_stmt|;
operator|*
name|ppas
operator|=
name|NULL
expr_stmt|;
name|calc
operator|=
literal|0
expr_stmt|;
comment|/* Read the L.sys file first.  */
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|V2_SYSTEMS
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|ab
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fopen (%s): %s"
argument_list|,
name|ab
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|zline
operator|=
name|zfgets
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|ztok
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cretry
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|qset
decl_stmt|;
name|char
modifier|*
name|zsemi
decl_stmt|,
modifier|*
name|zslash
decl_stmt|;
name|zline
index|[
name|strcspn
argument_list|(
name|zline
argument_list|,
literal|"#\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ztok
operator|=
name|strtok
argument_list|(
name|zline
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_CONFIG
argument_list|,
literal|"uv2_read_systems: Reading system %s"
argument_list|,
name|ztok
argument_list|)
expr_stmt|;
comment|/* See if we already have information for this system.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
operator|.
name|zname
argument_list|,
name|ztok
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
operator|*
name|pc
condition|)
block|{
if|if
condition|(
operator|*
name|pc
operator|>=
name|calc
condition|)
block|{
name|calc
operator|+=
literal|10
expr_stmt|;
operator|*
name|ppas
operator|=
operator|(
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
operator|*
name|ppas
argument_list|,
name|calc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|qset
operator|=
operator|&
operator|(
operator|*
name|ppas
operator|)
index|[
operator|*
name|pc
index|]
expr_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ssysteminfo
modifier|*
modifier|*
name|pq
decl_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
operator|.
name|qalternate
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qalternate
control|)
empty_stmt|;
operator|*
name|pq
operator|=
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
expr_stmt|;
name|qset
operator|=
operator|*
name|pq
expr_stmt|;
block|}
name|uset_system_defaults
argument_list|(
name|qset
argument_list|)
expr_stmt|;
name|qset
operator|->
name|zname
operator|=
name|ztok
expr_stmt|;
comment|/* Get the time string.  */
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|==
name|NULL
condition|)
continue|continue;
comment|/* The format of the time string appears to be time/grade, 	 time/grade;retry.  A missing grade is taken as 'z'.  */
name|cretry
operator|=
literal|0
expr_stmt|;
name|zsemi
operator|=
name|strchr
argument_list|(
name|ztok
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsemi
operator|!=
name|NULL
condition|)
block|{
operator|*
name|zsemi
operator|=
literal|'\0'
expr_stmt|;
name|cretry
operator|=
name|atoi
argument_list|(
name|zsemi
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|qset
operator|->
name|ztime
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
modifier|*
name|zcomma
decl_stmt|;
name|zcomma
operator|=
name|strchr
argument_list|(
name|ztok
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcomma
operator|!=
name|NULL
condition|)
operator|*
name|zcomma
operator|=
literal|'\0'
expr_stmt|;
name|zslash
operator|=
name|strchr
argument_list|(
name|ztok
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zslash
operator|==
name|NULL
operator|||
name|zslash
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|uvadd_time
argument_list|(
name|qset
argument_list|,
name|BGRADE_LOW
argument_list|,
name|ztok
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|zslash
operator|=
literal|'\0'
expr_stmt|;
name|uvadd_time
argument_list|(
name|qset
argument_list|,
name|zslash
index|[
literal|1
index|]
argument_list|,
name|ztok
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zcomma
operator|==
name|NULL
condition|)
break|break;
name|ztok
operator|=
name|zcomma
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Get the devices entry.  */
name|qset
operator|->
name|zport
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qset
operator|->
name|zport
operator|!=
name|NULL
condition|)
block|{
comment|/* Get the speed entry.  This is the baud rate to use.  */
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TCP
comment|/* If the port is "TCP", we set up a system specific port. 	     The baud rate becomes the service number and the phone 	     number becomes the address (which is still stored in 	     qsys->zphone).  */
if|if
condition|(
name|strcmp
argument_list|(
name|qset
operator|->
name|zport
argument_list|,
literal|"TCP"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qset
operator|->
name|zport
operator|=
name|NULL
expr_stmt|;
name|qset
operator|->
name|qport
operator|=
operator|(
operator|(
expr|struct
name|sport
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sport
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|qset
operator|->
name|qport
operator|->
name|zname
operator|=
literal|"TCP"
expr_stmt|;
name|qset
operator|->
name|qport
operator|->
name|ttype
operator|=
name|PORTTYPE_TCP
expr_stmt|;
name|qset
operator|->
name|qport
operator|->
name|zprotocols
operator|=
name|NULL
expr_stmt|;
name|qset
operator|->
name|qport
operator|->
name|cproto_params
operator|=
literal|0
expr_stmt|;
name|qset
operator|->
name|qport
operator|->
name|qproto_params
operator|=
name|NULL
expr_stmt|;
name|qset
operator|->
name|qport
operator|->
name|ireliable
operator|=
operator|(
name|RELIABLE_ENDTOEND
operator||
name|RELIABLE_RELIABLE
operator||
name|RELIABLE_EIGHT
operator||
name|RELIABLE_SPECIFIED
operator|)
expr_stmt|;
name|qset
operator|->
name|qport
operator|->
name|zlockname
operator|=
name|NULL
expr_stmt|;
name|qset
operator|->
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|o
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ztok
operator|==
name|NULL
condition|)
name|qset
operator|->
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|zport
operator|=
literal|"uucp"
expr_stmt|;
else|else
name|qset
operator|->
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|zport
operator|=
name|ztok
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_TCP */
if|if
condition|(
name|ztok
operator|!=
name|NULL
condition|)
block|{
name|qset
operator|->
name|ibaud
operator|=
name|atol
argument_list|(
name|ztok
argument_list|)
expr_stmt|;
comment|/* Get the phone number.  */
name|qset
operator|->
name|zphone
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
comment|/* The rest of the line is the login script.  */
if|if
condition|(
name|qset
operator|->
name|zphone
operator|!=
name|NULL
condition|)
block|{
name|qset
operator|->
name|schat
operator|.
name|zchat
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|qset
operator|->
name|schat
operator|.
name|zchat
operator|+=
name|strspn
argument_list|(
name|qset
operator|->
name|schat
operator|.
name|zchat
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Now read USERFILE and L.cmds to get permissions.  We can't fully      handle USERFILE since that specifies permissions based on local      users which we do not support.  */
block|{
name|char
name|abuserfile
index|[
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|V2_USERFILE
operator|-
literal|1
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|abuserfile
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|V2_USERFILE
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|abuserfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fopen (%s): %s"
argument_list|,
name|abuserfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|boolean
modifier|*
name|affound
decl_stmt|;
name|boolean
name|fothercallback
decl_stmt|;
name|char
modifier|*
name|zother
decl_stmt|;
name|affound
operator|=
operator|(
name|boolean
operator|*
operator|)
name|alloca
argument_list|(
operator|*
name|pc
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|affound
argument_list|,
operator|*
name|pc
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
name|fothercallback
operator|=
name|FALSE
expr_stmt|;
name|zother
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|zline
operator|=
name|zfgets
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|ztok
decl_stmt|,
modifier|*
name|zcomma
decl_stmt|,
modifier|*
name|zfiles
decl_stmt|,
modifier|*
name|zset
decl_stmt|;
name|boolean
name|fcallback
decl_stmt|;
name|zline
index|[
name|strcspn
argument_list|(
name|zline
argument_list|,
literal|"#\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* The first field is username,machinename */
name|ztok
operator|=
name|strtok
argument_list|(
name|zline
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|zcomma
operator|=
name|strchr
argument_list|(
name|ztok
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcomma
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|zcomma
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* The rest of the line is the list of directories, expect 	       that if the first directory is "c" we must call the 	       system back.  */
name|zfiles
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|zfiles
operator|+=
name|strspn
argument_list|(
name|zfiles
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|fcallback
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|zfiles
operator|==
literal|'c'
operator|&&
operator|(
name|zfiles
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|zfiles
index|[
literal|1
index|]
operator|==
literal|' '
operator|||
name|zfiles
index|[
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|fcallback
operator|=
name|TRUE
expr_stmt|;
operator|++
name|zfiles
expr_stmt|;
block|}
name|zset
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|zfiles
operator|=
name|strtok
argument_list|(
name|zfiles
argument_list|,
literal|" \t"
argument_list|)
init|;
name|zfiles
operator|!=
name|NULL
condition|;
name|zfiles
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
name|uadd_string
argument_list|(
operator|&
name|zset
argument_list|,
name|zfiles
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ztok
operator|==
literal|'\0'
condition|)
block|{
comment|/* There is no user name.  If this is the first entry 		   with no user name, then this line specifies the 		   directories which may be sent by local request 		   for login names which are not listed otherwise.  */
if|if
condition|(
name|zother
operator|==
name|NULL
condition|)
block|{
name|zother
operator|=
name|zset
expr_stmt|;
name|fothercallback
operator|=
name|fcallback
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|zcomma
operator|==
literal|'\0'
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* There is no system name.  This entry specifies 		   permissions based on the login name.  We must add 		   an alternate to each system specifying what to do 		   when this login name is used.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pc
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ssysteminfo
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
operator|.
name|zcalled_login
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
operator|.
name|zcalled_login
argument_list|,
literal|"ANY"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
operator|.
name|zcalled_login
operator|=
literal|"ANY"
expr_stmt|;
name|q
operator|=
operator|(
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
operator|)
expr_stmt|;
operator|*
name|q
operator|=
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
expr_stmt|;
name|q
operator|->
name|qalternate
operator|=
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
operator|.
name|qalternate
expr_stmt|;
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
operator|.
name|qalternate
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|zcalled_login
operator|=
name|xstrdup
argument_list|(
name|ztok
argument_list|)
expr_stmt|;
name|q
operator|->
name|fcallback
operator|=
name|fcallback
expr_stmt|;
name|q
operator|->
name|zremote_send
operator|=
name|q
operator|->
name|zremote_receive
operator|=
name|zset
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|q
decl_stmt|;
comment|/* Both the login name and the machine name were 		   listed; require the machine to be logged in under 		   this name.  This is not fully backward compatible, 		   and perhaps should be changed.  On the other hand, 		   it is more useful.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|ppas
operator|)
operator|->
name|zname
argument_list|,
name|zcomma
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
operator|*
name|pc
condition|)
block|{
comment|/* We don't warn about systems which don't already 		       exist, since they may appear in sample 		       USERFILES.  */
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|affound
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|q
operator|=
operator|&
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|qalternate
control|)
block|{
name|q
operator|->
name|zcalled_login
operator|=
name|xstrdup
argument_list|(
name|ztok
argument_list|)
expr_stmt|;
name|q
operator|->
name|zlocal_send
operator|=
name|q
operator|->
name|zlocal_receive
operator|=
name|zset
expr_stmt|;
name|q
operator|->
name|zremote_send
operator|=
name|q
operator|->
name|zremote_receive
operator|=
name|zset
expr_stmt|;
name|q
operator|->
name|fcallback
operator|=
name|fcallback
expr_stmt|;
block|}
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|zother
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pc
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ssysteminfo
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|affound
index|[
name|i
index|]
condition|)
continue|continue;
name|q
operator|=
operator|&
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|zcalled_login
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|q
operator|->
name|zcalled_login
argument_list|,
literal|"ANY"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|q
operator|->
name|zlocal_send
operator|=
name|q
operator|->
name|zlocal_receive
operator|=
name|zother
expr_stmt|;
name|q
operator|->
name|fcallback
operator|=
name|fothercallback
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Now we must read L.cmds to determine which commands may be      executed.  */
block|{
name|char
name|abcmds
index|[
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|V2_CMDS
operator|-
literal|1
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|abcmds
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|V2_CMDS
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|abcmds
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fopen (%s): %s"
argument_list|,
name|abcmds
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|zcmds
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|q
decl_stmt|;
name|zline
operator|=
name|zfgets
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|zline
index|[
name|strcspn
argument_list|(
name|zline
argument_list|,
literal|"#\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zline
argument_list|,
literal|"PATH="
argument_list|,
sizeof|sizeof
expr|"PATH="
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|zline
operator|+=
sizeof|sizeof
expr|"PATH="
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|z
operator|=
name|strchr
argument_list|(
name|zline
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|z
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pc
condition|;
name|i
operator|++
control|)
for|for
control|(
name|q
operator|=
operator|&
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|qalternate
control|)
name|q
operator|->
name|zpath
operator|=
name|zline
expr_stmt|;
name|zline
operator|=
name|zfgets
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|zcmds
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|zline
operator|!=
name|NULL
condition|)
block|{
name|zline
index|[
name|strcspn
argument_list|(
name|zline
argument_list|,
literal|"#\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|uadd_string
argument_list|(
operator|&
name|zcmds
argument_list|,
name|zline
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
name|zline
operator|=
name|zfgets
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pc
condition|;
name|i
operator|++
control|)
for|for
control|(
name|q
operator|=
operator|&
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|qalternate
control|)
name|q
operator|->
name|zcmds
operator|=
name|zcmds
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a port with a given name and speed in the file L-devices and    lock it.  If found and locked, fill in the structure pointed at by    qport.  Set *pffound to TRUE if a port was found but could not be    locked.  */
end_comment

begin_function_decl
name|boolean
name|fv2_find_port
parameter_list|(
name|zname
parameter_list|,
name|ibaud
parameter_list|,
name|ihighbaud
parameter_list|,
name|qport
parameter_list|,
name|pflock
parameter_list|,
name|pffound
parameter_list|)
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
name|long
name|ihighbaud
decl_stmt|;
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*pflock
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
expr|struct
name|sport
operator|*
operator|,
name|boolean
name|fin
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|boolean
modifier|*
name|pffound
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|ab
index|[
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|V2_DEVICES
operator|-
literal|1
index|]
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|V2_DEVICES
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|ab
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fopen (%s): %s"
argument_list|,
name|ab
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
while|while
condition|(
operator|(
name|zline
operator|=
name|zfgets
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|ztok
decl_stmt|,
modifier|*
name|zdevice
decl_stmt|,
modifier|*
name|zdial_device
decl_stmt|;
name|long
name|ilow
decl_stmt|,
name|ihigh
decl_stmt|;
name|zline
index|[
name|strcspn
argument_list|(
name|zline
argument_list|,
literal|"#\n"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* An entry in L-devices is type device dial-device baud.  */
name|ztok
operator|=
name|strtok
argument_list|(
name|zline
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|zname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zname
argument_list|,
name|ztok
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|qport
operator|->
name|zname
operator|=
name|ztok
expr_stmt|;
name|zdevice
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdevice
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|zdial_device
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdial_device
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zdial_device
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|zdial_device
operator|=
name|NULL
expr_stmt|;
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ilow
operator|=
name|strtol
argument_list|(
name|ztok
argument_list|,
operator|&
name|ztok
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilow
operator|==
literal|0
condition|)
name|ihigh
operator|=
literal|38400L
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|ztok
operator|==
literal|'-'
condition|)
name|ihigh
operator|=
name|atol
argument_list|(
name|ztok
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|ihigh
operator|=
name|ilow
expr_stmt|;
block|}
if|if
condition|(
name|ibaud
operator|!=
literal|0
operator|&&
operator|(
name|ihighbaud
operator|<
name|ilow
operator|||
name|ibaud
operator|>
name|ihigh
operator|)
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We have found a matching port.  We now fill in the sport 	 structure so that we can try to lock it.  */
name|qport
operator|->
name|zprotocols
operator|=
name|NULL
expr_stmt|;
name|qport
operator|->
name|cproto_params
operator|=
literal|0
expr_stmt|;
name|qport
operator|->
name|qproto_params
operator|=
name|NULL
expr_stmt|;
name|qport
operator|->
name|ireliable
operator|=
literal|0
expr_stmt|;
name|qport
operator|->
name|zlockname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|qport
operator|->
name|zname
argument_list|,
literal|"DIR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qport
operator|->
name|ttype
operator|=
name|PORTTYPE_DIRECT
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|sdirect
operator|.
name|zdevice
operator|=
name|zdevice
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|sdirect
operator|.
name|ibaud
operator|=
name|ilow
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSDEP_DIRECT_INIT
name|SYSDEP_DIRECT_INIT
argument_list|(
operator|&
name|qport
operator|->
name|u
operator|.
name|sdirect
operator|.
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|qport
operator|->
name|ttype
operator|=
name|PORTTYPE_MODEM
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdevice
operator|=
name|zdevice
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdial_device
operator|=
name|zdial_device
expr_stmt|;
if|if
condition|(
name|ilow
operator|!=
name|ihigh
condition|)
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ibaud
operator|=
literal|0
expr_stmt|;
else|else
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ibaud
operator|=
name|ilow
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ilowbaud
operator|=
name|ilow
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ihighbaud
operator|=
name|ihigh
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|fcarrier
operator|=
name|TRUE
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
operator|+=
name|strspn
argument_list|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|qdialer
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSDEP_MODEM_INIT
name|SYSDEP_MODEM_INIT
argument_list|(
operator|&
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pffound
operator|!=
name|NULL
condition|)
operator|*
name|pffound
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|pflock
operator|!=
name|NULL
operator|&&
operator|!
call|(
modifier|*
name|pflock
call|)
argument_list|(
name|qport
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_V2_CONFIG */
end_comment

end_unit

