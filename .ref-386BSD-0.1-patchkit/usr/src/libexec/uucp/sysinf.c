begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sysinf.c    Functions to read system information for the UUCP package.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: sysinf.c,v $    Revision 1.24  1992/04/02  22:51:09  ian    Add gcc 2.0 format checking to ulog, and fixed discovered problems     Revision 1.23  1992/03/30  04:49:10  ian    Niels Baggesen: added debugging types abnormal and uucp-proto     Revision 1.22  1992/03/28  21:47:55  ian    David J. MacKenzie: allow backslash to quote newline in config files     Revision 1.21  1992/03/28  20:31:55  ian    Franc,ois Pinard: allow a name to be given to an alternate     Revision 1.20  1992/03/24  17:18:33  ian    Fixed handling of alternates in file-wide defaults     Revision 1.19  1992/03/16  04:30:57  ian    Permit a retry time for the time and timegrade commands     Revision 1.18  1992/03/13  16:17:42  ian    Chip Salzenberg: set default login chat script timeout to 10 seconds     Revision 1.17  1992/03/12  19:54:43  ian    Debugging based on types rather than number     Revision 1.16  1992/03/09  20:14:37  ian    Ted Lindgreen: added max-remote-debug command     Revision 1.15  1992/03/07  02:56:30  ian    Rewrote time routines     Revision 1.14  1992/03/03  06:06:48  ian    T. William Wells: don't complain about missing configuration files     Revision 1.13  1992/02/23  19:50:50  ian    Handle READ and WRITE in Permissions correctly     Revision 1.12  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.11  1992/01/13  05:17:30  ian    Mike Park: wrong number of arguments to ulog call     Revision 1.10  1992/01/07  15:23:50  ian    Niels Baggesen: allocate number of protocol parameters correctly     Revision 1.9  1991/12/28  03:49:23  ian    Added HAVE_MEMFNS and HAVE_BFNS; changed uses of memset to bzero     Revision 1.8  1991/12/23  05:15:54  ian    David Nugent: set debugging level for a specific system     Revision 1.7  1991/12/17  17:08:02  ian    Marc Unangst: allow true and false for boolean strings as documented     Revision 1.6  1991/12/15  04:17:11  ian    Added chat-seven-bit command to control parity bit stripping     Revision 1.5  1991/12/15  03:42:33  ian    Added tprocess_chat_cmd for all chat commands, and added CMDTABTYPE_PREFIX     Revision 1.4  1991/11/13  20:38:00  ian    Added TCP port type for connections over TCP     Revision 1.3  1991/11/12  19:47:04  ian    Add called-chat set of commands to run a chat script on an incoming call     Revision 1.2  1991/11/11  23:47:24  ian    Added chat-program to run a program to do a chat script     Revision 1.1  1991/09/10  19:40:31  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|sysinf_rcsid
index|[]
init|=
literal|"$Id: sysinf.c,v 1.24 1992/04/02 22:51:09 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"uutime.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Whether we accept calls from unknown systems.  */
end_comment

begin_decl_stmt
name|boolean
name|fUnknown_ok
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Information we hold for an unknown system.  */
end_comment

begin_decl_stmt
name|struct
name|ssysteminfo
name|sUnknown
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Information we hold for the local system.  */
end_comment

begin_decl_stmt
name|struct
name|ssysteminfo
name|sLocalsys
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_if
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
end_if

begin_comment
comment|/* I don't find the system file format used by either V2 or BNU UUCP    very intuitive, so I've developed my own format.  This replaces the    files L.sys and USERFILE for V2, and Systems and Permissions for    BNU.  The complete format is described in a separate document.  */
end_comment

begin_comment
comment|/* Some local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|uiset_clear
name|P
argument_list|(
operator|(
name|boolean
name|falternate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set when we read the first line of a new file, to indicate that a    new set of defaults should be gathered.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fIfirst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure holds system information as it is gathered.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ssysteminfo
name|sIhold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default information.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ssysteminfo
name|sIdefault
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the next system.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zInext_system
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of alternates to draw from.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ssysteminfo
modifier|*
name|qIalternates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to use default alternates.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fIdefault_alternates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* There are several commands for which we want to take the default if    provided, but we don't want to add to the default.  For example,    each system can have multiple time specifications (using different    grades), which is implemented by adding each new time specification    to the previous ones. We want to allow default time specifications.    However, if a system has time specifications, we don't want to add    its time specifications to the default ones.  We handle this with a    set of boolean variables which we set to tell the adding functions    to ignore any existing entry; when an entry has been added, the    boolean variable is cleared.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_alias
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_alternate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_calltimegrade
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_call_local_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_call_remote_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_called_local_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_called_remote_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_chat_fail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_proto_param
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fIclear_called_chat_fail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions needed to parse the system information file.  */
end_comment

begin_define
define|#
directive|define
name|CMDTABFN
parameter_list|(
name|z
parameter_list|)
define|\
value|static enum tcmdtabret z P((int, char **, pointer, const char *))
end_define

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|ticlear
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|tisystem
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|tialias
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|tialternate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|titime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|titimegrade
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|ticall_local_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|ticall_remote_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|ticalled_local_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|ticalled_remote_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|titimetable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|tiport
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|tichat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|ticalled_login
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|tiproto_param
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|tirequest
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CMDTABFN
argument_list|(
name|titransfer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|CMDTABFN
end_undef

begin_comment
comment|/* The commands accepted from the system information file.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|scmdtab
name|asIcmds
index|[]
init|=
block|{
block|{
literal|"#"
block|,
name|CMDTABTYPE_FN
operator||
literal|1
block|,
name|NULL
block|,
name|ticlear
block|}
block|,
block|{
literal|"system"
block|,
name|CMDTABTYPE_FN
operator||
literal|2
block|,
name|NULL
block|,
name|tisystem
block|}
block|,
block|{
literal|"alias"
block|,
name|CMDTABTYPE_FN
operator||
literal|2
block|,
name|NULL
block|,
name|tialias
block|}
block|,
block|{
literal|"alternate"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|tialternate
block|}
block|,
block|{
literal|"default-alternates"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|fIdefault_alternates
block|,
name|NULL
block|}
block|,
block|{
literal|"time"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|titime
block|}
block|,
block|{
literal|"timegrade"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|ztime
block|,
name|titimegrade
block|}
block|,
block|{
literal|"call-timegrade"
block|,
name|CMDTABTYPE_FN
operator||
literal|3
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zcalltimegrade
block|,
name|titimegrade
block|}
block|,
block|{
literal|"call-local-size"
block|,
name|CMDTABTYPE_FN
operator||
literal|3
block|,
name|NULL
block|,
name|ticall_local_size
block|}
block|,
block|{
literal|"call-remote-size"
block|,
name|CMDTABTYPE_FN
operator||
literal|3
block|,
name|NULL
block|,
name|ticall_remote_size
block|}
block|,
block|{
literal|"called-local-size"
block|,
name|CMDTABTYPE_FN
operator||
literal|3
block|,
name|NULL
block|,
name|ticalled_local_size
block|}
block|,
block|{
literal|"called-remote-size"
block|,
name|CMDTABTYPE_FN
operator||
literal|3
block|,
name|NULL
block|,
name|ticalled_remote_size
block|}
block|,
block|{
literal|"timetable"
block|,
name|CMDTABTYPE_FN
operator||
literal|3
block|,
name|NULL
block|,
name|titimetable
block|}
block|,
block|{
literal|"baud"
block|,
name|CMDTABTYPE_LONG
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|ibaud
block|,
name|NULL
block|}
block|,
block|{
literal|"speed"
block|,
name|CMDTABTYPE_LONG
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|ibaud
block|,
name|NULL
block|}
block|,
block|{
literal|"port"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|tiport
block|}
block|,
block|{
literal|"phone"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zphone
block|,
name|NULL
block|}
block|,
block|{
literal|"address"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zphone
block|,
name|NULL
block|}
block|,
block|{
literal|"chat"
block|,
name|CMDTABTYPE_PREFIX
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|schat
block|,
name|tichat
block|}
block|,
block|{
literal|"call-login"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zcall_login
block|,
name|NULL
block|}
block|,
block|{
literal|"call-password"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zcall_password
block|,
name|NULL
block|}
block|,
block|{
literal|"called-login"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|ticalled_login
block|}
block|,
block|{
literal|"callback"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|fcallback
block|,
name|NULL
block|}
block|,
block|{
literal|"sequence"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|fsequence
block|,
name|NULL
block|}
block|,
block|{
literal|"protocol"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zprotocols
block|,
name|NULL
block|}
block|,
block|{
literal|"protocol-parameter"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|tiproto_param
block|}
block|,
block|{
literal|"called-chat"
block|,
name|CMDTABTYPE_PREFIX
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|scalled_chat
block|,
name|tichat
block|}
block|,
if|#
directive|if
name|DEBUG
operator|>
literal|1
block|{
literal|"debug"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|idebug
block|,
name|tidebug_parse
block|}
block|,
block|{
literal|"max-remote-debug"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|imax_remote_debug
block|,
name|tidebug_parse
block|}
block|,
endif|#
directive|endif
block|{
literal|"call-request"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|fcall_request
block|,
name|NULL
block|}
block|,
block|{
literal|"called-request"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|fcalled_request
block|,
name|NULL
block|}
block|,
block|{
literal|"request"
block|,
name|CMDTABTYPE_FN
operator||
literal|2
block|,
name|NULL
block|,
name|tirequest
block|}
block|,
block|{
literal|"call-transfer"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|fcall_transfer
block|,
name|NULL
block|}
block|,
block|{
literal|"called-transfer"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|fcalled_transfer
block|,
name|NULL
block|}
block|,
block|{
literal|"transfer"
block|,
name|CMDTABTYPE_FN
operator||
literal|2
block|,
name|NULL
block|,
name|titransfer
block|}
block|,
block|{
literal|"local-send"
block|,
name|CMDTABTYPE_FULLSTRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zlocal_send
block|,
name|NULL
block|}
block|,
block|{
literal|"remote-send"
block|,
name|CMDTABTYPE_FULLSTRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zremote_send
block|,
name|NULL
block|}
block|,
block|{
literal|"local-receive"
block|,
name|CMDTABTYPE_FULLSTRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zlocal_receive
block|,
name|NULL
block|}
block|,
block|{
literal|"remote-receive"
block|,
name|CMDTABTYPE_FULLSTRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zremote_receive
block|,
name|NULL
block|}
block|,
block|{
literal|"command-path"
block|,
name|CMDTABTYPE_FULLSTRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zpath
block|,
name|NULL
block|}
block|,
block|{
literal|"commands"
block|,
name|CMDTABTYPE_FULLSTRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zcmds
block|,
name|NULL
block|}
block|,
block|{
literal|"free-space"
block|,
name|CMDTABTYPE_LONG
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|cfree_space
block|,
name|NULL
block|}
block|,
block|{
literal|"forwardto"
block|,
name|CMDTABTYPE_FULLSTRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zforwardto
block|,
name|NULL
block|}
block|,
block|{
literal|"forward-to"
block|,
name|CMDTABTYPE_FULLSTRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zforwardto
block|,
name|NULL
block|}
block|,
block|{
literal|"pubdir"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zpubdir
block|,
name|NULL
block|}
block|,
block|{
literal|"myname"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|zlocalname
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This is called for the first line of each file.  It clears the    defaults, so that each file has a different set.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|ticlear
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|fIfirst
operator|=
name|TRUE
expr_stmt|;
return|return
name|CMDTABRET_FREE_AND_EXIT
return|;
block|}
end_function

begin_comment
comment|/* Process the system command.  We store away the system name and exit    out of processing commands to let the main loop handle it.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tisystem
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
comment|/* System names may only contain alphanumeric characters,      underscores, dashes and dots, and they may not begin with a dot,      at least for now.  */
for|for
control|(
name|z
operator|=
name|argv
index|[
literal|1
index|]
init|;
operator|*
name|z
operator|!=
literal|'\0'
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
operator|&&
operator|*
name|z
operator|!=
literal|'_'
operator|&&
operator|*
name|z
operator|!=
literal|'-'
operator|&&
operator|(
operator|*
name|z
operator|!=
literal|'.'
operator|||
name|z
operator|==
name|argv
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s %s: Illegal character in system name"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|>
name|cSysdep_max_name_len
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"System name \"%s\" too long (max %d)"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|cSysdep_max_name_len
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
name|zInext_system
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_CONFIG
argument_list|,
literal|"tisystem: Reading system %s"
argument_list|,
name|zInext_system
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_EXIT
return|;
block|}
end_function

begin_comment
comment|/* Process the alias command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tialias
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
if|if
condition|(
name|fIclear_alias
condition|)
block|{
name|sIhold
operator|.
name|zalias
operator|=
name|NULL
expr_stmt|;
name|fIclear_alias
operator|=
name|FALSE
expr_stmt|;
block|}
name|uadd_string
argument_list|(
operator|&
name|sIhold
operator|.
name|zalias
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_comment
comment|/* Process the alternate command.  The current information is in    sIhold.  We link this onto a chain of alternates starting at    sIalternate.  We then set up sIhold with the defaults for the next    alternate.  qIalternates holds the list of alternates for the    file-wide defaults, and we use to set up sIhold.  We also call    uiset_clear to set all the fIclear_* variables so that commands    like ``time'' know that they should ignore any existing entry.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ssysteminfo
name|sIalternate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tialternate
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
if|if
condition|(
name|fIclear_alternate
condition|)
block|{
name|sIalternate
operator|=
name|sIhold
expr_stmt|;
name|fIclear_alternate
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ssysteminfo
modifier|*
name|qnew
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
modifier|*
name|pq
decl_stmt|;
name|qnew
operator|=
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|qnew
operator|=
name|sIhold
expr_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|sIalternate
operator|.
name|qalternate
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qalternate
control|)
empty_stmt|;
operator|*
name|pq
operator|=
name|qnew
expr_stmt|;
name|sIhold
operator|=
name|sIalternate
expr_stmt|;
name|sIhold
operator|.
name|qalternate
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Clear the name of the next alternate.  */
name|sIhold
operator|.
name|zalternate
operator|=
name|NULL
expr_stmt|;
comment|/* Now, if there is a default alternate to base this on, we must      override everything not changed before the first ``alternate''      command to the default alternate.  */
if|if
condition|(
name|fIdefault_alternates
operator|&&
name|qIalternates
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qIalternates
operator|->
name|zalternate
operator|!=
name|NULL
condition|)
name|sIhold
operator|.
name|zalternate
operator|=
name|qIalternates
operator|->
name|zalternate
expr_stmt|;
define|#
directive|define
name|TEST
parameter_list|(
name|x
parameter_list|)
define|\
value|if (sIhold.x == sIdefault.x) \ 	sIhold.x = qIalternates->x;
name|TEST
argument_list|(
name|ztime
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcalltimegrade
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcall_local_size
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcall_remote_size
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcalled_local_size
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcalled_remote_size
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|ibaud
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zport
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|qport
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zphone
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|schat
operator|.
name|zchat
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|schat
operator|.
name|zprogram
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|schat
operator|.
name|ctimeout
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|schat
operator|.
name|zfail
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcall_login
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcalled_login
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|fcallback
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zprotocols
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|cproto_params
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|qproto_params
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|scalled_chat
operator|.
name|zchat
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|scalled_chat
operator|.
name|zprogram
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|scalled_chat
operator|.
name|ctimeout
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|scalled_chat
operator|.
name|zfail
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|TEST
argument_list|(
name|idebug
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|imax_remote_debug
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TEST
argument_list|(
name|fcall_request
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|fcalled_request
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|fcall_transfer
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|fcalled_transfer
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zlocal_send
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcalled_local_send
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zremote_send
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcalled_remote_send
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zlocal_receive
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcalled_local_receive
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zremote_receive
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcalled_remote_receive
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zpath
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zcmds
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|cfree_space
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zforwardto
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zpubdir
argument_list|)
expr_stmt|;
name|TEST
argument_list|(
name|zlocalname
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|TEST
name|qIalternates
operator|=
name|qIalternates
operator|->
name|qalternate
expr_stmt|;
block|}
comment|/* If there is a name for this alternate, put it in.  */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|sIhold
operator|.
name|zalternate
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|uiset_clear
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_comment
comment|/* Process the time command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|titime
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|char
modifier|*
name|pznew
index|[
literal|4
index|]
decl_stmt|;
name|char
name|ab
index|[
literal|2
index|]
decl_stmt|;
name|pznew
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|ab
index|[
literal|0
index|]
operator|=
literal|'z'
expr_stmt|;
name|ab
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pznew
index|[
literal|1
index|]
operator|=
name|ab
expr_stmt|;
name|pznew
index|[
literal|2
index|]
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|pznew
index|[
literal|3
index|]
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
return|return
name|titimegrade
argument_list|(
name|argc
operator|+
literal|1
argument_list|,
name|pznew
argument_list|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|ztime
argument_list|,
name|zerr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process the timegrade and the call-timegrade commands.  */
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|titimegrade
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|pztime
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|pvar
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
operator|||
name|argc
operator|>
literal|4
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Wrong number of arguments"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|||
operator|!
name|FGRADE_LEGAL
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Illegal grade '%s'"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
comment|/* We should probably check whether the time string is legal.  A      timegrade string is a single character grade, then a time string,      then an optional semicolon and a retry time.  */
name|clen
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
name|clen
operator|+=
name|strlen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|z
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
argument_list|)
expr_stmt|;
operator|*
name|z
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|z
operator|+
literal|1
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|strcat
argument_list|(
name|z
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|z
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pztime
operator|==
operator|&
name|sIhold
operator|.
name|ztime
condition|)
block|{
if|if
condition|(
name|fIclear_time
condition|)
block|{
operator|*
name|pztime
operator|=
name|NULL
expr_stmt|;
name|fIclear_time
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fIclear_calltimegrade
condition|)
block|{
operator|*
name|pztime
operator|=
name|NULL
expr_stmt|;
name|fIclear_calltimegrade
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|uadd_string
argument_list|(
name|pztime
argument_list|,
name|z
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_comment
comment|/* Add a size command.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|tcmdtabret
name|tiadd_size
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|,
name|boolean
operator|*
name|pf
operator|,
name|char
operator|*
operator|*
name|pz
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tiadd_size
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|zerr
parameter_list|,
name|pf
parameter_list|,
name|pz
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|boolean
modifier|*
name|pf
decl_stmt|;
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
block|{
name|long
name|cbytes
decl_stmt|;
name|char
modifier|*
name|zend
decl_stmt|;
name|char
modifier|*
name|zarg
decl_stmt|;
name|cbytes
operator|=
name|strtol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zend
operator|!=
literal|'\0'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Bad number"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
comment|/* We should check the legality of the time string here.  */
if|if
condition|(
operator|*
name|pf
condition|)
block|{
operator|*
name|pz
operator|=
name|NULL
expr_stmt|;
operator|*
name|pf
operator|=
name|FALSE
expr_stmt|;
block|}
name|zarg
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zarg
argument_list|,
literal|"%ld %s"
argument_list|,
name|cbytes
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|uadd_string
argument_list|(
name|pz
argument_list|,
name|zarg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_comment
comment|/* Process the call-local-size command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|ticall_local_size
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
return|return
name|tiadd_size
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|zerr
argument_list|,
operator|&
name|fIclear_call_local_size
argument_list|,
operator|&
name|sIhold
operator|.
name|zcall_local_size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process the call-remote-size command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|ticall_remote_size
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
return|return
name|tiadd_size
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|zerr
argument_list|,
operator|&
name|fIclear_call_remote_size
argument_list|,
operator|&
name|sIhold
operator|.
name|zcall_remote_size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process the called-local-size command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|ticalled_local_size
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
return|return
name|tiadd_size
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|zerr
argument_list|,
operator|&
name|fIclear_called_local_size
argument_list|,
operator|&
name|sIhold
operator|.
name|zcalled_local_size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process the called-remote-size command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|ticalled_remote_size
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
return|return
name|tiadd_size
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|zerr
argument_list|,
operator|&
name|fIclear_called_remote_size
argument_list|,
operator|&
name|sIhold
operator|.
name|zcalled_remote_size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process the timetable command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|titimetable
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|uaddtimetable
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* Process the port command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tiport
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Wrong number of arguments"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
if|if
condition|(
name|fIclear_port
condition|)
block|{
name|sIhold
operator|.
name|zport
operator|=
name|NULL
expr_stmt|;
name|sIhold
operator|.
name|qport
operator|=
name|NULL
expr_stmt|;
name|fIclear_port
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|enum
name|tcmdtabret
name|tret
decl_stmt|;
if|if
condition|(
name|sIhold
operator|.
name|zport
operator|!=
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Ignoring port specification following port name"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
name|tret
operator|=
name|tprocess_port_cmd
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
operator|(
name|pointer
operator|)
operator|&
name|sIhold
operator|.
name|qport
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sIhold
operator|.
name|qport
operator|!=
name|NULL
operator|&&
name|sIhold
operator|.
name|qport
operator|->
name|zname
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|zname
decl_stmt|;
if|if
condition|(
name|sIhold
operator|.
name|zname
operator|==
name|NULL
condition|)
name|sIhold
operator|.
name|qport
operator|->
name|zname
operator|=
literal|"default system file port"
expr_stmt|;
else|else
block|{
name|zname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|sIhold
operator|.
name|zname
argument_list|)
operator|+
sizeof|sizeof
expr|"system  port"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zname
argument_list|,
literal|"system %s port"
argument_list|,
name|sIhold
operator|.
name|zname
argument_list|)
expr_stmt|;
name|sIhold
operator|.
name|qport
operator|->
name|zname
operator|=
name|xstrdup
argument_list|(
name|zname
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|sIhold
operator|.
name|qport
operator|!=
name|NULL
condition|)
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_CONFIG
argument_list|,
literal|"tiport: Command %s to port %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|sIhold
operator|.
name|qport
operator|->
name|zname
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|tret
return|;
block|}
else|else
block|{
if|if
condition|(
name|sIhold
operator|.
name|qport
operator|!=
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Ignoring port name following port specification"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
name|sIhold
operator|.
name|zport
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
return|return
name|CMDTABRET_CONTINUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Process one of the chat commands.  We have a special version for    systems just so that we clear out the chat failure strings.  It    would be nice if there were a cleaner way to do this.  */
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tichat
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"chat-fail"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fIclear_chat_fail
condition|)
block|{
name|sIhold
operator|.
name|schat
operator|.
name|zfail
operator|=
name|NULL
expr_stmt|;
name|fIclear_chat_fail
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"called-chat-fail"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fIclear_called_chat_fail
condition|)
block|{
name|sIhold
operator|.
name|scalled_chat
operator|.
name|zfail
operator|=
name|NULL
expr_stmt|;
name|fIclear_called_chat_fail
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
name|tprocess_chat_cmd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|pvar
argument_list|,
name|zerr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process the called-login command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|ticalled_login
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Wrong number of arguments"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
name|sIhold
operator|.
name|zcalled_login
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|uadd_validate
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|argc
operator|-
literal|2
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|argv
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* Process the protocol parameter command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tiproto_param
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
if|if
condition|(
name|fIclear_proto_param
condition|)
block|{
name|sIhold
operator|.
name|cproto_params
operator|=
literal|0
expr_stmt|;
name|sIhold
operator|.
name|qproto_params
operator|=
name|NULL
expr_stmt|;
name|fIclear_proto_param
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|tadd_proto_param
argument_list|(
operator|&
name|sIhold
operator|.
name|cproto_params
argument_list|,
operator|&
name|sIhold
operator|.
name|qproto_params
argument_list|,
name|zerr
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process the request command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tirequest
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|char
name|b
decl_stmt|;
name|boolean
name|fset
decl_stmt|;
name|b
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|'y'
operator|||
name|b
operator|==
literal|'Y'
operator|||
name|b
operator|==
literal|'t'
operator|||
name|b
operator|==
literal|'T'
condition|)
name|fset
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
literal|'n'
operator|||
name|b
operator|==
literal|'N'
operator|||
name|b
operator|==
literal|'f'
operator|||
name|b
operator|==
literal|'F'
condition|)
name|fset
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: %s: Bad boolean"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
name|sIhold
operator|.
name|fcall_request
operator|=
name|fset
expr_stmt|;
name|sIhold
operator|.
name|fcalled_request
operator|=
name|fset
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_comment
comment|/* Process the transfer command.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|titransfer
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|char
name|b
decl_stmt|;
name|boolean
name|fset
decl_stmt|;
name|b
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|'y'
operator|||
name|b
operator|==
literal|'Y'
operator|||
name|b
operator|==
literal|'t'
operator|||
name|b
operator|==
literal|'T'
condition|)
name|fset
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
literal|'n'
operator|||
name|b
operator|==
literal|'N'
operator|||
name|b
operator|==
literal|'f'
operator|||
name|b
operator|==
literal|'F'
condition|)
name|fset
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: %s: Bad boolean"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
name|sIhold
operator|.
name|fcall_transfer
operator|=
name|fset
expr_stmt|;
name|sIhold
operator|.
name|fcalled_transfer
operator|=
name|fset
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_comment
comment|/* Mark all the contents of sIhold to be cleared before they are set.    If the falternate argument is TRUE, then only prepare to clear    those contents that should be cleared for an alternate.  */
end_comment

begin_function
specifier|static
name|void
name|uiset_clear
parameter_list|(
name|falternate
parameter_list|)
name|boolean
name|falternate
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|falternate
condition|)
block|{
name|fIclear_alias
operator|=
name|TRUE
expr_stmt|;
name|fIclear_alternate
operator|=
name|TRUE
expr_stmt|;
block|}
name|fIclear_time
operator|=
name|TRUE
expr_stmt|;
name|fIclear_calltimegrade
operator|=
name|TRUE
expr_stmt|;
name|fIclear_call_local_size
operator|=
name|TRUE
expr_stmt|;
name|fIclear_call_remote_size
operator|=
name|TRUE
expr_stmt|;
name|fIclear_called_local_size
operator|=
name|TRUE
expr_stmt|;
name|fIclear_called_remote_size
operator|=
name|TRUE
expr_stmt|;
name|fIclear_port
operator|=
name|TRUE
expr_stmt|;
name|fIclear_chat_fail
operator|=
name|TRUE
expr_stmt|;
name|fIclear_proto_param
operator|=
name|TRUE
expr_stmt|;
name|fIclear_called_chat_fail
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TAYLOR_CONFIG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Set up the default values advertised in the documentation.  */
end_comment

begin_function
name|void
name|uset_system_defaults
parameter_list|(
name|qsys
parameter_list|)
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
block|{
name|qsys
operator|->
name|zname
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zalias
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|qalternate
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zalternate
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|ztime
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
sizeof|sizeof
expr|"Never"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|qsys
operator|->
name|ztime
argument_list|,
literal|"%cNever"
argument_list|,
name|BGRADE_LOW
argument_list|)
expr_stmt|;
name|qsys
operator|->
name|zcalltimegrade
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zcall_local_size
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zcall_remote_size
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zcalled_local_size
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zcalled_remote_size
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|ibaud
operator|=
literal|0L
expr_stmt|;
name|qsys
operator|->
name|ihighbaud
operator|=
literal|0L
expr_stmt|;
name|qsys
operator|->
name|zport
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zphone
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|qport
operator|=
name|NULL
expr_stmt|;
name|INIT_CHAT
argument_list|(
operator|&
name|qsys
operator|->
name|schat
argument_list|)
expr_stmt|;
name|qsys
operator|->
name|schat
operator|.
name|zchat
operator|=
operator|(
name|char
operator|*
operator|)
literal|"\"\" \\r\\c ogin:-BREAK-ogin:-BREAK-ogin: \\L word: \\P"
expr_stmt|;
name|qsys
operator|->
name|schat
operator|.
name|ctimeout
operator|=
literal|10
expr_stmt|;
name|qsys
operator|->
name|zcall_login
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zcall_password
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zcalled_login
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|fcallback
operator|=
name|FALSE
expr_stmt|;
name|qsys
operator|->
name|fsequence
operator|=
name|FALSE
expr_stmt|;
name|qsys
operator|->
name|zprotocols
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|cproto_params
operator|=
literal|0
expr_stmt|;
name|qsys
operator|->
name|qproto_params
operator|=
name|NULL
expr_stmt|;
name|INIT_CHAT
argument_list|(
operator|&
name|qsys
operator|->
name|scalled_chat
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|qsys
operator|->
name|idebug
operator|=
literal|0
expr_stmt|;
name|qsys
operator|->
name|imax_remote_debug
operator|=
name|DEBUG_ABNORMAL
operator||
name|DEBUG_CHAT
operator||
name|DEBUG_HANDSHAKE
expr_stmt|;
endif|#
directive|endif
name|qsys
operator|->
name|fcall_request
operator|=
name|TRUE
expr_stmt|;
name|qsys
operator|->
name|fcalled_request
operator|=
name|TRUE
expr_stmt|;
name|qsys
operator|->
name|fcall_transfer
operator|=
name|TRUE
expr_stmt|;
name|qsys
operator|->
name|fcalled_transfer
operator|=
name|TRUE
expr_stmt|;
name|qsys
operator|->
name|zlocal_send
operator|=
name|ZROOTDIR
expr_stmt|;
name|qsys
operator|->
name|zcalled_local_send
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zremote_send
operator|=
literal|"~"
expr_stmt|;
name|qsys
operator|->
name|zcalled_remote_send
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zlocal_receive
operator|=
literal|"~"
expr_stmt|;
name|qsys
operator|->
name|zcalled_local_receive
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zremote_receive
operator|=
literal|"~"
expr_stmt|;
name|qsys
operator|->
name|zcalled_remote_receive
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zpath
operator|=
name|CMDPATH
expr_stmt|;
name|qsys
operator|->
name|zcmds
operator|=
literal|"rnews rmail"
expr_stmt|;
name|qsys
operator|->
name|cfree_space
operator|=
name|DEFAULT_FREE_SPACE
expr_stmt|;
name|qsys
operator|->
name|zforwardto
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zpubdir
operator|=
name|NULL
expr_stmt|;
name|qsys
operator|->
name|zlocalname
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Variables to store the loaded system information.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fIhave_systems
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cIsystems
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ssysteminfo
modifier|*
name|pasIsystems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read information about all systems.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|uiread_systems
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|uiread_systems
parameter_list|()
block|{
if|if
condition|(
name|fIhave_systems
condition|)
return|return;
name|fIhave_systems
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
if|if
condition|(
name|zSysfile
operator|==
name|NULL
condition|)
block|{
name|boolean
name|fmore
decl_stmt|;
comment|/* Only warn about a missing file if we aren't going to read the 	 V2 or BNU files.  */
name|fmore
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
name|HAVE_V2_CONFIG
if|if
condition|(
name|fV2
condition|)
name|fmore
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_BNU_CONFIG
if|if
condition|(
name|fBnu
condition|)
name|fmore
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fmore
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s%s: file not found"
argument_list|,
name|NEWCONFIGLIB
argument_list|,
name|SYSFILE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|struct
name|smulti_file
modifier|*
name|qmulti
decl_stmt|;
name|int
name|calc
decl_stmt|;
name|boolean
name|fdefaults
decl_stmt|,
name|fsystem
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|qalternates
decl_stmt|;
name|qmulti
operator|=
name|qmulti_open
argument_list|(
name|zSysfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|qmulti
operator|!=
name|NULL
condition|)
block|{
name|calc
operator|=
literal|0
expr_stmt|;
name|fdefaults
operator|=
name|FALSE
expr_stmt|;
name|fsystem
operator|=
name|FALSE
expr_stmt|;
name|qalternates
operator|=
name|NULL
expr_stmt|;
name|fIfirst
operator|=
name|FALSE
expr_stmt|;
name|zInext_system
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|qIalternates
operator|=
name|qalternates
expr_stmt|;
name|fIdefault_alternates
operator|=
name|TRUE
expr_stmt|;
comment|/* Read commands.  This will exit when it encounters the 		 start of a file (which it will when we first start 		 reading) and when it reads a ``system'' command.  */
name|uprocesscmds
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|,
name|qmulti
argument_list|,
name|asIcmds
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CMDFLAG_WARNUNRECOG
operator||
name|CMDFLAG_BACKSLASH
argument_list|)
expr_stmt|;
comment|/* The handling of alternates can get complex.  Before 		 we start reading a system, fIclear_alternate is set 		 to TRUE (this is done in uiset_clear).  After we have 		 finished reading a system, then if fIclear_alternate 		 is still TRUE then no ``alternate'' command was used 		 and the system information is in sIhold.  Otherwise, 		 if fIclear_alternate is FALSE, an ``alternate'' 		 command was used and we must call tialternate one 		 more time; after this final call to tialternate, the 		 system information will be in sIalternate.  		 The final call to tialternate is needed because each 		 occurrence of the ``alternate'' command links the 		 previous alternate into sIalternate and sets up 		 sIhold with the defaults for the next alternate.  The 		 final call will link the last alternate into 		 sIalternate.  */
if|if
condition|(
name|fdefaults
condition|)
block|{
comment|/* We were reading default information.  Save it.  */
if|if
condition|(
name|fIclear_alternate
condition|)
name|sIdefault
operator|=
name|sIhold
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|tialternate
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
literal|"alternate"
argument_list|)
expr_stmt|;
name|sIdefault
operator|=
name|sIalternate
expr_stmt|;
block|}
name|qalternates
operator|=
name|sIdefault
operator|.
name|qalternate
expr_stmt|;
name|sIdefault
operator|.
name|qalternate
operator|=
name|NULL
expr_stmt|;
name|fdefaults
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fsystem
condition|)
block|{
comment|/* We just either finished a file or encountered a 		     ``system'' command after we had started reading a 		     system.  Finish up the information for the system 		     we were reading.  */
if|if
condition|(
name|cIsystems
operator|>=
name|calc
condition|)
block|{
name|calc
operator|+=
literal|10
expr_stmt|;
name|pasIsystems
operator|=
operator|(
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pasIsystems
argument_list|,
name|calc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* We must now attach any remaining default 		     alternates.  */
if|if
condition|(
name|fIdefault_alternates
condition|)
block|{
while|while
condition|(
name|qIalternates
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|tialternate
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
literal|"alternate"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fIclear_alternate
condition|)
name|pasIsystems
index|[
name|cIsystems
index|]
operator|=
name|sIhold
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|tialternate
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
literal|"alternate"
argument_list|)
expr_stmt|;
name|pasIsystems
index|[
name|cIsystems
index|]
operator|=
name|sIalternate
expr_stmt|;
block|}
operator|++
name|cIsystems
expr_stmt|;
name|fsystem
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|fIfirst
condition|)
block|{
comment|/* We just started reading a new file.  Reset the 		     default information.  The next time around the 		     loop we will read the default information.  */
name|uset_system_defaults
argument_list|(
operator|&
name|sIhold
argument_list|)
expr_stmt|;
name|uiset_clear
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|qalternates
operator|=
name|NULL
expr_stmt|;
name|fdefaults
operator|=
name|TRUE
expr_stmt|;
name|fIfirst
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zInext_system
operator|!=
name|NULL
condition|)
block|{
comment|/* We just encountered a ``system'' command.  Save 		     the name, reset the system information to the 		     defaults, and go on to read the system 		     information.  */
name|sIhold
operator|=
name|sIdefault
expr_stmt|;
name|sIhold
operator|.
name|zname
operator|=
name|zInext_system
expr_stmt|;
name|uiset_clear
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|fsystem
operator|=
name|TRUE
expr_stmt|;
name|zInext_system
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* We have reached the end of the files to read.  */
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fmulti_close
argument_list|(
name|qmulti
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
if|#
directive|if
name|HAVE_V2_CONFIG
if|if
condition|(
name|fV2
condition|)
block|{
name|int
name|cv2
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|pasv2
decl_stmt|;
name|uv2_read_systems
argument_list|(
operator|&
name|cv2
argument_list|,
operator|&
name|pasv2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv2
operator|>
literal|0
condition|)
block|{
name|pasIsystems
operator|=
operator|(
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pasIsystems
argument_list|,
operator|(
name|cIsystems
operator|+
name|cv2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|pasIsystems
operator|+
name|cIsystems
argument_list|,
name|pasv2
argument_list|,
name|cv2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
expr_stmt|;
name|cIsystems
operator|+=
name|cv2
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_V2_CONFIG */
if|#
directive|if
name|HAVE_BNU_CONFIG
if|if
condition|(
name|fBnu
condition|)
block|{
name|int
name|cbnu
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|pasbnu
decl_stmt|;
name|ubnu_read_systems
argument_list|(
operator|&
name|cbnu
argument_list|,
operator|&
name|pasbnu
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbnu
operator|>
literal|0
condition|)
block|{
name|pasIsystems
operator|=
operator|(
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pasIsystems
argument_list|,
operator|(
name|cIsystems
operator|+
name|cbnu
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|pasIsystems
operator|+
name|cIsystems
argument_list|,
name|pasbnu
argument_list|,
name|cbnu
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
expr_stmt|;
name|cIsystems
operator|+=
name|cbnu
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_BNU_CONFIG */
block|}
end_function

begin_comment
comment|/* Get information about all systems.  */
end_comment

begin_function
name|void
name|uread_all_system_info
parameter_list|(
name|pc
parameter_list|,
name|ppas
parameter_list|)
name|int
modifier|*
name|pc
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
modifier|*
name|ppas
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fIhave_systems
condition|)
name|uiread_systems
argument_list|()
expr_stmt|;
operator|*
name|pc
operator|=
name|cIsystems
expr_stmt|;
operator|*
name|ppas
operator|=
name|pasIsystems
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get information about a specific system.  */
end_comment

begin_function
name|boolean
name|fread_system_info
parameter_list|(
name|zsystem
parameter_list|,
name|qsys
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_CONFIG
argument_list|,
literal|"fread_system_info: Reading information for system %s"
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fIhave_systems
condition|)
name|uiread_systems
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cIsystems
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|z
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zsystem
argument_list|,
name|pasIsystems
index|[
name|i
index|]
operator|.
name|zname
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|qsys
operator|=
name|pasIsystems
index|[
name|i
index|]
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_CONFIG
argument_list|,
literal|"fread_system_info: Got information for system %s"
argument_list|,
name|qsys
operator|->
name|zname
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|z
operator|=
name|pasIsystems
index|[
name|i
index|]
operator|.
name|zalias
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
continue|continue;
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
modifier|*
name|znext
decl_stmt|;
name|znext
operator|=
name|z
operator|+
name|strcspn
argument_list|(
name|z
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zsystem
argument_list|,
name|z
argument_list|,
name|znext
operator|-
name|z
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|qsys
operator|=
name|pasIsystems
index|[
name|i
index|]
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_CONFIG
argument_list|,
literal|"fread_system_info: Got system %s"
argument_list|,
name|qsys
operator|->
name|zname
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|z
operator|=
name|znext
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|==
literal|' '
condition|)
operator|++
name|z
expr_stmt|;
else|else
break|break;
block|}
block|}
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_CONFIG
argument_list|,
literal|"fread_system_info: Could not find system %s"
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prepare to read commands defining unknown systems.  */
end_comment

begin_function
name|void
name|uiunknown_start
parameter_list|()
block|{
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|uset_system_defaults
argument_list|(
operator|&
name|sIhold
argument_list|)
expr_stmt|;
name|uiset_clear
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_TAYLOR_CONFIG */
name|uset_system_defaults
argument_list|(
operator|&
name|sUnknown
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_TAYLOR_CONFIG */
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
end_if

begin_comment
comment|/* Process a command defining unknown systems.  This is actually    called from the main configuration file, not the system file.  */
end_comment

begin_function
name|enum
name|tcmdtabret
name|tiunknown
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|fUnknown_ok
operator|=
name|TRUE
expr_stmt|;
return|return
name|tprocess_one_cmd
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|asIcmds
argument_list|,
name|zerr
argument_list|,
name|CMDFLAG_WARNUNRECOG
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TAYLOR_CONFIG */
end_comment

begin_comment
comment|/* Finish up after all commands defining unknwon systems.  */
end_comment

begin_function
name|void
name|uiunknown_end
parameter_list|()
block|{
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
if|if
condition|(
name|fUnknown_ok
condition|)
block|{
comment|/* Add the final alternate.  */
if|if
condition|(
name|fIclear_alternate
condition|)
name|sUnknown
operator|=
name|sIhold
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|tialternate
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|pointer
operator|)
name|NULL
argument_list|,
literal|"alternate"
argument_list|)
expr_stmt|;
name|sUnknown
operator|=
name|sIalternate
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the local system information.  Perhaps it would be    desirable to allow the user to customize this as well.  This is    called after the configuration file has been read in and the system    name has been determined.  Only a few elements of this structure    are ever actually used, probably just zname and zremote_receive.  */
end_comment

begin_function
name|void
name|uisetup_localsys
parameter_list|()
block|{
name|uset_system_defaults
argument_list|(
operator|&
name|sLocalsys
argument_list|)
expr_stmt|;
name|sLocalsys
operator|.
name|zname
operator|=
name|zLocalname
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Translate a system name into something we can use locally.  This should    be more intelligent than it is.  Right now we just truncate the name;    if this matches the name of another system, we reject the call.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ztranslate_system
parameter_list|(
name|zsystem
parameter_list|)
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|struct
name|ssysteminfo
name|s
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|zsystem
argument_list|)
operator|<=
name|cSysdep_max_name_len
condition|)
return|return
name|zsystem
return|;
name|z
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|cSysdep_max_name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|z
argument_list|,
name|zsystem
argument_list|,
name|cSysdep_max_name_len
argument_list|)
expr_stmt|;
name|z
index|[
name|cSysdep_max_name_len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fread_system_info
argument_list|(
name|z
argument_list|,
operator|&
name|s
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|z
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|z
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
end_if

begin_comment
comment|/* Get the login name and password for a system out of the call file.    The call file is simple a sequence of lines.  The first word on    each line is the system name, the second word is the login name,    and the third word is the password.  We read it using uprocesscmds,    since it's easy.  */
end_comment

begin_struct
struct|struct
name|silogpass
block|{
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzpass
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|enum
name|tcmdtabret
name|tilog_pass
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tilog_pass
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|struct
name|silogpass
modifier|*
name|q
init|=
operator|(
expr|struct
name|silogpass
operator|*
operator|)
name|pvar
decl_stmt|;
operator|*
name|q
operator|->
name|pzlog
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|q
operator|->
name|pzpass
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE_AND_EXIT
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TAYLOR_CONFIG */
end_comment

begin_comment
comment|/* Get the login name and password to use for a system.  */
end_comment

begin_function
name|boolean
name|fcallout_login
parameter_list|(
name|qsys
parameter_list|,
name|pzlog
parameter_list|,
name|pzpass
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzlog
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzpass
decl_stmt|;
block|{
operator|*
name|pzlog
operator|=
name|NULL
expr_stmt|;
operator|*
name|pzpass
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
block|{
name|struct
name|smulti_file
modifier|*
name|qmulti
decl_stmt|;
name|struct
name|scmdtab
name|as
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|silogpass
name|s
decl_stmt|;
name|qmulti
operator|=
name|qmulti_open
argument_list|(
name|zCallfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|qmulti
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|s
operator|.
name|pzlog
operator|=
name|pzlog
expr_stmt|;
name|s
operator|.
name|pzpass
operator|=
name|pzpass
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|zcmd
operator|=
name|qsys
operator|->
name|zname
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|itype
operator|=
name|CMDTABTYPE_FN
operator||
literal|3
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|pvar
operator|=
operator|(
name|pointer
operator|)
operator|&
name|s
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|ptfn
operator|=
name|tilog_pass
expr_stmt|;
name|as
index|[
literal|1
index|]
operator|.
name|zcmd
operator|=
name|NULL
expr_stmt|;
name|uprocesscmds
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|,
name|qmulti
argument_list|,
name|as
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CMDFLAG_BACKSLASH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fmulti_close
argument_list|(
name|qmulti
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
if|if
condition|(
operator|*
name|pzlog
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No call out login for system %s"
argument_list|,
name|qsys
operator|->
name|zname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
end_if

begin_comment
comment|/* Check whether a login name and password gathered by the UUCP program    itself are correct.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|tcmdtabret
name|ticheck_login
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|ticheck_login
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|pz
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|pvar
decl_stmt|;
operator|*
name|pz
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE_AND_EXIT
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TAYLOR_CONFIG */
end_comment

begin_function
name|boolean
name|fcheck_login
parameter_list|(
name|zuser
parameter_list|,
name|zpass
parameter_list|)
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
specifier|const
name|char
modifier|*
name|zpass
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|struct
name|smulti_file
modifier|*
name|qmulti
decl_stmt|;
name|struct
name|scmdtab
name|as
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|zfilepass
decl_stmt|;
name|boolean
name|fok
decl_stmt|;
if|if
condition|(
name|zPwdfile
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s%s: file not found"
argument_list|,
name|NEWCONFIGLIB
argument_list|,
name|PASSWDFILE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|qmulti
operator|=
name|qmulti_open
argument_list|(
name|zPwdfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|qmulti
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|zfilepass
operator|=
name|NULL
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|zcmd
operator|=
name|zuser
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|itype
operator|=
name|CMDTABTYPE_FN
operator||
literal|2
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|pvar
operator|=
operator|(
name|pointer
operator|)
operator|&
name|zfilepass
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|ptfn
operator|=
name|ticheck_login
expr_stmt|;
name|as
index|[
literal|1
index|]
operator|.
name|zcmd
operator|=
name|NULL
expr_stmt|;
name|uprocesscmds
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|,
name|qmulti
argument_list|,
name|as
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CMDFLAG_CASESIGNIFICANT
operator||
name|CMDFLAG_BACKSLASH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fmulti_close
argument_list|(
name|qmulti
argument_list|)
expr_stmt|;
name|fok
operator|=
name|zfilepass
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zfilepass
argument_list|,
name|zpass
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|zfilepass
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|zfilepass
argument_list|,
name|strlen
argument_list|(
name|zfilepass
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zfilepass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fok
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad login"
argument_list|)
expr_stmt|;
return|return
name|fok
return|;
else|#
directive|else
comment|/* HAVE_TAYLOR_CONFIG */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not compiled to accept logins"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
end_if

begin_comment
comment|/* Process a chat command.  These are done as prefix commands.  We set    it up such that argv[0] will contain the string "chat" and we must    look after that point to see what command to execute.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|schat_info
name|sChat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|tcmdtabret
name|tcchat_fail
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|scmdtab
name|asChatcmds
index|[]
init|=
block|{
block|{
literal|"chat"
block|,
name|CMDTABTYPE_FULLSTRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sChat
operator|.
name|zchat
block|,
name|NULL
block|}
block|,
block|{
literal|"chat-program"
block|,
name|CMDTABTYPE_FULLSTRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sChat
operator|.
name|zprogram
block|,
name|NULL
block|}
block|,
block|{
literal|"chat-timeout"
block|,
name|CMDTABTYPE_INT
block|,
operator|(
name|pointer
operator|)
operator|&
name|sChat
operator|.
name|ctimeout
block|,
name|NULL
block|}
block|,
block|{
literal|"chat-fail"
block|,
name|CMDTABTYPE_FN
operator||
literal|2
block|,
name|NULL
block|,
name|tcchat_fail
block|}
block|,
block|{
literal|"chat-seven-bit"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|sChat
operator|.
name|fstrip
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|enum
name|tcmdtabret
name|tprocess_chat_cmd
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|struct
name|schat_info
modifier|*
name|qchat
init|=
operator|(
expr|struct
name|schat_info
operator|*
operator|)
name|pvar
decl_stmt|;
name|char
modifier|*
name|zchat
decl_stmt|;
name|enum
name|tcmdtabret
name|t
decl_stmt|;
name|zchat
operator|=
name|strstr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"chat"
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|zchat
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"tprocess_chat_cmd: Can't happen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|argv
index|[
literal|0
index|]
operator|=
name|zchat
expr_stmt|;
name|sChat
operator|=
operator|*
name|qchat
expr_stmt|;
name|t
operator|=
name|tprocess_one_cmd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|asChatcmds
argument_list|,
name|zerr
argument_list|,
name|CMDFLAG_WARNUNRECOG
argument_list|)
expr_stmt|;
operator|*
name|qchat
operator|=
name|sChat
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Add a new chat failure string.  */
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tcchat_fail
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|uadd_string
argument_list|(
operator|&
name|sChat
operator|.
name|zfail
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TAYLOR_CONFIG */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
end_if

begin_comment
comment|/* Add a protocol parameter entry.  The pc parameter points to the    number of protocol parameter entries, and the pq parameter points    to the array of protocol parameters.  */
end_comment

begin_function
name|enum
name|tcmdtabret
name|tadd_proto_param
parameter_list|(
name|pc
parameter_list|,
name|pq
parameter_list|,
name|zerr
parameter_list|,
name|cargs
parameter_list|,
name|azargs
parameter_list|)
name|int
modifier|*
name|pc
decl_stmt|;
name|struct
name|sproto_param
modifier|*
modifier|*
name|pq
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|int
name|cargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|azargs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sproto_param
modifier|*
name|q
decl_stmt|;
name|int
name|ientry
decl_stmt|;
name|int
name|icopy
decl_stmt|;
if|if
condition|(
name|cargs
operator|<
literal|1
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: protocol-parameter: Not enough arguments"
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
if|if
condition|(
name|azargs
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: protocol-parameter: Protocol names are single characters"
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
name|q
operator|=
name|NULL
expr_stmt|;
name|ientry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|pq
operator|)
index|[
name|i
index|]
operator|.
name|bproto
operator|==
name|azargs
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
block|{
name|q
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
index|[
name|i
index|]
expr_stmt|;
name|ientry
operator|=
name|q
operator|->
name|centries
expr_stmt|;
operator|++
name|q
operator|->
name|centries
expr_stmt|;
name|q
operator|->
name|qentries
operator|=
operator|(
operator|(
expr|struct
name|sproto_param_entry
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|q
operator|->
name|qentries
argument_list|,
operator|(
name|q
operator|->
name|centries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sproto_param_entry
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
operator|*
name|pc
condition|)
block|{
operator|++
operator|(
operator|*
name|pc
operator|)
expr_stmt|;
operator|*
name|pq
operator|=
operator|(
operator|(
expr|struct
name|sproto_param
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
operator|*
name|pq
argument_list|,
operator|(
operator|*
name|pc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sproto_param
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
name|q
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
index|[
operator|*
name|pc
operator|-
literal|1
index|]
expr_stmt|;
name|q
operator|->
name|bproto
operator|=
name|azargs
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|q
operator|->
name|centries
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|qentries
operator|=
operator|(
operator|(
expr|struct
name|sproto_param_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sproto_param_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ientry
operator|=
literal|0
expr_stmt|;
block|}
name|q
operator|->
name|qentries
index|[
name|ientry
index|]
operator|.
name|cargs
operator|=
name|cargs
operator|-
literal|1
expr_stmt|;
name|q
operator|->
name|qentries
index|[
name|ientry
index|]
operator|.
name|azargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|cargs
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|icopy
operator|=
literal|0
init|;
name|icopy
operator|<
name|cargs
operator|-
literal|1
condition|;
name|icopy
operator|++
control|)
name|q
operator|->
name|qentries
index|[
name|ientry
index|]
operator|.
name|azargs
index|[
name|icopy
index|]
operator|=
name|azargs
index|[
name|icopy
operator|+
literal|1
index|]
expr_stmt|;
return|return
name|CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TAYLOR_CONFIG */
end_comment

begin_comment
comment|/* Apply some protocol parameters, given the current protocol.  */
end_comment

begin_function
name|void
name|uapply_proto_params
parameter_list|(
name|bproto
parameter_list|,
name|qcmds
parameter_list|,
name|c
parameter_list|,
name|pas
parameter_list|)
name|int
name|bproto
decl_stmt|;
name|struct
name|scmdtab
modifier|*
name|qcmds
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|sproto_param
modifier|*
name|pas
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sproto_param
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|q
operator|=
name|pas
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
operator|,
name|q
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|bproto
operator|==
operator|(
name|char
operator|)
name|bproto
condition|)
block|{
name|char
name|ab
index|[
sizeof|sizeof
expr|"g protocol parameters"]
expr_stmt|;
name|struct
name|sproto_param_entry
modifier|*
name|qentry
decl_stmt|;
name|int
name|ientry
decl_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%c protocol parameters"
argument_list|,
name|bproto
argument_list|)
expr_stmt|;
name|q
operator|=
operator|&
name|pas
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|ientry
operator|=
literal|0
operator|,
name|qentry
operator|=
operator|&
name|q
operator|->
name|qentries
index|[
literal|0
index|]
init|;
name|ientry
operator|<
name|q
operator|->
name|centries
condition|;
name|ientry
operator|++
operator|,
name|qentry
operator|++
control|)
operator|(
name|void
operator|)
name|tprocess_one_cmd
argument_list|(
name|qentry
operator|->
name|cargs
argument_list|,
name|qentry
operator|->
name|azargs
argument_list|,
name|qcmds
argument_list|,
name|ab
argument_list|,
name|CMDFLAG_WARNUNRECOG
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Maintain a list of systems which are permitted to log in using a    particular login name.  This is the VALIDATE entry from the BNU    Permissions file.  */
end_comment

begin_struct
specifier|static
struct|struct
name|svalidate
block|{
name|struct
name|svalidate
modifier|*
name|qnext
decl_stmt|;
specifier|const
name|char
modifier|*
name|zlogname
decl_stmt|;
name|int
name|cmachines
decl_stmt|;
specifier|const
name|char
modifier|*
name|azmachines
index|[
literal|1
index|]
decl_stmt|;
block|}
modifier|*
name|qIvalidate
struct|;
end_struct

begin_comment
comment|/* Add an entry to the validation list.  This assumes that it does not    have to copy the login name or the machine names.  It does copy the    array of machines names.  */
end_comment

begin_function
name|void
name|uadd_validate
parameter_list|(
name|zlogname
parameter_list|,
name|cmachines
parameter_list|,
name|pazmachines
parameter_list|)
specifier|const
name|char
modifier|*
name|zlogname
decl_stmt|;
name|int
name|cmachines
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pazmachines
decl_stmt|;
block|{
name|struct
name|svalidate
modifier|*
modifier|*
name|pq
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|qIvalidate
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|zlogname
argument_list|,
name|zlogname
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pq
operator|=
operator|(
operator|(
expr|struct
name|svalidate
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
operator|*
name|pq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|svalidate
argument_list|)
operator|+
operator|(
operator|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|cmachines
operator|+
name|cmachines
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|azmachines
operator|+
operator|(
operator|*
name|pq
operator|)
operator|->
name|cmachines
argument_list|,
name|pazmachines
argument_list|,
name|cmachines
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pq
operator|)
operator|->
name|cmachines
operator|+=
name|cmachines
expr_stmt|;
return|return;
block|}
block|}
name|q
operator|=
operator|(
expr|struct
name|svalidate
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|svalidate
argument_list|)
operator|+
operator|(
operator|(
name|cmachines
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|qnext
operator|=
name|qIvalidate
expr_stmt|;
name|q
operator|->
name|zlogname
operator|=
name|zlogname
expr_stmt|;
name|memcpy
argument_list|(
name|q
operator|->
name|azmachines
argument_list|,
name|pazmachines
argument_list|,
name|cmachines
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|cmachines
operator|=
name|cmachines
expr_stmt|;
name|qIvalidate
operator|=
name|q
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether a particular login name/machine name is valid.  */
end_comment

begin_function
name|boolean
name|fcheck_validate
parameter_list|(
name|zlogname
parameter_list|,
name|zmachine
parameter_list|)
specifier|const
name|char
modifier|*
name|zlogname
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmachine
decl_stmt|;
block|{
name|struct
name|svalidate
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|qIvalidate
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|qnext
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|q
operator|->
name|zlogname
argument_list|,
name|zlogname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|cmachines
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|q
operator|->
name|azmachines
index|[
name|i
index|]
argument_list|,
name|zmachine
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The variables which hold the array of timetables.  */
end_comment

begin_decl_stmt
name|int
name|cTtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stimetable
modifier|*
name|pasTtable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the table of timetables as advertised in the    documentation.  */
end_comment

begin_function
name|void
name|uinittimetables
parameter_list|()
block|{
name|pasTtable
operator|=
operator|(
expr|struct
name|stimetable
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stimetable
argument_list|)
argument_list|)
expr_stmt|;
name|pasTtable
index|[
literal|0
index|]
operator|.
name|zname
operator|=
literal|"Evening"
expr_stmt|;
name|pasTtable
index|[
literal|0
index|]
operator|.
name|ztime
operator|=
literal|"Wk1705-0755,Sa,Su"
expr_stmt|;
name|pasTtable
index|[
literal|1
index|]
operator|.
name|zname
operator|=
literal|"Night"
expr_stmt|;
name|pasTtable
index|[
literal|1
index|]
operator|.
name|ztime
operator|=
literal|"Wk2305-0755,Sa,Su2305-1655"
expr_stmt|;
name|pasTtable
index|[
literal|2
index|]
operator|.
name|zname
operator|=
literal|"NonPeak"
expr_stmt|;
name|pasTtable
index|[
literal|2
index|]
operator|.
name|ztime
operator|=
literal|"Wk1805-0655,Sa,Su"
expr_stmt|;
name|cTtable
operator|=
literal|3
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new timetable entry.  This assumes it can take control of the    strings it is passed, so they must not be on the stack and if they    have been allocated they must not be freed.  */
end_comment

begin_function
name|void
name|uaddtimetable
parameter_list|(
name|zname
parameter_list|,
name|ztime
parameter_list|)
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztime
decl_stmt|;
block|{
if|if
condition|(
name|pasTtable
operator|==
name|NULL
condition|)
name|uinittimetables
argument_list|()
expr_stmt|;
name|pasTtable
operator|=
operator|(
operator|(
expr|struct
name|stimetable
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pasTtable
argument_list|,
operator|(
name|cTtable
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stimetable
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|pasTtable
index|[
name|cTtable
index|]
operator|.
name|zname
operator|=
name|zname
expr_stmt|;
name|pasTtable
index|[
name|cTtable
index|]
operator|.
name|ztime
operator|=
name|ztime
expr_stmt|;
operator|++
name|cTtable
expr_stmt|;
block|}
end_function

end_unit

