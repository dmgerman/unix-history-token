begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* chat.c    Chat routine for the UUCP package.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: chat.c,v $    Revision 1.26  1992/04/03  05:37:11  ian    Minor cleanups for gcc 2.1     Revision 1.25  1992/03/28  21:47:55  ian    David J. MacKenzie: allow backslash to quote newline in config files     Revision 1.24  1992/03/28  21:28:00  ian    David J. MacKenzie: handle empty subexpect strings correctly     Revision 1.23  1992/03/28  19:57:22  ian    David J. MacKenzie: send port device for /Y rather than port name     Revision 1.22  1992/03/17  01:03:03  ian    Miscellaneous cleanup     Revision 1.21  1992/03/16  21:21:59  ian    Scott Ballantyne: go ahead and send an illegal send script character     Revision 1.20  1992/03/16  00:47:15  ian    Turn off DEBUG_PORT for chat script debugging     Revision 1.19  1992/03/12  19:56:10  ian    Debugging based on types rather than number     Revision 1.18  1992/03/11  19:53:55  ian    Improved chat script debugging     Revision 1.17  1992/03/04  00:36:44  ian    Michael Richardson: better chat script debugging     Revision 1.16  1992/03/03  06:06:48  ian    T. William Wells: don't complain about missing configuration files     Revision 1.15  1992/02/19  19:36:07  ian    Rearranged time functions     Revision 1.14  1992/02/19  05:24:07  ian    Bob Denny: if no trailing send string, don't send a carriage return     Revision 1.13  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.12  1992/02/02  06:38:22  ian    Michael Nolan: chat script strings might be separated by more than just ' '     Revision 1.11  1992/01/05  03:11:06  ian    Made fcsend static     Revision 1.10  1991/12/28  03:49:23  ian    Added HAVE_MEMFNS and HAVE_BFNS; changed uses of memset to bzero     Revision 1.9  1991/12/17  23:14:08  ian    T. William Wells: allow dialer complete and abort to be chat scripts     Revision 1.8  1991/12/15  04:17:11  ian    Added chat-seven-bit command to control parity bit stripping     Revision 1.7  1991/12/15  03:42:33  ian    Added tprocess_chat_cmd for all chat commands, and added CMDTABTYPE_PREFIX     Revision 1.6  1991/12/13  04:27:33  ian    Franc,ois Pinard: add some chat script debugging messages     Revision 1.5  1991/12/07  17:58:38  ian    Handle a chat script with nothing but a send string     Revision 1.4  1991/12/06  21:10:27  ian    Franc,ois Pinard: ccescape should never return a negative number     Revision 1.3  1991/11/11  23:47:24  ian    Added chat-program to run a program to do a chat script     Revision 1.2  1991/11/11  19:32:03  ian    Added breceive_char to read characters through protocol buffering     Revision 1.1  1991/09/10  19:38:16  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|chat_rcsid
index|[]
init|=
literal|"$Id: chat.c,v 1.26 1992/04/03 05:37:11 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ccescape
name|P
argument_list|(
operator|(
name|char
operator|*
name|zbuf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icexpect
name|P
argument_list|(
operator|(
name|int
name|cstrings
operator|,
name|char
operator|*
operator|*
name|azstrings
operator|,
name|int
operator|*
name|aclens
operator|,
name|int
name|ctimeout
operator|,
name|boolean
name|fstrip
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcsend
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zsend
operator|,
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
specifier|const
expr|struct
name|sdialer
operator|*
name|qdial
operator|,
specifier|const
name|char
operator|*
name|zphone
operator|,
name|boolean
name|ftranslate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcecho_send
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|z
operator|,
name|int
name|clen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcphone
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|sdialer
operator|*
name|qdial
operator|,
specifier|const
name|char
operator|*
name|zphone
operator|,
name|boolean
argument_list|(
argument|*pfwrite
argument_list|)
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zwrite
operator|,
name|int
name|cwrite
operator|)
argument_list|)
operator|,
name|boolean
name|ftranslate
operator|,
name|boolean
operator|*
name|pfquote
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fctranslate
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zphone
operator|,
specifier|const
name|char
operator|*
operator|*
name|pzprefix
operator|,
specifier|const
name|char
operator|*
operator|*
name|pzsuffix
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcprogram
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zprogram
operator|,
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
specifier|const
expr|struct
name|sdialer
operator|*
name|qdial
operator|,
specifier|const
name|char
operator|*
name|zphone
operator|,
specifier|const
name|char
operator|*
name|zport
operator|,
name|long
name|ibaud
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Run a chat script with the other system.  The chat script is a    series of expect send pairs.  We wait for the expect string to show    up, and then we send the send string.  The chat string for a system    holds the expect and send strings separated by a single space.  */
end_comment

begin_function
name|boolean
name|fchat
parameter_list|(
name|qchat
parameter_list|,
name|qsys
parameter_list|,
name|qdial
parameter_list|,
name|zphone
parameter_list|,
name|ftranslate
parameter_list|,
name|zport
parameter_list|,
name|ibaud
parameter_list|)
specifier|const
name|struct
name|schat_info
modifier|*
name|qchat
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|struct
name|sdialer
modifier|*
name|qdial
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
name|boolean
name|ftranslate
decl_stmt|;
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zchat
decl_stmt|;
name|int
name|cstrings
decl_stmt|;
name|char
modifier|*
modifier|*
name|azstrings
decl_stmt|;
name|int
modifier|*
name|aclens
decl_stmt|;
name|char
modifier|*
name|zbuf
decl_stmt|;
comment|/* First run the program, if any.  */
if|if
condition|(
name|qchat
operator|->
name|zprogram
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fcprogram
argument_list|(
name|qchat
operator|->
name|zprogram
argument_list|,
name|qsys
argument_list|,
name|qdial
argument_list|,
name|zphone
argument_list|,
name|zport
argument_list|,
name|ibaud
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If there's no chat script, we're done.  */
if|if
condition|(
name|qchat
operator|->
name|zchat
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|zchat
operator|=
name|qchat
operator|->
name|zchat
expr_stmt|;
if|if
condition|(
name|qchat
operator|->
name|zfail
operator|==
name|NULL
condition|)
block|{
name|cstrings
operator|=
literal|1
expr_stmt|;
name|azstrings
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|aclens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zlook
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|,
modifier|*
name|z
decl_stmt|;
comment|/* We leave string number 0 for the chat script; after that 	 we want 1 more than the number of spaces in the chat_fail 	 string (the fencepost problem).  */
name|cstrings
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|zlook
operator|=
name|qchat
operator|->
name|zfail
init|;
operator|*
name|zlook
operator|!=
literal|'\0'
condition|;
name|zlook
operator|++
control|)
if|if
condition|(
operator|*
name|zlook
operator|==
literal|' '
condition|)
operator|++
name|cstrings
expr_stmt|;
name|azstrings
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|cstrings
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|aclens
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|cstrings
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|qchat
operator|->
name|zfail
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zcopy
argument_list|,
name|qchat
operator|->
name|zfail
argument_list|)
expr_stmt|;
comment|/* Get the strings into the array, and handle all the escape 	 characters.  */
name|cstrings
operator|=
literal|1
expr_stmt|;
name|azstrings
index|[
literal|1
index|]
operator|=
name|zcopy
expr_stmt|;
for|for
control|(
name|z
operator|=
name|zcopy
init|;
operator|*
name|z
operator|!=
literal|'\0'
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|z
operator|==
literal|' '
condition|)
block|{
operator|*
name|z
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|aclens
index|[
name|cstrings
index|]
operator|=
name|ccescape
argument_list|(
name|azstrings
index|[
name|cstrings
index|]
argument_list|)
expr_stmt|;
operator|++
name|cstrings
expr_stmt|;
name|azstrings
index|[
name|cstrings
index|]
operator|=
name|z
expr_stmt|;
block|}
block|}
name|aclens
index|[
name|cstrings
index|]
operator|=
name|ccescape
argument_list|(
name|azstrings
index|[
name|cstrings
index|]
argument_list|)
expr_stmt|;
operator|++
name|cstrings
expr_stmt|;
block|}
name|zbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zchat
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|zchat
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|cchatlen
decl_stmt|;
name|char
modifier|*
name|znext
decl_stmt|;
comment|/* Get this expect string into zbuf.  */
name|cchatlen
operator|=
name|strcspn
argument_list|(
name|zchat
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|zbuf
argument_list|,
name|zchat
argument_list|,
name|cchatlen
argument_list|)
expr_stmt|;
name|zbuf
index|[
name|cchatlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zchat
operator|+=
name|cchatlen
expr_stmt|;
name|zchat
operator|+=
name|strspn
argument_list|(
name|zchat
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
comment|/* Separate out the first subexpect string.  */
name|azstrings
index|[
literal|0
index|]
operator|=
name|zbuf
expr_stmt|;
name|znext
operator|=
name|strchr
argument_list|(
name|zbuf
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|znext
operator|!=
name|NULL
condition|)
operator|*
name|znext
operator|=
literal|'\0'
expr_stmt|;
name|aclens
index|[
literal|0
index|]
operator|=
name|ccescape
argument_list|(
name|azstrings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Loop over subexpects and subsends.  */
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
modifier|*
name|zsub
decl_stmt|;
if|if
condition|(
name|aclens
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|aclens
index|[
literal|0
index|]
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|azstrings
index|[
literal|0
index|]
argument_list|,
literal|"\"\""
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* There is no subexpect sequence.  If there is a 		 subsend sequence we move on to it.  Otherwise we let 		 this expect succeed.  This is somewhat inconsistent, 		 but it seems to be the traditional approach.  */
if|if
condition|(
name|znext
operator|==
name|NULL
condition|)
break|break;
block|}
else|else
block|{
name|int
name|istr
decl_stmt|;
name|istr
operator|=
name|icexpect
argument_list|(
name|cstrings
argument_list|,
name|azstrings
argument_list|,
name|aclens
argument_list|,
name|qchat
operator|->
name|ctimeout
argument_list|,
name|qchat
operator|->
name|fstrip
argument_list|)
expr_stmt|;
comment|/* If we found the string, break out of the 		 subexpect/subsend loop.  */
if|if
condition|(
name|istr
operator|==
literal|0
condition|)
break|break;
comment|/* If we got an error, return FALSE.  */
if|if
condition|(
name|istr
operator|<
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
comment|/* If we found a failure string, log it and get out.  */
if|if
condition|(
name|istr
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zfail
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|;
name|zfail
operator|=
name|qchat
operator|->
name|zfail
expr_stmt|;
for|for
control|(
operator|--
name|istr
init|;
name|istr
operator|>
literal|0
condition|;
operator|--
name|istr
control|)
name|zfail
operator|=
name|strchr
argument_list|(
name|zfail
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|clen
operator|=
name|strcspn
argument_list|(
name|zfail
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|zcopy
argument_list|,
name|zfail
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|zcopy
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Chat script failed: Got \"%s\""
argument_list|,
name|zcopy
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We timed out; look for a send subsequence.  If none, 		 the chat script has failed.  */
if|if
condition|(
name|znext
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Timed out in chat script"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Send the send subsequence.  A \"\" will send nothing.  An 	     empty string will send a carriage return.  */
operator|++
name|znext
expr_stmt|;
name|zsub
operator|=
name|znext
expr_stmt|;
name|znext
operator|=
name|strchr
argument_list|(
name|zsub
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|znext
operator|!=
name|NULL
condition|)
operator|*
name|znext
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|fcsend
argument_list|(
name|zsub
argument_list|,
name|qsys
argument_list|,
name|qdial
argument_list|,
name|zphone
argument_list|,
name|ftranslate
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If there is no expect subsequence, we are done.  */
if|if
condition|(
name|znext
operator|==
name|NULL
condition|)
break|break;
comment|/* Move on to next expect subsequence.  */
operator|++
name|znext
expr_stmt|;
name|azstrings
index|[
literal|0
index|]
operator|=
name|znext
expr_stmt|;
name|znext
operator|=
name|strchr
argument_list|(
name|azstrings
index|[
literal|0
index|]
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|znext
operator|!=
name|NULL
condition|)
operator|*
name|znext
operator|=
literal|'\0'
expr_stmt|;
name|aclens
index|[
literal|0
index|]
operator|=
name|ccescape
argument_list|(
name|azstrings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* We matched the expect string.  */
if|if
condition|(
operator|*
name|zchat
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
comment|/* Copy the send string into zbuf.  */
name|cchatlen
operator|=
name|strcspn
argument_list|(
name|zchat
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|zbuf
argument_list|,
name|zchat
argument_list|,
name|cchatlen
argument_list|)
expr_stmt|;
name|zbuf
index|[
name|cchatlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zchat
operator|+=
name|cchatlen
expr_stmt|;
name|zchat
operator|+=
name|strspn
argument_list|(
name|zchat
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zbuf
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|fcsend
argument_list|(
name|zbuf
argument_list|,
name|qsys
argument_list|,
name|qdial
argument_list|,
name|zphone
argument_list|,
name|ftranslate
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* The chat sequence has been completed.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Translate escape sequences within an expect string.  */
end_comment

begin_function
specifier|static
name|int
name|ccescape
parameter_list|(
name|z
parameter_list|)
name|char
modifier|*
name|z
decl_stmt|;
block|{
name|char
modifier|*
name|zto
decl_stmt|,
modifier|*
name|zfrom
decl_stmt|;
name|zto
operator|=
name|z
expr_stmt|;
name|zfrom
operator|=
name|z
expr_stmt|;
while|while
condition|(
operator|*
name|zfrom
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|zfrom
operator|!=
literal|'\\'
condition|)
block|{
operator|*
name|zto
operator|++
operator|=
operator|*
name|zfrom
operator|++
expr_stmt|;
continue|continue;
block|}
operator|++
name|zfrom
expr_stmt|;
switch|switch
condition|(
operator|*
name|zfrom
condition|)
block|{
case|case
literal|'b'
case|:
operator|*
name|zto
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|zto
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
operator|*
name|zto
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|zto
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|*
name|zto
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|zto
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
operator|--
name|zfrom
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'\\'
case|:
operator|*
name|zto
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|*
name|zfrom
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|zfrom
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|zfrom
index|[
literal|1
index|]
operator|<=
literal|'7'
condition|)
name|i
operator|=
literal|8
operator|*
name|i
operator|+
operator|*
operator|++
name|zfrom
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|zfrom
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|zfrom
index|[
literal|1
index|]
operator|<=
literal|'7'
condition|)
name|i
operator|=
literal|8
operator|*
name|i
operator|+
operator|*
operator|++
name|zfrom
operator|-
literal|'0'
expr_stmt|;
operator|*
name|zto
operator|++
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isxdigit
argument_list|(
name|BUCHAR
argument_list|(
name|zfrom
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
name|zfrom
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
name|i
operator|=
literal|16
operator|*
name|i
operator|+
operator|*
operator|++
name|zfrom
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|BUCHAR
argument_list|(
name|zfrom
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
name|i
operator|=
literal|16
operator|*
name|i
operator|+
operator|*
operator|++
name|zfrom
operator|-
literal|'A'
expr_stmt|;
else|else
name|i
operator|=
literal|16
operator|*
name|i
operator|+
operator|*
operator|++
name|zfrom
operator|-
literal|'a'
expr_stmt|;
block|}
operator|*
name|zto
operator|++
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
block|}
break|break;
default|default:
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Unrecognized escape sequence \\%c in expect string"
argument_list|,
operator|*
name|zfrom
argument_list|)
expr_stmt|;
operator|*
name|zto
operator|++
operator|=
operator|*
name|zfrom
expr_stmt|;
break|break;
block|}
operator|++
name|zfrom
expr_stmt|;
block|}
operator|*
name|zto
operator|=
literal|'\0'
expr_stmt|;
return|return
name|zto
operator|-
name|z
return|;
block|}
end_function

begin_comment
comment|/* Read characters and wait for one of a set of memory strings to come    in.  This returns the index into the array of the string that    arrives, or -1 on timeout, or -2 on error.  */
end_comment

begin_function
specifier|static
name|int
name|icexpect
parameter_list|(
name|cstrings
parameter_list|,
name|azstrings
parameter_list|,
name|aclens
parameter_list|,
name|ctimeout
parameter_list|,
name|fstrip
parameter_list|)
name|int
name|cstrings
decl_stmt|;
name|char
modifier|*
modifier|*
name|azstrings
decl_stmt|;
name|int
modifier|*
name|aclens
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
name|boolean
name|fstrip
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|cmin
decl_stmt|,
name|cmax
decl_stmt|;
name|char
modifier|*
name|zhave
decl_stmt|;
name|int
name|chave
decl_stmt|;
name|long
name|iendtime
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|int
name|cchars
decl_stmt|;
name|int
name|iolddebug
decl_stmt|;
endif|#
directive|endif
name|cmax
operator|=
name|cmin
operator|=
name|aclens
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cstrings
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmax
operator|<
name|aclens
index|[
name|i
index|]
condition|)
name|cmax
operator|=
name|aclens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cmin
operator|>
name|aclens
index|[
name|i
index|]
condition|)
name|cmin
operator|=
name|aclens
index|[
name|i
index|]
expr_stmt|;
block|}
name|zhave
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|cmax
argument_list|)
expr_stmt|;
name|chave
operator|=
literal|0
expr_stmt|;
name|iendtime
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
operator|+
name|ctimeout
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|cchars
operator|=
literal|0
expr_stmt|;
name|iolddebug
operator|=
name|iDebug
expr_stmt|;
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|udebug_buffer
argument_list|(
literal|"icexpect: Looking for"
argument_list|,
name|azstrings
index|[
literal|0
index|]
argument_list|,
name|aclens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"icexpect: Got \""
argument_list|)
expr_stmt|;
name|iDebug
operator|&=
operator|~
operator|(
name|DEBUG_INCOMING
operator||
name|DEBUG_PORT
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|bchar
decl_stmt|;
comment|/* If we have no more time, get out.  */
if|if
condition|(
name|ctimeout
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (timed out)"
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
comment|/* Read one character at a time.  We could use a more complex 	 algorithm to read in larger batches, but it's probably not 	 worth it.  If the buffer is full, shift it left; we already 	 know that no string matches, and the buffer holds the largest 	 string, so this can't lose a match.  */
if|if
condition|(
name|chave
operator|>=
name|cmax
condition|)
block|{
name|xmemmove
argument_list|(
name|zhave
argument_list|,
name|zhave
operator|+
literal|1
argument_list|,
name|cmax
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|--
name|chave
expr_stmt|;
block|}
comment|/* The timeout/error return values from breceive_char are the 	 same as for this function.  */
name|bchar
operator|=
name|breceive_char
argument_list|(
name|ctimeout
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bchar
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
comment|/* If there was an error, it will probably be logged in 		 the middle of our string, but this is only debugging 		 so it's not a big deal.  */
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (%s)"
argument_list|,
name|bchar
operator|==
operator|-
literal|1
condition|?
literal|"timed out"
else|:
literal|"error"
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|bchar
return|;
block|}
comment|/* Strip the parity bit if desired.  */
if|if
condition|(
name|fstrip
condition|)
name|bchar
operator|&=
literal|0x7f
expr_stmt|;
name|zhave
index|[
name|chave
index|]
operator|=
operator|(
name|char
operator|)
name|bchar
expr_stmt|;
operator|++
name|chave
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|char
name|ab
index|[
literal|5
index|]
decl_stmt|;
operator|++
name|cchars
expr_stmt|;
if|if
condition|(
name|cchars
operator|>
literal|60
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"icexpect: Got \""
argument_list|)
expr_stmt|;
name|cchars
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|cdebug_char
argument_list|(
name|ab
argument_list|,
name|bchar
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"%s"
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* See if any of the strings can be found in the buffer.  Since 	 we read one character at a time, the string can only be found 	 at the end of the buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cstrings
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aclens
index|[
name|i
index|]
operator|<=
name|chave
operator|&&
name|memcmp
argument_list|(
name|zhave
operator|+
name|chave
operator|-
name|aclens
index|[
name|i
index|]
argument_list|,
name|azstrings
index|[
name|i
index|]
argument_list|,
name|aclens
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\" (found it)"
argument_list|)
expr_stmt|;
else|else
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|udebug_buffer
argument_list|(
literal|"icexpect: Found"
argument_list|,
name|azstrings
index|[
name|i
index|]
argument_list|,
name|aclens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|iDebug
operator|=
name|iolddebug
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|i
return|;
block|}
block|}
name|ctimeout
operator|=
call|(
name|int
call|)
argument_list|(
name|iendtime
operator|-
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|DEBUG
operator|>
literal|1
end_if

begin_comment
comment|/* Debugging function for fcsend.  This takes the fquote variable, the    length of the string (0 if this an informational string which can    be printed directly) and the string itself.  It returns the new    value for fquote.  The fquote variable is TRUE if the debugging    output is in the middle of a quoted string.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cCsend_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iColddebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fcsend_debug
name|P
argument_list|(
operator|(
name|boolean
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|fcsend_debug
parameter_list|(
name|fquote
parameter_list|,
name|clen
parameter_list|,
name|zbuf
parameter_list|)
name|boolean
name|fquote
decl_stmt|;
name|int
name|clen
decl_stmt|;
specifier|const
name|char
modifier|*
name|zbuf
decl_stmt|;
block|{
name|int
name|cwas
decl_stmt|;
if|if
condition|(
operator|!
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|cwas
operator|=
name|cCsend_chars
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
name|cCsend_chars
operator|+=
name|clen
expr_stmt|;
else|else
name|cCsend_chars
operator|+=
name|strlen
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cCsend_chars
operator|>
literal|60
operator|&&
name|cwas
operator|>
literal|10
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"%s"
argument_list|,
name|fquote
condition|?
literal|"\""
else|:
literal|""
argument_list|)
expr_stmt|;
name|fquote
operator|=
name|FALSE
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"fcsend: Writing"
argument_list|)
expr_stmt|;
name|cCsend_chars
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|==
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"%s %s"
argument_list|,
name|fquote
condition|?
literal|"\""
else|:
literal|""
argument_list|,
name|zbuf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fquote
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|" \""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|clen
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ab
index|[
literal|5
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|cdebug_char
argument_list|(
name|ab
argument_list|,
name|zbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"%s"
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up the debugging information for fcsend.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ucsend_debug_end
name|P
argument_list|(
operator|(
name|boolean
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ucsend_debug_end
parameter_list|(
name|fquote
parameter_list|,
name|ferr
parameter_list|)
name|boolean
name|fquote
decl_stmt|;
name|boolean
name|ferr
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
return|return;
if|if
condition|(
name|fquote
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferr
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG_CONTINUE
argument_list|,
literal|" (error)"
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG_END
argument_list|,
literal|"%s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|iDebug
operator|=
name|iColddebug
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG<= 1 */
end_comment

begin_comment
comment|/* Use macro definitions to make fcsend look neater.  */
end_comment

begin_define
define|#
directive|define
name|fcsend_debug
parameter_list|(
name|fquote
parameter_list|,
name|clen
parameter_list|,
name|zbuf
parameter_list|)
value|TRUE
end_define

begin_define
define|#
directive|define
name|ucsend_debug_end
parameter_list|(
name|fquote
parameter_list|,
name|ferror
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG<= 1 */
end_comment

begin_comment
comment|/* Send a string out.  This has to parse escape sequences as it goes.    Note that it handles the dialer escape sequences (\e, \E, \D, \T)    although they make no sense for chatting with a system.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcsend
parameter_list|(
name|z
parameter_list|,
name|qsys
parameter_list|,
name|qdial
parameter_list|,
name|zphone
parameter_list|,
name|ftranslate
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|struct
name|sdialer
modifier|*
name|qdial
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
name|boolean
name|ftranslate
decl_stmt|;
block|{
name|boolean
name|fnocr
decl_stmt|;
name|boolean
argument_list|(
argument|*pfwrite
argument_list|)
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|zcallout_login
decl_stmt|;
name|char
modifier|*
name|zcallout_pass
decl_stmt|;
name|boolean
name|fquote
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|z
argument_list|,
literal|"\"\""
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|fnocr
operator|=
name|FALSE
expr_stmt|;
name|pfwrite
operator|=
name|fport_write
expr_stmt|;
name|zcallout_login
operator|=
name|NULL
expr_stmt|;
name|zcallout_pass
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_CHAT
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_DEBUG_START
argument_list|,
literal|"fcsend: Writing"
argument_list|)
expr_stmt|;
name|fquote
operator|=
name|FALSE
expr_stmt|;
name|cCsend_chars
operator|=
literal|0
expr_stmt|;
name|iColddebug
operator|=
name|iDebug
expr_stmt|;
name|iDebug
operator|&=
operator|~
operator|(
name|DEBUG_OUTGOING
operator||
name|DEBUG_PORT
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|*
name|z
operator|!=
literal|'\0'
condition|)
block|{
specifier|const
name|char
modifier|*
name|zlook
decl_stmt|;
name|boolean
name|fsend
decl_stmt|;
name|char
name|bsend
decl_stmt|;
name|zlook
operator|=
name|z
operator|+
name|strcspn
argument_list|(
name|z
argument_list|,
literal|"\\BE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zlook
operator|>
name|z
condition|)
block|{
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
name|zlook
operator|-
name|z
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
name|z
argument_list|,
name|zlook
operator|-
name|z
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
operator|*
name|zlook
operator|==
literal|'\0'
condition|)
break|break;
name|z
operator|=
name|zlook
expr_stmt|;
name|fsend
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
operator|*
name|z
condition|)
block|{
case|case
literal|'B'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|z
argument_list|,
literal|"BREAK"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"break"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fport_break
argument_list|()
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|z
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'B'
expr_stmt|;
operator|++
name|z
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|z
argument_list|,
literal|"EOT"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\004'
expr_stmt|;
block|}
else|else
block|{
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'E'
expr_stmt|;
operator|++
name|z
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
operator|++
name|z
expr_stmt|;
switch|switch
condition|(
operator|*
name|z
condition|)
block|{
case|case
literal|'b'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|fnocr
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"sleep"
argument_list|)
expr_stmt|;
name|usysdep_sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"echo-check-off"
argument_list|)
expr_stmt|;
name|pfwrite
operator|=
name|fport_write
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"echo-check-on"
argument_list|)
expr_stmt|;
name|pfwrite
operator|=
name|fcecho_send
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"break"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fport_break
argument_list|()
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|'n'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"pause"
argument_list|)
expr_stmt|;
name|usysdep_pause
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
operator|--
name|z
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'\\'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
operator|*
name|z
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|z
index|[
literal|1
index|]
operator|<=
literal|'7'
condition|)
name|bsend
operator|=
call|(
name|char
call|)
argument_list|(
literal|8
operator|*
name|bsend
operator|+
operator|*
operator|++
name|z
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|z
index|[
literal|1
index|]
operator|<=
literal|'7'
condition|)
name|bsend
operator|=
call|(
name|char
call|)
argument_list|(
literal|8
operator|*
name|bsend
operator|+
operator|*
operator|++
name|z
operator|-
literal|'0'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isxdigit
argument_list|(
name|BUCHAR
argument_list|(
name|z
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|BUCHAR
argument_list|(
name|z
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
name|bsend
operator|=
call|(
name|char
call|)
argument_list|(
literal|16
operator|*
name|bsend
operator|+
operator|*
operator|++
name|z
operator|-
literal|'0'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|BUCHAR
argument_list|(
name|z
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
name|bsend
operator|=
call|(
name|char
call|)
argument_list|(
literal|16
operator|*
name|bsend
operator|+
operator|*
operator|++
name|z
operator|-
literal|'A'
argument_list|)
expr_stmt|;
else|else
name|bsend
operator|=
call|(
name|char
call|)
argument_list|(
literal|16
operator|*
name|bsend
operator|+
operator|*
operator|++
name|z
operator|-
literal|'a'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
block|{
specifier|const
name|char
modifier|*
name|zlog
decl_stmt|;
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\L"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zlog
operator|=
name|qsys
operator|->
name|zcall_login
expr_stmt|;
if|if
condition|(
name|zlog
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No login defined"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zlog
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|zlog
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zcallout_login
operator|==
name|NULL
operator|&&
operator|!
name|fcallout_login
argument_list|(
name|qsys
argument_list|,
operator|&
name|zcallout_login
argument_list|,
operator|&
name|zcallout_pass
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zlog
operator|=
name|zcallout_login
expr_stmt|;
block|}
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"login"
argument_list|)
expr_stmt|;
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
name|strlen
argument_list|(
name|zlog
argument_list|)
argument_list|,
name|zlog
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
name|zlog
argument_list|,
name|strlen
argument_list|(
name|zlog
argument_list|)
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
break|break;
case|case
literal|'P'
case|:
block|{
specifier|const
name|char
modifier|*
name|zpass
decl_stmt|;
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\P"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zpass
operator|=
name|qsys
operator|->
name|zcall_password
expr_stmt|;
if|if
condition|(
name|zpass
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No password defined"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zpass
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|zpass
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zcallout_pass
operator|==
name|NULL
operator|&&
operator|!
name|fcallout_login
argument_list|(
name|qsys
argument_list|,
operator|&
name|zcallout_login
argument_list|,
operator|&
name|zcallout_pass
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zpass
operator|=
name|zcallout_pass
expr_stmt|;
block|}
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"password"
argument_list|)
expr_stmt|;
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
name|strlen
argument_list|(
name|zpass
argument_list|)
argument_list|,
name|zpass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
name|zpass
argument_list|,
name|strlen
argument_list|(
name|zpass
argument_list|)
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|qdial
operator|==
name|NULL
operator|||
name|zphone
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\D"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"\\D"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcphone
argument_list|(
name|qdial
argument_list|,
name|zphone
argument_list|,
name|pfwrite
argument_list|,
name|ftranslate
argument_list|,
operator|&
name|fquote
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|qdial
operator|==
name|NULL
operator|||
name|zphone
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\T"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"\\T"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcphone
argument_list|(
name|qdial
argument_list|,
name|zphone
argument_list|,
name|pfwrite
argument_list|,
name|TRUE
argument_list|,
operator|&
name|fquote
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|qdial
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\M"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"ignore-carrier"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fport_no_carrier
argument_list|()
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|qdial
operator|==
name|NULL
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Illegal use of \\m"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|0
argument_list|,
literal|"need-carrier"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fport_need_carrier
argument_list|()
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
comment|/* This error message will screw up any debugging 		 information, but it's easily avoidable.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Unrecognized escape sequence \\%c in send string"
argument_list|,
operator|*
name|z
argument_list|)
expr_stmt|;
name|fsend
operator|=
name|TRUE
expr_stmt|;
name|bsend
operator|=
operator|*
name|z
expr_stmt|;
break|break;
block|}
operator|++
name|z
expr_stmt|;
break|break;
if|#
directive|if
name|DEBUG
operator|>
literal|0
default|default:
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fcsend: Can't happen"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|fsend
condition|)
block|{
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|1
argument_list|,
operator|&
name|bsend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
operator|&
name|bsend
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
comment|/* Clobber and free the login and password names that came from      the call out file.  We probably shouldn't even keep them around      this long.  */
if|if
condition|(
name|zcallout_login
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|zcallout_login
argument_list|,
name|strlen
argument_list|(
name|zcallout_login
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zcallout_login
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zcallout_pass
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|zcallout_pass
argument_list|,
name|strlen
argument_list|(
name|zcallout_pass
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zcallout_pass
argument_list|)
expr_stmt|;
block|}
comment|/* Output a final carriage return, unless there was a \c.  Don't      bother to check for an echo.  */
if|if
condition|(
operator|!
name|fnocr
condition|)
block|{
name|char
name|b
decl_stmt|;
name|b
operator|=
literal|'\r'
expr_stmt|;
name|fquote
operator|=
name|fcsend_debug
argument_list|(
name|fquote
argument_list|,
literal|1
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fport_write
argument_list|(
operator|&
name|b
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|ucsend_debug_end
argument_list|(
name|fquote
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out a phone number with optional dialcode translation.  The    pfquote argument is only used for debugging.  */
end_comment

begin_function_decl
specifier|static
name|boolean
name|fcphone
parameter_list|(
name|qdial
parameter_list|,
name|zphone
parameter_list|,
name|pfwrite
parameter_list|,
name|ftranslate
parameter_list|,
name|pfquote
parameter_list|)
specifier|const
name|struct
name|sdialer
modifier|*
name|qdial
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*pfwrite
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zwrite
operator|,
name|int
name|cwrite
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|boolean
name|ftranslate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
modifier|*
name|pfquote
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|const
name|char
modifier|*
name|zprefix
decl_stmt|,
modifier|*
name|zsuffix
decl_stmt|;
if|if
condition|(
name|ftranslate
condition|)
block|{
if|if
condition|(
operator|!
name|fctranslate
argument_list|(
name|zphone
argument_list|,
operator|&
name|zprefix
argument_list|,
operator|&
name|zsuffix
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|zprefix
operator|=
name|zphone
expr_stmt|;
name|zsuffix
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|zprefix
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|TRUE
condition|)
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
specifier|const
name|char
modifier|*
name|zstr
decl_stmt|;
name|z
operator|=
name|zprefix
operator|+
name|strcspn
argument_list|(
name|zprefix
argument_list|,
literal|"=-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|>
name|zprefix
condition|)
block|{
operator|*
name|pfquote
operator|=
name|fcsend_debug
argument_list|(
operator|*
name|pfquote
argument_list|,
name|z
operator|-
name|zprefix
argument_list|,
name|zprefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
name|zprefix
argument_list|,
name|z
operator|-
name|zprefix
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|*
name|z
operator|==
literal|'='
condition|)
name|zstr
operator|=
name|qdial
operator|->
name|zdialtone
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|z
operator|==
literal|'-'
condition|)
name|zstr
operator|=
name|qdial
operator|->
name|zpause
expr_stmt|;
else|else
comment|/* *z == '\0' */
break|break;
if|if
condition|(
name|zstr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|pfquote
operator|=
name|fcsend_debug
argument_list|(
operator|*
name|pfquote
argument_list|,
name|strlen
argument_list|(
name|zstr
argument_list|)
argument_list|,
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|pfwrite
call|)
argument_list|(
name|zstr
argument_list|,
name|strlen
argument_list|(
name|zstr
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|zprefix
operator|=
name|z
operator|+
literal|1
expr_stmt|;
block|}
name|zprefix
operator|=
name|zsuffix
expr_stmt|;
name|zsuffix
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/* Given a phone number, run it through dial code translation    returning two strings.  */
end_comment

begin_function
specifier|static
name|boolean
name|fctranslate
parameter_list|(
name|zphone
parameter_list|,
name|pzprefix
parameter_list|,
name|pzsuffix
parameter_list|)
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pzprefix
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pzsuffix
decl_stmt|;
block|{
name|char
modifier|*
name|zdialcode
decl_stmt|,
modifier|*
name|zto
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
operator|*
name|pzprefix
operator|=
name|zphone
expr_stmt|;
operator|*
name|pzsuffix
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zDialcodefile
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|zdialcode
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zphone
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zfrom
operator|=
name|zphone
expr_stmt|;
name|zto
operator|=
name|zdialcode
expr_stmt|;
while|while
condition|(
operator|*
name|zfrom
operator|!=
literal|'\0'
operator|&&
name|isalpha
argument_list|(
name|BUCHAR
argument_list|(
operator|*
name|zfrom
argument_list|)
argument_list|)
condition|)
operator|*
name|zto
operator|++
operator|=
operator|*
name|zfrom
operator|++
expr_stmt|;
operator|*
name|zto
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|zdialcode
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|smulti_file
modifier|*
name|qmulti
decl_stmt|;
name|struct
name|scmdtab
name|as
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|zpre
decl_stmt|;
name|qmulti
operator|=
name|qmulti_open
argument_list|(
name|zDialcodefile
argument_list|)
expr_stmt|;
if|if
condition|(
name|qmulti
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|as
index|[
literal|0
index|]
operator|.
name|zcmd
operator|=
name|zdialcode
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|itype
operator|=
name|CMDTABTYPE_STRING
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|pvar
operator|=
operator|(
name|pointer
operator|)
operator|&
name|zpre
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|ptfn
operator|=
name|NULL
expr_stmt|;
name|as
index|[
literal|1
index|]
operator|.
name|zcmd
operator|=
name|NULL
expr_stmt|;
name|zpre
operator|=
name|NULL
expr_stmt|;
name|uprocesscmds
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|,
name|qmulti
argument_list|,
name|as
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CMDFLAG_BACKSLASH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fmulti_close
argument_list|(
name|qmulti
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpre
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Unknown dial code %s"
argument_list|,
name|zdialcode
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|pzprefix
operator|=
name|zpre
expr_stmt|;
operator|*
name|pzsuffix
operator|=
name|zfrom
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out a string making sure the each character is echoed back.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcecho_send
parameter_list|(
name|zwrite
parameter_list|,
name|cwrite
parameter_list|)
specifier|const
name|char
modifier|*
name|zwrite
decl_stmt|;
name|int
name|cwrite
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zend
decl_stmt|;
name|zend
operator|=
name|zwrite
operator|+
name|cwrite
expr_stmt|;
for|for
control|(
init|;
name|zwrite
operator|<
name|zend
condition|;
name|zwrite
operator|++
control|)
block|{
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|fport_write
argument_list|(
name|zwrite
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
do|do
block|{
comment|/* We arbitrarily wait five seconds for the echo.  */
name|b
operator|=
name|breceive_char
argument_list|(
literal|5
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Now b == -1 on timeout, -2 on error.  */
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Character not echoed"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
do|while
condition|(
name|b
operator|!=
name|BUCHAR
argument_list|(
operator|*
name|zwrite
argument_list|)
condition|)
do|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Run a chat program.  Expand any escape sequences and call a system    dependent program to run it.  */
end_comment

begin_function
specifier|static
name|boolean
name|fcprogram
parameter_list|(
name|zprogram
parameter_list|,
name|qsys
parameter_list|,
name|qdial
parameter_list|,
name|zphone
parameter_list|,
name|zport
parameter_list|,
name|ibaud
parameter_list|)
specifier|const
name|char
modifier|*
name|zprogram
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|struct
name|sdialer
modifier|*
name|qdial
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
specifier|const
name|char
modifier|*
name|zport
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
block|{
name|char
modifier|*
name|zbuf
decl_stmt|;
name|int
name|calc
decl_stmt|,
name|clen
decl_stmt|;
name|char
modifier|*
name|zto
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
name|char
modifier|*
name|zcallout_login
decl_stmt|;
name|char
modifier|*
name|zcallout_pass
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|zcallout_login
operator|=
name|NULL
expr_stmt|;
name|zcallout_pass
operator|=
name|NULL
expr_stmt|;
comment|/* Copy the string into memory expanding escape sequences.  */
name|zbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|calc
operator|=
literal|1
expr_stmt|;
name|clen
operator|=
literal|0
expr_stmt|;
name|zto
operator|=
name|zbuf
expr_stmt|;
for|for
control|(
name|zfrom
operator|=
name|zprogram
init|;
operator|*
name|zfrom
operator|!=
literal|'\0'
condition|;
name|zfrom
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|zadd
decl_stmt|;
name|int
name|cadd
decl_stmt|;
if|if
condition|(
operator|*
name|zfrom
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
name|clen
operator|+
literal|2
operator|>
name|calc
condition|)
block|{
name|calc
operator|=
name|clen
operator|+
literal|80
expr_stmt|;
name|zbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|zbuf
argument_list|,
name|calc
argument_list|)
expr_stmt|;
name|zto
operator|=
name|zbuf
operator|+
name|clen
expr_stmt|;
block|}
operator|*
name|zto
operator|++
operator|=
operator|*
name|zfrom
expr_stmt|;
operator|++
name|clen
expr_stmt|;
continue|continue;
block|}
operator|++
name|zfrom
expr_stmt|;
switch|switch
condition|(
operator|*
name|zfrom
condition|)
block|{
case|case
literal|'\0'
case|:
operator|--
name|zfrom
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'\\'
case|:
name|zadd
operator|=
literal|"\\"
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
block|{
specifier|const
name|char
modifier|*
name|zlog
decl_stmt|;
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\L"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zlog
operator|=
name|qsys
operator|->
name|zcall_login
expr_stmt|;
if|if
condition|(
name|zlog
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: No login defined"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zlog
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|zlog
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zcallout_login
operator|==
name|NULL
operator|&&
operator|!
name|fcallout_login
argument_list|(
name|qsys
argument_list|,
operator|&
name|zcallout_login
argument_list|,
operator|&
name|zcallout_pass
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|zlog
operator|=
name|zcallout_login
expr_stmt|;
block|}
name|zadd
operator|=
name|zlog
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
block|{
specifier|const
name|char
modifier|*
name|zpass
decl_stmt|;
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\P"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zpass
operator|=
name|qsys
operator|->
name|zcall_password
expr_stmt|;
if|if
condition|(
name|zpass
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: No password defined"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|zpass
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|zpass
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zcallout_pass
operator|==
name|NULL
operator|&&
operator|!
name|fcallout_login
argument_list|(
name|qsys
argument_list|,
operator|&
name|zcallout_login
argument_list|,
operator|&
name|zcallout_pass
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|zpass
operator|=
name|zcallout_pass
expr_stmt|;
block|}
name|zadd
operator|=
name|zpass
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|qdial
operator|==
name|NULL
operator|||
name|zphone
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\D"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zadd
operator|=
name|zphone
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
block|{
specifier|const
name|char
modifier|*
name|zprefix
decl_stmt|,
modifier|*
name|zsuffix
decl_stmt|;
if|if
condition|(
name|qdial
operator|==
name|NULL
operator|||
name|zphone
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\T"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|fctranslate
argument_list|(
name|zphone
argument_list|,
operator|&
name|zprefix
argument_list|,
operator|&
name|zsuffix
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|zsuffix
operator|==
name|NULL
condition|)
name|zadd
operator|=
name|zprefix
expr_stmt|;
else|else
block|{
name|int
name|cprefix
decl_stmt|;
name|cprefix
operator|=
name|strlen
argument_list|(
name|zprefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|+
name|cprefix
operator|+
literal|1
operator|>
name|calc
condition|)
block|{
name|calc
operator|=
name|clen
operator|+
name|cprefix
operator|+
literal|20
expr_stmt|;
name|zbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|zbuf
argument_list|,
name|calc
argument_list|)
expr_stmt|;
name|zto
operator|=
name|zbuf
operator|+
name|clen
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|zto
argument_list|,
name|zprefix
argument_list|)
expr_stmt|;
name|zto
operator|+=
name|cprefix
expr_stmt|;
name|clen
operator|+=
name|cprefix
expr_stmt|;
name|zadd
operator|=
name|zsuffix
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'Y'
case|:
if|if
condition|(
name|zLdevice
operator|==
name|NULL
operator|&&
name|zport
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\Y"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* zLdevice will generally make more sense than zport, but 	     it might not be set yet.  */
name|zadd
operator|=
name|zLdevice
expr_stmt|;
if|if
condition|(
name|zadd
operator|==
name|NULL
condition|)
name|zadd
operator|=
name|zport
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
if|if
condition|(
name|qsys
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\Z"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zadd
operator|=
name|qsys
operator|->
name|zname
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
block|{
name|char
modifier|*
name|zalc
decl_stmt|;
if|if
condition|(
name|ibaud
operator|==
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Illegal use of \\S"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|zalc
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zalc
argument_list|,
literal|"%ld"
argument_list|,
name|ibaud
argument_list|)
expr_stmt|;
name|zadd
operator|=
name|zalc
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|char
modifier|*
name|zset
decl_stmt|;
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"chat-program: Unrecognized escape sequence \\%c"
argument_list|,
operator|*
name|zfrom
argument_list|)
expr_stmt|;
name|zset
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|zset
index|[
literal|0
index|]
operator|=
operator|*
name|zfrom
expr_stmt|;
name|zset
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zadd
operator|=
name|zset
expr_stmt|;
block|}
break|break;
block|}
name|cadd
operator|=
name|strlen
argument_list|(
name|zadd
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|+
name|cadd
operator|+
literal|1
operator|>
name|calc
condition|)
block|{
name|calc
operator|=
name|clen
operator|+
name|cadd
operator|+
literal|20
expr_stmt|;
name|zbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|zbuf
argument_list|,
name|calc
argument_list|)
expr_stmt|;
name|zto
operator|=
name|zbuf
operator|+
name|clen
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|zto
argument_list|,
name|zadd
argument_list|)
expr_stmt|;
name|zto
operator|+=
name|cadd
expr_stmt|;
name|clen
operator|+=
name|cadd
expr_stmt|;
block|}
operator|*
name|zto
operator|=
literal|'\0'
expr_stmt|;
comment|/* Invoke the program.  */
name|fret
operator|=
name|fport_run_chat
argument_list|(
name|zbuf
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zbuf
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

end_unit

