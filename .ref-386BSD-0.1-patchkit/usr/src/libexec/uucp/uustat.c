begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* uustat.c    UUCP status program     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: uustat.c,v $    Revision 1.7  1992/03/28  22:54:45  ian    Allow multiple systems and users or kills and rejuvenates at once     Revision 1.6  1992/03/12  19:54:43  ian    Debugging based on types rather than number     Revision 1.5  1992/03/03  21:34:55  ian    Handle local execution files     Revision 1.4  1992/02/27  05:40:54  ian    T. William Wells: detach from controlling terminal, handle signals safely     Revision 1.3  1992/02/24  20:36:27  ian    Roberto Biancardi: skip spaces after strtok (NULL, "")     Revision 1.2  1992/02/23  03:26:51  ian    Overhaul to use automatic configure shell script     Revision 1.1  1992/02/20  04:18:59  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|uustat_rcsid
index|[]
init|=
literal|"$Id: uustat.c,v 1.7 1992/03/28 22:54:45 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|HAVE_TIME_H
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The uustat program permits various listings and manipulations of    files in the spool directory.  This implementation supports the    following switches:     -a list all jobs    -kjobid kill job with specified ID    -m report status for all remote machines    -ohour report jobs older than specified number of hours    -p do "ps -flp" on all processes holding lock files (Unix specific)    -q list number of jobs for all systems    -rjobid rejuvenate job with specified ID    -ssystem report on all jobs for specified system    -uuser report on all jobs for specified user    -yhour report jobs younger than specified number of hours    -Ifile set configuration file name    -xdebug set debugging level  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The program name.  */
end_comment

begin_decl_stmt
name|char
name|abProgram
index|[]
init|=
literal|"uustat"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ususage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsworkfiles
name|P
argument_list|(
operator|(
name|int
name|csystems
operator|,
name|char
operator|*
operator|*
name|pazsystems
operator|,
name|int
name|cusers
operator|,
name|char
operator|*
operator|*
name|pazusers
operator|,
name|long
name|iold
operator|,
name|long
name|iyoung
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsworkfiles_system
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
name|int
name|cusers
operator|,
name|char
operator|*
operator|*
name|pazusers
operator|,
name|long
name|iold
operator|,
name|long
name|iyoung
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsworkfile_show
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
specifier|const
expr|struct
name|scmd
operator|*
name|qcmd
operator|,
name|long
name|itime
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usworkfile_header
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
specifier|const
expr|struct
name|scmd
operator|*
name|qcmd
operator|,
specifier|const
name|char
operator|*
name|zjobid
operator|,
name|long
name|itime
operator|,
name|boolean
name|ffirst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsquery
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usunits_show
name|P
argument_list|(
operator|(
name|long
name|idiff
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsmachines
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Long getopt options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|asLongopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|option
modifier|*
name|_getopt_long_options
init|=
name|asLongopts
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|iopt
decl_stmt|;
comment|/* -a: list all jobs.  */
name|boolean
name|fall
init|=
name|FALSE
decl_stmt|;
comment|/* -k jobid: kill specified job.  */
name|int
name|ckills
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|pazkills
init|=
name|NULL
decl_stmt|;
comment|/* -m: report machine status.  */
name|boolean
name|fmachine
init|=
name|FALSE
decl_stmt|;
comment|/* -o hour: report jobs older than given number of hours.  */
name|int
name|ioldhours
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -p: report status of jobs holding lock files.  */
name|boolean
name|fps
init|=
name|FALSE
decl_stmt|;
comment|/* -q: list number of jobs for each system.  */
name|boolean
name|fquery
init|=
name|FALSE
decl_stmt|;
comment|/* -r jobid: rejuvenate specified job.  */
name|int
name|crejuvs
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|pazrejuvs
init|=
name|NULL
decl_stmt|;
comment|/* -s system: list all jobs for specified system.  */
name|int
name|csystems
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|pazsystems
init|=
name|NULL
decl_stmt|;
comment|/* -u user: list all jobs for specified user.  */
name|int
name|cusers
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|pazusers
init|=
name|NULL
decl_stmt|;
comment|/* -y hour: report jobs younger than given number of hours.  */
name|int
name|iyounghours
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -I file: set configuration file.  */
specifier|const
name|char
modifier|*
name|zconfig
init|=
name|NULL
decl_stmt|;
name|int
name|ccmds
decl_stmt|;
name|long
name|iold
decl_stmt|;
name|long
name|iyoung
decl_stmt|;
name|char
modifier|*
name|azoneuser
index|[
literal|1
index|]
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
while|while
condition|(
operator|(
name|iopt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aI:k:mo:pqr:s:u:x:y:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|iopt
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* List all jobs.  */
name|fall
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Set configuration file name.  */
name|zconfig
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* Kill specified job.  */
operator|++
name|ckills
expr_stmt|;
name|pazkills
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pazkills
argument_list|,
name|ckills
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pazkills
index|[
name|ckills
operator|-
literal|1
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Report machine status.  */
name|fmachine
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Report old jobs.  */
name|ioldhours
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Get status of processes holding locks.  */
name|fps
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* List number of jobs for each system.  */
name|fquery
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Rejuvenate specified job.  */
operator|++
name|crejuvs
expr_stmt|;
name|pazrejuvs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pazrejuvs
argument_list|,
name|crejuvs
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pazrejuvs
index|[
name|crejuvs
operator|-
literal|1
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* List jobs for specified system.  */
operator|++
name|csystems
expr_stmt|;
name|pazsystems
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pazsystems
argument_list|,
name|csystems
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pazsystems
index|[
name|csystems
operator|-
literal|1
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* List jobs for specified user.  */
operator|++
name|cusers
expr_stmt|;
name|pazusers
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pazusers
argument_list|,
name|cusers
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pazusers
index|[
name|cusers
operator|-
literal|1
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* Set debugging level.  */
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'y'
case|:
comment|/* List jobs younger than given number of hours.  */
name|iyounghours
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Long option found and flag set.  */
break|break;
default|default:
name|ususage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
name|ususage
argument_list|()
expr_stmt|;
comment|/* To avoid confusion, most options are only permitted by      themselves.  This restriction might be removed later, but it is      imposed by most implementations.  We do permit any combination of      -s, -u, -o and -y, and any combination of -k and -r.  */
name|ccmds
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fall
condition|)
operator|++
name|ccmds
expr_stmt|;
if|if
condition|(
name|ckills
operator|>
literal|0
operator|||
name|crejuvs
operator|>
literal|0
condition|)
operator|++
name|ccmds
expr_stmt|;
if|if
condition|(
name|fmachine
condition|)
operator|++
name|ccmds
expr_stmt|;
if|if
condition|(
name|fps
condition|)
operator|++
name|ccmds
expr_stmt|;
if|if
condition|(
name|fquery
condition|)
operator|++
name|ccmds
expr_stmt|;
if|if
condition|(
name|csystems
operator|>
literal|0
operator|||
name|cusers
operator|>
literal|0
operator|||
name|ioldhours
operator|!=
operator|-
literal|1
operator|||
name|iyounghours
operator|!=
operator|-
literal|1
condition|)
operator|++
name|ccmds
expr_stmt|;
if|if
condition|(
name|ccmds
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uustat: Too many options\n"
argument_list|)
expr_stmt|;
name|ususage
argument_list|()
expr_stmt|;
block|}
name|uread_config
argument_list|(
name|zconfig
argument_list|)
expr_stmt|;
name|usysdep_initialize
argument_list|(
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* If no commands were specified, we list all commands for the given      user.  */
if|if
condition|(
name|ccmds
operator|==
literal|0
condition|)
block|{
name|cusers
operator|=
literal|1
expr_stmt|;
name|azoneuser
index|[
literal|0
index|]
operator|=
name|xstrdup
argument_list|(
name|zsysdep_login_name
argument_list|()
argument_list|)
expr_stmt|;
name|pazusers
operator|=
name|azoneuser
expr_stmt|;
block|}
if|if
condition|(
name|ioldhours
operator|==
operator|-
literal|1
condition|)
name|iold
operator|=
operator|(
name|long
operator|)
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|iold
operator|=
operator|(
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
operator|-
operator|(
name|long
operator|)
name|ioldhours
operator|*
operator|(
name|long
operator|)
literal|60
operator|*
operator|(
name|long
operator|)
literal|60
operator|)
expr_stmt|;
if|if
condition|(
name|iold
operator|<
literal|0L
condition|)
name|iold
operator|=
literal|0L
expr_stmt|;
block|}
if|if
condition|(
name|iyounghours
operator|==
operator|-
literal|1
condition|)
name|iyoung
operator|=
operator|(
name|long
operator|)
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|iyoung
operator|=
operator|(
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
operator|-
operator|(
name|long
operator|)
name|iyounghours
operator|*
operator|(
name|long
operator|)
literal|60
operator|*
operator|(
name|long
operator|)
literal|60
operator|)
expr_stmt|;
if|if
condition|(
name|iyoung
operator|<
literal|0L
condition|)
name|iyoung
operator|=
literal|0L
expr_stmt|;
block|}
if|if
condition|(
name|fall
operator|||
name|ioldhours
operator|!=
operator|-
literal|1
operator|||
name|csystems
operator|>
literal|0
operator|||
name|cusers
operator|>
literal|0
operator|||
name|iyounghours
operator|!=
operator|-
literal|1
condition|)
name|fret
operator|=
name|fsworkfiles
argument_list|(
name|csystems
argument_list|,
name|pazsystems
argument_list|,
name|cusers
argument_list|,
name|pazusers
argument_list|,
name|iold
argument_list|,
name|iyoung
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fquery
condition|)
name|fret
operator|=
name|fsquery
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|fmachine
condition|)
name|fret
operator|=
name|fsmachines
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|ckills
operator|>
literal|0
operator|||
name|crejuvs
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ckills
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fsysdep_kill_job
argument_list|(
name|pazkills
index|[
name|i
index|]
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|crejuvs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fsysdep_rejuvenate_job
argument_list|(
name|pazrejuvs
index|[
name|i
index|]
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fps
condition|)
name|fret
operator|=
name|fsysdep_lock_status
argument_list|()
expr_stmt|;
else|else
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|0
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Can't happen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|fret
argument_list|)
expr_stmt|;
comment|/* Avoid errors about not returning a value.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print a usage message and die.  */
end_comment

begin_function
specifier|static
name|void
name|ususage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Taylor UUCP version %s, copyright (C) 1991, 1992 Ian Lance Taylor\n"
argument_list|,
name|abVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: uustat [-ampq] [-kr job] [-oy hours] [-s system] [-u user]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -a: list all UUCP jobs\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -k job: kill specified UUCP job\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -m: report status for all remote machines\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -o hours: list all jobs older than given number of hours\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -p: show status of all processes holding UUCP locks\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -q: list number of jobs for each system\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -r job: rejuvenate specified UUCP job\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -s system: list all jobs for specified system\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -u user: list all jobs for specified user\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -y hours: list all jobs younger than given number of hours\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -x debug: Set debugging level (0 for none, 9 is max)\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -I file: Set configuration file to use (default %s%s)\n"
argument_list|,
name|NEWCONFIGLIB
argument_list|,
name|CONFIGFILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle various possible requests to look at work files.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsworkfiles
parameter_list|(
name|csystems
parameter_list|,
name|pazsystems
parameter_list|,
name|cusers
parameter_list|,
name|pazusers
parameter_list|,
name|iold
parameter_list|,
name|iyoung
parameter_list|)
name|int
name|csystems
decl_stmt|;
name|char
modifier|*
modifier|*
name|pazsystems
decl_stmt|;
name|int
name|cusers
decl_stmt|;
name|char
modifier|*
modifier|*
name|pazusers
decl_stmt|;
name|long
name|iold
decl_stmt|;
name|long
name|iyoung
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|csystems
operator|>
literal|0
condition|)
block|{
name|struct
name|ssysteminfo
name|ssys
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|csystems
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|fread_system_info
argument_list|(
name|pazsystems
index|[
name|i
index|]
argument_list|,
operator|&
name|ssys
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: unknown system"
argument_list|,
name|pazsystems
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|fsworkfiles_system
argument_list|(
operator|&
name|ssys
argument_list|,
name|cusers
argument_list|,
name|pazusers
argument_list|,
name|iold
argument_list|,
name|iyoung
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|cs
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|pas
decl_stmt|;
name|uread_all_system_info
argument_list|(
operator|&
name|cs
argument_list|,
operator|&
name|pas
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fsworkfiles_system
argument_list|(
operator|&
name|pas
index|[
name|i
index|]
argument_list|,
name|cusers
argument_list|,
name|pazusers
argument_list|,
name|iold
argument_list|,
name|iyoung
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Look at the work files for a particular system.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsworkfiles_system
parameter_list|(
name|qsys
parameter_list|,
name|cusers
parameter_list|,
name|pazusers
parameter_list|,
name|iold
parameter_list|,
name|iyoung
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|int
name|cusers
decl_stmt|;
name|char
modifier|*
modifier|*
name|pazusers
decl_stmt|;
name|long
name|iold
decl_stmt|;
name|long
name|iyoung
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
if|if
condition|(
operator|!
name|fsysdep_get_work_init
argument_list|(
name|qsys
argument_list|,
name|BGRADE_LOW
argument_list|)
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|struct
name|scmd
name|s
decl_stmt|;
name|long
name|itime
decl_stmt|;
if|if
condition|(
operator|!
name|fsysdep_get_work
argument_list|(
name|qsys
argument_list|,
name|BGRADE_LOW
argument_list|,
operator|&
name|s
argument_list|)
condition|)
block|{
name|usysdep_get_work_free
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|s
operator|.
name|bcmd
operator|==
literal|'H'
condition|)
break|break;
if|if
condition|(
name|cusers
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cusers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|pazusers
index|[
name|i
index|]
argument_list|,
name|s
operator|.
name|zuser
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|cusers
condition|)
continue|continue;
block|}
name|itime
operator|=
name|isysdep_work_time
argument_list|(
name|qsys
argument_list|,
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|iold
operator|!=
operator|(
name|long
operator|)
operator|-
literal|1
operator|&&
name|itime
operator|>
name|iold
condition|)
continue|continue;
if|if
condition|(
name|iyoung
operator|!=
operator|(
name|long
operator|)
operator|-
literal|1
operator|&&
name|itime
operator|<
name|iyoung
condition|)
continue|continue;
if|if
condition|(
operator|!
name|fsworkfile_show
argument_list|(
name|qsys
argument_list|,
operator|&
name|s
argument_list|,
name|itime
argument_list|)
condition|)
block|{
name|usysdep_get_work_free
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|fret
operator|=
name|fsworkfile_show
argument_list|(
name|qsys
argument_list|,
operator|(
specifier|const
expr|struct
name|scmd
operator|*
operator|)
name|NULL
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|usysdep_get_work_free
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Show a single workfile.  This is actually called once for each line    in the workfile, so we accumulate the lines and show them all at    once.  This lets us show an execution in a useful fashion.  */
end_comment

begin_struct
struct|struct
name|scmdlist
block|{
name|struct
name|scmdlist
modifier|*
name|qnext
decl_stmt|;
name|struct
name|scmd
name|s
decl_stmt|;
name|long
name|itime
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|boolean
name|fsworkfile_show
parameter_list|(
name|qsys
parameter_list|,
name|qcmd
parameter_list|,
name|itime
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
name|long
name|itime
decl_stmt|;
block|{
specifier|static
name|struct
name|scmdlist
modifier|*
name|qlist
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|zlistid
decl_stmt|;
specifier|const
name|char
modifier|*
name|zid
decl_stmt|;
if|if
condition|(
name|qcmd
operator|==
name|NULL
condition|)
name|zid
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|zid
operator|=
name|zsysdep_jobid
argument_list|(
name|qsys
argument_list|,
name|qcmd
operator|->
name|pseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|zid
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If this is the same jobid as the list, put it on the end.  */
if|if
condition|(
name|qcmd
operator|!=
name|NULL
operator|&&
name|qlist
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zlistid
argument_list|,
name|zid
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|scmdlist
modifier|*
name|qnew
decl_stmt|,
modifier|*
modifier|*
name|pq
decl_stmt|;
name|qnew
operator|=
operator|(
expr|struct
name|scmdlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scmdlist
argument_list|)
argument_list|)
expr_stmt|;
name|qnew
operator|->
name|qnext
operator|=
name|NULL
expr_stmt|;
name|qnew
operator|->
name|s
operator|=
operator|*
name|qcmd
expr_stmt|;
name|qnew
operator|->
name|itime
operator|=
name|itime
expr_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|qlist
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
control|)
empty_stmt|;
operator|*
name|pq
operator|=
name|qnew
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|qcmd
operator|!=
name|NULL
condition|)
name|zid
operator|=
name|xstrdup
argument_list|(
name|zid
argument_list|)
expr_stmt|;
comment|/* Here we have found a different job ID, so we print the scmd      structures that we have accumulated.  We look for the special      case of an execution (one of the destination files begins with      X.).  We could be more clever about other situations as well.  */
if|if
condition|(
name|qlist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scmdlist
modifier|*
name|qlook
decl_stmt|;
for|for
control|(
name|qlook
operator|=
name|qlist
init|;
name|qlook
operator|!=
name|NULL
condition|;
name|qlook
operator|=
name|qlook
operator|->
name|qnext
control|)
if|if
condition|(
name|qlook
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'S'
operator|&&
name|qlook
operator|->
name|s
operator|.
name|zto
index|[
literal|0
index|]
operator|==
literal|'X'
operator|&&
name|qlook
operator|->
name|s
operator|.
name|zto
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|fspool_file
argument_list|(
name|qlook
operator|->
name|s
operator|.
name|zfrom
argument_list|)
condition|)
break|break;
if|if
condition|(
name|qlook
operator|==
name|NULL
condition|)
block|{
comment|/* Show all the lines in a regular work file.  */
for|for
control|(
name|qlook
operator|=
name|qlist
init|;
name|qlook
operator|!=
name|NULL
condition|;
name|qlook
operator|=
name|qlook
operator|->
name|qnext
control|)
block|{
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
name|usworkfile_header
argument_list|(
name|qsys
argument_list|,
operator|&
name|qlook
operator|->
name|s
argument_list|,
name|zlistid
argument_list|,
name|qlook
operator|->
name|itime
argument_list|,
name|qlook
operator|==
name|qlist
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|qlook
operator|->
name|s
operator|.
name|bcmd
condition|)
block|{
case|case
literal|'S'
case|:
if|if
condition|(
name|strchr
argument_list|(
name|qlook
operator|->
name|s
operator|.
name|zoptions
argument_list|,
literal|'C'
argument_list|)
operator|!=
name|NULL
operator|||
name|fspool_file
argument_list|(
name|qlook
operator|->
name|s
operator|.
name|zfrom
argument_list|)
condition|)
name|zfile
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qsys
argument_list|,
name|qlook
operator|->
name|s
operator|.
name|ztemp
argument_list|)
expr_stmt|;
else|else
name|zfile
operator|=
name|zsysdep_real_file_name
argument_list|(
name|qsys
argument_list|,
name|qlook
operator|->
name|s
operator|.
name|zfrom
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sending %s (%ld bytes) to %s"
argument_list|,
name|qlook
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|zfile
operator|==
name|NULL
condition|?
literal|0L
else|:
name|csysdep_size
argument_list|(
name|zfile
argument_list|)
argument_list|,
name|qlook
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|printf
argument_list|(
literal|"Requesting %s to %s"
argument_list|,
name|qlook
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qlook
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|printf
argument_list|(
literal|"Requesting %s to %s"
argument_list|,
name|qlook
operator|->
name|s
operator|.
name|zfrom
argument_list|,
name|qlook
operator|->
name|s
operator|.
name|zto
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|DEBUG
operator|>
literal|0
default|default:
name|printf
argument_list|(
literal|"Bad line %d"
argument_list|,
name|qlook
operator|->
name|s
operator|.
name|bcmd
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zxqt
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|long
name|csize
decl_stmt|;
name|struct
name|scmdlist
modifier|*
name|qsize
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
comment|/* Show the command for an execution file.  */
name|zxqt
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qsys
argument_list|,
name|qlook
operator|->
name|s
operator|.
name|zfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|zxqt
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|e
operator|=
name|fopen
argument_list|(
name|zxqt
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"fopen (%s): %s"
argument_list|,
name|zxqt
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|csize
operator|=
literal|0L
expr_stmt|;
for|for
control|(
name|qsize
operator|=
name|qlist
init|;
name|qsize
operator|!=
name|NULL
condition|;
name|qsize
operator|=
name|qsize
operator|->
name|qnext
control|)
block|{
if|if
condition|(
name|qsize
operator|->
name|s
operator|.
name|bcmd
operator|==
literal|'S'
condition|)
block|{
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|qsize
operator|->
name|s
operator|.
name|zoptions
argument_list|,
literal|'C'
argument_list|)
operator|!=
name|NULL
operator|||
name|fspool_file
argument_list|(
name|qsize
operator|->
name|s
operator|.
name|zfrom
argument_list|)
condition|)
name|zfile
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qsys
argument_list|,
name|qsize
operator|->
name|s
operator|.
name|ztemp
argument_list|)
expr_stmt|;
else|else
name|zfile
operator|=
name|zsysdep_real_file_name
argument_list|(
name|qsys
argument_list|,
name|qsize
operator|->
name|s
operator|.
name|zfrom
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfile
operator|!=
name|NULL
condition|)
name|csize
operator|+=
name|csysdep_size
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
block|}
block|}
name|usworkfile_header
argument_list|(
name|qsys
argument_list|,
operator|&
name|qlook
operator|->
name|s
argument_list|,
name|zlistid
argument_list|,
name|qlook
operator|->
name|itime
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|zline
operator|=
name|zfgets
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|ztok
decl_stmt|;
name|ztok
operator|=
name|strtok
argument_list|(
name|zline
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|ztok
argument_list|,
literal|"C"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|zcmd
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|zcmd
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|zcmd
operator|+=
name|strspn
argument_list|(
name|zcmd
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|zcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd
index|[
name|clen
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|zcmd
index|[
name|clen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"Executing %s"
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
break|break;
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zline
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"Unrecognized execution"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (sending %ld bytes)\n"
argument_list|,
name|csize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* Free up the list of entries.  */
name|qlook
operator|=
name|qlist
expr_stmt|;
while|while
condition|(
name|qlook
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scmdlist
modifier|*
name|qnext
decl_stmt|;
name|qnext
operator|=
name|qlook
operator|->
name|qnext
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qlook
argument_list|)
expr_stmt|;
name|qlook
operator|=
name|qnext
expr_stmt|;
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zlistid
argument_list|)
expr_stmt|;
name|qlist
operator|=
name|NULL
expr_stmt|;
name|zlistid
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Start a new list with the entry we just got.  */
if|if
condition|(
name|qcmd
operator|!=
name|NULL
condition|)
block|{
name|qlist
operator|=
operator|(
expr|struct
name|scmdlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scmdlist
argument_list|)
argument_list|)
expr_stmt|;
name|qlist
operator|->
name|qnext
operator|=
name|NULL
expr_stmt|;
name|qlist
operator|->
name|s
operator|=
operator|*
name|qcmd
expr_stmt|;
name|qlist
operator|->
name|itime
operator|=
name|itime
expr_stmt|;
name|zlistid
operator|=
name|zid
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Show the header of the line describing a workfile.  */
end_comment

begin_function
specifier|static
name|void
name|usworkfile_header
parameter_list|(
name|qsys
parameter_list|,
name|qcmd
parameter_list|,
name|zjobid
parameter_list|,
name|itime
parameter_list|,
name|ffirst
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|zjobid
decl_stmt|;
name|long
name|itime
decl_stmt|;
name|boolean
name|ffirst
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zshowid
decl_stmt|;
name|struct
name|tm
name|stime
decl_stmt|;
if|if
condition|(
name|ffirst
condition|)
name|zshowid
operator|=
name|zjobid
expr_stmt|;
else|else
name|zshowid
operator|=
literal|"-"
expr_stmt|;
name|printf
argument_list|(
literal|"%.14s %s %s "
argument_list|,
name|zshowid
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|qcmd
operator|->
name|zuser
argument_list|)
expr_stmt|;
name|usysdep_localtime
argument_list|(
name|itime
argument_list|,
operator|&
name|stime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%04d-%02d-%02d %02d:%02d:%02d "
argument_list|,
name|stime
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|stime
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|stime
operator|.
name|tm_mday
argument_list|,
name|stime
operator|.
name|tm_hour
argument_list|,
name|stime
operator|.
name|tm_min
argument_list|,
name|stime
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the -q option.  For each remote system this lists the number    of jobs queued, the number of executions queued, and the current    call status.  We get the executions all at once, because they are    not accessed by system.  They could be, but it is possible to have    executions pending for an unknown system, so special handling would    still be required.  */
end_comment

begin_struct
struct|struct
name|sxqtlist
block|{
name|struct
name|sxqtlist
modifier|*
name|qnext
decl_stmt|;
name|char
modifier|*
name|zsystem
decl_stmt|;
name|int
name|cxqts
decl_stmt|;
name|long
name|ifirst
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* These local functions need the definition of sxqtlist for the    prototype.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fsquery_system
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
expr|struct
name|sxqtlist
operator|*
operator|*
name|pq
operator|,
name|long
name|inow
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fsquery_show
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
name|int
name|cwork
operator|,
name|long
name|ifirstwork
operator|,
expr|struct
name|sxqtlist
operator|*
name|qxqt
operator|,
name|long
name|inow
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|fsquery
parameter_list|()
block|{
name|struct
name|sxqtlist
modifier|*
name|qlist
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|boolean
name|ferr
decl_stmt|;
name|long
name|inow
decl_stmt|;
name|int
name|csystems
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|pas
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get a count of all the execution files.  */
if|if
condition|(
operator|!
name|fsysdep_get_xqt_init
argument_list|()
condition|)
return|return
name|FALSE
return|;
name|qlist
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|zfile
operator|=
name|zsysdep_get_xqt
argument_list|(
operator|&
name|zsystem
argument_list|,
operator|&
name|ferr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sxqtlist
modifier|*
name|qlook
decl_stmt|;
for|for
control|(
name|qlook
operator|=
name|qlist
init|;
name|qlook
operator|!=
name|NULL
condition|;
name|qlook
operator|=
name|qlook
operator|->
name|qnext
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|zsystem
argument_list|,
name|qlook
operator|->
name|zsystem
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|qlook
operator|!=
name|NULL
condition|)
block|{
name|long
name|itime
decl_stmt|;
operator|++
name|qlook
operator|->
name|cxqts
expr_stmt|;
name|itime
operator|=
name|isysdep_file_time
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|itime
operator|<
name|qlook
operator|->
name|ifirst
condition|)
name|qlook
operator|->
name|ifirst
operator|=
name|itime
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sxqtlist
modifier|*
name|qnew
decl_stmt|;
name|qnew
operator|=
operator|(
expr|struct
name|sxqtlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sxqtlist
argument_list|)
argument_list|)
expr_stmt|;
name|qnew
operator|->
name|qnext
operator|=
name|qlist
expr_stmt|;
name|qnew
operator|->
name|zsystem
operator|=
name|xstrdup
argument_list|(
name|zsystem
argument_list|)
expr_stmt|;
name|qnew
operator|->
name|cxqts
operator|=
literal|1
expr_stmt|;
name|qnew
operator|->
name|ifirst
operator|=
name|isysdep_file_time
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
name|qlist
operator|=
name|qnew
expr_stmt|;
block|}
block|}
name|usysdep_get_xqt_free
argument_list|()
expr_stmt|;
if|if
condition|(
name|ferr
condition|)
return|return
name|FALSE
return|;
name|inow
operator|=
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get a count of all the work files, and print out the system.  */
name|uread_all_system_info
argument_list|(
operator|&
name|csystems
argument_list|,
operator|&
name|pas
argument_list|)
expr_stmt|;
name|fret
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|csystems
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fsquery_system
argument_list|(
operator|&
name|pas
index|[
name|i
index|]
argument_list|,
operator|&
name|qlist
argument_list|,
name|inow
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
comment|/* Check for the local system in the list of execution files.  */
if|if
condition|(
name|qlist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sxqtlist
modifier|*
modifier|*
name|pq
decl_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|qlist
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|zsystem
argument_list|,
name|zLocalname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|sxqtlist
modifier|*
name|qfree
decl_stmt|;
if|if
condition|(
operator|!
name|fsquery_show
argument_list|(
operator|&
name|sLocalsys
argument_list|,
literal|0
argument_list|,
literal|0L
argument_list|,
operator|*
name|pq
argument_list|,
name|inow
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
name|qfree
operator|=
operator|*
name|pq
expr_stmt|;
operator|*
name|pq
operator|=
name|qfree
operator|->
name|qnext
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qfree
operator|->
name|zsystem
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qfree
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Print out information for any unknown systems for which we have      execution files.  */
if|if
condition|(
name|qlist
operator|!=
name|NULL
operator|&&
operator|!
name|fUnknown_ok
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Executions queued up for unknown systems"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|qlist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sxqtlist
modifier|*
name|qnext
decl_stmt|;
name|sUnknown
operator|.
name|zname
operator|=
name|qlist
operator|->
name|zsystem
expr_stmt|;
if|if
condition|(
operator|!
name|fsquery_show
argument_list|(
operator|&
name|sUnknown
argument_list|,
literal|0
argument_list|,
literal|0L
argument_list|,
name|qlist
argument_list|,
name|inow
argument_list|)
condition|)
name|fret
operator|=
name|FALSE
expr_stmt|;
name|qnext
operator|=
name|qlist
operator|->
name|qnext
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qlist
operator|->
name|zsystem
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qlist
argument_list|)
expr_stmt|;
name|qlist
operator|=
name|qnext
expr_stmt|;
block|}
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Query a single known system.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsquery_system
parameter_list|(
name|qsys
parameter_list|,
name|pq
parameter_list|,
name|inow
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|struct
name|sxqtlist
modifier|*
modifier|*
name|pq
decl_stmt|;
name|long
name|inow
decl_stmt|;
block|{
name|int
name|cwork
decl_stmt|;
name|long
name|ifirstwork
decl_stmt|;
name|boolean
name|fret
decl_stmt|;
if|if
condition|(
operator|!
name|fsysdep_get_work_init
argument_list|(
name|qsys
argument_list|,
name|BGRADE_LOW
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|cwork
operator|=
literal|0
expr_stmt|;
name|ifirstwork
operator|=
literal|0L
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|struct
name|scmd
name|s
decl_stmt|;
name|long
name|itime
decl_stmt|;
if|if
condition|(
operator|!
name|fsysdep_get_work
argument_list|(
name|qsys
argument_list|,
name|BGRADE_LOW
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|s
operator|.
name|bcmd
operator|==
literal|'H'
condition|)
break|break;
operator|++
name|cwork
expr_stmt|;
name|itime
operator|=
name|isysdep_work_time
argument_list|(
name|qsys
argument_list|,
name|s
operator|.
name|pseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifirstwork
operator|==
literal|0L
operator|||
name|ifirstwork
operator|>
name|itime
condition|)
name|ifirstwork
operator|=
name|itime
expr_stmt|;
block|}
name|usysdep_get_work_free
argument_list|(
name|qsys
argument_list|)
expr_stmt|;
comment|/* Find the execution information, if any.  */
while|while
condition|(
operator|*
name|pq
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|zsystem
argument_list|,
name|qsys
operator|->
name|zname
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qnext
expr_stmt|;
block|}
comment|/* If there are no commands and no executions, don't print any      information for this system.  */
if|if
condition|(
name|cwork
operator|==
literal|0
operator|&&
operator|*
name|pq
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|fret
operator|=
name|fsquery_show
argument_list|(
name|qsys
argument_list|,
name|cwork
argument_list|,
name|ifirstwork
argument_list|,
operator|*
name|pq
argument_list|,
name|inow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pq
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sxqtlist
modifier|*
name|qfree
decl_stmt|;
name|qfree
operator|=
operator|*
name|pq
expr_stmt|;
operator|*
name|pq
operator|=
name|qfree
operator|->
name|qnext
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qfree
operator|->
name|zsystem
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qfree
argument_list|)
expr_stmt|;
block|}
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Print out the query information for a single system.  We handle the    local system specially.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsquery_show
parameter_list|(
name|qsys
parameter_list|,
name|cwork
parameter_list|,
name|ifirstwork
parameter_list|,
name|qxqt
parameter_list|,
name|inow
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|int
name|cwork
decl_stmt|;
name|long
name|ifirstwork
decl_stmt|;
name|struct
name|sxqtlist
modifier|*
name|qxqt
decl_stmt|;
name|long
name|inow
decl_stmt|;
block|{
name|boolean
name|flocal
decl_stmt|;
name|struct
name|sstatus
name|sstat
decl_stmt|;
name|struct
name|tm
name|stime
decl_stmt|;
name|flocal
operator|=
name|strcmp
argument_list|(
name|qsys
operator|->
name|zname
argument_list|,
name|zLocalname
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|flocal
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_get_status
argument_list|(
name|qsys
argument_list|,
operator|&
name|sstat
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|printf
argument_list|(
literal|"%s %dC ("
argument_list|,
name|qsys
operator|->
name|zname
argument_list|,
name|cwork
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwork
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"0 secs"
argument_list|)
expr_stmt|;
else|else
name|usunits_show
argument_list|(
name|inow
operator|-
name|ifirstwork
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
if|if
condition|(
name|qxqt
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"0X (0 secs)"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%dX ("
argument_list|,
name|qxqt
operator|->
name|cxqts
argument_list|)
expr_stmt|;
name|usunits_show
argument_list|(
name|inow
operator|-
name|qxqt
operator|->
name|ifirst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flocal
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|usysdep_localtime
argument_list|(
name|sstat
operator|.
name|ilast
argument_list|,
operator|&
name|stime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %04d-%02d-%02d %02d:%02d:%02d "
argument_list|,
name|stime
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|stime
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|stime
operator|.
name|tm_mday
argument_list|,
name|stime
operator|.
name|tm_hour
argument_list|,
name|stime
operator|.
name|tm_min
argument_list|,
name|stime
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|azStatus
index|[
operator|(
name|int
operator|)
name|sstat
operator|.
name|ttype
index|]
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Print a time difference in the largest applicable units.  */
end_comment

begin_function
specifier|static
name|void
name|usunits_show
parameter_list|(
name|idiff
parameter_list|)
name|long
name|idiff
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zunit
decl_stmt|;
name|long
name|iunits
decl_stmt|;
if|if
condition|(
name|idiff
operator|>
operator|(
name|long
operator|)
literal|24
operator|*
operator|(
name|long
operator|)
literal|60
operator|*
operator|(
name|long
operator|)
literal|60
condition|)
block|{
name|iunits
operator|=
name|idiff
operator|/
operator|(
operator|(
name|long
operator|)
literal|24
operator|*
operator|(
name|long
operator|)
literal|60
operator|*
operator|(
name|long
operator|)
literal|60
operator|)
expr_stmt|;
name|zunit
operator|=
literal|"day"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idiff
operator|>
operator|(
name|long
operator|)
literal|60
operator|*
literal|60
condition|)
block|{
name|iunits
operator|=
name|idiff
operator|/
call|(
name|long
call|)
argument_list|(
literal|60
operator|*
literal|60
argument_list|)
expr_stmt|;
name|zunit
operator|=
literal|"hour"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idiff
operator|>
operator|(
name|long
operator|)
literal|60
condition|)
block|{
name|iunits
operator|=
name|idiff
operator|/
operator|(
name|long
operator|)
literal|60
expr_stmt|;
name|zunit
operator|=
literal|"min"
expr_stmt|;
block|}
else|else
block|{
name|iunits
operator|=
name|idiff
expr_stmt|;
name|zunit
operator|=
literal|"sec"
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%ld %s%s"
argument_list|,
name|iunits
argument_list|,
name|zunit
argument_list|,
name|iunits
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Give a list of all status entries for all machines that we have    status entries for.  We need to get a list of status entries in a    system dependent fashion, since we may have status for unknown    systems.  */
end_comment

begin_function
specifier|static
name|boolean
name|fsmachines
parameter_list|()
block|{
name|pointer
name|phold
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|;
name|boolean
name|ferr
decl_stmt|;
name|struct
name|sstatus
name|sstat
decl_stmt|;
if|if
condition|(
operator|!
name|fsysdep_all_status_init
argument_list|(
operator|&
name|phold
argument_list|)
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
operator|(
name|zsystem
operator|=
name|zsysdep_all_status
argument_list|(
name|phold
argument_list|,
operator|&
name|ferr
argument_list|,
operator|&
name|sstat
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|tm
name|stime
decl_stmt|;
name|usysdep_localtime
argument_list|(
name|sstat
operator|.
name|ilast
argument_list|,
operator|&
name|stime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-14s %04d-%02d-%02d %02d:%02d:%02d %s"
argument_list|,
name|zsystem
argument_list|,
name|stime
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|stime
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|stime
operator|.
name|tm_mday
argument_list|,
name|stime
operator|.
name|tm_hour
argument_list|,
name|stime
operator|.
name|tm_min
argument_list|,
name|stime
operator|.
name|tm_sec
argument_list|,
name|azStatus
index|[
operator|(
name|int
operator|)
name|sstat
operator|.
name|ttype
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstat
operator|.
name|ttype
operator|!=
name|STATUS_TALKING
operator|&&
name|sstat
operator|.
name|cwait
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" (%d %s"
argument_list|,
name|sstat
operator|.
name|cretries
argument_list|,
name|sstat
operator|.
name|cretries
operator|==
literal|1
condition|?
literal|"try"
else|:
literal|"tries"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstat
operator|.
name|ilast
operator|+
name|sstat
operator|.
name|cwait
operator|>
name|isysdep_time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|usysdep_localtime
argument_list|(
name|sstat
operator|.
name|ilast
operator|+
name|sstat
operator|.
name|cwait
argument_list|,
operator|&
name|stime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", next %04d-%02d-%02d %02d:%02d:%02d"
argument_list|,
name|stime
operator|.
name|tm_year
operator|+
literal|1900
argument_list|,
name|stime
operator|.
name|tm_mon
operator|+
literal|1
argument_list|,
name|stime
operator|.
name|tm_mday
argument_list|,
name|stime
operator|.
name|tm_hour
argument_list|,
name|stime
operator|.
name|tm_min
argument_list|,
name|stime
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|usysdep_all_status_free
argument_list|(
name|phold
argument_list|)
expr_stmt|;
return|return
operator|!
name|ferr
return|;
block|}
end_function

end_unit

