begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tstuu.c    Test the uucp package on a UNIX system.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: tstuu.c,v $  * Revision 1.2  1992/05/13  05:42:07  rich  * ported to 386bsd  *  * Revision 1.1  1992/05/10  20:03:07  rich  * Initial revision  *    Revision 1.52  1992/04/02  23:02:40  ian    Conditionally declare times     Revision 1.51  1992/03/28  04:29:19  ian    Roberto Biancardi: define SIGCHLD as SIGCLD if necessary     Revision 1.50  1992/03/16  22:22:35  ian    Adjusted external declarations     Revision 1.49  1992/03/15  01:54:46  ian    All execs are now done in isspawn, all waits are done in iswait     Revision 1.48  1992/03/12  19:54:43  ian    Debugging based on types rather than number     Revision 1.47  1992/03/08  17:02:24  ian    Ted Lindgreen: don't include<sys/ioctl.h> if it's not there     Revision 1.46  1992/03/04  15:38:19  ian    Roberto Biancardi: use poll if we haven't got select     Revision 1.45  1992/03/04  01:40:51  ian    Thomas Fischer: tweaked a bit for the NeXT     Revision 1.44  1992/02/27  05:40:54  ian    T. William Wells: detach from controlling terminal, handle signals safely     Revision 1.43  1992/02/24  20:07:43  ian    John Theus: some systems don't have<fcntl.h>     Revision 1.42  1992/02/24  04:58:47  ian    Only permit files to be received into directories that are world-writeable     Revision 1.41  1992/02/23  03:26:51  ian    Overhaul to use automatic configure shell script     Revision 1.40  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.39  1992/01/29  04:27:11  ian    Jay Vassos-Libove: removed some conflicting declarations     Revision 1.38  1992/01/19  02:53:05  ian    Mike Park: don't sleep when buffer is full; it's too slow     Revision 1.37  1992/01/16  16:32:44  ian    Mike Park: ioctl is sometimes declared varadic, so we can't declare it     Revision 1.36  1992/01/15  21:06:11  ian    Mike Park: some systems can't include<sys/time.h> and<time.h> together     Revision 1.35  1992/01/15  20:48:41  ian    Mike Park: removed prototype for times     Revision 1.34  1992/01/15  20:02:05  ian    Mike Park: sh on NeXT interprets leading ~ (incredible, isn't it)     Revision 1.33  1992/01/15  19:40:35  ian    Mike Park: handle HAVE_UNION_WAIT correctly and completely     Revision 1.32  1992/01/13  19:38:16  ian    Chip Salzenberg: can't declare execl, since it is varadic     Revision 1.31  1992/01/13  06:11:39  ian    David Nugent: can't declare open or fcntl     Revision 1.30  1992/01/13  05:53:04  ian    Mike Park: added HAVE_WAITPID and HAVE_WAIT4 configuration parameters     Revision 1.29  1992/01/13  05:37:20  ian    Mike Park: use IPUBLIC_DIRECTORY_MODE rather than S_ macros     Revision 1.28  1991/12/29  04:04:18  ian    Added a bunch of extern definitions     Revision 1.27  1991/12/29  00:55:23  ian    Monty Solomon: added HAVE_UNION_WAIT     Revision 1.26  1991/12/28  06:35:05  ian    Use TIMES_TICK rather than CLK_TCK     Revision 1.25  1991/12/28  06:10:50  ian    Added HAVE_STRCHR and HAVE_INDEX to conf.h     Revision 1.24  1991/12/28  04:05:13  ian    Create spool directories     Revision 1.23  1991/12/28  03:49:23  ian    Added HAVE_MEMFNS and HAVE_BFNS; changed uses of memset to bzero     Revision 1.22  1991/12/22  22:14:19  ian    Monty Solomon: added HAVE_UNISTD_H configuration parameter     Revision 1.21  1991/12/21  22:07:47  ian    John Theus: don't warn if port file does not exist     Revision 1.20  1991/12/19  04:25:57  ian    Terry Gardner: configuration parameter to not use both NONBLOCK and NDELAY     Revision 1.19  1991/12/19  03:55:40  ian    Give the uucico processes a chance to die on their own     Revision 1.18  1991/12/18  05:12:00  ian    Added -l option to uucico to prompt for login name once and then exit     Revision 1.17  1991/12/17  22:21:19  ian    Sleep before printing login to wait until input has been flushed     Revision 1.16  1991/12/17  04:55:01  ian    David Nugent: ignore SIGHUP in uucico and uuxqt     Revision 1.15  1991/12/11  04:21:37  ian    Arne Ludwig: merge in Arne Ludwig's patches for V2 and BNU style logging     Revision 1.14  1991/12/07  02:57:28  ian    Allow failure message to be sent from uux test     Revision 1.13  1991/12/01  19:58:01  ian    Don't use the not-very-portable fd_set typedef at all     Revision 1.12  1991/12/01  19:41:00  ian    Don't read V2 or BNU configuration files while testing     Revision 1.11  1991/12/01  03:29:30  ian    Bob Izenberg: get definitions for EAGAIN and EWOULDBLOCK     Revision 1.10  1991/12/01  02:23:12  ian    Niels Baggesen: don't multiply include<unistd.h>     Revision 1.9  1991/12/01  02:12:02  ian    David Nugent: some systems don't define O_NDELAY     Revision 1.8  1991/11/26  02:13:48  ian    Bob Denny: Add definitions for FD_SET, FD_ZERO and FD_ISSET     Revision 1.7  1991/11/26  01:45:42  ian    Marty Shannon: configuration option to not include<sys/wait.h>     Revision 1.6  1991/11/21  22:17:06  ian    Add version string, print version when printing usage     Revision 1.5  1991/11/14  21:07:15  ian    Create port file and add protocol command for second system     Revision 1.4  1991/11/12  19:47:04  ian    Add called-chat set of commands to run a chat script on an incoming call     Revision 1.3  1991/11/11  23:47:24  ian    Added chat-program to run a program to do a chat script     Revision 1.2  1991/11/11  04:21:16  ian    Added 'f' protocol     Revision 1.1  1991/09/10  19:40:31  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|tstuu_rcsid
index|[]
init|=
literal|"$Id: tstuu.c,v 1.2 1992/05/13 05:42:07 rich Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|USE_STDIO
operator|&&
name|HAVE_UNISTD_H
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_IOCTL_H
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SELECT
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_POLL
end_if

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_FILE_H
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_define
define|#
directive|define
name|O_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_TIME_H
operator|&&
operator|(
name|HAVE_SYS_TIME_AND_TIME_H
operator|||
operator|!
name|HAVE_SELECT
operator|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_WAIT_H
end_if

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_UNION_WAIT
end_if

begin_typedef
typedef|typedef
name|union
name|wait
name|wait_status
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
name|wait_status
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* Get definitions for both O_NONBLOCK and O_NDELAY.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_NDELAY
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|FNDELAY
end_ifdef

begin_define
define|#
directive|define
name|O_NDELAY
value|FNDELAY
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (FNDELAY) */
end_comment

begin_define
define|#
directive|define
name|O_NDELAY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (FNDELAY) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (O_NDELAY) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_NONBLOCK
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|FNBLOCK
end_ifdef

begin_define
define|#
directive|define
name|O_NONBLOCK
value|FNBLOCK
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (FNBLOCK) */
end_comment

begin_define
define|#
directive|define
name|O_NONBLOCK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (FNBLOCK) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (O_NONBLOCK) */
end_comment

begin_if
if|#
directive|if
name|O_NDELAY
operator|==
literal|0
operator|&&
name|O_NONBLOCK
operator|==
literal|0
end_if

begin_error
error|#
directive|error
error|No way to do nonblocking I/O
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we can define them both together, do so.  This is because some    ancient drivers on some systems appear to look for one but not the    other.  Otherwise just use O_NONBLOCK.  */
end_comment

begin_if
if|#
directive|if
name|COMBINED_UNBLOCK
end_if

begin_define
define|#
directive|define
name|FILE_UNBLOCKED
value|(O_NDELAY | O_NONBLOCK)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FILE_UNBLOCKED
value|O_NONBLOCK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get definitions for both EAGAIN and EWOULDBLOCK.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EAGAIN
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|EWOULDBLOCK
end_ifndef

begin_define
define|#
directive|define
name|EAGAIN
value|(-1)
end_define

begin_define
define|#
directive|define
name|EWOULDBLOCK
value|(-1)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined (EWOULDBLOCK) */
end_comment

begin_define
define|#
directive|define
name|EAGAIN
value|EWOULDBLOCK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (EWOULDBLOCK) */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined (EAGAIN) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EWOULDBLOCK
end_ifndef

begin_define
define|#
directive|define
name|EWOULDBLOCK
value|EAGAIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (EWOULDBLOCK) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (EAGAIN) */
end_comment

begin_comment
comment|/* Make sure we have a CLK_TCK definition, even if it makes no sense.    This is in case TIMES_TICK is defined as CLK_TCK.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CLK_TCK
end_ifndef

begin_define
define|#
directive|define
name|CLK_TCK
value|(60)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Don't try too hard to get a TIMES_TICK value; it doesn't matter    that much.  */
end_comment

begin_if
if|#
directive|if
name|TIMES_TICK
operator|==
literal|0
end_if

begin_undef
undef|#
directive|undef
name|TIMES_TICK
end_undef

begin_define
define|#
directive|define
name|TIMES_TICK
value|CLK_TCK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TIMES_DECLARATION_OK
end_if

begin_function_decl
specifier|extern
name|long
name|times
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SIGCHLD
end_ifndef

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ZUUCICO_CMD
value|"login uucp"
end_define

begin_define
define|#
directive|define
name|UUCICO_EXECL
value|"/bin/login", "login", "uucp"
end_define

begin_if
if|#
directive|if
operator|!
name|HAVE_SELECT
operator|&&
operator|!
name|HAVE_POLL
end_if

begin_error
error|#
directive|error
error|You need select or poll
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* External functions.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|close
argument_list|()
decl_stmt|,
name|dup2
argument_list|()
decl_stmt|,
name|access
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|read
argument_list|()
decl_stmt|,
name|write
argument_list|()
decl_stmt|,
name|unlink
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fclose
argument_list|()
decl_stmt|,
name|fflush
argument_list|()
decl_stmt|,
name|rand
argument_list|()
decl_stmt|,
name|system
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|pid_t
name|fork
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|HAVE_SELECT
end_if

begin_function_decl
specifier|extern
name|int
name|select
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_POLL
end_if

begin_function_decl
specifier|extern
name|int
name|poll
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_WAITPID
operator|&&
name|HAVE_WAIT4
end_if

begin_function_decl
specifier|extern
name|pid_t
name|wait4
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_REMOVE
end_if

begin_undef
undef|#
directive|undef
name|remove
end_undef

begin_define
define|#
directive|define
name|remove
value|unlink
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|umake_file
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfile
operator|,
name|int
name|cextra
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uprepare_test
name|P
argument_list|(
operator|(
name|int
name|itest
operator|,
name|boolean
name|fcall_uucico
operator|,
specifier|const
name|char
operator|*
name|zsys
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ucheck_file
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfile
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|,
name|int
name|cextra
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ucheck_test
name|P
argument_list|(
operator|(
name|int
name|itest
operator|,
name|boolean
name|fcall_uucico
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|utransfer
name|P
argument_list|(
operator|(
name|int
name|ofrom
operator|,
name|int
name|oto
operator|,
name|int
name|otoslave
operator|,
name|int
operator|*
name|pc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SIGtype
name|uchild
name|P
argument_list|(
operator|(
name|int
name|isig
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpshow
name|P
argument_list|(
operator|(
name|char
operator|*
name|z
operator|,
name|int
name|bchar
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uchoose
name|P
argument_list|(
operator|(
name|int
operator|*
name|po1
operator|,
name|int
operator|*
name|po2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fwritable
name|P
argument_list|(
operator|(
name|int
name|o
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xsystem
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zcmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zDebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iTest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fCall_uucico
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iPercent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pid_t
name|iPid1
decl_stmt|,
name|iPid2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cFrom1
decl_stmt|,
name|cFrom2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|char
name|abLogout1
index|[
sizeof|sizeof
expr|"tstout /dev/ptyp0"]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|char
name|abLogout2
index|[
sizeof|sizeof
expr|"tstout /dev/ptyp0"]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zProtocols
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|iopt
decl_stmt|;
specifier|const
name|char
modifier|*
name|zcmd1
decl_stmt|,
modifier|*
name|zcmd2
decl_stmt|;
specifier|const
name|char
modifier|*
name|zpty
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsys
decl_stmt|;
name|char
name|abpty1
index|[
sizeof|sizeof
expr|"/dev/ptyp0"]
expr_stmt|;
name|char
name|abpty2
index|[
sizeof|sizeof
expr|"/dev/ptyp0"]
expr_stmt|;
name|char
modifier|*
name|zptyname
decl_stmt|;
name|int
name|omaster1
decl_stmt|,
name|oslave1
decl_stmt|,
name|omaster2
decl_stmt|,
name|oslave2
decl_stmt|;
name|zcmd1
operator|=
name|NULL
expr_stmt|;
name|zcmd2
operator|=
name|NULL
expr_stmt|;
name|zsys
operator|=
literal|"test2"
expr_stmt|;
while|while
condition|(
operator|(
name|iopt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:p:s:t:ux:1:2:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|iopt
condition|)
block|{
case|case
literal|'c'
case|:
name|zProtocols
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|iPercent
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|zsys
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|iTest
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|fCall_uucico
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|zDebug
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|zcmd1
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|zcmd2
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Taylor UUCP version %s, copyright (C) 1991, 1992 Ian Lance Taylor\n"
argument_list|,
name|abVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: tstuu [-x] [-t #] [-u] [-1 cmd] [-2 cmd]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fCall_uucico
operator|&&
name|zcmd2
operator|==
name|NULL
condition|)
name|zcmd2
operator|=
name|ZUUCICO_CMD
expr_stmt|;
name|uprepare_test
argument_list|(
name|iTest
argument_list|,
name|fCall_uucico
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/spool1/core"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/spool2/core"
argument_list|)
expr_stmt|;
name|omaster1
operator|=
operator|-
literal|1
expr_stmt|;
name|oslave1
operator|=
operator|-
literal|1
expr_stmt|;
name|omaster2
operator|=
operator|-
literal|1
expr_stmt|;
name|oslave2
operator|=
operator|-
literal|1
expr_stmt|;
name|zptyname
operator|=
name|abpty1
expr_stmt|;
for|for
control|(
name|zpty
operator|=
literal|"pqrs"
init|;
operator|*
name|zpty
operator|!=
literal|'\0'
condition|;
operator|++
name|zpty
control|)
block|{
name|int
name|ipty
decl_stmt|;
for|for
control|(
name|ipty
operator|=
literal|0
init|;
name|ipty
operator|<
literal|16
condition|;
name|ipty
operator|++
control|)
block|{
name|int
name|om
decl_stmt|,
name|os
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|sprintf
argument_list|(
name|zptyname
argument_list|,
literal|"/dev/pty%c%c"
argument_list|,
operator|*
name|zpty
argument_list|,
literal|"0123456789abcdef"
index|[
name|ipty
index|]
argument_list|)
expr_stmt|;
name|om
operator|=
name|open
argument_list|(
name|zptyname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|om
operator|<
literal|0
condition|)
continue|continue;
name|zptyname
index|[
literal|5
index|]
operator|=
literal|'t'
expr_stmt|;
name|os
operator|=
name|open
argument_list|(
name|zptyname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|om
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|omaster1
operator|==
operator|-
literal|1
condition|)
block|{
name|omaster1
operator|=
name|om
expr_stmt|;
name|oslave1
operator|=
name|os
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
literal|"/usr/tmp/tstuu/pty1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"fopen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|zptyname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|zptyname
operator|=
name|abpty2
expr_stmt|;
block|}
else|else
block|{
name|omaster2
operator|=
name|om
expr_stmt|;
name|oslave2
operator|=
name|os
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
literal|"/usr/tmp/tstuu/pty2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"fopen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s"
argument_list|,
name|zptyname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|omaster1
operator|!=
operator|-
literal|1
operator|&&
name|omaster2
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|omaster2
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No pseudo-terminals available\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we can or these into an int for the select call.  Most      systems could use 31 instead of 15, but it should never be a      problem.  */
if|if
condition|(
name|omaster1
operator|>
literal|15
operator|||
name|omaster2
operator|>
literal|15
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File descriptors are too large\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare to log out the command if it is a login command.  On      Ultrix 4.0 uucico can only be run from login for some reason.  */
if|if
condition|(
name|zcmd1
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|zcmd1
argument_list|,
literal|"login"
argument_list|,
sizeof|sizeof
expr|"login"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|abLogout1
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|abLogout1
argument_list|,
literal|"tstout %s"
argument_list|,
name|abpty1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd2
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|zcmd2
argument_list|,
literal|"login"
argument_list|,
sizeof|sizeof
expr|"login"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|abLogout2
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|abLogout2
argument_list|,
literal|"tstout %s"
argument_list|,
name|abpty2
argument_list|)
expr_stmt|;
name|iPid1
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|iPid1
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iPid1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
literal|1
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|omaster1
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|omaster2
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|oslave2
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|oslave1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|dup2
argument_list|(
name|oslave1
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|oslave1
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"About to exec first process\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd1
operator|!=
name|NULL
condition|)
name|exit
argument_list|(
name|system
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zcmd1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|execl
argument_list|(
literal|"uucico"
argument_list|,
literal|"uucico"
argument_list|,
literal|"-I"
argument_list|,
literal|"/usr/tmp/tstuu/Config1"
argument_list|,
literal|"-q"
argument_list|,
literal|"-S"
argument_list|,
name|zsys
argument_list|,
literal|"-pstdin"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"execl failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|iPid2
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|iPid2
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|iPid1
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iPid2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
literal|1
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|omaster1
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|oslave1
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|omaster2
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|oslave2
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|dup2
argument_list|(
name|oslave2
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|oslave2
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"About to exec second process\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fCall_uucico
condition|)
block|{
operator|(
name|void
operator|)
name|execl
argument_list|(
name|UUCICO_EXECL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"execl failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zcmd2
operator|!=
name|NULL
condition|)
name|exit
argument_list|(
name|system
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zcmd2
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|execl
argument_list|(
literal|"uucico"
argument_list|,
literal|"uucico"
argument_list|,
literal|"-I"
argument_list|,
literal|"/usr/tmp/tstuu/Config2"
argument_list|,
literal|"-lq"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"execl failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|uchild
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|omaster1
argument_list|,
name|F_SETFL
argument_list|,
name|FILE_UNBLOCKED
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|omaster2
argument_list|,
name|F_SETFL
argument_list|,
name|FILE_UNBLOCKED
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|int
name|o1
decl_stmt|,
name|o2
decl_stmt|;
name|o1
operator|=
name|omaster1
expr_stmt|;
name|o2
operator|=
name|omaster2
expr_stmt|;
name|uchoose
argument_list|(
operator|&
name|o1
argument_list|,
operator|&
name|o2
argument_list|)
expr_stmt|;
if|if
condition|(
name|o1
operator|==
operator|-
literal|1
operator|&&
name|o2
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Five second pause\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|o1
operator|!=
operator|-
literal|1
operator|&&
name|fwritable
argument_list|(
name|omaster2
argument_list|)
condition|)
name|utransfer
argument_list|(
name|omaster1
argument_list|,
name|omaster2
argument_list|,
name|oslave2
argument_list|,
operator|&
name|cFrom1
argument_list|)
expr_stmt|;
if|if
condition|(
name|o2
operator|!=
operator|-
literal|1
operator|&&
name|fwritable
argument_list|(
name|omaster1
argument_list|)
condition|)
name|utransfer
argument_list|(
name|omaster2
argument_list|,
name|omaster1
argument_list|,
name|oslave1
argument_list|,
operator|&
name|cFrom2
argument_list|)
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* When a child dies, kill them both.  */
end_comment

begin_function
specifier|static
name|SIGtype
name|uchild
parameter_list|(
name|isig
parameter_list|)
name|int
name|isig
decl_stmt|;
block|{
name|struct
name|tms
name|sbase
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* Give the processes a chance to die on their own.  */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|iPid1
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|iPid2
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|times
argument_list|(
operator|&
name|sbase
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_WAITPID
operator|(
name|void
operator|)
name|waitpid
argument_list|(
name|iPid1
argument_list|,
operator|(
name|wait_status
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_WAITPID */
if|#
directive|if
name|HAVE_WAIT4
operator|(
name|void
operator|)
name|wait4
argument_list|(
name|iPid1
argument_list|,
operator|(
name|wait_status
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_WAIT4 */
operator|(
name|void
operator|)
name|wait
argument_list|(
operator|(
name|wait_status
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_WAIT4 */
endif|#
directive|endif
comment|/* ! HAVE_WAITPID */
operator|(
name|void
operator|)
name|times
argument_list|(
operator|&
name|s1
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_WAITPID
operator|(
name|void
operator|)
name|waitpid
argument_list|(
name|iPid2
argument_list|,
operator|(
name|wait_status
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_WAITPID */
if|#
directive|if
name|HAVE_WAIT4
operator|(
name|void
operator|)
name|wait4
argument_list|(
name|iPid2
argument_list|,
operator|(
name|wait_status
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_WAIT4 */
operator|(
name|void
operator|)
name|wait
argument_list|(
operator|(
name|wait_status
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_WAIT4 */
endif|#
directive|endif
comment|/* ! HAVE_WAITPID */
operator|(
name|void
operator|)
name|times
argument_list|(
operator|&
name|s2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" First child: user: %g; system: %g\n"
argument_list|,
call|(
name|double
call|)
argument_list|(
name|s1
operator|.
name|tms_cutime
operator|-
name|sbase
operator|.
name|tms_cutime
argument_list|)
operator|/
operator|(
name|double
operator|)
name|TIMES_TICK
argument_list|,
call|(
name|double
call|)
argument_list|(
name|s1
operator|.
name|tms_cstime
operator|-
name|sbase
operator|.
name|tms_cstime
argument_list|)
operator|/
operator|(
name|double
operator|)
name|TIMES_TICK
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Second child: user: %g; system: %g\n"
argument_list|,
call|(
name|double
call|)
argument_list|(
name|s2
operator|.
name|tms_cutime
operator|-
name|s1
operator|.
name|tms_cutime
argument_list|)
operator|/
operator|(
name|double
operator|)
name|TIMES_TICK
argument_list|,
call|(
name|double
call|)
argument_list|(
name|s2
operator|.
name|tms_cstime
operator|-
name|s1
operator|.
name|tms_cstime
argument_list|)
operator|/
operator|(
name|double
operator|)
name|TIMES_TICK
argument_list|)
expr_stmt|;
name|ucheck_test
argument_list|(
name|iTest
argument_list|,
name|fCall_uucico
argument_list|)
expr_stmt|;
if|if
condition|(
name|abLogout1
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Executing %s\n"
argument_list|,
name|abLogout1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|abLogout1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abLogout2
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Executing %s\n"
argument_list|,
name|abLogout2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|abLogout2
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrote %d bytes from 1 to 2\n"
argument_list|,
name|cFrom1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrote %d bytes from 2 to 1\n"
argument_list|,
name|cFrom2
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
literal|"/usr/tmp/tstuu/spool1/core"
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"core file 1 exists\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
literal|"/usr/tmp/tstuu/spool2/core"
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"core file 2 exists\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open a file without error.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|xfopen
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zname
operator|,
specifier|const
name|char
operator|*
name|zmode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|FILE
modifier|*
name|xfopen
parameter_list|(
name|zname
parameter_list|,
name|zmode
parameter_list|)
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmode
decl_stmt|;
block|{
name|FILE
modifier|*
name|eret
decl_stmt|;
name|eret
operator|=
name|fopen
argument_list|(
name|zname
argument_list|,
name|zmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|eret
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|zname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|eret
return|;
block|}
end_function

begin_comment
comment|/* Close a file without error.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|xfclose
name|P
argument_list|(
operator|(
name|FILE
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|xfclose
parameter_list|(
name|e
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a test file.  */
end_comment

begin_function
specifier|static
name|void
name|umake_file
parameter_list|(
name|z
parameter_list|,
name|c
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
name|z
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|int
name|i2
decl_stmt|;
for|for
control|(
name|i2
operator|=
literal|0
init|;
name|i2
operator|<
literal|256
condition|;
name|i2
operator|++
control|)
name|putc
argument_list|(
name|i
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|i
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check a test file.  */
end_comment

begin_function
specifier|static
name|void
name|ucheck_file
parameter_list|(
name|z
parameter_list|,
name|zerr
parameter_list|,
name|c
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
name|z
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|int
name|i2
decl_stmt|;
for|for
control|(
name|i2
operator|=
literal|0
init|;
name|i2
operator|<
literal|256
condition|;
name|i2
operator|++
control|)
block|{
name|int
name|bread
decl_stmt|;
name|bread
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
operator|==
name|EOF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unexpected EOF at position %d,%d\n"
argument_list|,
name|zerr
argument_list|,
name|i
argument_list|,
name|i2
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bread
operator|!=
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: At position %d,%d got %d expected %d\n"
argument_list|,
name|zerr
argument_list|,
name|i
argument_list|,
name|i2
argument_list|,
name|bread
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bread
decl_stmt|;
name|bread
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
operator|==
name|EOF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unexpected EOF at extra %d\n"
argument_list|,
name|zerr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bread
operator|!=
name|i
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: At extra %d got %d expected %d\n"
argument_list|,
name|zerr
argument_list|,
name|i
argument_list|,
name|bread
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getc
argument_list|(
name|e
argument_list|)
operator|!=
name|EOF
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: File is too long"
argument_list|,
name|zerr
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare all the configuration files for testing.  */
end_comment

begin_function
specifier|static
name|void
name|uprepare_test
parameter_list|(
name|itest
parameter_list|,
name|fcall_uucico
parameter_list|,
name|zsys
parameter_list|)
name|int
name|itest
decl_stmt|;
name|boolean
name|fcall_uucico
decl_stmt|;
specifier|const
name|char
modifier|*
name|zsys
decl_stmt|;
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuucp1
decl_stmt|,
modifier|*
name|zuucp2
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuux1
decl_stmt|,
modifier|*
name|zuux2
decl_stmt|;
name|char
name|ab
index|[
literal|1000
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
comment|/* We must make /usr/tmp/tstuu world writeable or we won't be able to    receive files into it.  */
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|S_IWOTH
define|#
directive|define
name|S_IWOTH
value|02
endif|#
directive|endif
if|if
condition|(
name|mkdir
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"/usr/tmp/tstuu"
argument_list|,
name|IPUBLIC_DIRECTORY_MODE
operator||
name|S_IWOTH
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|perror
argument_list|(
literal|"mkdir"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mkdir
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"/usr/tmp/tstuu/spool1"
argument_list|,
name|IPUBLIC_DIRECTORY_MODE
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|perror
argument_list|(
literal|"mkdir"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mkdir
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|"/usr/tmp/tstuu/spool2"
argument_list|,
name|IPUBLIC_DIRECTORY_MODE
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|perror
argument_list|(
literal|"mkdir"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Config1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# First test configuration file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"nodename test1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"spool /usr/tmp/tstuu/spool1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"sysfile /usr/tmp/tstuu/System1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"sysfile /usr/tmp/tstuu/System1.2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"portfile /usr/tmp/tstuu/Port1\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/Log1"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_BNU_LOGGING
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"logfile /usr/tmp/tstuu/Log1\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s\n"
argument_list|,
literal|"logfile /usr/tmp/tstuu/Log1/%s/%s"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"statfile /usr/tmp/tstuu/Stats1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"debugfile /usr/tmp/tstuu/Debug1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"callfile /usr/tmp/tstuu/Call1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"pubdir /usr/tmp/tstuu\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_V2_CONFIG
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"v2-files no\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_BNU_CONFIG
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"bnu-files no\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"debug %s\n"
argument_list|,
name|zDebug
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/System1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# This file is ignored, to test multiple system files\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"time never\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/System1.2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# First test system file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"time Any\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"port stdin\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# That was the defaults\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"system %s\n"
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcall_uucico
condition|)
block|{
name|FILE
modifier|*
name|eprog
decl_stmt|;
name|eprog
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Chat1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
comment|/* Wait for the other side to open the port and flush input.  */
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"sleep 1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"echo password $1 speed $2 1>&2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"echo test1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"exit 0\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|eprog
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
literal|"/usr/tmp/tstuu/Chat1"
argument_list|,
name|S_IRWXU
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"chat-program /usr/tmp/tstuu/Chat1 \\P \\S\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"chat word: \\P\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"chat-fail login;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"call-login *\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"call-password *\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"chat \"\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"call-transfer yes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"commands cat\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcall_uucico
operator|&&
name|iPercent
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"protocol-parameter g window 7\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"protocol-parameter g packet-size 4096\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zProtocols
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"protocol %s\n"
argument_list|,
name|zProtocols
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Port1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"port stdin\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"type stdin\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"pty true\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Call1"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"Call out password file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s test1 pass1\n"
argument_list|,
name|zsys
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fcall_uucico
condition|)
block|{
name|FILE
modifier|*
name|eprog
decl_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Config2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# Second test configuration file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"nodename test2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"spool /usr/tmp/tstuu/spool2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"sysfile /usr/tmp/tstuu/System2\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/Log2"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_BNU_LOGGING
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"logfile /usr/tmp/tstuu/Log2\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"%s\n"
argument_list|,
literal|"logfile /usr/tmp/tstuu/Log2/%s/%s"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"statfile /usr/tmp/tstuu/Stats2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"debugfile /usr/tmp/tstuu/Debug2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"passwdfile /usr/tmp/tstuu/Pass2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"pubdir /usr/tmp/tstuu\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_V2_CONFIG
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"v2-files no\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_BNU_CONFIG
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"bnu-files no\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"debug %s\n"
argument_list|,
name|zDebug
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/System2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# Second test system file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"system test1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"called-login test1\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"called-request true\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zProtocols
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"protocol %s\n"
argument_list|,
name|zProtocols
argument_list|)
expr_stmt|;
name|eprog
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Chat2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"echo port $1 1>&2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eprog
argument_list|,
literal|"exit 0\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|eprog
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"called-chat-program /bin/sh /usr/tmp/tstuu/Chat2 \\Y\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"time Any\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|xfopen
argument_list|(
literal|"/usr/tmp/tstuu/Pass2"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"# Call in password file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"test1 pass1\n"
argument_list|)
expr_stmt|;
name|xfclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|zuucp1
operator|=
literal|"./uucp -I /usr/tmp/tstuu/Config1 -r"
expr_stmt|;
name|zuux1
operator|=
literal|"./uux -I /usr/tmp/tstuu/Config1 -r"
expr_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
block|{
name|zuucp2
operator|=
literal|"/usr/bin/uucp -r"
expr_stmt|;
name|zuux2
operator|=
literal|"/usr/bin/uux -r"
expr_stmt|;
block|}
else|else
block|{
name|zuucp2
operator|=
literal|"./uucp -I /usr/tmp/tstuu/Config2 -r"
expr_stmt|;
name|zuux2
operator|=
literal|"./uux -I /usr/tmp/tstuu/Config2 -r"
expr_stmt|;
block|}
comment|/* Test transferring a file from the first system to the second.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|1
condition|)
block|{
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/from1"
expr_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
name|zto
operator|=
literal|"/usr/spool/uucppublic/to1"
expr_stmt|;
else|else
name|zto
operator|=
literal|"/usr/tmp/tstuu/to1"
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s %s %s!%s"
argument_list|,
name|zuucp1
argument_list|,
name|zfrom
argument_list|,
name|zsys
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the first system request a file from the second.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|fcall_uucico
condition|)
name|zfrom
operator|=
literal|"/usr/spool/uucppublic/from2"
expr_stmt|;
else|else
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/from2"
expr_stmt|;
name|zto
operator|=
literal|"/usr/tmp/tstuu/to2"
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s %s!%s %s"
argument_list|,
name|zuucp1
argument_list|,
name|zsys
argument_list|,
name|zfrom
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the second system send a file to the first.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|fcall_uucico
condition|)
name|zfrom
operator|=
literal|"/usr/spool/uucppublic/from3"
expr_stmt|;
else|else
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/from3"
expr_stmt|;
name|zto
operator|=
literal|"/usr/tmp/tstuu/to3"
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s -c \\~/from3 test1!~/to3"
argument_list|,
name|zuucp2
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the second system request a file from the first.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|4
condition|)
block|{
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/from4"
expr_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
name|zto
operator|=
literal|"/usr/spool/uucppublic/to4"
expr_stmt|;
else|else
name|zto
operator|=
literal|"/usr/tmp/tstuu/to4"
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s test1!%s %s"
argument_list|,
name|zuucp2
argument_list|,
name|zfrom
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the second system make an execution request.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|5
condition|)
block|{
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/from5"
expr_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
name|zto
operator|=
literal|"/usr/spool/uucppublic/to5"
expr_stmt|;
else|else
name|zto
operator|=
literal|"/usr/tmp/tstuu/to5"
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s test1!cat '<%s' '>%s'"
argument_list|,
name|zuux2
argument_list|,
name|zfrom
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the first system request a wildcard.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|6
condition|)
block|{
specifier|const
name|char
modifier|*
name|zfrom1
decl_stmt|,
modifier|*
name|zfrom2
decl_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
block|{
name|zfrom
operator|=
literal|"/usr/spool/uucppublic/to6\\*"
expr_stmt|;
name|zfrom1
operator|=
literal|"/usr/spool/uucppublic/to6.1"
expr_stmt|;
name|zfrom2
operator|=
literal|"/usr/spool/uucppublic/to6.2"
expr_stmt|;
block|}
else|else
block|{
name|zfrom
operator|=
literal|"/usr/tmp/tstuu/spool2/to6\\*"
expr_stmt|;
name|zfrom1
operator|=
literal|"/usr/tmp/tstuu/spool2/to6.1"
expr_stmt|;
name|zfrom2
operator|=
literal|"/usr/tmp/tstuu/spool2/to6.2"
expr_stmt|;
block|}
name|umake_file
argument_list|(
name|zfrom1
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
name|zfrom2
argument_list|,
literal|101
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/to6.1"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
literal|"/usr/tmp/tstuu/to6.2"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s %s!%s /usr/tmp/tstuu"
argument_list|,
name|zuucp1
argument_list|,
name|zsys
argument_list|,
name|zfrom
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* Test having the second system request a wildcard.  */
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|7
condition|)
block|{
specifier|const
name|char
modifier|*
name|zto1
decl_stmt|,
modifier|*
name|zto2
decl_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
block|{
name|zto
operator|=
literal|"/usr/spool/uucppublic"
expr_stmt|;
name|zto1
operator|=
literal|"/usr/spool/uucppublic/to7.1"
expr_stmt|;
name|zto2
operator|=
literal|"/usr/spool/uucppublic/to7.2"
expr_stmt|;
block|}
else|else
block|{
name|zto
operator|=
literal|"/usr/tmp/tstuu"
expr_stmt|;
name|zto1
operator|=
literal|"/usr/tmp/tstuu/to7.1"
expr_stmt|;
name|zto2
operator|=
literal|"/usr/tmp/tstuu/to7.2"
expr_stmt|;
block|}
name|umake_file
argument_list|(
literal|"/usr/tmp/tstuu/spool1/to7.1"
argument_list|,
literal|150
argument_list|)
expr_stmt|;
name|umake_file
argument_list|(
literal|"/usr/tmp/tstuu/spool1/to7.2"
argument_list|,
literal|155
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zto2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s test1!/usr/tmp/tstuu/spool1/to7.\\* %s"
argument_list|,
name|zuucp2
argument_list|,
name|zto
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to make sure the file transfers were successful.  */
end_comment

begin_function
specifier|static
name|void
name|ucheck_test
parameter_list|(
name|itest
parameter_list|,
name|fcall_uucico
parameter_list|)
name|int
name|itest
decl_stmt|;
name|boolean
name|fcall_uucico
decl_stmt|;
block|{
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fcall_uucico
condition|)
name|ucheck_file
argument_list|(
literal|"/usr/spool/uucppublic/to1"
argument_list|,
literal|"test 1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to1"
argument_list|,
literal|"test 1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|2
condition|)
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to2"
argument_list|,
literal|"test 2"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|3
condition|)
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to3"
argument_list|,
literal|"test 3"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|fcall_uucico
condition|)
name|ucheck_file
argument_list|(
literal|"/usr/spool/uucppublic/to4"
argument_list|,
literal|"test 4"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
else|else
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to4"
argument_list|,
literal|"test 4"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|6
condition|)
block|{
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to6.1"
argument_list|,
literal|"test 6.1"
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|ucheck_file
argument_list|(
literal|"/usr/tmp/tstuu/to6.2"
argument_list|,
literal|"test 6.2"
argument_list|,
literal|101
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itest
operator|==
literal|0
operator|||
name|itest
operator|==
literal|7
condition|)
block|{
specifier|const
name|char
modifier|*
name|zto1
decl_stmt|,
modifier|*
name|zto2
decl_stmt|;
if|if
condition|(
name|fcall_uucico
condition|)
block|{
name|zto1
operator|=
literal|"/usr/spool/uucppublic/to7.1"
expr_stmt|;
name|zto2
operator|=
literal|"/usr/spool/uucppublic/to7.2"
expr_stmt|;
block|}
else|else
block|{
name|zto1
operator|=
literal|"/usr/tmp/tstuu/to7.1"
expr_stmt|;
name|zto2
operator|=
literal|"/usr/tmp/tstuu/to7.2"
expr_stmt|;
block|}
name|ucheck_file
argument_list|(
name|zto1
argument_list|,
literal|"test 7.1"
argument_list|,
literal|150
argument_list|)
expr_stmt|;
name|ucheck_file
argument_list|(
name|zto2
argument_list|,
literal|"test 7.2"
argument_list|,
literal|155
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A debugging routine used when displaying buffers.  */
end_comment

begin_function
specifier|static
name|int
name|cpshow
parameter_list|(
name|z
parameter_list|,
name|ichar
parameter_list|)
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|ichar
decl_stmt|;
block|{
if|if
condition|(
name|isprint
argument_list|(
name|BUCHAR
argument_list|(
name|ichar
argument_list|)
argument_list|)
operator|&&
name|ichar
operator|!=
literal|'\"'
condition|)
block|{
operator|*
name|z
operator|=
operator|(
name|char
operator|)
name|ichar
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|z
operator|++
operator|=
literal|'\\'
expr_stmt|;
switch|switch
condition|(
name|ichar
condition|)
block|{
case|case
literal|'\n'
case|:
operator|*
name|z
operator|=
literal|'n'
expr_stmt|;
return|return
literal|2
return|;
case|case
literal|'\r'
case|:
operator|*
name|z
operator|=
literal|'r'
expr_stmt|;
return|return
literal|2
return|;
case|case
literal|'\"'
case|:
operator|*
name|z
operator|=
literal|'\"'
expr_stmt|;
return|return
literal|2
return|;
default|default:
name|sprintf
argument_list|(
name|z
argument_list|,
literal|"%03o"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|ichar
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Transfer data from one pseudo-terminal to the other.  */
end_comment

begin_function
specifier|static
name|void
name|utransfer
parameter_list|(
name|ofrom
parameter_list|,
name|oto
parameter_list|,
name|otoslave
parameter_list|,
name|pc
parameter_list|)
name|int
name|ofrom
decl_stmt|;
name|int
name|oto
decl_stmt|;
name|int
name|otoslave
decl_stmt|;
name|int
modifier|*
name|pc
decl_stmt|;
block|{
name|int
name|cread
decl_stmt|;
ifdef|#
directive|ifdef
name|FIONREAD
name|char
name|abbuf
index|[
literal|10000
index|]
decl_stmt|;
else|#
directive|else
name|char
name|abbuf
index|[
literal|80
index|]
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|zwrite
decl_stmt|;
name|cread
operator|=
name|read
argument_list|(
name|ofrom
argument_list|,
name|abbuf
argument_list|,
sizeof|sizeof
name|abbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cread
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|cread
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
block|{
name|char
name|abshow
index|[
literal|325
index|]
decl_stmt|;
name|char
modifier|*
name|zshow
decl_stmt|;
name|int
name|i
decl_stmt|;
name|zshow
operator|=
name|abshow
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cread
operator|&&
name|i
operator|<
literal|80
condition|;
name|i
operator|++
control|)
name|zshow
operator|+=
name|cpshow
argument_list|(
name|zshow
argument_list|,
name|abbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|cread
condition|)
block|{
operator|*
name|zshow
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|zshow
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|zshow
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|zshow
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing to %d: %d \"%s\"\n"
argument_list|,
name|oto
argument_list|,
name|cread
argument_list|,
name|abshow
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iPercent
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cread
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rand
argument_list|()
operator|%
literal|100
operator|<
name|iPercent
condition|)
block|{
operator|++
name|abbuf
index|[
name|i
index|]
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zDebug
operator|!=
name|NULL
operator|&&
name|c
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Clobbered %d bytes\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|zwrite
operator|=
name|abbuf
expr_stmt|;
while|while
condition|(
name|cread
operator|>
literal|0
condition|)
block|{
name|long
name|cunread
decl_stmt|;
name|int
name|cdo
decl_stmt|;
name|int
name|cwrote
decl_stmt|;
ifdef|#
directive|ifdef
name|FIONREAD
if|if
condition|(
name|ioctl
argument_list|(
name|otoslave
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|cunread
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"FIONREAD"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zDebug
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld unread\n"
argument_list|,
name|cunread
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! FIONREAD */
name|cunread
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* ! FIONREAD */
name|cdo
operator|=
name|cread
expr_stmt|;
if|if
condition|(
literal|256
operator|-
name|cunread
operator|<
name|cdo
condition|)
block|{
name|cdo
operator|=
literal|256
operator|-
name|cunread
expr_stmt|;
if|if
condition|(
name|cdo
operator|==
literal|0
condition|)
continue|continue;
block|}
name|cwrote
operator|=
name|write
argument_list|(
name|oto
argument_list|,
name|zwrite
argument_list|,
name|cdo
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwrote
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
name|cread
operator|-=
name|cwrote
expr_stmt|;
name|zwrite
operator|+=
name|cwrote
expr_stmt|;
operator|*
name|pc
operator|+=
name|cwrote
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A version of the system command that checks for errors.  */
end_comment

begin_function
specifier|static
name|void
name|xsystem
parameter_list|(
name|zcmd
parameter_list|)
specifier|const
name|char
modifier|*
name|zcmd
decl_stmt|;
block|{
name|int
name|istat
decl_stmt|;
name|istat
operator|=
name|system
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|istat
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command failed with status %d\n"
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pick one of two file descriptors which is ready for reading, or    return in five seconds.  If the argument is ready for reading,    leave it alone; otherwise set it to -1.  */
end_comment

begin_function
specifier|static
name|void
name|uchoose
parameter_list|(
name|po1
parameter_list|,
name|po2
parameter_list|)
name|int
modifier|*
name|po1
decl_stmt|;
name|int
modifier|*
name|po2
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_SELECT
name|int
name|iread
decl_stmt|;
name|struct
name|timeval
name|stime
decl_stmt|;
name|iread
operator|=
operator|(
literal|1
operator|<<
operator|*
name|po1
operator|)
operator||
operator|(
literal|1
operator|<<
operator|*
name|po2
operator|)
expr_stmt|;
name|stime
operator|.
name|tv_sec
operator|=
literal|5
expr_stmt|;
name|stime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
operator|(
operator|*
name|po1
operator|>
operator|*
name|po2
condition|?
operator|*
name|po1
else|:
operator|*
name|po2
operator|)
operator|+
literal|1
argument_list|,
operator|&
name|iread
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|stime
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|iread
operator|&
operator|(
literal|1
operator|<<
operator|*
name|po1
operator|)
operator|)
operator|==
literal|0
condition|)
operator|*
name|po1
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|iread
operator|&
operator|(
literal|1
operator|<<
operator|*
name|po2
operator|)
operator|)
operator|==
literal|0
condition|)
operator|*
name|po2
operator|=
operator|-
literal|1
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_SELECT */
if|#
directive|if
name|HAVE_POLL
name|struct
name|pollfd
name|as
index|[
literal|2
index|]
decl_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|fd
operator|=
operator|*
name|po1
expr_stmt|;
name|as
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|as
index|[
literal|1
index|]
operator|.
name|fd
operator|=
operator|*
name|po2
expr_stmt|;
name|as
index|[
literal|1
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
if|if
condition|(
name|poll
argument_list|(
name|as
argument_list|,
literal|2
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"poll"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|as
index|[
literal|0
index|]
operator|.
name|revents
operator|&
name|POLLIN
operator|)
operator|==
literal|0
condition|)
operator|*
name|po1
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|as
index|[
literal|1
index|]
operator|.
name|revents
operator|&
name|POLLIN
operator|)
operator|==
literal|0
condition|)
operator|*
name|po2
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_POLL */
endif|#
directive|endif
comment|/* ! HAVE_SELECT */
block|}
end_function

begin_comment
comment|/* Check whether a file descriptor can be written to.  */
end_comment

begin_function
specifier|static
name|boolean
name|fwritable
parameter_list|(
name|o
parameter_list|)
name|int
name|o
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_SELECT
name|int
name|iwrite
decl_stmt|;
name|struct
name|timeval
name|stime
decl_stmt|;
name|int
name|cfds
decl_stmt|;
name|iwrite
operator|=
literal|1
operator|<<
name|o
expr_stmt|;
name|stime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|stime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|cfds
operator|=
name|select
argument_list|(
name|o
operator|+
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|iwrite
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|stime
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfds
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
return|return
name|cfds
operator|>
literal|0
return|;
else|#
directive|else
comment|/* ! HAVE_SELECT */
if|#
directive|if
name|HAVE_POLL
name|struct
name|pollfd
name|s
decl_stmt|;
name|int
name|cfds
decl_stmt|;
name|s
operator|.
name|fd
operator|=
name|o
expr_stmt|;
name|s
operator|.
name|events
operator|=
name|POLLOUT
expr_stmt|;
name|cfds
operator|=
name|poll
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfds
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"poll"
argument_list|)
expr_stmt|;
name|uchild
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
return|return
name|cfds
operator|>
literal|0
return|;
endif|#
directive|endif
comment|/* HAVE_POLL */
endif|#
directive|endif
comment|/* ! HAVE_SELECT */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We don't want to link in util.c, since that would bring in the log    file stuff.  Instead, we have local copies of functions that may be    needed by getopt.c.  This should be done in a cleaner way.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_MEMCPY
operator|&&
operator|!
name|HAVE_BCOPY
end_if

begin_comment
comment|/* Copy one block of memory to another.  */
end_comment

begin_function
name|pointer
name|memcpy
parameter_list|(
name|ptoarg
parameter_list|,
name|pfromarg
parameter_list|,
name|c
parameter_list|)
name|pointer
name|ptoarg
decl_stmt|;
name|constpointer
name|pfromarg
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|pto
init|=
operator|(
name|char
operator|*
operator|)
name|ptoarg
decl_stmt|;
specifier|const
name|char
modifier|*
name|pfrom
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|pfromarg
decl_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
operator|*
name|pto
operator|++
operator|=
operator|*
name|pfrom
operator|++
expr_stmt|;
return|return
name|ptoarg
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_MEMCPY&& ! HAVE_BCOPY */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_STRCHR
operator|&&
operator|!
name|HAVE_INDEX
end_if

begin_comment
comment|/* Look for a character in a string.  This is supposed to work for a    null byte, although we never actually call it with one.  */
end_comment

begin_function
name|char
modifier|*
name|strchr
parameter_list|(
name|z
parameter_list|,
name|b
parameter_list|)
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|b
decl_stmt|;
block|{
name|b
operator|=
operator|(
name|char
operator|)
name|b
expr_stmt|;
while|while
condition|(
operator|*
name|z
operator|!=
name|b
condition|)
if|if
condition|(
operator|*
name|z
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|char
operator|*
operator|)
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_STRCHR&& ! HAVE_INDEX */
end_comment

end_unit

