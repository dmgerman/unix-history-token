begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* uux.c    Prepare to execute a command on a remote system.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: uux.c,v $    Revision 1.32  1992/03/15  04:51:17  ian    Keep an array of signals we've received rather than a single variable     Revision 1.31  1992/03/12  19:54:43  ian    Debugging based on types rather than number     Revision 1.30  1992/03/02  15:20:43  ian    Check iSignal before entering fread     Revision 1.29  1992/02/29  04:07:08  ian    Added -j option to uucp and uux     Revision 1.28  1992/02/29  01:06:59  ian    Chip Salzenberg: recheck file permissions before sending     Revision 1.27  1992/02/28  05:06:15  ian    T. William Wells: fsysdep_catch must be a macro     Revision 1.26  1992/02/27  05:40:54  ian    T. William Wells: detach from controlling terminal, handle signals safely     Revision 1.25  1992/02/23  03:26:51  ian    Overhaul to use automatic configure shell script     Revision 1.24  1992/02/08  22:33:32  ian    Only get the current working directory if it's going to be needed     Revision 1.23  1992/02/08  20:33:57  ian    Handle all possible signals raised by abort     Revision 1.22  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.21  1992/02/02  20:34:36  ian    Niels Baggesen: must check user permissions on access to local files     Revision 1.20  1992/01/21  19:39:12  ian    Chip Salzenberg: uucp and uux start uucico for right system, not any     Revision 1.19  1992/01/15  07:06:29  ian    Set configuration directory in Makefile rather than sysdep.h     Revision 1.18  1992/01/05  03:09:17  ian    Changed abProgram and abVersion to non const to avoid compiler bug     Revision 1.17  1992/01/05  02:51:38  ian    Allocate enough space for log message     Revision 1.16  1991/12/29  04:04:18  ian    Added a bunch of extern definitions     Revision 1.15  1991/12/21  21:16:05  ian    Franc,ois Pinard: remove parentheses from ZSHELLSEPS     Revision 1.14  1991/12/20  03:07:54  ian    Added space and tab to ZSHELLSEPS to stop command at whitespace     Revision 1.13  1991/12/18  03:54:14  ian    Made error messages to terminal appear more normal     Revision 1.12  1991/12/14  16:09:07  ian    Added -l option to uux to link files into the spool directory     Revision 1.11  1991/12/11  03:59:19  ian    Create directories when necessary; don't just assume they exist     Revision 1.10  1991/12/07  03:03:12  ian    Split arguments like sh; request sh execution if any metachars appear     Revision 1.9  1991/11/21  22:17:06  ian    Add version string, print version when printing usage     Revision 1.8  1991/11/15  19:17:32  ian    Hannu Strang: copy stdin using fread/fwrite, not fgets/fputs     Revision 1.7  1991/11/13  23:08:40  ian    Expand remote pathnames in uucp and uux; fix up uux special cases     Revision 1.6  1991/11/08  21:53:17  ian    Brian Campbell: fix argument handling when looking for '-'     Revision 1.5  1991/11/07  22:52:49  ian    Chip Salzenberg: avoid recursive strtok, handle redirection better     Revision 1.4  1991/09/19  03:23:34  ian    Chip Salzenberg: append to private debugging file, don't overwrite it     Revision 1.3  1991/09/19  02:30:37  ian    From Chip Salzenberg: check whether signal is ignored differently     Revision 1.2  1991/09/11  02:33:14  ian    Added ffork argument to fsysdep_run     Revision 1.1  1991/09/10  19:40:31  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|uux_rcsid
index|[]
init|=
literal|"$Id: uux.c,v 1.32 1992/03/15 04:51:17 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_comment
comment|/* External functions.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|fclose
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* These character lists should, perhaps, be in sysdep.h.  */
end_comment

begin_comment
comment|/* This is the list of shell metacharacters that we check for.  If one    of these is present, we request uuxqt to execute the command with    /bin/sh.  Otherwise we let it execute using execve.  */
end_comment

begin_define
define|#
directive|define
name|ZSHELLCHARS
value|"\"'`*?[;&()|<>\\$"
end_define

begin_comment
comment|/* This is the list of word separators.  We break filename arguments    at these characters.  */
end_comment

begin_define
define|#
directive|define
name|ZSHELLSEPS
value|";&*|<> \t"
end_define

begin_comment
comment|/* This is the list of word separators without the redirection    operators.  */
end_comment

begin_define
define|#
directive|define
name|ZSHELLNONREDIRSEPS
value|";&*| \t"
end_define

begin_escape
end_escape

begin_comment
comment|/* The program name.  */
end_comment

begin_decl_stmt
name|char
name|abProgram
index|[]
init|=
literal|"uux"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Long getopt options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|asXlongopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|option
modifier|*
name|_getopt_long_options
init|=
name|asXlongopts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The execute file we are creating.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eXxqt_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of commands to be spooled.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scmd
modifier|*
name|pasXcmds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cXcmds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A file to close if we're forced to exit.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|eXclose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|uxusage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxadd_xqt_line
name|P
argument_list|(
operator|(
name|int
name|bchar
operator|,
specifier|const
name|char
operator|*
name|z1
operator|,
specifier|const
name|char
operator|*
name|z2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxadd_send_file
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfrom
operator|,
specifier|const
name|char
operator|*
name|zto
operator|,
specifier|const
name|char
operator|*
name|zoptions
operator|,
specifier|const
name|char
operator|*
name|ztemp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxcopy_stdin
name|P
argument_list|(
operator|(
name|FILE
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxrecord_file
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uxabort
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|iopt
decl_stmt|;
comment|/* -a: requestor address for status reports.  */
specifier|const
name|char
modifier|*
name|zrequestor
init|=
name|NULL
decl_stmt|;
comment|/* -b: if true, return standard input on error.  */
name|boolean
name|fretstdin
init|=
name|FALSE
decl_stmt|;
comment|/* -c,-C: if true, copy to spool directory.  */
name|boolean
name|fcopy
init|=
name|FALSE
decl_stmt|;
comment|/* -c: set if -c appears explicitly; if it and -l appear, then if the      link fails we don't copy the file.  */
name|boolean
name|fdontcopy
init|=
name|FALSE
decl_stmt|;
comment|/* -I: configuration file name.  */
specifier|const
name|char
modifier|*
name|zconfig
init|=
name|NULL
decl_stmt|;
comment|/* -j: output job id.  */
name|boolean
name|fjobid
init|=
name|FALSE
decl_stmt|;
comment|/* -g: job grade.  */
name|char
name|bgrade
init|=
name|BDEFAULT_UUX_GRADE
decl_stmt|;
comment|/* -l: link file to spool directory.  */
name|boolean
name|flink
init|=
name|FALSE
decl_stmt|;
comment|/* -n: do not notify upon command completion.  */
name|boolean
name|fno_ack
init|=
name|FALSE
decl_stmt|;
comment|/* -p: read standard input for command standard input.  */
name|boolean
name|fread_stdin
init|=
name|FALSE
decl_stmt|;
comment|/* -r: do not start uucico when finished.  */
name|boolean
name|fuucico
init|=
name|TRUE
decl_stmt|;
comment|/* -s: report status to named file.  */
specifier|const
name|char
modifier|*
name|zstatus_file
init|=
name|NULL
decl_stmt|;
comment|/* -W: only expand local file names.  */
name|boolean
name|fexpand
init|=
name|TRUE
decl_stmt|;
comment|/* -z: report status only on error.  */
name|boolean
name|ferror_ack
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|zargs
decl_stmt|;
name|char
modifier|*
name|zarg
decl_stmt|;
name|char
modifier|*
name|zcmd
decl_stmt|;
name|char
modifier|*
name|zexclam
decl_stmt|;
name|boolean
name|fgetcwd
decl_stmt|;
specifier|const
name|char
modifier|*
name|zuser
decl_stmt|;
name|struct
name|ssysteminfo
name|sxqtsys
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qxqtsys
decl_stmt|;
name|boolean
name|fxqtlocal
decl_stmt|;
name|char
modifier|*
modifier|*
name|pzargs
decl_stmt|;
name|int
name|calloc_args
decl_stmt|;
name|int
name|cargs
decl_stmt|;
specifier|const
name|char
modifier|*
name|zxqtname
decl_stmt|;
name|char
name|abxqt_tname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
name|abxqt_xname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|boolean
name|fneedshell
decl_stmt|;
name|char
modifier|*
name|zprint
decl_stmt|;
specifier|const
name|char
modifier|*
name|zcall_system
decl_stmt|;
name|boolean
name|fcall_any
decl_stmt|;
name|boolean
name|fexit
decl_stmt|;
comment|/* We need to be able to read a single - as an option, which getopt      won't do.  So that we can still use getopt, we run through the      options looking for an option "-"; if we find one we change it to      "-p", which is an equivalent option.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|argv
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
literal|"-p"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
for|for
control|(
name|z
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
init|;
operator|*
name|z
operator|!=
literal|'\0'
condition|;
name|z
operator|++
control|)
block|{
comment|/* If the option takes an argument, and the argument is 		 not appended, then skip the next argument.  */
if|if
condition|(
operator|*
name|z
operator|==
literal|'a'
operator|||
operator|*
name|z
operator|==
literal|'g'
operator|||
operator|*
name|z
operator|==
literal|'I'
operator|||
operator|*
name|z
operator|==
literal|'s'
operator|||
operator|*
name|z
operator|==
literal|'x'
condition|)
block|{
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* The leading + in the getopt string means to stop processing      options as soon as a non-option argument is seen.  */
while|while
condition|(
operator|(
name|iopt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+a:bcCg:I:jlnprs:Wx:z"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|iopt
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* Set requestor name: mail address to which status reports 	     should be sent.  */
name|zrequestor
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Return standard input on error.  */
name|fretstdin
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Do not copy local files to spool directory.  */
name|fcopy
operator|=
name|FALSE
expr_stmt|;
name|fdontcopy
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Copy local files to spool directory.  */
name|fcopy
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Configuration file name.  */
name|zconfig
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
comment|/* Output jobid.  */
name|fjobid
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Set job grade.  */
name|bgrade
operator|=
name|optarg
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Link file to spool directory.  */
name|flink
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Do not notify upon command completion.  */
name|fno_ack
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Read standard input for command standard input.  */
name|fread_stdin
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Do not start uucico when finished.  */
name|fuucico
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Report status to named file.  */
name|zstatus_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* Only expand local file names.  */
name|fexpand
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* Set debugging level.  */
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'z'
case|:
comment|/* Report status only on error.  */
name|ferror_ack
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Long option found and flag set.  */
break|break;
default|default:
name|uxusage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|FGRADE_LEGAL
argument_list|(
name|bgrade
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Ignoring illegal grade"
argument_list|)
expr_stmt|;
name|bgrade
operator|=
name|BDEFAULT_UUX_GRADE
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|uxusage
argument_list|()
expr_stmt|;
name|uread_config
argument_list|(
name|zconfig
argument_list|)
expr_stmt|;
comment|/* The command and files arguments could be quoted in any number of      ways, so we split them apart ourselves.  We do this before      calling usysdep_initialize because we want to set fgetcwd      correctly.  */
name|clen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|clen
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|zargs
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
argument_list|)
expr_stmt|;
operator|*
name|zargs
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|zargs
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zargs
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/* The first argument is the command to execute.  */
name|clen
operator|=
name|strcspn
argument_list|(
name|zargs
argument_list|,
name|ZSHELLSEPS
argument_list|)
expr_stmt|;
name|zcmd
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|zcmd
argument_list|,
name|zargs
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|zcmd
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zargs
operator|+=
name|clen
expr_stmt|;
comment|/* Split the arguments out into an array.  We break the arguments      into alternating sequences of characters not in ZSHELLSEPS      and characters in ZSHELLSEPS.  We remove whitespace.  We      separate the redirection characters '>' and '<' into their      own arguments to make them easier to process below.  */
name|calloc_args
operator|=
literal|10
expr_stmt|;
name|pzargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|calloc_args
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|zarg
operator|=
name|strtok
argument_list|(
name|zargs
argument_list|,
literal|" \t"
argument_list|)
init|;
name|zarg
operator|!=
name|NULL
condition|;
name|zarg
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
block|{
while|while
condition|(
operator|*
name|zarg
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|cargs
operator|>=
name|calloc_args
operator|+
literal|1
condition|)
block|{
name|calloc_args
operator|+=
literal|10
expr_stmt|;
name|pzargs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pzargs
argument_list|,
name|calloc_args
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clen
operator|=
name|strcspn
argument_list|(
name|zarg
argument_list|,
name|ZSHELLSEPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
literal|0
condition|)
block|{
name|pzargs
index|[
name|cargs
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|pzargs
index|[
name|cargs
index|]
argument_list|,
name|zarg
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|cargs
index|]
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|cargs
expr_stmt|;
name|zarg
operator|+=
name|clen
expr_stmt|;
block|}
comment|/* We deliberately separate '>' and '<' out.  */
if|if
condition|(
operator|*
name|zarg
operator|!=
literal|'\0'
condition|)
block|{
name|clen
operator|=
name|strspn
argument_list|(
name|zarg
argument_list|,
name|ZSHELLNONREDIRSEPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|==
literal|0
condition|)
name|clen
operator|=
literal|1
expr_stmt|;
name|pzargs
index|[
name|cargs
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|clen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|pzargs
index|[
name|cargs
index|]
argument_list|,
name|zarg
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|cargs
index|]
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|cargs
expr_stmt|;
name|zarg
operator|+=
name|clen
expr_stmt|;
block|}
block|}
block|}
comment|/* Now look through the arguments to see if we are going to need the      current working directory.  We don't try to make a precise      determination, just a conservative one.  The basic idea is that      we don't want to get the cwd for 'rmail - foo!user' (note that we      don't examine the command itself).  */
name|fgetcwd
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cargs
condition|;
name|i
operator|++
control|)
block|{
name|zexclam
operator|=
name|strrchr
argument_list|(
name|pzargs
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zexclam
operator|!=
name|NULL
operator|&&
name|fsysdep_needs_cwd
argument_list|(
name|zexclam
operator|+
literal|1
argument_list|)
condition|)
block|{
name|fgetcwd
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|pzargs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'<'
operator|||
name|pzargs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'>'
operator|)
operator|&&
name|i
operator|+
literal|1
operator|<
name|cargs
operator|&&
name|strchr
argument_list|(
name|pzargs
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|'!'
argument_list|)
operator|==
name|NULL
operator|&&
name|fsysdep_needs_cwd
argument_list|(
name|pzargs
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|fgetcwd
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|SIGINT
name|usysdep_signal
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|usysdep_signal
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|usysdep_signal
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|usysdep_signal
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|usysdep_signal
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usysdep_initialize
argument_list|(
name|FALSE
argument_list|,
name|fgetcwd
argument_list|)
expr_stmt|;
name|ulog_fatal_fn
argument_list|(
name|uxabort
argument_list|)
expr_stmt|;
name|zuser
operator|=
name|zsysdep_login_name
argument_list|()
expr_stmt|;
comment|/* Figure out which system the command is to be executed on.  */
name|zexclam
operator|=
name|strchr
argument_list|(
name|zcmd
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zexclam
operator|==
name|NULL
condition|)
block|{
name|qxqtsys
operator|=
operator|&
name|sLocalsys
expr_stmt|;
name|fxqtlocal
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|zexclam
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|zcmd
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|zcmd
argument_list|,
name|zLocalname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qxqtsys
operator|=
operator|&
name|sLocalsys
expr_stmt|;
name|fxqtlocal
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fread_system_info
argument_list|(
name|zcmd
argument_list|,
operator|&
name|sxqtsys
argument_list|)
condition|)
name|qxqtsys
operator|=
operator|&
name|sxqtsys
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|fUnknown_ok
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"System %s unknown"
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
name|qxqtsys
operator|=
operator|&
name|sUnknown
expr_stmt|;
name|sUnknown
operator|.
name|zname
operator|=
name|zcmd
expr_stmt|;
block|}
name|fxqtlocal
operator|=
name|FALSE
expr_stmt|;
block|}
name|zcmd
operator|=
name|zexclam
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Make sure we have a spool directory.  */
if|if
condition|(
operator|!
name|fsysdep_make_spool_dir
argument_list|(
name|qxqtsys
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
comment|/* Name and open the execute file.  If the execution is to occur on      a remote system, we must create a data file and copy it over.  */
if|if
condition|(
name|fxqtlocal
condition|)
name|zxqtname
operator|=
name|zsysdep_xqt_file_name
argument_list|()
expr_stmt|;
else|else
name|zxqtname
operator|=
name|zsysdep_data_file_name
argument_list|(
name|qxqtsys
argument_list|,
literal|'X'
argument_list|,
name|abxqt_tname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|abxqt_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zxqtname
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|eXxqt_file
operator|=
name|esysdep_fopen
argument_list|(
name|zxqtname
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eXxqt_file
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|uxrecord_file
argument_list|(
name|xstrdup
argument_list|(
name|zxqtname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Specify the user.  */
name|uxadd_xqt_line
argument_list|(
literal|'U'
argument_list|,
name|zuser
argument_list|,
name|zLocalname
argument_list|)
expr_stmt|;
comment|/* Look through the arguments.  Any argument containing an      exclamation point character is interpreted as a file name, and is      sent to the appropriate system.  */
name|zcall_system
operator|=
name|NULL
expr_stmt|;
name|fcall_any
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cargs
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|zsystem
decl_stmt|,
modifier|*
name|zconst
decl_stmt|;
name|char
modifier|*
name|zfile
decl_stmt|;
name|boolean
name|finput
decl_stmt|,
name|foutput
decl_stmt|;
name|boolean
name|flocal
decl_stmt|;
comment|/* Check for a parenthesized argument; remove the parentheses 	 and otherwise ignore it (this is how an exclamation point is 	 quoted).  */
if|if
condition|(
name|pzargs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
block|{
name|clen
operator|=
name|strlen
argument_list|(
name|pzargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzargs
index|[
name|i
index|]
index|[
name|clen
operator|-
literal|1
index|]
operator|!=
literal|')'
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Mismatched parentheses"
argument_list|)
expr_stmt|;
else|else
name|pzargs
index|[
name|i
index|]
index|[
name|clen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|pzargs
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* Check whether we are doing a redirection.  */
name|finput
operator|=
name|FALSE
expr_stmt|;
name|foutput
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|cargs
condition|)
block|{
if|if
condition|(
name|pzargs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
name|finput
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|pzargs
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'>'
condition|)
name|foutput
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|finput
operator|||
name|foutput
condition|)
block|{
name|pzargs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|zexclam
operator|=
name|strchr
argument_list|(
name|pzargs
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
comment|/* If there is no exclamation point and no redirection, this 	 argument is left untouched.  */
if|if
condition|(
name|zexclam
operator|==
name|NULL
operator|&&
operator|!
name|finput
operator|&&
operator|!
name|foutput
condition|)
continue|continue;
comment|/* Get the system name and file name for this file.  */
if|if
condition|(
name|zexclam
operator|==
name|NULL
condition|)
block|{
name|zsystem
operator|=
name|zLocalname
expr_stmt|;
name|zfile
operator|=
name|pzargs
index|[
name|i
index|]
expr_stmt|;
name|flocal
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|zexclam
operator|=
literal|'\0'
expr_stmt|;
name|zsystem
operator|=
name|pzargs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zsystem
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|flocal
operator|=
name|strcmp
argument_list|(
name|zsystem
argument_list|,
name|zLocalname
argument_list|)
operator|==
literal|0
expr_stmt|;
else|else
block|{
name|zsystem
operator|=
name|zLocalname
expr_stmt|;
name|flocal
operator|=
name|TRUE
expr_stmt|;
block|}
name|zfile
operator|=
name|zexclam
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Add the current working directory to the file name if it's 	 not an absolute path.  */
if|if
condition|(
name|fexpand
operator|||
name|flocal
condition|)
block|{
name|zconst
operator|=
name|zsysdep_add_cwd
argument_list|(
name|zfile
argument_list|,
name|flocal
argument_list|)
expr_stmt|;
if|if
condition|(
name|zconst
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|zfile
operator|=
name|xstrdup
argument_list|(
name|zconst
argument_list|)
expr_stmt|;
block|}
comment|/* Check for output redirection.  We strip this argument out, 	 and create an O command which tells uuxqt where to send the 	 output.  */
if|if
condition|(
name|foutput
condition|)
block|{
if|if
condition|(
name|flocal
condition|)
block|{
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
name|qxqtsys
argument_list|,
name|zfile
argument_list|,
name|qxqtsys
operator|->
name|zremote_receive
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Not permitted to create %s"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zsystem
argument_list|,
name|qxqtsys
operator|->
name|zname
argument_list|)
operator|==
literal|0
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'O'
argument_list|,
name|zfile
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|uxadd_xqt_line
argument_list|(
literal|'O'
argument_list|,
name|zfile
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|finput
condition|)
block|{
if|if
condition|(
name|fread_stdin
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Standard input specified twice"
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|flocal
condition|)
block|{
name|char
modifier|*
name|zuse
decl_stmt|;
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|char
name|abtname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
name|abdname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
comment|/* It's a local file.  If requested by -C, copy the file to 	     the spool directory.  If requested by -l, link the file 	     to the spool directory; if the link fails, we copy the 	     file, unless -c was explictly used.  If the execution is 	     occurring on the local system, we force the copy as well, 	     because otherwise we would have to have some way to tell 	     uuxqt not to move the file.  If the file is being shipped 	     to another system, we must set up a transfer request. 	     First make sure the user has legitimate access, since we 	     are running setuid.  */
if|if
condition|(
operator|!
name|fsysdep_access
argument_list|(
name|zfile
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fcopy
operator|||
name|flink
operator|||
name|fxqtlocal
condition|)
block|{
name|char
modifier|*
name|zdup
decl_stmt|;
name|boolean
name|fdid
decl_stmt|;
name|zdata
operator|=
name|zsysdep_data_file_name
argument_list|(
name|qxqtsys
argument_list|,
name|bgrade
argument_list|,
name|abtname
argument_list|,
name|abdname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdata
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|zdup
operator|=
name|xstrdup
argument_list|(
name|zdata
argument_list|)
expr_stmt|;
name|uxrecord_file
argument_list|(
name|zdup
argument_list|)
expr_stmt|;
name|fdid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|flink
condition|)
block|{
name|boolean
name|fworked
decl_stmt|;
if|if
condition|(
operator|!
name|fsysdep_link
argument_list|(
name|zfile
argument_list|,
name|zdup
argument_list|,
operator|&
name|fworked
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fworked
condition|)
name|fdid
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fdontcopy
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"%s: Can't link to spool directory"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fdid
condition|)
block|{
if|if
condition|(
operator|!
name|fcopy_file
argument_list|(
name|zfile
argument_list|,
name|zdup
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zdup
argument_list|)
expr_stmt|;
name|zuse
operator|=
name|abtname
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure the daemon can access the file.  */
if|if
condition|(
operator|!
name|fsysdep_daemon_access
argument_list|(
name|zfile
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fin_directory_list
argument_list|(
operator|&
name|sLocalsys
argument_list|,
name|zfile
argument_list|,
name|sLocalsys
operator|.
name|zlocal_send
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|zuser
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"Not permitted to send from %s"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
name|zuse
operator|=
name|zfile
expr_stmt|;
name|zdata
operator|=
name|zsysdep_data_file_name
argument_list|(
name|qxqtsys
argument_list|,
name|bgrade
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|abdname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdata
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|abtname
argument_list|,
literal|"D.0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fxqtlocal
condition|)
block|{
if|if
condition|(
name|finput
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|zuse
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|pzargs
index|[
name|i
index|]
operator|=
name|zuse
expr_stmt|;
block|}
else|else
block|{
name|uxadd_send_file
argument_list|(
name|zuse
argument_list|,
name|abdname
argument_list|,
name|fcopy
operator|||
name|flink
operator|||
name|fxqtlocal
condition|?
literal|"C"
else|:
literal|"c"
argument_list|,
name|abtname
argument_list|)
expr_stmt|;
if|if
condition|(
name|finput
condition|)
block|{
name|uxadd_xqt_line
argument_list|(
literal|'F'
argument_list|,
name|abdname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|abdname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zbase
decl_stmt|;
name|zbase
operator|=
name|zsysdep_base_name
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|uxadd_xqt_line
argument_list|(
literal|'F'
argument_list|,
name|abdname
argument_list|,
name|zbase
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|zbase
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|qxqtsys
operator|->
name|zname
argument_list|,
name|zsystem
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The file is already on the system where the command is to 	     be executed.  */
if|if
condition|(
name|finput
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|zfile
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|pzargs
index|[
name|i
index|]
operator|=
name|zfile
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ssysteminfo
name|sfromsys
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qfromsys
decl_stmt|;
name|char
name|abtname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
name|abdname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|ztemp
decl_stmt|;
name|struct
name|scmd
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|zjobid
decl_stmt|;
comment|/* We need to request a remote file.  Make sure we have a 	     spool directory for the remote system.  */
if|if
condition|(
operator|!
name|fread_system_info
argument_list|(
name|zsystem
argument_list|,
operator|&
name|sfromsys
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fUnknown_ok
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"System %s unknown"
argument_list|,
name|zsystem
argument_list|)
expr_stmt|;
name|sfromsys
operator|=
name|sUnknown
expr_stmt|;
name|sfromsys
operator|.
name|zname
operator|=
name|zsystem
expr_stmt|;
block|}
name|qfromsys
operator|=
operator|&
name|sfromsys
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_make_spool_dir
argument_list|(
name|qfromsys
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
comment|/* We want the file to wind up in the spool directory of the 	     local system (whether the execution is occurring 	     locally or not); we have to use an absolute file name 	     here, because otherwise the file would wind up in the 	     spool directory of the system it is coming from.  */
if|if
condition|(
operator|!
name|fxqtlocal
condition|)
block|{
if|if
condition|(
operator|!
name|fsysdep_make_spool_dir
argument_list|(
operator|&
name|sLocalsys
argument_list|)
condition|)
name|uxabort
argument_list|()
expr_stmt|;
block|}
name|zconst
operator|=
name|zsysdep_data_file_name
argument_list|(
operator|&
name|sLocalsys
argument_list|,
name|bgrade
argument_list|,
name|abtname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zconst
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
comment|/* Request the file.  The special option '9' is a signal to 	     uucico that it's OK to receive a file into the spool 	     directory; normally such requests are rejected.  */
name|s
operator|.
name|bcmd
operator|=
literal|'R'
expr_stmt|;
name|s
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|zfrom
operator|=
name|zfile
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|abtname
expr_stmt|;
name|s
operator|.
name|zuser
operator|=
name|zuser
expr_stmt|;
name|s
operator|.
name|zoptions
operator|=
literal|"9"
expr_stmt|;
name|s
operator|.
name|ztemp
operator|=
literal|""
expr_stmt|;
name|s
operator|.
name|imode
operator|=
literal|0600
expr_stmt|;
name|s
operator|.
name|znotify
operator|=
literal|""
expr_stmt|;
name|s
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|zjobid
operator|=
name|zsysdep_spool_commands
argument_list|(
name|qfromsys
argument_list|,
name|bgrade
argument_list|,
literal|1
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|zjobid
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|fjobid
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zjobid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcall_any
condition|)
name|zcall_system
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|fcall_any
operator|=
name|TRUE
expr_stmt|;
name|zcall_system
operator|=
name|xstrdup
argument_list|(
name|qfromsys
operator|->
name|zname
argument_list|)
expr_stmt|;
block|}
comment|/* Now if the execution is to occur on another system, we 	     must create an execute file to send the file there.  The 	     name of the file on the execution system is put into 	     abdname.  */
if|if
condition|(
name|fxqtlocal
condition|)
name|ztemp
operator|=
name|abtname
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|zxqt_file
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
comment|/* Get a file name to use on the execution system.  */
if|if
condition|(
name|zsysdep_data_file_name
argument_list|(
name|qxqtsys
argument_list|,
name|bgrade
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|abdname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|ztemp
operator|=
name|abdname
expr_stmt|;
comment|/* The local spool directory was created above, if it 		 didn't already exist.  */
name|zxqt_file
operator|=
name|zsysdep_xqt_file_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|zxqt_file
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
comment|/* Queue up a uucp command to be executed locally once 		 the file arrives.  We take advantage of the file 		 renaming and moving that uuxqt does to remove the 		 file and avoid the hassles of adding the current 		 directory.  The -W switch to uucp prevents from 		 adding the current directory to the remote file.  */
name|e
operator|=
name|esysdep_fopen
argument_list|(
name|zxqt_file
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|eXclose
operator|=
name|e
expr_stmt|;
name|uxrecord_file
argument_list|(
name|xstrdup
argument_list|(
name|zxqt_file
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"U %s %s\n"
argument_list|,
name|zuser
argument_list|,
name|zLocalname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"F %s foo\n"
argument_list|,
name|abtname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
argument_list|,
literal|"C uucp -CW foo %s!%s\n"
argument_list|,
name|qxqtsys
operator|->
name|zname
argument_list|,
name|abdname
argument_list|)
expr_stmt|;
name|eXclose
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Tell the command execution to wait until the file has 	     been received, and tell it the real file name to use.  */
if|if
condition|(
name|finput
condition|)
block|{
name|uxadd_xqt_line
argument_list|(
literal|'F'
argument_list|,
name|ztemp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|ztemp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|zbase
decl_stmt|;
name|zbase
operator|=
name|zsysdep_base_name
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbase
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|uxadd_xqt_line
argument_list|(
literal|'F'
argument_list|,
name|ztemp
argument_list|,
name|zbase
argument_list|)
expr_stmt|;
name|pzargs
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|zbase
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If standard input is to be read from the stdin of uux, we read it      here into a temporary file and send it to the execute system.  */
if|if
condition|(
name|fread_stdin
condition|)
block|{
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|char
name|abtname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
name|abdname
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|zdata
operator|=
name|zsysdep_data_file_name
argument_list|(
name|qxqtsys
argument_list|,
name|bgrade
argument_list|,
name|abtname
argument_list|,
name|abdname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdata
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|e
operator|=
name|esysdep_fopen
argument_list|(
name|zdata
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|uxabort
argument_list|()
expr_stmt|;
name|eXclose
operator|=
name|e
expr_stmt|;
name|uxrecord_file
argument_list|(
name|xstrdup
argument_list|(
name|zdata
argument_list|)
argument_list|)
expr_stmt|;
name|uxcopy_stdin
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|eXclose
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fxqtlocal
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|abtname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|uxadd_xqt_line
argument_list|(
literal|'F'
argument_list|,
name|abdname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|uxadd_xqt_line
argument_list|(
literal|'I'
argument_list|,
name|abdname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|uxadd_send_file
argument_list|(
name|abtname
argument_list|,
name|abdname
argument_list|,
literal|"C"
argument_list|,
name|abtname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Here all the arguments have been determined, so the command can      be written out.  If any of the arguments contain shell      metacharacters, we request remote execution with /bin/sh (this is      the 'e' command in the execute file).  The default is assumed to      be remote execution with execve.  */
name|fprintf
argument_list|(
name|eXxqt_file
argument_list|,
literal|"C %s"
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
name|fneedshell
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|zcmd
index|[
name|strcspn
argument_list|(
name|zcmd
argument_list|,
name|ZSHELLCHARS
argument_list|)
index|]
operator|!=
literal|'\0'
condition|)
name|fneedshell
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pzargs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|eXxqt_file
argument_list|,
literal|" %s"
argument_list|,
name|pzargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pzargs
index|[
name|i
index|]
index|[
name|strcspn
argument_list|(
name|pzargs
index|[
name|i
index|]
argument_list|,
name|ZSHELLCHARS
argument_list|)
index|]
operator|!=
literal|'\0'
condition|)
name|fneedshell
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|eXxqt_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Write out all the other miscellaneous junk.  */
if|if
condition|(
name|fno_ack
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'N'
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror_ack
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'Z'
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zrequestor
operator|!=
name|NULL
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'R'
argument_list|,
name|zrequestor
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fretstdin
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'B'
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus_file
operator|!=
name|NULL
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'M'
argument_list|,
name|zstatus_file
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fneedshell
condition|)
name|uxadd_xqt_line
argument_list|(
literal|'e'
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|eXxqt_file
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fclose: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|eXxqt_file
operator|=
name|NULL
expr_stmt|;
comment|/* If the execution is to occur on another system, we must now      arrange to copy the execute file to this system.  */
if|if
condition|(
operator|!
name|fxqtlocal
condition|)
name|uxadd_send_file
argument_list|(
name|abxqt_tname
argument_list|,
name|abxqt_xname
argument_list|,
literal|"C"
argument_list|,
name|abxqt_tname
argument_list|)
expr_stmt|;
comment|/* If we got a signal, get out before spooling anything.  */
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
name|uxabort
argument_list|()
expr_stmt|;
comment|/* From here on in, it's too late.  We don't call uxabort.  */
if|if
condition|(
name|cXcmds
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zjobid
decl_stmt|;
name|zjobid
operator|=
name|zsysdep_spool_commands
argument_list|(
name|qxqtsys
argument_list|,
name|bgrade
argument_list|,
name|cXcmds
argument_list|,
name|pasXcmds
argument_list|)
expr_stmt|;
if|if
condition|(
name|zjobid
operator|==
name|NULL
condition|)
block|{
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fjobid
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zjobid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcall_any
condition|)
name|zcall_system
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|fcall_any
operator|=
name|TRUE
expr_stmt|;
name|zcall_system
operator|=
name|qxqtsys
operator|->
name|zname
expr_stmt|;
block|}
block|}
comment|/* If all that worked, make a log file entry.  All log file reports      up to this point went to stderr.  */
name|ulog_to_file
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ulog_system
argument_list|(
name|qxqtsys
operator|->
name|zname
argument_list|)
expr_stmt|;
name|ulog_user
argument_list|(
name|zuser
argument_list|)
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|zcmd
argument_list|)
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cargs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pzargs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|clen
operator|+=
name|strlen
argument_list|(
name|pzargs
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|zprint
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|clen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zprint
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zprint
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pzargs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|zprint
argument_list|,
name|pzargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zprint
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
name|zprint
index|[
name|strlen
argument_list|(
name|zprint
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Queuing %s"
argument_list|,
name|zprint
argument_list|)
expr_stmt|;
name|ulog_close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fuucico
condition|)
name|fexit
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|zcall_system
operator|!=
name|NULL
condition|)
name|fexit
operator|=
name|fsysdep_run
argument_list|(
name|TRUE
argument_list|,
literal|"uucico"
argument_list|,
literal|"-s"
argument_list|,
name|zcall_system
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fcall_any
condition|)
name|fexit
operator|=
name|fsysdep_run
argument_list|(
name|TRUE
argument_list|,
literal|"uucico"
argument_list|,
literal|"-r1"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|fexit
operator|=
name|TRUE
expr_stmt|;
block|}
name|usysdep_exit
argument_list|(
name|fexit
argument_list|)
expr_stmt|;
comment|/* Avoid error about not returning a value.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Report command usage.  */
end_comment

begin_function
specifier|static
name|void
name|uxusage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Taylor UUCP version %s, copyright (C) 1991, 1992 Ian Lance Taylor\n"
argument_list|,
name|abVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: uux [options] [-] command\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -,-p: Read standard input for standard input of command\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -c: Do not copy local files to spool directory (default)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -C: Copy local files to spool directory\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -l: link local files to spool directory\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -g grade: Set job grade (must be alphabetic)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -n: Do not report completion status\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -z: Report completion status only on error\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -r: Do not start uucico daemon\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -a address: Address to mail status report to\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -b: Return standard input with status report\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -s file: Report completion status to file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -j: Report job id\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -x debug: Set debugging level\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -I file: Set configuration file to use (default %s%s)\n"
argument_list|,
name|NEWCONFIGLIB
argument_list|,
name|CONFIGFILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a line to the execute file.  */
end_comment

begin_function
specifier|static
name|void
name|uxadd_xqt_line
parameter_list|(
name|bchar
parameter_list|,
name|z1
parameter_list|,
name|z2
parameter_list|)
name|int
name|bchar
decl_stmt|;
specifier|const
name|char
modifier|*
name|z1
decl_stmt|;
specifier|const
name|char
modifier|*
name|z2
decl_stmt|;
block|{
if|if
condition|(
name|z1
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|eXxqt_file
argument_list|,
literal|"%c\n"
argument_list|,
name|bchar
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|z2
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|eXxqt_file
argument_list|,
literal|"%c %s\n"
argument_list|,
name|bchar
argument_list|,
name|z1
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|eXxqt_file
argument_list|,
literal|"%c %s %s\n"
argument_list|,
name|bchar
argument_list|,
name|z1
argument_list|,
name|z2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a file to be sent to the execute system.  */
end_comment

begin_function
specifier|static
name|void
name|uxadd_send_file
parameter_list|(
name|zfrom
parameter_list|,
name|zto
parameter_list|,
name|zoptions
parameter_list|,
name|ztemp
parameter_list|)
specifier|const
name|char
modifier|*
name|zfrom
decl_stmt|;
specifier|const
name|char
modifier|*
name|zto
decl_stmt|;
specifier|const
name|char
modifier|*
name|zoptions
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztemp
decl_stmt|;
block|{
name|struct
name|scmd
name|s
decl_stmt|;
name|s
operator|.
name|bcmd
operator|=
literal|'S'
expr_stmt|;
name|s
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|zfrom
operator|=
name|xstrdup
argument_list|(
name|zfrom
argument_list|)
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|xstrdup
argument_list|(
name|zto
argument_list|)
expr_stmt|;
name|s
operator|.
name|zuser
operator|=
name|zsysdep_login_name
argument_list|()
expr_stmt|;
name|s
operator|.
name|zoptions
operator|=
name|xstrdup
argument_list|(
name|zoptions
argument_list|)
expr_stmt|;
name|s
operator|.
name|ztemp
operator|=
name|xstrdup
argument_list|(
name|ztemp
argument_list|)
expr_stmt|;
name|s
operator|.
name|imode
operator|=
literal|0666
expr_stmt|;
name|s
operator|.
name|znotify
operator|=
literal|""
expr_stmt|;
name|s
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|cXcmds
expr_stmt|;
name|pasXcmds
operator|=
operator|(
expr|struct
name|scmd
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pasXcmds
argument_list|,
name|cXcmds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scmd
argument_list|)
argument_list|)
expr_stmt|;
name|pasXcmds
index|[
name|cXcmds
operator|-
literal|1
index|]
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy stdin to a file.  This is a separate function because it may    call setjump.  */
end_comment

begin_function
specifier|static
name|void
name|uxcopy_stdin
parameter_list|(
name|e
parameter_list|)
name|FILE
modifier|*
name|e
decl_stmt|;
block|{
name|CATCH_PROTECT
name|int
name|cread
decl_stmt|;
name|char
name|ab
index|[
literal|1024
index|]
decl_stmt|;
do|do
block|{
name|int
name|cwrite
decl_stmt|;
if|if
condition|(
name|fsysdep_catch
argument_list|()
condition|)
block|{
name|usysdep_start_catch
argument_list|()
expr_stmt|;
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
name|uxabort
argument_list|()
expr_stmt|;
comment|/* There's an unimportant race here.  If the user hits ^C 	     between the FGOT_SIGNAL we just did and the time we enter 	     fread, we won't know about the signal (unless we're doing 	     a longjmp, but we normally aren't).  It's not a big 	     problem, because the user can just hit ^C again.  */
name|cread
operator|=
name|fread
argument_list|(
name|ab
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
sizeof|sizeof
name|ab
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
name|usysdep_end_catch
argument_list|()
expr_stmt|;
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
name|uxabort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cread
operator|>
literal|0
condition|)
block|{
name|cwrite
operator|=
name|fwrite
argument_list|(
name|ab
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|cread
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwrite
operator|!=
name|cread
condition|)
block|{
if|if
condition|(
name|cwrite
operator|==
name|EOF
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fwrite: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fwrite: Wrote %d when attempted %d"
argument_list|,
name|cwrite
argument_list|,
name|cread
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|cread
operator|==
sizeof|sizeof
name|ab
condition|)
do|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keep track of all files we have created so that we can delete them    if we get a signal.  The argument will be on the heap.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cxfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|pxaz
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|uxrecord_file
parameter_list|(
name|zfile
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
block|{
name|pxaz
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pxaz
argument_list|,
operator|(
name|cxfiles
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pxaz
index|[
name|cxfiles
index|]
operator|=
name|zfile
expr_stmt|;
operator|++
name|cxfiles
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all the files we have recorded and exit.  */
end_comment

begin_function
specifier|static
name|void
name|uxabort
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|eXxqt_file
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eXxqt_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|eXclose
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eXclose
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cxfiles
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|pxaz
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

