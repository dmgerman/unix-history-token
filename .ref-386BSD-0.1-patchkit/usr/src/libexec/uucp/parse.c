begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* parse.c    Parse a UUCP command string.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: parse.c,v $    Revision 1.3  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.2  1991/11/11  02:10:39  ian    Forget to set pseq field to NULL     Revision 1.1  1991/09/10  19:40:31  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|parse_rcsid
index|[]
init|=
literal|"$Id: parse.c,v 1.3 1992/02/08 03:54:18 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Parse a UUCP command string into an scmd structure.  This is called    by the 'g' protocol and the UNIX command file reading routines.  It    destroys the string it is passed, and the scmd string pointers are    left pointing into it.  It returns TRUE if the string is    successfully parsed, FALSE otherwise.  */
end_comment

begin_function
name|boolean
name|fparse_cmd
parameter_list|(
name|zcmd
parameter_list|,
name|qcmd
parameter_list|)
name|char
modifier|*
name|zcmd
decl_stmt|;
name|struct
name|scmd
modifier|*
name|qcmd
decl_stmt|;
block|{
name|char
modifier|*
name|z
decl_stmt|;
name|z
operator|=
name|strtok
argument_list|(
name|zcmd
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|bcmd
operator|=
operator|*
name|z
expr_stmt|;
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|!=
literal|'S'
operator|&&
name|qcmd
operator|->
name|bcmd
operator|!=
literal|'R'
operator|&&
name|qcmd
operator|->
name|bcmd
operator|!=
literal|'X'
operator|&&
name|qcmd
operator|->
name|bcmd
operator|!=
literal|'H'
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|pseq
operator|=
name|NULL
expr_stmt|;
comment|/* Handle hangup commands specially.  If it's just "H", return      the command 'H' to indicate a hangup request.  If it's "HY"      return 'Y' and if it's "HN" return 'N'.  */
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'H'
condition|)
block|{
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'Y'
condition|)
block|{
name|qcmd
operator|->
name|bcmd
operator|=
literal|'Y'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|qcmd
operator|->
name|bcmd
operator|=
literal|'N'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|z
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|FALSE
return|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|zfrom
operator|=
name|z
expr_stmt|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|zto
operator|=
name|z
expr_stmt|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|zuser
operator|=
name|z
expr_stmt|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|NULL
operator|||
operator|*
name|z
operator|!=
literal|'-'
condition|)
return|return
name|FALSE
return|;
name|qcmd
operator|->
name|zoptions
operator|=
name|z
operator|+
literal|1
expr_stmt|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
name|qcmd
operator|->
name|ztemp
operator|=
name|z
expr_stmt|;
elseif|else
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'S'
condition|)
return|return
name|FALSE
return|;
else|else
name|qcmd
operator|->
name|ztemp
operator|=
literal|""
expr_stmt|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zend
decl_stmt|;
name|qcmd
operator|->
name|imode
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|z
argument_list|,
operator|&
name|zend
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zend
operator|!=
literal|'\0'
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|qcmd
operator|->
name|bcmd
operator|==
literal|'S'
condition|)
return|return
name|FALSE
return|;
else|else
name|qcmd
operator|->
name|imode
operator|=
literal|0666
expr_stmt|;
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
name|qcmd
operator|->
name|znotify
operator|=
name|z
expr_stmt|;
else|else
name|qcmd
operator|->
name|znotify
operator|=
literal|""
expr_stmt|;
comment|/* If the notify string is "", there may be a number of bytes.  */
name|qcmd
operator|->
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|qcmd
operator|->
name|znotify
argument_list|,
literal|"\"\""
argument_list|)
operator|==
literal|0
condition|)
block|{
name|z
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zend
decl_stmt|;
name|qcmd
operator|->
name|znotify
operator|=
literal|""
expr_stmt|;
name|qcmd
operator|->
name|cbytes
operator|=
name|strtol
argument_list|(
name|z
argument_list|,
operator|&
name|zend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zend
operator|!=
literal|'\0'
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

