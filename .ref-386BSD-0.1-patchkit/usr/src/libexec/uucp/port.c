begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* port.c    Port manipulation routines for the Taylor UUCP package.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: port.c,v $    Revision 1.17  1992/04/01  22:31:05  ian    Initialize stdin port     Revision 1.16  1992/03/28  19:57:22  ian    David J. MacKenzie: send port device for /Y rather than port name     Revision 1.15  1992/03/17  01:03:03  ian    Miscellaneous cleanup     Revision 1.14  1992/03/15  06:58:12  ian    Show fport_read and fport_write calls under DEBUG_PORT     Revision 1.13  1992/03/12  19:54:43  ian    Debugging based on types rather than number     Revision 1.12  1992/03/04  00:36:44  ian    Michael Richardson: better chat script debugging     Revision 1.11  1992/02/08  19:34:07  ian    Cast result of alloca     Revision 1.10  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.9  1991/12/28  04:20:36  ian    Cleaned up debugging code     Revision 1.8  1991/12/20  02:18:35  ian    Complete diagnostics for fport_io     Revision 1.7  1991/12/15  03:42:33  ian    Added tprocess_chat_cmd for all chat commands, and added CMDTABTYPE_PREFIX     Revision 1.6  1991/12/10  19:45:05  ian    Added ulog_device to record device name for log file     Revision 1.5  1991/11/14  03:20:13  ian    Added seven-bit and reliable commands to help when selecting protocols     Revision 1.4  1991/11/13  20:38:00  ian    Added TCP port type for connections over TCP     Revision 1.3  1991/11/11  23:47:24  ian    Added chat-program to run a program to do a chat script     Revision 1.2  1991/11/11  00:39:45  ian    Open port in seven bit mode, added fport_set to change to eight bit     Revision 1.1  1991/09/10  19:40:31  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|port_rcsid
index|[]
init|=
literal|"$Id: port.c,v 1.17 1992/04/01 22:31:05 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_escape
end_escape

begin_if
if|#
directive|if
name|DEBUG
operator|>
literal|1
end_if

begin_comment
comment|/* A debugging routine used when displaying buffers.  */
end_comment

begin_function
name|int
name|cdebug_char
parameter_list|(
name|z
parameter_list|,
name|ichar
parameter_list|)
name|char
modifier|*
name|z
decl_stmt|;
name|int
name|ichar
decl_stmt|;
block|{
name|char
name|b
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|BUCHAR
argument_list|(
name|ichar
argument_list|)
argument_list|)
operator|&&
name|ichar
operator|!=
literal|'\"'
operator|&&
name|ichar
operator|!=
literal|'\\'
condition|)
block|{
operator|*
name|z
operator|++
operator|=
operator|(
name|char
operator|)
name|ichar
expr_stmt|;
operator|*
name|z
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|z
operator|++
operator|=
literal|'\\'
expr_stmt|;
switch|switch
condition|(
name|ichar
condition|)
block|{
case|case
literal|'\n'
case|:
name|b
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|b
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|b
operator|=
literal|'\"'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|b
operator|=
literal|'\\'
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|z
argument_list|,
literal|"%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|BUCHAR
argument_list|(
name|ichar
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|z
argument_list|)
operator|+
literal|1
return|;
block|}
operator|*
name|z
operator|++
operator|=
name|b
expr_stmt|;
operator|*
name|z
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Display a buffer when debugging.  */
end_comment

begin_function
name|void
name|udebug_buffer
parameter_list|(
name|zhdr
parameter_list|,
name|zbuf
parameter_list|,
name|clen
parameter_list|)
specifier|const
name|char
modifier|*
name|zhdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|zbuf
decl_stmt|;
name|int
name|clen
decl_stmt|;
block|{
name|char
modifier|*
name|z
decl_stmt|,
modifier|*
name|zalc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|z
operator|=
name|zalc
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|clen
operator|*
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|clen
operator|&&
name|i
operator|<
literal|80
condition|;
name|i
operator|++
control|)
name|z
operator|+=
name|cdebug_char
argument_list|(
name|z
argument_list|,
name|zbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|clen
condition|)
block|{
operator|*
name|z
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|z
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|z
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|z
operator|=
literal|'\0'
expr_stmt|;
name|ulog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s %d \"%s\""
argument_list|,
name|zhdr
argument_list|,
name|clen
argument_list|,
name|zalc
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zalc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG> 1 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The open port.  */
end_comment

begin_decl_stmt
name|struct
name|sport
modifier|*
name|qPort
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The port dispatch table.  The order of entries in this table must    be the same as the tporttype enumeration.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|sportcmds
name|asPortcmds
index|[]
init|=
block|{
block|{
name|fsysdep_stdin_lock
block|,
name|fsysdep_stdin_open
block|,
name|fsysdep_stdin_close
block|,
name|fsysdep_stdin_reset
block|,
name|NULL
block|,
name|fsysdep_stdin_read
block|,
name|fsysdep_stdin_write
block|,
name|fsysdep_stdin_io
block|,
name|fsysdep_stdin_break
block|,
name|fsysdep_stdin_set
block|,
name|fsysdep_stdin_chat
block|,
name|isysdep_stdin_baud
block|}
block|,
block|{
name|fsysdep_modem_lock
block|,
name|fsysdep_modem_open
block|,
name|fsysdep_modem_close
block|,
name|fsysdep_modem_reset
block|,
name|fmodem_dial
block|,
name|fsysdep_modem_read
block|,
name|fsysdep_modem_write
block|,
name|fsysdep_modem_io
block|,
name|fsysdep_modem_break
block|,
name|fsysdep_modem_set
block|,
name|fsysdep_modem_chat
block|,
name|isysdep_modem_baud
block|}
block|,
block|{
name|fsysdep_direct_lock
block|,
name|fsysdep_direct_open
block|,
name|fsysdep_direct_close
block|,
name|fsysdep_direct_reset
block|,
name|NULL
block|,
name|fsysdep_direct_read
block|,
name|fsysdep_direct_write
block|,
name|fsysdep_direct_io
block|,
name|fsysdep_direct_break
block|,
name|fsysdep_direct_set
block|,
name|fsysdep_direct_chat
block|,
name|isysdep_direct_baud
block|}
block|,
if|#
directive|if
name|HAVE_TCP
block|{
name|ftcp_lock
block|,
name|ftcp_open
block|,
name|ftcp_close
block|,
name|ftcp_reset
block|,
name|ftcp_dial
block|,
name|fsysdep_tcp_read
block|,
name|fsysdep_tcp_write
block|,
name|fsysdep_tcp_io
block|,
name|NULL
block|,
name|NULL
block|,
name|fsysdep_tcp_chat
block|,
name|itcp_baud
block|}
block|,
endif|#
directive|endif
comment|/* HAVE_TCP */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Port dispatch routines.  These could probably become macros,    although the port argument would have to be evaluated twice.  */
end_comment

begin_comment
comment|/* Lock a port.  */
end_comment

begin_function
name|boolean
name|fport_lock
parameter_list|(
name|qport
parameter_list|,
name|fin
parameter_list|)
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
name|boolean
name|fin
decl_stmt|;
block|{
return|return
operator|(
operator|*
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qport
operator|->
name|ttype
index|]
operator|.
name|pflock
operator|)
operator|(
name|qport
operator|,
name|fin
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The port structure we use when opening standard input as a port.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sport
name|sPstdin
init|=
block|{
literal|"stdin"
block|,
name|PORTTYPE_STDIN
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Open a port.  */
end_comment

begin_function
name|boolean
name|fport_open
parameter_list|(
name|qport
parameter_list|,
name|ibaud
parameter_list|,
name|ihighbaud
parameter_list|,
name|fwait
parameter_list|)
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
name|long
name|ihighbaud
decl_stmt|;
name|boolean
name|fwait
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_PORT
argument_list|)
condition|)
block|{
name|char
name|abspeed
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|ibaud
operator|==
operator|(
name|long
operator|)
literal|0
condition|)
name|strcpy
argument_list|(
name|abspeed
argument_list|,
literal|"default speed"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|abspeed
argument_list|,
literal|"speed %ld"
argument_list|,
name|ibaud
argument_list|)
expr_stmt|;
if|if
condition|(
name|qport
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"fport_open: Opening stdin port (%s)"
argument_list|,
name|abspeed
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qport
operator|->
name|zname
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"fport_open: Opening unnamed port (%s)"
argument_list|,
name|abspeed
argument_list|)
expr_stmt|;
else|else
name|ulog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"fport_open: Opening port %s (%s)"
argument_list|,
name|qport
operator|->
name|zname
argument_list|,
name|abspeed
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|qport
operator|==
name|NULL
condition|)
block|{
name|qport
operator|=
operator|&
name|sPstdin
expr_stmt|;
name|SYSDEP_STDIN_INIT
argument_list|(
operator|&
name|qport
operator|->
name|u
operator|.
name|sstdin
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
name|qPort
operator|=
name|NULL
expr_stmt|;
comment|/* If the system provides a range of baud rates, we select the      highest baud rate supported by the port.  */
if|if
condition|(
name|ihighbaud
operator|!=
literal|0
condition|)
block|{
name|ibaud
operator|=
name|ihighbaud
expr_stmt|;
if|if
condition|(
name|qport
operator|->
name|ttype
operator|==
name|PORTTYPE_MODEM
condition|)
block|{
if|if
condition|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ihighbaud
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ihighbaud
operator|<
name|ihighbaud
condition|)
name|ibaud
operator|=
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ihighbaud
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ibaud
operator|!=
literal|0
condition|)
name|ibaud
operator|=
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ibaud
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qport
operator|->
name|ttype
operator|==
name|PORTTYPE_DIRECT
condition|)
block|{
if|if
condition|(
name|qport
operator|->
name|u
operator|.
name|sdirect
operator|.
name|ibaud
operator|!=
literal|0
condition|)
name|ibaud
operator|=
name|qport
operator|->
name|u
operator|.
name|sdirect
operator|.
name|ibaud
expr_stmt|;
block|}
block|}
comment|/* This will normally be overridden by the port specific open      routine.  */
name|ulog_device
argument_list|(
name|qport
operator|->
name|zname
argument_list|)
expr_stmt|;
name|fret
operator|=
operator|(
operator|*
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qport
operator|->
name|ttype
index|]
operator|.
name|pfopen
operator|)
operator|(
name|qport
operator|,
name|ibaud
operator|,
name|fwait
operator|)
expr_stmt|;
if|if
condition|(
name|fret
condition|)
name|qPort
operator|=
name|qport
expr_stmt|;
else|else
name|ulog_device
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Close and unlock the port.  */
end_comment

begin_function
name|boolean
name|fport_close
parameter_list|(
name|fsuccess
parameter_list|)
name|boolean
name|fsuccess
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
if|if
condition|(
name|qPort
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"fport_close: Closing port"
argument_list|)
expr_stmt|;
name|fret
operator|=
operator|(
operator|*
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qPort
operator|->
name|ttype
index|]
operator|.
name|pfclose
operator|)
operator|(
name|qPort
operator|,
name|fsuccess
operator|)
expr_stmt|;
name|qPort
operator|=
name|NULL
expr_stmt|;
name|ulog_device
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Reset the port.  */
end_comment

begin_function
name|boolean
name|fport_reset
parameter_list|()
block|{
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"fport_reset: Resetting port"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qPort
operator|->
name|ttype
index|]
operator|.
name|pfreset
operator|)
operator|(
name|qPort
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dial out on the port.  */
end_comment

begin_function
name|boolean
name|fport_dial
parameter_list|(
name|qsys
parameter_list|,
name|pcproto_params
parameter_list|,
name|pqproto_params
parameter_list|,
name|pireliable
parameter_list|)
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|int
modifier|*
name|pcproto_params
decl_stmt|;
name|struct
name|sproto_param
modifier|*
modifier|*
name|pqproto_params
decl_stmt|;
name|int
modifier|*
name|pireliable
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*pfdial
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|sport
operator|*
operator|,
specifier|const
expr|struct
name|ssysteminfo
operator|*
operator|,
name|int
operator|*
operator|,
expr|struct
name|sproto_param
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
name|pfdial
operator|=
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qPort
operator|->
name|ttype
index|]
operator|.
name|pfdial
expr_stmt|;
if|if
condition|(
name|pfdial
operator|==
name|NULL
condition|)
block|{
operator|*
name|pcproto_params
operator|=
literal|0
expr_stmt|;
operator|*
name|pqproto_params
operator|=
name|NULL
expr_stmt|;
operator|*
name|pireliable
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
call|(
modifier|*
name|pfdial
call|)
argument_list|(
name|qPort
argument_list|,
name|qsys
argument_list|,
name|pcproto_params
argument_list|,
name|pqproto_params
argument_list|,
name|pireliable
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read data from the port.  */
end_comment

begin_function
name|boolean
name|fport_read
parameter_list|(
name|zbuf
parameter_list|,
name|pclen
parameter_list|,
name|cmin
parameter_list|,
name|ctimeout
parameter_list|,
name|freport
parameter_list|)
name|char
modifier|*
name|zbuf
decl_stmt|;
name|int
modifier|*
name|pclen
decl_stmt|;
name|int
name|cmin
decl_stmt|;
name|int
name|ctimeout
decl_stmt|;
name|boolean
name|freport
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
name|fret
operator|=
operator|(
operator|*
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qPort
operator|->
name|ttype
index|]
operator|.
name|pfread
operator|)
operator|(
name|qPort
operator|,
name|zbuf
operator|,
name|pclen
operator|,
name|cmin
operator|,
name|ctimeout
operator|,
name|freport
operator|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_INCOMING
argument_list|)
condition|)
name|udebug_buffer
argument_list|(
literal|"fport_read: Read"
argument_list|,
name|zbuf
argument_list|,
operator|*
name|pclen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_PORT
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"fport_read: Read %d"
argument_list|,
operator|*
name|pclen
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Write data to the port.  */
end_comment

begin_function
name|boolean
name|fport_write
parameter_list|(
name|zbuf
parameter_list|,
name|clen
parameter_list|)
specifier|const
name|char
modifier|*
name|zbuf
decl_stmt|;
name|int
name|clen
decl_stmt|;
block|{
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_OUTGOING
argument_list|)
condition|)
name|udebug_buffer
argument_list|(
literal|"fport_write: Writing"
argument_list|,
name|zbuf
argument_list|,
name|clen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_PORT
argument_list|)
condition|)
name|ulog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"fport_write: Writing %d"
argument_list|,
name|clen
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|*
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qPort
operator|->
name|ttype
index|]
operator|.
name|pfwrite
operator|)
operator|(
name|qPort
operator|,
name|zbuf
operator|,
name|clen
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read and write data.  */
end_comment

begin_function
name|boolean
name|fport_io
parameter_list|(
name|zwrite
parameter_list|,
name|pcwrite
parameter_list|,
name|zread
parameter_list|,
name|pcread
parameter_list|)
specifier|const
name|char
modifier|*
name|zwrite
decl_stmt|;
name|int
modifier|*
name|pcwrite
decl_stmt|;
name|char
modifier|*
name|zread
decl_stmt|;
name|int
modifier|*
name|pcread
decl_stmt|;
block|{
name|boolean
name|fret
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
name|int
name|cwrite
init|=
operator|*
name|pcwrite
decl_stmt|;
name|int
name|cread
init|=
operator|*
name|pcread
decl_stmt|;
if|if
condition|(
name|cread
operator|<=
literal|0
operator|||
name|cwrite
operator|<=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"fport_io: cread %d; cwrite %d"
argument_list|,
name|cread
argument_list|,
name|cwrite
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
name|FDEBUGGING
argument_list|(
name|DEBUG_OUTGOING
argument_list|)
condition|)
name|udebug_buffer
argument_list|(
literal|"fport_io: Writing"
argument_list|,
name|zwrite
argument_list|,
name|cwrite
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fret
operator|=
operator|(
operator|*
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qPort
operator|->
name|ttype
index|]
operator|.
name|pfio
operator|)
operator|(
name|qPort
operator|,
name|zwrite
operator|,
name|pcwrite
operator|,
name|zread
operator|,
name|pcread
operator|)
expr_stmt|;
name|DEBUG_MESSAGE4
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"fport_io: Wrote %d of %d, read %d of %d"
argument_list|,
operator|*
name|pcwrite
argument_list|,
name|cwrite
argument_list|,
operator|*
name|pcread
argument_list|,
name|cread
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|1
if|if
condition|(
operator|*
name|pcread
operator|>
literal|0
operator|&&
name|FDEBUGGING
argument_list|(
name|DEBUG_INCOMING
argument_list|)
condition|)
name|udebug_buffer
argument_list|(
literal|"fport_io: Read"
argument_list|,
name|zread
argument_list|,
operator|*
name|pcread
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|fret
return|;
block|}
end_function

begin_comment
comment|/* Send a break character to a port.  Some port types may not support    break characters, in which case we just return TRUE.  */
end_comment

begin_function
name|boolean
name|fport_break
parameter_list|()
block|{
name|boolean
argument_list|(
argument|*pfbreak
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|sport
operator|*
operator|)
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE0
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"fport_break: Sending break character"
argument_list|)
expr_stmt|;
name|pfbreak
operator|=
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qPort
operator|->
name|ttype
index|]
operator|.
name|pfbreak
expr_stmt|;
if|if
condition|(
name|pfbreak
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
return|return
call|(
modifier|*
name|pfbreak
call|)
argument_list|(
name|qPort
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Change the setting of a port.  Some port types may not support    this, in which case we just return TRUE.  */
end_comment

begin_function
name|boolean
name|fport_set
parameter_list|(
name|tset
parameter_list|)
name|enum
name|tportsetting
name|tset
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*pfset
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|sport
operator|*
operator|,
expr|enum
name|tportsetting
operator|)
argument_list|)
expr_stmt|;
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_PORT
argument_list|,
literal|"fport_set: Changing setting to %d"
argument_list|,
operator|(
name|int
operator|)
name|tset
argument_list|)
expr_stmt|;
name|pfset
operator|=
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qPort
operator|->
name|ttype
index|]
operator|.
name|pfset
expr_stmt|;
if|if
condition|(
name|pfset
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
return|return
call|(
modifier|*
name|pfset
call|)
argument_list|(
name|qPort
argument_list|,
name|tset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Run a chat program on a port.  */
end_comment

begin_function
name|boolean
name|fport_run_chat
parameter_list|(
name|zprog
parameter_list|)
specifier|const
name|char
modifier|*
name|zprog
decl_stmt|;
block|{
return|return
operator|(
operator|*
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qPort
operator|->
name|ttype
index|]
operator|.
name|pfchat
operator|)
operator|(
name|qPort
operator|,
name|zprog
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the baud rate of a port.  */
end_comment

begin_function
name|long
name|iport_baud
parameter_list|()
block|{
return|return
operator|(
operator|*
name|asPortcmds
index|[
operator|(
name|int
operator|)
name|qPort
operator|->
name|ttype
index|]
operator|.
name|pibaud
operator|)
operator|(
name|qPort
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Modem dialing routines.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fpdo_dial
name|P
argument_list|(
operator|(
expr|struct
name|sdialer
operator|*
name|qdial
operator|,
specifier|const
name|char
operator|*
name|zphone
operator|,
name|boolean
name|ftranslate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|boolean
name|fmodem_dial
parameter_list|(
name|qport
parameter_list|,
name|qsys
parameter_list|,
name|pcproto_params
parameter_list|,
name|pqproto_params
parameter_list|,
name|pireliable
parameter_list|)
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
name|int
modifier|*
name|pcproto_params
decl_stmt|;
name|struct
name|sproto_param
modifier|*
modifier|*
name|pqproto_params
decl_stmt|;
name|int
modifier|*
name|pireliable
decl_stmt|;
block|{
if|if
condition|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zcopy
decl_stmt|,
modifier|*
name|zdialer
decl_stmt|;
name|boolean
name|ffirst
decl_stmt|;
comment|/* The zdialer string is a sequence of dialer/token pairs.  The 	 dialer portion names a dialer to use.  The token portion is 	 what \D and \T in the chat script expand to.  If there is no 	 token for the last dialer, the phone number for the system is 	 used.  */
name|ffirst
operator|=
name|TRUE
expr_stmt|;
operator|*
name|pcproto_params
operator|=
literal|0
expr_stmt|;
operator|*
name|pqproto_params
operator|=
name|NULL
expr_stmt|;
operator|*
name|pireliable
operator|=
literal|0
expr_stmt|;
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zcopy
argument_list|,
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
argument_list|)
expr_stmt|;
name|zdialer
operator|=
name|strtok
argument_list|(
name|zcopy
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
while|while
condition|(
name|zdialer
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sdialer
name|s
decl_stmt|;
name|char
modifier|*
name|ztoken
decl_stmt|;
name|boolean
name|ftranslate
decl_stmt|,
name|ftoken
decl_stmt|;
if|if
condition|(
operator|!
name|fread_dialer_info
argument_list|(
name|zdialer
argument_list|,
operator|&
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|ztoken
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|ftoken
operator|=
name|ztoken
operator|!=
name|NULL
expr_stmt|;
name|ftranslate
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ztoken
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|ztoken
argument_list|,
literal|"\\D"
argument_list|)
operator|==
literal|0
condition|)
name|ztoken
operator|=
name|qsys
operator|->
name|zphone
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ztoken
argument_list|,
literal|"\\T"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ztoken
operator|=
name|qsys
operator|->
name|zphone
expr_stmt|;
name|ftranslate
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Perhaps we should accumulate the protocol parameters.  */
if|if
condition|(
name|ffirst
condition|)
block|{
operator|*
name|pcproto_params
operator|=
name|s
operator|.
name|cproto_params
expr_stmt|;
operator|*
name|pqproto_params
operator|=
name|s
operator|.
name|qproto_params
expr_stmt|;
operator|*
name|pireliable
operator|=
name|s
operator|.
name|ireliable
expr_stmt|;
name|ffirst
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fpdo_dial
argument_list|(
operator|&
name|s
argument_list|,
name|ztoken
argument_list|,
name|ftranslate
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|ftoken
condition|)
name|zdialer
operator|=
name|NULL
expr_stmt|;
else|else
name|zdialer
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|qdialer
operator|!=
name|NULL
condition|)
block|{
operator|*
name|pcproto_params
operator|=
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|qdialer
operator|->
name|cproto_params
expr_stmt|;
operator|*
name|pqproto_params
operator|=
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|qdialer
operator|->
name|qproto_params
expr_stmt|;
operator|*
name|pireliable
operator|=
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|qdialer
operator|->
name|ireliable
expr_stmt|;
return|return
name|fpdo_dial
argument_list|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|qdialer
argument_list|,
name|qsys
operator|->
name|zphone
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"No dialer information"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Actually use a dialer.  We set up the modem (which may include    opening the dialer device), run the chat script, and finish dealing    with the modem.  */
end_comment

begin_function
specifier|static
name|boolean
name|fpdo_dial
parameter_list|(
name|qdial
parameter_list|,
name|zphone
parameter_list|,
name|ftranslate
parameter_list|)
name|struct
name|sdialer
modifier|*
name|qdial
decl_stmt|;
specifier|const
name|char
modifier|*
name|zphone
decl_stmt|;
name|boolean
name|ftranslate
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fsysdep_modem_begin_dial
argument_list|(
name|qPort
argument_list|,
name|qdial
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|fchat
argument_list|(
operator|&
name|qdial
operator|->
name|schat
argument_list|,
operator|(
specifier|const
expr|struct
name|ssysteminfo
operator|*
operator|)
name|NULL
argument_list|,
name|qdial
argument_list|,
name|zphone
argument_list|,
name|ftranslate
argument_list|,
name|qPort
operator|->
name|zname
argument_list|,
name|iport_baud
argument_list|()
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|fsysdep_modem_end_dial
argument_list|(
name|qPort
argument_list|,
name|qdial
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Permit no carrier from a port.  */
end_comment

begin_function
name|boolean
name|fport_no_carrier
parameter_list|()
block|{
return|return
name|fsysdep_modem_no_carrier
argument_list|(
name|qPort
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Require carrier from a port.  */
end_comment

begin_function
name|boolean
name|fport_need_carrier
parameter_list|()
block|{
return|return
name|fsysdep_modem_need_carrier
argument_list|(
name|qPort
argument_list|)
return|;
block|}
end_function

end_unit

