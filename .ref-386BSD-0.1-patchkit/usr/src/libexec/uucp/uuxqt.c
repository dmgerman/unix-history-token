begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* uuxqt.c    Run uux commands.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: uuxqt.c,v $    Revision 1.43  1992/03/17  04:42:41  ian    Correct bug in previous patch     Revision 1.42  1992/03/17  03:15:40  ian    Pass command to fsysdep_execute as first element of argument array     Revision 1.41  1992/03/17  01:07:15  ian    Miscellaneous cleanup     Revision 1.40  1992/03/16  19:44:45  ian    Cast result of alloca     Revision 1.39  1992/03/15  04:51:17  ian    Keep an array of signals we've received rather than a single variable     Revision 1.38  1992/03/15  01:54:46  ian    All execs are now done in isspawn, all waits are done in iswait     Revision 1.37  1992/03/12  19:54:43  ian    Debugging based on types rather than number     Revision 1.36  1992/03/11  22:34:25  ian    Chip Salzenberg: support Internet mail addresses in uuxqt replies     Revision 1.35  1992/03/11  22:06:37  ian    Marty Shannon: added max-uuxqts command     Revision 1.34  1992/03/11  17:04:53  ian    Jon Zeeff: retry execution later if temporary failure     Revision 1.33  1992/03/11  02:09:19  ian    Correct bug in previous change     Revision 1.32  1992/03/04  02:32:26  ian    Handle executions on local system     Revision 1.31  1992/02/29  04:07:08  ian    Added -j option to uucp and uux     Revision 1.30  1992/02/29  01:06:59  ian    Chip Salzenberg: recheck file permissions before sending     Revision 1.29  1992/02/27  05:40:54  ian    T. William Wells: detach from controlling terminal, handle signals safely     Revision 1.28  1992/02/24  04:58:47  ian    Only permit files to be received into directories that are world-writeable     Revision 1.27  1992/02/23  19:50:50  ian    Handle READ and WRITE in Permissions correctly     Revision 1.26  1992/02/23  03:26:51  ian    Overhaul to use automatic configure shell script     Revision 1.25  1992/02/18  19:03:02  ian    Pass fdaemon argument correctly to usysdep_initialize     Revision 1.24  1992/02/18  04:53:26  ian    T. William Wells: make sure sh execution uses absolute path     Revision 1.23  1992/02/14  21:32:50  ian    Niels Baggesen: under HAVE_BNU_LOGGING, don't lost system name when dieing     Revision 1.22  1992/02/08  22:33:32  ian    Only get the current working directory if it's going to be needed     Revision 1.21  1992/02/08  20:33:57  ian    Handle all possible signals raised by abort     Revision 1.20  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.19  1992/01/16  17:48:41  ian    Niels Baggesen: was checking strcmp return incorrectly     Revision 1.18  1992/01/15  07:06:29  ian    Set configuration directory in Makefile rather than sysdep.h     Revision 1.17  1992/01/05  03:09:17  ian    Changed abProgram and abVersion to non const to avoid compiler bug     Revision 1.16  1992/01/04  21:43:24  ian    Chip Salzenberg: added ALLOW_FILENAME_ARGUMENTS to permit them     Revision 1.15  1992/01/04  04:12:54  ian    David J. Fiander: make sure execution arguments are not bad file names     Revision 1.14  1991/12/29  04:22:41  ian    The mailing address was not getting initialized     Revision 1.13  1991/12/29  04:04:18  ian    Added a bunch of extern definitions     Revision 1.12  1991/12/20  00:17:38  ian    Don't process execute files for unknown systems     Revision 1.11  1991/12/19  03:52:07  ian    David Nugent: rescan the list of execute files until nothing can be done     Revision 1.10  1991/12/18  03:54:14  ian    Made error messages to terminal appear more normal     Revision 1.9  1991/12/17  04:55:01  ian    David Nugent: ignore SIGHUP in uucico and uuxqt     Revision 1.8  1991/12/09  18:49:06  ian    Richard Todd: the requestor address is relative to the requesting system     Revision 1.7  1991/12/06  23:42:18  ian    Don't acknowledge success by default     Revision 1.6  1991/12/01  01:28:44  ian    Mitch Mitchell: fixed comment listing supported commands     Revision 1.5  1991/11/21  22:17:06  ian    Add version string, print version when printing usage     Revision 1.4  1991/11/07  20:52:33  ian    Chip Salzenberg: pass command as single argument to /bin/sh     Revision 1.3  1991/09/19  16:15:58  ian    Chip Salzenberg: configuration option for permitting execution via sh     Revision 1.2  1991/09/19  02:30:37  ian    From Chip Salzenberg: check whether signal is ignored differently     Revision 1.1  1991/09/10  19:40:31  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|uuxqt_rcsid
index|[]
init|=
literal|"$Id: uuxqt.c,v 1.43 1992/03/17 04:42:41 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_comment
comment|/* External functions.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|fclose
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* The program name.  */
end_comment

begin_decl_stmt
name|char
name|abProgram
index|[]
init|=
literal|"uuxqt"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static variables used to unlock things if we get a fatal error.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iQunlock_seq
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zQunlock_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zQunlock_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|fQunlock_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|uqusage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uqabort
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uqdo_xqt_file
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfile
operator|,
specifier|const
expr|struct
name|ssysteminfo
operator|*
name|qsys
operator|,
specifier|const
name|char
operator|*
name|zcmd
operator|,
name|boolean
operator|*
name|pfprocessed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uqcleanup
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|zfile
operator|,
name|int
name|iflags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Long getopt options.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|asQlongopts
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|option
modifier|*
name|_getopt_long_options
init|=
name|asQlongopts
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|iopt
decl_stmt|;
comment|/* The type of command to execute (NULL for any type).  */
specifier|const
name|char
modifier|*
name|zcmd
init|=
name|NULL
decl_stmt|;
comment|/* The configuration file name.  */
specifier|const
name|char
modifier|*
name|zconfig
init|=
name|NULL
decl_stmt|;
comment|/* The system to execute commands for.  */
specifier|const
name|char
modifier|*
name|zdosys
init|=
name|NULL
decl_stmt|;
name|boolean
name|fany
decl_stmt|;
specifier|const
name|char
modifier|*
name|z
decl_stmt|;
specifier|const
name|char
modifier|*
name|zgetsys
decl_stmt|;
name|boolean
name|ferr
decl_stmt|;
name|struct
name|ssysteminfo
name|sreadsys
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qreadsys
decl_stmt|;
while|while
condition|(
operator|(
name|iopt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:I:s:x:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|iopt
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* Set the type of command to execute.  */
name|zcmd
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Set the configuration file name.  */
name|zconfig
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|zdosys
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|#
directive|if
name|DEBUG
operator|>
literal|1
comment|/* Set the debugging level.  */
name|iDebug
operator||=
name|idebug_parse
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|0
case|:
comment|/* Long option found and flag set.  */
break|break;
default|default:
name|uqusage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
name|uqusage
argument_list|()
expr_stmt|;
name|uread_config
argument_list|(
name|zconfig
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGINT
name|usysdep_signal
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|usysdep_signal
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|usysdep_signal
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|usysdep_signal
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|usysdep_signal
argument_list|(
name|SIGPIPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usysdep_initialize
argument_list|(
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ulog_to_file
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|ulog_fatal_fn
argument_list|(
name|uqabort
argument_list|)
expr_stmt|;
comment|/* Limit the number of uuxqt processes, and make sure we're the only      uuxqt daemon running for this command.  */
name|iQunlock_seq
operator|=
name|isysdep_lock_uuxqt
argument_list|(
name|zcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|iQunlock_seq
operator|<
literal|0
condition|)
block|{
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|zQunlock_cmd
operator|=
name|zcmd
expr_stmt|;
comment|/* Keep scanning the execute files until we don't process any of      them.  */
do|do
block|{
name|fany
operator|=
name|FALSE
expr_stmt|;
comment|/* Look for each execute file, and run it.  */
if|if
condition|(
operator|!
name|fsysdep_get_xqt_init
argument_list|()
condition|)
block|{
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|qreadsys
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|z
operator|=
name|zsysdep_get_xqt
argument_list|(
operator|&
name|zgetsys
argument_list|,
operator|&
name|ferr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zcopy
decl_stmt|;
name|boolean
name|fprocessed
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qusesys
decl_stmt|;
if|#
directive|if
operator|!
name|HAVE_ALLOCA
comment|/* Clear out any accumulated alloca buffers.  */
operator|(
name|void
operator|)
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* It would be more efficient to pass zdosys down to the 	     routines which retrieve execute files.  */
if|if
condition|(
name|zdosys
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zdosys
argument_list|,
name|zgetsys
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|zgetsys
argument_list|,
name|zLocalname
argument_list|)
operator|==
literal|0
condition|)
name|qusesys
operator|=
operator|&
name|sLocalsys
expr_stmt|;
else|else
block|{
if|if
condition|(
name|qreadsys
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|qreadsys
operator|->
name|zname
argument_list|,
name|zgetsys
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fread_system_info
argument_list|(
name|zgetsys
argument_list|,
operator|&
name|sreadsys
argument_list|)
condition|)
name|qreadsys
operator|=
operator|&
name|sreadsys
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|fUnknown_ok
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: Execute file for unknown system %s"
argument_list|,
name|z
argument_list|,
name|zgetsys
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|z
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|qreadsys
operator|=
operator|&
name|sUnknown
expr_stmt|;
name|sUnknown
operator|.
name|zname
operator|=
name|xstrdup
argument_list|(
name|zgetsys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fsysdep_make_spool_dir
argument_list|(
name|qreadsys
argument_list|)
condition|)
continue|continue;
block|}
name|qusesys
operator|=
name|qreadsys
expr_stmt|;
block|}
comment|/* If we've received a signal, get out of the loop.  */
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
break|break;
name|zcopy
operator|=
name|xstrdup
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|ulog_system
argument_list|(
name|qusesys
operator|->
name|zname
argument_list|)
expr_stmt|;
name|uqdo_xqt_file
argument_list|(
name|zcopy
argument_list|,
name|qusesys
argument_list|,
name|zcmd
argument_list|,
operator|&
name|fprocessed
argument_list|)
expr_stmt|;
name|ulog_system
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprocessed
condition|)
name|fany
operator|=
name|TRUE
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zcopy
argument_list|)
expr_stmt|;
block|}
name|usysdep_get_xqt_free
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|fany
operator|&&
operator|!
name|FGOT_SIGNAL
argument_list|()
condition|)
do|;
operator|(
name|void
operator|)
name|fsysdep_unlock_uuxqt
argument_list|(
name|iQunlock_seq
argument_list|,
name|zcmd
argument_list|)
expr_stmt|;
name|iQunlock_seq
operator|=
operator|-
literal|1
expr_stmt|;
name|ulog_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|FGOT_SIGNAL
argument_list|()
condition|)
name|ferr
operator|=
name|TRUE
expr_stmt|;
name|usysdep_exit
argument_list|(
operator|!
name|ferr
argument_list|)
expr_stmt|;
comment|/* Avoid errors about not returning a value.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uqusage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Taylor UUCP version %s, copyright (C) 1991, 1992 Ian Lance Taylor\n"
argument_list|,
name|abVersion
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: uuxqt [-c cmd] [-I file] [-s system] [-x debug]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -c cmd: Set type of command to execute\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -s system: Execute commands only for named system\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -x debug: Set debugging level (0 for none, 9 is max)\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_TAYLOR_CONFIG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -I file: Set configuration file to use (default %s%s)\n"
argument_list|,
name|NEWCONFIGLIB
argument_list|,
name|CONFIGFILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TAYLOR_CONFIG */
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the abort function called when we get a fatal error.  */
end_comment

begin_function
specifier|static
name|void
name|uqabort
parameter_list|()
block|{
if|#
directive|if
operator|!
name|HAVE_BNU_LOGGING
comment|/* When using BNU logging, it's a pain to have no system name.  */
name|ulog_system
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ulog_user
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fQunlock_directory
condition|)
operator|(
name|void
operator|)
name|fsysdep_unlock_uuxqt_dir
argument_list|()
expr_stmt|;
if|if
condition|(
name|zQunlock_file
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fsysdep_unlock_uuxqt_file
argument_list|(
name|zQunlock_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|iQunlock_seq
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|fsysdep_unlock_uuxqt
argument_list|(
name|iQunlock_seq
argument_list|,
name|zQunlock_cmd
argument_list|)
expr_stmt|;
name|ulog_close
argument_list|()
expr_stmt|;
name|usysdep_exit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* An execute file is a series of lines.  The first character of each    line is a command.  The following commands are defined:     C command-line    I standard-input    O standard-output [ system ]    F required-file filename-to-use    R requestor-address    U user system    Z (acknowledge if command failed; default)    N (no acknowledgement on failure)    n (acknowledge if command succeeded)    B (return command input on error)    e (process with sh)    E (process with exec)    M status-file    # comment     Unrecognized commands are ignored.  We actually do not recognize    the Z command, since it requests default behaviour.  We always send    mail on failure, unless the N command appears.  We never send mail    on success, unless the n command appears.     This code does not currently support the B or M commands.  */
end_comment

begin_comment
comment|/* Command arguments.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|azQargs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command as a complete string.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zQcmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Standard input file name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zQinput
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Standard output file name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zQoutfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Standard output system.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zQoutsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of required files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cQfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of required files.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|azQfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names required files should be renamed to (NULL if original is OK).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|azQfiles_to
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Requestor address (this is where mail should be sent).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zQrequestor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zQuser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* System name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zQsystem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is set by the N flag, meaning that no acknowledgement should    be mailed on failure.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fQno_ack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is set by the n flag, meaning that acknowledgement should be    mailed if the command succeeded.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fQsuccess_ack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is set by the B flag, meaning that command input should be    mailed to the requestor if an error occurred.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fQsend_input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is set by the E flag, meaning that exec should be used to    execute the command.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fQuse_exec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The status should be copied to this file on the requesting host.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zQstatus_file
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|ALLOW_SH_EXECUTION
end_if

begin_comment
comment|/* This is set by the e flag, meaning that sh should be used to    execute the command.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|fQuse_sh
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALLOW_SH_EXECUTION */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|tcmdtabret
name|tqcmd
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|tcmdtabret
name|tqout
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|tcmdtabret
name|tqfile
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|tcmdtabret
name|tquser
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|tcmdtabret
name|tqset
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scmdtab
name|asQcmds
index|[]
init|=
block|{
block|{
literal|"C"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|tqcmd
block|}
block|,
block|{
literal|"I"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zQinput
block|,
name|NULL
block|}
block|,
block|{
literal|"O"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|tqout
block|}
block|,
block|{
literal|"F"
block|,
name|CMDTABTYPE_FN
operator||
literal|0
block|,
name|NULL
block|,
name|tqfile
block|}
block|,
block|{
literal|"R"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zQrequestor
block|,
name|NULL
block|}
block|,
block|{
literal|"U"
block|,
name|CMDTABTYPE_FN
operator||
literal|3
block|,
name|NULL
block|,
name|tquser
block|}
block|,
block|{
literal|"N"
block|,
name|CMDTABTYPE_FN
operator||
literal|1
block|,
operator|(
name|pointer
operator|)
operator|&
name|fQno_ack
block|,
name|tqset
block|}
block|,
block|{
literal|"n"
block|,
name|CMDTABTYPE_FN
operator||
literal|1
block|,
operator|(
name|pointer
operator|)
operator|&
name|fQsuccess_ack
block|,
name|tqset
block|}
block|,
block|{
literal|"B"
block|,
name|CMDTABTYPE_FN
operator||
literal|1
block|,
operator|(
name|pointer
operator|)
operator|&
name|fQsend_input
block|,
name|tqset
block|}
block|,
if|#
directive|if
name|ALLOW_SH_EXECUTION
block|{
literal|"e"
block|,
name|CMDTABTYPE_FN
operator||
literal|1
block|,
operator|(
name|pointer
operator|)
operator|&
name|fQuse_sh
block|,
name|tqset
block|}
block|,
endif|#
directive|endif
block|{
literal|"E"
block|,
name|CMDTABTYPE_FN
operator||
literal|1
block|,
operator|(
name|pointer
operator|)
operator|&
name|fQuse_exec
block|,
name|tqset
block|}
block|,
block|{
literal|"M"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|zQstatus_file
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the C command: store off the arguments.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tqcmd
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|clen
decl_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
return|return
name|CMDTABRET_FREE
return|;
name|azQargs
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|clen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|azQargs
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|clen
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|azQargs
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|zQcmd
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|clen
argument_list|)
expr_stmt|;
name|zQcmd
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|zQcmd
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zQcmd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|zQcmd
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* Handle the O command, which may have one or two arguments.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tqout
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
operator|&&
name|argc
operator|!=
literal|3
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Wrong number of arguments"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
name|zQoutfile
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
name|zQoutsys
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
return|return
name|CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* Handle the F command, which may have one or two arguments.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tqfile
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
operator|&&
name|argc
operator|!=
literal|3
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: %s: Wrong number of arguments"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
comment|/* If this file is not in the spool directory, just ignore it.  */
if|if
condition|(
operator|!
name|fspool_file
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|CMDTABRET_FREE
return|;
operator|++
name|cQfiles
expr_stmt|;
name|azQfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|azQfiles
argument_list|,
name|cQfiles
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|azQfiles_to
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|azQfiles_to
argument_list|,
name|cQfiles
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|azQfiles
index|[
name|cQfiles
operator|-
literal|1
index|]
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
name|azQfiles_to
index|[
name|cQfiles
operator|-
literal|1
index|]
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|azQfiles_to
index|[
name|cQfiles
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_comment
comment|/* Handle the U command, which takes two arguments.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tquser
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|zQuser
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|zQsystem
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
return|return
name|CMDTABRET_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* Handle various commands which just set boolean variables.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tqset
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
name|boolean
modifier|*
name|pf
init|=
operator|(
name|boolean
operator|*
operator|)
name|pvar
decl_stmt|;
operator|*
name|pf
operator|=
name|TRUE
expr_stmt|;
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The execution processing does a lot of things that have to be    cleaned up.  Rather than try to add the appropriate statements    to each return point, we keep a set of flags indicating what    has to be cleaned up.  The actual clean up is done by the    function uqcleanup.  */
end_comment

begin_define
define|#
directive|define
name|REMOVE_FILE
value|(01)
end_define

begin_define
define|#
directive|define
name|REMOVE_NEEDED
value|(02)
end_define

begin_define
define|#
directive|define
name|FREE_QINPUT
value|(04)
end_define

begin_comment
comment|/* Process an execute file.  The zfile argument is the name of the    execute file.  The qsys argument describes the system it came from.    The zcmd argument is the name of the command we are executing (from    the -c option) or NULL if any command is OK.  This sets    *pfprocessed to TRUE if the file is ready to be executed.  */
end_comment

begin_function
specifier|static
name|void
name|uqdo_xqt_file
parameter_list|(
name|zfile
parameter_list|,
name|qsys
parameter_list|,
name|zcmd
parameter_list|,
name|pfprocessed
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qsys
decl_stmt|;
specifier|const
name|char
modifier|*
name|zcmd
decl_stmt|;
name|boolean
modifier|*
name|pfprocessed
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|zcmds
decl_stmt|;
specifier|const
name|char
modifier|*
name|zabsolute
decl_stmt|;
name|boolean
name|ferr
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|iclean
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmail
decl_stmt|;
specifier|const
name|char
modifier|*
name|zoutput
decl_stmt|;
name|char
name|abtemp
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
name|char
name|abdata
index|[
name|CFILE_NAME_LEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerror
decl_stmt|;
name|struct
name|ssysteminfo
name|soutsys
decl_stmt|;
specifier|const
name|struct
name|ssysteminfo
modifier|*
name|qoutsys
decl_stmt|;
name|boolean
name|fshell
decl_stmt|;
name|char
modifier|*
name|zfullcmd
decl_stmt|;
name|boolean
name|ftemp
decl_stmt|;
operator|*
name|pfprocessed
operator|=
name|FALSE
expr_stmt|;
comment|/* If we're not permitted to execute anything for this system,      we can just clobber the file without even looking at it.  */
name|zcmds
operator|=
name|qsys
operator|->
name|zcmds
expr_stmt|;
if|if
condition|(
operator|*
name|zcmds
operator|==
literal|'\0'
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: No commands permitted for system %s"
argument_list|,
name|zfile
argument_list|,
name|qsys
operator|->
name|zname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we are only willing to execute a particular command, and it      is not one of those accepted by this system, quit now.  */
if|if
condition|(
name|zcmd
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zcmds
argument_list|,
literal|"ALL"
argument_list|)
operator|!=
literal|0
operator|&&
name|strstr
argument_list|(
name|zcmds
argument_list|,
name|zcmd
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|e
operator|=
name|fopen
argument_list|(
name|zfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return;
name|azQargs
operator|=
name|NULL
expr_stmt|;
name|zQcmd
operator|=
name|NULL
expr_stmt|;
name|zQinput
operator|=
name|NULL
expr_stmt|;
name|zQoutfile
operator|=
name|NULL
expr_stmt|;
name|zQoutsys
operator|=
name|NULL
expr_stmt|;
name|cQfiles
operator|=
literal|0
expr_stmt|;
name|azQfiles
operator|=
name|NULL
expr_stmt|;
name|azQfiles_to
operator|=
name|NULL
expr_stmt|;
name|zQrequestor
operator|=
name|NULL
expr_stmt|;
name|zQuser
operator|=
name|NULL
expr_stmt|;
name|zQsystem
operator|=
name|NULL
expr_stmt|;
name|fQno_ack
operator|=
name|FALSE
expr_stmt|;
name|fQsuccess_ack
operator|=
name|FALSE
expr_stmt|;
name|fQsend_input
operator|=
name|FALSE
expr_stmt|;
name|fQuse_exec
operator|=
name|FALSE
expr_stmt|;
name|zQstatus_file
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|ALLOW_SH_EXECUTION
name|fQuse_sh
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|uprocesscmds
argument_list|(
name|e
argument_list|,
operator|(
expr|struct
name|smulti_file
operator|*
operator|)
name|NULL
argument_list|,
name|asQcmds
argument_list|,
name|zfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|iclean
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|azQargs
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: No command given"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
operator||
name|REMOVE_FILE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zcmd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zcmd
argument_list|,
name|azQargs
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* If there is a lock file for this particular command already, 	 it means that some other uuxqt is supposed to handle it.  */
if|if
condition|(
name|fsysdep_uuxqt_locked
argument_list|(
name|azQargs
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Lock this particular file.  */
if|if
condition|(
operator|!
name|fsysdep_lock_uuxqt_file
argument_list|(
name|zfile
argument_list|)
condition|)
block|{
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
return|return;
block|}
name|zQunlock_file
operator|=
name|zfile
expr_stmt|;
if|if
condition|(
name|zQuser
operator|!=
name|NULL
condition|)
name|ulog_user
argument_list|(
name|zQuser
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zQrequestor
operator|!=
name|NULL
condition|)
name|ulog_user
argument_list|(
name|zQrequestor
argument_list|)
expr_stmt|;
else|else
name|ulog_user
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
comment|/* Make sure that all the required files exist, and get their      full names in the spool directory.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cQfiles
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|zreal
decl_stmt|;
name|zreal
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qsys
argument_list|,
name|azQfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zreal
operator|==
name|NULL
condition|)
block|{
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|fsysdep_file_exists
argument_list|(
name|zreal
argument_list|)
condition|)
block|{
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
return|return;
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|azQfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|azQfiles
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|zreal
argument_list|)
expr_stmt|;
block|}
comment|/* See if we need the execute directory, and lock it if we do.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cQfiles
condition|;
name|i
operator|++
control|)
block|{
name|int
name|itries
decl_stmt|;
if|if
condition|(
name|azQfiles_to
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|itries
operator|=
literal|0
init|;
name|itries
operator|<
literal|5
condition|;
name|itries
operator|++
control|)
block|{
if|if
condition|(
name|fsysdep_lock_uuxqt_dir
argument_list|()
condition|)
break|break;
name|usysdep_sleep
argument_list|(
literal|30
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itries
operator|>=
literal|5
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Could not lock execute directory"
argument_list|)
expr_stmt|;
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
return|return;
block|}
name|fQunlock_directory
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|iclean
operator||=
name|REMOVE_FILE
operator||
name|REMOVE_NEEDED
expr_stmt|;
operator|*
name|pfprocessed
operator|=
name|TRUE
expr_stmt|;
comment|/* Get the address to mail results to.  Prepend the system from      which the execute file originated, since mail addresses are      relative to it.  */
name|zmail
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zQrequestor
operator|!=
name|NULL
condition|)
name|zmail
operator|=
name|zQrequestor
expr_stmt|;
elseif|else
if|if
condition|(
name|zQuser
operator|!=
name|NULL
condition|)
name|zmail
operator|=
name|zQuser
expr_stmt|;
if|if
condition|(
name|zmail
operator|!=
name|NULL
operator|&&
name|zQsystem
operator|!=
name|NULL
if|#
directive|if
name|HAVE_INTERNET_MAIL
operator|&&
name|strchr
argument_list|(
name|zmail
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
endif|#
directive|endif
operator|&&
name|strcmp
argument_list|(
name|zQsystem
argument_list|,
name|zLocalname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|zset
decl_stmt|;
name|zset
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zQsystem
argument_list|)
operator|+
name|strlen
argument_list|(
name|zmail
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|"%s!%s"
argument_list|,
name|zQsystem
argument_list|,
name|zmail
argument_list|)
expr_stmt|;
name|zmail
operator|=
name|zset
expr_stmt|;
block|}
comment|/* Get the pathname to execute.  */
name|zabsolute
operator|=
name|zsysdep_find_command
argument_list|(
name|azQargs
index|[
literal|0
index|]
argument_list|,
name|zcmds
argument_list|,
name|qsys
operator|->
name|zpath
argument_list|,
operator|&
name|ferr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zabsolute
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ferr
condition|)
block|{
comment|/* If we get an error, try again later.  */
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
operator|&
operator|~
operator|(
name|REMOVE_FILE
operator||
name|REMOVE_NEEDED
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pfprocessed
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
comment|/* Not permitted.  Send mail to requestor.  */
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not permitted to execute %s"
argument_list|,
name|azQargs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zmail
operator|!=
name|NULL
operator|&&
operator|!
name|fQno_ack
condition|)
block|{
specifier|const
name|char
modifier|*
name|az
index|[
literal|20
index|]
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"Your execution request failed because you are not"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|" permitted to execute\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|azQargs
index|[
literal|0
index|]
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\non this system.\n"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"Execution requested was:\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zQcmd
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\n"
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_mail
argument_list|(
name|zmail
argument_list|,
literal|"Execution failed"
argument_list|,
name|i
argument_list|,
name|az
argument_list|)
expr_stmt|;
block|}
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
name|char
modifier|*
name|zcopy
decl_stmt|;
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zabsolute
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zcopy
argument_list|,
name|zabsolute
argument_list|)
expr_stmt|;
name|zabsolute
operator|=
name|zcopy
expr_stmt|;
block|}
name|azQargs
index|[
literal|0
index|]
operator|=
name|zabsolute
expr_stmt|;
if|#
directive|if
operator|!
name|ALLOW_FILENAME_ARGUMENTS
comment|/* Check all the arguments to make sure they don't try to specify      files they are not permitted to access.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|azQargs
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|fsysdep_xqt_check_file
argument_list|(
name|qsys
argument_list|,
name|azQargs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|zmail
operator|!=
name|NULL
operator|&&
operator|!
name|fQno_ack
condition|)
block|{
specifier|const
name|char
modifier|*
name|az
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|zfailed
decl_stmt|;
name|zfailed
operator|=
name|azQargs
index|[
name|i
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"Your execution request failed because you are not"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|" permitted to refer to file\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zfailed
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\non this system.\n"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"Execution requested was:\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zQcmd
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\n"
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_mail
argument_list|(
name|zmail
argument_list|,
literal|"Execution failed"
argument_list|,
name|i
argument_list|,
name|az
argument_list|)
expr_stmt|;
block|}
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* ! ALLOW_FILENAME_ARGUMENTS */
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Executing %s (%s)"
argument_list|,
name|zfile
argument_list|,
name|zQcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|zQinput
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fspool
decl_stmt|;
name|fspool
operator|=
name|fspool_file
argument_list|(
name|zQinput
argument_list|)
expr_stmt|;
if|if
condition|(
name|fspool
condition|)
name|zQinput
operator|=
name|zsysdep_spool_file_name
argument_list|(
name|qsys
argument_list|,
name|zQinput
argument_list|)
expr_stmt|;
else|else
name|zQinput
operator|=
name|zsysdep_real_file_name
argument_list|(
name|qsys
argument_list|,
name|zQinput
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zQinput
operator|==
name|NULL
condition|)
block|{
comment|/* If we get an error, try again later.  */
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
operator|&
operator|~
operator|(
name|REMOVE_FILE
operator||
name|REMOVE_NEEDED
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pfprocessed
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|zQinput
operator|=
name|xstrdup
argument_list|(
name|zQinput
argument_list|)
expr_stmt|;
name|iclean
operator||=
name|FREE_QINPUT
expr_stmt|;
if|if
condition|(
operator|!
name|fspool
operator|&&
operator|!
name|fin_directory_list
argument_list|(
name|qsys
argument_list|,
name|zQinput
argument_list|,
name|qsys
operator|->
name|zremote_send
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not permitted to read %s"
argument_list|,
name|zQinput
argument_list|)
expr_stmt|;
if|if
condition|(
name|zmail
operator|!=
name|NULL
operator|&&
operator|!
name|fQno_ack
condition|)
block|{
specifier|const
name|char
modifier|*
name|az
index|[
literal|20
index|]
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"Your execution request failed because you are"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|" not permitted to read\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zQinput
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\non this system.\n"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"Execution requested was:\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zQcmd
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\n"
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_mail
argument_list|(
name|zmail
argument_list|,
literal|"Execution failed"
argument_list|,
name|i
argument_list|,
name|az
argument_list|)
expr_stmt|;
block|}
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|zQoutfile
operator|==
name|NULL
condition|)
block|{
name|zoutput
operator|=
name|NULL
expr_stmt|;
name|qoutsys
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zQoutsys
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zQoutsys
argument_list|,
name|zLocalname
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|zdata
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|;
comment|/* The output file is destined for some other system, so we must 	 use a temporary file to catch standard output.  */
if|if
condition|(
name|strcmp
argument_list|(
name|zQoutsys
argument_list|,
name|qsys
operator|->
name|zname
argument_list|)
operator|==
literal|0
condition|)
name|qoutsys
operator|=
name|qsys
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|fread_system_info
argument_list|(
name|zQoutsys
argument_list|,
operator|&
name|soutsys
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fUnknown_ok
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Can't send standard output to unknown system %s"
argument_list|,
name|zQoutsys
argument_list|)
expr_stmt|;
comment|/* We don't send mail to unknown systems, either. 		     Maybe we should.  */
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
return|return;
block|}
name|soutsys
operator|=
name|sUnknown
expr_stmt|;
name|soutsys
operator|.
name|zname
operator|=
name|zQoutsys
expr_stmt|;
block|}
name|qoutsys
operator|=
operator|&
name|soutsys
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_make_spool_dir
argument_list|(
name|qoutsys
argument_list|)
condition|)
block|{
comment|/* If we get an error, try again later.  */
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
operator|&
operator|~
operator|(
name|REMOVE_FILE
operator||
name|REMOVE_NEEDED
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pfprocessed
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
block|}
name|zdata
operator|=
name|zsysdep_data_file_name
argument_list|(
name|qoutsys
argument_list|,
name|BDEFAULT_UUX_GRADE
argument_list|,
name|abtemp
argument_list|,
name|abdata
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdata
operator|==
name|NULL
condition|)
block|{
comment|/* If we get an error, try again later.  */
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
operator|&
operator|~
operator|(
name|REMOVE_FILE
operator||
name|REMOVE_NEEDED
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pfprocessed
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zdata
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zcopy
argument_list|,
name|zdata
argument_list|)
expr_stmt|;
name|zoutput
operator|=
name|zcopy
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|fok
decl_stmt|;
name|char
modifier|*
name|zcopy
decl_stmt|;
name|qoutsys
operator|=
name|NULL
expr_stmt|;
comment|/* If we permitted the standard output to be redirected into 	 the spool directory, people could set up phony commands.  */
if|if
condition|(
name|fspool_file
argument_list|(
name|zQoutfile
argument_list|)
condition|)
name|fok
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|zQoutfile
operator|=
name|zsysdep_real_file_name
argument_list|(
operator|&
name|sLocalsys
argument_list|,
name|zQoutfile
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zQoutfile
operator|==
name|NULL
condition|)
block|{
comment|/* If we get an error, try again later.  */
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
operator|&
operator|~
operator|(
name|REMOVE_FILE
operator||
name|REMOVE_NEEDED
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pfprocessed
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
comment|/* Make sure it's OK to receive this file.  Note that this 	     means that a locally executed uux (which presumably 	     requires remote files) will only be able to create files 	     in standard directories.  If we don't it this way, users 	     could clobber files which uucp has access to; still, it 	     would be nice to allow them to direct the output to their 	     home directory.  */
name|fok
operator|=
name|fin_directory_list
argument_list|(
name|qsys
argument_list|,
name|zQoutfile
argument_list|,
name|qsys
operator|->
name|zremote_receive
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fok
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Not permitted to write to %s"
argument_list|,
name|zQoutfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|zmail
operator|!=
name|NULL
operator|&&
operator|!
name|fQno_ack
condition|)
block|{
specifier|const
name|char
modifier|*
name|az
index|[
literal|20
index|]
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"Your execution request failed because you are"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|" not permitted to write to\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zQoutfile
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\non this system.\n"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"Execution requested was:\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zQcmd
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\n"
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_mail
argument_list|(
name|zmail
argument_list|,
literal|"Execution failed"
argument_list|,
name|i
argument_list|,
name|az
argument_list|)
expr_stmt|;
block|}
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
return|return;
block|}
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zQoutfile
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zcopy
argument_list|,
name|zQoutfile
argument_list|)
expr_stmt|;
name|zQoutfile
operator|=
name|zcopy
expr_stmt|;
name|zoutput
operator|=
name|zcopy
expr_stmt|;
block|}
comment|/* Move the required files to the execution directory if necessary.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cQfiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|azQfiles_to
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
comment|/* Move the file to the execute directory.  */
name|zname
operator|=
name|zsysdep_in_dir
argument_list|(
name|XQTDIR
argument_list|,
name|azQfiles_to
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zname
operator|==
name|NULL
condition|)
block|{
comment|/* If we get an error, try again later.  */
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
operator|&
operator|~
operator|(
name|REMOVE_FILE
operator||
name|REMOVE_NEEDED
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pfprocessed
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|fsysdep_move_file
argument_list|(
name|azQfiles
index|[
name|i
index|]
argument_list|,
name|zname
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
comment|/* If we get an error, try again later.  This may not be 		 correct, depending on what kind of error we get.  */
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
operator|&
operator|~
operator|(
name|REMOVE_FILE
operator||
name|REMOVE_NEEDED
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pfprocessed
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
comment|/* If we just moved the standard input file, adjust the 	     file name.  */
if|if
condition|(
name|zQinput
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|azQfiles
index|[
name|i
index|]
argument_list|,
name|zQinput
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zQinput
argument_list|)
expr_stmt|;
name|zQinput
operator|=
name|xstrdup
argument_list|(
name|zname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|ALLOW_SH_EXECUTION
name|fshell
operator|=
name|fQuse_sh
expr_stmt|;
else|#
directive|else
name|fshell
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* Get a shell command which uses the full path of the command to      execute.  */
name|zfullcmd
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|zQcmd
argument_list|)
operator|+
name|strlen
argument_list|(
name|azQargs
index|[
literal|0
index|]
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|zfullcmd
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|azQargs
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|zfullcmd
argument_list|,
name|azQargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zfullcmd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|zfullcmd
index|[
name|strlen
argument_list|(
name|zfullcmd
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|fsysdep_execute
argument_list|(
name|qsys
argument_list|,
name|zQuser
operator|==
name|NULL
condition|?
operator|(
specifier|const
name|char
operator|*
operator|)
literal|"uucp"
else|:
name|zQuser
argument_list|,
name|azQargs
argument_list|,
name|zfullcmd
argument_list|,
name|zQinput
argument_list|,
name|zoutput
argument_list|,
name|fshell
argument_list|,
operator|&
name|zerror
argument_list|,
operator|&
name|ftemp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ftemp
condition|)
block|{
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Will retry later (%s)"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|zoutput
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zoutput
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerror
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zerror
argument_list|)
expr_stmt|;
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
operator|&
operator|~
operator|(
name|REMOVE_FILE
operator||
name|REMOVE_NEEDED
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pfprocessed
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|ulog
argument_list|(
name|LOG_NORMAL
argument_list|,
literal|"Execution failed (%s)"
argument_list|,
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|zmail
operator|!=
name|NULL
operator|&&
operator|!
name|fQno_ack
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
name|int
name|cgot
decl_stmt|;
name|FILE
modifier|*
name|eerr
decl_stmt|;
name|int
name|istart
decl_stmt|;
name|cgot
operator|=
literal|20
expr_stmt|;
name|pz
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cgot
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|pz
index|[
name|i
operator|++
index|]
operator|=
literal|"Execution request failed:\n\t"
expr_stmt|;
name|pz
index|[
name|i
operator|++
index|]
operator|=
name|zQcmd
expr_stmt|;
name|pz
index|[
name|i
operator|++
index|]
operator|=
literal|"\n"
expr_stmt|;
if|if
condition|(
name|zerror
operator|==
name|NULL
condition|)
name|eerr
operator|=
name|NULL
expr_stmt|;
else|else
name|eerr
operator|=
name|fopen
argument_list|(
name|zerror
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eerr
operator|==
name|NULL
condition|)
block|{
name|pz
index|[
name|i
operator|++
index|]
operator|=
literal|"There was no output on standard error\n"
expr_stmt|;
name|istart
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|zline
decl_stmt|;
name|pz
index|[
name|i
operator|++
index|]
operator|=
literal|"Standard error output was:\n"
expr_stmt|;
name|istart
operator|=
name|i
expr_stmt|;
while|while
condition|(
operator|(
name|zline
operator|=
name|zfgets
argument_list|(
name|eerr
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|cgot
condition|)
block|{
name|cgot
operator|+=
literal|20
expr_stmt|;
name|pz
operator|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
name|pz
argument_list|,
name|cgot
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|pz
index|[
name|i
operator|++
index|]
operator|=
name|zline
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eerr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fsysdep_mail
argument_list|(
name|zmail
argument_list|,
literal|"Execution failed"
argument_list|,
name|i
argument_list|,
name|pz
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|istart
operator|<
name|i
condition|;
name|istart
operator|++
control|)
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|pz
index|[
name|istart
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|pz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qoutsys
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zoutput
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zmail
operator|!=
name|NULL
operator|&&
name|fQsuccess_ack
condition|)
block|{
specifier|const
name|char
modifier|*
name|az
index|[
literal|20
index|]
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\nExecution request succeeded:\n\t"
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
name|zQcmd
expr_stmt|;
name|az
index|[
name|i
operator|++
index|]
operator|=
literal|"\n"
expr_stmt|;
operator|(
name|void
operator|)
name|fsysdep_mail
argument_list|(
name|zmail
argument_list|,
literal|"Execution succeded"
argument_list|,
name|i
argument_list|,
name|az
argument_list|)
expr_stmt|;
block|}
comment|/* Now we may have to uucp the output to some other machine.  */
if|if
condition|(
name|qoutsys
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scmd
name|s
decl_stmt|;
comment|/* Fill in the command structure.  */
name|s
operator|.
name|bcmd
operator|=
literal|'S'
expr_stmt|;
name|s
operator|.
name|pseq
operator|=
name|NULL
expr_stmt|;
name|s
operator|.
name|zfrom
operator|=
name|abtemp
expr_stmt|;
name|s
operator|.
name|zto
operator|=
name|zQoutfile
expr_stmt|;
if|if
condition|(
name|zQuser
operator|!=
name|NULL
condition|)
name|s
operator|.
name|zuser
operator|=
name|zQuser
expr_stmt|;
else|else
name|s
operator|.
name|zuser
operator|=
literal|"uucp"
expr_stmt|;
if|if
condition|(
name|zmail
operator|!=
name|NULL
operator|&&
name|fQsuccess_ack
condition|)
name|s
operator|.
name|zoptions
operator|=
literal|"Cn"
expr_stmt|;
else|else
name|s
operator|.
name|zoptions
operator|=
literal|"C"
expr_stmt|;
name|s
operator|.
name|ztemp
operator|=
name|abtemp
expr_stmt|;
name|s
operator|.
name|imode
operator|=
literal|0666
expr_stmt|;
if|if
condition|(
name|zmail
operator|!=
name|NULL
operator|&&
name|fQsuccess_ack
condition|)
name|s
operator|.
name|znotify
operator|=
name|zmail
expr_stmt|;
else|else
name|s
operator|.
name|znotify
operator|=
literal|""
expr_stmt|;
comment|/* The number of bytes will be filled in when the file is 	     actually sent.  */
name|s
operator|.
name|cbytes
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|zsysdep_spool_commands
argument_list|(
name|qoutsys
argument_list|,
name|BDEFAULT_UUX_GRADE
argument_list|,
literal|1
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zerror
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zerror
argument_list|)
expr_stmt|;
name|uqcleanup
argument_list|(
name|zfile
argument_list|,
name|iclean
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up the results of uqdo_xqt_file.  */
end_comment

begin_function
specifier|static
name|void
name|uqcleanup
parameter_list|(
name|zfile
parameter_list|,
name|iflags
parameter_list|)
specifier|const
name|char
modifier|*
name|zfile
decl_stmt|;
name|int
name|iflags
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|DEBUG_MESSAGE2
argument_list|(
name|DEBUG_SPOOLDIR
argument_list|,
literal|"uqcleanup: %s, %d"
argument_list|,
name|zfile
argument_list|,
name|iflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|zQunlock_file
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_unlock_uuxqt_file
argument_list|(
name|zQunlock_file
argument_list|)
expr_stmt|;
name|zQunlock_file
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|iflags
operator|&
name|REMOVE_FILE
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iflags
operator|&
name|REMOVE_NEEDED
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cQfiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|azQfiles
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|azQfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|iflags
operator|&
name|FREE_QINPUT
operator|)
operator|!=
literal|0
condition|)
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zQinput
argument_list|)
expr_stmt|;
if|if
condition|(
name|fQunlock_directory
condition|)
block|{
operator|(
name|void
operator|)
name|fsysdep_unlock_uuxqt_dir
argument_list|()
expr_stmt|;
name|fQunlock_directory
operator|=
name|FALSE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cQfiles
condition|;
name|i
operator|++
control|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|azQfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|azQfiles_to
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|azQargs
argument_list|)
expr_stmt|;
name|azQargs
operator|=
name|NULL
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zQcmd
argument_list|)
expr_stmt|;
name|zQcmd
operator|=
name|NULL
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|azQfiles
argument_list|)
expr_stmt|;
name|azQfiles
operator|=
name|NULL
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|azQfiles_to
argument_list|)
expr_stmt|;
name|azQfiles_to
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

