begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* bnu.c    Read BNU configuration files.     Copyright (C) 1991, 1992 Ian Lance Taylor     This file is part of the Taylor UUCP package.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author of the program may be contacted at ian@airs.com or    c/o AIRS, P.O. Box 520, Waltham, MA 02254.     $Log: bnu.c,v $    Revision 1.35  1992/04/06  19:49:49  ian    Erik Forsberg: support multiple character modem classes     Revision 1.34  1992/03/15  05:21:12  ian    Scott Ballantyne: accept "Any" as a device speed     Revision 1.33  1992/03/12  19:56:10  ian    Debugging based on types rather than number     Revision 1.32  1992/03/11  22:06:37  ian    Marty Shannon: added max-uuxqts command     Revision 1.31  1992/03/10  21:47:39  ian    Added protocol command for ports     Revision 1.30  1992/02/24  20:36:27  ian    Roberto Biancardi: skip spaces after strtok (NULL, "")     Revision 1.29  1992/02/24  04:58:47  ian    Only permit files to be received into directories that are world-writeable     Revision 1.28  1992/02/24  04:02:45  ian    Doug Evans: WRITE only applies to remote requests     Revision 1.27  1992/02/23  19:50:50  ian    Handle READ and WRITE in Permissions correctly     Revision 1.26  1992/02/14  16:45:09  ian    This time for sure     Revision 1.25  1992/02/14  16:43:07  ian    Make the last patch better     Revision 1.24  1992/02/14  16:39:31  ian    T. William Wells: must xstrdup before calling uadd_validate     Revision 1.23  1992/02/08  03:54:18  ian    Include<string.h> only in<uucp.h>, added 1992 copyright     Revision 1.22  1992/01/30  23:18:59  ian    Michael Nolan: stupid error in ubadd_perm     Revision 1.21  1992/01/15  07:06:29  ian    Set configuration directory in Makefile rather than sysdep.h     Revision 1.20  1991/12/28  03:49:23  ian    Added HAVE_MEMFNS and HAVE_BFNS; changed uses of memset to bzero     Revision 1.19  1991/12/17  23:14:08  ian    T. William Wells: allow dialer complete and abort to be chat scripts     Revision 1.18  1991/12/16  16:25:57  ian    Mike Bernson: ignore lines beginning with whitespace     Revision 1.17  1991/12/15  03:42:33  ian    Added tprocess_chat_cmd for all chat commands, and added CMDTABTYPE_PREFIX     Revision 1.16  1991/12/09  19:20:51  ian    Arne Ludwig: devices entry can be followed by list of protocols     Revision 1.15  1991/12/03  03:43:36  ian    Dave Buck: time strings with grades were not parsed correctly     Revision 1.14  1991/12/01  19:35:38  ian    David Nugent: read V2 and BNU files by default even with TAYLOR_CONFIG     Revision 1.13  1991/12/01  03:10:36  ian    Niels Baggesen: accept dialers with no substitutions     Revision 1.12  1991/12/01  03:04:20  ian    Niels Baggesen: don't free up zline in ubadd_perm; don't even pass it in     Revision 1.11  1991/12/01  02:44:12  ian    Niels Baggesen: didn't handle combinations of multiple MACHINE/LOGNAME     Revision 1.10  1991/12/01  02:31:36  ian    Made zread and zwrite fields of sperm structure const char *     Revision 1.9  1991/11/30  23:39:37  ian    Marty Shannon: allow comments in Sysfiles     Revision 1.8  1991/11/30  22:39:39  ian    Marty Shannon: don't initialize an auto array     Revision 1.7  1991/11/26  01:04:04  ian    Marty Shannon: initialize ireliable for BNU and V2 configuration files     Revision 1.6  1991/11/13  20:38:00  ian    Added TCP port type for connections over TCP     Revision 1.5  1991/11/11  23:47:24  ian    Added chat-program to run a program to do a chat script     Revision 1.4  1991/11/11  16:59:05  ian    Eliminate fread_port_info, allow NULL pflock arg to ffind_port     Revision 1.3  1991/11/07  18:26:13  ian    Chip Salzenberg: can't portably take address of casted value, obviously     Revision 1.2  1991/09/19  02:22:44  ian    Chip Salzenberg's patch to allow ";retrytime" at the end of a time string     Revision 1.1  1991/09/10  19:37:52  ian    Initial revision     */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_if
if|#
directive|if
name|HAVE_BNU_CONFIG
end_if

begin_if
if|#
directive|if
name|USE_RCS_ID
end_if

begin_decl_stmt
name|char
name|bnu_rcsid
index|[]
init|=
literal|"$Id: bnu.c,v 1.35 1992/04/06 19:49:49 ian Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Whether to use BNU configuration files.  */
end_comment

begin_decl_stmt
name|boolean
name|fBnu
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of space separated file names to interpret as Systems.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zBnu_systems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of space separated file names to interpret as Dialers.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zBnu_dialers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of space separated file names to interpret as Devices.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zBnu_devices
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ubadd_perm
name|P
argument_list|(
operator|(
name|int
name|csystems
operator|,
expr|struct
name|ssysteminfo
operator|*
name|passystems
operator|,
name|boolean
operator|*
operator|*
name|paffound
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ubadd_perm_alternate
name|P
argument_list|(
operator|(
expr|struct
name|ssysteminfo
operator|*
name|q
operator|,
name|boolean
name|fmachine
operator|,
name|boolean
name|flogname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Read Sysfiles to get the file names to use.  */
end_comment

begin_function
name|void
name|ubnu_read_sysfiles
parameter_list|()
block|{
name|char
name|ab
index|[
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|BNU_SYSFILES
operator|-
literal|1
index|]
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
name|zBnu_systems
operator|=
name|NULL
expr_stmt|;
name|zBnu_dialers
operator|=
name|NULL
expr_stmt|;
name|zBnu_devices
operator|=
name|NULL
expr_stmt|;
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|BNU_SYSFILES
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|ab
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|zline
operator|=
name|zfgets
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|inl
decl_stmt|;
name|char
modifier|*
name|ztok
decl_stmt|;
name|inl
operator|=
name|strlen
argument_list|(
name|zline
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zline
index|[
name|inl
index|]
operator|==
literal|'\n'
condition|)
name|zline
index|[
name|inl
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
name|zline
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|||
name|zline
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ztok
operator|=
name|strtok
argument_list|(
name|zline
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|ztok
argument_list|,
literal|"service="
argument_list|,
sizeof|sizeof
expr|"service="
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Unrecognized Sysfiles line: %s"
argument_list|,
name|ztok
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
do|do
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|strcspn
argument_list|(
name|ztok
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
sizeof|sizeof
expr|"uucico"
operator|-
literal|1
operator|&&
name|strncmp
argument_list|(
name|ztok
argument_list|,
literal|"uucico"
argument_list|,
sizeof|sizeof
expr|"uucico"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|ztok
operator|+=
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|ztok
operator|==
literal|':'
condition|)
operator|++
name|ztok
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|ztok
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
operator|*
name|ztok
operator|==
literal|'\0'
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
operator|(
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
modifier|*
name|pz
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
name|boolean
name|fend
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ztok
argument_list|,
literal|"systems="
argument_list|,
sizeof|sizeof
expr|"systems="
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pz
operator|=
operator|&
name|zBnu_systems
expr_stmt|;
name|ztok
operator|+=
sizeof|sizeof
expr|"systems="
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|ztok
argument_list|,
literal|"dialers="
argument_list|,
sizeof|sizeof
expr|"dialers="
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pz
operator|=
operator|&
name|zBnu_dialers
expr_stmt|;
name|ztok
operator|+=
sizeof|sizeof
expr|"dialers="
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|ztok
argument_list|,
literal|"devices="
argument_list|,
sizeof|sizeof
expr|"devices="
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pz
operator|=
operator|&
name|zBnu_devices
expr_stmt|;
name|ztok
operator|+=
sizeof|sizeof
expr|"devices="
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Unrecognized Sysfiles command: %s"
argument_list|,
name|ztok
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Stick the configuration file directory in front of each 		 file.  */
name|z
operator|=
name|ztok
expr_stmt|;
do|do
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|strcspn
argument_list|(
name|z
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|fend
operator|=
name|z
index|[
name|c
index|]
operator|==
literal|'\0'
expr_stmt|;
name|z
index|[
name|c
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Looking for a leading '/' is Unix dependent, and 		     should be changed.  */
if|if
condition|(
operator|*
name|z
operator|==
literal|'/'
condition|)
name|uadd_string
argument_list|(
name|pz
argument_list|,
name|z
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|zdir
decl_stmt|;
name|zdir
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
name|strlen
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zdir
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|uadd_string
argument_list|(
name|pz
argument_list|,
name|zdir
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zdir
argument_list|)
expr_stmt|;
block|}
name|z
operator|+=
name|c
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|fend
condition|)
do|;
block|}
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zBnu_systems
operator|==
name|NULL
condition|)
block|{
name|zBnu_systems
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|BNU_SYSTEMS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zBnu_systems
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|BNU_SYSTEMS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zBnu_dialers
operator|==
name|NULL
condition|)
block|{
name|zBnu_dialers
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|BNU_DIALERS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zBnu_dialers
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|BNU_DIALERS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zBnu_devices
operator|==
name|NULL
condition|)
block|{
name|zBnu_devices
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|BNU_DEVICES
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zBnu_devices
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|BNU_DEVICES
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|HAVE_TAYLOR_CONFIG
comment|/* If we are NOT reading the new configuration files, then look for      Maxuuxqts.  It would be more efficient to only read the file in      uuxqt.c.  Too bad.  */
block|{
name|char
modifier|*
name|zmax
decl_stmt|;
name|zmax
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|BNU_MAXUUXQTS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zmax
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|BNU_MAXUUXQTS
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|zmax
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
name|zline
operator|=
name|zfgets
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zline
operator|!=
name|NULL
condition|)
block|{
name|cMaxuuxqts
operator|=
name|atoi
argument_list|(
name|zline
argument_list|)
expr_stmt|;
if|if
condition|(
name|cMaxuuxqts
operator|<
literal|0
condition|)
name|cMaxuuxqts
operator|=
literal|0
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ! HAVE_TAYLOR_CONFIG */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A little routine to add a grade and a time string to a system.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ubadd_time
name|P
argument_list|(
operator|(
expr|struct
name|ssysteminfo
operator|*
name|q
operator|,
name|int
name|bgrade
operator|,
specifier|const
name|char
operator|*
name|ztime
operator|,
name|int
name|cretry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ubadd_time
parameter_list|(
name|q
parameter_list|,
name|bgrade
parameter_list|,
name|ztime
parameter_list|,
name|cretry
parameter_list|)
name|struct
name|ssysteminfo
modifier|*
name|q
decl_stmt|;
name|int
name|bgrade
decl_stmt|;
specifier|const
name|char
modifier|*
name|ztime
decl_stmt|;
name|int
name|cretry
decl_stmt|;
block|{
name|char
modifier|*
name|zset
decl_stmt|;
name|zset
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|ztime
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|cretry
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|"%c%s"
argument_list|,
name|bgrade
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|zset
argument_list|,
literal|"%c%s;%d"
argument_list|,
name|bgrade
argument_list|,
name|ztime
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
name|uadd_string
argument_list|(
operator|&
name|q
operator|->
name|ztime
argument_list|,
name|zset
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These structures are used to read the Permissions file.  */
end_comment

begin_struct
specifier|static
struct|struct
name|sperm
block|{
name|char
modifier|*
name|zlogname
decl_stmt|;
name|char
modifier|*
name|zmachine
decl_stmt|;
name|boolean
name|frequest
decl_stmt|;
enum|enum
block|{
name|SENDFILES_YES
block|,
name|SENDFILES_CALL
block|,
name|SENDFILES_NO
block|}
name|tsendfiles
enum|;
specifier|const
name|char
modifier|*
name|zread
decl_stmt|;
specifier|const
name|char
modifier|*
name|zwrite
decl_stmt|;
name|char
modifier|*
name|znoread
decl_stmt|;
name|char
modifier|*
name|znowrite
decl_stmt|;
name|boolean
name|fcallback
decl_stmt|;
specifier|const
name|char
modifier|*
name|zcommands
decl_stmt|;
name|char
modifier|*
name|zvalidate
decl_stmt|;
name|char
modifier|*
name|zmyname
decl_stmt|;
name|char
modifier|*
name|zpubdir
decl_stmt|;
block|}
name|sBperm
struct|;
end_struct

begin_decl_stmt
specifier|static
name|enum
name|tcmdtabret
name|tbsendfiles
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|pointer
name|pvar
operator|,
specifier|const
name|char
operator|*
name|zerr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scmdtab
name|asBperm_cmds
index|[]
init|=
block|{
block|{
literal|"LOGNAME"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|zlogname
block|,
name|NULL
block|}
block|,
block|{
literal|"MACHINE"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|zmachine
block|,
name|NULL
block|}
block|,
block|{
literal|"REQUEST"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|frequest
block|,
name|NULL
block|}
block|,
block|{
literal|"SENDFILES"
block|,
name|CMDTABTYPE_FN
operator||
literal|2
block|,
name|NULL
block|,
name|tbsendfiles
block|}
block|,
block|{
literal|"READ"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|zread
block|,
name|NULL
block|}
block|,
block|{
literal|"WRITE"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|zwrite
block|,
name|NULL
block|}
block|,
block|{
literal|"NOREAD"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|znoread
block|,
name|NULL
block|}
block|,
block|{
literal|"NOWRITE"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|znowrite
block|,
name|NULL
block|}
block|,
block|{
literal|"CALLBACK"
block|,
name|CMDTABTYPE_BOOLEAN
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|fcallback
block|,
name|NULL
block|}
block|,
block|{
literal|"COMMANDS"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|zcommands
block|,
name|NULL
block|}
block|,
block|{
literal|"VALIDATE"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|zvalidate
block|,
name|NULL
block|}
block|,
block|{
literal|"MYNAME"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|zmyname
block|,
name|NULL
block|}
block|,
block|{
literal|"PUBDIR"
block|,
name|CMDTABTYPE_STRING
block|,
operator|(
name|pointer
operator|)
operator|&
name|sBperm
operator|.
name|zpubdir
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|spermlist
block|{
name|struct
name|spermlist
modifier|*
name|qnext
decl_stmt|;
name|struct
name|sperm
name|sperm
decl_stmt|;
block|}
modifier|*
name|qBothers
struct|;
end_struct

begin_comment
comment|/* Read BNU system information.  This means reading the Systems file    and the Permissions file.  */
end_comment

begin_function
name|void
name|ubnu_read_systems
parameter_list|(
name|pc
parameter_list|,
name|ppas
parameter_list|)
name|int
modifier|*
name|pc
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
modifier|*
name|ppas
decl_stmt|;
block|{
name|int
name|calc
decl_stmt|;
name|struct
name|smulti_file
modifier|*
name|qmulti
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
operator|*
name|pc
operator|=
literal|0
expr_stmt|;
operator|*
name|ppas
operator|=
name|NULL
expr_stmt|;
name|calc
operator|=
literal|0
expr_stmt|;
comment|/* Read the Systems file(s) first.  */
name|qmulti
operator|=
name|qmulti_open
argument_list|(
name|zBnu_systems
argument_list|)
expr_stmt|;
if|if
condition|(
name|qmulti
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|(
name|zline
operator|=
name|zmulti_gets
argument_list|(
name|qmulti
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|inl
decl_stmt|;
name|char
modifier|*
name|ztok
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cretry
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|qset
decl_stmt|;
name|char
modifier|*
name|zsemi
decl_stmt|,
modifier|*
name|zslash
decl_stmt|;
name|inl
operator|=
name|strlen
argument_list|(
name|zline
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zline
index|[
name|inl
index|]
operator|==
literal|'\n'
condition|)
name|zline
index|[
name|inl
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
name|zline
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|||
name|zline
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ztok
operator|=
name|strtok
argument_list|(
name|zline
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DEBUG_MESSAGE1
argument_list|(
name|DEBUG_CONFIG
argument_list|,
literal|"ubnu_read_systems: Reading system %s"
argument_list|,
name|ztok
argument_list|)
expr_stmt|;
comment|/* See if we already have information for this system.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
operator|.
name|zname
argument_list|,
name|ztok
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
operator|*
name|pc
condition|)
block|{
if|if
condition|(
operator|*
name|pc
operator|>=
name|calc
condition|)
block|{
name|calc
operator|+=
literal|10
expr_stmt|;
operator|*
name|ppas
operator|=
operator|(
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|pointer
operator|)
operator|*
name|ppas
argument_list|,
name|calc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|qset
operator|=
operator|&
operator|(
operator|*
name|ppas
operator|)
index|[
operator|*
name|pc
index|]
expr_stmt|;
operator|(
operator|*
name|pc
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ssysteminfo
modifier|*
modifier|*
name|pq
decl_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
operator|.
name|qalternate
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qalternate
control|)
empty_stmt|;
operator|*
name|pq
operator|=
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
expr_stmt|;
name|qset
operator|=
operator|*
name|pq
expr_stmt|;
block|}
name|uset_system_defaults
argument_list|(
name|qset
argument_list|)
expr_stmt|;
name|qset
operator|->
name|zname
operator|=
name|ztok
expr_stmt|;
comment|/* Under BNU, a local request is permitted to write into any 	 directory that is world writeable.  */
name|qset
operator|->
name|zlocal_receive
operator|=
literal|"/"
expr_stmt|;
comment|/* Get the time string.  */
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|==
name|NULL
condition|)
continue|continue;
comment|/* The time string is "time/grade,time/grade;retry".  A missing 	 grade is taken as 'z'.  */
name|cretry
operator|=
literal|0
expr_stmt|;
name|zsemi
operator|=
name|strchr
argument_list|(
name|ztok
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsemi
operator|!=
name|NULL
condition|)
block|{
operator|*
name|zsemi
operator|=
literal|'\0'
expr_stmt|;
name|cretry
operator|=
name|atoi
argument_list|(
name|zsemi
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|qset
operator|->
name|ztime
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|char
modifier|*
name|zcomma
decl_stmt|;
name|zcomma
operator|=
name|strchr
argument_list|(
name|ztok
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcomma
operator|!=
name|NULL
condition|)
operator|*
name|zcomma
operator|=
literal|'\0'
expr_stmt|;
name|zslash
operator|=
name|strchr
argument_list|(
name|ztok
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|zslash
operator|==
name|NULL
operator|||
name|zslash
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|ubadd_time
argument_list|(
name|qset
argument_list|,
name|BGRADE_LOW
argument_list|,
name|ztok
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|zslash
operator|=
literal|'\0'
expr_stmt|;
name|ubadd_time
argument_list|(
name|qset
argument_list|,
name|zslash
index|[
literal|1
index|]
argument_list|,
name|ztok
argument_list|,
name|cretry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zcomma
operator|==
name|NULL
condition|)
break|break;
name|ztok
operator|=
name|zcomma
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Get the devices entry.  */
name|qset
operator|->
name|zport
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
comment|/* Get the speed entry.  If it starts with a nondigit, it's a 	 modem class.  We append it to the device name, and do the 	 same thing when reading the Devices file, since we don't need 	 to preserve the ``ACU''.  I've heard that the modem class is 	 permitted at either end, but this code doesn't support that. 	 A range of speeds is also permitted.  */
if|if
condition|(
name|qset
operator|->
name|zport
operator|!=
name|NULL
condition|)
block|{
comment|/* According to Arne Ludwig, the devices entry can be 	     followed by a comma and a list of protocols.  */
name|ztok
operator|=
name|strrchr
argument_list|(
name|qset
operator|->
name|zport
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|!=
name|NULL
operator|&&
name|ztok
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|qset
operator|->
name|zprotocols
operator|=
name|ztok
operator|+
literal|1
expr_stmt|;
operator|*
name|ztok
operator|=
literal|'\0'
expr_stmt|;
block|}
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|fany
decl_stmt|;
name|fany
operator|=
operator|(
name|strcmp
argument_list|(
name|ztok
argument_list|,
literal|"Any"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|ztok
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|ztok
argument_list|)
operator|&&
operator|!
name|fany
condition|)
block|{
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|zport
decl_stmt|,
modifier|*
name|zset
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|qset
operator|->
name|zport
argument_list|)
expr_stmt|;
name|zport
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|clen
operator|+
name|strlen
argument_list|(
name|ztok
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zport
argument_list|,
name|qset
operator|->
name|zport
argument_list|)
expr_stmt|;
name|zset
operator|=
name|zport
operator|+
name|clen
expr_stmt|;
while|while
condition|(
operator|*
name|ztok
operator|!=
literal|'\0'
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|ztok
argument_list|)
condition|)
operator|*
name|zset
operator|++
operator|=
operator|*
name|ztok
operator|++
expr_stmt|;
operator|*
name|zset
operator|=
literal|'\0'
expr_stmt|;
name|qset
operator|->
name|zport
operator|=
name|zport
expr_stmt|;
block|}
if|if
condition|(
name|fany
condition|)
name|qset
operator|->
name|ibaud
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|qset
operator|->
name|ibaud
operator|=
name|strtol
argument_list|(
name|ztok
argument_list|,
operator|&
name|ztok
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ztok
operator|==
literal|'-'
condition|)
name|qset
operator|->
name|ihighbaud
operator|=
name|atol
argument_list|(
name|ztok
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Get the phone number.  */
name|qset
operator|->
name|zphone
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
comment|/* The rest of the line is the login script.  */
if|if
condition|(
name|qset
operator|->
name|zphone
operator|!=
name|NULL
condition|)
block|{
name|qset
operator|->
name|schat
operator|.
name|zchat
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|qset
operator|->
name|schat
operator|.
name|zchat
operator|+=
name|strspn
argument_list|(
name|qset
operator|->
name|schat
operator|.
name|zchat
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
operator|(
name|void
operator|)
name|fmulti_close
argument_list|(
name|qmulti
argument_list|)
expr_stmt|;
comment|/* Now we have to read the Permissions file.  */
block|{
name|char
name|abperm
index|[
sizeof|sizeof
name|OLDCONFIGLIB
operator|+
sizeof|sizeof
name|BNU_PERMISSIONS
operator|-
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|zpubdir
init|=
name|PUBDIR
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|boolean
modifier|*
name|affound
decl_stmt|;
name|sprintf
argument_list|(
name|abperm
argument_list|,
literal|"%s%s"
argument_list|,
name|OLDCONFIGLIB
argument_list|,
name|BNU_PERMISSIONS
argument_list|)
expr_stmt|;
name|e
operator|=
name|fopen
argument_list|(
name|abperm
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return;
name|affound
operator|=
operator|(
name|boolean
operator|*
operator|)
name|alloca
argument_list|(
operator|*
name|pc
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|affound
argument_list|,
operator|*
name|pc
operator|*
sizeof|sizeof
argument_list|(
name|boolean
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|zline
operator|=
name|zfgets
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|inl
decl_stmt|;
name|char
modifier|*
name|ztok
decl_stmt|;
name|boolean
name|fany
decl_stmt|;
name|inl
operator|=
name|strlen
argument_list|(
name|zline
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zline
index|[
name|inl
index|]
operator|==
literal|'\n'
condition|)
name|zline
index|[
name|inl
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
name|zline
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|||
name|zline
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sBperm
operator|.
name|zlogname
operator|=
name|NULL
expr_stmt|;
name|sBperm
operator|.
name|zmachine
operator|=
name|NULL
expr_stmt|;
name|sBperm
operator|.
name|frequest
operator|=
name|FALSE
expr_stmt|;
name|sBperm
operator|.
name|tsendfiles
operator|=
name|SENDFILES_CALL
expr_stmt|;
name|sBperm
operator|.
name|zread
operator|=
name|zpubdir
expr_stmt|;
name|sBperm
operator|.
name|zwrite
operator|=
name|zpubdir
expr_stmt|;
name|sBperm
operator|.
name|znoread
operator|=
name|NULL
expr_stmt|;
name|sBperm
operator|.
name|znowrite
operator|=
name|NULL
expr_stmt|;
name|sBperm
operator|.
name|fcallback
operator|=
name|FALSE
expr_stmt|;
name|sBperm
operator|.
name|zcommands
operator|=
literal|"rnews rmail"
expr_stmt|;
name|sBperm
operator|.
name|zvalidate
operator|=
name|NULL
expr_stmt|;
name|sBperm
operator|.
name|zmyname
operator|=
name|NULL
expr_stmt|;
name|sBperm
operator|.
name|zpubdir
operator|=
name|NULL
expr_stmt|;
name|fany
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|ztok
operator|=
name|strtok
argument_list|(
name|zline
argument_list|,
literal|" \t"
argument_list|)
init|;
name|ztok
operator|!=
name|NULL
condition|;
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
block|{
name|char
modifier|*
name|zeq
decl_stmt|;
name|char
modifier|*
name|azargs
index|[
literal|2
index|]
decl_stmt|;
name|fany
operator|=
name|TRUE
expr_stmt|;
name|zeq
operator|=
name|strchr
argument_list|(
name|ztok
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|zeq
operator|==
name|NULL
condition|)
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"Bad %s entry: %s"
argument_list|,
name|BNU_PERMISSIONS
argument_list|,
name|ztok
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|zeq
operator|=
literal|'\0'
expr_stmt|;
name|azargs
index|[
literal|0
index|]
operator|=
name|ztok
expr_stmt|;
name|azargs
index|[
literal|1
index|]
operator|=
name|zeq
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|tprocess_one_cmd
argument_list|(
literal|2
argument_list|,
name|azargs
argument_list|,
name|asBperm_cmds
argument_list|,
name|BNU_PERMISSIONS
argument_list|,
name|CMDFLAG_WARNUNRECOG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fany
condition|)
continue|continue;
if|if
condition|(
name|sBperm
operator|.
name|zlogname
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zstart
decl_stmt|;
name|boolean
name|fend
decl_stmt|;
comment|/* Process each LOGNAME separately.  */
name|zstart
operator|=
name|sBperm
operator|.
name|zlogname
expr_stmt|;
do|do
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|strcspn
argument_list|(
name|zstart
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|fend
operator|=
name|zstart
index|[
name|c
index|]
operator|==
literal|'\0'
expr_stmt|;
name|zstart
index|[
name|c
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sBperm
operator|.
name|zlogname
operator|=
name|zstart
expr_stmt|;
name|ubadd_perm
argument_list|(
operator|*
name|pc
argument_list|,
operator|*
name|ppas
argument_list|,
operator|&
name|affound
argument_list|)
expr_stmt|;
name|zstart
operator|+=
name|c
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|fend
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|sBperm
operator|.
name|zmachine
operator|!=
name|NULL
condition|)
name|ubadd_perm
argument_list|(
operator|*
name|pc
argument_list|,
operator|*
name|ppas
argument_list|,
operator|&
name|affound
argument_list|)
expr_stmt|;
else|else
block|{
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: No MACHINE or LOGNAME entry: \"%s\""
argument_list|,
name|BNU_PERMISSIONS
argument_list|,
name|zline
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* If there were any MACHINE=OTHER entry, add the permissions for        each machine that was not specified by name.  */
while|while
condition|(
name|qBothers
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|spermlist
modifier|*
name|qnext
decl_stmt|;
name|sBperm
operator|=
name|qBothers
operator|->
name|sperm
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|affound
index|[
name|i
index|]
condition|)
block|{
name|sBperm
operator|.
name|zmachine
operator|=
name|xstrdup
argument_list|(
operator|(
operator|*
name|ppas
operator|)
index|[
name|i
index|]
operator|.
name|zname
argument_list|)
expr_stmt|;
name|ubadd_perm
argument_list|(
operator|*
name|pc
argument_list|,
operator|*
name|ppas
argument_list|,
operator|&
name|affound
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|sBperm
operator|.
name|zmachine
argument_list|)
expr_stmt|;
block|}
block|}
name|qnext
operator|=
name|qBothers
operator|->
name|qnext
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|qBothers
argument_list|)
expr_stmt|;
name|qBothers
operator|=
name|qnext
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Look up a machine and attach permissions to it.  */
end_comment

begin_function
specifier|static
name|void
name|ubadd_perm
parameter_list|(
name|csystems
parameter_list|,
name|passystems
parameter_list|,
name|paffound
parameter_list|)
name|int
name|csystems
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|passystems
decl_stmt|;
name|boolean
modifier|*
modifier|*
name|paffound
decl_stmt|;
block|{
if|if
condition|(
name|sBperm
operator|.
name|zmachine
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zcopy
decl_stmt|;
name|char
modifier|*
name|ztok
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sBperm
operator|.
name|zmachine
argument_list|,
literal|"OTHER"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|spermlist
modifier|*
name|qnew
decl_stmt|;
name|qnew
operator|=
operator|(
expr|struct
name|spermlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spermlist
argument_list|)
argument_list|)
expr_stmt|;
name|qnew
operator|->
name|qnext
operator|=
name|qBothers
expr_stmt|;
name|qnew
operator|->
name|sperm
operator|=
name|sBperm
expr_stmt|;
name|qBothers
operator|=
name|qnew
expr_stmt|;
return|return;
block|}
name|zcopy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|sBperm
operator|.
name|zmachine
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zcopy
argument_list|,
name|sBperm
operator|.
name|zmachine
argument_list|)
expr_stmt|;
for|for
control|(
name|ztok
operator|=
name|strtok
argument_list|(
name|zcopy
argument_list|,
literal|":"
argument_list|)
init|;
name|ztok
operator|!=
name|NULL
condition|;
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|":"
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ssysteminfo
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|csystems
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|passystems
index|[
name|i
index|]
operator|.
name|zname
argument_list|,
name|ztok
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|csystems
condition|)
block|{
comment|/* We just ignore Permissions entries for unknown 		 systems.  */
continue|continue;
block|}
if|if
condition|(
operator|(
operator|*
name|paffound
operator|)
index|[
name|i
index|]
condition|)
block|{
name|struct
name|ssysteminfo
modifier|*
modifier|*
name|pq
decl_stmt|;
comment|/* We have already handled this machine.  Make a copy of 		 the first alternate and set the login name to 		 whatever this entry wants.  Then put the new entry at 		 the end of list of alternates.  This will make 		 whatever we saw first the default.  */
name|q
operator|=
operator|(
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
operator|)
expr_stmt|;
operator|*
name|q
operator|=
name|passystems
index|[
name|i
index|]
expr_stmt|;
name|q
operator|->
name|qalternate
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|passystems
index|[
name|i
index|]
operator|.
name|qalternate
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|qalternate
control|)
empty_stmt|;
operator|*
name|pq
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|zcalled_login
operator|=
literal|"ANY"
expr_stmt|;
name|ubadd_perm_alternate
argument_list|(
name|q
argument_list|,
name|TRUE
argument_list|,
name|sBperm
operator|.
name|zlogname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|paffound
operator|)
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|q
operator|=
operator|&
name|passystems
index|[
name|i
index|]
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|qalternate
control|)
name|ubadd_perm_alternate
argument_list|(
name|q
argument_list|,
name|TRUE
argument_list|,
name|sBperm
operator|.
name|zlogname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|>
literal|0
if|if
condition|(
name|sBperm
operator|.
name|zlogname
operator|==
name|NULL
condition|)
name|ulog
argument_list|(
name|LOG_FATAL
argument_list|,
literal|"bnu.c: ubadd_perm: Can't happen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* There was a LOGNAME= but no MACHINE=.  We must add an 	 alternate specifying this LOGNAME to all machines.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|csystems
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ssysteminfo
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|passystems
index|[
name|i
index|]
operator|.
name|zcalled_login
operator|==
name|NULL
condition|)
name|passystems
index|[
name|i
index|]
operator|.
name|zcalled_login
operator|=
literal|"ANY"
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ssysteminfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssysteminfo
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|passystems
index|[
name|i
index|]
expr_stmt|;
name|q
operator|->
name|qalternate
operator|=
name|passystems
index|[
name|i
index|]
operator|.
name|qalternate
expr_stmt|;
name|passystems
index|[
name|i
index|]
operator|.
name|qalternate
operator|=
name|q
expr_stmt|;
name|ubadd_perm_alternate
argument_list|(
name|q
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Attach permissions to a specific alternate of a machine.  */
end_comment

begin_function
specifier|static
name|void
name|ubadd_perm_alternate
parameter_list|(
name|q
parameter_list|,
name|fmachine
parameter_list|,
name|flogname
parameter_list|)
name|struct
name|ssysteminfo
modifier|*
name|q
decl_stmt|;
name|boolean
name|fmachine
decl_stmt|;
name|boolean
name|flogname
decl_stmt|;
block|{
name|char
modifier|*
name|z
decl_stmt|,
modifier|*
name|zset
decl_stmt|;
if|if
condition|(
name|flogname
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|zcalled_login
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|q
operator|->
name|zcalled_login
argument_list|,
literal|"ANY"
argument_list|)
operator|!=
literal|0
condition|)
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: Can't handle two login names for one machine"
argument_list|,
name|q
operator|->
name|zname
argument_list|)
expr_stmt|;
else|else
name|q
operator|->
name|zcalled_login
operator|=
name|sBperm
operator|.
name|zlogname
expr_stmt|;
block|}
if|if
condition|(
name|fmachine
condition|)
name|q
operator|->
name|fcall_request
operator|=
name|sBperm
operator|.
name|frequest
expr_stmt|;
if|if
condition|(
name|flogname
condition|)
name|q
operator|->
name|fcalled_request
operator|=
name|sBperm
operator|.
name|frequest
expr_stmt|;
if|if
condition|(
name|flogname
condition|)
block|{
name|q
operator|->
name|fcall_transfer
operator|=
operator|(
name|sBperm
operator|.
name|tsendfiles
operator|==
name|SENDFILES_CALL
operator|||
operator|(
name|sBperm
operator|.
name|tsendfiles
operator|==
name|SENDFILES_YES
operator|)
operator|)
expr_stmt|;
name|q
operator|->
name|fcalled_transfer
operator|=
name|sBperm
operator|.
name|tsendfiles
operator|==
name|SENDFILES_YES
expr_stmt|;
block|}
name|zset
operator|=
name|xstrdup
argument_list|(
name|sBperm
operator|.
name|zread
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|z
operator|=
name|strchr
argument_list|(
name|zset
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|z
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|sBperm
operator|.
name|znoread
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zstart
decl_stmt|;
name|boolean
name|fend
decl_stmt|;
name|zstart
operator|=
name|xstrdup
argument_list|(
name|sBperm
operator|.
name|znoread
argument_list|)
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|zalloc
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
name|strcspn
argument_list|(
name|zstart
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|fend
operator|=
name|zstart
index|[
name|c
index|]
operator|==
literal|'\0'
expr_stmt|;
name|zstart
index|[
name|c
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zalloc
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|c
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zalloc
argument_list|,
literal|"!%s"
argument_list|,
name|zstart
argument_list|)
expr_stmt|;
name|uadd_string
argument_list|(
operator|&
name|zset
argument_list|,
name|zalloc
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zalloc
argument_list|)
expr_stmt|;
name|zstart
operator|+=
name|c
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|fend
condition|)
do|;
block|}
if|if
condition|(
name|fmachine
condition|)
name|q
operator|->
name|zremote_send
operator|=
name|zset
expr_stmt|;
if|if
condition|(
name|flogname
condition|)
block|{
if|if
condition|(
name|fmachine
condition|)
name|q
operator|->
name|zcalled_remote_send
operator|=
name|NULL
expr_stmt|;
else|else
name|q
operator|->
name|zcalled_remote_send
operator|=
name|zset
expr_stmt|;
block|}
name|zset
operator|=
name|xstrdup
argument_list|(
name|sBperm
operator|.
name|zwrite
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|z
operator|=
name|strchr
argument_list|(
name|zset
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|z
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|sBperm
operator|.
name|znowrite
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zstart
decl_stmt|;
name|boolean
name|fend
decl_stmt|;
name|zstart
operator|=
name|xstrdup
argument_list|(
name|sBperm
operator|.
name|znowrite
argument_list|)
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|zalloc
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
name|strcspn
argument_list|(
name|zstart
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|fend
operator|=
name|zstart
index|[
name|c
index|]
operator|==
literal|'\0'
expr_stmt|;
name|zstart
index|[
name|c
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zalloc
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|c
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|zalloc
argument_list|,
literal|"!%s"
argument_list|,
name|zstart
argument_list|)
expr_stmt|;
name|uadd_string
argument_list|(
operator|&
name|zset
argument_list|,
name|zalloc
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zalloc
argument_list|)
expr_stmt|;
name|zstart
operator|+=
name|c
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|fend
condition|)
do|;
block|}
if|if
condition|(
name|fmachine
condition|)
name|q
operator|->
name|zremote_receive
operator|=
name|zset
expr_stmt|;
if|if
condition|(
name|flogname
condition|)
block|{
if|if
condition|(
name|fmachine
condition|)
name|q
operator|->
name|zcalled_remote_receive
operator|=
name|NULL
expr_stmt|;
else|else
name|q
operator|->
name|zcalled_remote_receive
operator|=
name|zset
expr_stmt|;
block|}
if|if
condition|(
name|flogname
condition|)
name|q
operator|->
name|fcallback
operator|=
name|sBperm
operator|.
name|fcallback
expr_stmt|;
if|if
condition|(
name|fmachine
operator|&&
name|sBperm
operator|.
name|zcommands
operator|!=
name|NULL
condition|)
block|{
name|q
operator|->
name|zcmds
operator|=
name|sBperm
operator|.
name|zcommands
expr_stmt|;
while|while
condition|(
operator|(
name|z
operator|=
name|strchr
argument_list|(
name|q
operator|->
name|zcmds
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|z
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|flogname
operator|&&
name|sBperm
operator|.
name|zvalidate
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|zcopy
decl_stmt|;
name|boolean
name|fend
decl_stmt|;
name|zcopy
operator|=
name|xstrdup
argument_list|(
name|sBperm
operator|.
name|zvalidate
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|strcspn
argument_list|(
name|zcopy
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|fend
operator|=
name|zcopy
index|[
name|c
index|]
operator|==
literal|'\0'
expr_stmt|;
name|zcopy
index|[
name|c
index|]
operator|=
literal|'\0'
expr_stmt|;
name|uadd_validate
argument_list|(
name|sBperm
operator|.
name|zlogname
argument_list|,
literal|1
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|zcopy
argument_list|)
expr_stmt|;
name|zcopy
operator|+=
name|c
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|fend
condition|)
do|;
block|}
if|if
condition|(
name|fmachine
condition|)
name|q
operator|->
name|zlocalname
operator|=
name|sBperm
operator|.
name|zmyname
expr_stmt|;
comment|/* This isn't quite right, since the BNU Permissions file can      specify a different public directory based on whether we are      calling out or are being called.  */
if|if
condition|(
name|sBperm
operator|.
name|zpubdir
operator|!=
name|NULL
condition|)
name|q
operator|->
name|zpubdir
operator|=
name|sBperm
operator|.
name|zpubdir
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle SENDFILES=string, where string can be YES, NO or CALL.  We    actually only switch off on the first letter.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|enum
name|tcmdtabret
name|tbsendfiles
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pvar
parameter_list|,
name|zerr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pointer
name|pvar
decl_stmt|;
specifier|const
name|char
modifier|*
name|zerr
decl_stmt|;
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
name|sBperm
operator|.
name|tsendfiles
operator|=
name|SENDFILES_CALL
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
case|case
literal|'n'
case|:
name|sBperm
operator|.
name|tsendfiles
operator|=
name|SENDFILES_NO
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
case|case
literal|'y'
case|:
name|sBperm
operator|.
name|tsendfiles
operator|=
name|SENDFILES_YES
expr_stmt|;
break|break;
default|default:
name|ulog
argument_list|(
name|LOG_ERROR
argument_list|,
literal|"%s: Unrecognized SENDFILES=%s"
argument_list|,
name|zerr
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|CMDTABRET_FREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a port with a given name and baud rate in the Devices file,    and lock it.  If found and locked, fill in the structure pointed at    by qport.  Set *pffound to TRUE if a port was found but could not    be locked.  */
end_comment

begin_function_decl
name|boolean
name|fbnu_find_port
parameter_list|(
name|zname
parameter_list|,
name|ibaud
parameter_list|,
name|ihighbaud
parameter_list|,
name|qport
parameter_list|,
name|pflock
parameter_list|,
name|pffound
parameter_list|)
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
name|long
name|ibaud
decl_stmt|;
name|long
name|ihighbaud
decl_stmt|;
name|struct
name|sport
modifier|*
name|qport
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*pflock
end_function_decl

begin_expr_stmt
unit|)
name|P
argument_list|(
operator|(
expr|struct
name|sport
operator|*
operator|,
name|boolean
name|fin
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|boolean
modifier|*
name|pffound
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|smulti_file
modifier|*
name|qmulti
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
name|qmulti
operator|=
name|qmulti_open
argument_list|(
name|zBnu_devices
argument_list|)
expr_stmt|;
if|if
condition|(
name|qmulti
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
operator|(
name|zline
operator|=
name|zmulti_gets
argument_list|(
name|qmulti
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|inl
decl_stmt|;
name|char
modifier|*
name|ztok
decl_stmt|,
modifier|*
name|zportname
decl_stmt|,
modifier|*
name|zprotocols
decl_stmt|,
modifier|*
name|zdevice
decl_stmt|,
modifier|*
name|zdial_device
decl_stmt|;
name|long
name|ilow
decl_stmt|,
name|ihigh
decl_stmt|;
name|inl
operator|=
name|strlen
argument_list|(
name|zline
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zline
index|[
name|inl
index|]
operator|==
literal|'\n'
condition|)
name|zline
index|[
name|inl
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
name|zline
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|||
name|zline
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* An entry in Devices is type device dial-device baud 	 dialer-token pairs.  */
comment|/* Get the port type.  */
name|zportname
operator|=
name|strtok
argument_list|(
name|zline
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zportname
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* There may be a comma separated list of protocols following 	 the port name.  */
name|zprotocols
operator|=
name|strchr
argument_list|(
name|zportname
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|zprotocols
operator|!=
name|NULL
condition|)
block|{
operator|*
name|zprotocols
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|zprotocols
expr_stmt|;
block|}
comment|/* Get the device name.  */
name|zdevice
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdevice
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Some systems seem to permit ,M at the end of the device name; 	 this means to open the port with O_NDELAY and then allow 	 delays later.  We always do this anyhow, so I just ignore the 	 ,M.  There may be portability problems here.  */
name|zdevice
index|[
name|strcspn
argument_list|(
name|zdevice
argument_list|,
literal|","
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get the dial-device.  A value of ``-'' means none.  */
name|zdial_device
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdial_device
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|zdial_device
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|zdial_device
operator|=
name|NULL
expr_stmt|;
comment|/* Get the speed.  */
name|ztok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ztok
operator|==
name|NULL
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See whether we match the port name we are looking for.  If 	 the speed starts with a non-digit, it is a modem class (but 	 "-" or "Any" mean any speed).  When reading the Systems file 	 we appended the modem class to the device name, so we must 	 match appropriately.  */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|ztok
argument_list|)
operator|||
name|strcmp
argument_list|(
name|ztok
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|ztok
argument_list|,
literal|"Any"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zname
argument_list|,
name|zportname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|zclass
decl_stmt|,
modifier|*
name|zset
decl_stmt|;
name|zclass
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|ztok
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zset
operator|=
name|zclass
expr_stmt|;
while|while
condition|(
operator|*
name|ztok
operator|!=
literal|'\0'
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|ztok
argument_list|)
condition|)
operator|*
name|zset
operator|++
operator|=
operator|*
name|ztok
operator|++
expr_stmt|;
operator|*
name|zset
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|zname
operator|!=
name|NULL
condition|)
block|{
name|int
name|clen
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|zportname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zname
argument_list|,
name|zportname
argument_list|,
name|clen
argument_list|)
operator|!=
literal|0
operator|||
name|strlen
argument_list|(
name|zname
argument_list|)
operator|<=
name|clen
operator|||
name|strcmp
argument_list|(
name|zname
operator|+
name|clen
argument_list|,
name|zclass
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|ilow
operator|=
name|strtol
argument_list|(
name|ztok
argument_list|,
operator|&
name|ztok
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilow
operator|==
literal|0
condition|)
name|ihigh
operator|=
literal|38400L
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|ztok
operator|==
literal|'-'
condition|)
name|ihigh
operator|=
name|atol
argument_list|(
name|ztok
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|ihigh
operator|=
name|ilow
expr_stmt|;
block|}
comment|/* Now we must match the range ibaud to ihighbaud against to 	 range ilow to ihigh.  */
if|if
condition|(
name|ibaud
operator|!=
literal|0
operator|&&
operator|(
name|ihighbaud
operator|<
name|ilow
operator|||
name|ibaud
operator|>
name|ihigh
operator|)
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We have found a matching port.  We now fill in the sport 	 structure so that we can try to lock it.  */
if|if
condition|(
name|zname
operator|!=
name|NULL
condition|)
name|qport
operator|->
name|zname
operator|=
name|zname
expr_stmt|;
else|else
name|qport
operator|->
name|zname
operator|=
name|zportname
expr_stmt|;
name|qport
operator|->
name|zprotocols
operator|=
name|zprotocols
expr_stmt|;
name|qport
operator|->
name|cproto_params
operator|=
literal|0
expr_stmt|;
name|qport
operator|->
name|qproto_params
operator|=
name|NULL
expr_stmt|;
name|qport
operator|->
name|ireliable
operator|=
literal|0
expr_stmt|;
name|qport
operator|->
name|zlockname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|qport
operator|->
name|zname
argument_list|,
literal|"Direct"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qport
operator|->
name|ttype
operator|=
name|PORTTYPE_DIRECT
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|sdirect
operator|.
name|zdevice
operator|=
name|zdevice
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|sdirect
operator|.
name|ibaud
operator|=
name|ilow
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSDEP_DIRECT_INIT
name|SYSDEP_DIRECT_INIT
argument_list|(
operator|&
name|qport
operator|->
name|u
operator|.
name|sdirect
operator|.
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|HAVE_TCP
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|qport
operator|->
name|zname
argument_list|,
literal|"TCP"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qport
operator|->
name|ttype
operator|=
name|PORTTYPE_TCP
expr_stmt|;
name|qport
operator|->
name|ireliable
operator|=
operator|(
name|RELIABLE_ENDTOEND
operator||
name|RELIABLE_RELIABLE
operator||
name|RELIABLE_EIGHT
operator||
name|RELIABLE_SPECIFIED
operator|)
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|o
operator|=
operator|-
literal|1
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|stcp
operator|.
name|zport
operator|=
name|zdevice
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_TCP */
else|else
block|{
name|qport
operator|->
name|ttype
operator|=
name|PORTTYPE_MODEM
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdevice
operator|=
name|zdevice
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdial_device
operator|=
name|zdial_device
expr_stmt|;
if|if
condition|(
name|ilow
operator|!=
name|ihigh
condition|)
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ibaud
operator|=
literal|0
expr_stmt|;
else|else
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ibaud
operator|=
name|ilow
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ilowbaud
operator|=
name|ilow
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|ihighbaud
operator|=
name|ihigh
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|fcarrier
operator|=
name|TRUE
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
operator|+=
name|strspn
argument_list|(
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|zdialer
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|qdialer
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSDEP_MODEM_INIT
name|SYSDEP_MODEM_INIT
argument_list|(
operator|&
name|qport
operator|->
name|u
operator|.
name|smodem
operator|.
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pffound
operator|!=
name|NULL
condition|)
operator|*
name|pffound
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|pflock
operator|!=
name|NULL
operator|&&
operator|!
call|(
modifier|*
name|pflock
call|)
argument_list|(
name|qport
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|fmulti_close
argument_list|(
name|qmulti
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|(
name|void
operator|)
name|fmulti_close
argument_list|(
name|qmulti
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read dialer information from the Dialers file.  */
end_comment

begin_function
name|boolean
name|fbnu_read_dialer_info
parameter_list|(
name|zdialer
parameter_list|,
name|qdialer
parameter_list|)
specifier|const
name|char
modifier|*
name|zdialer
decl_stmt|;
name|struct
name|sdialer
modifier|*
name|qdialer
decl_stmt|;
block|{
name|struct
name|smulti_file
modifier|*
name|qmulti
decl_stmt|;
name|char
modifier|*
name|zline
decl_stmt|;
name|qmulti
operator|=
name|qmulti_open
argument_list|(
name|zBnu_dialers
argument_list|)
expr_stmt|;
if|if
condition|(
name|qmulti
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
operator|(
name|zline
operator|=
name|zmulti_gets
argument_list|(
name|qmulti
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|inl
decl_stmt|;
name|char
modifier|*
name|zname
decl_stmt|,
modifier|*
name|zsubs
decl_stmt|;
name|inl
operator|=
name|strlen
argument_list|(
name|zline
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zline
index|[
name|inl
index|]
operator|==
literal|'\n'
condition|)
name|zline
index|[
name|inl
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|BUCHAR
argument_list|(
name|zline
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|||
name|zline
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|zname
operator|=
name|strtok
argument_list|(
name|zline
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zname
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|zname
argument_list|,
name|zdialer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xfree
argument_list|(
operator|(
name|pointer
operator|)
name|zline
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We found the dialer we want.  Get information from it.  */
name|qdialer
operator|->
name|zname
operator|=
name|zdialer
expr_stmt|;
name|INIT_CHAT
argument_list|(
operator|&
name|qdialer
operator|->
name|schat
argument_list|)
expr_stmt|;
name|qdialer
operator|->
name|zdialtone
operator|=
literal|","
expr_stmt|;
name|qdialer
operator|->
name|zpause
operator|=
literal|","
expr_stmt|;
name|qdialer
operator|->
name|fcarrier
operator|=
name|TRUE
expr_stmt|;
name|qdialer
operator|->
name|ccarrier_wait
operator|=
literal|60
expr_stmt|;
name|qdialer
operator|->
name|fdtr_toggle
operator|=
name|FALSE
expr_stmt|;
name|qdialer
operator|->
name|fdtr_toggle_wait
operator|=
name|FALSE
expr_stmt|;
name|INIT_CHAT
argument_list|(
operator|&
name|qdialer
operator|->
name|scomplete
argument_list|)
expr_stmt|;
name|INIT_CHAT
argument_list|(
operator|&
name|qdialer
operator|->
name|sabort
argument_list|)
expr_stmt|;
name|qdialer
operator|->
name|cproto_params
operator|=
literal|0
expr_stmt|;
name|qdialer
operator|->
name|qproto_params
operator|=
name|NULL
expr_stmt|;
name|qdialer
operator|->
name|ireliable
operator|=
literal|0
expr_stmt|;
name|zsubs
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsubs
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zsubs
argument_list|,
literal|"\"\""
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|bnext
decl_stmt|;
name|bnext
operator|=
operator|*
name|zsubs
expr_stmt|;
while|while
condition|(
name|bnext
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|zsubs
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|bnext
operator|==
literal|'='
condition|)
name|qdialer
operator|->
name|zdialtone
operator|=
name|zsubs
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|bnext
operator|==
literal|'-'
condition|)
name|qdialer
operator|->
name|zpause
operator|=
name|zsubs
operator|+
literal|1
expr_stmt|;
name|zsubs
operator|+=
literal|2
expr_stmt|;
name|bnext
operator|=
operator|*
name|zsubs
expr_stmt|;
operator|*
name|zsubs
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zsubs
operator|==
name|NULL
condition|)
name|qdialer
operator|->
name|schat
operator|.
name|zchat
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|qdialer
operator|->
name|schat
operator|.
name|zchat
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|qdialer
operator|->
name|schat
operator|.
name|zchat
operator|+=
name|strspn
argument_list|(
name|qdialer
operator|->
name|schat
operator|.
name|zchat
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fmulti_close
argument_list|(
name|qmulti
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|(
name|void
operator|)
name|fmulti_close
argument_list|(
name|qmulti
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_BNU_CONFIG */
end_comment

end_unit

