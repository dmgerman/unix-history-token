begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gzip (GNU zip) -- compress files with zip algorithm and 'compress' interface  * Copyright (C) 1992-1993 Jean-loup Gailly  * The unzip code was written and put in the public domain by Mark Adler.  * Portions of the lzw code are derived from the public domain 'compress'  * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,  * Ken Turkowski, Dave Mack and Peter Jannesen.  *  * See the license_msg below and the file COPYING for the software license.  * See the file algorithm.doc for the compression algorithms and file formats.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|license_msg
index|[]
init|=
block|{
literal|"   Copyright (C) 1992-1993 Jean-loup Gailly"
block|,
literal|"   This program is free software; you can redistribute it and/or modify"
block|,
literal|"   it under the terms of the GNU General Public License as published by"
block|,
literal|"   the Free Software Foundation; either version 2, or (at your option)"
block|,
literal|"   any later version."
block|,
literal|""
block|,
literal|"   This program is distributed in the hope that it will be useful,"
block|,
literal|"   but WITHOUT ANY WARRANTY; without even the implied warranty of"
block|,
literal|"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"
block|,
literal|"   GNU General Public License for more details."
block|,
literal|""
block|,
literal|"   You should have received a copy of the GNU General Public License"
block|,
literal|"   along with this program; if not, write to the Free Software"
block|,
literal|"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA."
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compress files with zip algorithm and 'compress' interface.  * See usage() and help() functions below for all options.  * Outputs:  *        file.z:   compressed file with same mode, owner, and utimes  *        file.Z:   same with -Z option (old compress format)  *     or stdout with -c option or if stdin used as input.  * If the OS does not support file names with multiple dots (MSDOS, VMS) or  * if the output file name had to be truncated, the original name is kept  * in the compressed .z file. (Feature not available in old compress format.)  * On MSDOS, file.tmp -> file.tmz. On VMS, file.tmp -> file.tmp-z.  *  * For the meaning of all compilation flags, see comments in Makefile.in.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: gzip.c,v 0.17 1993/03/18 18:14:56 jloup Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"gzip.h"
end_include

begin_include
include|#
directive|include
file|"lzw.h"
end_include

begin_include
include|#
directive|include
file|"revision.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* configuration */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FCNTL_H
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|NO_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIRENT
argument_list|)
operator|||
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|dirent
name|dir_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NLENGTH
parameter_list|(
name|dirent
parameter_list|)
value|((int)strlen((dirent)->d_name))
end_define

begin_define
define|#
directive|define
name|DIR_OPT
value|"DIRENT"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NLENGTH
parameter_list|(
name|dirent
parameter_list|)
value|((dirent)->d_namlen)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYSDIR
end_ifdef

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|direct
name|dir_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DIR_OPT
value|"SYSDIR"
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SYSNDIR
end_ifdef

begin_include
include|#
directive|include
file|<sys/ndir.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|direct
name|dir_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DIR_OPT
value|"SYSNDIR"
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|NDIR
end_ifdef

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|direct
name|dir_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DIR_OPT
value|"NDIR"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NO_DIR
end_define

begin_define
define|#
directive|define
name|DIR_OPT
value|"NO_DIR"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UTIME
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UTIME_H
end_ifndef

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_define
define|#
directive|define
name|TIME_OPT
value|"UTIME"
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UTIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/utime.h>
end_include

begin_define
define|#
directive|define
name|TIME_OPT
value|"SYS_UTIME"
end_define

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|utimbuf
block|{
name|time_t
name|actime
decl_stmt|;
name|time_t
name|modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TIME_OPT
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TIME_OPT
value|"NO_UTIME"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISREG
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFREG
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|RETSIGTYPE
function_decl|(
modifier|*
name|sig_type
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_comment
comment|/* creation mode for open() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_CREAT
end_ifndef

begin_comment
comment|/* Pure BSD system? */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_CREAT
end_ifndef

begin_define
define|#
directive|define
name|O_CREAT
value|FCREAT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_EXCL
end_ifndef

begin_define
define|#
directive|define
name|O_EXCL
value|FEXCL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RW_USER
value|0600
end_define

begin_comment
comment|/* creation mode for open() */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_PATH_LEN
end_ifndef

begin_define
define|#
directive|define
name|MAX_PATH_LEN
value|1024
end_define

begin_comment
comment|/* max pathname length */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_HEADER_LEN
value|16
end_define

begin_comment
comment|/* max length of a compressed file header, fixed part only */
end_comment

begin_comment
comment|/* global buffers */
end_comment

begin_expr_stmt
name|DECLARE
argument_list|(
name|uch
argument_list|,
name|inbuf
argument_list|,
name|INBUFSIZ
operator|+
name|INBUF_EXTRA
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE
argument_list|(
name|uch
argument_list|,
name|outbuf
argument_list|,
name|OUTBUFSIZ
operator|+
name|OUTBUF_EXTRA
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE
argument_list|(
name|ush
argument_list|,
name|d_buf
argument_list|,
name|DIST_BUFSIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE
argument_list|(
name|uch
argument_list|,
name|window
argument_list|,
literal|2L
operator|*
name|WSIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MAXSEG_64K
end_ifndef

begin_expr_stmt
name|DECLARE
argument_list|(
name|ush
argument_list|,
name|tab_prefix
argument_list|,
literal|1L
operator|<<
name|BITS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|DECLARE
argument_list|(
name|ush
argument_list|,
name|tab_prefix0
argument_list|,
literal|1L
operator|<<
operator|(
name|BITS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE
argument_list|(
name|ush
argument_list|,
name|tab_prefix1
argument_list|,
literal|1L
operator|<<
operator|(
name|BITS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* local variables */
end_comment

begin_decl_stmt
name|int
name|to_stdout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output to stdout (-c) */
end_comment

begin_decl_stmt
name|int
name|decompress
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* decompress (-d) */
end_comment

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't ask questions, compress links (-f) */
end_comment

begin_decl_stmt
name|int
name|recursive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recurse through directories (-r) */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* be verbose (-v) */
end_comment

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* be very quiet (-q) */
end_comment

begin_decl_stmt
name|int
name|quit_on_tty
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* quit if compressing to or decompressing from a tty */
end_comment

begin_decl_stmt
name|int
name|do_lzw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generate output compatible with old compress (-Z) */
end_comment

begin_decl_stmt
name|int
name|test
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* test .z file integrity */
end_comment

begin_decl_stmt
name|int
name|foreground
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if program run in foreground */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program name */
end_comment

begin_decl_stmt
name|int
name|maxbits
init|=
name|BITS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max bits per code for LZW */
end_comment

begin_decl_stmt
name|int
name|method
init|=
name|DEFLATED
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compression method */
end_comment

begin_decl_stmt
name|int
name|level
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compression level */
end_comment

begin_decl_stmt
name|int
name|exit_code
init|=
name|OK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program exit code */
end_comment

begin_decl_stmt
name|int
name|save_orig_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if original name must be saved */
end_comment

begin_decl_stmt
name|int
name|last_member
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set for .zip and .Z files */
end_comment

begin_decl_stmt
name|int
name|part_nb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of parts in .z file */
end_comment

begin_decl_stmt
name|ulg
name|time_stamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original time stamp (modification time) */
end_comment

begin_decl_stmt
name|long
name|ifile_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file size, -1 for devices (debug only) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contents of GZIP env variable */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argv pointer if GZIP env variable defined */
end_comment

begin_decl_stmt
name|long
name|bytes_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of input bytes */
end_comment

begin_decl_stmt
name|long
name|bytes_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of output bytes */
end_comment

begin_decl_stmt
name|char
name|ifname
index|[
name|MAX_PATH_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input filename */
end_comment

begin_decl_stmt
name|char
name|ofname
index|[
name|MAX_PATH_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output filename */
end_comment

begin_decl_stmt
name|int
name|remove_ofname
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* remove output file on error */
end_comment

begin_decl_stmt
name|struct
name|stat
name|istat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status for input file */
end_comment

begin_decl_stmt
name|int
name|ifd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file descriptor */
end_comment

begin_decl_stmt
name|int
name|ofd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file descriptor */
end_comment

begin_decl_stmt
name|unsigned
name|insize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* valid bytes in inbuf */
end_comment

begin_decl_stmt
name|unsigned
name|inptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of next byte to be processed in inbuf */
end_comment

begin_decl_stmt
name|unsigned
name|outcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bytes in output buffer */
end_comment

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
comment|/* { name  has_arg  *flag  val } */
comment|/* {"ascii",      0, 0, 'a'},  ascii text mode */
block|{
literal|"stdout"
block|,
literal|0
block|,
literal|0
block|,
literal|'c'
block|}
block|,
comment|/* write output on standard output */
block|{
literal|"decompress"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
comment|/* decompress */
block|{
literal|"uncompress"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
comment|/* decompress */
comment|/* {"encrypt",    0, 0, 'e'},    encrypt */
block|{
literal|"force"
block|,
literal|0
block|,
literal|0
block|,
literal|'f'
block|}
block|,
comment|/* force overwrite of output file */
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
literal|'h'
block|}
block|,
comment|/* give help */
comment|/* {"pkzip",      0, 0, 'k'},    force output in pkzip format */
comment|/* {"list",       0, 0, 'l'},    list .z file contents */
block|{
literal|"license"
block|,
literal|0
block|,
literal|0
block|,
literal|'L'
block|}
block|,
comment|/* display software license */
block|{
literal|"quiet"
block|,
literal|0
block|,
literal|0
block|,
literal|'q'
block|}
block|,
comment|/* quiet mode */
block|{
literal|"recurse"
block|,
literal|0
block|,
literal|0
block|,
literal|'r'
block|}
block|,
comment|/* recurse through directories */
block|{
literal|"test"
block|,
literal|0
block|,
literal|0
block|,
literal|'t'
block|}
block|,
comment|/* test compressed file integrity */
block|{
literal|"verbose"
block|,
literal|0
block|,
literal|0
block|,
literal|'v'
block|}
block|,
comment|/* verbose mode */
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'V'
block|}
block|,
comment|/* display version number */
block|{
literal|"fast"
block|,
literal|0
block|,
literal|0
block|,
literal|'1'
block|}
block|,
comment|/* compress faster */
block|{
literal|"best"
block|,
literal|0
block|,
literal|0
block|,
literal|'9'
block|}
block|,
comment|/* compress better */
block|{
literal|"lzw"
block|,
literal|0
block|,
literal|0
block|,
literal|'Z'
block|}
block|,
comment|/* make output compatible with old compress */
block|{
literal|"bits"
block|,
literal|1
block|,
literal|0
block|,
literal|'b'
block|}
block|,
comment|/* max number of bits per code (implies -Z) */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local functions */
end_comment

begin_decl_stmt
name|local
name|void
name|usage
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|help
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|license
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|version
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|treat_stdin
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|treat_file
name|OF
argument_list|(
operator|(
name|char
operator|*
name|iname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|create_outfile
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|do_stat
name|OF
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
expr|struct
name|stat
operator|*
name|sbuf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|char
modifier|*
name|get_suffix
name|OF
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|get_istat
name|OF
argument_list|(
operator|(
name|char
operator|*
name|iname
operator|,
expr|struct
name|stat
operator|*
name|sbuf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|make_ofname
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|same_file
name|OF
argument_list|(
operator|(
expr|struct
name|stat
operator|*
name|stat1
operator|,
expr|struct
name|stat
operator|*
name|stat2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|name_too_long
name|OF
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
expr|struct
name|stat
operator|*
name|statb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|get_method
name|OF
argument_list|(
operator|(
name|int
name|in
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|check_ofname
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|reset_times
name|OF
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
expr|struct
name|stat
operator|*
name|statb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|copy_stat
name|OF
argument_list|(
operator|(
expr|struct
name|stat
operator|*
name|ifstat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|treat_dir
name|OF
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|do_exit
name|OF
argument_list|(
operator|(
name|int
name|exitcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
decl|main
name|OF
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|void
argument_list|(
argument|*work
argument_list|)
end_macro

begin_expr_stmt
name|OF
argument_list|(
operator|(
name|int
name|infile
operator|,
name|int
name|outfile
operator|)
argument_list|)
operator|=
name|zip
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* function to call */
end_comment

begin_define
define|#
directive|define
name|strequ
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp((s1),(s2)) == 0)
end_define

begin_comment
comment|/* ======================================================================== */
end_comment

begin_function
name|local
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
ifdef|#
directive|ifdef
name|LZW
ifdef|#
directive|ifdef
name|NO_DIR
literal|"usage: %s [-cdfhLtvVZ19] [-b maxbits] [file ...]\n"
argument_list|,
else|#
directive|else
literal|"usage: %s [-cdfhLrtvVZ19] [-b maxbits] [file ...]\n"
argument_list|,
endif|#
directive|endif
else|#
directive|else
comment|/* !LZW */
ifdef|#
directive|ifdef
name|NO_DIR
literal|"usage: %s [-cdfhLtvV19] [file ...]\n"
argument_list|,
else|#
directive|else
literal|"usage: %s [-cdfhLrtvV19] [file ...]\n"
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
comment|/* LZW */
name|progname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ======================================================================== */
end_comment

begin_function
name|local
name|void
name|help
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|help_msg
index|[]
init|=
block|{
comment|/* -a --ascii       ascii text; convert end-of-lines to local OS conventions */
literal|" -c --stdout      write on standard output, keep original files unchanged"
block|,
literal|" -d --decompress  decompress"
block|,
comment|/* -e --encrypt     encrypt */
literal|" -f --force       force overwrite of output file and compress links"
block|,
literal|" -h --help        give this help"
block|,
comment|/* -k --pkzip       force output in pkzip format */
comment|/* -l --list        list .z file contents */
literal|" -L --license     display software license"
block|,
literal|" -q --quiet       suppress all warnings"
block|,
ifndef|#
directive|ifndef
name|NO_DIR
literal|" -r --recurse     recurse through directories"
block|,
endif|#
directive|endif
literal|" -t --test        test compressed file integrity"
block|,
literal|" -v --verbose     verbose mode"
block|,
literal|" -V --version     display version number"
block|,
literal|" -1 --fast        compress faster"
block|,
literal|" -9 --best        compress better"
block|,
ifdef|#
directive|ifdef
name|LZW
literal|" -Z --lzw         produce output compatible with old compress"
block|,
literal|" -b --bits maxbits   max number of bits per code (implies -Z)"
block|,
endif|#
directive|endif
literal|" file...          files to (de)compress. If none given, use standard input."
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
init|=
name|help_msg
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s (%s)\n"
argument_list|,
name|progname
argument_list|,
name|VERSION
argument_list|,
name|REVDATE
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ======================================================================== */
end_comment

begin_function
name|local
name|void
name|license
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|p
init|=
name|license_msg
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s (%s)\n"
argument_list|,
name|progname
argument_list|,
name|VERSION
argument_list|,
name|REVDATE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ======================================================================== */
end_comment

begin_function
name|local
name|void
name|version
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s (%s)\n"
argument_list|,
name|progname
argument_list|,
name|VERSION
argument_list|,
name|REVDATE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Compilation options:\n%s %s "
argument_list|,
name|DIR_OPT
argument_list|,
name|TIME_OPT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STDC_HEADERS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"STDC_HEADERS "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"HAVE_UNISTD_H "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_MEMORY_H
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NO_MEMORY_H "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_STRING_H
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NO_STRING_H "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_SYMLINK
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NO_SYMLINK "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NO_MULTIPLE_DOTS "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_CHOWN
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NO_CHOWN "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROTO
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PROTO "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASMV
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ASMV "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DYN_ALLOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DYN_ALLOC "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAXSEG_64K
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MAXSEG_64K"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ======================================================================== */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|file_count
init|=
literal|0
decl_stmt|;
comment|/* number of files to precess */
name|int
name|proglen
decl_stmt|;
comment|/* length of progname */
name|int
name|optc
decl_stmt|;
comment|/* current option */
name|EXPAND
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* wild card expansion if necessary */
name|progname
operator|=
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|proglen
operator|=
name|strlen
argument_list|(
name|progname
argument_list|)
expr_stmt|;
comment|/* Suppress .exe for MSDOS, OS/2 and VMS: */
if|if
condition|(
name|proglen
operator|>
literal|4
operator|&&
name|strequ
argument_list|(
name|progname
operator|+
name|proglen
operator|-
literal|4
argument_list|,
literal|".exe"
argument_list|)
condition|)
block|{
name|progname
index|[
name|proglen
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Add options in GZIP environment variable if there is one */
name|env
operator|=
name|add_envopt
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
name|OPTIONS_VAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
name|args
operator|=
name|argv
expr_stmt|;
name|foreground
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
expr_stmt|;
if|if
condition|(
name|foreground
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
operator|(
name|sig_type
operator|)
name|abort_gzip
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGTERM
name|signal
argument_list|(
name|SIGTERM
argument_list|,
operator|(
name|sig_type
operator|)
name|abort_gzip
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|signal
argument_list|(
name|SIGHUP
argument_list|,
operator|(
name|sig_type
operator|)
name|abort_gzip
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|GNU_STANDARD
comment|/* For compatibility with old compress, use program name as an option.      * If you compile with -DGNU_STANDARD, this program will behave as      * gzip even if it is invoked under the name gunzip or zcat.      *      * Systems which do not support links can still use -d or -dc.      * Ignore an .exe extension for MSDOS, OS/2 and VMS.      */
if|if
condition|(
name|strncmp
argument_list|(
name|progname
argument_list|,
literal|"un"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
comment|/* ungzip, uncompress */
operator|||
name|strncmp
argument_list|(
name|progname
argument_list|,
literal|"gun"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* gunzip */
name|decompress
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strequ
argument_list|(
name|progname
operator|+
literal|1
argument_list|,
literal|"cat"
argument_list|)
comment|/* zcat, pcat */
operator|||
name|strequ
argument_list|(
name|progname
argument_list|,
literal|"gzcat"
argument_list|)
condition|)
block|{
comment|/* gzcat */
name|decompress
operator|=
name|to_stdout
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:cdfhLqrtvVZ123456789"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'b'
case|:
name|maxbits
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|to_stdout
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|decompress
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|help
argument_list|()
expr_stmt|;
name|do_exit
argument_list|(
name|OK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|license
argument_list|()
expr_stmt|;
name|do_exit
argument_list|(
name|OK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
name|verbose
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
ifdef|#
directive|ifdef
name|NO_DIR
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -r not supported on this system\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|recursive
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'t'
case|:
name|test
operator|=
name|decompress
operator|=
name|to_stdout
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
name|quiet
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|version
argument_list|()
expr_stmt|;
name|quit_on_tty
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
ifdef|#
directive|ifdef
name|LZW
name|do_lzw
operator|=
literal|1
expr_stmt|;
break|break;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -Z not supported in this version\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|level
operator|=
name|optc
operator|-
literal|'0'
expr_stmt|;
break|break;
default|default:
comment|/* Error message already emitted by getopt_long. */
name|usage
argument_list|()
expr_stmt|;
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* loop on all arguments */
name|file_count
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
if|if
condition|(
name|do_lzw
operator|&&
operator|!
name|decompress
condition|)
name|work
operator|=
name|lzw
expr_stmt|;
comment|/* Allocate all global buffers (for DYN_ALLOC option) */
name|ALLOC
argument_list|(
name|uch
argument_list|,
name|inbuf
argument_list|,
name|INBUFSIZ
operator|+
name|INBUF_EXTRA
argument_list|)
expr_stmt|;
name|ALLOC
argument_list|(
name|uch
argument_list|,
name|outbuf
argument_list|,
name|OUTBUFSIZ
operator|+
name|OUTBUF_EXTRA
argument_list|)
expr_stmt|;
name|ALLOC
argument_list|(
name|ush
argument_list|,
name|d_buf
argument_list|,
name|DIST_BUFSIZE
argument_list|)
expr_stmt|;
name|ALLOC
argument_list|(
name|uch
argument_list|,
name|window
argument_list|,
literal|2L
operator|*
name|WSIZE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAXSEG_64K
name|ALLOC
argument_list|(
name|ush
argument_list|,
name|tab_prefix
argument_list|,
literal|1L
operator|<<
name|BITS
argument_list|)
expr_stmt|;
else|#
directive|else
name|ALLOC
argument_list|(
name|ush
argument_list|,
name|tab_prefix0
argument_list|,
literal|1L
operator|<<
operator|(
name|BITS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ALLOC
argument_list|(
name|ush
argument_list|,
name|tab_prefix1
argument_list|,
literal|1L
operator|<<
operator|(
name|BITS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* And get to work */
if|if
condition|(
name|file_count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|to_stdout
operator|&&
operator|!
name|test
condition|)
block|{
name|SET_BINARY_MODE
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|treat_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Standard input */
name|treat_stdin
argument_list|()
expr_stmt|;
block|}
name|do_exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
return|return
name|exit_code
return|;
comment|/* just to avoid lint warning */
block|}
end_function

begin_comment
comment|/* ========================================================================  * Compress or decompress stdin  */
end_comment

begin_function
name|local
name|void
name|treat_stdin
parameter_list|()
block|{
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|decompress
condition|?
name|stdin
else|:
name|stdout
operator|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Do not send compressed data to the terminal or read it from 	 * the terminal. We get here when user invoked the program 	 * without parameters, so be helpful. However, on systems supporting          * pseudo ttys, let the beginner stare at the 'hung' program 	 * (explicity request from Noah Friedman). Don't give an error message 	 * if the user only wanted the version number (gzip -V). 	 */
if|if
condition|(
name|quit_on_tty
condition|)
name|do_exit
argument_list|(
name|OK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_PTY
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: compressed data not %s a terminal. Redirect %s file or pipe.\n"
argument_list|,
name|progname
argument_list|,
name|decompress
condition|?
literal|"read from"
else|:
literal|"written to"
argument_list|,
name|decompress
condition|?
literal|"from"
else|:
literal|"to"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"For help, type: %s -h\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|SET_BINARY_MODE
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
condition|)
name|SET_BINARY_MODE
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ifname
argument_list|,
literal|"stdin"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ofname
argument_list|,
literal|"stdout"
argument_list|)
expr_stmt|;
comment|/* Get the time stamp on the input file */
ifdef|#
directive|ifdef
name|NO_STDIN_FSTAT
name|time_stamp
operator|=
literal|0
expr_stmt|;
comment|/* time unknown */
else|#
directive|else
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|istat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"fstat(stdin)"
argument_list|)
expr_stmt|;
block|}
name|time_stamp
operator|=
name|istat
operator|.
name|st_mtime
expr_stmt|;
endif|#
directive|endif
name|ifile_size
operator|=
operator|-
literal|1L
expr_stmt|;
comment|/* convention for unknown size */
name|clear_bufs
argument_list|()
expr_stmt|;
comment|/* clear input and output buffers */
name|to_stdout
operator|=
literal|1
expr_stmt|;
name|part_nb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|method
operator|=
name|get_method
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|<
literal|0
condition|)
block|{
name|do_exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
comment|/* error message already emitted */
block|}
block|}
comment|/* Actually do the compression/decompression. Loop over zipped members.      */
for|for
control|(
init|;
condition|;
control|)
block|{
call|(
modifier|*
name|work
call|)
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decompress
operator|||
name|last_member
operator|||
name|inptr
operator|==
name|insize
condition|)
break|break;
comment|/* end of file */
name|method
operator|=
name|get_method
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* error message already emitted */
name|bytes_out
operator|=
literal|0
expr_stmt|;
comment|/* required for length check */
block|}
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|test
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" OK"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|decompress
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Compression: "
argument_list|)
expr_stmt|;
name|display_ratio
argument_list|(
name|bytes_in
operator|-
name|bytes_out
operator|-
name|overhead
argument_list|,
name|bytes_in
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ========================================================================  * Compress or decompress the given file  */
end_comment

begin_function
name|local
name|void
name|treat_file
parameter_list|(
name|iname
parameter_list|)
name|char
modifier|*
name|iname
decl_stmt|;
block|{
comment|/* Check if the input file is present, set ifname and istat: */
if|if
condition|(
name|get_istat
argument_list|(
name|iname
argument_list|,
operator|&
name|istat
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* If the input name is that of a directory, recurse or ignore: */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|istat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_DIR
if|if
condition|(
name|recursive
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|st
operator|=
name|istat
expr_stmt|;
name|treat_dir
argument_list|(
name|iname
argument_list|)
expr_stmt|;
comment|/* Warning: ifname is now garbage */
name|reset_times
argument_list|(
name|iname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s is a directory -- ignored\n"
operator|,
name|progname
operator|,
name|ifname
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|istat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s is not a directory or a regular file - ignored\n"
operator|,
name|progname
operator|,
name|ifname
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|istat
operator|.
name|st_nlink
operator|>
literal|1
operator|&&
operator|!
name|to_stdout
operator|&&
operator|!
name|force
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s has %d other link%c -- unchanged\n"
operator|,
name|progname
operator|,
name|ifname
operator|,
operator|(
name|int
operator|)
name|istat
operator|.
name|st_nlink
operator|-
literal|1
operator|,
name|istat
operator|.
name|st_nlink
operator|>
literal|2
condition|?
literal|'s'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifile_size
operator|=
name|istat
operator|.
name|st_size
expr_stmt|;
name|time_stamp
operator|=
name|istat
operator|.
name|st_mtime
expr_stmt|;
comment|/* Generate output file name */
if|if
condition|(
name|to_stdout
condition|)
block|{
name|strcpy
argument_list|(
name|ofname
argument_list|,
literal|"stdout"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|make_ofname
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
comment|/* Open the input file and determine compression method. The mode      * parameter is ignored but required by some systems (VMS).      */
name|ifd
operator|=
name|open
argument_list|(
name|ifname
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
name|RW_USER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifd
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return;
block|}
name|clear_bufs
argument_list|()
expr_stmt|;
comment|/* clear input and output buffers */
name|part_nb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|method
operator|=
name|get_method
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
comment|/* updates ofname if original given */
if|if
condition|(
name|method
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
return|return;
comment|/* error message already emitted */
block|}
block|}
comment|/* If compressing to a file, check if ofname is not ambiguous      * because the operating system truncates names. Otherwise, generate      * a new ofname and save the original name in the compressed file.      */
if|if
condition|(
name|to_stdout
condition|)
block|{
name|ofd
operator|=
name|fileno
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* keep remove_ofname as zero */
block|}
else|else
block|{
if|if
condition|(
name|create_outfile
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|save_orig_name
operator|&&
operator|!
name|verbose
operator|&&
operator|!
name|quiet
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s compressed to %s\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:\t%s"
argument_list|,
name|ifname
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|ifname
argument_list|)
operator|>=
literal|15
condition|?
literal|""
else|:
operator|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|ifname
argument_list|)
operator|>=
literal|7
condition|?
literal|"\t"
else|:
literal|"\t\t"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Actually do the compression/decompression. Loop over zipped members.      */
for|for
control|(
init|;
condition|;
control|)
block|{
call|(
modifier|*
name|work
call|)
argument_list|(
name|ifd
argument_list|,
name|ofd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decompress
operator|||
name|last_member
operator|||
name|inptr
operator|==
name|insize
condition|)
break|break;
comment|/* end of file */
name|method
operator|=
name|get_method
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|<
literal|0
condition|)
break|break;
comment|/* error message already emitted */
name|bytes_out
operator|=
literal|0
expr_stmt|;
comment|/* required for length check */
block|}
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|to_stdout
operator|&&
name|close
argument_list|(
name|ofd
argument_list|)
condition|)
block|{
name|write_error
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|method
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* error, don't display success msg */
comment|/* Display statistics */
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
operator|!
name|decompress
condition|)
block|{
name|display_ratio
argument_list|(
name|bytes_in
operator|-
name|bytes_out
operator|-
name|overhead
argument_list|,
name|bytes_in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|test
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" OK"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|to_stdout
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- replaced with %s"
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Copy modes, times, ownership */
if|if
condition|(
operator|!
name|to_stdout
condition|)
block|{
name|copy_stat
argument_list|(
operator|&
name|istat
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ========================================================================  * Create the output file. Return 0 for success, -1 for error.  * Try twice if ofname is exactly one beyond the name limit, to avoid  * creating a compressed file of name "1234567890123."  * We could actually loop more than once if the user gives an extra long  * name, but I prefer generating an error then. (Posix forbids the system  * to truncate names.) The error message is generated by check_ofname()  * in this case.  * IN assertions: the input file has already been open (ifd is set) and  *   ofname has already been updated if there was an original name.  * OUT assertions: ifd and ofd are closed in case of error.  */
end_comment

begin_function
name|local
name|int
name|create_outfile
parameter_list|()
block|{
name|struct
name|stat
name|ostat
decl_stmt|;
comment|/* stat for ofname */
name|int
name|n
decl_stmt|;
comment|/* loop counter */
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<=
literal|2
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|check_ofname
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Create the output file */
name|remove_ofname
operator|=
literal|1
expr_stmt|;
name|ofd
operator|=
name|open
argument_list|(
name|ofname
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
operator||
name|O_BINARY
argument_list|,
name|RW_USER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofd
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check for name truncation on new file (1234567890123.z) */
if|if
condition|(
name|fstat
argument_list|(
name|ofd
argument_list|,
operator|&
name|ostat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|name_too_long
argument_list|(
name|ofname
argument_list|,
operator|&
name|ostat
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|decompress
condition|)
block|{
comment|/* name might be too long if an original name was saved */
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s: warning, name truncated\n"
operator|,
name|progname
operator|,
name|ofname
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
comment|/* Should never happen, see check_ofname() */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: name too long\n"
argument_list|,
name|progname
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
else|#
directive|else
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|save_orig_name
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|ofname
operator|+
name|strlen
argument_list|(
name|ofname
argument_list|)
operator|-
name|Z_LEN
operator|-
literal|1
argument_list|,
name|Z_SUFFIX
argument_list|)
expr_stmt|;
comment|/* 1234567890123.z -> 123456789012.z */
endif|#
directive|endif
block|}
comment|/* decompress ? */
block|}
comment|/* for (n) */
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: name too long\n"
argument_list|,
name|progname
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Use lstat if available, except for -c or -f. Use stat otherwise.  * This allows links when not removing the original file.  */
end_comment

begin_function
name|local
name|int
name|do_stat
parameter_list|(
name|name
parameter_list|,
name|sbuf
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|stat
modifier|*
name|sbuf
decl_stmt|;
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|S_IFLNK
argument_list|)
operator|||
name|defined
argument_list|(
name|S_ISLNK
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_SYMLINK
argument_list|)
if|if
condition|(
operator|!
name|to_stdout
operator|&&
operator|!
name|force
condition|)
block|{
return|return
name|lstat
argument_list|(
name|name
argument_list|,
name|sbuf
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
name|stat
argument_list|(
name|name
argument_list|,
name|sbuf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Return a pointer to the 'z' suffix of a file name, or NULL.  * For all systems, ".z", ".Z", ".taz", ".tgz", "-z" are accepted suffixes.  * ".tgz" is a useful convention for tar.z files on systems limited  * to 3 characters extensions. On such systems, ".?z" and ".??z" are  * also accepted suffixes. For Unix, we do not want to accept any  * .??z suffix as indicating a compressed file; some people use .xyz  * to denote volume data.  */
end_comment

begin_function
name|local
name|char
modifier|*
name|get_suffix
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|char
name|suffix
index|[
literal|10
index|]
decl_stmt|;
comment|/* last few chars of name, forced to lower case */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|==
name|name
operator|||
name|strchr
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|PATH_SEP
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|NULL
return|;
name|strncpy
argument_list|(
name|suffix
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|suffix
argument_list|)
argument_list|)
expr_stmt|;
name|suffix
index|[
sizeof|sizeof
argument_list|(
name|suffix
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Force null termination */
ifdef|#
directive|ifdef
name|SUFFIX_SEP
comment|/* strip a version number from the file name */
block|{
name|char
modifier|*
name|v
init|=
name|strrchr
argument_list|(
name|suffix
argument_list|,
name|SUFFIX_SEP
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
operator|*
name|v
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|strlwr
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strequ
argument_list|(
name|suffix
argument_list|,
literal|".z"
argument_list|)
operator|||
name|strequ
argument_list|(
name|suffix
argument_list|,
literal|".zip"
argument_list|)
operator|||
name|strequ
argument_list|(
name|suffix
argument_list|,
literal|".tgz"
argument_list|)
operator|||
name|strequ
argument_list|(
name|suffix
argument_list|,
literal|".taz"
argument_list|)
condition|)
block|{
return|return
name|p
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|2
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|strequ
argument_list|(
name|suffix
operator|+
name|len
operator|-
literal|2
argument_list|,
literal|"-z"
argument_list|)
condition|)
return|return
name|p
operator|+
name|len
operator|-
literal|2
return|;
ifdef|#
directive|ifdef
name|MAX_EXT_CHARS
if|if
condition|(
name|suffix
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'z'
condition|)
return|return
name|p
operator|+
name|len
operator|-
literal|1
return|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Set ifname to the input file name (with .z appended if necessary)  * and istat to its stats. Return 0 if ok, -1 if error.  */
end_comment

begin_function
name|local
name|int
name|get_istat
parameter_list|(
name|iname
parameter_list|,
name|sbuf
parameter_list|)
name|char
modifier|*
name|iname
decl_stmt|;
name|struct
name|stat
modifier|*
name|sbuf
decl_stmt|;
block|{
name|int
name|iexists
decl_stmt|;
comment|/* set if iname exists */
name|int
name|ilen
init|=
name|strlen
argument_list|(
name|iname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|suff
decl_stmt|;
name|strcpy
argument_list|(
name|ifname
argument_list|,
name|iname
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* If input file exists, return OK. */
if|if
condition|(
name|do_stat
argument_list|(
name|ifname
argument_list|,
name|sbuf
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|decompress
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* file.ext doesn't exist, try file.ext.z and file.ext.Z. For MSDOS      * try file.exz, for VMS try file.ext-z.      */
name|suff
operator|=
name|get_suffix
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|suff
operator|!=
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
comment|/* ifname already has z suffix and does not exist */
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|SUFFIX_SEP
comment|/* strip a version number from the input file name */
if|if
condition|(
operator|(
name|suff
operator|=
name|strrchr
argument_list|(
name|ifname
argument_list|,
name|SUFFIX_SEP
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|suff
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strrchr
argument_list|(
name|ifname
argument_list|,
literal|'.'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|ifname
argument_list|,
name|Z_SUFFIX
argument_list|)
expr_stmt|;
name|ilen
operator|+=
name|Z_LEN
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|ifname
argument_list|,
literal|".z"
argument_list|)
expr_stmt|;
name|ilen
operator|+=
literal|2
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|iexists
operator|=
operator|!
name|do_stat
argument_list|(
name|ifname
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iexists
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ifname
index|[
name|ilen
operator|-
literal|1
index|]
operator|=
literal|'Z'
expr_stmt|;
name|iexists
operator|=
operator|!
name|do_stat
argument_list|(
name|ifname
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
comment|/* One more try just to be nice to you */
if|if
condition|(
operator|!
name|iexists
condition|)
block|{
name|char
name|c
init|=
name|ifname
index|[
name|ilen
operator|-
literal|2
index|]
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|ifname
operator|+
name|ilen
operator|-
literal|2
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
name|iexists
operator|=
operator|!
name|do_stat
argument_list|(
name|ifname
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iexists
condition|)
block|{
name|ifname
index|[
name|ilen
operator|-
literal|2
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|iexists
condition|)
block|{
name|ifname
index|[
name|ilen
operator|-
literal|1
index|]
operator|=
literal|'z'
expr_stmt|;
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sbuf
operator|->
name|st_mode
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s: not a regular file -- ignored\n"
operator|,
name|progname
operator|,
name|ifname
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
comment|/* ok */
block|}
end_function

begin_comment
comment|/* ========================================================================  * Generate ofname given ifname. Return 0 if ok, -1 if file must be skipped.  * Initializes save_orig_name.  * IN assertion: this function is not called if to_stdout is true.  */
end_comment

begin_function
name|local
name|int
name|make_ofname
parameter_list|()
block|{
name|char
modifier|*
name|suff
decl_stmt|;
comment|/* ofname z suffix */
name|strcpy
argument_list|(
name|ofname
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|suff
operator|=
name|get_suffix
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
if|if
condition|(
name|suff
operator|==
name|NULL
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s: no z suffix -- ignored\n"
operator|,
name|progname
operator|,
name|ifname
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make a special case for .tgz and .taz: */
name|strlwr
argument_list|(
name|suff
argument_list|)
expr_stmt|;
if|if
condition|(
name|strequ
argument_list|(
name|suff
argument_list|,
literal|".tgz"
argument_list|)
operator|||
name|strequ
argument_list|(
name|suff
argument_list|,
literal|".taz"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|suff
argument_list|,
literal|".tar"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|suff
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip z suffix and optional version number */
block|}
comment|/* ofname might be changed later if infile contains an original name */
block|}
elseif|else
if|if
condition|(
name|suff
operator|!=
name|NULL
condition|)
block|{
comment|/* Avoid annoying messages with -r (see treat_dir()) */
if|if
condition|(
name|verbose
operator|||
operator|(
operator|!
name|recursive
operator|&&
operator|!
name|quiet
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s already has %s suffix -- unchanged\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|suff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_code
operator|==
name|OK
condition|)
name|exit_code
operator|=
name|WARNING
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|save_orig_name
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUFFIX_SEP
comment|/* strip a version number from the file name */
if|if
condition|(
operator|(
name|suff
operator|=
name|strrchr
argument_list|(
name|ofname
argument_list|,
name|SUFFIX_SEP
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|suff
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
name|suff
operator|=
name|strrchr
argument_list|(
name|ofname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|suff
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|MAX_EXT_CHARS
comment|/* On the Atari and some versions of MSDOS, name_too_long() 	     * does not work correctly because of a bug in stat(). So we 	     * must truncate here. 	     */
if|if
condition|(
name|strlen
argument_list|(
name|suff
argument_list|)
operator|>
name|MAX_EXT_CHARS
condition|)
block|{
name|strcpy
argument_list|(
name|suff
operator|+
name|MAX_EXT_CHARS
argument_list|,
name|do_lzw
condition|?
literal|"Z"
else|:
literal|"z"
argument_list|)
expr_stmt|;
name|save_orig_name
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|strcat
argument_list|(
name|ofname
argument_list|,
name|Z_SUFFIX
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
name|strcat
argument_list|(
name|ofname
argument_list|,
name|do_lzw
condition|?
literal|".Z"
else|:
literal|".z"
argument_list|)
expr_stmt|;
block|}
comment|/* decompress ? */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Check the magic number of the input file and update ofname if an  * original name was given and to_stdout is not set.  * Return the compression method, -1 for error, -2 for warning.  * Set inptr to the offset of the next byte to be processed.  * This function may be called repeatedly for an input file consisting  * of several contiguous gzip'ed members.  * IN assertions: there is at least one remaining compressed member.  *   If the member is a zip file, it must be the only one.  */
end_comment

begin_function
name|local
name|int
name|get_method
parameter_list|(
name|in
parameter_list|)
name|int
name|in
decl_stmt|;
comment|/* input file descriptor */
block|{
name|uch
name|flags
decl_stmt|;
name|char
name|magic
index|[
literal|2
index|]
decl_stmt|;
comment|/* magic header */
name|magic
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|get_byte
argument_list|()
expr_stmt|;
name|magic
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|get_byte
argument_list|()
expr_stmt|;
name|time_stamp
operator|=
name|istat
operator|.
name|st_mtime
expr_stmt|;
comment|/* may be modified later for some methods */
name|method
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown yet */
name|part_nb
operator|++
expr_stmt|;
comment|/* number of parts in gzip file */
name|last_member
operator|=
name|RECORD_IO
expr_stmt|;
comment|/* assume multiple members in gzip file except for record oriented I/O */
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|GZIP_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|memcmp
argument_list|(
name|magic
argument_list|,
name|OLD_GZIP_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|=
name|unzip
expr_stmt|;
name|method
operator|=
operator|(
name|int
operator|)
name|get_byte
argument_list|()
expr_stmt|;
name|flags
operator|=
operator|(
name|uch
operator|)
name|get_byte
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ENCRYPTED
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is encrypted -- get newer version of gzip\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|CONTINUATION
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is a a multi-part gzip file -- get newer version of gzip\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
if|if
condition|(
name|force
operator|<=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|RESERVED
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s has flags 0x%x -- get newer version of gzip\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
if|if
condition|(
name|force
operator|<=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|time_stamp
operator|=
operator|(
name|ulg
operator|)
name|get_byte
argument_list|()
expr_stmt|;
name|time_stamp
operator||=
operator|(
operator|(
name|ulg
operator|)
name|get_byte
argument_list|()
operator|)
operator|<<
literal|8
expr_stmt|;
name|time_stamp
operator||=
operator|(
operator|(
name|ulg
operator|)
name|get_byte
argument_list|()
operator|)
operator|<<
literal|16
expr_stmt|;
name|time_stamp
operator||=
operator|(
operator|(
name|ulg
operator|)
name|get_byte
argument_list|()
operator|)
operator|<<
literal|24
expr_stmt|;
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
comment|/* Ignore extra flags for the moment */
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
comment|/* Ignore OS type for the moment */
if|if
condition|(
operator|(
name|flags
operator|&
name|CONTINUATION
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|part
init|=
operator|(
name|unsigned
operator|)
name|get_byte
argument_list|()
decl_stmt|;
name|part
operator||=
operator|(
operator|(
name|unsigned
operator|)
name|get_byte
argument_list|()
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: part number %u\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|part
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|EXTRA_FIELD
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|len
init|=
operator|(
name|unsigned
operator|)
name|get_byte
argument_list|()
decl_stmt|;
name|len
operator||=
operator|(
operator|(
name|unsigned
operator|)
name|get_byte
argument_list|()
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: extra field of %u bytes ignored\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|--
condition|)
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
block|}
comment|/* Get original file name if it was truncated */
if|if
condition|(
operator|(
name|flags
operator|&
name|ORIG_NAME
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|to_stdout
operator|||
name|part_nb
operator|>
literal|1
condition|)
block|{
comment|/* Discard the old name */
while|while
condition|(
name|get_byte
argument_list|()
operator|!=
literal|0
condition|)
comment|/* null */
empty_stmt|;
block|}
else|else
block|{
comment|/* Copy the base name. Keep a directory prefix intact. */
name|char
modifier|*
name|p
init|=
name|basename
argument_list|(
name|ofname
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|get_byte
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|p
operator|>=
name|ofname
operator|+
sizeof|sizeof
argument_list|(
name|ofname
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"corrupted input -- file name too large"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* to_stdout */
block|}
comment|/* orig_name */
comment|/* Discard file comment if any */
if|if
condition|(
operator|(
name|flags
operator|&
name|COMMENT
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|get_byte
argument_list|()
operator|!=
literal|0
condition|)
comment|/* null */
empty_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|PKZIP_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|inptr
operator|==
literal|2
operator|&&
name|memcmp
argument_list|(
name|inbuf
argument_list|,
name|PKZIP_MAGIC
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* To simplify the code, we support a zip file when alone only.          * We are thus guaranteed that the entire local header fits in inbuf.          */
name|inptr
operator|=
literal|0
expr_stmt|;
name|work
operator|=
name|unzip
expr_stmt|;
if|if
condition|(
name|check_zipfile
argument_list|(
name|in
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* check_zipfile may get ofname from the local header */
name|last_member
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|PACK_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|=
name|unpack
expr_stmt|;
name|method
operator|=
name|PACKED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|LZW_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|=
name|unlzw
expr_stmt|;
name|method
operator|=
name|COMPRESSED
expr_stmt|;
name|last_member
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|method
operator|>=
literal|0
condition|)
return|return
name|method
return|;
if|if
condition|(
name|part_nb
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is not in gzip format\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s: trailing garbage ignored\n"
operator|,
name|progname
operator|,
name|ifname
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
end_function

begin_comment
comment|/* ========================================================================  * Return true if the two stat structures correspond to the same file.  */
end_comment

begin_function
name|local
name|int
name|same_file
parameter_list|(
name|stat1
parameter_list|,
name|stat2
parameter_list|)
name|struct
name|stat
modifier|*
name|stat1
decl_stmt|;
name|struct
name|stat
modifier|*
name|stat2
decl_stmt|;
block|{
return|return
name|stat1
operator|->
name|st_mode
operator|==
name|stat2
operator|->
name|st_mode
operator|&&
name|stat1
operator|->
name|st_ino
operator|==
name|stat2
operator|->
name|st_ino
operator|&&
name|stat1
operator|->
name|st_dev
operator|==
name|stat2
operator|->
name|st_dev
operator|&&
name|stat1
operator|->
name|st_uid
operator|==
name|stat2
operator|->
name|st_uid
operator|&&
name|stat1
operator|->
name|st_gid
operator|==
name|stat2
operator|->
name|st_gid
operator|&&
name|stat1
operator|->
name|st_size
operator|==
name|stat2
operator|->
name|st_size
operator|&&
name|stat1
operator|->
name|st_atime
operator|==
name|stat2
operator|->
name|st_atime
operator|&&
name|stat1
operator|->
name|st_mtime
operator|==
name|stat2
operator|->
name|st_mtime
operator|&&
name|stat1
operator|->
name|st_ctime
operator|==
name|stat2
operator|->
name|st_ctime
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Return true if a file name is ambiguous because the operating system  * truncates file names.  */
end_comment

begin_function
name|local
name|int
name|name_too_long
parameter_list|(
name|name
parameter_list|,
name|statb
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* file name to check */
name|struct
name|stat
modifier|*
name|statb
decl_stmt|;
comment|/* stat buf for this file name */
block|{
name|int
name|s
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
name|c
init|=
name|name
index|[
name|s
operator|-
literal|1
index|]
decl_stmt|;
name|struct
name|stat
name|tstat
decl_stmt|;
comment|/* stat for truncated name */
name|int
name|res
decl_stmt|;
name|tstat
operator|=
operator|*
name|statb
expr_stmt|;
comment|/* Just in case OS does not fill all fields */
name|name
index|[
name|s
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|res
operator|=
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|tstat
argument_list|)
operator|==
literal|0
operator|&&
name|same_file
argument_list|(
name|statb
argument_list|,
operator|&
name|tstat
argument_list|)
expr_stmt|;
name|name
index|[
name|s
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * If compressing to a file, check if ofname is not ambigous  * because the operating system truncates names. Otherwise, generate  * a new ofname and save the original name in the compressed file.  * If the compressed file already exists, ask for confirmation.  *    The check for name truncation is made dynamically, because different  * file systems on the same OS might use different truncation rules (on SVR4  * s5 truncates to 14 chars and ufs does not truncate).  *    This function returns -1 if the file must be skipped, and  * updates save_orig_name if necessary.  * IN assertions: save_orig_name is already set if ofname has been  * already truncated because of NO_MULTIPLE_DOTS. The input file has  * already been open and istat is set.  */
end_comment

begin_function
name|local
name|int
name|check_ofname
parameter_list|()
block|{
name|int
name|s
init|=
name|strlen
argument_list|(
name|ofname
argument_list|)
decl_stmt|;
name|struct
name|stat
name|ostat
decl_stmt|;
comment|/* stat for ofname */
if|if
condition|(
name|stat
argument_list|(
name|ofname
argument_list|,
operator|&
name|ostat
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Check for name truncation on existing file: */
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
if|if
condition|(
operator|!
name|decompress
operator|&&
name|name_too_long
argument_list|(
name|ofname
argument_list|,
operator|&
name|ostat
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|!
name|decompress
operator|&&
name|s
operator|>
literal|8
operator|&&
name|name_too_long
argument_list|(
name|ofname
argument_list|,
operator|&
name|ostat
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|save_orig_name
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
name|strcpy
argument_list|(
name|ofname
operator|+
name|s
operator|-
name|Z_LEN
operator|-
literal|1
argument_list|,
name|Z_SUFFIX
argument_list|)
expr_stmt|;
comment|/* f.extz -> f.exz  */
else|#
directive|else
name|strcpy
argument_list|(
name|ofname
operator|+
name|s
operator|-
literal|4
argument_list|,
literal|".z"
argument_list|)
expr_stmt|;
comment|/* 12345678901234.z -> 123456789012.z */
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|ofname
argument_list|,
operator|&
name|ostat
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* !decompress&& name_too_long */
comment|/* Check that the input and output files are different (could be      * the same by name truncation or links).      */
if|if
condition|(
name|same_file
argument_list|(
operator|&
name|istat
argument_list|,
operator|&
name|ostat
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s and %s are the same file\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Ask permission to overwrite the existing file */
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|char
name|response
index|[
literal|80
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|response
argument_list|,
literal|"n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s already exists;"
argument_list|,
name|progname
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
if|if
condition|(
name|foreground
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" do you wish to overwrite (y or n)? "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|response
argument_list|,
sizeof|sizeof
argument_list|(
name|response
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tolow
argument_list|(
operator|*
name|response
argument_list|)
operator|!=
literal|'y'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tnot overwritten\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_code
operator|==
name|OK
condition|)
name|exit_code
operator|=
name|WARNING
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|ofname
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|ofname
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* ========================================================================  * Set the access and modification times from the given stat buffer.  */
name|local
name|void
name|reset_times
parameter_list|(
name|name
parameter_list|,
name|statb
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|stat
modifier|*
name|statb
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|NO_UTIME
name|struct
name|utimbuf
name|timep
decl_stmt|;
comment|/* Copy the time stamp */
name|timep
operator|.
name|actime
operator|=
name|statb
operator|->
name|st_atime
expr_stmt|;
name|timep
operator|.
name|modtime
operator|=
name|statb
operator|->
name|st_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|name
argument_list|,
operator|&
name|timep
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: "
operator|,
name|progname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|name
operator|=
name|name
expr_stmt|;
name|statb
operator|=
name|statb
expr_stmt|;
comment|/* avoid warnings */
endif|#
directive|endif
block|}
comment|/* ========================================================================  * Copy modes, times, ownership from input file to output file.  * IN assertion: to_stdout is false.  */
name|local
name|void
name|copy_stat
parameter_list|(
name|ifstat
parameter_list|)
name|struct
name|stat
modifier|*
name|ifstat
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|NO_UTIME
name|time_t
name|diff
init|=
name|ifstat
operator|->
name|st_mtime
operator|-
name|time_stamp
decl_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|=
operator|-
name|diff
expr_stmt|;
if|if
condition|(
name|decompress
operator|&&
name|diff
operator|>
literal|60
operator|&&
name|time_stamp
operator|!=
literal|0
condition|)
block|{
name|ifstat
operator|->
name|st_mtime
operator|=
name|time_stamp
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: time stamp restored\n"
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
block|}
block|}
name|reset_times
argument_list|(
name|ofname
argument_list|,
name|ifstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Copy the protection modes */
if|if
condition|(
name|chmod
argument_list|(
name|ofname
argument_list|,
name|ifstat
operator|->
name|st_mode
operator|&
literal|07777
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: "
operator|,
name|progname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_CHOWN
name|chown
argument_list|(
name|ofname
argument_list|,
name|ifstat
operator|->
name|st_uid
argument_list|,
name|ifstat
operator|->
name|st_gid
argument_list|)
expr_stmt|;
comment|/* Copy ownership */
endif|#
directive|endif
name|remove_ofname
operator|=
literal|0
expr_stmt|;
comment|/* It's now safe to remove the input file: */
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|ifname
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|ifname
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: "
operator|,
name|progname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|NO_DIR
comment|/* ========================================================================  * Recurse through the given directory. This code is taken from ncompress.  */
name|local
name|void
name|treat_dir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|dir_type
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|char
name|nbuf
index|[
name|MAX_PATH_LEN
index|]
decl_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s unreadable\n"
argument_list|,
name|progname
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return ;
block|}
comment|/*      ** WARNING: the following algorithm could occasionally cause      ** compress to produce error warnings of the form "<filename>.z      ** already has .z suffix - ignored". This occurs when the      ** .z output file is inserted into the directory below      ** readdir's current pointer.      ** These warnings are harmless but annoying, so they are suppressed      ** with option -r (except when -v is on). An alternative      ** to allowing this would be to store the entire directory      ** list in memory, then compress the entries in the stored      ** list. Given the depth-first recursive algorithm used here,      ** this could use up a tremendous amount of memory. I don't      ** think it's worth it. -- Dave Mack      ** (An other alternative might be two passes to avoid depth-first.)      */
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strequ
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|||
name|strequ
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|NLENGTH
argument_list|(
name|dp
argument_list|)
operator|+
literal|1
operator|)
operator|<
operator|(
name|MAX_PATH_LEN
operator|-
literal|1
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* dir = "" means current dir on Amiga */
ifdef|#
directive|ifdef
name|OTHER_PATH_SEP
if|if
condition|(
name|dir
index|[
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
index|]
operator|!=
name|OTHER_PATH_SEP
condition|)
endif|#
directive|endif
name|strcat
argument_list|(
name|nbuf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|nbuf
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|treat_file
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s/%s: pathname too long\n"
argument_list|,
name|progname
argument_list|,
name|dir
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ? NO_DIR */
comment|/* ========================================================================  * Free all dynamically allocated variables and exit with the given code.  */
name|local
name|void
name|do_exit
parameter_list|(
name|exitcode
parameter_list|)
name|int
name|exitcode
decl_stmt|;
block|{
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|env
argument_list|)
operator|,
name|env
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|args
argument_list|)
operator|,
name|args
operator|=
name|NULL
expr_stmt|;
name|FREE
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|d_buf
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|window
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAXSEG_64K
name|FREE
argument_list|(
name|tab_prefix
argument_list|)
expr_stmt|;
else|#
directive|else
name|FREE
argument_list|(
name|tab_prefix0
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|tab_prefix1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
block|}
comment|/* ========================================================================  * Signal and error handler.  */
name|RETSIGTYPE
name|abort_gzip
parameter_list|()
block|{
if|if
condition|(
name|remove_ofname
condition|)
block|{
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
block|}
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

