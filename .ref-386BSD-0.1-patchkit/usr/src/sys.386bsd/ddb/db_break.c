begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1991,1990 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * HISTORY  * $Log: db_break.c,v $  * Revision 1.1  1992/03/25  21:44:57  pace  * Initial revision  *  * Revision 2.7  91/02/05  17:06:00  mrt  * 	Changed to new Mach copyright  * 	[91/01/31  16:17:01  mrt]  *   * Revision 2.6  91/01/08  15:09:03  rpd  * 	Added db_map_equal, db_map_current, db_map_addr.  * 	[90/11/10            rpd]  *   * Revision 2.5  90/11/05  14:26:32  rpd  * 	Initialize db_breakpoints_inserted to TRUE.  * 	[90/11/04            rpd]  *   * Revision 2.4  90/10/25  14:43:33  rwd  * 	Added map field to breakpoints.  * 	Added map argument to db_set_breakpoint, db_delete_breakpoint,  * 	db_find_breakpoint.  Added db_find_breakpoint_here.  * 	[90/10/18            rpd]  *   * Revision 2.3  90/09/28  16:57:07  jsb  * 	Fixed db_breakpoint_free.  * 	[90/09/18            rpd]  *   * Revision 2.2  90/08/27  21:49:53  dbg  * 	Reflected changes in db_printsym()'s calling seq.  * 	[90/08/20            af]  * 	Clear breakpoints only if inserted.  * 	Reduce lint.  * 	[90/08/07            dbg]  * 	Created.  * 	[90/07/25            dbg]  *   */
end_comment

begin_comment
comment|/*  *	Author: David B. Golub, Carnegie Mellon University  *	Date:	7/90  */
end_comment

begin_comment
comment|/*  * Breakpoints.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|<machine/db_machdep.h>
end_include

begin_comment
comment|/* type definitions */
end_comment

begin_include
include|#
directive|include
file|<ddb/db_lex.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_break.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_access.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_break.h>
end_include

begin_function_decl
specifier|extern
name|boolean_t
name|db_map_equal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|boolean_t
name|db_map_current
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|vm_map_t
name|db_map_addr
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NBREAKPOINTS
value|100
end_define

begin_decl_stmt
name|struct
name|db_breakpoint
name|db_break_table
index|[
name|NBREAKPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_breakpoint_t
name|db_next_free_breakpoint
init|=
operator|&
name|db_break_table
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_breakpoint_t
name|db_free_breakpoints
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_breakpoint_t
name|db_breakpoint_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|db_breakpoint_t
name|db_breakpoint_alloc
parameter_list|()
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
if|if
condition|(
operator|(
name|bkpt
operator|=
name|db_free_breakpoints
operator|)
operator|!=
literal|0
condition|)
block|{
name|db_free_breakpoints
operator|=
name|bkpt
operator|->
name|link
expr_stmt|;
return|return
operator|(
name|bkpt
operator|)
return|;
block|}
if|if
condition|(
name|db_next_free_breakpoint
operator|==
operator|&
name|db_break_table
index|[
name|NBREAKPOINTS
index|]
condition|)
block|{
name|db_printf
argument_list|(
literal|"All breakpoints used.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bkpt
operator|=
name|db_next_free_breakpoint
expr_stmt|;
name|db_next_free_breakpoint
operator|++
expr_stmt|;
return|return
operator|(
name|bkpt
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_breakpoint_free
parameter_list|(
name|bkpt
parameter_list|)
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
block|{
name|bkpt
operator|->
name|link
operator|=
name|db_free_breakpoints
expr_stmt|;
name|db_free_breakpoints
operator|=
name|bkpt
expr_stmt|;
block|}
end_function

begin_function
name|void
name|db_set_breakpoint
parameter_list|(
name|map
parameter_list|,
name|addr
parameter_list|,
name|count
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
name|db_addr_t
name|addr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
if|if
condition|(
name|db_find_breakpoint
argument_list|(
name|map
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Already set.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bkpt
operator|=
name|db_breakpoint_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|bkpt
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Too many breakpoints.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bkpt
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|bkpt
operator|->
name|address
operator|=
name|addr
expr_stmt|;
name|bkpt
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|bkpt
operator|->
name|init_count
operator|=
name|count
expr_stmt|;
name|bkpt
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|bkpt
operator|->
name|link
operator|=
name|db_breakpoint_list
expr_stmt|;
name|db_breakpoint_list
operator|=
name|bkpt
expr_stmt|;
block|}
end_function

begin_function
name|void
name|db_delete_breakpoint
parameter_list|(
name|map
parameter_list|,
name|addr
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
name|db_addr_t
name|addr
decl_stmt|;
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
specifier|register
name|db_breakpoint_t
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|prev
operator|=
operator|&
name|db_breakpoint_list
init|;
operator|(
name|bkpt
operator|=
operator|*
name|prev
operator|)
operator|!=
literal|0
condition|;
name|prev
operator|=
operator|&
name|bkpt
operator|->
name|link
control|)
block|{
if|if
condition|(
name|db_map_equal
argument_list|(
name|bkpt
operator|->
name|map
argument_list|,
name|map
argument_list|)
operator|&&
operator|(
name|bkpt
operator|->
name|address
operator|==
name|addr
operator|)
condition|)
block|{
operator|*
name|prev
operator|=
name|bkpt
operator|->
name|link
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bkpt
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Not set.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_breakpoint_free
argument_list|(
name|bkpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|db_breakpoint_t
name|db_find_breakpoint
parameter_list|(
name|map
parameter_list|,
name|addr
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
name|db_addr_t
name|addr
decl_stmt|;
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
for|for
control|(
name|bkpt
operator|=
name|db_breakpoint_list
init|;
name|bkpt
operator|!=
literal|0
condition|;
name|bkpt
operator|=
name|bkpt
operator|->
name|link
control|)
block|{
if|if
condition|(
name|db_map_equal
argument_list|(
name|bkpt
operator|->
name|map
argument_list|,
name|map
argument_list|)
operator|&&
operator|(
name|bkpt
operator|->
name|address
operator|==
name|addr
operator|)
condition|)
return|return
operator|(
name|bkpt
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|db_breakpoint_t
name|db_find_breakpoint_here
parameter_list|(
name|addr
parameter_list|)
name|db_addr_t
name|addr
decl_stmt|;
block|{
return|return
name|db_find_breakpoint
argument_list|(
name|db_map_addr
argument_list|(
name|addr
argument_list|)
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|boolean_t
name|db_breakpoints_inserted
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|db_set_breakpoints
parameter_list|()
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
if|if
condition|(
operator|!
name|db_breakpoints_inserted
condition|)
block|{
for|for
control|(
name|bkpt
operator|=
name|db_breakpoint_list
init|;
name|bkpt
operator|!=
literal|0
condition|;
name|bkpt
operator|=
name|bkpt
operator|->
name|link
control|)
if|if
condition|(
name|db_map_current
argument_list|(
name|bkpt
operator|->
name|map
argument_list|)
condition|)
block|{
name|bkpt
operator|->
name|bkpt_inst
operator|=
name|db_get_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|db_put_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|BKPT_SET
argument_list|(
name|bkpt
operator|->
name|bkpt_inst
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|db_breakpoints_inserted
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|db_clear_breakpoints
parameter_list|()
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
if|if
condition|(
name|db_breakpoints_inserted
condition|)
block|{
for|for
control|(
name|bkpt
operator|=
name|db_breakpoint_list
init|;
name|bkpt
operator|!=
literal|0
condition|;
name|bkpt
operator|=
name|bkpt
operator|->
name|link
control|)
if|if
condition|(
name|db_map_current
argument_list|(
name|bkpt
operator|->
name|map
argument_list|)
condition|)
block|{
name|db_put_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|bkpt
operator|->
name|bkpt_inst
argument_list|)
expr_stmt|;
block|}
name|db_breakpoints_inserted
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set a temporary breakpoint.  * The instruction is changed immediately,  * so the breakpoint does not have to be on the breakpoint list.  */
end_comment

begin_function
name|db_breakpoint_t
name|db_set_temp_breakpoint
parameter_list|(
name|addr
parameter_list|)
name|db_addr_t
name|addr
decl_stmt|;
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
name|bkpt
operator|=
name|db_breakpoint_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|bkpt
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Too many breakpoints.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bkpt
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
name|bkpt
operator|->
name|address
operator|=
name|addr
expr_stmt|;
name|bkpt
operator|->
name|flags
operator|=
name|BKPT_TEMP
expr_stmt|;
name|bkpt
operator|->
name|init_count
operator|=
literal|1
expr_stmt|;
name|bkpt
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|bkpt
operator|->
name|bkpt_inst
operator|=
name|db_get_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|db_put_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|BKPT_SET
argument_list|(
name|bkpt
operator|->
name|bkpt_inst
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bkpt
return|;
block|}
end_function

begin_function
name|void
name|db_delete_temp_breakpoint
parameter_list|(
name|bkpt
parameter_list|)
name|db_breakpoint_t
name|bkpt
decl_stmt|;
block|{
name|db_put_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|bkpt
operator|->
name|bkpt_inst
argument_list|)
expr_stmt|;
name|db_breakpoint_free
argument_list|(
name|bkpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * List breakpoints.  */
end_comment

begin_function
name|void
name|db_list_breakpoints
parameter_list|()
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
if|if
condition|(
name|db_breakpoint_list
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"No breakpoints set\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_printf
argument_list|(
literal|" Map      Count    Address\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bkpt
operator|=
name|db_breakpoint_list
init|;
name|bkpt
operator|!=
literal|0
condition|;
name|bkpt
operator|=
name|bkpt
operator|->
name|link
control|)
block|{
name|db_printf
argument_list|(
literal|"%s%8x %5d    "
argument_list|,
name|db_map_current
argument_list|(
name|bkpt
operator|->
name|map
argument_list|)
condition|?
literal|"*"
else|:
literal|" "
argument_list|,
name|bkpt
operator|->
name|map
argument_list|,
name|bkpt
operator|->
name|init_count
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete breakpoint */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|db_delete_cmd
parameter_list|(
name|addr
parameter_list|,
name|have_addr
parameter_list|,
name|count
parameter_list|,
name|modif
parameter_list|)
name|db_expr_t
name|addr
decl_stmt|;
name|int
name|have_addr
decl_stmt|;
name|db_expr_t
name|count
decl_stmt|;
name|char
modifier|*
name|modif
decl_stmt|;
block|{
name|db_delete_breakpoint
argument_list|(
name|db_map_addr
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|(
name|db_addr_t
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set breakpoint with skip count */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|db_breakpoint_cmd
parameter_list|(
name|addr
parameter_list|,
name|have_addr
parameter_list|,
name|count
parameter_list|,
name|modif
parameter_list|)
name|db_expr_t
name|addr
decl_stmt|;
name|int
name|have_addr
decl_stmt|;
name|db_expr_t
name|count
decl_stmt|;
name|char
modifier|*
name|modif
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|==
operator|-
literal|1
condition|)
name|count
operator|=
literal|1
expr_stmt|;
name|db_set_breakpoint
argument_list|(
name|db_map_addr
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|(
name|db_addr_t
operator|)
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* list breakpoints */
end_comment

begin_function
name|void
name|db_listbreak_cmd
parameter_list|()
block|{
name|db_list_breakpoints
argument_list|()
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_comment
comment|/*  *	We want ddb to be usable before most of the kernel has been  *	initialized.  In particular, current_thread() or kernel_map  *	(or both) may be null.  */
end_comment

begin_function
name|boolean_t
name|db_map_equal
parameter_list|(
name|map1
parameter_list|,
name|map2
parameter_list|)
name|vm_map_t
name|map1
decl_stmt|,
name|map2
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|map1
operator|==
name|map2
operator|)
operator|||
operator|(
operator|(
name|map1
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|map2
operator|==
name|kernel_map
operator|)
operator|)
operator|||
operator|(
operator|(
name|map1
operator|==
name|kernel_map
operator|)
operator|&&
operator|(
name|map2
operator|==
name|NULL
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|db_map_current
parameter_list|(
name|map
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|thread_t	thread;  	return ((map == NULL) || 		(map == kernel_map) || 		(((thread = current_thread()) != NULL)&& 		 (map == thread->task->map)));
else|#
directive|else
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|vm_map_t
name|db_map_addr
parameter_list|(
name|addr
parameter_list|)
name|vm_offset_t
name|addr
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|thread_t	thread;
comment|/* 	 *	We want to return kernel_map for all 	 *	non-user addresses, even when debugging 	 *	kernel tasks with their own maps. 	 */
block|if ((VM_MIN_ADDRESS<= addr)&& 	    (addr< VM_MAX_ADDRESS)&& 	    ((thread = current_thread()) != NULL)) 	    return thread->task->map; 	else
endif|#
directive|endif
return|return
name|kernel_map
return|;
block|}
end_function

end_unit

