begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         2       00149  * --------------------         -----   ----------------------  *  * 16 Feb 93	Julian Elischer		ADDED for SCSI system  * 23 May 93	Rodney W. Grimes	ADDED Pioneer DRM-600 cd changer  */
end_comment

begin_comment
comment|/*  * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  */
end_comment

begin_comment
comment|/* $Log: * */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"st.h"
end_include

begin_include
include|#
directive|include
file|"sd.h"
end_include

begin_include
include|#
directive|include
file|"ch.h"
end_include

begin_include
include|#
directive|include
file|"cd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MACH
end_ifdef

begin_include
include|#
directive|include
file|<i386/machparam.h>
end_include

begin_endif
endif|#
directive|endif
endif|MACH
end_endif

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OSF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__386BSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"bll.h"
end_include

begin_include
include|#
directive|include
file|"cals.h"
end_include

begin_include
include|#
directive|include
file|"kil.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NBLL
value|0
end_define

begin_define
define|#
directive|define
name|NCALS
value|0
end_define

begin_define
define|#
directive|define
name|NKIL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(OSF)&& !defined(__386BSD__) */
end_comment

begin_if
if|#
directive|if
name|NSD
operator|>
literal|0
end_if

begin_extern
extern|extern	sdattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
endif|NSD
end_endif

begin_if
if|#
directive|if
name|NST
operator|>
literal|0
end_if

begin_extern
extern|extern	stattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
endif|NST
end_endif

begin_if
if|#
directive|if
name|NCH
operator|>
literal|0
end_if

begin_extern
extern|extern	chattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
endif|NCH
end_endif

begin_if
if|#
directive|if
name|NCD
operator|>
literal|0
end_if

begin_extern
extern|extern	cdattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
endif|NCD
end_endif

begin_if
if|#
directive|if
name|NBLL
operator|>
literal|0
end_if

begin_extern
extern|extern	bllattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
endif|NBLL
end_endif

begin_if
if|#
directive|if
name|NCALS
operator|>
literal|0
end_if

begin_extern
extern|extern	calsattach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
endif|NCALS
end_endif

begin_if
if|#
directive|if
name|NKIL
operator|>
literal|0
end_if

begin_extern
extern|extern	kil_attach(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
endif|NKIL
end_endif

begin_comment
comment|/***************************************************************\ * The structure of pre-configured devices that might be turned	* * off and therefore may not show up				* \***************************************************************/
end_comment

begin_struct
struct|struct
name|predefined
block|{
name|u_char
name|scsibus
decl_stmt|;
name|u_char
name|dev
decl_stmt|;
name|u_char
name|lu
decl_stmt|;
name|int
function_decl|(
modifier|*
name|attach_rtn
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|devname
decl_stmt|;
name|char
name|flags
decl_stmt|;
block|}
name|pd
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|EXAMPLE_PREDEFINE
if|#
directive|if
name|NSD
operator|>
literal|0
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|sdattach
block|,
literal|"sd"
block|,
literal|0
block|}
block|,
comment|/* define a disk at scsibus=0 dev=0 lu=0 */
endif|#
directive|endif
endif|NSD
endif|#
directive|endif
endif|EXAMPLE_PREDEFINE
block|{
literal|0
block|,
literal|9
block|,
literal|9
block|}
comment|/*illegal dummy end entry */
block|}
struct|;
end_struct

begin_comment
comment|/***************************************************************\ * The structure of known drivers for autoconfiguration		* \***************************************************************/
end_comment

begin_struct
specifier|static
struct|struct
name|scsidevs
block|{
name|int
name|type
decl_stmt|;
name|int
name|removable
decl_stmt|;
name|char
modifier|*
name|manufacturer
decl_stmt|;
name|char
modifier|*
name|model
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|int
function_decl|(
modifier|*
name|attach_rtn
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|devname
decl_stmt|;
name|char
name|flags
decl_stmt|;
comment|/* 1 show my comparisons during boot(debug) */
block|}
define|#
directive|define
name|SC_SHOWME
value|0x01
define|#
directive|define
name|SC_ONE_LU
value|0x00
define|#
directive|define
name|SC_MORE_LUS
value|0x02
name|knowndevs
index|[]
init|=
block|{
if|#
directive|if
name|NSD
operator|>
literal|0
block|{
name|T_DIRECT
block|,
name|T_FIXED
block|,
literal|"standard"
block|,
literal|"any"
block|,
literal|"any"
block|,
name|sdattach
block|,
literal|"sd"
block|,
name|SC_ONE_LU
block|}
block|,
block|{
name|T_DIRECT
block|,
name|T_FIXED
block|,
literal|"MAXTOR  "
block|,
literal|"XT-4170S        "
block|,
literal|"B5A "
block|,
name|sdattach
block|,
literal|"mx1"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
endif|NSD
if|#
directive|if
name|NST
operator|>
literal|0
block|{
name|T_SEQUENTIAL
block|,
name|T_REMOV
block|,
literal|"standard"
block|,
literal|"any"
block|,
literal|"any"
block|,
name|stattach
block|,
literal|"st"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
endif|NST
if|#
directive|if
name|NCALS
operator|>
literal|0
block|{
name|T_PROCESSOR
block|,
name|T_FIXED
block|,
literal|"standard"
block|,
literal|"any"
block|,
literal|"any"
block|,
name|calsattach
block|,
literal|"cals"
block|,
name|SC_MORE_LUS
block|}
block|,
endif|#
directive|endif
endif|NCALS
if|#
directive|if
name|NCH
operator|>
literal|0
block|{
name|T_CHANGER
block|,
name|T_REMOV
block|,
literal|"standard"
block|,
literal|"any"
block|,
literal|"any"
block|,
name|chattach
block|,
literal|"ch"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
endif|NCH
if|#
directive|if
name|NCD
operator|>
literal|0
block|{
name|T_READONLY
block|,
name|T_REMOV
block|,
literal|"SONY    "
block|,
literal|"CD-ROM CDU-8012 "
block|,
literal|"3.1a"
block|,
name|cdattach
block|,
literal|"cd"
block|,
name|SC_ONE_LU
block|}
block|,
block|{
name|T_READONLY
block|,
name|T_REMOV
block|,
literal|"PIONEER "
block|,
literal|"CD-ROM DRM-600  "
block|,
literal|"any"
block|,
name|cdattach
block|,
literal|"cd"
block|,
name|SC_MORE_LUS
block|}
block|,
endif|#
directive|endif
endif|NCD
if|#
directive|if
name|NBLL
operator|>
literal|0
block|{
name|T_PROCESSOR
block|,
name|T_FIXED
block|,
literal|"AEG     "
block|,
literal|"READER          "
block|,
literal|"V1.0"
block|,
name|bllattach
block|,
literal|"bll"
block|,
name|SC_MORE_LUS
block|}
block|,
endif|#
directive|endif
endif|NBLL
if|#
directive|if
name|NKIL
operator|>
literal|0
block|{
name|T_SCANNER
block|,
name|T_FIXED
block|,
literal|"KODAK   "
block|,
literal|"IL Scanner 900  "
block|,
literal|"any"
block|,
name|kil_attach
block|,
literal|"kil"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
endif|NKIL
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/***************************************************************\ * Declarations							* \***************************************************************/
end_comment

begin_function_decl
name|struct
name|predefined
modifier|*
name|scsi_get_predef
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|scsidevs
modifier|*
name|scsi_probedev
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|scsidevs
modifier|*
name|selectdev
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* controls debug level within the scsi subsystem */
end_comment

begin_comment
comment|/* see scsiconf.h for values			  */
end_comment

begin_decl_stmt
name|int
name|scsi_debug
init|=
literal|0x0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsibus
init|=
literal|0x0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the Nth scsibus */
end_comment

begin_comment
comment|/***************************************************************\ * The routine called by the adapter boards to get all their	* * devices configured in.					* \***************************************************************/
end_comment

begin_macro
name|scsi_attachdevs
argument_list|(
argument|unit
argument_list|,
argument|scsi_addr
argument_list|,
argument|scsi_switch
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|scsi_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi_switch
modifier|*
name|scsi_switch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|targ
decl_stmt|,
name|lun
decl_stmt|;
name|struct
name|scsidevs
modifier|*
name|bestmatch
init|=
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|predefined
modifier|*
name|predef
decl_stmt|;
name|int
name|maybe_more
decl_stmt|;
ifdef|#
directive|ifdef
name|SCSI_DELAY
if|#
directive|if
name|SCSI_DELAY
operator|>
literal|2
name|printf
argument_list|(
literal|"waiting for scsi devices to settle\n"
argument_list|)
expr_stmt|;
else|#
directive|else
else|SCSI_DELAY> 2
define|#
directive|define
name|SCSI_DELAY
value|15
endif|#
directive|endif
endif|SCSI_DELAY> 2
else|#
directive|else
define|#
directive|define
name|SCSI_DELAY
value|2
endif|#
directive|endif
endif|SCSI_DELAY
name|spinwait
argument_list|(
literal|1000
operator|*
name|SCSI_DELAY
argument_list|)
expr_stmt|;
name|targ
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|targ
operator|<
literal|8
condition|)
block|{
name|maybe_more
operator|=
literal|0
expr_stmt|;
comment|/* by default only check 1 lun */
if|if
condition|(
name|targ
operator|==
name|scsi_addr
condition|)
block|{
name|targ
operator|++
expr_stmt|;
continue|continue;
block|}
name|lun
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lun
operator|<
literal|8
condition|)
block|{
name|predef
operator|=
name|scsi_get_predef
argument_list|(
name|scsibus
argument_list|,
name|targ
argument_list|,
name|lun
argument_list|,
operator|&
name|maybe_more
argument_list|)
expr_stmt|;
name|bestmatch
operator|=
name|scsi_probedev
argument_list|(
name|unit
argument_list|,
name|targ
argument_list|,
name|lun
argument_list|,
name|scsi_switch
argument_list|,
operator|&
name|maybe_more
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bestmatch
operator|)
operator|&&
operator|(
name|predef
operator|)
condition|)
comment|/* both exist */
block|{
if|if
condition|(
name|bestmatch
operator|->
name|attach_rtn
operator|!=
name|predef
operator|->
name|attach_rtn
condition|)
block|{
name|printf
argument_list|(
literal|"Clash in found/expected devices\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"will link in FOUND\n"
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
operator|(
name|bestmatch
operator|->
name|attach_rtn
operator|)
operator|)
operator|(
name|unit
operator|,
name|targ
operator|,
name|lun
operator|,
name|scsi_switch
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bestmatch
operator|)
operator|&&
operator|(
operator|!
name|predef
operator|)
condition|)
comment|/* just FOUND */
block|{
operator|(
operator|*
operator|(
name|bestmatch
operator|->
name|attach_rtn
operator|)
operator|)
operator|(
name|unit
operator|,
name|targ
operator|,
name|lun
operator|,
name|scsi_switch
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|bestmatch
operator|)
operator|&&
operator|(
name|predef
operator|)
condition|)
comment|/* just predef */
block|{
operator|(
operator|*
operator|(
name|predef
operator|->
name|attach_rtn
operator|)
operator|)
operator|(
name|unit
operator|,
name|targ
operator|,
name|lun
operator|,
name|scsi_switch
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|maybe_more
operator|)
condition|)
comment|/* nothing suggests we'll find more */
block|{
break|break;
comment|/* nothing here, skip to next targ */
block|}
comment|/* otherwise something says we should look further*/
name|lun
operator|++
expr_stmt|;
block|}
name|targ
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|NGENSCSI
operator|>
literal|0
comment|/***************************************************************\ 	* If available hook up the generic scsi driver, letting it	* 	* know which target is US. (i.e. illegal or at least special)	* 	\***************************************************************/
name|genscsi_attach
argument_list|(
name|unit
argument_list|,
name|scsi_addr
argument_list|,
literal|0
argument_list|,
name|scsi_switch
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scsibus
operator|++
expr_stmt|;
comment|/* next time we are on the NEXT scsi bus */
block|}
end_block

begin_comment
comment|/***********************************************\ * given a target and lu, check if there is a	* * predefined device for that address		* \***********************************************/
end_comment

begin_function
name|struct
name|predefined
modifier|*
name|scsi_get_predef
parameter_list|(
name|unit
parameter_list|,
name|target
parameter_list|,
name|lu
parameter_list|,
name|maybe_more
parameter_list|)
name|int
name|unit
decl_stmt|,
name|target
decl_stmt|,
name|lu
decl_stmt|,
decl|*
name|maybe_more
decl_stmt|;
end_function

begin_block
block|{
name|int
name|upto
decl_stmt|,
name|numents
decl_stmt|;
name|numents
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|pd
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|predefined
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|upto
operator|=
literal|0
init|;
name|upto
operator|<
name|numents
condition|;
name|upto
operator|++
control|)
block|{
if|if
condition|(
name|pd
index|[
name|upto
index|]
operator|.
name|scsibus
operator|!=
name|unit
condition|)
continue|continue;
if|if
condition|(
name|pd
index|[
name|upto
index|]
operator|.
name|dev
operator|!=
name|target
condition|)
continue|continue;
if|if
condition|(
name|pd
index|[
name|upto
index|]
operator|.
name|lu
operator|!=
name|lu
condition|)
continue|continue;
name|printf
argument_list|(
literal|"  dev%d,lu%d: %s - PRECONFIGURED -\n"
argument_list|,
name|target
argument_list|,
name|lu
argument_list|,
name|pd
index|[
name|upto
index|]
operator|.
name|devname
argument_list|)
expr_stmt|;
operator|*
name|maybe_more
operator|=
name|pd
index|[
name|upto
index|]
operator|.
name|flags
operator|&
name|SC_MORE_LUS
expr_stmt|;
return|return
operator|(
operator|&
operator|(
name|pd
index|[
name|upto
index|]
operator|)
operator|)
return|;
block|}
return|return
operator|(
operator|(
expr|struct
name|predefined
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/***********************************************\ * given a target and lu, ask the device what	* * it is, and find the correct driver table	* * entry.					* \***********************************************/
end_comment

begin_function
name|struct
name|scsidevs
modifier|*
name|scsi_probedev
parameter_list|(
name|unit
parameter_list|,
name|target
parameter_list|,
name|lu
parameter_list|,
name|scsi_switch
parameter_list|,
name|maybe_more
parameter_list|)
name|struct
name|scsi_switch
modifier|*
name|scsi_switch
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|target
decl_stmt|,
name|lu
decl_stmt|;
name|int
modifier|*
name|maybe_more
decl_stmt|;
block|{
name|struct
name|scsidevs
modifier|*
name|bestmatch
init|=
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|dtype
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|,
modifier|*
name|desc
decl_stmt|;
name|char
modifier|*
name|qtype
decl_stmt|;
specifier|static
name|struct
name|scsi_inquiry_data
name|inqbuf
decl_stmt|;
name|int
name|len
decl_stmt|,
name|qualifier
decl_stmt|,
name|type
decl_stmt|,
name|remov
decl_stmt|;
name|char
name|manu
index|[
literal|32
index|]
decl_stmt|;
name|char
name|model
index|[
literal|32
index|]
decl_stmt|;
name|char
name|version
index|[
literal|32
index|]
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|inqbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|inqbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* Ask the device what it is			* 	\***********************************************/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|target
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lu
operator|==
literal|0
operator|)
condition|)
name|scsi_debug
operator|=
literal|0xfff
expr_stmt|;
else|else
name|scsi_debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|scsi_ready
argument_list|(
name|unit
argument_list|,
name|target
argument_list|,
name|lu
argument_list|,
name|scsi_switch
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
argument_list|)
operator|!=
name|COMPLETE
condition|)
block|{
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
block|}
if|if
condition|(
name|scsi_inquire
argument_list|(
name|unit
argument_list|,
name|target
argument_list|,
name|lu
argument_list|,
name|scsi_switch
argument_list|,
operator|&
name|inqbuf
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
argument_list|)
operator|!=
name|COMPLETE
condition|)
block|{
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
block|}
comment|/***********************************************\ 	* note what BASIC type of device it is		* 	\***********************************************/
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWINQUIRY
condition|)
block|{
name|desc
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|inqbuf
expr_stmt|;
name|printf
argument_list|(
literal|"inq: %x %x %x %x %x %x %x %x %x %x %x %x %x\n"
argument_list|,
name|desc
index|[
literal|0
index|]
argument_list|,
name|desc
index|[
literal|1
index|]
argument_list|,
name|desc
index|[
literal|2
index|]
argument_list|,
name|desc
index|[
literal|3
index|]
argument_list|,
name|desc
index|[
literal|4
index|]
argument_list|,
name|desc
index|[
literal|5
index|]
argument_list|,
name|desc
index|[
literal|6
index|]
argument_list|,
name|desc
index|[
literal|7
index|]
argument_list|,
name|desc
index|[
literal|8
index|]
argument_list|,
name|desc
index|[
literal|9
index|]
argument_list|,
name|desc
index|[
literal|10
index|]
argument_list|,
name|desc
index|[
literal|11
index|]
argument_list|,
name|desc
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|inqbuf
operator|.
name|device_type
expr_stmt|;
name|qualifier
operator|=
name|inqbuf
operator|.
name|device_qualifier
expr_stmt|;
name|remov
operator|=
name|inqbuf
operator|.
name|removable
expr_stmt|;
comment|/* Check for a non-existent unit.  If the device is returning 	 * this much, then we must set the flag that has 	 * the searcher keep looking on other luns. 	 */
if|if
condition|(
name|qualifier
operator|==
literal|3
operator|&&
name|type
operator|==
name|T_NODEVICE
condition|)
block|{
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
block|}
comment|/* Any device qualifier that has 	 * the top bit set (qualifier&4 != 0) is vendor specific and 	 * won't match in this switch. 	 */
switch|switch
condition|(
name|qualifier
condition|)
block|{
case|case
literal|0
case|:
name|qtype
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|qtype
operator|=
literal|", Unit not Connected!"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|qtype
operator|=
literal|", Reserved Peripheral Qualifier!"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|qtype
operator|=
literal|", The Target can't support this Unit!"
expr_stmt|;
break|break;
default|default:
name|dtype
operator|=
literal|"vendor specific"
expr_stmt|;
name|qtype
operator|=
literal|""
expr_stmt|;
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dtype
operator|==
literal|0
condition|)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_DIRECT
case|:
name|dtype
operator|=
literal|"direct"
expr_stmt|;
break|break;
case|case
name|T_SEQUENTIAL
case|:
name|dtype
operator|=
literal|"sequential"
expr_stmt|;
break|break;
case|case
name|T_PRINTER
case|:
name|dtype
operator|=
literal|"printer"
expr_stmt|;
break|break;
case|case
name|T_PROCESSOR
case|:
name|dtype
operator|=
literal|"processor"
expr_stmt|;
break|break;
case|case
name|T_READONLY
case|:
name|dtype
operator|=
literal|"readonly"
expr_stmt|;
break|break;
case|case
name|T_WORM
case|:
name|dtype
operator|=
literal|"worm"
expr_stmt|;
break|break;
case|case
name|T_SCANNER
case|:
name|dtype
operator|=
literal|"scanner"
expr_stmt|;
break|break;
case|case
name|T_OPTICAL
case|:
name|dtype
operator|=
literal|"optical"
expr_stmt|;
break|break;
case|case
name|T_CHANGER
case|:
name|dtype
operator|=
literal|"changer"
expr_stmt|;
break|break;
case|case
name|T_COMM
case|:
name|dtype
operator|=
literal|"communication"
expr_stmt|;
break|break;
default|default:
name|dtype
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
comment|/***********************************************\ 	* Then if it's advanced enough, more detailed	* 	* information					* 	\***********************************************/
if|if
condition|(
name|inqbuf
operator|.
name|ansii_version
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|inqbuf
operator|.
name|additional_length
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
name|inqbuf
operator|.
name|unused
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|inqbuf
operator|)
operator|)
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
operator|-
literal|1
expr_stmt|;
name|desc
operator|=
name|inqbuf
operator|.
name|vendor
expr_stmt|;
name|desc
index|[
name|len
operator|-
operator|(
name|desc
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|inqbuf
operator|)
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|manu
argument_list|,
name|inqbuf
operator|.
name|vendor
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|manu
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|model
argument_list|,
name|inqbuf
operator|.
name|product
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|model
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|version
argument_list|,
name|inqbuf
operator|.
name|revision
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|version
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/***********************************************\ 	* If not advanced enough, use default values	* 	\***********************************************/
block|{
name|desc
operator|=
literal|"early protocol device"
expr_stmt|;
name|strncpy
argument_list|(
name|manu
argument_list|,
literal|"unknown"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|model
argument_list|,
literal|"unknown"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|version
argument_list|,
literal|"????"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  dev%d,lu%d: type %d:%d(%s%s),%s '%s%s%s' scsi%d\n"
argument_list|,
name|target
argument_list|,
name|lu
argument_list|,
name|qualifier
argument_list|,
name|type
argument_list|,
name|dtype
argument_list|,
name|qtype
argument_list|,
name|remov
condition|?
literal|"removable"
else|:
literal|"fixed"
argument_list|,
name|manu
argument_list|,
name|model
argument_list|,
name|version
argument_list|,
name|inqbuf
operator|.
name|ansii_version
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* Try make as good a match as possible with	* 	* available sub drivers	 			* 	\***********************************************/
name|bestmatch
operator|=
operator|(
name|selectdev
argument_list|(
name|unit
argument_list|,
name|target
argument_list|,
name|lu
argument_list|,
operator|&
name|scsi_switch
argument_list|,
name|qualifier
argument_list|,
name|type
argument_list|,
name|remov
argument_list|,
name|manu
argument_list|,
name|model
argument_list|,
name|version
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bestmatch
operator|)
operator|&&
operator|(
name|bestmatch
operator|->
name|flags
operator|&
name|SC_MORE_LUS
operator|)
condition|)
block|{
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|bestmatch
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************\ * Try make as good a match as possible with	* * available sub drivers	 			* \***********************************************/
end_comment

begin_function
name|struct
name|scsidevs
modifier|*
name|selectdev
parameter_list|(
name|unit
parameter_list|,
name|target
parameter_list|,
name|lu
parameter_list|,
name|dvr_switch
parameter_list|,
name|qualifier
parameter_list|,
name|type
parameter_list|,
name|remov
parameter_list|,
name|manu
parameter_list|,
name|model
parameter_list|,
name|rev
parameter_list|)
name|int
name|unit
decl_stmt|,
name|target
decl_stmt|,
name|lu
decl_stmt|;
name|struct
name|scsi_switch
modifier|*
name|dvr_switch
decl_stmt|;
name|int
name|qualifier
decl_stmt|,
name|type
decl_stmt|,
name|remov
decl_stmt|;
name|char
modifier|*
name|manu
decl_stmt|,
decl|*
name|model
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
end_function

begin_block
block|{
name|int
name|numents
init|=
operator|(
sizeof|sizeof
argument_list|(
name|knowndevs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|scsidevs
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|bestmatches
init|=
literal|0
decl_stmt|;
name|struct
name|scsidevs
modifier|*
name|bestmatch
init|=
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|scsidevs
modifier|*
name|thisentry
init|=
name|knowndevs
decl_stmt|;
name|type
operator||=
operator|(
name|qualifier
operator|<<
literal|5
operator|)
expr_stmt|;
name|thisentry
operator|--
expr_stmt|;
while|while
condition|(
name|count
operator|++
operator|<
name|numents
condition|)
block|{
name|thisentry
operator|++
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|thisentry
operator|->
name|type
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bestmatches
operator|<
literal|1
condition|)
block|{
name|bestmatches
operator|=
literal|1
expr_stmt|;
name|bestmatch
operator|=
name|thisentry
expr_stmt|;
block|}
if|if
condition|(
name|remov
operator|!=
name|thisentry
operator|->
name|removable
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bestmatches
operator|<
literal|2
condition|)
block|{
name|bestmatches
operator|=
literal|2
expr_stmt|;
name|bestmatch
operator|=
name|thisentry
expr_stmt|;
block|}
if|if
condition|(
name|thisentry
operator|->
name|flags
operator|&
name|SC_SHOWME
condition|)
name|printf
argument_list|(
literal|"\n%s-\n%s-"
argument_list|,
name|thisentry
operator|->
name|manufacturer
argument_list|,
name|manu
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|thisentry
operator|->
name|manufacturer
argument_list|,
name|manu
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bestmatches
operator|<
literal|3
condition|)
block|{
name|bestmatches
operator|=
literal|3
expr_stmt|;
name|bestmatch
operator|=
name|thisentry
expr_stmt|;
block|}
if|if
condition|(
name|thisentry
operator|->
name|flags
operator|&
name|SC_SHOWME
condition|)
name|printf
argument_list|(
literal|"\n%s-\n%s-"
argument_list|,
name|thisentry
operator|->
name|model
argument_list|,
name|model
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|thisentry
operator|->
name|model
argument_list|,
name|model
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bestmatches
operator|<
literal|4
condition|)
block|{
name|bestmatches
operator|=
literal|4
expr_stmt|;
name|bestmatch
operator|=
name|thisentry
expr_stmt|;
block|}
if|if
condition|(
name|thisentry
operator|->
name|flags
operator|&
name|SC_SHOWME
condition|)
name|printf
argument_list|(
literal|"\n%s-\n%s-"
argument_list|,
name|thisentry
operator|->
name|version
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|thisentry
operator|->
name|version
argument_list|,
name|rev
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|bestmatches
operator|<
literal|5
condition|)
block|{
name|bestmatches
operator|=
literal|5
expr_stmt|;
name|bestmatch
operator|=
name|thisentry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bestmatch
operator|==
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
condition|)
name|printf
argument_list|(
literal|"	No explicit device driver match for \"%s %s\".\n"
argument_list|,
name|manu
argument_list|,
name|model
argument_list|)
expr_stmt|;
return|return
operator|(
name|bestmatch
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|recurse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************\ * Do a scsi operation asking a device if it is	* * ready. Use the scsi_cmd routine in the switch * * table.					* \***********************************************/
end_comment

begin_macro
name|scsi_ready
argument_list|(
argument|unit
argument_list|,
argument|target
argument_list|,
argument|lu
argument_list|,
argument|scsi_switch
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|scsi_switch
modifier|*
name|scsi_switch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_test_unit_ready
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_xfer
name|scsi_xfer
decl_stmt|;
specifier|volatile
name|int
name|rval
decl_stmt|;
name|int
name|key
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_xfer
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_xfer
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|TEST_UNIT_READY
expr_stmt|;
name|scsi_xfer
operator|.
name|flags
operator|=
name|flags
operator||
name|INUSE
expr_stmt|;
name|scsi_xfer
operator|.
name|adapter
operator|=
name|unit
expr_stmt|;
name|scsi_xfer
operator|.
name|targ
operator|=
name|target
expr_stmt|;
name|scsi_xfer
operator|.
name|lu
operator|=
name|lu
expr_stmt|;
name|scsi_xfer
operator|.
name|cmd
operator|=
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
expr_stmt|;
name|scsi_xfer
operator|.
name|retries
operator|=
literal|8
expr_stmt|;
name|scsi_xfer
operator|.
name|timeout
operator|=
literal|10000
expr_stmt|;
name|scsi_xfer
operator|.
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
expr_stmt|;
name|scsi_xfer
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|scsi_xfer
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|scsi_xfer
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
name|scsi_xfer
operator|.
name|when_done
operator|=
literal|0
expr_stmt|;
name|scsi_xfer
operator|.
name|done_arg
operator|=
literal|0
expr_stmt|;
name|retry
label|:
name|scsi_xfer
operator|.
name|error
operator|=
literal|0
expr_stmt|;
comment|/*******************************************************\ 	* do not use interrupts					* 	\*******************************************************/
name|rval
operator|=
operator|(
operator|*
operator|(
name|scsi_switch
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
operator|&
name|scsi_xfer
operator|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|COMPLETE
condition|)
block|{
if|if
condition|(
name|scsi_debug
condition|)
block|{
name|printf
argument_list|(
literal|"scsi error, rval = 0x%x\n"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"code from driver: 0x%x\n"
argument_list|,
name|scsi_xfer
operator|.
name|error
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|scsi_xfer
operator|.
name|error
condition|)
block|{
case|case
name|XS_SENSE
case|:
comment|/*******************************************************\ 		* Any sense value is illegal except UNIT ATTENTION	* 		* In which case we need to check again to get the	* 		* correct response.					* 		*( especially exabytes)					* 		\*******************************************************/
if|if
condition|(
name|scsi_xfer
operator|.
name|sense
operator|.
name|error_class
operator|==
literal|7
condition|)
block|{
name|key
operator|=
name|scsi_xfer
operator|.
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|sense_key
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|2
case|:
comment|/* not ready BUT PRESENT! */
return|return
operator|(
name|COMPLETE
operator|)
return|;
case|case
literal|6
case|:
name|spinwait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_xfer
operator|.
name|retries
operator|--
condition|)
block|{
name|scsi_xfer
operator|.
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
default|default:
if|if
condition|(
name|scsi_debug
condition|)
name|printf
argument_list|(
literal|"%d:%d,key=%x."
argument_list|,
name|target
argument_list|,
name|lu
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
case|case
name|XS_BUSY
case|:
name|spinwait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_xfer
operator|.
name|retries
operator|--
condition|)
block|{
name|scsi_xfer
operator|.
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
comment|/* it's busy so it's there */
case|case
name|XS_TIMEOUT
case|:
default|default:
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_block

begin_comment
comment|/***********************************************\ * Do a scsi operation asking a device what it is* * Use the scsi_cmd routine in the switch table.	* \***********************************************/
end_comment

begin_macro
name|scsi_inquire
argument_list|(
argument|unit
argument_list|,
argument|target
argument_list|,
argument|lu
argument_list|,
argument|scsi_switch
argument_list|,
argument|inqbuf
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|scsi_switch
modifier|*
name|scsi_switch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|inqbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_inquiry
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_xfer
name|scsi_xfer
decl_stmt|;
specifier|volatile
name|int
name|rval
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_xfer
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_xfer
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|INQUIRY
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
expr_stmt|;
name|scsi_xfer
operator|.
name|flags
operator|=
name|flags
operator||
name|SCSI_DATA_IN
operator||
name|INUSE
expr_stmt|;
name|scsi_xfer
operator|.
name|adapter
operator|=
name|unit
expr_stmt|;
name|scsi_xfer
operator|.
name|targ
operator|=
name|target
expr_stmt|;
name|scsi_xfer
operator|.
name|lu
operator|=
name|lu
expr_stmt|;
name|scsi_xfer
operator|.
name|retries
operator|=
literal|8
expr_stmt|;
name|scsi_xfer
operator|.
name|timeout
operator|=
literal|10000
expr_stmt|;
name|scsi_xfer
operator|.
name|cmd
operator|=
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
expr_stmt|;
name|scsi_xfer
operator|.
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry
argument_list|)
expr_stmt|;
name|scsi_xfer
operator|.
name|data
operator|=
name|inqbuf
expr_stmt|;
name|scsi_xfer
operator|.
name|datalen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
expr_stmt|;
name|scsi_xfer
operator|.
name|resid
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
expr_stmt|;
name|scsi_xfer
operator|.
name|when_done
operator|=
literal|0
expr_stmt|;
name|scsi_xfer
operator|.
name|done_arg
operator|=
literal|0
expr_stmt|;
name|retry
label|:
name|scsi_xfer
operator|.
name|error
operator|=
literal|0
expr_stmt|;
comment|/*******************************************************\ 	* do not use interrupts					* 	\*******************************************************/
if|if
condition|(
operator|(
operator|*
operator|(
name|scsi_switch
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
operator|&
name|scsi_xfer
operator|)
operator|!=
name|COMPLETE
condition|)
block|{
if|if
condition|(
name|scsi_debug
condition|)
name|printf
argument_list|(
literal|"inquiry had error(0x%x) "
argument_list|,
name|scsi_xfer
operator|.
name|error
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|scsi_xfer
operator|.
name|error
condition|)
block|{
case|case
name|XS_NOERROR
case|:
break|break;
case|case
name|XS_SENSE
case|:
comment|/*******************************************************\ 		* Any sense value is illegal except UNIT ATTENTION	* 		* In which case we need to check again to get the	* 		* correct response.					* 		*( especially exabytes)					* 		\*******************************************************/
if|if
condition|(
operator|(
name|scsi_xfer
operator|.
name|sense
operator|.
name|error_class
operator|==
literal|7
operator|)
operator|&&
operator|(
name|scsi_xfer
operator|.
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|sense_key
operator|==
literal|6
operator|)
condition|)
block|{
comment|/* it's changed so it's there */
name|spinwait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|{
if|if
condition|(
name|scsi_xfer
operator|.
name|retries
operator|--
condition|)
block|{
name|scsi_xfer
operator|.
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
case|case
name|XS_BUSY
case|:
name|spinwait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_xfer
operator|.
name|retries
operator|--
condition|)
block|{
name|scsi_xfer
operator|.
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
case|case
name|XS_TIMEOUT
case|:
default|default:
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_block

begin_comment
comment|/***********************************************\ * Utility routines often used in SCSI stuff	* \***********************************************/
end_comment

begin_comment
comment|/***********************************************\ * convert a physical address to 3 bytes, 	* * MSB at the lowest address,			* * LSB at the highest.				* \***********************************************/
end_comment

begin_macro
name|lto3b
argument_list|(
argument|val
argument_list|,
argument|bytes
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|bytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|bytes
operator|++
operator|=
operator|(
name|val
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
name|bytes
operator|++
operator|=
operator|(
name|val
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|bytes
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
block|}
end_block

begin_comment
comment|/***********************************************\ * The reverse of lto3b				* \***********************************************/
end_comment

begin_macro
name|_3btol
argument_list|(
argument|bytes
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|bytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
operator|(
operator|*
name|bytes
operator|++
operator|<<
literal|16
operator|)
expr_stmt|;
name|rc
operator|+=
operator|(
operator|*
name|bytes
operator|++
operator|<<
literal|8
operator|)
expr_stmt|;
name|rc
operator|+=
operator|*
name|bytes
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_block

end_unit

