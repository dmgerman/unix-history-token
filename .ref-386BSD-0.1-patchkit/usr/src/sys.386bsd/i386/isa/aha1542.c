begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * (Mostly) Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         1       00098  * --------------------         -----   ----------------------  *  * 16 Feb 93	Julian Elischer		ADDED for SCSI system  */
end_comment

begin_comment
comment|/*  * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  */
end_comment

begin_comment
comment|/*  * HISTORY  * $Log: aha1542.c,v $  * Revision 1.6  1992/08/24  21:01:58  jason  * many changes and bugfixes for osf1  *  * Revision 1.5  1992/07/31  01:22:03  julian  * support improved scsi.h layout  *  * Revision 1.4  1992/07/25  03:11:26  julian  * check each request fro sane flags.  *  * Revision 1.3  1992/07/24  00:52:45  julian  * improved timeout handling.  * added support for two arguments to the sd_done (or equiv) call so that  * they can pre-queue several arguments.  * slightly clean up error handling  *  * Revision 1.2  1992/07/17  22:03:54  julian  * upgraded the timeout code.  * added support for UIO-based i/o (as used for pmem operations)  *  * Revision 1.1  1992/05/27  00:51:12  balsup  * machkern/cor merge  */
end_comment

begin_comment
comment|/*  * a FEW lines in this driver come from a MACH adaptec-disk driver  * so the copyright below is included:  *  * Copyright 1990 by Open Software Foundation,  * Grenoble, FRANCE  *  * 		All Rights Reserved  *   *   Permission to use, copy, modify, and distribute this software and  * its documentation for any purpose and without fee is hereby granted,  * provided that the above copyright notice appears in all copies and  * that both the copyright notice and this permission notice appear in  * supporting documentation, and that the name of OSF or Open Software  * Foundation not be used in advertising or publicity pertaining to  * distribution of the software without specific, written prior  * permission.  *   *   OSF DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,  * IN NO EVENT SHALL OSF BE LIABLE FOR ANY SPECIAL, INDIRECT, OR  * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,  * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<aha.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MACH
end_ifdef

begin_comment
comment|/* EITHER CMU OR OSF */
end_comment

begin_include
include|#
directive|include
file|<i386/ipl.h>
end_include

begin_include
include|#
directive|include
file|<i386at/scsi.h>
end_include

begin_include
include|#
directive|include
file|<i386at/scsiconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OSF
end_ifdef

begin_comment
comment|/* OSF ONLY */
end_comment

begin_include
include|#
directive|include
file|<sys/table.h>
end_include

begin_include
include|#
directive|include
file|<i386/handler.h>
end_include

begin_include
include|#
directive|include
file|<i386/dispatcher.h>
end_include

begin_include
include|#
directive|include
file|<i386/AT386/atbus.h>
end_include

begin_else
else|#
directive|else
else|OSF
end_else

begin_comment
comment|/* CMU ONLY */
end_comment

begin_include
include|#
directive|include
file|<i386at/atbus.h>
end_include

begin_include
include|#
directive|include
file|<i386/pio.h>
end_include

begin_endif
endif|#
directive|endif
endif|OSF
end_endif

begin_endif
endif|#
directive|endif
endif|MACH
end_endif

begin_comment
comment|/* end of MACH specific */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_comment
comment|/* 386BSD specific */
end_comment

begin_define
define|#
directive|define
name|isa_dev
value|isa_device
end_define

begin_define
define|#
directive|define
name|dev_unit
value|id_unit
end_define

begin_define
define|#
directive|define
name|dev_addr
value|id_iobase
end_define

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_include
include|#
directive|include
file|"ddb.h"
end_include

begin_if
if|#
directive|if
name|NDDB
operator|>
literal|0
end_if

begin_function_decl
name|int
name|Debugger
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
else|NDDB
end_else

begin_define
define|#
directive|define
name|Debugger
parameter_list|()
value|panic("should call debugger here (adaptec.c)")
end_define

begin_endif
endif|#
directive|endif
endif|NDDB
end_endif

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_decl_stmt
specifier|extern
name|int
name|delaycount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from clock setup code */
end_comment

begin_comment
comment|/************************** board definitions *******************************/
end_comment

begin_comment
comment|/*  * I/O Port Interface  */
end_comment

begin_define
define|#
directive|define
name|AHA_BASE
value|aha_base[unit]
end_define

begin_define
define|#
directive|define
name|AHA_CTRL_STAT_PORT
value|(AHA_BASE + 0x0)
end_define

begin_comment
comment|/* control& status */
end_comment

begin_define
define|#
directive|define
name|AHA_CMD_DATA_PORT
value|(AHA_BASE + 0x1)
end_define

begin_comment
comment|/* cmds and datas */
end_comment

begin_define
define|#
directive|define
name|AHA_INTR_PORT
value|(AHA_BASE + 0x2)
end_define

begin_comment
comment|/* Intr. stat */
end_comment

begin_comment
comment|/*  * AHA_CTRL_STAT bits (write)  */
end_comment

begin_define
define|#
directive|define
name|AHA_HRST
value|0x80
end_define

begin_comment
comment|/* Hardware reset */
end_comment

begin_define
define|#
directive|define
name|AHA_SRST
value|0x40
end_define

begin_comment
comment|/* Software reset */
end_comment

begin_define
define|#
directive|define
name|AHA_IRST
value|0x20
end_define

begin_comment
comment|/* Interrupt reset */
end_comment

begin_define
define|#
directive|define
name|AHA_SCRST
value|0x10
end_define

begin_comment
comment|/* SCSI bus reset */
end_comment

begin_comment
comment|/*  * AHA_CTRL_STAT bits (read)  */
end_comment

begin_define
define|#
directive|define
name|AHA_STST
value|0x80
end_define

begin_comment
comment|/* Self test in Progress */
end_comment

begin_define
define|#
directive|define
name|AHA_DIAGF
value|0x40
end_define

begin_comment
comment|/* Diagnostic Failure */
end_comment

begin_define
define|#
directive|define
name|AHA_INIT
value|0x20
end_define

begin_comment
comment|/* Mbx Init required */
end_comment

begin_define
define|#
directive|define
name|AHA_IDLE
value|0x10
end_define

begin_comment
comment|/* Host Adapter Idle */
end_comment

begin_define
define|#
directive|define
name|AHA_CDF
value|0x08
end_define

begin_comment
comment|/* cmd/data out port full */
end_comment

begin_define
define|#
directive|define
name|AHA_DF
value|0x04
end_define

begin_comment
comment|/* Data in port full */
end_comment

begin_define
define|#
directive|define
name|AHA_INVDCMD
value|0x01
end_define

begin_comment
comment|/* Invalid command */
end_comment

begin_comment
comment|/*  * AHA_CMD_DATA bits (write)  */
end_comment

begin_define
define|#
directive|define
name|AHA_NOP
value|0x00
end_define

begin_comment
comment|/* No operation */
end_comment

begin_define
define|#
directive|define
name|AHA_MBX_INIT
value|0x01
end_define

begin_comment
comment|/* Mbx initialization */
end_comment

begin_define
define|#
directive|define
name|AHA_START_SCSI
value|0x02
end_define

begin_comment
comment|/* start scsi command */
end_comment

begin_define
define|#
directive|define
name|AHA_START_BIOS
value|0x03
end_define

begin_comment
comment|/* start bios command */
end_comment

begin_define
define|#
directive|define
name|AHA_INQUIRE
value|0x04
end_define

begin_comment
comment|/* Adapter Inquiry */
end_comment

begin_define
define|#
directive|define
name|AHA_MBO_INTR_EN
value|0x05
end_define

begin_comment
comment|/* Enable MBO available interrupt */
end_comment

begin_define
define|#
directive|define
name|AHA_SEL_TIMEOUT_SET
value|0x06
end_define

begin_comment
comment|/* set selection time-out */
end_comment

begin_define
define|#
directive|define
name|AHA_BUS_ON_TIME_SET
value|0x07
end_define

begin_comment
comment|/* set bus-on time */
end_comment

begin_define
define|#
directive|define
name|AHA_BUS_OFF_TIME_SET
value|0x08
end_define

begin_comment
comment|/* set bus-off time */
end_comment

begin_define
define|#
directive|define
name|AHA_SPEED_SET
value|0x09
end_define

begin_comment
comment|/* set transfer speed */
end_comment

begin_define
define|#
directive|define
name|AHA_DEV_GET
value|0x0a
end_define

begin_comment
comment|/* return installed devices */
end_comment

begin_define
define|#
directive|define
name|AHA_CONF_GET
value|0x0b
end_define

begin_comment
comment|/* return configuration data */
end_comment

begin_define
define|#
directive|define
name|AHA_TARGET_EN
value|0x0c
end_define

begin_comment
comment|/* enable target mode */
end_comment

begin_define
define|#
directive|define
name|AHA_SETUP_GET
value|0x0d
end_define

begin_comment
comment|/* return setup data */
end_comment

begin_define
define|#
directive|define
name|AHA_WRITE_CH2
value|0x1a
end_define

begin_comment
comment|/* write channel 2 buffer */
end_comment

begin_define
define|#
directive|define
name|AHA_READ_CH2
value|0x1b
end_define

begin_comment
comment|/* read channel 2 buffer */
end_comment

begin_define
define|#
directive|define
name|AHA_WRITE_FIFO
value|0x1c
end_define

begin_comment
comment|/* write fifo buffer */
end_comment

begin_define
define|#
directive|define
name|AHA_READ_FIFO
value|0x1d
end_define

begin_comment
comment|/* read fifo buffer */
end_comment

begin_define
define|#
directive|define
name|AHA_ECHO
value|0x1e
end_define

begin_comment
comment|/* Echo command data */
end_comment

begin_struct
struct|struct
name|aha_cmd_buf
block|{
name|u_char
name|byte
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * AHA_INTR_PORT bits (read)  */
end_comment

begin_define
define|#
directive|define
name|AHA_ANY_INTR
value|0x80
end_define

begin_comment
comment|/* Any interrupt */
end_comment

begin_define
define|#
directive|define
name|AHA_SCRD
value|0x08
end_define

begin_comment
comment|/* SCSI reset detected */
end_comment

begin_define
define|#
directive|define
name|AHA_HACC
value|0x04
end_define

begin_comment
comment|/* Command complete */
end_comment

begin_define
define|#
directive|define
name|AHA_MBOA
value|0x02
end_define

begin_comment
comment|/* MBX out empty */
end_comment

begin_define
define|#
directive|define
name|AHA_MBIF
value|0x01
end_define

begin_comment
comment|/* MBX in full */
end_comment

begin_comment
comment|/*  * Mail box defs   */
end_comment

begin_define
define|#
directive|define
name|AHA_MBX_SIZE
value|16
end_define

begin_comment
comment|/* mail box size */
end_comment

begin_struct
struct|struct
name|aha_mbx
block|{
struct|struct
name|aha_mbx_out
block|{
name|unsigned
name|char
name|cmd
decl_stmt|;
name|unsigned
name|char
name|ccb_addr
index|[
literal|3
index|]
decl_stmt|;
block|}
name|mbo
index|[
name|AHA_MBX_SIZE
index|]
struct|;
struct|struct
name|aha_mbx_in
block|{
name|unsigned
name|char
name|stat
decl_stmt|;
name|unsigned
name|char
name|ccb_addr
index|[
literal|3
index|]
decl_stmt|;
block|}
name|mbi
index|[
name|AHA_MBX_SIZE
index|]
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * mbo.cmd values  */
end_comment

begin_define
define|#
directive|define
name|AHA_MBO_FREE
value|0x0
end_define

begin_comment
comment|/* MBO entry is free */
end_comment

begin_define
define|#
directive|define
name|AHA_MBO_START
value|0x1
end_define

begin_comment
comment|/* MBO activate entry */
end_comment

begin_define
define|#
directive|define
name|AHA_MBO_ABORT
value|0x2
end_define

begin_comment
comment|/* MBO abort entry */
end_comment

begin_define
define|#
directive|define
name|AHA_MBI_FREE
value|0x0
end_define

begin_comment
comment|/* MBI entry is free */
end_comment

begin_define
define|#
directive|define
name|AHA_MBI_OK
value|0x1
end_define

begin_comment
comment|/* completed without error */
end_comment

begin_define
define|#
directive|define
name|AHA_MBI_ABORT
value|0x2
end_define

begin_comment
comment|/* aborted ccb */
end_comment

begin_define
define|#
directive|define
name|AHA_MBI_UNKNOWN
value|0x3
end_define

begin_comment
comment|/* Tried to abort invalid CCB */
end_comment

begin_define
define|#
directive|define
name|AHA_MBI_ERROR
value|0x4
end_define

begin_comment
comment|/* Completed with error */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|aha_mbx
name|aha_mbx
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FOR OLD VERSIONS OF THE !%$@ this may have to be 16 (yuk) */
end_comment

begin_define
define|#
directive|define
name|AHA_NSEG
value|17
end_define

begin_comment
comment|/* Number of scatter gather segments<= 16 */
end_comment

begin_comment
comment|/* allow 64 K i/o (min) */
end_comment

begin_struct
struct|struct
name|aha_ccb
block|{
name|unsigned
name|char
name|opcode
decl_stmt|;
name|unsigned
name|char
name|lun
range|:
literal|3
decl_stmt|;
name|unsigned
name|char
name|data_in
range|:
literal|1
decl_stmt|;
comment|/* must be 0 */
name|unsigned
name|char
name|data_out
range|:
literal|1
decl_stmt|;
comment|/* must be 0 */
name|unsigned
name|char
name|target
range|:
literal|3
decl_stmt|;
name|unsigned
name|char
name|scsi_cmd_length
decl_stmt|;
name|unsigned
name|char
name|req_sense_length
decl_stmt|;
name|unsigned
name|char
name|data_length
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|data_addr
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|link_addr
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|link_id
decl_stmt|;
name|unsigned
name|char
name|host_stat
decl_stmt|;
name|unsigned
name|char
name|target_stat
decl_stmt|;
name|unsigned
name|char
name|reserved
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|scsi_generic
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_sense_data
name|scsi_sense
decl_stmt|;
struct|struct
name|aha_scat_gath
block|{
name|unsigned
name|char
name|seg_len
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|seg_addr
index|[
literal|3
index|]
decl_stmt|;
block|}
name|scat_gath
index|[
name|AHA_NSEG
index|]
struct|;
name|struct
name|aha_ccb
modifier|*
name|next
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xfer
decl_stmt|;
comment|/* the scsi_xfer for this cmd */
name|struct
name|aha_mbx_out
modifier|*
name|mbx
decl_stmt|;
comment|/* pointer to mail box */
name|long
name|int
name|delta
decl_stmt|;
comment|/* difference from previous*/
name|struct
name|aha_ccb
modifier|*
name|later
decl_stmt|,
modifier|*
name|sooner
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|CCB_FREE
value|0
define|#
directive|define
name|CCB_ACTIVE
value|1
define|#
directive|define
name|CCB_ABORTED
value|2
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|aha_ccb
modifier|*
name|aha_soonest
init|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|aha_ccb
modifier|*
name|aha_latest
init|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|aha_furtherest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* longest time in the timeout queue */
end_comment

begin_comment
comment|/*  * opcode fields  */
end_comment

begin_define
define|#
directive|define
name|AHA_INITIATOR_CCB
value|0x00
end_define

begin_comment
comment|/* SCSI Initiator CCB */
end_comment

begin_define
define|#
directive|define
name|AHA_TARGET_CCB
value|0x01
end_define

begin_comment
comment|/* SCSI Target CCB */
end_comment

begin_define
define|#
directive|define
name|AHA_INIT_SCAT_GATH_CCB
value|0x02
end_define

begin_comment
comment|/* SCSI Initiator with scattter gather*/
end_comment

begin_define
define|#
directive|define
name|AHA_RESET_CCB
value|0x81
end_define

begin_comment
comment|/* SCSI Bus reset */
end_comment

begin_comment
comment|/*  * aha_ccb.host_stat values  */
end_comment

begin_define
define|#
directive|define
name|AHA_OK
value|0x00
end_define

begin_comment
comment|/* cmd ok */
end_comment

begin_define
define|#
directive|define
name|AHA_LINK_OK
value|0x0a
end_define

begin_comment
comment|/* Link cmd ok */
end_comment

begin_define
define|#
directive|define
name|AHA_LINK_IT
value|0x0b
end_define

begin_comment
comment|/* Link cmd ok + int */
end_comment

begin_define
define|#
directive|define
name|AHA_SEL_TIMEOUT
value|0x11
end_define

begin_comment
comment|/* Selection time out */
end_comment

begin_define
define|#
directive|define
name|AHA_OVER_UNDER
value|0x12
end_define

begin_comment
comment|/* Data over/under run */
end_comment

begin_define
define|#
directive|define
name|AHA_BUS_FREE
value|0x13
end_define

begin_comment
comment|/* Bus dropped at unexpected time */
end_comment

begin_define
define|#
directive|define
name|AHA_INV_BUS
value|0x14
end_define

begin_comment
comment|/* Invalid bus phase/sequence */
end_comment

begin_define
define|#
directive|define
name|AHA_BAD_MBO
value|0x15
end_define

begin_comment
comment|/* Incorrect MBO cmd */
end_comment

begin_define
define|#
directive|define
name|AHA_BAD_CCB
value|0x16
end_define

begin_comment
comment|/* Incorrect ccb opcode */
end_comment

begin_define
define|#
directive|define
name|AHA_BAD_LINK
value|0x17
end_define

begin_comment
comment|/* Not same values of LUN for links */
end_comment

begin_define
define|#
directive|define
name|AHA_INV_TARGET
value|0x18
end_define

begin_comment
comment|/* Invalid target direction */
end_comment

begin_define
define|#
directive|define
name|AHA_CCB_DUP
value|0x19
end_define

begin_comment
comment|/* Duplicate CCB received */
end_comment

begin_define
define|#
directive|define
name|AHA_INV_CCB
value|0x1a
end_define

begin_comment
comment|/* Invalid CCB or segment list */
end_comment

begin_define
define|#
directive|define
name|AHA_ABORTED
value|42
end_define

begin_struct
struct|struct
name|aha_setup
block|{
name|u_char
name|sync_neg
range|:
literal|1
decl_stmt|;
name|u_char
name|parity
range|:
literal|1
decl_stmt|;
name|u_char
label|:
literal|6
expr_stmt|;
name|u_char
name|speed
decl_stmt|;
name|u_char
name|bus_on
decl_stmt|;
name|u_char
name|bus_off
decl_stmt|;
name|u_char
name|num_mbx
decl_stmt|;
name|u_char
name|mbx
index|[
literal|3
index|]
decl_stmt|;
struct|struct
block|{
name|u_char
name|offset
range|:
literal|4
decl_stmt|;
name|u_char
name|period
range|:
literal|3
decl_stmt|;
name|u_char
name|valid
range|:
literal|1
decl_stmt|;
block|}
name|sync
index|[
literal|8
index|]
struct|;
name|u_char
name|disc_sts
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|aha_config
block|{
name|u_char
name|chan
decl_stmt|;
name|u_char
name|intr
decl_stmt|;
name|u_char
name|scsi_dev
range|:
literal|3
decl_stmt|;
name|u_char
label|:
literal|5
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|INT9
value|0x01
end_define

begin_define
define|#
directive|define
name|INT10
value|0x02
end_define

begin_define
define|#
directive|define
name|INT11
value|0x04
end_define

begin_define
define|#
directive|define
name|INT12
value|0x08
end_define

begin_define
define|#
directive|define
name|INT14
value|0x20
end_define

begin_define
define|#
directive|define
name|INT15
value|0x40
end_define

begin_define
define|#
directive|define
name|CHAN0
value|0x01
end_define

begin_define
define|#
directive|define
name|CHAN5
value|0x20
end_define

begin_define
define|#
directive|define
name|CHAN6
value|0x40
end_define

begin_define
define|#
directive|define
name|CHAN7
value|0x80
end_define

begin_comment
comment|/*********************************** end of board definitions***************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MACH
end_ifdef

begin_define
define|#
directive|define
name|PHYSTOKV
parameter_list|(
name|x
parameter_list|)
value|phystokv(x)
end_define

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|kvtophys(x)
end_define

begin_else
else|#
directive|else
else|MACH
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_define
define|#
directive|define
name|PHYSTOKV
parameter_list|(
name|x
parameter_list|)
value|(x | 0xFE000000)
end_define

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_else
else|#
directive|else
else|__386BSD__
end_else

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_endif
endif|#
directive|endif
endif|MACH
end_endif

begin_define
define|#
directive|define
name|AHA_DMA_PAGES
value|AHA_NSEG
end_define

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_define
define|#
directive|define
name|INVALIDATE_CACHE
value|{asm volatile( ".byte	0x0F ;.byte 0x08" ); }
end_define

begin_decl_stmt
name|u_char
name|aha_scratch_buf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MACH
end_ifdef

begin_decl_stmt
name|caddr_t
name|aha_base
index|[
name|NAHA
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base port for each board */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|short
name|aha_base
index|[
name|NAHA
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base port for each board */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|aha_mbx
name|aha_mbx
index|[
name|NAHA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|aha_ccb
modifier|*
name|aha_ccb_free
index|[
name|NAHA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|aha_ccb
name|aha_ccb
index|[
name|NAHA
index|]
index|[
name|AHA_MBX_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi_xfer
name|aha_scsi_xfer
index|[
name|NAHA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_dev
modifier|*
name|ahainfo
index|[
name|NAHA
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|aha_ccb
modifier|*
name|aha_get_ccb
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|aha_int
index|[
name|NAHA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|aha_dma
index|[
name|NAHA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|aha_scsi_dev
index|[
name|NAHA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|aha_initialized
index|[
name|NAHA
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OSF
end_ifdef

begin_decl_stmt
name|int
name|aha_attached
index|[
name|NAHA
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|OSF
end_endif

begin_decl_stmt
name|int
name|aha_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ahaprobe
argument_list|()
decl_stmt|,
name|ahaattach
argument_list|()
decl_stmt|,
name|ahaintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MACH
end_ifdef

begin_decl_stmt
name|struct
name|isa_driver
name|ahadriver
init|=
block|{
name|ahaprobe
block|,
literal|0
block|,
name|ahaattach
block|,
literal|"aha"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|ahaintrs
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|ahaintr
operator|,
function_decl|0
end_function_decl

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_decl_stmt
name|struct
name|isa_driver
name|ahadriver
init|=
block|{
name|ahaprobe
block|,
name|ahaattach
block|,
literal|"aha"
block|,}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_decl_stmt
specifier|static
name|int
name|ahaunit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|aha_abortmbx
parameter_list|(
name|mbx
parameter_list|)
define|\
value|(mbx)->cmd = AHA_MBO_ABORT; \ 	outb(AHA_CMD_DATA_PORT, AHA_START_SCSI);
end_define

begin_define
define|#
directive|define
name|aha_startmbx
parameter_list|(
name|mbx
parameter_list|)
define|\
value|(mbx)->cmd = AHA_MBO_START; \ 	outb(AHA_CMD_DATA_PORT, AHA_START_SCSI);
end_define

begin_function_decl
name|int
name|aha_scsi_cmd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|aha_timeout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ahaminphys
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|int
name|aha_adapter_info
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|scsi_switch
name|aha_switch
init|=
block|{
name|aha_scsi_cmd
block|,
name|ahaminphys
block|,
literal|0
block|,
literal|0
block|,
name|aha_adapter_info
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AHA_CMD_TIMEOUT_FUDGE
value|200
end_define

begin_comment
comment|/* multiplied to get Secs	*/
end_comment

begin_define
define|#
directive|define
name|AHA_RESET_TIMEOUT
value|1000000
end_define

begin_comment
comment|/* time to wait for reset	*/
end_comment

begin_define
define|#
directive|define
name|AHA_SCSI_TIMEOUT_FUDGE
value|20
end_define

begin_comment
comment|/* divided by for mSecs		*/
end_comment

begin_comment
comment|/***********************************************************************\ * aha_cmd(unit,icnt, ocnt,wait, retval, opcode, args)			* * Activate Adapter command						* *	icnt:	number of args (outbound bytes written after opcode)	* *	ocnt:	number of expected returned bytes			* *	wait:	number of seconds to wait for response			* *	retval:	buffer where to place returned bytes			* *	opcode:	opcode AHA_NOP, AHA_MBX_INIT, AHA_START_SCSI ...	* *	args:	parameters						* *									* * Performs an adapter command through the ports. Not to be confused	* *	with a scsi command, which is read in via the dma		* * One of the adapter commands tells it to read in a scsi command	* \***********************************************************************/
end_comment

begin_macro
name|aha_cmd
argument_list|(
argument|unit
argument_list|,
argument|icnt
argument_list|,
argument|ocnt
argument_list|,
argument|wait
argument_list|,
argument|retval
argument_list|,
argument|opcode
argument_list|,
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|opcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
modifier|*
name|ic
init|=
operator|&
name|opcode
decl_stmt|;
name|u_char
name|oc
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|sts
decl_stmt|;
comment|/*******************************************************\ 	* multiply the wait argument by a big constant		* 	* zero defaults to 1					* 	\*******************************************************/
if|if
condition|(
operator|!
name|wait
condition|)
name|wait
operator|=
name|AHA_CMD_TIMEOUT_FUDGE
operator|*
name|delaycount
expr_stmt|;
else|else
name|wait
operator|*=
name|AHA_CMD_TIMEOUT_FUDGE
operator|*
name|delaycount
expr_stmt|;
comment|/*******************************************************\ 	* Wait for the adapter to go idle, unless it's one of	* 	* the commands which don't need this			* 	\*******************************************************/
if|if
condition|(
name|opcode
operator|!=
name|AHA_MBX_INIT
operator|&&
name|opcode
operator|!=
name|AHA_START_SCSI
condition|)
block|{
name|i
operator|=
name|AHA_CMD_TIMEOUT_FUDGE
operator|*
name|delaycount
expr_stmt|;
comment|/* 1 sec?*/
while|while
condition|(
operator|--
name|i
condition|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|&
name|AHA_IDLE
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|printf
argument_list|(
literal|"aha_cmd: aha1542 host not idle(0x%x)\n"
argument_list|,
name|sts
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/*******************************************************\ 	* Now that it is idle, if we expect output, preflush the* 	* queue feeding to us.					* 	\*******************************************************/
if|if
condition|(
name|ocnt
condition|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
operator|)
operator|&
name|AHA_DF
condition|)
name|inb
argument_list|(
name|AHA_CMD_DATA_PORT
argument_list|)
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Output the command and the number of arguments given	* 	* for each byte, first check the port is empty.		* 	\*******************************************************/
name|icnt
operator|++
expr_stmt|;
comment|/* include the command */
while|while
condition|(
name|icnt
operator|--
condition|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wait
condition|;
name|i
operator|++
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|AHA_CDF
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|wait
condition|)
block|{
name|printf
argument_list|(
literal|"aha_cmd: aha1542 cmd/data port full\n"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|,
name|AHA_SRST
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|outb
argument_list|(
name|AHA_CMD_DATA_PORT
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|*
name|ic
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*******************************************************\ 	* If we expect input, loop that many times, each time,	* 	* looking for the data register to have valid data	* 	\*******************************************************/
while|while
condition|(
name|ocnt
operator|--
condition|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wait
condition|;
name|i
operator|++
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|&
name|AHA_DF
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|wait
condition|)
block|{
name|printf
argument_list|(
literal|"aha_cmd: aha1542 cmd/data port empty %d\n"
argument_list|,
name|ocnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|oc
operator|=
name|inb
argument_list|(
name|AHA_CMD_DATA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
operator|*
name|retval
operator|++
operator|=
name|oc
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Wait for the board to report a finised instruction	* 	\*******************************************************/
name|i
operator|=
name|AHA_CMD_TIMEOUT_FUDGE
operator|*
name|delaycount
expr_stmt|;
comment|/* 1 sec? */
while|while
condition|(
operator|--
name|i
condition|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_INTR_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|&
name|AHA_HACC
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|printf
argument_list|(
literal|"aha_cmd: aha1542 host not finished(0x%x)\n"
argument_list|,
name|sts
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|outb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|,
name|AHA_IRST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Check if the device can be found at the port given	* * and if so, set it up ready for further work		* * as an argument, takes the isa_dev structure from	* * autoconf.c						* \*******************************************************/
end_comment

begin_macro
name|ahaprobe
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_dev
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|ahaunit
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
specifier|static
name|ihandler_t
name|aha_handler
index|[
name|NAHA
index|]
decl_stmt|;
specifier|static
name|ihandler_id_t
modifier|*
name|aha_handler_id
index|[
name|NAHA
index|]
decl_stmt|;
specifier|register
name|ihandler_t
modifier|*
name|chp
init|=
operator|&
name|aha_handler
index|[
name|unit
index|]
decl_stmt|;
empty_stmt|;
endif|#
directive|endif
comment|/* defined(OSF) */
comment|/***********************************************\ 	/***********************************************\ 	* find unit and check we have that many defined	* 	\***********************************************/
name|dev
operator|->
name|dev_unit
operator|=
name|unit
expr_stmt|;
name|aha_base
index|[
name|unit
index|]
operator|=
name|dev
operator|->
name|dev_addr
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NAHA
condition|)
block|{
name|printf
argument_list|(
literal|"aha: unit number (%d) too high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/***********************************************\ 	* Try initialise a unit at this location	* 	* sets up dma and bus speed, loads aha_int[unit]* 	\***********************************************/
if|if
condition|(
name|aha_init
argument_list|(
name|unit
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/***********************************************\ 	* If it's there, put in it's interrupt vectors	* 	\***********************************************/
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OSF
argument_list|)
if|#
directive|if
name|defined
name|MACH
name|iunit
index|[
name|aha_int
index|[
name|unit
index|]
index|]
operator|=
name|unit
expr_stmt|;
name|ivect
index|[
name|aha_int
index|[
name|unit
index|]
index|]
operator|=
name|ahaintr
expr_stmt|;
name|intpri
index|[
name|aha_int
index|[
name|unit
index|]
index|]
operator|=
name|dev
operator|->
name|dev_spl
expr_stmt|;
name|form_pic_mask
argument_list|()
expr_stmt|;
comment|/*take_dev_irq(dev);*/
else|#
directive|else
ifdef|#
directive|ifdef
name|__386BSD__
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|aha_int
index|[
name|unit
index|]
operator|)
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
name|aha_dma
index|[
name|unit
index|]
expr_stmt|;
endif|#
directive|endif
endif|__386BSD__
endif|#
directive|endif
else|#
directive|else
comment|/* !defined(OSF) */
name|chp
operator|->
name|ih_level
operator|=
name|dev
operator|->
name|dev_pic
expr_stmt|;
name|chp
operator|->
name|ih_handler
operator|=
name|dev
operator|->
name|dev_intr
index|[
literal|0
index|]
expr_stmt|;
name|chp
operator|->
name|ih_resolver
operator|=
name|i386_resolver
expr_stmt|;
name|chp
operator|->
name|ih_rdev
operator|=
name|dev
expr_stmt|;
name|chp
operator|->
name|ih_stats
operator|.
name|intr_type
operator|=
name|INTR_DEVICE
expr_stmt|;
name|chp
operator|->
name|ih_stats
operator|.
name|intr_cnt
operator|=
literal|0
expr_stmt|;
name|chp
operator|->
name|ih_hparam
index|[
literal|0
index|]
operator|.
name|intparam
operator|=
name|unit
expr_stmt|;
if|if
condition|(
operator|(
name|aha_handler_id
index|[
name|unit
index|]
operator|=
name|handler_add
argument_list|(
name|chp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|handler_enable
argument_list|(
name|aha_handler_id
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"Unable to add aha interrupt handler"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(OSF) */
ifdef|#
directive|ifdef
name|__386BSD__
name|printf
argument_list|(
literal|"\n  **"
argument_list|)
expr_stmt|;
else|#
directive|else
else|__386BSD__
name|printf
argument_list|(
literal|"port=%x spl=%d\n"
argument_list|,
name|dev
operator|->
name|dev_addr
argument_list|,
name|dev
operator|->
name|dev_spl
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|__386BSD__
name|ahaunit
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/***********************************************\ * Attach all the sub-devices we can find	* \***********************************************/
end_comment

begin_macro
name|ahaattach
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_dev
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|dev_unit
decl_stmt|;
ifdef|#
directive|ifdef
name|__386BSD__
name|printf
argument_list|(
literal|" probing for scsi devices**\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|__386BSD__
comment|/***********************************************\ 	* ask the adapter what subunits are present	* 	\***********************************************/
name|scsi_attachdevs
argument_list|(
name|unit
argument_list|,
name|aha_scsi_dev
index|[
name|unit
index|]
argument_list|,
operator|&
name|aha_switch
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
name|aha_attached
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* defined(OSF) */
if|if
condition|(
operator|!
name|unit
condition|)
comment|/* only one for all boards */
block|{
name|aha_timeout
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__386BSD__
name|printf
argument_list|(
literal|"aha%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|__386BSD__
return|return;
block|}
end_block

begin_comment
comment|/***********************************************\ * Return some information to the caller about	* * the adapter and it's capabilities		* \***********************************************/
end_comment

begin_function
name|long
name|int
name|aha_adapter_info
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 2 outstanding requests at a time per device */
block|}
end_function

begin_comment
comment|/***********************************************\ * Catch an interrupt from the adaptor		* \***********************************************/
end_comment

begin_macro
name|ahaintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_block
block|{
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
name|unsigned
name|char
name|stat
decl_stmt|;
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"ahaintr "
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* First acknowlege the interrupt, Then if it's	* 	* not telling about a completed operation	* 	* just return. 					* 	\***********************************************/
name|stat
operator|=
name|inb
argument_list|(
name|AHA_INTR_PORT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|,
name|AHA_IRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEINTERRUPTS
condition|)
name|printf
argument_list|(
literal|"int "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|AHA_MBIF
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEINTERRUPTS
condition|)
name|printf
argument_list|(
literal|"b "
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
if|if
condition|(
operator|!
name|aha_attached
index|[
name|unit
index|]
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* defined(OSF) */
comment|/***********************************************\ 	* If it IS then process the competed operation	* 	\***********************************************/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHA_MBX_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|stat
operator|!=
name|AHA_MBI_FREE
condition|)
block|{
name|ccb
operator|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
name|PHYSTOKV
argument_list|(
operator|(
name|_3btol
argument_list|(
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|ccb_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|=
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|stat
operator|)
operator|!=
name|AHA_MBI_OK
condition|)
block|{
switch|switch
condition|(
name|stat
condition|)
block|{
case|case
name|AHA_MBI_ABORT
case|:
if|if
condition|(
name|aha_debug
condition|)
name|printf
argument_list|(
literal|"abort"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|host_stat
operator|=
name|AHA_ABORTED
expr_stmt|;
break|break;
case|case
name|AHA_MBI_UNKNOWN
case|:
name|ccb
operator|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|aha_debug
condition|)
name|printf
argument_list|(
literal|"unknown ccb for abort "
argument_list|)
expr_stmt|;
comment|/* may have missed it */
comment|/* no such ccb known for abort */
case|case
name|AHA_MBI_ERROR
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"Impossible mbxi status"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aha_debug
operator|&&
name|ccb
condition|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
operator|(
name|ccb
operator|->
name|scsi_cmd
operator|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"op=%x %x %x %x %x %x\n"
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|,
name|cp
index|[
literal|2
index|]
argument_list|,
name|cp
index|[
literal|3
index|]
argument_list|,
name|cp
index|[
literal|4
index|]
argument_list|,
name|cp
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"stat %x for mbi[%d]\n"
argument_list|,
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|stat
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addr = 0x%x\n"
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ccb
condition|)
block|{
name|aha_remove_timeout
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|aha_done
argument_list|(
name|unit
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|stat
operator|=
name|AHA_MBI_FREE
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/***********************************************\ * A ccb (and hence a mbx-out is put onto the 	* * free list.					* \***********************************************/
end_comment

begin_macro
name|aha_free_ccb
argument_list|(
argument|unit
argument_list|,
argument|ccb
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|opri
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"ccb%d(0x%x)> "
argument_list|,
name|unit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ccb
operator|->
name|next
operator|=
name|aha_ccb_free
index|[
name|unit
index|]
expr_stmt|;
name|aha_ccb_free
index|[
name|unit
index|]
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|flags
operator|=
name|CCB_FREE
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|sooner
operator|||
name|ccb
operator|->
name|later
condition|)
block|{
name|printf
argument_list|(
literal|"yikes, still in timeout queue\n"
argument_list|)
expr_stmt|;
name|aha_remove_timeout
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
comment|/***********************************************\ 	* If there were none, wake abybody waiting for	* 	* one to come free, starting with queued entries* 	\***********************************************/
if|if
condition|(
operator|!
name|ccb
operator|->
name|next
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|aha_ccb_free
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***********************************************\ * Get a free ccb (and hence mbox-out entry)	* \***********************************************/
end_comment

begin_function
name|struct
name|aha_ccb
modifier|*
name|aha_get_ccb
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
block|{
name|unsigned
name|opri
decl_stmt|;
name|struct
name|aha_ccb
modifier|*
name|rc
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"<ccb%d(0x%x) "
argument_list|,
name|unit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/***********************************************\ 	* If we can and have to, sleep waiting for one	* 	* to come free					* 	\***********************************************/
while|while
condition|(
operator|(
operator|!
operator|(
name|rc
operator|=
name|aha_ccb_free
index|[
name|unit
index|]
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
operator|)
condition|)
block|{
name|sleep
argument_list|(
operator|&
name|aha_ccb_free
index|[
name|unit
index|]
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
block|{
name|aha_ccb_free
index|[
name|unit
index|]
operator|=
name|aha_ccb_free
index|[
name|unit
index|]
operator|->
name|next
expr_stmt|;
name|rc
operator|->
name|flags
operator|=
name|CCB_ACTIVE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************\ * We have a ccb which has been processed by the	* * adaptor, now we look to see how the operation	* * went. Wake up the owner if waiting		* \***********************************************/
end_comment

begin_macro
name|aha_done
argument_list|(
argument|unit
argument_list|,
argument|ccb
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_sense_data
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|ccb
operator|->
name|xfer
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"aha_done "
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* Otherwise, put the results of the operation	* 	* into the xfer and call whoever started it	* 	\***********************************************/
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"exiting but not in use! "
argument_list|)
expr_stmt|;
name|Debugger
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|host_stat
operator|!=
name|AHA_OK
operator|||
name|ccb
operator|->
name|target_stat
operator|!=
name|SCSI_OK
operator|)
operator|&&
operator|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
operator|)
condition|)
block|{
name|s1
operator|=
operator|(
expr|struct
name|scsi_sense_data
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|ccb
operator|->
name|scsi_cmd
operator|)
operator|)
operator|+
name|ccb
operator|->
name|scsi_cmd_length
operator|)
expr_stmt|;
name|s2
operator|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|host_stat
condition|)
block|{
switch|switch
condition|(
name|ccb
operator|->
name|host_stat
condition|)
block|{
case|case
name|AHA_ABORTED
case|:
case|case
name|AHA_SEL_TIMEOUT
case|:
comment|/* No response */
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
break|break;
default|default:
comment|/* Other scsi protocol messes */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
if|if
condition|(
name|aha_debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"host_stat%x\n"
argument_list|,
name|ccb
operator|->
name|host_stat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|ccb
operator|->
name|target_stat
condition|)
block|{
case|case
literal|0x02
case|:
comment|/* structure copy!!!!!*/
operator|*
name|s2
operator|=
operator|*
name|s1
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|aha_debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"target_stat%x\n"
argument_list|,
name|ccb
operator|->
name|target_stat
argument_list|)
expr_stmt|;
block|}
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* All went correctly  OR errors expected */
block|{
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
block|}
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|aha_free_ccb
argument_list|(
name|unit
argument_list|,
name|ccb
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|when_done
condition|)
operator|(
operator|*
operator|(
name|xs
operator|->
name|when_done
operator|)
operator|)
operator|(
name|xs
operator|->
name|done_arg
operator|,
name|xs
operator|->
name|done_arg2
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***********************************************\ * Start the board, ready for normal operation	* \***********************************************/
end_comment

begin_macro
name|aha_init
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|ad
index|[
literal|3
index|]
decl_stmt|;
specifier|volatile
name|int
name|i
decl_stmt|,
name|sts
decl_stmt|;
name|struct
name|aha_config
name|conf
decl_stmt|;
comment|/***********************************************\ 	* reset board, If it doesn't respond, assume 	* 	* that it's not there.. good for the probe	* 	\***********************************************/
name|outb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|,
name|AHA_HRST
operator||
name|AHA_SRST
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHA_RESET_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|==
operator|(
name|AHA_IDLE
operator||
name|AHA_INIT
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|AHA_RESET_TIMEOUT
condition|)
block|{
if|if
condition|(
name|aha_debug
condition|)
name|printf
argument_list|(
literal|"aha_init: No answer from adaptec board\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/***********************************************\ 	* Assume we have a board at this stage		* 	* setup dma channel from jumpers and save int	* 	* level						* 	\***********************************************/
ifdef|#
directive|ifdef
name|__386BSD__
name|printf
argument_list|(
literal|"aha%d reading board settings, "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
define|#
directive|define
name|PRNT
parameter_list|(
name|x
parameter_list|)
else|#
directive|else
else|__386BSD__
name|printf
argument_list|(
literal|"aha%d:"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
define|#
directive|define
name|PRNT
parameter_list|(
name|x
parameter_list|)
value|printf(x)
endif|#
directive|endif
endif|__386BSD__
name|aha_cmd
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|conf
argument_list|,
name|AHA_CONF_GET
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|conf
operator|.
name|chan
condition|)
block|{
case|case
name|CHAN0
case|:
name|outb
argument_list|(
literal|0x0b
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x0a
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|aha_dma
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|PRNT
argument_list|(
literal|"dma=0 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAN5
case|:
name|outb
argument_list|(
literal|0xd6
argument_list|,
literal|0xc1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xd4
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|aha_dma
index|[
name|unit
index|]
operator|=
literal|5
expr_stmt|;
name|PRNT
argument_list|(
literal|"dma=5 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAN6
case|:
name|outb
argument_list|(
literal|0xd6
argument_list|,
literal|0xc2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xd4
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|aha_dma
index|[
name|unit
index|]
operator|=
literal|6
expr_stmt|;
name|PRNT
argument_list|(
literal|"dma=6 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAN7
case|:
name|outb
argument_list|(
literal|0xd6
argument_list|,
literal|0xc3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xd4
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|aha_dma
index|[
name|unit
index|]
operator|=
literal|7
expr_stmt|;
name|PRNT
argument_list|(
literal|"dma=7 "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal dma jumper setting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
switch|switch
condition|(
name|conf
operator|.
name|intr
condition|)
block|{
case|case
name|INT9
case|:
name|aha_int
index|[
name|unit
index|]
operator|=
literal|9
expr_stmt|;
name|PRNT
argument_list|(
literal|"int=9 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT10
case|:
name|aha_int
index|[
name|unit
index|]
operator|=
literal|10
expr_stmt|;
name|PRNT
argument_list|(
literal|"int=10 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT11
case|:
name|aha_int
index|[
name|unit
index|]
operator|=
literal|11
expr_stmt|;
name|PRNT
argument_list|(
literal|"int=11 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT12
case|:
name|aha_int
index|[
name|unit
index|]
operator|=
literal|12
expr_stmt|;
name|PRNT
argument_list|(
literal|"int=12 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT14
case|:
name|aha_int
index|[
name|unit
index|]
operator|=
literal|14
expr_stmt|;
name|PRNT
argument_list|(
literal|"int=14 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT15
case|:
name|aha_int
index|[
name|unit
index|]
operator|=
literal|15
expr_stmt|;
name|PRNT
argument_list|(
literal|"int=15 "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal int jumper setting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* who are we on the scsi bus */
name|aha_scsi_dev
index|[
name|unit
index|]
operator|=
name|conf
operator|.
name|scsi_dev
expr_stmt|;
comment|/***********************************************\ 	* Initialize memory transfer speed		* 	\***********************************************/
if|if
condition|(
operator|!
operator|(
name|aha_set_bus_speed
argument_list|(
name|unit
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/***********************************************\ 	* Initialize mail box 				* 	\***********************************************/
name|lto3b
argument_list|(
name|KVTOPHYS
argument_list|(
operator|&
name|aha_mbx
index|[
name|unit
index|]
argument_list|)
argument_list|,
name|ad
argument_list|)
expr_stmt|;
name|aha_cmd
argument_list|(
name|unit
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_MBX_INIT
argument_list|,
name|AHA_MBX_SIZE
argument_list|,
name|ad
index|[
literal|0
index|]
argument_list|,
name|ad
index|[
literal|1
index|]
argument_list|,
name|ad
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* link the ccb's with the mbox-out entries and	* 	* into a free-list				* 	\***********************************************/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHA_MBX_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|aha_ccb
index|[
name|unit
index|]
index|[
name|i
index|]
operator|.
name|next
operator|=
name|aha_ccb_free
index|[
name|unit
index|]
expr_stmt|;
name|aha_ccb_free
index|[
name|unit
index|]
operator|=
operator|&
name|aha_ccb
index|[
name|unit
index|]
index|[
name|i
index|]
expr_stmt|;
name|aha_ccb_free
index|[
name|unit
index|]
operator|->
name|flags
operator|=
name|CCB_FREE
expr_stmt|;
name|aha_ccb_free
index|[
name|unit
index|]
operator|->
name|mbx
operator|=
operator|&
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbo
index|[
name|i
index|]
expr_stmt|;
name|lto3b
argument_list|(
name|KVTOPHYS
argument_list|(
name|aha_ccb_free
index|[
name|unit
index|]
argument_list|)
argument_list|,
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbo
index|[
name|i
index|]
operator|.
name|ccb_addr
argument_list|)
expr_stmt|;
block|}
comment|/***********************************************\ 	* Note that we are going and return (to probe)	* 	\***********************************************/
name|aha_initialized
index|[
name|unit
index|]
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|void
name|ahaminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MACH
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OSF
argument_list|)
name|bp
operator|->
name|b_flags
operator||=
name|B_NPAGES
expr_stmt|;
comment|/* can support scat/gather */
endif|#
directive|endif
comment|/* !defined(OSF) */
endif|#
directive|endif
endif|MACH
comment|/*	aha seems to explode with 17 segs (64k may require 17 segs) */
comment|/* 	on old boards so use a max of 16 segs if you have problems here*/
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|AHA_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|AHA_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************\ * start a scsi operation given the command and	* * the data address. Also needs the unit, target	* * and lu					* \***********************************************/
end_comment

begin_function
name|int
name|aha_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_sense_data
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|aha_scat_gath
modifier|*
name|sg
decl_stmt|;
name|int
name|seg
decl_stmt|;
comment|/* scatter gather seg being worked on */
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|thiskv
decl_stmt|;
name|int
name|thisphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|int
name|unit
init|=
name|xs
operator|->
name|adapter
decl_stmt|;
name|int
name|bytes_this_seg
decl_stmt|,
name|bytes_this_page
decl_stmt|,
name|datalen
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iovp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"aha_scsi_cmd "
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* get a ccb (mbox-out) to use. If the transfer	* 	* is from a buf (possibly from interrupt time)	* 	* then we can't allow it to sleep		* 	\***********************************************/
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"not in use!"
argument_list|)
expr_stmt|;
name|Debugger
argument_list|()
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"Already done! check device retry code "
argument_list|)
expr_stmt|;
name|Debugger
argument_list|()
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
operator|(
name|SCSI_NOSLEEP
operator|)
expr_stmt|;
comment|/* just to be sure */
if|if
condition|(
operator|!
operator|(
name|ccb
operator|=
name|aha_get_ccb
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
if|if
condition|(
name|ccb
operator|->
name|mbx
operator|->
name|cmd
operator|!=
name|AHA_MBO_FREE
condition|)
name|printf
argument_list|(
literal|"MBO not free\n"
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* Put all the arguments for the xfer in the ccb	* 	\***********************************************/
name|ccb
operator|->
name|xfer
operator|=
name|xs
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|ccb
operator|->
name|opcode
operator|=
name|AHA_RESET_CCB
expr_stmt|;
block|}
else|else
block|{
comment|/* can't use S/G if zero length */
name|ccb
operator|->
name|opcode
operator|=
operator|(
name|xs
operator|->
name|datalen
condition|?
name|AHA_INIT_SCAT_GATH_CCB
else|:
name|AHA_INITIATOR_CCB
operator|)
expr_stmt|;
block|}
name|ccb
operator|->
name|target
operator|=
name|xs
operator|->
name|targ
expr_stmt|;
empty_stmt|;
name|ccb
operator|->
name|data_out
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|data_in
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|lun
operator|=
name|xs
operator|->
name|lu
expr_stmt|;
name|ccb
operator|->
name|scsi_cmd_length
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|ccb
operator|->
name|req_sense_length
operator|=
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|scsi_sense
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xs
operator|->
name|datalen
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_RESET
operator|)
operator|)
condition|)
block|{
comment|/* can use S/G only if not zero length */
name|lto3b
argument_list|(
name|KVTOPHYS
argument_list|(
name|ccb
operator|->
name|scat_gath
argument_list|)
argument_list|,
name|ccb
operator|->
name|data_addr
argument_list|)
expr_stmt|;
name|sg
operator|=
name|ccb
operator|->
name|scat_gath
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_UIO
condition|)
block|{
name|iovp
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iov
expr_stmt|;
name|datalen
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iovcnt
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|AHA_NSEG
operator|)
condition|)
block|{
name|lto3b
argument_list|(
name|iovp
operator|->
name|iov_base
argument_list|,
operator|&
operator|(
name|sg
operator|->
name|seg_addr
operator|)
argument_list|)
expr_stmt|;
name|lto3b
argument_list|(
name|iovp
operator|->
name|iov_len
argument_list|,
operator|&
operator|(
name|sg
operator|->
name|seg_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWSCATGATH
condition|)
name|printf
argument_list|(
literal|"(0x%x@0x%x)"
argument_list|,
name|iovp
operator|->
name|iov_len
argument_list|,
name|iovp
operator|->
name|iov_base
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|iovp
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|datalen
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/***********************************************\ 			* Set up the scatter gather block		* 			\***********************************************/
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWSCATGATH
condition|)
name|printf
argument_list|(
literal|"%d @0x%x:- "
argument_list|,
name|xs
operator|->
name|datalen
argument_list|,
name|xs
operator|->
name|data
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|thiskv
operator|=
operator|(
name|int
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|AHA_NSEG
operator|)
condition|)
block|{
name|bytes_this_seg
operator|=
literal|0
expr_stmt|;
comment|/* put in the base address */
name|lto3b
argument_list|(
name|thisphys
argument_list|,
operator|&
operator|(
name|sg
operator|->
name|seg_addr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWSCATGATH
condition|)
name|printf
argument_list|(
literal|"0x%x"
argument_list|,
name|thisphys
argument_list|)
expr_stmt|;
comment|/* do it at least once */
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
comment|/***************************************\ 				* This page is contiguous (physically)	* 				* with the the last, just extend the	* 				* length				* 				\***************************************/
block|{
comment|/** how far to the end of the page ***/
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
comment|/**** or the data ****/
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
comment|/**** get more ready for the next page ****/
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
comment|/***************************************\ 				* next page isn't contiguous, finish the seg* 				\***************************************/
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWSCATGATH
condition|)
name|printf
argument_list|(
literal|"(0x%x)"
argument_list|,
name|bytes_this_seg
argument_list|)
expr_stmt|;
name|lto3b
argument_list|(
name|bytes_this_seg
argument_list|,
operator|&
operator|(
name|sg
operator|->
name|seg_len
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
block|}
name|lto3b
argument_list|(
name|seg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aha_scat_gath
argument_list|)
argument_list|,
name|ccb
operator|->
name|data_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWSCATGATH
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* there's still data, must have run out of segs! */
name|printf
argument_list|(
literal|"aha_scsi_cmd%d: more than %d DMA segs\n"
argument_list|,
name|unit
argument_list|,
name|AHA_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|aha_free_ccb
argument_list|(
name|unit
argument_list|,
name|ccb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* No data xfer, use non S/G values */
name|lto3b
argument_list|(
literal|0
argument_list|,
name|ccb
operator|->
name|data_addr
argument_list|)
expr_stmt|;
name|lto3b
argument_list|(
literal|0
argument_list|,
name|ccb
operator|->
name|data_length
argument_list|)
expr_stmt|;
block|}
name|lto3b
argument_list|(
literal|0
argument_list|,
name|ccb
operator|->
name|link_addr
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* Put the scsi command in the ccb and start it	* 	\***********************************************/
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_RESET
operator|)
condition|)
name|bcopy
argument_list|(
name|xs
operator|->
name|cmd
argument_list|,
operator|&
name|ccb
operator|->
name|scsi_cmd
argument_list|,
name|ccb
operator|->
name|scsi_cmd_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWCOMMANDS
condition|)
block|{
name|u_char
modifier|*
name|b
init|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ccb
operator|->
name|scsi_cmd
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_RESET
operator|)
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"aha%d:%d:%d-"
argument_list|,
name|unit
argument_list|,
name|ccb
operator|->
name|target
argument_list|,
name|ccb
operator|->
name|lun
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|ccb
operator|->
name|scsi_cmd_length
condition|)
block|{
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|b
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"aha%d:%d:%d-RESET- "
argument_list|,
name|unit
argument_list|,
name|ccb
operator|->
name|target
argument_list|,
name|ccb
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* stop instant timeouts */
name|aha_add_timeout
argument_list|(
name|ccb
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|aha_startmbx
argument_list|(
name|ccb
operator|->
name|mbx
argument_list|)
expr_stmt|;
comment|/***********************************************\ 		* Usually return SUCCESSFULLY QUEUED		* 		\***********************************************/
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEINTERRUPTS
condition|)
name|printf
argument_list|(
literal|"sent "
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
name|aha_startmbx
argument_list|(
name|ccb
operator|->
name|mbx
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEINTERRUPTS
condition|)
name|printf
argument_list|(
literal|"cmd_sent, waiting "
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* If we can't use interrupts, poll on completion* 	\***********************************************/
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
name|delaycount
operator|*
name|xs
operator|->
name|timeout
operator|/
name|AHA_SCSI_TIMEOUT_FUDGE
decl_stmt|;
while|while
condition|(
operator|(
operator|!
name|done
operator|)
operator|&&
name|count
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|!
name|done
operator|)
operator|&&
name|i
operator|<
name|AHA_MBX_SIZE
condition|)
block|{
if|if
condition|(
operator|(
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|stat
operator|!=
name|AHA_MBI_FREE
operator|)
operator|&&
operator|(
name|PHYSTOKV
argument_list|(
name|_3btol
argument_list|(
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|ccb_addr
argument_list|)
operator|==
operator|(
name|int
operator|)
name|ccb
argument_list|)
operator|)
condition|)
block|{
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|stat
operator|=
name|AHA_MBI_FREE
expr_stmt|;
name|aha_done
argument_list|(
name|unit
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|done
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|count
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"cmd fail\n"
argument_list|)
expr_stmt|;
name|aha_abortmbx
argument_list|(
name|ccb
operator|->
name|mbx
argument_list|)
expr_stmt|;
name|count
operator|=
name|delaycount
operator|*
literal|2000
operator|/
name|AHA_SCSI_TIMEOUT_FUDGE
expr_stmt|;
while|while
condition|(
operator|(
operator|!
name|done
operator|)
operator|&&
name|count
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|!
name|done
operator|)
operator|&&
name|i
operator|<
name|AHA_MBX_SIZE
condition|)
block|{
if|if
condition|(
operator|(
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|stat
operator|!=
name|AHA_MBI_FREE
operator|)
operator|&&
operator|(
name|PHYSTOKV
argument_list|(
name|_3btol
argument_list|(
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|ccb_addr
argument_list|)
operator|==
operator|(
name|int
operator|)
name|ccb
argument_list|)
operator|)
condition|)
block|{
name|aha_mbx
index|[
name|unit
index|]
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|stat
operator|=
name|AHA_MBI_FREE
expr_stmt|;
name|aha_done
argument_list|(
name|unit
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|done
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|printf
argument_list|(
literal|"abort failed in wait\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|mbx
operator|->
name|cmd
operator|=
name|AHA_MBO_FREE
expr_stmt|;
block|}
name|aha_free_ccb
argument_list|(
name|unit
argument_list|,
name|ccb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ahaintr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
name|ahaintr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|error
condition|)
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/***************************************************************\ * try each speed in turn, when we find one that works, use	* * the NEXT one for a safety margin, unless that doesn't exist	* * or doesn't work. returns the nSEC value of the time used	* * or 0 if it could get a working speed ( or the NEXT speed 	* * failed)							* \***************************************************************/
end_comment

begin_function
name|int
name|aha_set_bus_speed
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|speed
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|retval2
decl_stmt|;
ifdef|#
directive|ifdef
name|EISA
name|speed
operator|=
literal|0
expr_stmt|;
comment|/* start at the fastest */
else|#
directive|else
else|EISA
name|speed
operator|=
literal|1
expr_stmt|;
comment|/* 100 ns can crash some ISA busses (!?!) */
endif|#
directive|endif
endif|EISA
while|while
condition|(
literal|1
condition|)
block|{
name|retval
operator|=
name|aha_bus_speed_check
argument_list|(
name|unit
argument_list|,
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|HAD_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"no working bus speed!!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|speed
operator|++
expr_stmt|;
block|}
else|else
comment|/* Go one slower to be safe */
block|{
comment|/* unless eisa at 100 ns.. trust it */
if|if
condition|(
name|speed
operator|!=
literal|0
condition|)
block|{
name|speed
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d nSEC ok, use "
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|retval2
operator|=
name|aha_bus_speed_check
argument_list|(
name|unit
argument_list|,
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval2
operator|==
name|HAD_ERROR
condition|)
comment|/* retval is slowest already */
block|{
name|printf
argument_list|(
literal|"marginal "
argument_list|)
expr_stmt|;
name|retval2
operator|=
name|retval
expr_stmt|;
block|}
if|if
condition|(
name|retval2
condition|)
block|{
name|printf
argument_list|(
literal|"%d nSEC "
argument_list|,
name|retval2
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval2
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|".. slower failed, abort.\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/***************************************************************\ * Set the DMA speed to the Nth speed and try an xfer. If it	* * fails return 0, if it succeeds return the nSec value selected	* * If there is no such speed return HAD_ERROR.			* \***************************************************************/
end_comment

begin_struct
specifier|static
struct|struct
name|bus_speed
block|{
name|char
name|arg
decl_stmt|;
name|int
name|nsecs
decl_stmt|;
block|}
name|aha_bus_speeds
index|[]
init|=
block|{
block|{
literal|0x88
block|,
literal|100
block|}
block|,
block|{
literal|0x99
block|,
literal|150
block|}
block|,
block|{
literal|0xaa
block|,
literal|200
block|}
block|,
block|{
literal|0xbb
block|,
literal|250
block|}
block|,
block|{
literal|0xcc
block|,
literal|300
block|}
block|,
block|{
literal|0xdd
block|,
literal|350
block|}
block|,
block|{
literal|0xee
block|,
literal|400
block|}
block|,
block|{
literal|0xff
block|,
literal|450
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
name|aha_test_string
index|[]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz!@"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|aha_bus_speed_check
parameter_list|(
name|unit
parameter_list|,
name|speed
parameter_list|)
name|int
name|unit
decl_stmt|,
name|speed
decl_stmt|;
block|{
name|int
name|numspeeds
init|=
sizeof|sizeof
argument_list|(
name|aha_bus_speeds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bus_speed
argument_list|)
decl_stmt|;
name|u_char
name|ad
index|[
literal|3
index|]
decl_stmt|;
comment|/*******************************************************\ 	* Check we have such an entry				* 	\*******************************************************/
if|if
condition|(
name|speed
operator|>=
name|numspeeds
condition|)
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
comment|/* illegal speed */
comment|/*******************************************************\ 	* Set the dma-speed					* 	\*******************************************************/
name|aha_cmd
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_SPEED_SET
argument_list|,
name|aha_bus_speeds
index|[
name|speed
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* put the test data into the buffer and calculate	* 	* it's address. Read it onto the board			* 	\*******************************************************/
name|strcpy
argument_list|(
name|aha_scratch_buf
argument_list|,
name|aha_test_string
argument_list|)
expr_stmt|;
name|lto3b
argument_list|(
name|KVTOPHYS
argument_list|(
name|aha_scratch_buf
argument_list|)
argument_list|,
name|ad
argument_list|)
expr_stmt|;
name|aha_cmd
argument_list|(
name|unit
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_WRITE_FIFO
argument_list|,
name|ad
index|[
literal|0
index|]
argument_list|,
name|ad
index|[
literal|1
index|]
argument_list|,
name|ad
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* clear the buffer then copy the contents back from the	* 	* board.						* 	\*******************************************************/
name|bzero
argument_list|(
name|aha_scratch_buf
argument_list|,
literal|54
argument_list|)
expr_stmt|;
comment|/* 54 bytes transfered by test */
name|aha_cmd
argument_list|(
name|unit
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_READ_FIFO
argument_list|,
name|ad
index|[
literal|0
index|]
argument_list|,
name|ad
index|[
literal|1
index|]
argument_list|,
name|ad
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* Compare the original data and the final data and	* 	* return the correct value depending upon the result	* 	\*******************************************************/
if|if
condition|(
name|strcmp
argument_list|(
name|aha_test_string
argument_list|,
name|aha_scratch_buf
argument_list|)
condition|)
block|{
comment|/* copy failed.. assume too fast */
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* copy succeded assume speed ok */
return|return
operator|(
name|aha_bus_speeds
index|[
name|speed
index|]
operator|.
name|nsecs
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  *                +----------+    +----------+    +----------+  * aha_soonest--->|    later |--->|     later|--->|     later|-->0  *                | [Delta]  |    | [Delta]  |    | [Delta]  |  *           0<---|sooner    |<---|sooner    |<---|sooner    |<---aha_latest  *                +----------+    +----------+    +----------+  *  *     aha_furtherest = sum(Delta[1..n])  */
end_comment

begin_macro
name|aha_add_timeout
argument_list|(
argument|ccb
argument_list|,
argument|time
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|timeprev
decl_stmt|;
name|struct
name|aha_ccb
modifier|*
name|prev
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|prev
operator|=
name|aha_latest
condition|)
comment|/* yes, an assign */
block|{
name|timeprev
operator|=
name|aha_furtherest
expr_stmt|;
block|}
else|else
block|{
name|timeprev
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|prev
operator|&&
operator|(
name|timeprev
operator|>
name|time
operator|)
condition|)
block|{
name|timeprev
operator|-=
name|prev
operator|->
name|delta
expr_stmt|;
name|prev
operator|=
name|prev
operator|->
name|sooner
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|ccb
operator|->
name|delta
operator|=
name|time
operator|-
name|timeprev
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|later
operator|=
name|prev
operator|->
name|later
condition|)
comment|/* yes an assign */
block|{
name|ccb
operator|->
name|later
operator|->
name|sooner
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|later
operator|->
name|delta
operator|-=
name|ccb
operator|->
name|delta
expr_stmt|;
block|}
else|else
block|{
name|aha_furtherest
operator|=
name|time
expr_stmt|;
name|aha_latest
operator|=
name|ccb
expr_stmt|;
block|}
name|ccb
operator|->
name|sooner
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|later
operator|=
name|ccb
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ccb
operator|->
name|later
operator|=
name|aha_soonest
condition|)
comment|/* yes, an assign*/
block|{
name|ccb
operator|->
name|later
operator|->
name|sooner
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|later
operator|->
name|delta
operator|-=
name|time
expr_stmt|;
block|}
else|else
block|{
name|aha_furtherest
operator|=
name|time
expr_stmt|;
name|aha_latest
operator|=
name|ccb
expr_stmt|;
block|}
name|ccb
operator|->
name|delta
operator|=
name|time
expr_stmt|;
name|ccb
operator|->
name|sooner
operator|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
literal|0
expr_stmt|;
name|aha_soonest
operator|=
name|ccb
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|aha_remove_timeout
argument_list|(
argument|ccb
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|sooner
condition|)
block|{
name|ccb
operator|->
name|sooner
operator|->
name|later
operator|=
name|ccb
operator|->
name|later
expr_stmt|;
block|}
else|else
block|{
name|aha_soonest
operator|=
name|ccb
operator|->
name|later
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|later
condition|)
block|{
name|ccb
operator|->
name|later
operator|->
name|sooner
operator|=
name|ccb
operator|->
name|sooner
expr_stmt|;
name|ccb
operator|->
name|later
operator|->
name|delta
operator|+=
name|ccb
operator|->
name|delta
expr_stmt|;
block|}
else|else
block|{
name|aha_latest
operator|=
name|ccb
operator|->
name|sooner
expr_stmt|;
name|aha_furtherest
operator|-=
name|ccb
operator|->
name|delta
expr_stmt|;
block|}
name|ccb
operator|->
name|sooner
operator|=
name|ccb
operator|->
name|later
operator|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ONETICK
value|500
end_define

begin_comment
comment|/* milliseconds */
end_comment

begin_define
define|#
directive|define
name|SLEEPTIME
value|((hz * 1000) / ONETICK)
end_define

begin_macro
name|aha_timeout
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
while|while
condition|(
name|ccb
operator|=
name|aha_soonest
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|delta
operator|<=
name|ONETICK
condition|)
comment|/***********************************************\ 		* It has timed out, we need to do some work	* 		\***********************************************/
block|{
name|unit
operator|=
name|ccb
operator|->
name|xfer
operator|->
name|adapter
expr_stmt|;
name|printf
argument_list|(
literal|"aha%d: device %d timed out "
argument_list|,
name|unit
argument_list|,
name|ccb
operator|->
name|xfer
operator|->
name|targ
argument_list|)
expr_stmt|;
comment|/***************************************\ 			* Unlink it from the queue		* 			\***************************************/
name|aha_remove_timeout
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/***************************************\ 			* If The ccb's mbx is not free, then	* 			* the board has gone south		* 			\***************************************/
if|if
condition|(
name|ccb
operator|->
name|mbx
operator|->
name|cmd
operator|!=
name|AHA_MBO_FREE
condition|)
block|{
name|printf
argument_list|(
literal|"aha%d not taking commands!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|()
expr_stmt|;
block|}
comment|/***************************************\ 			* If it has been through before, then	* 			* a previous abort has failed, don't	* 			* try abort again			* 			\***************************************/
if|if
condition|(
name|ccb
operator|->
name|flags
operator|==
name|CCB_ABORTED
condition|)
comment|/* abort timed out */
block|{
name|printf
argument_list|(
literal|" AGAIN\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|xfer
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* I MEAN IT ! */
name|ccb
operator|->
name|host_stat
operator|=
name|AHA_ABORTED
expr_stmt|;
name|aha_done
argument_list|(
name|unit
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* abort the operation that has timed out */
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|aha_abortmbx
argument_list|(
name|ccb
operator|->
name|mbx
argument_list|)
expr_stmt|;
comment|/* 2 secs for the abort */
name|aha_add_timeout
argument_list|(
name|ccb
argument_list|,
literal|2000
operator|+
name|ONETICK
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|flags
operator|=
name|CCB_ABORTED
expr_stmt|;
block|}
block|}
else|else
comment|/***********************************************\ 		* It has not timed out, adjust and leave	* 		\***********************************************/
block|{
name|ccb
operator|->
name|delta
operator|-=
name|ONETICK
expr_stmt|;
name|aha_furtherest
operator|-=
name|ONETICK
expr_stmt|;
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|aha_timeout
argument_list|,
name|arg
argument_list|,
name|SLEEPTIME
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

