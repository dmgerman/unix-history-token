begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Ported to boot 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  *  * Mach Operating System  * Copyright (c) 1992, 1991 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         1       00159  * --------------------         -----   ----------------------  *  * 23 May 93	Rodney W. Grimes	Added pad to kernel size for structs  *					allocated by locore.s  */
end_comment

begin_comment
comment|/*  * HISTORY  * $Log:	boot.c,v $  * Revision 2.2  92/04/04  11:34:37  rpd  * 	Change date in banner.  * 	[92/04/03  16:51:14  rvb]  *   * 	Fix Intel Copyright as per B. Davies authorization.  * 	[92/04/03            rvb]  * 	From 2.5 version.  * 	[92/03/30            mg32]  *   */
end_comment

begin_comment
comment|/*   Copyright 1988, 1989, 1990, 1991, 1992     by Intel Corporation, Santa Clara, California.                  All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appears in all copies and that both the copyright notice and this permission notice appear in supporting documentation, and that the name of Intel not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  INTEL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL INTEL BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_decl_stmt
name|struct
name|exec
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|argv
index|[
literal|10
index|]
decl_stmt|,
name|esym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|names
index|[]
init|=
block|{
literal|"/386bsd"
block|,
literal|"/386bsd.old"
block|,
literal|"/vmunix"
block|,
literal|"/vmunix.old"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUMNAMES
value|(sizeof(names)/sizeof(char *))
end_define

begin_decl_stmt
specifier|extern
name|int
name|end
decl_stmt|;
end_decl_stmt

begin_macro
name|boot
argument_list|(
argument|drive
argument_list|)
end_macro

begin_decl_stmt
name|int
name|drive
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|loadflags
decl_stmt|,
name|currname
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"\n>> 386bsd BOOT @ 0x%x: %d/%d k of memory  [20/9/92]\n"
argument_list|,
name|ouraddr
argument_list|,
name|argv
index|[
literal|7
index|]
operator|=
name|memsize
argument_list|(
literal|0
argument_list|)
argument_list|,
name|argv
index|[
literal|8
index|]
operator|=
name|memsize
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"use options hd(1,...... to boot sd0 when wd0 is also installed\n"
argument_list|)
expr_stmt|;
name|gateA20
argument_list|()
expr_stmt|;
name|loadstart
label|:
comment|/***************************************************************\ 	* As a default set it to the first partition of the first	* 	* floppy or hard drive						* 	\***************************************************************/
name|part
operator|=
name|unit
operator|=
literal|0
expr_stmt|;
name|maj
operator|=
operator|(
name|drive
operator|&
literal|0x80
condition|?
literal|0
else|:
literal|2
operator|)
expr_stmt|;
comment|/* a good first bet */
name|name
operator|=
name|names
index|[
name|currname
operator|++
index|]
expr_stmt|;
name|loadflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|currname
operator|==
name|NUMNAMES
condition|)
name|currname
operator|=
literal|0
expr_stmt|;
name|getbootdev
argument_list|(
operator|&
name|loadflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|openrd
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"Can't find %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|loadstart
goto|;
block|}
comment|/*	if (inode.i_mode&IEXEC) 		loadflags |= RB_KDB; */
name|loadprog
argument_list|(
name|loadflags
argument_list|)
expr_stmt|;
goto|goto
name|loadstart
goto|;
block|}
end_block

begin_macro
name|loadprog
argument_list|(
argument|howto
argument_list|)
end_macro

begin_decl_stmt
name|int
name|howto
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|int
name|startaddr
decl_stmt|;
name|long
name|int
name|addr
decl_stmt|;
comment|/* physical address.. not directly useable */
name|int
name|i
decl_stmt|;
specifier|static
name|int
function_decl|(
modifier|*
name|x_entry
function_decl|)
parameter_list|()
init|=
literal|0
function_decl|;
name|unsigned
name|char
name|tmpbuf
index|[
literal|4096
index|]
decl_stmt|;
comment|/* we need to load the first 4k here */
name|argv
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|read
argument_list|(
operator|&
name|head
argument_list|,
sizeof|sizeof
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|.
name|a_magic
operator|==
literal|0413
condition|)
block|{
name|poff
operator|=
literal|4096
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Invalid format!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|startaddr
operator|=
operator|(
name|int
operator|)
name|head
operator|.
name|a_entry
expr_stmt|;
name|addr
operator|=
operator|(
name|startaddr
operator|&
literal|0x00f00000
operator|)
expr_stmt|;
comment|/* some MEG boundary */
name|printf
argument_list|(
literal|"Booting %s(%d,%c)%s @ 0x%x\n"
argument_list|,
name|devs
index|[
name|maj
index|]
argument_list|,
name|unit
argument_list|,
literal|'a'
operator|+
name|part
argument_list|,
name|name
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|ouraddr
condition|)
block|{
if|if
condition|(
operator|(
name|addr
operator|+
name|head
operator|.
name|a_text
operator|+
name|head
operator|.
name|a_data
operator|)
operator|>
name|ouraddr
condition|)
block|{
name|printf
argument_list|(
literal|"kernel will not fit below loader\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * The +28672 is for memory allocated by locore.s that must 		 * fit in the bss! 		 */
if|if
condition|(
operator|(
name|addr
operator|+
name|head
operator|.
name|a_text
operator|+
name|head
operator|.
name|a_data
operator|+
name|head
operator|.
name|a_bss
operator|+
literal|28672
operator|)
operator|>
literal|0xa0000
condition|)
block|{
name|printf
argument_list|(
literal|"kernel too big, won't fit in 640K with bss\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Only hope is to link the kernel for> 1MB\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|addr
operator|+
name|head
operator|.
name|a_text
operator|+
name|head
operator|.
name|a_data
operator|+
name|head
operator|.
name|a_bss
operator|)
operator|>
name|ouraddr
condition|)
block|{
name|printf
argument_list|(
literal|"loader overlaps bss, kernel must bzero\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"text=0x%x"
argument_list|,
name|head
operator|.
name|a_text
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* LOAD THE TEXT SEGMENT				*/
comment|/* don't clobber the first 4k yet (BIOS NEEDS IT) 	*/
comment|/********************************************************/
name|read
argument_list|(
name|tmpbuf
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4096
expr_stmt|;
name|xread
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_text
operator|-
literal|4096
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_text
operator|-
literal|4096
expr_stmt|;
comment|/********************************************************/
comment|/* Load the Initialised data after the text		*/
comment|/********************************************************/
while|while
condition|(
name|addr
operator|&
name|CLOFSET
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|addr
operator|++
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|" data=0x%x"
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|xread
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_data
expr_stmt|;
comment|/********************************************************/
comment|/* Skip over the uninitialised data			*/
comment|/* (but clear it)					*/
comment|/********************************************************/
name|printf
argument_list|(
literal|" bss=0x%x"
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|<
name|ouraddr
operator|)
operator|&&
operator|(
operator|(
name|addr
operator|+
name|head
operator|.
name|a_bss
operator|)
operator|>
name|ouraddr
operator|)
condition|)
block|{
name|pbzero
argument_list|(
name|addr
argument_list|,
name|ouraddr
operator|-
operator|(
name|int
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pbzero
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
literal|3
index|]
operator|=
operator|(
name|addr
operator|+=
name|head
operator|.
name|a_bss
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOADSYMS
comment|/* not yet, haven't worked this out yet */
if|if
condition|(
name|addr
operator|>
literal|0x100000
condition|)
block|{
comment|/********************************************************/
comment|/*copy in the symbol header				*/
comment|/********************************************************/
name|pcpy
argument_list|(
operator|&
name|head
operator|.
name|a_syms
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* READ in the symbol table				*/
comment|/********************************************************/
name|printf
argument_list|(
literal|" symbols=[+0x%x"
argument_list|,
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|xread
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_syms
expr_stmt|;
comment|/********************************************************/
comment|/* Followed by the next integer (another header)	*/
comment|/* more debug symbols?					*/
comment|/********************************************************/
name|read
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pcpy
argument_list|(
operator|&
name|i
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* and that many bytes of (debug symbols?)		*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"+0x%x]"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|xread
argument_list|(
name|addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|i
expr_stmt|;
block|}
endif|#
directive|endif
endif|LOADSYMS
comment|/********************************************************/
comment|/* and note the end address of all this			*/
comment|/********************************************************/
name|argv
index|[
literal|4
index|]
operator|=
operator|(
operator|(
name|addr
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" total=0x%x"
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* 	 *  We now pass the various bootstrap parameters to the loaded 	 *  image via the argument list 	 *  (THIS IS A BIT OF HISTORY FROM MACH.. LEAVE FOR NOW) 	 *  arg1 = boot flags 	 *  arg2 = boot device 	 *  arg3 = start of symbol table (0 if not loaded) 	 *  arg4 = end of symbol table (0 if not loaded) 	 *  arg5 = transfer address from image 	 *  arg6 = transfer address for next image pointer 	 */
switch|switch
condition|(
name|maj
condition|)
block|{
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"\n\nInsert file system floppy \n"
argument_list|)
expr_stmt|;
name|getchar
argument_list|()
expr_stmt|;
break|break;
case|case
literal|4
case|:
break|break;
block|}
name|argv
index|[
literal|1
index|]
operator|=
name|howto
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
operator|(
name|MAKEBOOTDEV
argument_list|(
name|maj
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|unit
argument_list|,
name|part
argument_list|)
operator|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|=
operator|(
name|head
operator|.
name|a_entry
operator|&=
literal|0xfffffff
operator|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|=
operator|(
name|int
operator|)
operator|&
name|x_entry
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
literal|8
expr_stmt|;
comment|/****************************************************************/
comment|/* copy that first page and overwrite any BIOS variables	*/
comment|/****************************************************************/
name|printf
argument_list|(
literal|" entry point=0x%x \n"
argument_list|,
operator|(
operator|(
name|int
operator|)
name|startaddr
operator|)
operator|&
literal|0xffffff
argument_list|)
expr_stmt|;
name|pcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|0
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|startprog
argument_list|(
operator|(
operator|(
name|int
operator|)
name|startaddr
operator|&
literal|0xffffff
operator|)
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
name|namebuf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|getbootdev
argument_list|(
argument|howto
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|howto
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|ptr
init|=
name|namebuf
decl_stmt|;
name|printf
argument_list|(
literal|"Boot: [[[%s(%d,%c)]%s][-s][-a][-d]] :- "
argument_list|,
name|devs
index|[
name|maj
index|]
argument_list|,
name|unit
argument_list|,
literal|'a'
operator|+
name|part
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|namebuf
argument_list|)
condition|)
block|{
while|while
condition|(
name|c
operator|=
operator|*
name|ptr
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
operator|*
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|ptr
operator|)
operator|&&
name|c
operator|!=
literal|' '
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
operator|*
name|howto
operator||=
name|RB_ASKNAME
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
operator|*
name|howto
operator||=
name|RB_SINGLE
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
operator|*
name|howto
operator||=
name|RB_KDB
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
operator|*
name|howto
operator||=
name|RB_HALT
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|name
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|ptr
operator|)
operator|&&
name|c
operator|!=
literal|' '
condition|)
empty_stmt|;
if|if
condition|(
name|c
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

end_unit

