begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tp0bridge.c - TCP/X.25 TP0 bridge */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/others/tp0bridge/RCS/tp0bridge.c,v 7.2 91/02/22 09:34:27 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/others/tp0bridge/RCS/tp0bridge.c,v 7.2 91/02/22 09:34:27 mrose Interim $  *  * Contributed by Julian Onions, Nottingham University in the UK  *  *  * $Log:	tp0bridge.c,v $  * Revision 7.2  91/02/22  09:34:27  mrose  * Interim 6.8  *   * Revision 7.1  90/07/09  14:42:52  mrose  * sync  *   * Revision 7.0  89/11/23  22:11:02  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"tpkt.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"internet.h"
end_include

begin_include
include|#
directive|include
file|"x25.h"
end_include

begin_include
include|#
directive|include
file|"logger.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|options
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nbits
init|=
name|FD_SETSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LLog
name|_pgm_log
init|=
block|{
literal|"tp0bridge.log"
block|,
name|NULLCP
block|,
name|NULLCP
block|,
name|LLOG_FATAL
operator||
name|LLOG_EXCEPTIONS
operator||
name|LLOG_NOTICE
block|,
name|LLOG_FATAL
block|,
operator|-
literal|1
block|,
name|LLOGCLS
operator||
name|LLOGCRT
operator||
name|LLOGZER
block|,
name|NOTOK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LLog
modifier|*
name|pgm_log
init|=
operator|&
name|_pgm_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myname
init|=
literal|"tp0bridge"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|myhost
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myprotocol
init|=
literal|"tcp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myservice
init|=
literal|"x25bridge"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcp_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fd_set
name|ifds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|main_in_socket
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
modifier|*
name|mainisock
init|=
operator|&
name|main_in_socket
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|emptyaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fd_set
name|sentinel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sent2list
index|[
name|FD_SETSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|list2sent
index|[
name|FD_SETSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|callbacks
index|[
name|FD_SETSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CAMTEC
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|NSAPaddr
name|listens
index|[
name|FD_SETSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FORK_LISTENER
end_define

begin_comment
comment|/* new process per listener */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|abortfd
argument_list|()
decl_stmt|,
name|shuffle
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|adios
argument_list|()
decl_stmt|,
name|advise
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_function_decl
name|int
name|chldser
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|alrmser
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|fd_set
name|mask
decl_stmt|;
name|arginit
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|envinit
argument_list|()
expr_stmt|;
name|nfds
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|sentinel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tcp_fd
operator|=
name|start_tcp_server
argument_list|(
name|mainisock
argument_list|,
name|SOMAXCONN
argument_list|,
name|options
operator|&
name|SO_DEBUG
condition|?
name|SO_DEBUG
else|:
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"start_tcp_server"
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tcp_fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp_fd
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|tcp_fd
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|chldser
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|mask
operator|=
name|ifds
expr_stmt|;
ifdef|#
directive|ifdef
name|CAMTEC
comment|/* due to problems in select when camtec is enabled, a small 	   timeout is given. This should not affect anything I hope. 	  */
operator|(
name|void
operator|)
name|xselect
argument_list|(
name|nfds
argument_list|,
operator|&
name|mask
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|xselect
argument_list|(
name|nfds
argument_list|,
operator|&
name|mask
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
name|NOTOK
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nbits
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
if|if
condition|(
name|fd
operator|==
name|tcp_fd
condition|)
name|do_new_fd
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|sentinel
argument_list|)
condition|)
name|abortfd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|else
name|do_old_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|BSD42
while|while
condition|(
name|mywait3
argument_list|(
name|NULLIP
argument_list|)
operator|!=
name|NOTOK
condition|)
continue|continue;
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|do_new_fd
argument_list|()
block|{
name|int
name|fd
block|;
name|char
name|c
block|;     struct
name|sockaddr_in
name|zosock
block|;     struct
name|sockaddr_in
operator|*
name|osock
operator|=
operator|&
name|zosock
block|;
if|if
condition|(
operator|(
name|fd
operator|=
name|join_tcp_client
argument_list|(
name|tcp_fd
argument_list|,
name|osock
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"join_tcp_client"
argument_list|)
expr_stmt|;
return|return;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|read_tcp_socket
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"initial read_tcp_socket"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_if

begin_switch
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|1
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"outgoing connection"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
name|OK
case|:
name|do_outgoing
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|NOTOK
case|:
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"TCP socket"
argument_list|,
literal|"no forks, so rejecting connection on"
argument_list|)
expr_stmt|;
default|default:
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXOS
name|FD_CLR
argument_list|(
name|tcp_fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tcp_fd
operator|=
name|start_tcp_server
argument_list|(
name|isock
argument_list|,
name|SOMAXCONN
argument_list|,
name|options
operator|&
name|SO_DEBUG
condition|?
name|SO_DEBUG
else|:
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"start_tcp_server"
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tcp_fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp_fd
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|tcp_fd
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
break|break;
case|case
literal|2
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"setup listen address"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_listen
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown dialogue mode 0x%x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
end_switch

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_macro
unit|static
name|do_outgoing
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sd
decl_stmt|;
name|struct
name|NSAPaddr
name|znsap
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|nsap
init|=
operator|&
name|znsap
decl_stmt|;
ifdef|#
directive|ifdef
name|SOCKETS
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|tcp_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|sd
operator|=
literal|0
init|;
name|sd
operator|<
name|nbits
condition|;
name|sd
operator|++
control|)
if|if
condition|(
name|sd
operator|!=
name|fd
operator|&&
name|FD_ISSET
argument_list|(
name|sd
argument_list|,
operator|&
name|ifds
argument_list|)
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|ll_close
argument_list|(
name|pgm_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|bridge_read_nsap_addr
argument_list|(
name|fd
argument_list|,
name|nsap
argument_list|,
name|read_tcp_socket
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"read of NSAP"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nsap
operator|->
name|na_stack
condition|)
block|{
case|case
name|NA_BRG
case|:
name|nsap
operator|->
name|na_stack
operator|=
name|NA_X25
expr_stmt|;
comment|/* we use real X.25 here */
break|break;
case|case
name|NA_X25
case|:
break|break;
case|case
name|NA_NSAP
case|:
case|case
name|NA_TCP
case|:
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"Addressing style not supported (type %d)"
argument_list|,
name|nsap
operator|->
name|na_stack
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"x25 call on to %*s\n"
argument_list|,
name|nsap
operator|->
name|na_dtelen
argument_list|,
name|nsap
operator|->
name|na_dte
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sd
operator|=
name|start_x25_client
argument_list|(
name|nsap
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"start_x25_client"
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_x25_server
argument_list|(
name|sd
argument_list|,
name|nsap
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"join_x25_server"
argument_list|)
expr_stmt|;
name|transfer
argument_list|(
name|sd
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|do_listen
argument_list|(
argument|fd
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|sockaddr_in
name|in_socket
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|isock
init|=
operator|&
name|in_socket
decl_stmt|;
name|struct
name|NSAPaddr
name|znsap
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|nsap
init|=
operator|&
name|znsap
decl_stmt|;
name|int
name|newfd
decl_stmt|;
if|if
condition|(
name|bridge_read_nsap_addr
argument_list|(
name|fd
argument_list|,
name|nsap
argument_list|,
name|read_tcp_socket
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"read of NSAP"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|nsap
operator|->
name|na_stack
condition|)
block|{
case|case
name|NA_BRG
case|:
name|nsap
operator|->
name|na_stack
operator|=
name|NA_X25
expr_stmt|;
comment|/* we use real X.25 here */
break|break;
case|case
name|NA_X25
case|:
break|break;
case|case
name|NA_NSAP
case|:
case|case
name|NA_TCP
case|:
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"Addressing style not supported (type %d)"
argument_list|,
name|nsap
operator|->
name|na_stack
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"type=%d Listening on '%s' len=%d"
argument_list|,
name|nsap
operator|->
name|na_stack
argument_list|,
name|nsap
operator|->
name|na_dte
argument_list|,
name|nsap
operator|->
name|na_dtelen
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"pid='%s'(%d) fac='%s'(%d) cudf='%s'(%d)"
argument_list|,
name|nsap
operator|->
name|na_pid
argument_list|,
name|nsap
operator|->
name|na_pidlen
argument_list|,
name|nsap
operator|->
name|na_fac
argument_list|,
name|nsap
operator|->
name|na_faclen
argument_list|,
name|nsap
operator|->
name|na_pid
argument_list|,
name|nsap
operator|->
name|na_pidlen
argument_list|,
name|nsap
operator|->
name|na_cudf
argument_list|,
name|nsap
operator|->
name|na_cudflen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|readx
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|isock
argument_list|,
sizeof|sizeof
expr|*
name|isock
argument_list|,
name|read_tcp_socket
argument_list|)
operator|!=
sizeof|sizeof
expr|*
name|isock
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"read_tcp_socket of sockaddr_in"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|isock
operator|->
name|sin_family
operator|=
name|ntohs
argument_list|(
name|isock
operator|->
name|sin_family
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORK_LISTENER
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
name|OK
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbits
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|fd
operator|&&
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|ifds
argument_list|)
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NOTOK
case|:
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"X25 socket"
argument_list|,
literal|"no forks, so rejecting listen on"
argument_list|)
expr_stmt|;
default|default:
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* more from the 'stamp out boring names' committee */
define|#
directive|define
name|iso_defining_new_protocols
value|1
while|while
condition|(
name|iso_defining_new_protocols
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
operator|(
name|newfd
operator|=
name|start_x25_server
argument_list|(
name|nsap
argument_list|,
name|SOMAXCONN
argument_list|,
name|options
operator|&
name|SO_DEBUG
condition|?
name|SO_DEBUG
else|:
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"start_x25_server"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORK_LISTENER
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|CAMTEC
name|listens
index|[
name|newfd
index|]
operator|=
operator|*
name|nsap
expr_stmt|;
comment|/* struct copy */
endif|#
directive|endif
name|callbacks
index|[
name|newfd
index|]
operator|=
operator|*
name|isock
expr_stmt|;
comment|/* struct copy */
comment|/* set up the admin stuff */
name|FD_SET
argument_list|(
name|newfd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
comment|/* listen for new connections */
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
comment|/* listen for problems */
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|sentinel
argument_list|)
expr_stmt|;
name|sent2list
index|[
name|fd
index|]
operator|=
name|newfd
expr_stmt|;
name|list2sent
index|[
name|newfd
index|]
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|newfd
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|newfd
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|FORK_LISTENER
name|do_old_fd
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
block|}
comment|/* loop again */
endif|#
directive|endif
return|return;
name|out
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|do_old_fd
argument_list|(
argument|fd
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|sd
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|isock
init|=
operator|&
name|callbacks
index|[
name|fd
index|]
decl_stmt|;
name|struct
name|NSAPaddr
name|znsap
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|nsap
init|=
operator|&
name|znsap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"callback"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isock
operator|==
name|NULL
operator|||
name|isock
operator|->
name|sin_family
operator|!=
name|AF_INET
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"Callback has bogus address"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sd
operator|=
name|join_x25_client
argument_list|(
name|fd
argument_list|,
name|nsap
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"join_x25_client"
argument_list|)
expr_stmt|;
name|abortfd
argument_list|(
name|list2sent
index|[
name|fd
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"type=%d Accepted '%s' len=%d"
argument_list|,
name|nsap
operator|->
name|na_stack
argument_list|,
name|nsap
operator|->
name|na_dte
argument_list|,
name|nsap
operator|->
name|na_dtelen
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"pid='%s'(%d) fac='%s'(%d) cudf='%s'(%d)"
argument_list|,
name|nsap
operator|->
name|na_pid
argument_list|,
name|nsap
operator|->
name|na_pidlen
argument_list|,
name|nsap
operator|->
name|na_fac
argument_list|,
name|nsap
operator|->
name|na_faclen
argument_list|,
name|nsap
operator|->
name|na_pid
argument_list|,
name|nsap
operator|->
name|na_pidlen
argument_list|,
name|nsap
operator|->
name|na_cudf
argument_list|,
name|nsap
operator|->
name|na_cudflen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nsap
operator|->
name|na_stack
operator|=
name|NA_BRG
expr_stmt|;
ifdef|#
directive|ifdef
name|CAMTEC
comment|/* get back addressing info for this fd into nsap 	 */
name|nsap
operator|=
operator|&
name|listens
index|[
name|fd
index|]
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
name|OK
case|:
break|break;
case|case
name|NOTOK
case|:
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"X.25 socket"
argument_list|,
literal|"no forks, so rejecting connection on"
argument_list|)
expr_stmt|;
default|default:
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|CAMTEC
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nbits
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|fd
operator|!=
name|sd
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|ll_close
argument_list|(
name|pgm_log
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"connecting to %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|isock
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"port=%d"
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
name|isock
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|fd
operator|=
name|start_tcp_client
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"start_tcp_client"
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_tcp_server
argument_list|(
name|fd
argument_list|,
name|isock
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"join_tcp_server"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bridge_write_nsap_addr
argument_list|(
name|fd
argument_list|,
name|nsap
argument_list|,
name|write_tcp_socket
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"write of NSAP"
argument_list|)
expr_stmt|;
name|transfer
argument_list|(
name|sd
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|transfer
argument_list|(
argument|sd
argument_list|,
argument|fd
argument_list|)
name|int
name|sd
operator|,
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|mfds
decl_stmt|;
name|fd_set
name|rfds
decl_stmt|,
name|mask
decl_stmt|;
name|struct
name|tsapblk
modifier|*
name|tcpb
decl_stmt|,
modifier|*
name|x25b
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|rfds
argument_list|)
expr_stmt|;
name|mfds
operator|=
operator|(
name|sd
operator|>
name|fd
condition|?
name|sd
else|:
name|fd
operator|)
operator|+
literal|1
expr_stmt|;
name|FD_SET
argument_list|(
name|sd
argument_list|,
operator|&
name|rfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|rfds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tcpb
operator|=
name|newtblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|tcpb
operator|->
name|tb_fd
operator|=
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|TTService
argument_list|(
name|tcpb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x25b
operator|=
name|newtblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|x25b
operator|->
name|tb_fd
operator|=
name|sd
expr_stmt|;
operator|(
name|void
operator|)
name|XTService
argument_list|(
name|x25b
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CAMTEC
for|for
control|(
init|;
condition|;
control|)
block|{
name|mask
operator|=
name|rfds
expr_stmt|;
if|if
condition|(
name|xselect
argument_list|(
name|mfds
argument_list|,
operator|&
name|mask
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
name|NOTOK
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"xselect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|sd
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
name|shuffle
argument_list|(
name|x25b
argument_list|,
name|tcpb
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
name|shuffle
argument_list|(
name|tcpb
argument_list|,
name|x25b
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|mfds
operator|=
name|fd
operator|+
literal|1
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|xselect
argument_list|(
name|mfds
argument_list|,
operator|&
name|mask
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"xselect tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"tcp -> x25"
argument_list|)
expr_stmt|;
name|shuffle
argument_list|(
name|tcpb
argument_list|,
name|x25b
argument_list|)
expr_stmt|;
block|}
name|FD_ZERO
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|mfds
operator|=
name|sd
operator|+
literal|1
expr_stmt|;
name|FD_SET
argument_list|(
name|sd
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|xselect
argument_list|(
name|mfds
argument_list|,
operator|&
name|mask
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"xselect x25"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|sd
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"x25 -> tcp"
argument_list|)
expr_stmt|;
name|shuffle
argument_list|(
name|x25b
argument_list|,
name|tcpb
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|void
name|shuffle
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|struct
name|tsapblk
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|udvec
modifier|*
name|uv
decl_stmt|;
specifier|register
name|struct
name|tsapkt
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|fd2tpkt
argument_list|(
name|from
operator|->
name|tb_fd
argument_list|,
name|from
operator|->
name|tb_initfnx
argument_list|,
name|from
operator|->
name|tb_readfnx
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|t
operator|->
name|t_errno
operator|!=
name|OK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"fd2tpkt failed (%d)"
argument_list|,
name|t
condition|?
name|t
operator|->
name|t_errno
else|:
name|NOTOK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"read: code=0x%x user len=%d"
argument_list|,
name|TPDU_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
operator|->
name|t_qbuf
condition|?
name|t
operator|->
name|t_qbuf
operator|->
name|qb_len
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uv
operator|=
name|t
operator|->
name|t_udvec
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_qbuf
condition|)
block|{
name|uv
operator|->
name|uv_base
operator|=
name|t
operator|->
name|t_qbuf
operator|->
name|qb_data
expr_stmt|;
name|uv
operator|->
name|uv_len
operator|=
name|t
operator|->
name|t_qbuf
operator|->
name|qb_len
expr_stmt|;
name|uv
operator|++
expr_stmt|;
block|}
name|uv
operator|->
name|uv_base
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tpkt2fd
argument_list|(
name|to
operator|->
name|tb_fd
argument_list|,
name|t
argument_list|,
name|to
operator|->
name|tb_writefnx
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"tpkt2fd failed (%d)"
argument_list|,
name|t
operator|->
name|t_errno
argument_list|)
expr_stmt|;
name|freetpkt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|abortfd
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|assocfd
init|=
name|sent2list
index|[
name|fd
index|]
decl_stmt|;
comment|/* get fd that is listening on */
ifdef|#
directive|ifdef
name|DEBUG
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"Shutdown listen (%d,%d)"
argument_list|,
name|fd
argument_list|,
name|assocfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|sentinel
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|assocfd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_x25_socket
argument_list|(
name|assocfd
argument_list|)
expr_stmt|;
name|sent2list
index|[
name|fd
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|list2sent
index|[
name|assocfd
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|callbacks
index|[
name|assocfd
index|]
operator|=
name|emptyaddr
expr_stmt|;
comment|/* struct copy */
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|arginit
argument_list|(
argument|vec
argument_list|)
name|char
operator|*
operator|*
name|vec
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|port
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|myname
operator|=
name|rindex
argument_list|(
operator|*
name|vec
argument_list|,
literal|'/'
argument_list|)
condition|)
name|myname
operator|++
expr_stmt|;
if|if
condition|(
name|myname
operator|==
name|NULL
operator|||
operator|*
name|myname
operator|==
name|NULL
condition|)
name|myname
operator|=
operator|*
name|vec
expr_stmt|;
name|isodetailor
argument_list|(
name|myname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|myhost
argument_list|,
sizeof|sizeof
name|myhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|myhost
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|myhost
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
name|myservice
argument_list|,
name|myprotocol
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|mainisock
operator|->
name|sin_port
operator|=
name|x25_bridge_port
expr_stmt|;
else|else
name|mainisock
operator|->
name|sin_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
name|mainisock
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|mainisock
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
operator|(
name|nbits
operator|=
name|getdtablesize
argument_list|()
operator|)
operator|>
name|FD_SETSIZE
condition|)
name|nbits
operator|=
name|FD_SETSIZE
expr_stmt|;
for|for
control|(
name|vec
operator|++
init|;
name|ap
operator|=
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|ap
condition|)
block|{
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
operator|||
operator|(
name|port
operator|=
name|atoi
argument_list|(
name|ap
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -p portno"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|mainisock
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s: unknown switch"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s [switches]"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|envinit
argument_list|()
block|{
name|int
name|i
block|,
name|sd
block|;
if|if
condition|(
name|debug
operator|==
literal|0
operator|&&
operator|!
operator|(
name|debug
operator|=
name|isatty
argument_list|(
literal|2
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|OK
case|:
break|break;
default|default:
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_break
break|break;
end_break

begin_expr_stmt
unit|}  	(
name|void
end_expr_stmt

begin_expr_stmt
unit|)
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|sd
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|sd
argument_list|,
literal|0
argument_list|)
operator|,
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SETSID
end_ifdef

begin_if
if|if
condition|(
name|setsid
argument_list|()
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"setsid"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCNOTTY
end_ifdef

begin_if
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|sd
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_block
unit|}     else
block|{
name|options
operator||=
name|SO_DEBUG
expr_stmt|;
name|ll_dbinit
argument_list|(
name|pgm_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|sun
end_ifndef

begin_comment
comment|/* damn YP... */
end_comment

begin_for
for|for
control|(
name|sd
operator|=
literal|3
init|;
name|sd
operator|<
name|nbits
condition|;
name|sd
operator|++
control|)
if|if
condition|(
name|pgm_log
operator|->
name|ll_fd
operator|!=
name|sd
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
end_for

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"starting"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_expr_stmt
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"options=0x%x port=%d"
argument_list|,
name|options
argument_list|,
name|ntohs
argument_list|(
name|mainisock
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/*
comment|Berkeley UNIX: 4.2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
unit|static
name|int
name|chldser
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|sc
parameter_list|)
name|int
name|sig
decl_stmt|;
name|long
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|sc
decl_stmt|;
block|{
name|union
name|wait
name|status
decl_stmt|;
while|while
condition|(
name|wait3
argument_list|(
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
name|NULL
argument_list|)
operator|>
literal|0
condition|)
continue|continue;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*
comment|AT&T UNIX: 5 */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_define
define|#
directive|define
name|WAITSECS
value|((unsigned) 2)
end_define

begin_decl_stmt
specifier|static
name|jmp_buf
name|jmpenv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|alrmser
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alrmser
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|jmpenv
argument_list|,
name|NOTOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mywait3
parameter_list|(
name|status
parameter_list|)
name|int
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|jmpenv
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alrmser
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|WAITSECS
argument_list|)
expr_stmt|;
name|result
operator|=
name|wait
argument_list|(
name|status
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NOTOK
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|readx
parameter_list|(
name|fd
parameter_list|,
name|buffer
parameter_list|,
name|n
parameter_list|,
name|readfnx
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|n
decl_stmt|;
name|IFP
name|readfnx
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|cc
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|buffer
operator|,
name|i
operator|=
name|n
init|;
name|i
operator|>
literal|0
condition|;
name|bp
operator|+=
name|cc
operator|,
name|i
operator|-=
name|cc
control|)
block|{
switch|switch
condition|(
name|cc
operator|=
call|(
modifier|*
name|readfnx
call|)
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|,
name|i
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
operator|(
name|i
operator|=
name|bp
operator|-
name|buffer
operator|)
condition|?
name|i
else|:
name|NOTOK
return|;
case|case
name|OK
case|:
break|break;
default|default:
continue|continue;
block|}
break|break;
block|}
return|return
operator|(
name|bp
operator|-
name|buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|ERRORS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|adios
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_ll_log
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_FATAL
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|adios
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|adios
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|advise
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|int
name|code
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|_ll_log
argument_list|(
name|pgm_log
argument_list|,
name|code
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|advise
parameter_list|(
name|code
parameter_list|,
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|advise
argument_list|(
name|code
argument_list|,
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

