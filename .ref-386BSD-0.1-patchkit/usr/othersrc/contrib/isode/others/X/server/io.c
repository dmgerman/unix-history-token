begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: io.c,v 1.49 88/09/06 15:50:44 jim Exp $ */
end_comment

begin_comment
comment|/*****************************************************************  * i/o functions  *  *   WriteToClient, ReadRequestFromClient  *  *****************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"Xos.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"os.h"
end_include

begin_include
include|#
directive|include
file|"osdep.h"
end_include

begin_include
include|#
directive|include
file|"opaque.h"
end_include

begin_include
include|#
directive|include
file|"dixstruct.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_include
include|#
directive|include
file|<isode/tsap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|ClientsWithInput
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|ClientsWriteBlocked
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|OutputPending
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|OutputBufferSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ClientPtr
name|ConnectionTranslation
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Bool
name|NewOutputPending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Bool
name|AnyClientsWriteBlocked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Bool
name|CriticalOutputPending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timesThisConnection
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|request_length
parameter_list|(
name|req
parameter_list|,
name|cli
parameter_list|)
value|((cli->swapped ? \ 	lswaps((req)->length) : (req)->length)<< 2)
end_define

begin_define
define|#
directive|define
name|MAX_TIMES_PER
value|10
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_comment
comment|/*  * Convenience Routines  */
end_comment

begin_macro
name|TWriteToClient
argument_list|(
argument|sd
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sd
decl_stmt|,
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
if|if
condition|(
name|TDataRequest
argument_list|(
name|sd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TWriteToClient: %s\n"
argument_list|,
name|td
operator|->
name|td_reason
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * sd = transport descriptor  * iov is iovec of iovcnt buffers  */
end_comment

begin_macro
name|TWritevToClient
argument_list|(
argument|sd
argument_list|,
argument|iov
argument_list|,
argument|iovcnt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sd
decl_stmt|,
name|iovcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|tot
init|=
literal|0
decl_stmt|;
name|struct
name|udvec
name|uv
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|uvp
init|=
name|uv
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
comment|/*  * Grotty hack  */
if|if
condition|(
name|iovcnt
operator|>=
literal|64
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Oh Spaghettio\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iovcnt
condition|;
name|i
operator|++
operator|,
name|uvp
operator|++
operator|,
name|iov
operator|++
control|)
block|{
name|uvp
operator|->
name|uv_base
operator|=
name|iov
operator|->
name|iov_base
expr_stmt|;
name|uvp
operator|->
name|uv_len
operator|=
name|iov
operator|->
name|iov_len
expr_stmt|;
name|tot
operator|+=
name|iov
operator|->
name|iov_len
expr_stmt|;
block|}
name|uvp
operator|->
name|uv_base
operator|=
name|NULL
expr_stmt|;
name|uvp
operator|->
name|uv_len
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|TWriteRequest
argument_list|(
name|sd
argument_list|,
name|uv
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NOTOK
condition|)
block|{
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
if|if
condition|(
name|isodexbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TWritevToCl: %s\n"
argument_list|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISODEBUG */
return|return
name|ret
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TWritevToCl to %d: %d\n"
argument_list|,
name|sd
argument_list|,
name|tot
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISODEBUG */
return|return
name|tot
return|;
block|}
block|}
end_block

begin_macro
name|TAcceptFromClient
argument_list|(
argument|fd
argument_list|,
argument|vecp
argument_list|,
argument|vec
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vecp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
name|struct
name|TSAPstart
name|tsts
decl_stmt|;
name|struct
name|TSAPstart
modifier|*
name|tst
init|=
operator|&
name|tsts
decl_stmt|;
if|if
condition|(
name|TInit
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|,
name|tst
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|Error
argument_list|(
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"TInit"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|TConnResponse
argument_list|(
name|tst
operator|->
name|ts_sd
argument_list|,
name|NULLTA
argument_list|,
name|tst
operator|->
name|ts_expedited
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
operator|(
name|tst
operator|->
name|ts_qos
operator|)
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|Error
argument_list|(
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"TConnResponse"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|tst
operator|->
name|ts_sd
return|;
block|}
end_block

begin_macro
name|TDiscFromClient
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
if|if
condition|(
name|TDiscRequest
argument_list|(
name|fd
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
operator|&
name|tds
argument_list|)
operator|==
name|NOTOK
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TDisc Failed %s\n"
argument_list|,
name|TErrString
argument_list|(
name|tds
operator|.
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_comment
comment|/*****************************************************************  * ReadRequestFromClient  *    Returns one request from client.  If the client misbehaves,  *    returns NULL.  The dispatcher closes down all misbehaving clients.    *  *        client:  index into bit array returned from WaitForSomething()   *  *        status: status is set to  *> 0 the number of bytes in the request if the read is sucessful   *            = 0 if action would block (entire request not ready)  *< 0 indicates an error (probably client died)  *  *        oldbuf:  *            To facilitate buffer management (e.g. on multi-processor  *            systems), the diX layer must tell the OS layer when it is   *            done with a request, so the parameter oldbuf is a pointer   *            to a request that diX is finished with.  In the   *            sample implementation, which is single threaded,  *            oldbuf is ignored.  We assume that when diX calls  *            ReadRequestFromClient(), the previous buffer is finished with.  *  *    The returned string returned must be contiguous so that it can be  *    cast in the dispatcher to the correct request type.  Because requests  *    are variable length, ReadRequestFromClient() must look at the first 4  *    bytes of a request to determine the length (the request length is  *    always the 3rd byte in the request).    *  *    Note: in order to make the server scheduler (WaitForSomething())  *    "fair", the ClientsWithInput mask is used.  This mask tells which  *    clients have FULL requests left in their buffers.  Clients with  *    partial requests require a read.  Basically, client buffers  *    are drained before select() is called again.  But, we can't keep  *    reading from a client that is sending buckets of data (or has  *    a partial request) because others clients need to be scheduled.  *****************************************************************/
end_comment

begin_decl_stmt
name|ConnectionInput
name|inputBuffers
index|[
name|MAXSOCKS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers for clients */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|char
modifier|*
name|ReadRequestFromClient
parameter_list|(
name|who
parameter_list|,
name|status
parameter_list|,
name|oldbuf
parameter_list|)
name|ClientPtr
name|who
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
comment|/* read at least n from client */
name|char
modifier|*
name|oldbuf
decl_stmt|;
block|{
define|#
directive|define
name|YieldControl
parameter_list|()
define|\
value|{ isItTimeToYield = TRUE;		\ 	  timesThisConnection = 0; }
define|#
directive|define
name|YieldControlNoInput
parameter_list|()
define|\
value|{ YieldControl();			\ 	  BITCLEAR(ClientsWithInput, client); }
define|#
directive|define
name|YieldControlAndReturnNull
parameter_list|()
define|\
value|{ YieldControlNoInput();		\ 	  return((char *) NULL ); }
name|OsCommPtr
name|oc
init|=
operator|(
name|OsCommPtr
operator|)
name|who
operator|->
name|osPrivate
decl_stmt|;
name|int
name|client
init|=
name|oc
operator|->
name|fd
decl_stmt|;
name|int
name|result
decl_stmt|,
name|gotnow
decl_stmt|,
name|needed
decl_stmt|;
specifier|register
name|ConnectionInput
modifier|*
name|pBuff
decl_stmt|;
specifier|register
name|xReq
modifier|*
name|request
decl_stmt|;
comment|/* ignore oldbuf, just assume we're done with prev. buffer */
if|if
condition|(
name|client
operator|==
operator|-
literal|1
condition|)
block|{
name|ErrorF
argument_list|(
literal|"OH NO, %d translates to -1\n"
argument_list|,
name|who
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|pBuff
operator|=
operator|&
name|inputBuffers
index|[
name|client
index|]
expr_stmt|;
name|pBuff
operator|->
name|bufptr
operator|+=
name|pBuff
operator|->
name|lenLastReq
expr_stmt|;
name|pBuff
operator|->
name|lenLastReq
operator|=
literal|0
expr_stmt|;
comment|/* handle buffer empty or full case first */
if|if
condition|(
operator|(
name|pBuff
operator|->
name|bufptr
operator|-
name|pBuff
operator|->
name|buffer
operator|)
operator|>=
name|pBuff
operator|->
name|bufcnt
condition|)
block|{
ifdef|#
directive|ifdef
name|ISOCONN
name|result
operator|=
name|SRead
argument_list|(
name|client
argument_list|,
name|pBuff
operator|->
name|buffer
argument_list|,
name|pBuff
operator|->
name|size
argument_list|,
name|OK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|result
operator|=
name|read
argument_list|(
name|client
argument_list|,
name|pBuff
operator|->
name|buffer
argument_list|,
name|pBuff
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
operator|*
name|status
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|YieldControlAndReturnNull
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
operator|*
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|YieldControlAndReturnNull
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pBuff
operator|->
name|bufcnt
operator|=
name|result
expr_stmt|;
comment|/* free up some space after huge requests */
if|if
condition|(
operator|(
name|pBuff
operator|->
name|size
operator|>
name|BUFWATERMARK
operator|)
operator|&&
operator|(
name|result
operator|<
name|BUFSIZE
operator|)
condition|)
block|{
name|pBuff
operator|->
name|size
operator|=
name|BUFSIZE
expr_stmt|;
name|pBuff
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|pBuff
operator|->
name|buffer
argument_list|,
name|pBuff
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|pBuff
operator|->
name|bufptr
operator|=
name|pBuff
operator|->
name|buffer
expr_stmt|;
block|}
block|}
comment|/* now look if there is enough in the buffer */
name|request
operator|=
operator|(
name|xReq
operator|*
operator|)
name|pBuff
operator|->
name|bufptr
expr_stmt|;
name|gotnow
operator|=
name|pBuff
operator|->
name|bufcnt
operator|+
name|pBuff
operator|->
name|buffer
operator|-
name|pBuff
operator|->
name|bufptr
expr_stmt|;
if|if
condition|(
name|gotnow
operator|<
sizeof|sizeof
argument_list|(
name|xReq
argument_list|)
condition|)
name|needed
operator|=
sizeof|sizeof
argument_list|(
name|xReq
argument_list|)
operator|-
name|gotnow
expr_stmt|;
else|else
block|{
name|needed
operator|=
name|request_length
argument_list|(
name|request
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
name|needed
operator|>
name|MAXBUFSIZE
condition|)
block|{
operator|*
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|YieldControlAndReturnNull
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|needed
operator|<=
literal|0
condition|)
name|needed
operator|=
sizeof|sizeof
argument_list|(
name|xReq
argument_list|)
expr_stmt|;
block|}
comment|/* if the needed amount won't fit in what's remaining, 	   move everything to the front of the buffer.  If the 	   entire header isn't available, move what's there too */
if|if
condition|(
operator|(
name|pBuff
operator|->
name|bufptr
operator|+
name|needed
operator|-
name|pBuff
operator|->
name|buffer
operator|>
name|pBuff
operator|->
name|size
operator|)
operator|||
operator|(
name|gotnow
operator|<
sizeof|sizeof
argument_list|(
name|xReq
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|pBuff
operator|->
name|bufptr
argument_list|,
name|pBuff
operator|->
name|buffer
argument_list|,
name|gotnow
argument_list|)
expr_stmt|;
name|pBuff
operator|->
name|bufcnt
operator|=
name|gotnow
expr_stmt|;
if|if
condition|(
name|needed
operator|>
name|pBuff
operator|->
name|size
condition|)
block|{
name|pBuff
operator|->
name|size
operator|=
name|needed
expr_stmt|;
name|pBuff
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|pBuff
operator|->
name|buffer
argument_list|,
name|needed
argument_list|)
expr_stmt|;
block|}
name|pBuff
operator|->
name|bufptr
operator|=
name|pBuff
operator|->
name|buffer
expr_stmt|;
block|}
comment|/* don't have a full header */
if|if
condition|(
name|gotnow
operator|<
sizeof|sizeof
argument_list|(
name|xReq
argument_list|)
condition|)
block|{
while|while
condition|(
name|pBuff
operator|->
name|bufcnt
operator|+
name|pBuff
operator|->
name|buffer
operator|-
name|pBuff
operator|->
name|bufptr
operator|<
sizeof|sizeof
argument_list|(
name|xReq
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ISOCONN
name|result
operator|=
name|SRead
argument_list|(
name|client
argument_list|,
name|pBuff
operator|->
name|buffer
operator|+
name|pBuff
operator|->
name|bufcnt
argument_list|,
name|pBuff
operator|->
name|size
operator|-
name|pBuff
operator|->
name|bufcnt
argument_list|,
name|OK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|result
operator|=
name|read
argument_list|(
name|client
argument_list|,
name|pBuff
operator|->
name|buffer
operator|+
name|pBuff
operator|->
name|bufcnt
argument_list|,
name|pBuff
operator|->
name|size
operator|-
name|pBuff
operator|->
name|bufcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
operator|*
name|status
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|YieldControlAndReturnNull
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
operator|*
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|YieldControlAndReturnNull
argument_list|()
expr_stmt|;
block|}
name|pBuff
operator|->
name|bufcnt
operator|+=
name|result
expr_stmt|;
block|}
name|request
operator|=
operator|(
name|xReq
operator|*
operator|)
name|pBuff
operator|->
name|bufptr
expr_stmt|;
name|gotnow
operator|=
name|pBuff
operator|->
name|bufcnt
operator|+
name|pBuff
operator|->
name|buffer
operator|-
name|pBuff
operator|->
name|bufptr
expr_stmt|;
name|needed
operator|=
name|request_length
argument_list|(
name|request
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
name|needed
operator|<=
literal|0
condition|)
name|needed
operator|=
sizeof|sizeof
argument_list|(
name|xReq
argument_list|)
expr_stmt|;
if|if
condition|(
name|needed
operator|>
name|pBuff
operator|->
name|size
condition|)
block|{
name|pBuff
operator|->
name|size
operator|=
name|needed
expr_stmt|;
name|pBuff
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|pBuff
operator|->
name|buffer
argument_list|,
name|needed
argument_list|)
expr_stmt|;
block|}
name|pBuff
operator|->
name|bufptr
operator|=
name|pBuff
operator|->
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|gotnow
operator|<
name|needed
condition|)
block|{
name|int
name|i
decl_stmt|,
name|wanted
decl_stmt|;
name|wanted
operator|=
name|needed
operator|-
name|gotnow
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|wanted
condition|)
block|{
ifdef|#
directive|ifdef
name|ISOCONN
name|result
operator|=
name|SRead
argument_list|(
name|client
argument_list|,
name|pBuff
operator|->
name|buffer
operator|+
name|pBuff
operator|->
name|bufcnt
argument_list|,
name|pBuff
operator|->
name|size
operator|-
name|pBuff
operator|->
name|bufcnt
argument_list|,
name|OK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|result
operator|=
name|read
argument_list|(
name|client
argument_list|,
name|pBuff
operator|->
name|buffer
operator|+
name|pBuff
operator|->
name|bufcnt
argument_list|,
name|pBuff
operator|->
name|size
operator|-
name|pBuff
operator|->
name|bufcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
operator|*
name|status
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|YieldControlAndReturnNull
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
operator|*
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|YieldControlAndReturnNull
argument_list|()
expr_stmt|;
block|}
name|i
operator|+=
name|result
expr_stmt|;
name|pBuff
operator|->
name|bufcnt
operator|+=
name|result
expr_stmt|;
block|}
block|}
operator|*
name|status
operator|=
name|needed
expr_stmt|;
name|pBuff
operator|->
name|lenLastReq
operator|=
name|needed
expr_stmt|;
comment|/*      *  Check to see if client has at least one whole request in the      *  buffer.  If there is only a partial request, treat like buffer      *  is empty so that select() will be called again and other clients      *  can get into the queue.         */
name|timesThisConnection
operator|++
expr_stmt|;
if|if
condition|(
name|pBuff
operator|->
name|bufcnt
operator|+
name|pBuff
operator|->
name|buffer
operator|>=
name|pBuff
operator|->
name|bufptr
operator|+
name|needed
operator|+
sizeof|sizeof
argument_list|(
name|xReq
argument_list|)
condition|)
block|{
name|request
operator|=
operator|(
name|xReq
operator|*
operator|)
operator|(
name|pBuff
operator|->
name|bufptr
operator|+
name|needed
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pBuff
operator|->
name|bufcnt
operator|+
name|pBuff
operator|->
name|buffer
operator|)
operator|>=
operator|(
operator|(
name|char
operator|*
operator|)
name|request
operator|+
name|request_length
argument_list|(
name|request
argument_list|,
name|who
argument_list|)
operator|)
condition|)
name|BITSET
argument_list|(
name|ClientsWithInput
argument_list|,
name|client
argument_list|)
expr_stmt|;
else|else
name|YieldControlNoInput
argument_list|()
expr_stmt|;
block|}
else|else
name|YieldControlNoInput
argument_list|()
expr_stmt|;
if|if
condition|(
name|timesThisConnection
operator|==
name|MAX_TIMES_PER
condition|)
name|YieldControl
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|pBuff
operator|->
name|bufptr
operator|)
return|;
undef|#
directive|undef
name|YieldControlAndReturnNull
undef|#
directive|undef
name|YieldControlNoInput
undef|#
directive|undef
name|YieldControl
block|}
end_function

begin_comment
comment|/* lookup table for adding padding bytes to data that is read from     	or written to the X socket.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|padlength
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/********************  * FlushClient()  *    If the client isn't keeping up with us, then we try to continue  *    buffering the data and set the apropriate bit in ClientsWritable  *    (which is used by WaitFor in the select).  If the connection yields  *    a permanent error, or we can't allocate any more space, we then  *    close the connection.  *  **********************/
end_comment

begin_function
specifier|static
name|int
name|FlushClient
parameter_list|(
name|who
parameter_list|,
name|oc
parameter_list|,
name|extraBuf
parameter_list|,
name|extraCount
parameter_list|)
name|ClientPtr
name|who
decl_stmt|;
name|OsCommPtr
name|oc
decl_stmt|;
name|char
modifier|*
name|extraBuf
decl_stmt|;
name|int
name|extraCount
decl_stmt|;
comment|/* do not modify... returned below */
block|{
name|int
name|connection
init|=
name|oc
operator|->
name|fd
decl_stmt|,
name|total
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|notWritten
decl_stmt|,
name|written
decl_stmt|,
name|iovCnt
init|=
literal|0
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|3
index|]
decl_stmt|;
name|char
name|padBuffer
index|[
literal|3
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|total
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oc
operator|->
name|count
condition|)
block|{
name|total
operator|+=
name|iov
index|[
name|iovCnt
index|]
operator|.
name|iov_len
operator|=
name|oc
operator|->
name|count
expr_stmt|;
name|iov
index|[
name|iovCnt
operator|++
index|]
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|oc
operator|->
name|buf
expr_stmt|;
comment|/* Notice that padding isn't needed for oc->buf since            it is alreay padded by WriteToClient */
block|}
if|if
condition|(
name|extraCount
condition|)
block|{
name|total
operator|+=
name|iov
index|[
name|iovCnt
index|]
operator|.
name|iov_len
operator|=
name|extraCount
expr_stmt|;
name|iov
index|[
name|iovCnt
operator|++
index|]
operator|.
name|iov_base
operator|=
name|extraBuf
expr_stmt|;
if|if
condition|(
name|extraCount
operator|&
literal|3
condition|)
block|{
name|total
operator|+=
name|iov
index|[
name|iovCnt
index|]
operator|.
name|iov_len
operator|=
name|padlength
index|[
name|extraCount
operator|&
literal|3
index|]
expr_stmt|;
name|iov
index|[
name|iovCnt
operator|++
index|]
operator|.
name|iov_base
operator|=
name|padBuffer
expr_stmt|;
block|}
block|}
name|notWritten
operator|=
name|total
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
while|while
condition|(
operator|(
name|n
operator|=
name|SWritev
argument_list|(
name|connection
argument_list|,
name|iov
argument_list|,
name|iovCnt
argument_list|)
operator|)
operator|!=
name|notWritten
condition|)
else|#
directive|else
comment|/* ISOCONN */
while|while
condition|(
operator|(
name|n
operator|=
name|writev
argument_list|(
name|connection
argument_list|,
name|iov
argument_list|,
name|iovCnt
argument_list|)
operator|)
operator|!=
name|notWritten
condition|)
endif|#
directive|endif
comment|/* ISOCONN */
block|{
ifdef|#
directive|ifdef
name|hpux
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EMSGSIZE
condition|)
name|n
operator|=
name|swWritev
argument_list|(
name|connection
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|notWritten
operator|-=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iovCnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|>
name|iov
index|[
name|i
index|]
operator|.
name|iov_len
condition|)
block|{
name|n
operator|-=
name|iov
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
name|iov
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|iov
index|[
name|i
index|]
operator|.
name|iov_len
operator|-=
name|n
expr_stmt|;
name|iov
index|[
name|i
index|]
operator|.
name|iov_base
operator|+=
name|n
expr_stmt|;
break|break;
block|}
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|errno
operator|!=
name|EBADF
condition|)
name|ErrorF
argument_list|(
literal|"Closing connection %d because write failed\n"
argument_list|,
name|connection
argument_list|)
expr_stmt|;
comment|/* this close will cause the select in WaitForSomething 		   to return that the connection is dead, so we can actually 		   clean up after the client.  We can't clean up here, 		   because the we're in the middle of doing something 		   and will probably screw up some data strucutres */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISOCONN
name|SClose
argument_list|(
name|connection
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|close
argument_list|(
name|connection
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|MarkClientException
argument_list|(
name|who
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* If we've arrived here, then the client is stuffed to the gills 	   and not ready to accept more.  Make a note of it and buffer 	   the rest. */
name|BITSET
argument_list|(
name|ClientsWriteBlocked
argument_list|,
name|connection
argument_list|)
expr_stmt|;
name|AnyClientsWriteBlocked
operator|=
name|TRUE
expr_stmt|;
name|written
operator|=
name|total
operator|-
name|notWritten
expr_stmt|;
if|if
condition|(
name|written
operator|<
name|oc
operator|->
name|count
condition|)
block|{
if|if
condition|(
name|written
operator|>
literal|0
condition|)
block|{
name|oc
operator|->
name|count
operator|-=
name|written
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oc
operator|->
name|buf
operator|+
name|written
argument_list|,
operator|(
name|char
operator|*
operator|)
name|oc
operator|->
name|buf
argument_list|,
name|oc
operator|->
name|count
argument_list|)
expr_stmt|;
name|written
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|written
operator|-=
name|oc
operator|->
name|count
expr_stmt|;
name|oc
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|notWritten
operator|>
name|oc
operator|->
name|bufsize
condition|)
block|{
comment|/* allocate at least enough to contain it plus one 	       OutputBufferSize */
name|oc
operator|->
name|bufsize
operator|=
name|notWritten
operator|+
name|OutputBufferSize
expr_stmt|;
name|oc
operator|->
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|oc
operator|->
name|buf
argument_list|,
name|oc
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|outOfMem
label|:
ifdef|#
directive|ifdef
name|notdef
name|ErrorF
argument_list|(
literal|"Closing connection %d because out of memory\n"
argument_list|,
name|connection
argument_list|)
expr_stmt|;
comment|/* this close will cause the select in WaitForSomething 		   to return that the connection is dead, so we can actually 		   clean up after the client.  We can't clean up here, 		   because the we're in the middle of doing something 		   and will probably screw up some data strucutres */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISOCONN
ifdef|#
directive|ifdef
name|ISODEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of mem: closing connection %d\n"
argument_list|,
name|connection
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISODEBUG */
name|SClose
argument_list|(
name|connection
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|close
argument_list|(
name|connection
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|MarkClientException
argument_list|(
name|who
argument_list|)
expr_stmt|;
name|oc
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|oc
operator|->
name|bufsize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* If the amount written extended into the padBuffer, then the 	   difference "extraCount - written" may be less than 0 */
if|if
condition|(
operator|(
name|n
operator|=
name|extraCount
operator|-
name|written
operator|)
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|extraBuf
operator|+
name|written
argument_list|,
operator|(
name|char
operator|*
operator|)
name|oc
operator|->
name|buf
operator|+
name|oc
operator|->
name|count
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|oc
operator|->
name|count
operator|=
name|notWritten
expr_stmt|;
comment|/* this will include the pad */
return|return
name|extraCount
return|;
comment|/* return only the amount explicitly requested */
block|}
comment|/* everything was flushed out */
name|oc
operator|->
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oc
operator|->
name|bufsize
operator|>
name|OutputBufferSize
condition|)
block|{
name|oc
operator|->
name|bufsize
operator|=
name|OutputBufferSize
expr_stmt|;
name|oc
operator|->
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|oc
operator|->
name|buf
argument_list|,
name|OutputBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|->
name|buf
operator|==
name|NULL
condition|)
comment|/* nearly impossible */
goto|goto
name|outOfMem
goto|;
block|}
return|return
name|extraCount
return|;
comment|/* return only the amount explicitly requested */
block|}
end_function

begin_comment
comment|/********************  * FlushAllOutput()  *    Flush all clients with output.  However, if some client still  *    has input in the queue (more requests), then don't flush.  This  *    will prevent the output queue from being flushed every time around  *    the round robin queue.  Now, some say that it SHOULD be flushed  *    every time around, but...  *  **********************/
end_comment

begin_function
name|void
name|FlushAllOutput
parameter_list|()
block|{
specifier|register
name|int
name|index
decl_stmt|,
name|base
decl_stmt|,
name|mask
decl_stmt|;
name|OsCommPtr
name|oc
decl_stmt|;
specifier|register
name|ClientPtr
name|client
decl_stmt|;
if|if
condition|(
operator|!
name|NewOutputPending
condition|)
return|return;
comment|/*      * It may be that some client still has critical output pending,      * but he is not yet ready to receive it anyway, so we will      * simply wait for the select to tell us when he's ready to receive.      */
name|CriticalOutputPending
operator|=
name|FALSE
expr_stmt|;
name|NewOutputPending
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|base
operator|=
literal|0
init|;
name|base
operator|<
name|mskcnt
condition|;
name|base
operator|++
control|)
block|{
name|mask
operator|=
name|OutputPending
index|[
name|base
index|]
expr_stmt|;
name|OutputPending
index|[
name|base
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
name|index
operator|=
name|ffs
argument_list|(
name|mask
argument_list|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
operator|~
name|lowbit
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|=
name|ConnectionTranslation
index|[
operator|(
literal|32
operator|*
name|base
operator|)
operator|+
name|index
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|client
operator|->
name|clientGone
condition|)
continue|continue;
name|oc
operator|=
operator|(
name|OsCommPtr
operator|)
name|client
operator|->
name|osPrivate
expr_stmt|;
if|if
condition|(
name|GETBIT
argument_list|(
name|ClientsWithInput
argument_list|,
name|client
operator|->
name|index
argument_list|)
condition|)
block|{
name|BITSET
argument_list|(
name|OutputPending
argument_list|,
name|oc
operator|->
name|fd
argument_list|)
expr_stmt|;
comment|/* set the bit again */
name|NewOutputPending
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|FlushClient
argument_list|(
name|client
argument_list|,
name|oc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|FlushIfCriticalOutputPending
parameter_list|()
block|{
if|if
condition|(
name|CriticalOutputPending
condition|)
name|FlushAllOutput
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetCriticalOutputPending
parameter_list|()
block|{
name|CriticalOutputPending
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************  * WriteToClient  *    Copies buf into ClientPtr.buf if it fits (with padding), else  *    flushes ClientPtr.buf and buf to client.  As of this writing,  *    every use of WriteToClient is cast to void, and the result  *    is ignored.  Potentially, this could be used by requests  *    that are sending several chunks of data and want to break  *    out of a loop on error.  Thus, we will leave the type of  *    this routine as int.  *****************/
end_comment

begin_function
name|int
name|WriteToClient
parameter_list|(
name|who
parameter_list|,
name|count
parameter_list|,
name|buf
parameter_list|)
name|ClientPtr
name|who
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|OsCommPtr
name|oc
init|=
operator|(
name|OsCommPtr
operator|)
name|who
operator|->
name|osPrivate
decl_stmt|;
name|int
name|padBytes
decl_stmt|;
if|if
condition|(
name|oc
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|ErrorF
argument_list|(
literal|"OH NO, %d translates to -1\n"
argument_list|,
name|oc
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|oc
operator|->
name|fd
operator|==
operator|-
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
name|ErrorF
argument_list|(
literal|"CONNECTION %d ON ITS WAY OUT\n"
argument_list|,
name|oc
operator|->
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|padBytes
operator|=
name|padlength
index|[
name|count
operator|&
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|oc
operator|->
name|count
operator|+
name|count
operator|+
name|padBytes
operator|>
name|oc
operator|->
name|bufsize
condition|)
block|{
name|BITCLEAR
argument_list|(
name|OutputPending
argument_list|,
name|oc
operator|->
name|fd
argument_list|)
expr_stmt|;
name|CriticalOutputPending
operator|=
name|FALSE
expr_stmt|;
name|NewOutputPending
operator|=
name|FALSE
expr_stmt|;
return|return
name|FlushClient
argument_list|(
name|who
argument_list|,
name|oc
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
return|;
block|}
name|NewOutputPending
operator|=
name|TRUE
expr_stmt|;
name|BITSET
argument_list|(
name|OutputPending
argument_list|,
name|oc
operator|->
name|fd
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|oc
operator|->
name|buf
operator|+
name|oc
operator|->
name|count
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|oc
operator|->
name|count
operator|+=
name|count
operator|+
name|padBytes
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

end_unit

