begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*****************************************************************  * OS Depedent input routines:  *  *  WaitForSomething,  GetEvent  *  *****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"Xos.h"
end_include

begin_comment
comment|/* for strings, fcntl, time */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"osdep.h"
end_include

begin_include
include|#
directive|include
file|"dixstruct.h"
end_include

begin_decl_stmt
specifier|extern
name|long
name|AllSockets
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|AllClients
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|LastSelectMask
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|WellKnownConnections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|EnabledDevices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|ClientsWithInput
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|ClientsWriteBlocked
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|OutputPending
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|ScreenSaverTime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* milliseconds */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|ScreenSaverInterval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* milliseconds */
end_comment

begin_decl_stmt
specifier|extern
name|ClientPtr
name|ConnectionTranslation
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Bool
name|clientsDoomed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Bool
name|NewOutputPending
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Bool
name|AnyClientsWriteBlocked
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|CheckConnections
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|EstablishNewConnections
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|isItTimeToYield
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MULTI_X_HACK
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|XMulti
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|sigwindow_handler
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|MULTI_X_HACK
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XTESTEXT1
end_ifdef

begin_comment
comment|/*  * defined in xtestext1dd.c  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|playback_on
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XTESTEXT1 */
end_comment

begin_comment
comment|/*****************  * WaitForSomething:  *     Make the server suspend until there is  *	1. data from clients or  *	2. input events available or  *	3. ddx notices something of interest (graphics  *	   queue ready, etc.) or  *	4. clients that have buffered replies/events are ready  *  *     If the time between INPUT events is  *     greater than ScreenSaverTime, the display is turned off (or  *     saved, depending on the hardware).  So, WaitForSomething()  *     has to handle this also (that's why the select() has a timeout.  *     For more info on ClientsWithInput, see ReadRequestFromClient().  *     pClientsReady is a mask, the bits set are   *     indices into the o.s. depedent table of available clients.  *     (In this case, there is no table -- the index is the socket  *     file descriptor.)    *****************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_comment
comment|/*  * cannot use select in TSAP stuff, so...see TNetAccept  * (which calls xselect, which calls select...)  */
end_comment

begin_include
include|#
directive|include
file|<isode/tsap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
specifier|static
name|long
name|timeTilFrob
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* while screen saving */
end_comment

begin_if
if|#
directive|if
operator|(
name|mskcnt
operator|>
literal|4
operator|)
end_if

begin_comment
comment|/*  * This is a macro if mskcnt<= 4  */
end_comment

begin_macro
name|ANYSET
argument_list|(
argument|src
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|src
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mskcnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|src
index|[
name|i
index|]
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|WaitForSomething
argument_list|(
argument|pClientsReady
argument_list|,
argument|nready
argument_list|,
argument|pNewClients
argument_list|,
argument|nnew
argument_list|)
end_macro

begin_decl_stmt
name|ClientPtr
modifier|*
name|pClientsReady
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|nready
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ClientPtr
modifier|*
name|pNewClients
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|nnew
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|waittime
decl_stmt|,
modifier|*
name|wt
decl_stmt|;
name|long
name|timeout
decl_stmt|;
name|long
name|clientsReadable
index|[
name|mskcnt
index|]
decl_stmt|;
name|long
name|clientsWritable
index|[
name|mskcnt
index|]
decl_stmt|;
name|long
name|curclient
decl_stmt|;
name|int
name|selecterr
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|int
name|vecp
decl_stmt|;
name|char
modifier|*
name|vec
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
ifdef|#
directive|ifdef
name|hpux
name|long
name|ready_inputs
decl_stmt|;
comment|/* to tell HIL drivers about input */
endif|#
directive|endif
endif|hpux
operator|*
name|nready
operator|=
literal|0
expr_stmt|;
operator|*
name|nnew
operator|=
literal|0
expr_stmt|;
name|CLEARBITS
argument_list|(
name|clientsReadable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ANYSET
argument_list|(
name|ClientsWithInput
argument_list|)
operator|)
condition|)
block|{
comment|/* We need a while loop here to handle  	   crashed connections and the screen saver timeout */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ScreenSaverTime
condition|)
block|{
name|timeout
operator|=
name|ScreenSaverTime
operator|-
name|TimeSinceLastInputEvent
argument_list|()
expr_stmt|;
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
comment|/* may be forced by AutoResetServer() */
block|{
name|long
name|timeSinceSave
decl_stmt|;
if|if
condition|(
name|clientsDoomed
condition|)
block|{
operator|*
name|nnew
operator|=
operator|*
name|nready
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|timeSinceSave
operator|=
operator|-
name|timeout
expr_stmt|;
if|if
condition|(
operator|(
name|timeSinceSave
operator|>=
name|timeTilFrob
operator|)
operator|&&
operator|(
name|timeTilFrob
operator|>=
literal|0
operator|)
condition|)
block|{
name|SaveScreens
argument_list|(
name|SCREEN_SAVER_ON
argument_list|,
name|ScreenSaverActive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ScreenSaverInterval
condition|)
comment|/* round up to the next ScreenSaverInterval */
name|timeTilFrob
operator|=
name|ScreenSaverInterval
operator|*
operator|(
operator|(
name|timeSinceSave
operator|+
name|ScreenSaverInterval
operator|)
operator|/
name|ScreenSaverInterval
operator|)
expr_stmt|;
else|else
name|timeTilFrob
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|timeout
operator|=
name|timeTilFrob
operator|-
name|timeSinceSave
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|timeout
operator|>
name|ScreenSaverTime
condition|)
name|timeout
operator|=
name|ScreenSaverTime
expr_stmt|;
name|timeTilFrob
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|timeTilFrob
operator|>=
literal|0
condition|)
block|{
name|waittime
operator|.
name|tv_sec
operator|=
name|timeout
operator|/
name|MILLI_PER_SECOND
expr_stmt|;
name|waittime
operator|.
name|tv_usec
operator|=
operator|(
name|timeout
operator|%
name|MILLI_PER_SECOND
operator|)
operator|*
operator|(
literal|1000000
operator|/
name|MILLI_PER_SECOND
operator|)
expr_stmt|;
name|wt
operator|=
operator|&
name|waittime
expr_stmt|;
block|}
else|else
block|{
name|wt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|wt
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTI_X_HACK
if|if
condition|(
name|XMulti
condition|)
block|{
name|ipc_block_handler
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGWINDOW
argument_list|,
name|sigwindow_handler
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|MULTI_X_HACK
name|COPYBITS
argument_list|(
name|AllSockets
argument_list|,
name|LastSelectMask
argument_list|)
expr_stmt|;
name|BlockHandler
argument_list|(
operator|&
name|wt
argument_list|,
name|LastSelectMask
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewOutputPending
condition|)
name|FlushAllOutput
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XTESTEXT1
comment|/* XXX how does this interact with new write block handling? */
if|if
condition|(
name|playback_on
condition|)
block|{
name|wt
operator|=
operator|&
name|waittime
expr_stmt|;
name|XTestComputeWaitTime
argument_list|(
operator|&
name|waittime
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XTESTEXT1 */
ifndef|#
directive|ifndef
name|ISOCONN
if|if
condition|(
name|AnyClientsWriteBlocked
condition|)
block|{
name|COPYBITS
argument_list|(
name|ClientsWriteBlocked
argument_list|,
name|clientsWritable
argument_list|)
expr_stmt|;
name|i
operator|=
name|select
argument_list|(
name|MAXSOCKS
argument_list|,
name|LastSelectMask
argument_list|,
name|clientsWritable
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|wt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|select
argument_list|(
name|MAXSOCKS
argument_list|,
name|LastSelectMask
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|wt
argument_list|)
expr_stmt|;
block|}
name|selecterr
operator|=
name|errno
expr_stmt|;
else|#
directive|else
comment|/* IS ISOCONN */
if|if
condition|(
name|AnyClientsWriteBlocked
condition|)
block|{
name|int
name|secs
init|=
name|wt
operator|->
name|tv_sec
decl_stmt|;
if|if
condition|(
name|secs
operator|==
literal|0
operator|&&
name|wt
operator|->
name|tv_usec
operator|!=
literal|0
condition|)
name|secs
operator|=
literal|1
expr_stmt|;
name|COPYBITS
argument_list|(
name|ClientsWriteBlocked
argument_list|,
name|clientsWritable
argument_list|)
expr_stmt|;
name|i
operator|=
name|TNetAccept
argument_list|(
operator|&
name|vecp
argument_list|,
name|vec
argument_list|,
name|MAXSOCKS
argument_list|,
name|LastSelectMask
argument_list|,
name|clientsWritable
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|wt
operator|->
name|tv_sec
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|secs
init|=
name|wt
operator|->
name|tv_sec
decl_stmt|;
if|if
condition|(
name|secs
operator|==
literal|0
operator|&&
name|wt
operator|->
name|tv_usec
operator|!=
literal|0
condition|)
name|secs
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|TNetAccept
argument_list|(
operator|&
name|vecp
argument_list|,
name|vec
argument_list|,
name|MAXSOCKS
argument_list|,
name|LastSelectMask
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|secs
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
comment|/* map errors */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|DR_FATAL
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
condition|)
name|errno
operator|=
name|EWOULDBLOCK
expr_stmt|;
block|}
name|selecterr
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|WakeupHandler
argument_list|(
name|i
argument_list|,
name|LastSelectMask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XTESTEXT1
if|if
condition|(
name|playback_on
condition|)
block|{
name|i
operator|=
name|XTestProcessInputAction
argument_list|(
name|i
argument_list|,
operator|&
name|waittime
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XTESTEXT1 */
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
comment|/* An error or timeout occurred */
block|{
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WF: TO or ERR %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CLEARBITS
argument_list|(
name|clientsWritable
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
if|if
condition|(
name|selecterr
operator|==
name|EBADF
condition|)
comment|/* Some client disconnected */
block|{
name|CheckConnections
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ANYSET
argument_list|(
name|AllClients
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|selecterr
operator|!=
name|EINTR
condition|)
name|ErrorF
argument_list|(
literal|"WaitForSomething(): select: errno=%d\n"
argument_list|,
name|selecterr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|AnyClientsWriteBlocked
operator|&&
name|ANYSET
argument_list|(
name|clientsWritable
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WF: write\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|NewOutputPending
operator|=
name|TRUE
expr_stmt|;
name|ORBITS
argument_list|(
name|OutputPending
argument_list|,
name|clientsWritable
argument_list|,
name|OutputPending
argument_list|)
expr_stmt|;
name|UNSETBITS
argument_list|(
name|ClientsWriteBlocked
argument_list|,
name|clientsWritable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ANYSET
argument_list|(
name|ClientsWriteBlocked
argument_list|)
condition|)
name|AnyClientsWriteBlocked
operator|=
name|FALSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|hpux
name|ready_inputs
operator|=
operator|(
name|LastSelectMask
index|[
literal|0
index|]
operator|&
name|EnabledDevices
operator|)
expr_stmt|;
if|if
condition|(
name|ready_inputs
operator|>
literal|0
condition|)
name|store_inputs
argument_list|(
name|ready_inputs
argument_list|)
expr_stmt|;
comment|/* call the HIL driver to gather inputs. 	*/
endif|#
directive|endif
endif|hpux
name|MASKANDSETBITS
argument_list|(
name|clientsReadable
argument_list|,
name|LastSelectMask
argument_list|,
name|AllClients
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * ISODE version says new connections pending accept if vecp> 0 !!  */
if|if
condition|(
name|vecp
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WF: CX pending\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EstablishNewConnections
argument_list|(
name|pNewClients
argument_list|,
name|nnew
argument_list|,
name|vecp
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ISOCONN */
if|if
condition|(
name|LastSelectMask
index|[
literal|0
index|]
operator|&
name|WellKnownConnections
condition|)
name|EstablishNewConnections
argument_list|(
name|pNewClients
argument_list|,
name|nnew
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
operator|*
name|nnew
operator|||
operator|(
name|LastSelectMask
index|[
literal|0
index|]
operator|&
name|EnabledDevices
operator|)
operator|||
operator|(
name|ANYSET
argument_list|(
name|clientsReadable
argument_list|)
operator|)
condition|)
break|break;
block|}
block|}
block|}
else|else
block|{
name|COPYBITS
argument_list|(
name|ClientsWithInput
argument_list|,
name|clientsReadable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ANYSET
argument_list|(
name|clientsReadable
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WF: readable\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mskcnt
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|clientsReadable
index|[
name|i
index|]
condition|)
block|{
name|curclient
operator|=
name|ffs
argument_list|(
name|clientsReadable
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|pClientsReady
index|[
operator|(
operator|*
name|nready
operator|)
operator|++
index|]
operator|=
name|ConnectionTranslation
index|[
name|curclient
operator|+
operator|(
literal|32
operator|*
name|i
operator|)
index|]
expr_stmt|;
name|clientsReadable
index|[
name|i
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|curclient
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

end_unit

