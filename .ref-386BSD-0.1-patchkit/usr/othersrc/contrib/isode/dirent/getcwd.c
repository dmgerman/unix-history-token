begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 	getcwd -- get current working directory name (POSIX and SVID compatible)  	last edit:	21-Sep-1987	D A Gwyn  	This public-domain getcwd() routine can be used to replace the UNIX 	System V library routine (which uses popen() to capture the output of 	the "pwd" command).  Once that is done, "pwd" can be reimplemented as 	just puts(getcwd()).  	This implementation depends on every directory having entries for 	"." and "..".  It also depends on the internals of the<dirent.h> 	data structures to some degree.  	I considered using chdir() to ascend the hierarchy, followed by a 	final chdir() to the path being returned by getcwd() to restore the 	location, but decided that error recovery was too difficult that way. 	The algorithm I settled on was inspired by my rewrite of the "pwd" 	utility, combined with the dotdots[] array trick from the SVR2 shell. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"usr.dirent.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_typedef
typedef|typedef
name|char
modifier|*
name|pointer
typedef|;
end_typedef

begin_comment
comment|/* (void *) if you have it */
end_comment

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|pointer
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|fstat
argument_list|()
decl_stmt|,
name|stat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* normally done by<errno.h> */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_comment
comment|/* amorphous null pointer constant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NAME_MAX
end_ifndef

begin_define
define|#
directive|define
name|NAME_MAX
value|255
end_define

begin_comment
comment|/* maximum directory entry size */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|getcwd
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
comment|/* returns pointer to CWD pathname */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* where to put name (NULL to malloc) */
name|int
name|size
decl_stmt|;
comment|/* size of buf[] or malloc()ed memory */
block|{
specifier|static
name|char
name|dotdots
index|[]
init|=
literal|"../../../../../../../../../../../../../../../../../../../../../../../../../.."
decl_stmt|;
name|char
modifier|*
name|dotdot
decl_stmt|;
comment|/* -> dotdots[.], right to left */
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* -> parent directory stream */
name|struct
name|dirent
modifier|*
name|dir
decl_stmt|;
comment|/* -> directory entry */
name|struct
name|stat
name|stat1
decl_stmt|,
name|stat2
decl_stmt|;
comment|/* info from stat() */
name|struct
name|stat
modifier|*
name|d
init|=
operator|&
name|stat1
decl_stmt|;
comment|/* -> info about "." */
name|struct
name|stat
modifier|*
name|dd
init|=
operator|&
name|stat2
decl_stmt|;
comment|/* -> info about ".." */
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* local copy of buf, or malloc()ed */
name|char
modifier|*
name|bufend
decl_stmt|;
comment|/* -> buffer[size] */
specifier|register
name|char
modifier|*
name|endp
decl_stmt|;
comment|/* -> end of reversed string */
specifier|register
name|char
modifier|*
name|dname
decl_stmt|;
comment|/* entry name ("" for root) */
name|int
name|serrno
init|=
name|errno
decl_stmt|;
comment|/* save entry errno */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
comment|/* invalid argument */
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|buffer
operator|=
name|buf
operator|)
operator|==
name|NULL
comment|/* wants us to malloc() the string */
operator|&&
operator|(
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
comment|/* cannot malloc() specified size */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
name|dd
argument_list|)
operator|!=
literal|0
condition|)
comment|/* prime the pump */
goto|goto
name|error
goto|;
comment|/* errno already set */
name|endp
operator|=
name|buffer
expr_stmt|;
comment|/* initially, empty string */
name|bufend
operator|=
operator|&
name|buffer
index|[
name|size
index|]
expr_stmt|;
for|for
control|(
name|dotdot
operator|=
operator|&
name|dotdots
index|[
sizeof|sizeof
argument_list|(
name|dotdots
argument_list|)
index|]
init|;
name|dotdot
operator|!=
name|dotdots
condition|;
control|)
block|{
name|dotdot
operator|-=
literal|3
expr_stmt|;
comment|/* include one more "/.." section */
comment|/* (first time is actually "..") */
comment|/* swap stat() info buffers */
block|{
specifier|register
name|struct
name|stat
modifier|*
name|temp
init|=
name|d
decl_stmt|;
name|d
operator|=
name|dd
expr_stmt|;
comment|/* new current dir is old parent dir */
name|dd
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dotdot
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* new parent */
goto|goto
name|error
goto|;
comment|/* errno already set */
if|if
condition|(
name|fstat
argument_list|(
name|dirp
operator|->
name|dd_fd
argument_list|,
name|dd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|serrno
operator|=
name|errno
expr_stmt|;
comment|/* set by fstat() */
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|serrno
expr_stmt|;
comment|/* in case closedir() clobbered it */
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|d
operator|->
name|st_dev
operator|==
name|dd
operator|->
name|st_dev
condition|)
block|{
comment|/* not crossing a mount point */
if|if
condition|(
name|d
operator|->
name|st_ino
operator|==
name|dd
operator|->
name|st_ino
condition|)
block|{
comment|/* root directory */
name|dname
operator|=
literal|""
expr_stmt|;
goto|goto
name|append
goto|;
block|}
do|do
if|if
condition|(
operator|(
name|dir
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
comment|/* missing entry */
goto|goto
name|error
goto|;
block|}
do|while
condition|(
name|dir
operator|->
name|d_ino
operator|!=
name|d
operator|->
name|st_ino
condition|)
do|;
block|}
else|else
block|{
comment|/* crossing a mount point */
name|struct
name|stat
name|t
decl_stmt|;
comment|/* info re. test entry */
name|char
name|name
index|[
sizeof|sizeof
argument_list|(
name|dotdots
argument_list|)
operator|+
literal|1
operator|+
name|NAME_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|dotdot
argument_list|)
expr_stmt|;
name|dname
operator|=
operator|&
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
index|]
expr_stmt|;
operator|*
name|dname
operator|++
operator|=
literal|'/'
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|dir
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
comment|/* missing entry */
goto|goto
name|error
goto|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dname
argument_list|,
name|dir
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* must fit if NAME_MAX is not a lie */
block|}
do|while
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|t
argument_list|)
operator|!=
literal|0
operator|||
name|t
operator|.
name|st_ino
operator|!=
name|d
operator|->
name|st_ino
operator|||
name|t
operator|.
name|st_dev
operator|!=
name|d
operator|->
name|st_dev
condition|)
do|;
block|}
name|dname
operator|=
name|dir
operator|->
name|d_name
expr_stmt|;
comment|/* append "/" and reversed dname string onto buffer */
name|append
label|:
if|if
condition|(
name|endp
operator|!=
name|buffer
comment|/* avoid trailing / in final name */
operator|||
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
comment|/* but allow "/" when CWD is root */
condition|)
operator|*
name|endp
operator|++
operator|=
literal|'/'
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|app
decl_stmt|;
comment|/* traverses dname string */
for|for
control|(
name|app
operator|=
name|dname
init|;
operator|*
name|app
operator|!=
literal|'\0'
condition|;
operator|++
name|app
control|)
empty_stmt|;
if|if
condition|(
name|app
operator|-
name|dname
operator|>=
name|bufend
operator|-
name|endp
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ERANGE
expr_stmt|;
comment|/* won't fit allotted space */
goto|goto
name|error
goto|;
block|}
while|while
condition|(
name|app
operator|!=
name|dname
condition|)
operator|*
name|endp
operator|++
operator|=
operator|*
operator|--
name|app
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* reached root; wrap it up */
block|{
specifier|register
name|char
modifier|*
name|startp
decl_stmt|;
comment|/* -> buffer[.] */
operator|*
name|endp
operator|=
literal|'\0'
expr_stmt|;
comment|/* plant null terminator */
comment|/* straighten out reversed pathname string */
for|for
control|(
name|startp
operator|=
name|buffer
init|;
operator|--
name|endp
operator|>
name|startp
condition|;
operator|++
name|startp
control|)
block|{
name|char
name|temp
init|=
operator|*
name|endp
decl_stmt|;
operator|*
name|endp
operator|=
operator|*
name|startp
expr_stmt|;
operator|*
name|startp
operator|=
name|temp
expr_stmt|;
block|}
name|errno
operator|=
name|serrno
expr_stmt|;
comment|/* restore entry errno */
return|return
name|buffer
return|;
block|}
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
comment|/* actually, algorithm failure */
name|error
label|:
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|pointer
operator|)
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

