begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ds_bind.c - BindArgument Checking and Authentication */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/ds_bind.c,v 7.6 91/03/09 11:56:33 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/quipu/RCS/ds_bind.c,v 7.6 91/03/09 11:56:33 mrose Exp $  *  *  * $Log:	ds_bind.c,v $  * Revision 7.6  91/03/09  11:56:33  mrose  * update  *   * Revision 7.5  91/02/22  09:38:44  mrose  * Interim 6.8  *   * Revision 7.4  90/11/20  15:28:40  mrose  * cjr  *   * Revision 7.3  90/10/17  11:53:38  mrose  * sync  *   * Revision 7.2  90/03/15  11:18:46  mrose  * quipu-sync  *   * Revision 7.1  89/12/19  16:20:13  mrose  * sync  *   * Revision 7.0  89/11/23  22:17:05  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/entry.h"
end_include

begin_include
include|#
directive|include
file|"quipu/commonarg.h"
end_include

begin_include
include|#
directive|include
file|"quipu/bind.h"
end_include

begin_include
include|#
directive|include
file|"quipu/compare.h"
end_include

begin_include
include|#
directive|include
file|"quipu/dua.h"
end_include

begin_include
include|#
directive|include
file|"quipu/connection.h"
end_include

begin_include
include|#
directive|include
file|"pepsy.h"
end_include

begin_include
include|#
directive|include
file|"quipu/DAS_pre_defs.h"
end_include

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DN
name|mydsadn
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|oper_act
modifier|*
name|oper_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NO_STATS
end_ifndef

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_stat
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|dn_print
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|bind_window
init|=
literal|300
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tailorable timeout for credentials */
end_comment

begin_decl_stmt
name|int
name|auth_bind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ds_bind_init
parameter_list|(
name|cn
parameter_list|)
name|struct
name|connection
modifier|*
name|cn
decl_stmt|;
block|{
name|struct
name|ds_bind_arg
modifier|*
name|arg
init|=
operator|&
operator|(
name|cn
operator|->
name|cn_start
operator|.
name|cs_ds
operator|.
name|ds_bind_arg
operator|)
decl_stmt|;
name|struct
name|ds_bind_arg
modifier|*
name|result
init|=
operator|&
operator|(
name|cn
operator|->
name|cn_start
operator|.
name|cs_res
operator|)
decl_stmt|;
name|struct
name|ds_bind_error
modifier|*
name|error
init|=
operator|&
operator|(
name|cn
operator|->
name|cn_start
operator|.
name|cs_err
operator|)
decl_stmt|;
name|Attr_Sequence
name|as
decl_stmt|;
name|Entry
name|entryptr
decl_stmt|;
specifier|extern
name|AttributeType
name|at_password
decl_stmt|;
specifier|extern
name|AttributeType
name|at_p_password
decl_stmt|;
name|struct
name|di_block
modifier|*
name|dsas
init|=
name|NULL_DI_BLOCK
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di_tmp
decl_stmt|;
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
name|struct
name|ds_compare_arg
modifier|*
name|cma
decl_stmt|;
name|struct
name|DSError
name|err
decl_stmt|;
specifier|static
name|struct
name|common_args
name|ca_def
init|=
name|default_common_args
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|protected_password
modifier|*
name|pp
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|char
name|buff
index|[
name|LINESIZE
index|]
decl_stmt|;
endif|#
directive|endif
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"ds_bind_init"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|dba_version
operator|!=
name|DBA_VERSION_V1988
condition|)
block|{
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SERVICE
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SV_UNAVAILABLE
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
block|}
comment|/* We don't support any bilaterally-defined authentication procedures.  * Hence, if we get EXTERNAL credentials in the bind, reject them.  */
if|if
condition|(
name|arg
operator|->
name|dba_auth_type
operator|==
name|DBA_AUTH_EXTERNAL
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"EXTERNAL found in credentials"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SERVICE
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SV_UNAVAILABLE
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
block|}
comment|/* If password is present, but zero length, treat as though absent */
if|if
condition|(
operator|(
name|arg
operator|->
name|dba_auth_type
operator|==
name|DBA_AUTH_SIMPLE
operator|)
operator|&&
operator|(
name|arg
operator|->
name|dba_passwd_len
operator|==
literal|0
operator|)
condition|)
name|arg
operator|->
name|dba_auth_type
operator|=
name|DBA_AUTH_NONE
expr_stmt|;
switch|switch
condition|(
name|arg
operator|->
name|dba_auth_type
condition|)
block|{
case|case
name|DBA_AUTH_NONE
case|:
if|if
condition|(
operator|(
operator|(
name|arg
operator|->
name|dba_dn
operator|==
name|NULLDN
operator|)
operator|&&
name|auth_bind
operator|==
literal|1
operator|)
operator|||
operator|(
name|auth_bind
operator|>
literal|1
operator|)
condition|)
block|{
name|out
label|:
empty_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
if|if
condition|(
name|arg
operator|->
name|dba_dn
operator|==
name|NULLDN
condition|)
name|LLOG
argument_list|(
name|log_stat
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"Bind (%d) (rejected)"
operator|,
name|cn
operator|->
name|cn_ad
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Bind (%d) (rejected)"
argument_list|,
name|cn
operator|->
name|cn_ad
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_TRACE
argument_list|,
name|buff
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|arg
operator|->
name|dba_dn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SECURITY
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SC_AUTHENTICATION
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
block|}
break|break;
case|case
name|DBA_AUTH_SIMPLE
case|:
if|if
condition|(
name|auth_bind
operator|>
literal|2
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|DBA_AUTH_PROTECTED
case|:
if|if
condition|(
name|auth_bind
operator|>
literal|3
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|DBA_AUTH_STRONG
case|:
break|break;
case|case
name|DBA_AUTH_EXTERNAL
case|:
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|arg
operator|->
name|dba_dn
operator|==
name|NULLDN
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|LLOG
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Bind (%d) (anonymous)"
operator|,
name|cn
operator|->
name|cn_ad
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cn
operator|->
name|cn_authen
operator|=
name|DBA_AUTH_NONE
expr_stmt|;
name|make_dsa_bind_arg
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
comment|/* Now we're sure dba_dn contains a valid pointer, can decode it */
switch|switch
condition|(
name|arg
operator|->
name|dba_auth_type
condition|)
block|{
case|case
name|DBA_AUTH_NONE
case|:
comment|/* partially check DN - i.e see if we can say if DEFINATELY does */
comment|/* not exist.  If it possibly exists - allow bind, checking it   */
comment|/* runs the risk of livelock */
switch|switch
condition|(
name|res
operator|=
name|really_find_entry
argument_list|(
name|arg
operator|->
name|dba_dn
argument_list|,
name|TRUE
argument_list|,
name|NULLDNSEQ
argument_list|,
name|FALSE
argument_list|,
operator|&
operator|(
name|entryptr
operator|)
argument_list|,
operator|&
operator|(
name|err
operator|)
argument_list|,
operator|&
operator|(
name|dsas
operator|)
argument_list|)
condition|)
block|{
case|case
name|DS_X500_ERROR
case|:
if|if
condition|(
operator|(
name|err
operator|.
name|dse_type
operator|==
name|DSE_NAMEERROR
operator|)
operator|&&
operator|(
name|err
operator|.
name|ERR_NAME
operator|.
name|DSE_na_problem
operator|==
name|DSE_NA_NOSUCHOBJECT
operator|)
condition|)
block|{
name|ds_error_free
argument_list|(
operator|&
operator|(
name|err
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Bind (%d) (no auth - rejected)"
argument_list|,
name|cn
operator|->
name|cn_ad
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_TRACE
argument_list|,
name|buff
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|arg
operator|->
name|dba_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SECURITY
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SC_INVALIDCREDENTIALS
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
block|}
comment|/* fall */
default|default:
ifndef|#
directive|ifndef
name|NO_STATS
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Bind (%d) (no auth)"
argument_list|,
name|cn
operator|->
name|cn_ad
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
name|buff
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|arg
operator|->
name|dba_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dsas
operator|!=
name|NULL_DI_BLOCK
condition|)
name|di_desist
argument_list|(
name|dsas
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_authen
operator|=
name|DBA_AUTH_NONE
expr_stmt|;
name|make_dsa_bind_arg
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
case|case
name|DBA_AUTH_SIMPLE
case|:
ifndef|#
directive|ifndef
name|NO_STATS
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Bind (%d) (simple)"
argument_list|,
name|cn
operator|->
name|cn_ad
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
name|buff
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|arg
operator|->
name|dba_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Can't check simple credentials from DSP (livelock risk). 	 * Hence treat DSP accesses as unauthenticated. 	 */
if|if
condition|(
name|cn
operator|->
name|cn_ctx
operator|!=
name|DS_CTX_X500_DAP
condition|)
block|{
name|cn
operator|->
name|cn_authen
operator|=
name|DBA_AUTH_NONE
expr_stmt|;
name|make_dsa_bind_arg
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
break|break;
case|case
name|DBA_AUTH_PROTECTED
case|:
ifndef|#
directive|ifndef
name|NO_STATS
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Bind (%d) (protected)"
argument_list|,
name|cn
operator|->
name|cn_ad
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
name|buff
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|arg
operator|->
name|dba_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cn
operator|->
name|cn_ctx
operator|!=
name|DS_CTX_X500_DAP
condition|)
block|{
name|cn
operator|->
name|cn_authen
operator|=
name|DBA_AUTH_NONE
expr_stmt|;
name|make_dsa_bind_arg
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
else|else
block|{
name|UTC
name|ut
decl_stmt|;
name|long
name|c_time
decl_stmt|,
name|s_time
decl_stmt|,
name|delta
decl_stmt|;
name|time_t
name|time
parameter_list|()
function_decl|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|s_time
argument_list|)
expr_stmt|;
name|ut
operator|=
name|str2utct
argument_list|(
name|arg
operator|->
name|dba_time1
argument_list|,
name|strlen
argument_list|(
name|arg
operator|->
name|dba_time1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ut
operator|==
name|NULLUTC
condition|)
name|c_time
operator|=
literal|0L
expr_stmt|;
comment|/* 1970 is a convenient out-of-date timestamp */
else|else
name|c_time
operator|=
name|gtime
argument_list|(
name|ut2tm
argument_list|(
name|ut
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|s_time
operator|-
name|c_time
expr_stmt|;
if|if
condition|(
operator|(
name|delta
operator|<
literal|0
operator|)
operator|||
operator|(
name|delta
operator|>
name|bind_window
operator|)
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Time = %s, Delay = %D s : Association rejected"
operator|,
name|arg
operator|->
name|dba_time1
operator|,
name|delta
operator|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SECURITY
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SC_INVALIDCREDENTIALS
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
block|}
name|pp
operator|=
operator|(
expr|struct
name|protected_password
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ought to check for null pointer ... */
name|pp
operator|->
name|passwd
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|arg
operator|->
name|dba_passwd_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arg
operator|->
name|dba_passwd
argument_list|,
name|pp
operator|->
name|passwd
argument_list|,
name|arg
operator|->
name|dba_passwd_len
argument_list|)
expr_stmt|;
name|pp
operator|->
name|n_octets
operator|=
name|arg
operator|->
name|dba_passwd_len
expr_stmt|;
name|pp
operator|->
name|time1
operator|=
name|strdup
argument_list|(
name|arg
operator|->
name|dba_time1
argument_list|)
expr_stmt|;
name|pp
operator|->
name|is_protected
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|DBA_AUTH_STRONG
case|:
ifndef|#
directive|ifndef
name|NO_STATS
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Bind (%d) (strong)"
argument_list|,
name|cn
operator|->
name|cn_ad
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
name|buff
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|arg
operator|->
name|dba_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Strong authentication is not yet supported. 	 * It will eventually be possible to check strong credentials over DSP. 	 * For the moment, accept them and treat as NONE over DSP, but reject 	 * over DAP. 	 */
ifdef|#
directive|ifdef
name|HAVE_RSA
block|{
name|int
name|rc
decl_stmt|;
name|DN
name|real_name
decl_stmt|;
name|rc
operator|=
name|check_cert_path
argument_list|(
operator|(
name|caddr_t
operator|)
name|arg
argument_list|,
name|_ZTokenToSignDAS
argument_list|,
operator|&
name|_ZDAS_mod
argument_list|,
name|arg
operator|->
name|dba_cpath
argument_list|,
name|arg
operator|->
name|dba_sig
argument_list|,
operator|&
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|OK
condition|)
block|{
name|make_dsa_bind_arg
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
else|else
block|{
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SECURITY
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|rc
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|cn
operator|->
name|cn_ctx
operator|!=
name|DS_CTX_X500_DAP
condition|)
block|{
name|cn
operator|->
name|cn_authen
operator|=
name|DBA_AUTH_NONE
expr_stmt|;
name|make_dsa_bind_arg
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
else|else
block|{
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SERVICE
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SV_UNAVAILABLE
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
block|}
endif|#
directive|endif
block|}
comment|/* If we fall through to here, credentials are simple or protected simple */
if|if
condition|(
operator|(
name|res
operator|=
name|really_find_entry
argument_list|(
name|arg
operator|->
name|dba_dn
argument_list|,
name|TRUE
argument_list|,
name|NULLDNSEQ
argument_list|,
name|FALSE
argument_list|,
operator|&
operator|(
name|entryptr
operator|)
argument_list|,
operator|&
operator|(
name|err
operator|)
argument_list|,
operator|&
operator|(
name|dsas
operator|)
argument_list|)
operator|)
operator|==
name|DS_OK
condition|)
block|{
comment|/* is it really OK ??? */
if|if
condition|(
operator|(
name|entryptr
operator|->
name|e_data
operator|==
name|E_TYPE_CONSTRUCTOR
operator|)
operator|||
operator|(
name|entryptr
operator|->
name|e_data
operator|==
name|E_TYPE_CACHE_FROM_MASTER
operator|)
condition|)
block|{
name|DN
name|dn_found
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"rfe (bind) returned a constructor"
operator|)
argument_list|)
expr_stmt|;
name|dn_found
operator|=
name|get_copy_dn
argument_list|(
name|entryptr
argument_list|)
expr_stmt|;
name|res
operator|=
name|constructor_dsa_info
argument_list|(
name|dn_found
argument_list|,
name|NULLDNSEQ
argument_list|,
name|FALSE
argument_list|,
name|entryptr
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|dsas
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|DS_OK
case|:
comment|/* entryptr filled out - break through to deal with it */
break|break;
case|case
name|DS_CONTINUE
case|:
comment|/* 	*  At this point a remote operation is required to compare 	*  the password given with the password of the entry, so 	*  fire up the remote operation and return without completing. 	*  Mark the operation as a BIND_COMPARE_OP and set the connection 	*  which will need to be restarted. 	*  Generate a compare argument. 	*  Chain the compare operation using the di_blocks. 	*/
name|cn
operator|->
name|cn_start
operator|.
name|cs_bind_compare
operator|=
name|on
operator|=
name|oper_alloc
argument_list|()
expr_stmt|;
comment|/* cn knows about on */
name|on
operator|->
name|on_type
operator|=
name|ON_TYPE_BIND_COMPARE
expr_stmt|;
name|on
operator|->
name|on_bind_compare
operator|=
name|cn
expr_stmt|;
comment|/* on knows about cn */
name|on
operator|->
name|on_arg
operator|=
operator|&
operator|(
name|on
operator|->
name|on_req
operator|)
expr_stmt|;
name|set_my_chain_args
argument_list|(
operator|&
operator|(
name|on
operator|->
name|on_req
operator|.
name|dca_charg
operator|)
argument_list|,
name|arg
operator|->
name|dba_dn
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_type
operator|=
name|OP_COMPARE
expr_stmt|;
name|cma
operator|=
operator|&
operator|(
name|on
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_cm
operator|)
expr_stmt|;
name|cma
operator|->
name|cma_common
operator|=
name|ca_def
expr_stmt|;
comment|/* struct copy */
comment|/* Set originator/requestor */
name|on
operator|->
name|on_req
operator|.
name|dca_charg
operator|.
name|cha_originator
operator|=
name|dn_cpy
argument_list|(
name|arg
operator|->
name|dba_dn
argument_list|)
expr_stmt|;
name|cma
operator|->
name|cma_common
operator|.
name|ca_requestor
operator|=
name|dn_cpy
argument_list|(
name|arg
operator|->
name|dba_dn
argument_list|)
expr_stmt|;
name|cma
operator|->
name|cma_common
operator|.
name|ca_servicecontrol
operator|.
name|svc_prio
operator|=
name|SVC_PRIO_HIGH
expr_stmt|;
name|cma
operator|->
name|cma_object
operator|=
name|dn_cpy
argument_list|(
name|arg
operator|->
name|dba_dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|dba_auth_type
operator|==
name|DBA_AUTH_SIMPLE
condition|)
block|{
name|cma
operator|->
name|cma_purported
operator|.
name|ava_type
operator|=
name|AttrT_cpy
argument_list|(
name|at_password
argument_list|)
expr_stmt|;
name|cma
operator|->
name|cma_purported
operator|.
name|ava_value
operator|=
name|str2AttrV
argument_list|(
name|arg
operator|->
name|dba_passwd
argument_list|,
name|str2syntax
argument_list|(
literal|"octetstring"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cma
operator|->
name|cma_purported
operator|.
name|ava_type
operator|=
name|AttrT_cpy
argument_list|(
name|at_p_password
argument_list|)
expr_stmt|;
name|cma
operator|->
name|cma_purported
operator|.
name|ava_value
operator|=
operator|(
name|AttributeValue
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|attrVal
argument_list|)
argument_list|)
expr_stmt|;
name|cma
operator|->
name|cma_purported
operator|.
name|ava_value
operator|->
name|av_syntax
operator|=
name|str2syntax
argument_list|(
literal|"protectedPassword"
argument_list|)
expr_stmt|;
name|cma
operator|->
name|cma_purported
operator|.
name|ava_value
operator|->
name|av_struct
operator|=
operator|(
name|caddr_t
operator|)
name|pp
expr_stmt|;
block|}
name|on
operator|->
name|on_dsas
operator|=
name|dsas
expr_stmt|;
for|for
control|(
name|di_tmp
operator|=
name|on
operator|->
name|on_dsas
init|;
name|di_tmp
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp
operator|=
name|di_tmp
operator|->
name|di_next
control|)
block|{
name|di_tmp
operator|->
name|di_type
operator|=
name|DI_OPERATION
expr_stmt|;
name|di_tmp
operator|->
name|di_oper
operator|=
name|on
expr_stmt|;
block|}
if|if
condition|(
name|oper_chain
argument_list|(
name|on
argument_list|)
operator|==
name|OK
condition|)
return|return
operator|(
name|DS_CONTINUE
operator|)
return|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_start
operator|.
name|cs_bind_compare
operator|=
name|NULLOPER
expr_stmt|;
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SERVICE
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SV_UNAVAILABLE
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
case|case
name|DS_X500_ERROR
case|:
comment|/* User's entry doesn't exist, for example */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"ds_bind - really_find_entry erred:"
operator|)
argument_list|)
expr_stmt|;
name|log_ds_error
argument_list|(
operator|&
operator|(
name|err
operator|)
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
operator|&
operator|(
name|err
operator|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SECURITY
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SC_INVALIDCREDENTIALS
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
default|default:
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SERVICE
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SV_DITERROR
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|as
operator|=
name|as_find_type
argument_list|(
name|entryptr
operator|->
name|e_attributes
argument_list|,
operator|(
name|arg
operator|->
name|dba_auth_type
operator|==
name|DBA_AUTH_SIMPLE
operator|)
condition|?
name|at_password
else|:
name|at_p_password
argument_list|)
operator|)
operator|==
name|NULLATTR
condition|)
block|{
comment|/* No password in entry. 	 * Simple authentication is not possible for entities without passwords. 	 * Hence, give the `inappropriate authentication' message. 	 */
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SECURITY
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SC_AUTHENTICATION
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
block|}
if|if
condition|(
name|arg
operator|->
name|dba_auth_type
operator|==
name|DBA_AUTH_SIMPLE
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|as
operator|->
name|attr_value
operator|->
name|avseq_av
operator|.
name|av_struct
argument_list|)
operator|!=
name|arg
operator|->
name|dba_passwd_len
condition|)
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|retval
operator|=
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|as
operator|->
name|attr_value
operator|->
name|avseq_av
operator|.
name|av_struct
argument_list|,
name|arg
operator|->
name|dba_passwd
argument_list|,
name|arg
operator|->
name|dba_passwd_len
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator|=
name|check_guard
argument_list|(
operator|(
operator|(
expr|struct
name|protected_password
operator|*
operator|)
name|as
operator|->
name|attr_value
operator|->
name|avseq_av
operator|.
name|av_struct
operator|)
operator|->
name|passwd
argument_list|,
operator|(
operator|(
expr|struct
name|protected_password
operator|*
operator|)
name|as
operator|->
name|attr_value
operator|->
name|avseq_av
operator|.
name|av_struct
operator|)
operator|->
name|n_octets
argument_list|,
name|arg
operator|->
name|dba_time1
argument_list|,
name|arg
operator|->
name|dba_passwd
argument_list|,
name|arg
operator|->
name|dba_passwd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
comment|/* Password OK! */
name|cn
operator|->
name|cn_authen
operator|=
name|arg
operator|->
name|dba_auth_type
expr_stmt|;
name|make_dsa_bind_arg
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
else|else
block|{
comment|/* password wrong ! */
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SECURITY
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SC_INVALIDCREDENTIALS
expr_stmt|;
return|return
operator|(
name|DS_ERROR_CONNECT
operator|)
return|;
block|}
block|}
end_function

begin_macro
name|bind_compare_result_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"bind_compare_result_wakeup()"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
operator|->
name|on_bind_compare
operator|==
name|NULLCONN
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"bind_compare_result_wakeup - connection initiating compare already failed"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|on
operator|->
name|on_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_cm
operator|.
name|cmr_matched
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"bind_compare - user authenticated"
operator|)
argument_list|)
expr_stmt|;
name|on
operator|->
name|on_bind_compare
operator|->
name|cn_authen
operator|=
name|on
operator|->
name|on_bind_compare
operator|->
name|cn_start
operator|.
name|cs_ds
operator|.
name|ds_bind_arg
operator|.
name|dba_auth_type
expr_stmt|;
name|conn_init_res
argument_list|(
name|on
operator|->
name|on_bind_compare
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ds_bind_error
modifier|*
name|error
init|=
operator|&
operator|(
name|on
operator|->
name|on_bind_compare
operator|->
name|cn_start
operator|.
name|cs_err
operator|)
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"bind_compare - user NOT authenticated"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SECURITY
expr_stmt|;
comment|/* Password match failed, therefore credentials are wrong */
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SC_INVALIDCREDENTIALS
expr_stmt|;
name|conn_init_err
argument_list|(
name|on
operator|->
name|on_bind_compare
argument_list|)
expr_stmt|;
block|}
block|}
name|oper_conn_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|oper_free
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bind_compare_error_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|errmsg
init|=
name|DSE_SV_DITERROR
decl_stmt|;
name|int
name|errtype
init|=
name|DBE_TYPE_SERVICE
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"bind_compare_error_wakeup()"
operator|)
argument_list|)
expr_stmt|;
comment|/*     *  Check for referral and rechain if appropriate;     *  Otherwise check if error requires propagation     *  or another of the original di_blocks to be chained to.     */
if|if
condition|(
name|on
operator|->
name|on_bind_compare
operator|==
name|NULLCONN
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"bind_compare_error_wakeup - connection initiating compare already failed"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ds_bind_error
modifier|*
name|error
init|=
operator|&
operator|(
name|on
operator|->
name|on_bind_compare
operator|->
name|cn_start
operator|.
name|cs_err
operator|)
decl_stmt|;
switch|switch
condition|(
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|dse_type
condition|)
block|{
case|case
name|DSE_NOERROR
case|:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"bind_compare_error_wakeup() - no error!"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DSE_REFERRAL
case|:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"bind_compare_error_wakeup() - DAP referral received!"
operator|)
argument_list|)
expr_stmt|;
case|case
name|DSE_DSAREFERRAL
case|:
comment|/* Follow referral */
if|if
condition|(
name|oper_rechain
argument_list|(
name|on
argument_list|)
operator|==
name|OK
condition|)
return|return;
break|break;
case|case
name|DSE_NAMEERROR
case|:
case|case
name|DSE_SECURITYERROR
case|:
case|case
name|DSE_ATTRIBUTEERROR
case|:
name|errtype
operator|=
name|DBE_TYPE_SECURITY
expr_stmt|;
name|errmsg
operator|=
name|DSE_SC_INVALIDCREDENTIALS
expr_stmt|;
break|break;
case|case
name|DSE_SERVICEERROR
case|:
name|errmsg
operator|=
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|.
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
expr_stmt|;
break|break;
default|default:
name|log_ds_error
argument_list|(
operator|&
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"bind_compare_error_wakeup() - assuming all errors finish operation!"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|errtype
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|errmsg
expr_stmt|;
name|conn_init_err
argument_list|(
name|on
operator|->
name|on_bind_compare
argument_list|)
expr_stmt|;
block|}
name|oper_conn_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|oper_free
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bind_compare_fail_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"bind_compare_fail_wakeup()"
operator|)
argument_list|)
expr_stmt|;
comment|/*     *  If there are any more "di_block"s to attempt it must be     *  worth a go (perhaps this depends on the failure which     *  has occurrred).     */
if|if
condition|(
name|on
operator|->
name|on_bind_compare
operator|==
name|NULLCONN
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"bind_compare_fail_wakeup - connection initiating compare already failed"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ds_bind_error
modifier|*
name|error
init|=
operator|&
operator|(
name|on
operator|->
name|on_bind_compare
operator|->
name|cn_start
operator|.
name|cs_err
operator|)
decl_stmt|;
if|if
condition|(
name|on
operator|->
name|on_dsas
condition|)
block|{
if|if
condition|(
name|oper_chain
argument_list|(
name|on
argument_list|)
operator|==
name|OK
condition|)
return|return;
block|}
if|if
condition|(
name|on
operator|->
name|on_dsas
condition|)
block|{
comment|/* oper_chain must be awaiting deferred di_blocks */
return|return;
block|}
name|error
operator|->
name|dbe_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|error
operator|->
name|dbe_type
operator|=
name|DBE_TYPE_SERVICE
expr_stmt|;
name|error
operator|->
name|dbe_value
operator|=
name|DSE_SV_UNAVAILABLE
expr_stmt|;
name|conn_init_err
argument_list|(
name|on
operator|->
name|on_bind_compare
argument_list|)
expr_stmt|;
block|}
name|oper_conn_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|oper_free
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|do_ds_unbind
argument_list|(
name|conn
argument_list|)
specifier|register
expr|struct
name|connection
operator|*
name|conn
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|char
name|buff
index|[
name|LINESIZE
index|]
decl_stmt|;
if|if
condition|(
name|conn
operator|->
name|cn_initiator
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Unbind (%d) (initiator)"
argument_list|,
name|conn
operator|->
name|cn_ad
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Unbind (%d) (responder)"
argument_list|,
name|conn
operator|->
name|cn_ad
argument_list|)
expr_stmt|;
block|}
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
name|buff
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|conn
operator|->
name|cn_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"ds_un_bind"
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

