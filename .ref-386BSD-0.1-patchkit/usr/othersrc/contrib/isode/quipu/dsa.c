begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dsa.c - Main routine for QUIPU DSA process */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/dsa.c,v 7.9 91/03/09 11:56:48 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/quipu/RCS/dsa.c,v 7.9 91/03/09 11:56:48 mrose Exp $  *  *  * $Log:	dsa.c,v $  * Revision 7.9  91/03/09  11:56:48  mrose  * update  *   * Revision 7.8  91/02/22  09:39:04  mrose  * Interim 6.8  *   * Revision 7.7  90/11/20  15:28:47  mrose  * cjr  *   * Revision 7.6  90/10/17  11:54:00  mrose  * sync  *   * Revision 7.5  90/07/09  14:45:56  mrose  * sync  *   * Revision 7.4  90/03/15  11:18:57  mrose  * quipu-sync  *   * Revision 7.3  90/01/11  23:55:57  mrose  * lint  *   * Revision 7.2  90/01/11  18:37:21  mrose  * real-sync  *   * Revision 7.1  89/12/19  16:53:08  mrose  * dgram  *   * Revision 7.0  89/11/23  22:17:19  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"rosap.h"
end_include

begin_include
include|#
directive|include
file|"tsap.h"
end_include

begin_include
include|#
directive|include
file|"logger.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/connection.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dgram.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_include
include|#
directive|include
file|"internet.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|PS
name|opt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nbits
init|=
name|FD_SETSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|adios
argument_list|()
decl_stmt|,
name|advise
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|envinit
argument_list|()
operator|,
name|setdsauid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
name|SFD
name|attempt_restart
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|print_parse_errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|parse_line
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|task_act
modifier|*
name|task_select
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|SFP
name|abort_vector
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_STATS
end_ifndef

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_stat
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* * Basic data structure of the DSA server. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mydsaname
init|=
literal|"undefined"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|PSAPaddr
modifier|*
name|mydsaaddr
init|=
name|NULLPA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|PSAPaddr
modifier|*
name|dsaladdr
init|=
name|NULLPA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|connection
modifier|*
name|connlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|conns_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|connection
modifier|*
name|connwaitlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|di_block
modifier|*
name|deferred_dis
init|=
name|NULL_DI_BLOCK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|get_edb_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|sargv
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|unsigned
name|proc_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|new_size
decl_stmt|;
specifier|extern
name|caddr_t
name|sbrk
parameter_list|()
function_decl|;
endif|#
directive|endif
specifier|extern
name|char
modifier|*
name|mydsaname
decl_stmt|;
specifier|extern
name|char
name|startup_update
decl_stmt|;
specifier|extern
name|time_t
name|timenow
decl_stmt|;
name|struct
name|task_act
modifier|*
name|task
decl_stmt|;
name|int
name|secs
decl_stmt|;
name|char
name|start_buf
index|[
name|LINESIZE
index|]
decl_stmt|;
comment|/*     * Function to stop DSA server.     */
name|SFD
name|stop_dsa
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|SIGUSR1
name|SFD
name|list_status
parameter_list|()
function_decl|;
endif|#
directive|endif
name|sargv
operator|=
name|argv
expr_stmt|;
if|if
condition|(
name|myname
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
name|myname
operator|++
expr_stmt|;
if|if
condition|(
name|myname
operator|==
name|NULL
operator|||
operator|*
name|myname
operator|==
name|NULL
condition|)
name|myname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|isodetailor
argument_list|(
name|myname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|envinit
argument_list|()
expr_stmt|;
comment|/* detach */
name|quipu_syntaxes
argument_list|()
expr_stmt|;
name|dsa_sys_init
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|setdsauid
argument_list|()
expr_stmt|;
name|print_parse_errors
operator|=
name|FALSE
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|ll_hdinit
argument_list|(
name|log_stat
argument_list|,
name|myname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|opt
operator|=
name|ps_alloc
argument_list|(
name|std_open
argument_list|)
operator|)
operator|==
name|NULLPS
condition|)
name|fatal
argument_list|(
operator|-
literal|12
argument_list|,
literal|"ps_alloc failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|std_setup
argument_list|(
name|opt
argument_list|,
name|stdout
argument_list|)
operator|==
name|NOTOK
condition|)
name|fatal
argument_list|(
operator|-
literal|13
argument_list|,
literal|"std_setup failed"
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"About to dsa_init()"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsa_init
argument_list|()
operator|==
name|NOTOK
condition|)
block|{
name|fatal
argument_list|(
operator|-
literal|14
argument_list|,
literal|"Couldn't initialise the DSA!!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net_init
argument_list|()
operator|==
name|NOTOK
condition|)
block|{
name|fatal
argument_list|(
operator|-
literal|15
argument_list|,
literal|"Couldn't start the DSA!!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|startup_update
condition|)
block|{
comment|/* Will generate a list of EDB operations! */
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|slave_update
argument_list|()
expr_stmt|;
block|}
block|{
specifier|extern
name|char
modifier|*
name|treedir
decl_stmt|;
name|char
name|filebuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|filebuf
argument_list|,
literal|"%s/PID"
argument_list|,
name|treedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|filebuf
argument_list|,
literal|"w"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Can't open PID file %s"
operator|,
name|filebuf
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*     * Do stop_dsa() on receiving a Ctrl-C     */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|stop_dsa
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|stop_dsa
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|stop_dsa
argument_list|)
expr_stmt|;
comment|/* now started don't stop on core dumps !!! */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|attempt_restart
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|attempt_restart
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|attempt_restart
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|attempt_restart
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|attempt_restart
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|attempt_restart
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGUSR1
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|list_status
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abort_vector
operator|=
name|attempt_restart
expr_stmt|;
name|parse_line
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|start_buf
argument_list|,
literal|"DSA %s has started on %s"
argument_list|,
name|mydsaname
argument_list|,
name|paddr2str
argument_list|(
name|dsaladdr
argument_list|,
name|NULLNA
argument_list|)
argument_list|)
expr_stmt|;
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
name|start_buf
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|LLOG
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
name|start_buf
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|start_buf
argument_list|)
expr_stmt|;
name|start_malloc_trace
argument_list|(
name|NULLCP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|proc_size
operator|=
operator|(
name|unsigned
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|task
operator|=
name|task_select
argument_list|(
operator|&
name|secs
argument_list|)
operator|)
operator|==
name|NULLTASK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|secs
operator|!=
literal|0
condition|)
block|{
comment|/* Only if we are idle ! */
name|new_size
operator|=
operator|(
name|unsigned
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_size
operator|>
name|proc_size
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Process grown by %d bytes"
operator|,
name|new_size
operator|-
name|proc_size
operator|)
argument_list|)
expr_stmt|;
name|proc_size
operator|=
name|new_size
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|dsa_wait
argument_list|(
name|secs
argument_list|)
expr_stmt|;
comment|/* Check network with timeout of secs */
block|}
else|else
block|{
name|dsa_work
argument_list|(
name|task
argument_list|)
expr_stmt|;
comment|/* Process the DSA task selected */
name|dsa_wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* forever */
block|}
end_function

begin_comment
comment|/* main */
end_comment

begin_macro
name|dsa_abort
argument_list|(
argument|isfatal
argument_list|)
end_macro

begin_decl_stmt
name|int
name|isfatal
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|connection
modifier|*
name|cn
decl_stmt|;
name|struct
name|DSAPindication
name|di_s
decl_stmt|;
name|struct
name|DSAPindication
modifier|*
name|di
init|=
operator|&
name|di_s
decl_stmt|;
for|for
control|(
name|cn
operator|=
name|connlist
init|;
name|cn
operator|!=
name|NULLCONN
condition|;
name|cn
operator|=
name|cn
operator|->
name|cn_next
control|)
if|if
condition|(
name|cn
operator|->
name|cn_ad
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
name|isfatal
operator|||
operator|(
operator|!
name|cn
operator|->
name|cn_initiator
operator|)
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|cn
operator|->
name|cn_ad
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|DUAbortRequest
argument_list|(
name|cn
operator|->
name|cn_ad
argument_list|,
name|di
argument_list|)
expr_stmt|;
block|}
block|}
name|watch_dog
argument_list|(
literal|"stop_listeners"
argument_list|)
expr_stmt|;
name|stop_listeners
argument_list|()
expr_stmt|;
name|watch_dog_reset
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|SFD
name|stop_dsa
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* to stop recursion */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"*** Stopping on signal %d ***"
operator|,
name|sig
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DSA %s has Stopped\n"
argument_list|,
name|mydsaname
argument_list|)
expr_stmt|;
name|dsa_abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGUSR1
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|SFD
name|list_status
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|struct
name|connection
modifier|*
name|cn
decl_stmt|;
name|time_t
name|now
decl_stmt|;
ifndef|#
directive|ifndef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|list_status
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|fd
operator|=
name|getdtablesize
argument_list|()
operator|-
literal|1
init|;
name|fd
operator|>=
literal|0
condition|;
name|fd
operator|--
control|)
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|)
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"fd %d: fmt=0%o"
operator|,
name|fd
operator|,
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"logs dsap=%d stat=%d"
operator|,
name|log_dsap
operator|->
name|ll_fd
operator|,
name|log_stat
operator|->
name|ll_fd
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"logs dsap=%d"
operator|,
name|log_dsap
operator|->
name|ll_fd
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
for|for
control|(
name|cn
operator|=
name|connlist
init|;
name|cn
condition|;
name|cn
operator|=
name|cn
operator|->
name|cn_next
control|)
if|if
condition|(
name|cn
operator|->
name|cn_ad
operator|!=
name|NOTOK
condition|)
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"cn %d: init=%d used=%ld release=%ld"
operator|,
name|cn
operator|->
name|cn_ad
operator|,
name|cn
operator|->
name|cn_initiator
operator|,
operator|(
name|long
operator|)
name|now
operator|-
name|cn
operator|->
name|cn_last_used
operator|,
operator|(
name|long
operator|)
name|now
operator|-
name|cn
operator|->
name|cn_last_release
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|envinit
argument_list|()
block|{
name|int
name|i
block|,
name|sd
block|;
name|nbits
operator|=
name|getdtablesize
argument_list|()
block|;
if|if
condition|(
operator|!
operator|(
name|debug
operator|=
name|isatty
argument_list|(
literal|2
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|OK
case|:
goto|goto
name|fork_ok
goto|;
default|default:
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_break
break|break;
end_break

begin_empty_stmt
unit|}  fork_ok:
empty_stmt|;
end_empty_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|sd
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|sd
argument_list|,
literal|0
argument_list|)
operator|,
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SETSID
end_ifdef

begin_if
if|if
condition|(
name|setsid
argument_list|()
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"setsid"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCNOTTY
end_ifdef

begin_if
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|sd
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_expr_stmt
operator|(
name|void
operator|)
name|setpgrp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
unit|}
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_comment
comment|/* "Normal" ISODE behavior of full logging only without DEBUG */
end_comment

begin_expr_stmt
unit|else
name|ll_dbinit
argument_list|(
name|log_dsap
argument_list|,
name|myname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sun
end_ifndef

begin_comment
comment|/* damn YP... */
end_comment

begin_for
for|for
control|(
name|sd
operator|=
literal|3
init|;
name|sd
operator|<
name|nbits
condition|;
name|sd
operator|++
control|)
block|{
if|if
condition|(
name|log_dsap
operator|->
name|ll_fd
operator|==
name|sd
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NO_STATS
if|if
condition|(
name|log_stats
operator|->
name|ll_fd
operator|==
name|sd
condition|)
continue|continue;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
end_for

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ll_hdinit
argument_list|(
name|log_dsap
argument_list|,
name|myname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_expr_stmt
name|advise
argument_list|(
name|LLOG_TRACE
argument_list|,
name|NULLCP
argument_list|,
literal|"starting"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/*
comment|ERRORS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
unit|void
name|adios
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_ll_log
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"adios exit - see dsap.log\n"
argument_list|)
expr_stmt|;
name|dsa_abort
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|18
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|adios
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|adios
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|advise
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|int
name|code
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_ll_log
argument_list|(
name|log_dsap
argument_list|,
name|code
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|advise
parameter_list|(
name|code
parameter_list|,
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|advise
argument_list|(
name|code
argument_list|,
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|setdsauid
argument_list|()
block|{ struct
name|stat
name|buf
block|;
specifier|extern
name|char
operator|*
name|treedir
block|;
operator|(
name|void
operator|)
name|stat
argument_list|(
name|treedir
argument_list|,
operator|&
name|buf
argument_list|)
block|;
if|if
condition|(
name|setgid
argument_list|(
name|buf
operator|.
name|st_gid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Can't set gid %d (database directory \"%s\")"
operator|,
name|buf
operator|.
name|st_uid
operator|,
name|treedir
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|setuid
argument_list|(
name|buf
operator|.
name|st_uid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Can't set uid %d (database directory \"%s\")"
operator|,
name|buf
operator|.
name|st_uid
operator|,
name|treedir
operator|)
argument_list|)
expr_stmt|;
end_if

begin_define
unit|}
define|#
directive|define
name|RESTART_TIME
value|30
end_define

begin_comment
comment|/* for connections to clear... */
end_comment

begin_define
define|#
directive|define
name|CLEAR_TIME
value|300
end_define

begin_comment
comment|/*   .. */
end_comment

begin_macro
unit|SFD
name|attempt_restart
argument_list|(
argument|sig
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fpid
decl_stmt|,
name|sd
decl_stmt|;
name|unsigned
name|int
name|secs
decl_stmt|;
specifier|extern
name|char
modifier|*
name|mydsaname
decl_stmt|;
if|if
condition|(
name|sig
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* to stop recursion */
if|if
condition|(
name|sig
operator|>=
literal|0
operator|&&
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DSA %s has a problem\n"
argument_list|,
name|mydsaname
argument_list|)
expr_stmt|;
name|dsa_abort
argument_list|(
name|sig
operator|!=
name|NOTOK
argument_list|)
expr_stmt|;
name|secs
operator|=
name|sig
operator|!=
name|NOTOK
condition|?
name|CLEAR_TIME
else|:
name|RESTART_TIME
expr_stmt|;
for|for
control|(
name|sd
operator|=
literal|3
init|;
name|sd
operator|<
name|nbits
condition|;
name|sd
operator|++
control|)
block|{
if|if
condition|(
name|log_dsap
operator|->
name|ll_fd
operator|==
name|sd
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NO_STATS
if|if
condition|(
name|log_stats
operator|->
name|ll_fd
operator|==
name|sd
condition|)
continue|continue;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sig
operator|==
operator|-
literal|2
operator|||
operator|(
name|fpid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sig
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* restart due to congestion... */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"*** in-situ restart attempted ***"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|LLOG
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"RESTARTING (%s)"
operator|,
name|mydsaname
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sleep
argument_list|(
name|secs
argument_list|)
expr_stmt|;
comment|/* give connections time to clear */
operator|(
name|void
operator|)
name|execv
argument_list|(
name|isodefile
argument_list|(
name|sargv
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sargv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|19
argument_list|)
expr_stmt|;
block|}
name|log_dsap
operator|->
name|ll_syslog
operator|=
name|LLOG_FATAL
expr_stmt|;
if|if
condition|(
name|fpid
operator|!=
operator|-
literal|1
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"Quipu restart attempted in %d seconds (sig %d)"
operator|,
name|secs
operator|,
name|sig
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|LLOG
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"RESTARTING with pid %d (%s)"
operator|,
name|fpid
operator|,
name|mydsaname
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|LLOG
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"PANIC (%s)"
operator|,
name|mydsaname
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"Quipu aborting - sig (%d)"
operator|,
name|sig
operator|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|20
argument_list|)
expr_stmt|;
comment|/* abort should not return */
block|}
end_block

end_unit

