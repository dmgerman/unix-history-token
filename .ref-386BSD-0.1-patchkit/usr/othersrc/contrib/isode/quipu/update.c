begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* update.c - write EDB back to disk after modify */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/update.c,v 7.6 91/03/09 11:57:16 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/quipu/RCS/update.c,v 7.6 91/03/09 11:57:16 mrose Exp $  *  *  * $Log:	update.c,v $  * Revision 7.6  91/03/09  11:57:16  mrose  * update  *   * Revision 7.5  91/02/22  09:40:12  mrose  * Interim 6.8  *   * Revision 7.4  90/10/17  11:55:02  mrose  * sync  *   * Revision 7.3  90/07/09  14:46:49  mrose  * sync  *   * Revision 7.2  90/03/15  11:19:14  mrose  * quipu-sync  *   * Revision 7.1  89/12/19  16:20:54  mrose  * sync  *   * Revision 7.0  89/11/23  22:18:18  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/entry.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"quipu/read.h"
end_include

begin_include
include|#
directive|include
file|"quipu/dua.h"
end_include

begin_include
include|#
directive|include
file|"quipu/connection.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TURBO_AVL
end_ifdef

begin_include
include|#
directive|include
file|"quipu/turbo.h"
end_include

begin_function_decl
specifier|extern
name|int
name|parent_link
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_STATS
end_ifndef

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_stat
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|dn_print
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|new_version
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|remote_lookup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|local_slave_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|slave_edbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Entry
name|database_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DN
name|mydsadn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Attr_Sequence
name|dsa_real_attr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|Entry
name|local_find_entry_aux
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|oper_act
modifier|*
name|oper_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|oper_act
modifier|*
name|make_get_edb_op
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|TURBO_DISK
end_ifndef

begin_comment
comment|/* routine name is historic - not significant */
end_comment

begin_macro
name|journal
argument_list|(
argument|myentry
argument_list|)
end_macro

begin_decl_stmt
name|Entry
name|myentry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|dn2edbfile
argument_list|()
decl_stmt|;
name|char
name|savefile
index|[
name|LINESIZE
index|]
decl_stmt|,
name|newfile
index|[
name|LINESIZE
index|]
decl_stmt|;
name|DN
name|dn
decl_stmt|;
specifier|extern
name|char
modifier|*
name|treedir
decl_stmt|;
specifier|extern
name|char
modifier|*
name|parse_file
decl_stmt|;
name|Entry
name|liststart
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|myentry
operator|==
name|NULLENTRY
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"update edb problem"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|myentry
operator|->
name|e_parent
operator|!=
name|NULLENTRY
operator|)
operator|&&
operator|(
name|myentry
operator|->
name|e_parent
operator|->
name|e_leaf
operator|)
condition|)
block|{
name|liststart
operator|=
name|myentry
expr_stmt|;
name|dn
operator|=
name|get_copy_dn
argument_list|(
name|liststart
operator|->
name|e_parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|filename
operator|=
name|dn2edbfile
argument_list|(
name|dn
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|myentry
operator|->
name|e_parent
operator|->
name|e_leaf
operator|=
name|FALSE
expr_stmt|;
comment|/* not a leaf now !! */
if|if
condition|(
name|write_edb
argument_list|(
name|liststart
argument_list|,
name|filename
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|myentry
operator|->
name|e_parent
operator|==
name|NULLENTRY
condition|)
block|{
name|liststart
operator|=
name|myentry
expr_stmt|;
name|dn
operator|=
name|NULLDN
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|TURBO_AVL
name|liststart
operator|=
operator|(
name|Entry
operator|)
name|avl_getone
argument_list|(
name|myentry
operator|->
name|e_parent
operator|->
name|e_children
argument_list|)
expr_stmt|;
else|#
directive|else
name|liststart
operator|=
name|myentry
operator|->
name|e_parent
operator|->
name|e_child
expr_stmt|;
endif|#
directive|endif
name|dn
operator|=
name|get_copy_dn
argument_list|(
name|liststart
operator|->
name|e_parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|filename
operator|=
name|dn2edbfile
argument_list|(
name|dn
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|newfile
argument_list|,
literal|".new"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_edb
argument_list|(
name|liststart
argument_list|,
name|newfile
argument_list|)
operator|!=
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|newfile
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|savefile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|savefile
argument_list|,
literal|".bak"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|savefile
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|filename
argument_list|,
name|savefile
argument_list|)
operator|==
name|NOTOK
condition|)
name|SLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|savefile
argument_list|,
operator|(
literal|"unable to link %s to"
operator|,
name|filename
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|newfile
argument_list|,
name|filename
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|SLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|filename
argument_list|,
operator|(
literal|"unable to rename %s to"
operator|,
name|newfile
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|savefile
argument_list|,
name|filename
argument_list|)
operator|==
name|NOTOK
operator|&&
operator|!
name|fileexists
argument_list|(
name|filename
argument_list|)
condition|)
name|LLOG
argument_list|(
argument|log_dsap
argument_list|,
argument|LLOG_EXCEPTIONS
argument_list|,
argument|(
literal|"and couldn't get old file back - PANIC!!!"
argument|)
argument_list|)
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|TURBO_DISK
end_endif

begin_macro
name|modify_attr
argument_list|(
argument|eptr
argument_list|,
argument|who
argument_list|)
end_macro

begin_decl_stmt
name|Entry
name|eptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DN
name|who
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|AttributeType
name|at
decl_stmt|;
name|AttributeValue
name|av
decl_stmt|;
name|AV_Sequence
name|avs
decl_stmt|;
name|Attr_Sequence
name|as
decl_stmt|,
name|old
decl_stmt|,
name|entry_find_type
argument_list|()
decl_stmt|;
specifier|extern
name|int
name|no_last_mod
decl_stmt|;
if|if
condition|(
name|no_last_mod
condition|)
return|return;
name|at
operator|=
name|AttrT_new
argument_list|(
name|LAST_MOD_OID
argument_list|)
expr_stmt|;
name|av
operator|=
name|AttrV_alloc
argument_list|()
expr_stmt|;
name|av
operator|->
name|av_syntax
operator|=
name|str2syntax
argument_list|(
literal|"UTCTime"
argument_list|)
expr_stmt|;
name|av
operator|->
name|av_struct
operator|=
operator|(
name|caddr_t
operator|)
name|new_version
argument_list|()
expr_stmt|;
name|avs
operator|=
name|avs_comp_new
argument_list|(
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|old
operator|=
name|as_find_type
argument_list|(
name|eptr
operator|->
name|e_attributes
argument_list|,
name|at
argument_list|)
operator|)
operator|==
name|NULLATTR
condition|)
block|{
name|as
operator|=
name|as_comp_new
argument_list|(
name|at
argument_list|,
name|avs
argument_list|,
name|NULLACL_INFO
argument_list|)
expr_stmt|;
name|eptr
operator|->
name|e_attributes
operator|=
name|as_merge
argument_list|(
name|eptr
operator|->
name|e_attributes
argument_list|,
name|as
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|avs_free
argument_list|(
name|old
operator|->
name|attr_value
argument_list|)
expr_stmt|;
name|old
operator|->
name|attr_value
operator|=
name|avs
expr_stmt|;
name|AttrT_free
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
name|at
operator|=
name|AttrT_new
argument_list|(
name|MOD_BY_OID
argument_list|)
expr_stmt|;
name|av
operator|=
name|AttrV_alloc
argument_list|()
expr_stmt|;
name|av
operator|->
name|av_syntax
operator|=
name|str2syntax
argument_list|(
literal|"DN"
argument_list|)
expr_stmt|;
name|av
operator|->
name|av_struct
operator|=
operator|(
name|caddr_t
operator|)
name|dn_cpy
argument_list|(
name|who
argument_list|)
expr_stmt|;
name|avs
operator|=
name|avs_comp_new
argument_list|(
name|av
argument_list|)
expr_stmt|;
comment|/* Is it inherited ? */
name|set_inheritance
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|old
operator|=
name|entry_find_type
argument_list|(
name|eptr
argument_list|,
name|at
argument_list|)
operator|)
operator|!=
name|NULLATTR
condition|)
comment|/* possibly... */
if|if
condition|(
name|as_find_type
argument_list|(
name|eptr
operator|->
name|e_attributes
argument_list|,
name|at
argument_list|)
operator|==
name|NULLATTR
condition|)
comment|/* yes ! */
if|if
condition|(
name|avs_cmp
argument_list|(
name|avs
argument_list|,
name|old
operator|->
name|attr_value
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* No need to change it ! */
name|avs_free
argument_list|(
name|avs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|old
operator|==
name|NULLATTR
condition|)
block|{
name|as
operator|=
name|as_comp_new
argument_list|(
name|at
argument_list|,
name|avs
argument_list|,
name|NULLACL_INFO
argument_list|)
expr_stmt|;
name|eptr
operator|->
name|e_attributes
operator|=
name|as_merge
argument_list|(
name|eptr
operator|->
name|e_attributes
argument_list|,
name|as
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|avs_free
argument_list|(
name|old
operator|->
name|attr_value
argument_list|)
expr_stmt|;
name|old
operator|->
name|attr_value
operator|=
name|avs
expr_stmt|;
name|AttrT_free
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|allowed_to_send
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
specifier|register
name|DN
name|a
operator|,
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* Return TRUE if the DNs are the same */
comment|/* Return TRUE if all components of 'a' match, but 'b' has one extra */
comment|/* False otherwise */
if|if
condition|(
operator|(
name|a
operator|==
name|NULLDN
operator|)
operator|||
operator|(
name|b
operator|==
name|NULLDN
operator|)
condition|)
return|return
name|FALSE
return|;
for|for
control|(
init|;
name|a
operator|!=
name|NULLDN
operator|&&
name|b
operator|!=
name|NULLDN
condition|;
name|a
operator|=
name|a
operator|->
name|dn_parent
operator|,
name|b
operator|=
name|b
operator|->
name|dn_parent
control|)
if|if
condition|(
name|dn_comp_cmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|b
operator|==
name|NULLDN
operator|)
operator|||
operator|(
name|b
operator|->
name|dn_parent
operator|==
name|NULLDN
operator|)
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_block

begin_macro
name|do_get_edb
argument_list|(
argument|arg
argument_list|,
argument|error
argument_list|,
argument|result
argument_list|,
argument|binddn
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|getedb_arg
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|DSError
modifier|*
name|error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|getedb_result
modifier|*
name|result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DN
name|binddn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Entry
name|eptr
decl_stmt|;
name|Entry
name|my_entry
decl_stmt|;
name|AV_Sequence
name|avs
decl_stmt|;
name|struct
name|edb_info
modifier|*
name|dsainfo
decl_stmt|;
name|char
name|proceed
init|=
name|FALSE
decl_stmt|;
name|struct
name|dn_seq
modifier|*
name|dnseq
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
name|Entry
name|akid
decl_stmt|;
endif|#
directive|endif
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"getedb '%s'"
operator|,
name|arg
operator|->
name|ga_version
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|really_find_entry
argument_list|(
name|arg
operator|->
name|ga_entry
argument_list|,
name|FALSE
argument_list|,
name|NULLDNSEQ
argument_list|,
name|FALSE
argument_list|,
operator|&
operator|(
name|eptr
operator|)
argument_list|,
name|error
argument_list|,
operator|&
operator|(
name|di
operator|)
argument_list|)
condition|)
block|{
case|case
name|DS_OK
case|:
comment|/* 	    *  Entry has been found and returned via eptr. 	    *  Go through and process this entry. 	    */
break|break;
case|case
name|DS_CONTINUE
case|:
comment|/* 	    * Get edb operations should never generate referrals. 	    * Free the di_blocks generated and return an error. 	    */
name|error
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|error
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_CHAININGREQUIRED
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
case|case
name|DS_X500_ERROR
case|:
comment|/* something wrong with the request - error should be filled out */
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
default|default:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"do_get_edb() - really_find_entry() failed"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|error
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_DITERROR
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|my_entry
operator|=
name|local_find_entry_aux
argument_list|(
name|mydsadn
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
name|fatal
argument_list|(
literal|84
argument_list|,
literal|"my entry has gone - no getedb"
argument_list|)
expr_stmt|;
comment|/* Check we will send to this DSA */
for|for
control|(
name|avs
operator|=
name|my_entry
operator|->
name|e_dsainfo
operator|->
name|dsa_attr
init|;
name|avs
operator|!=
name|NULLAV
condition|;
name|avs
operator|=
name|avs
operator|->
name|avseq_next
control|)
block|{
if|if
condition|(
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
operator|==
name|NULL
condition|)
continue|continue;
name|dsainfo
operator|=
operator|(
expr|struct
name|edb_info
operator|*
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
expr_stmt|;
if|if
condition|(
name|dn_cmp
argument_list|(
name|dsainfo
operator|->
name|edb_name
argument_list|,
name|arg
operator|->
name|ga_entry
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|dnseq
operator|=
name|dsainfo
operator|->
name|edb_allowed
init|;
name|dnseq
operator|!=
name|NULLDNSEQ
condition|;
name|dnseq
operator|=
name|dnseq
operator|->
name|dns_next
control|)
block|{
if|if
condition|(
name|allowed_to_send
argument_list|(
name|dnseq
operator|->
name|dns_dn
argument_list|,
name|binddn
argument_list|)
condition|)
block|{
name|proceed
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|proceed
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|proceed
condition|)
block|{
name|error
operator|->
name|dse_type
operator|=
name|DSE_SECURITYERROR
expr_stmt|;
name|error
operator|->
name|ERR_SECURITY
operator|.
name|DSE_sc_problem
operator|=
name|DSE_SC_ACCESSRIGHTS
expr_stmt|;
return|return
operator|(
name|DS_ERROR_REMOTE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TURBO_AVL
name|akid
operator|=
operator|(
name|Entry
operator|)
name|avl_getone
argument_list|(
name|eptr
operator|->
name|e_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|akid
operator|==
name|NULLENTRY
operator|||
operator|(
name|akid
operator|->
name|e_data
operator|!=
name|E_DATA_MASTER
operator|&&
name|akid
operator|->
name|e_data
operator|!=
name|E_TYPE_SLAVE
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|eptr
operator|->
name|e_child
operator|==
name|NULLENTRY
operator|)
operator|||
operator|(
operator|(
name|eptr
operator|->
name|e_child
operator|->
name|e_data
operator|!=
name|E_DATA_MASTER
operator|)
operator|&&
operator|(
name|eptr
operator|->
name|e_child
operator|->
name|e_data
operator|!=
name|E_TYPE_SLAVE
operator|)
operator|)
condition|)
block|{
endif|#
directive|endif
name|error
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|error
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_DITERROR
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|eptr
operator|->
name|e_edbversion
operator|!=
name|NULLCP
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"edb_ver = %s"
operator|,
name|eptr
operator|->
name|e_edbversion
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
name|arg
operator|->
name|ga_version
argument_list|,
name|eptr
operator|->
name|e_edbversion
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|->
name|gr_version
operator|=
name|eptr
operator|->
name|e_edbversion
expr_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
name|result
operator|->
name|gr_edb
operator|=
name|NULLAVL
expr_stmt|;
else|#
directive|else
name|result
operator|->
name|gr_edb
operator|=
name|NULLENTRY
expr_stmt|;
endif|#
directive|endif
name|result
operator|->
name|gr_next
operator|=
name|NULL_GETRESULT
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
block|}
else|else
name|eptr
operator|->
name|e_edbversion
operator|=
name|new_version
argument_list|()
expr_stmt|;
name|result
operator|->
name|gr_version
operator|=
name|eptr
operator|->
name|e_edbversion
expr_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
name|result
operator|->
name|gr_edb
operator|=
name|eptr
operator|->
name|e_children
expr_stmt|;
else|#
directive|else
name|result
operator|->
name|gr_edb
operator|=
name|eptr
operator|->
name|e_child
expr_stmt|;
endif|#
directive|endif
name|result
operator|->
name|gr_next
operator|=
name|NULL_GETRESULT
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
name|slave_update
argument_list|()
block|{
specifier|extern
name|time_t
name|lastedb_update
decl_stmt|,
name|timenow
decl_stmt|;
operator|(
name|void
operator|)
name|update_aux
argument_list|(
name|NULLDN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shadow_update
argument_list|()
expr_stmt|;
name|lastedb_update
operator|=
name|timenow
expr_stmt|;
block|}
name|update_aux
argument_list|(
argument|dn
argument_list|,
argument|isroot
argument_list|)
name|DN
name|dn
decl_stmt|;
name|int
name|isroot
decl_stmt|;
block|{
name|Entry
name|my_entry
decl_stmt|,
name|make_path
argument_list|()
decl_stmt|;
name|Entry
name|find_sibling
parameter_list|()
function_decl|;
specifier|extern
name|DN
name|mydsadn
decl_stmt|;
name|struct
name|edb_info
modifier|*
name|dsainfo
decl_stmt|;
name|Entry
name|eptr
decl_stmt|;
specifier|static
name|char
modifier|*
name|version
init|=
name|NULLCP
decl_stmt|;
name|AV_Sequence
name|avs
decl_stmt|;
name|AV_Sequence
name|avs_head
decl_stmt|;
name|int
name|success
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"slave update"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|my_entry
operator|=
name|local_find_entry_aux
argument_list|(
name|mydsadn
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
name|fatal
argument_list|(
literal|82
argument_list|,
literal|"Can't update slaves - my entry has gone"
argument_list|)
expr_stmt|;
name|avs_head
operator|=
name|avs_cpy
argument_list|(
name|my_entry
operator|->
name|e_dsainfo
operator|->
name|dsa_attr
argument_list|)
expr_stmt|;
for|for
control|(
name|avs
operator|=
name|avs_head
init|;
name|avs
operator|!=
name|NULLAV
condition|;
name|avs
operator|=
name|avs
operator|->
name|avseq_next
control|)
block|{
if|if
condition|(
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
operator|==
name|NULL
condition|)
continue|continue;
name|dsainfo
operator|=
operator|(
expr|struct
name|edb_info
operator|*
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
expr_stmt|;
if|if
condition|(
name|dsainfo
operator|->
name|edb_getfrom
operator|==
name|NULLDN
condition|)
continue|continue;
comment|/* not an EDB to update */
if|if
condition|(
operator|(
name|dn
operator|||
name|isroot
operator|)
operator|&&
name|dn_cmp
argument_list|(
name|dn
argument_list|,
name|dsainfo
operator|->
name|edb_name
argument_list|)
operator|!=
name|OK
condition|)
continue|continue;
comment|/* not an EDB this time */
if|if
condition|(
operator|(
name|eptr
operator|=
name|local_find_entry
argument_list|(
name|dsainfo
operator|->
name|edb_name
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
name|version
operator|=
literal|"0000000000Z"
expr_stmt|;
name|eptr
operator|=
name|make_path
argument_list|(
name|dsainfo
operator|->
name|edb_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|version
operator|=
name|eptr
operator|->
name|e_edbversion
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"update_aux: edbversion was NULLCP"
operator|)
argument_list|)
expr_stmt|;
name|version
operator|=
literal|"0000000000Z"
expr_stmt|;
block|}
block|}
name|success
operator|=
name|send_get_edb
argument_list|(
name|version
argument_list|,
name|dsainfo
operator|->
name|edb_name
argument_list|,
name|dsainfo
operator|->
name|edb_getfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|||
name|isroot
condition|)
break|break;
name|dsa_wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* accept any results of previous ops */
block|}
name|avs_free
argument_list|(
name|avs_head
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|dn
operator|||
name|isroot
operator|)
condition|?
name|success
else|:
name|OK
operator|)
return|;
block|}
name|int
name|send_get_edb
parameter_list|(
name|version
parameter_list|,
name|dn
parameter_list|,
name|from
parameter_list|)
name|char
modifier|*
name|version
decl_stmt|;
name|DN
name|dn
decl_stmt|,
name|from
decl_stmt|;
block|{
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
name|struct
name|DSError
name|error
decl_stmt|;
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|PS
name|ps
decl_stmt|;
switch|switch
condition|(
name|get_dsa_info
argument_list|(
name|from
argument_list|,
name|NULLDNSEQ
argument_list|,
operator|&
operator|(
name|error
operator|)
argument_list|,
operator|&
operator|(
name|di
operator|)
argument_list|)
condition|)
block|{
case|case
name|DS_OK
case|:
comment|/* 	    *  di is a completed dsa info block 	    *  Make a get_edb operation from it, attempt to send the operation 	    *  and link the operation onto the global list of get_edb 	    *  operations. 	    */
if|if
condition|(
name|ps
operator|=
name|ps_alloc
argument_list|(
name|str_open
argument_list|)
condition|)
block|{
if|if
condition|(
name|str_setup
argument_list|(
name|ps
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
literal|1
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|ps_printf
argument_list|(
name|ps
argument_list|,
literal|"contact "
argument_list|)
expr_stmt|;
name|dn_print
argument_list|(
name|ps
argument_list|,
name|from
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|ps
argument_list|,
literal|" for "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
condition|)
name|dn_print
argument_list|(
name|ps
argument_list|,
name|dn
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
operator|*
name|ps
operator|->
name|ps_ptr
operator|=
name|NULL
expr_stmt|;
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"%s"
operator|,
name|buffer
operator|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ps_free
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"send_get_edb - get_dsa_info OK:"
operator|)
argument_list|)
expr_stmt|;
name|di_list_log
argument_list|(
name|di
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|on
operator|=
name|make_get_edb_op
argument_list|(
name|dn
argument_list|,
name|version
argument_list|,
name|di
argument_list|)
operator|)
operator|==
name|NULLOPER
condition|)
block|{
comment|/* Flake out screaming */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"make_get_edb_op failed for send_get_edb"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|PARA_GETEDB
comment|/* Do getEDBs in parallel as in 6.0 */
if|if
condition|(
name|oper_chain
argument_list|(
name|on
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Could not chain a getEDB operation"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|on
operator|->
name|on_next_task
operator|=
name|get_edb_ops
expr_stmt|;
name|get_edb_ops
operator|=
name|on
expr_stmt|;
else|#
directive|else
comment|/* Do getEDBs serially */
name|schedule_operation
argument_list|(
name|on
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|OK
operator|)
return|;
case|case
name|DS_CONTINUE
case|:
comment|/* 	    *  di is a deferred dsa info block 	    *  make the operation and suspend waiting for the di_block to be  	    *  woken up. 	    */
ifdef|#
directive|ifdef
name|DEBUG
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"send_get_edb - get_dsa_info CONT:"
operator|)
argument_list|)
expr_stmt|;
name|di_list_log
argument_list|(
name|di
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|on
operator|=
name|make_get_edb_op
argument_list|(
name|dn
argument_list|,
name|version
argument_list|,
name|di
argument_list|)
operator|)
operator|==
name|NULLOPER
condition|)
block|{
comment|/* Flake out screaming */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"make_get_edb_op failed for send_get_edb"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|on
operator|->
name|on_state
operator|=
name|ON_DEFERRED
expr_stmt|;
name|on
operator|->
name|on_next_task
operator|=
name|get_edb_ops
expr_stmt|;
name|get_edb_ops
operator|=
name|on
expr_stmt|;
if|if
condition|(
name|ps
operator|=
name|ps_alloc
argument_list|(
name|str_open
argument_list|)
condition|)
block|{
if|if
condition|(
name|str_setup
argument_list|(
name|ps
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
literal|1
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|ps_printf
argument_list|(
name|ps
argument_list|,
literal|"contact "
argument_list|)
expr_stmt|;
name|dn_print
argument_list|(
name|ps
argument_list|,
name|from
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|ps
argument_list|,
literal|" for "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
condition|)
name|dn_print
argument_list|(
name|ps
argument_list|,
name|dn
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
operator|*
name|ps
operator|->
name|ps_ptr
operator|=
name|NULL
expr_stmt|;
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"%s"
operator|,
name|buffer
operator|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ps_free
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
case|case
name|DS_X500_ERROR
case|:
comment|/* Error encountered generating di_block */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"send_get_edb - get_dsa_info returned X500 ERROR"
operator|)
argument_list|)
expr_stmt|;
name|log_ds_error
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
name|ds_error_free
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
default|default:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"send_get_edb - get_dsa_info unexpected return"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
ifdef|#
directive|ifdef
name|TURBO_AVL
specifier|static
name|Entry
name|g_parent
decl_stmt|;
specifier|static
name|int
name|g_entry_cnt
decl_stmt|;
comment|/*  * unravel_edb - called from avl_apply on a new slave edb to unravel the  * new entries and link them to their new parent node, which should be  * set in g_parent before the call.  */
specifier|static
name|unravel_edb
argument_list|(
argument|e
argument_list|,
argument|error
argument_list|)
name|Entry
name|e
expr_stmt|;
name|struct
name|DSError
modifier|*
name|error
decl_stmt|;
block|{
name|e
operator|->
name|e_parent
operator|=
name|g_parent
expr_stmt|;
if|if
condition|(
name|unravel_attribute
argument_list|(
name|e
argument_list|,
name|error
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
name|shadow_entry
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|turbo_add2index
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
comment|/*  * make_parent - called from link_child to set the parent of a node.  * it has to happen in this grossly inefficient way because make_parent  * is called from avl_apply.  */
specifier|static
name|link_child
argument_list|(
argument|e
argument_list|,
argument|oldkids
argument_list|)
name|Entry
name|e
expr_stmt|;
name|Avlnode
modifier|*
name|oldkids
decl_stmt|;
block|{
name|Entry
name|old_entry
decl_stmt|;
name|int
name|entryrdn_cmp
parameter_list|()
function_decl|;
name|g_entry_cnt
operator|++
expr_stmt|;
comment|/* find the old entry the new one is replacing */
name|old_entry
operator|=
operator|(
name|Entry
operator|)
name|avl_find
argument_list|(
name|oldkids
argument_list|,
operator|(
name|caddr_t
operator|)
name|e
operator|->
name|e_name
argument_list|,
name|entryrdn_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_entry
operator|==
name|NULLENTRY
condition|)
return|return
operator|(
name|OK
operator|)
return|;
name|e
operator|->
name|e_leaf
operator|=
name|old_entry
operator|->
name|e_leaf
expr_stmt|;
name|e
operator|->
name|e_allchildrenpresent
operator|=
name|old_entry
operator|->
name|e_allchildrenpresent
expr_stmt|;
name|e
operator|->
name|e_children
operator|=
name|old_entry
operator|->
name|e_children
expr_stmt|;
name|turbo_index_delete
argument_list|(
name|old_entry
argument_list|)
expr_stmt|;
name|turbo_add2index
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* link children to their new parent */
operator|(
name|void
operator|)
name|avl_apply
argument_list|(
name|e
operator|->
name|e_children
argument_list|,
name|parent_link
argument_list|,
operator|(
name|caddr_t
operator|)
name|e
argument_list|,
name|NOTOK
argument_list|,
name|AVL_PREORDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_entry
operator|->
name|e_edbversion
operator|!=
name|NULLCP
condition|)
name|e
operator|->
name|e_edbversion
operator|=
name|strdup
argument_list|(
name|old_entry
operator|->
name|e_edbversion
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* TURBO_AVL */
name|process_edb
argument_list|(
argument|on
argument_list|)
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
block|{
specifier|extern
name|DN
name|mydsadn
decl_stmt|;
name|Entry
name|make_path
argument_list|()
decl_stmt|,
name|find_sibling
argument_list|()
decl_stmt|;
name|Entry
name|eptr
decl_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
name|Avlnode
modifier|*
name|newkids
decl_stmt|;
name|int
name|entry_free
parameter_list|()
function_decl|;
else|#
directive|else
name|Entry
name|new_entry
decl_stmt|,
name|old_entry
decl_stmt|,
name|temp
decl_stmt|,
name|sibl
decl_stmt|,
name|next
decl_stmt|;
name|int
name|entry_cnt
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|struct
name|DSError
name|error
decl_stmt|;
name|struct
name|getedb_result
modifier|*
name|result
init|=
operator|&
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_ge
operator|)
decl_stmt|;
name|char
name|got_subtree
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|(
name|eptr
operator|=
name|local_find_entry
argument_list|(
name|on
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_ge
operator|.
name|ga_entry
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"Updating something which does not exist !!!"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|on
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_ge
operator|.
name|ga_entry
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|TURBO_AVL
if|if
condition|(
operator|(
name|newkids
operator|=
name|result
operator|->
name|gr_edb
operator|)
operator|==
name|NULLAVL
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|new_entry
operator|=
name|result
operator|->
name|gr_edb
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
endif|#
directive|endif
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"  EDBs are the same (%d): %s"
operator|,
name|on
operator|->
name|on_id
operator|,
name|on
operator|->
name|on_getedb_ver
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"  EDB updated from (%d): %s to: %s"
operator|,
name|on
operator|->
name|on_id
operator|,
name|on
operator|->
name|on_getedb_ver
operator|,
name|result
operator|->
name|gr_version
operator|)
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_STATS
block|{
name|DN
name|tmp_dn
decl_stmt|;
name|tmp_dn
operator|=
name|get_copy_dn
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
literal|"Slave update"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|tmp_dn
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|tmp_dn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|eptr
operator|->
name|e_edbversion
condition|)
name|free
argument_list|(
name|eptr
operator|->
name|e_edbversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|gr_version
operator|==
name|NULLCP
condition|)
block|{
name|eptr
operator|->
name|e_edbversion
operator|=
literal|"Unknown"
expr_stmt|;
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"EDBRES: NULL version"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|eptr
operator|->
name|e_edbversion
operator|=
name|strdup
argument_list|(
name|result
operator|->
name|gr_version
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
comment|/*          * now unravel the attributes, linking all nodes to eptr, their          * parent node.          */
name|g_parent
operator|=
name|eptr
expr_stmt|;
if|if
condition|(
name|avl_apply
argument_list|(
name|newkids
argument_list|,
name|unravel_edb
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|error
argument_list|,
name|NOTOK
argument_list|,
name|AVL_INORDER
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Error in new EDB - continuing with old"
operator|)
argument_list|)
expr_stmt|;
name|log_ds_error
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
return|return;
comment|/* ??? should we free newkids here ??? */
block|}
comment|/* 	 * the new edb is now unravelled and linked to its parent.  now go 	 * through and link children of entries in the old edb that also  	 * exist in the new edb to their new parent.  link_child updates 	 * g_entry_cnt with the number of entries in the new edb. 	 */
name|g_entry_cnt
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|avl_apply
argument_list|(
name|newkids
argument_list|,
name|link_child
argument_list|,
operator|(
name|caddr_t
operator|)
name|eptr
operator|->
name|e_children
argument_list|,
name|NOTOK
argument_list|,
name|AVL_INORDER
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|temp
operator|=
name|new_entry
init|;
name|temp
operator|!=
name|NULLENTRY
condition|;
name|temp
operator|=
name|temp
operator|->
name|e_sibling
control|)
block|{
name|temp
operator|->
name|e_parent
operator|=
name|eptr
expr_stmt|;
if|if
condition|(
name|unravel_attribute
argument_list|(
name|temp
argument_list|,
operator|&
name|error
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Error in new EDB - continuing with old"
operator|)
argument_list|)
expr_stmt|;
name|log_ds_error
argument_list|(
operator|&
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|shadow_entry
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|temp
operator|=
name|new_entry
init|;
name|temp
operator|!=
name|NULLENTRY
condition|;
name|temp
operator|=
name|temp
operator|->
name|e_sibling
control|)
block|{
name|entry_cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|old_entry
operator|=
name|find_sibling
argument_list|(
name|temp
operator|->
name|e_name
argument_list|,
name|eptr
operator|->
name|e_child
argument_list|)
operator|)
operator|!=
name|NULLENTRY
condition|)
block|{
name|temp
operator|->
name|e_leaf
operator|=
name|old_entry
operator|->
name|e_leaf
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|->
name|e_allchildrenpresent
operator|=
name|old_entry
operator|->
name|e_allchildrenpresent
operator|)
operator|!=
literal|2
condition|)
name|got_subtree
operator|=
name|FALSE
expr_stmt|;
name|temp
operator|->
name|e_child
operator|=
name|old_entry
operator|->
name|e_child
expr_stmt|;
for|for
control|(
name|sibl
operator|=
name|temp
operator|->
name|e_child
init|;
name|sibl
operator|!=
name|NULLENTRY
condition|;
name|sibl
operator|=
name|sibl
operator|->
name|e_sibling
control|)
block|{
name|sibl
operator|->
name|e_parent
operator|=
name|temp
expr_stmt|;
name|set_inheritance
argument_list|(
name|sibl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_entry
operator|->
name|e_edbversion
operator|!=
name|NULLCP
condition|)
name|temp
operator|->
name|e_edbversion
operator|=
name|strdup
argument_list|(
name|old_entry
operator|->
name|e_edbversion
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|temp
operator|->
name|e_leaf
condition|)
block|{
name|got_subtree
operator|=
name|FALSE
expr_stmt|;
name|temp
operator|->
name|e_allchildrenpresent
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* TURBO_AVL */
name|dsa_wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* progress any other connections before writing EDB */
ifdef|#
directive|ifdef
name|TURBO_AVL
if|if
condition|(
name|eptr
operator|->
name|e_children
operator|==
name|NULLAVL
condition|)
else|#
directive|else
if|if
condition|(
name|eptr
operator|->
name|e_child
operator|==
name|NULLENTRY
condition|)
endif|#
directive|endif
name|slave_edbs
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|TURBO_AVL
comment|/* 	 * now free up entries from the old edb and update the size of 	 * our cache. avl_free returns the number of nodes freed. 	 */
name|local_slave_size
operator|-=
name|avl_free
argument_list|(
name|eptr
operator|->
name|e_children
argument_list|,
name|entry_free
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|temp
operator|=
name|eptr
operator|->
name|e_child
init|;
name|temp
operator|!=
name|NULLENTRY
condition|;
name|temp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|temp
operator|->
name|e_sibling
expr_stmt|;
name|local_slave_size
operator|--
expr_stmt|;
name|entry_free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TURBO_AVL
name|eptr
operator|->
name|e_children
operator|=
name|newkids
expr_stmt|;
name|local_slave_size
operator|+=
name|g_entry_cnt
expr_stmt|;
else|#
directive|else
name|eptr
operator|->
name|e_child
operator|=
name|new_entry
expr_stmt|;
name|local_slave_size
operator|+=
name|entry_cnt
expr_stmt|;
endif|#
directive|endif
name|eptr
operator|->
name|e_leaf
operator|=
name|FALSE
expr_stmt|;
name|eptr
operator|->
name|e_allchildrenpresent
operator|=
operator|(
name|got_subtree
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TURBO_DISK
if|if
condition|(
name|turbo_writeall
argument_list|(
name|eptr
argument_list|)
operator|!=
name|OK
condition|)
name|fatal
argument_list|(
operator|-
literal|79
argument_list|,
literal|"Lost old EDB, can't write new one!!!"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TURBO_AVL
if|if
condition|(
name|journal
argument_list|(
operator|(
name|Entry
operator|)
name|avl_getone
argument_list|(
name|eptr
operator|->
name|e_children
argument_list|)
argument_list|)
operator|!=
name|OK
condition|)
else|#
directive|else
if|if
condition|(
name|journal
argument_list|(
name|new_entry
argument_list|)
operator|!=
name|OK
condition|)
endif|#
directive|endif
name|fatal
argument_list|(
operator|-
literal|79
argument_list|,
literal|"Lost old EDB, can't write new one !!!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|eptr
operator|=
name|local_find_entry_aux
argument_list|(
name|mydsadn
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
name|fatal
argument_list|(
operator|-
literal|80
argument_list|,
literal|"My entry has disappeared from the DIT !!!"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|as_cmp
argument_list|(
name|eptr
operator|->
name|e_attributes
argument_list|,
name|dsa_real_attr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Slave Copy out of date with my entry - re-applying modify"
operator|)
argument_list|)
expr_stmt|;
name|as_free
argument_list|(
name|eptr
operator|->
name|e_attributes
argument_list|)
expr_stmt|;
name|eptr
operator|->
name|e_attributes
operator|=
name|as_cpy
argument_list|(
name|dsa_real_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unravel_attribute
argument_list|(
name|eptr
argument_list|,
operator|&
name|error
argument_list|)
operator|!=
name|OK
condition|)
name|fatal
argument_list|(
operator|-
literal|81
argument_list|,
literal|"real DSA entry bad error"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* *  get_edb_fail_wakeup suffices for both fail and error conditions *  arising on a get edb operation. */
name|get_edb_fail_wakeup
argument_list|(
argument|on
argument_list|)
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
block|{
name|struct
name|oper_act
modifier|*
name|on_tmp
decl_stmt|;
name|struct
name|oper_act
modifier|*
modifier|*
name|on_p
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"get_edb_fail_wakeup"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
operator|->
name|on_resp
operator|.
name|di_type
operator|==
name|DI_ERROR
condition|)
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"Remote getEDB error"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|on
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_ge
operator|.
name|ga_entry
argument_list|)
expr_stmt|;
name|log_ds_error
argument_list|(
operator|&
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
argument_list|)
expr_stmt|;
block|}
name|on_p
operator|=
operator|&
operator|(
name|get_edb_ops
operator|)
expr_stmt|;
for|for
control|(
name|on_tmp
operator|=
name|get_edb_ops
init|;
name|on_tmp
operator|!=
name|NULLOPER
condition|;
name|on_tmp
operator|=
name|on_tmp
operator|->
name|on_next_task
control|)
block|{
if|if
condition|(
name|on_tmp
operator|==
name|on
condition|)
break|break;
name|on_p
operator|=
operator|&
operator|(
name|on_tmp
operator|->
name|on_next_task
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|on_tmp
operator|!=
name|NULLOPER
condition|)
block|{
operator|(
operator|*
name|on_p
operator|)
operator|=
name|on_tmp
operator|->
name|on_next_task
expr_stmt|;
block|}
else|else
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"get_edb_fail_wakeup - op escaped from get_edb_ops (the global list)"
operator|)
argument_list|)
expr_stmt|;
block|}
name|oper_conn_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|oper_free
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
name|struct
name|oper_act
modifier|*
name|make_get_edb_op
parameter_list|(
name|dn
parameter_list|,
name|version
parameter_list|,
name|di
parameter_list|)
name|DN
name|dn
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
block|{
name|struct
name|di_block
modifier|*
name|di_tmp
decl_stmt|;
name|struct
name|oper_act
modifier|*
name|on_tmp
decl_stmt|;
name|struct
name|getedb_arg
modifier|*
name|arg
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"make_get_edb_op"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|on_tmp
operator|=
name|oper_alloc
argument_list|()
operator|)
operator|==
name|NULLOPER
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"make_get_edb_op - out of memory"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULLOPER
operator|)
return|;
block|}
name|on_tmp
operator|->
name|on_type
operator|=
name|ON_TYPE_GET_EDB
expr_stmt|;
name|on_tmp
operator|->
name|on_arg
operator|=
operator|&
operator|(
name|on_tmp
operator|->
name|on_req
operator|)
expr_stmt|;
name|on_tmp
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_type
operator|=
name|OP_GETEDB
expr_stmt|;
name|on_tmp
operator|->
name|on_getedb_ver
operator|=
name|version
expr_stmt|;
name|arg
operator|=
operator|&
operator|(
name|on_tmp
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_ge
operator|)
expr_stmt|;
name|arg
operator|->
name|ga_entry
operator|=
name|dn_cpy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|arg
operator|->
name|ga_version
operator|=
name|strdup
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"EDBARG: ver = %s"
operator|,
name|arg
operator|->
name|ga_version
operator|)
argument_list|)
expr_stmt|;
name|on_tmp
operator|->
name|on_dsas
operator|=
name|di
expr_stmt|;
for|for
control|(
name|di_tmp
operator|=
name|di
init|;
name|di_tmp
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp
operator|=
name|di_tmp
operator|->
name|di_next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Linking a di_block to this op"
operator|)
argument_list|)
expr_stmt|;
name|di_log
argument_list|(
name|di_tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|di_tmp
operator|->
name|di_type
operator|=
name|DI_OPERATION
expr_stmt|;
name|di_tmp
operator|->
name|di_oper
operator|=
name|on_tmp
expr_stmt|;
block|}
return|return
operator|(
name|on_tmp
operator|)
return|;
block|}
end_block

end_unit

