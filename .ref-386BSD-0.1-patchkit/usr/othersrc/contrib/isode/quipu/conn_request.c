begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* conn_request.c - Generate DSP BIND from connection block */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/conn_request.c,v 7.6 91/02/22 09:38:33 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/quipu/RCS/conn_request.c,v 7.6 91/02/22 09:38:33 mrose Interim $  *  *  * $Log:	conn_request.c,v $  * Revision 7.6  91/02/22  09:38:33  mrose  * Interim 6.8  *   * Revision 7.5  90/10/17  11:53:28  mrose  * sync  *   * Revision 7.4  90/07/09  14:45:28  mrose  * sync  *   * Revision 7.3  89/12/19  16:20:06  mrose  * sync  *   * Revision 7.2  89/11/27  10:30:09  mrose  * sync  *   * Revision 7.1  89/11/24  16:21:56  mrose  * sync  *   * Revision 7.0  89/11/23  22:16:55  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|"quipu/dsap.h"
end_include

begin_include
include|#
directive|include
file|"tsap.h"
end_include

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/connection.h"
end_include

begin_decl_stmt
specifier|extern
name|time_t
name|timenow
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|connection
modifier|*
name|conn_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|conn_free
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_STATS
end_ifndef

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_stat
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|dn_print
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|PS
name|opt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|watchdog_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|watchdog_delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *  conn_request uses the directory bind argument and context *  set up in the connection block to generate an asynchronous *  association request. *  If OK is returned the connection should be linked onto *  the global list. *  If NOTOK is returned the connection block should be freed, *  alerting all the operations requesting it. */
end_comment

begin_expr_stmt
name|conn_request
argument_list|(
name|cn
argument_list|)
specifier|register
expr|struct
name|connection
operator|*
name|cn
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|DSAPconnect
modifier|*
name|dc
init|=
operator|&
operator|(
name|cn
operator|->
name|cn_connect
operator|.
name|cc_dc
operator|)
decl_stmt|;
name|struct
name|DSAPindication
name|di_s
decl_stmt|;
name|struct
name|DSAPindication
modifier|*
name|di
init|=
operator|&
operator|(
name|di_s
operator|)
decl_stmt|;
name|int
name|inv_ret
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"conn_request()"
operator|)
argument_list|)
expr_stmt|;
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"conn_request: Calling: %s"
operator|,
name|paddr2str
argument_list|(
operator|&
operator|(
name|cn
operator|->
name|cn_addr
operator|)
argument_list|,
name|NULLNA
argument_list|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cn
operator|->
name|cn_ctx
condition|)
block|{
case|case
name|DS_CTX_X500_DAP
case|:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Making DAP connections illegal for DSA"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
case|case
name|DS_CTX_X500_DSP
case|:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"Making an X500 DSP connection"
operator|)
argument_list|)
expr_stmt|;
name|inv_ret
operator|=
name|DspAsynBindRequest
argument_list|(
operator|&
operator|(
name|cn
operator|->
name|cn_addr
operator|)
argument_list|,
operator|&
operator|(
name|cn
operator|->
name|cn_connect
operator|.
name|cc_req
operator|)
argument_list|,
literal|0
argument_list|,
name|dc
argument_list|,
name|di
argument_list|,
name|ROS_ASYNC
argument_list|)
expr_stmt|;
break|break;
case|case
name|DS_CTX_QUIPU_DSP
case|:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"Making a QUIPU DSP connection"
operator|)
argument_list|)
expr_stmt|;
name|inv_ret
operator|=
name|QspAsynBindRequest
argument_list|(
operator|&
operator|(
name|cn
operator|->
name|cn_addr
operator|)
argument_list|,
operator|&
operator|(
name|cn
operator|->
name|cn_connect
operator|.
name|cc_req
operator|)
argument_list|,
literal|0
argument_list|,
name|dc
argument_list|,
name|di
argument_list|,
name|ROS_ASYNC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Unknown connection context"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|cn
operator|->
name|cn_last_used
operator|=
name|timenow
expr_stmt|;
switch|switch
condition|(
name|inv_ret
condition|)
block|{
case|case
name|NOTOK
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"ASYN BIND REQUEST NOTOK!"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
literal|"Failed (NOTOK)"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|cn
operator|->
name|cn_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dsa_reliable
argument_list|(
name|cn
argument_list|,
name|FALSE
argument_list|,
name|timenow
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
case|case
name|DONE
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"ASYN BIND REQUEST DONE! (ad = %d)"
operator|,
name|dc
operator|->
name|dc_sd
operator|)
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_ad
operator|=
name|dc
operator|->
name|dc_sd
expr_stmt|;
if|if
condition|(
name|cn
operator|->
name|cn_ad
operator|==
name|NOTOK
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
literal|"Failed (DONE)"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|cn
operator|->
name|cn_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cn
operator|->
name|cn_state
operator|=
name|CN_FAILED
expr_stmt|;
name|dsa_reliable
argument_list|(
name|cn
argument_list|,
name|FALSE
argument_list|,
name|timenow
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|conn_req_aux
argument_list|(
name|cn
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_STATS
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
literal|"Failed (DONE 2)"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|cn
operator|->
name|cn_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dsa_reliable
argument_list|(
name|cn
argument_list|,
name|FALSE
argument_list|,
name|timenow
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
case|case
name|CONNECTING_1
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"ASYN BIND REQUEST CONNECTING_1 (ad = %d)"
operator|,
name|dc
operator|->
name|dc_sd
operator|)
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_ad
operator|=
name|dc
operator|->
name|dc_sd
expr_stmt|;
name|cn
operator|->
name|cn_state
operator|=
name|CN_CONNECTING1
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
literal|"Trying (CONN_1)"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|cn
operator|->
name|cn_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|OK
operator|)
return|;
case|case
name|CONNECTING_2
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"ASYN BIND REQUEST CONNECTING_2 (ad = %d)"
operator|,
name|dc
operator|->
name|dc_sd
operator|)
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_ad
operator|=
name|dc
operator|->
name|dc_sd
expr_stmt|;
name|cn
operator|->
name|cn_state
operator|=
name|CN_CONNECTING2
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
literal|"Trying (CONN_2)"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|cn
operator|->
name|cn_dn
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|OK
operator|)
return|;
default|default:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Unknown return from DAsynBind : %d"
operator|,
name|inv_ret
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
comment|/* switch inv_ret */
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/* * conn_req_aux() is called to complete work started by conn_request(). * Current major complication is how to deal with an undecodable BindResult. * If OK is returned, the connection is ready for action and any waiting * operations should be sent. * If NOTOK is returned the connection needs to be extracted, alerting any * waiting operations in the process. */
end_comment

begin_expr_stmt
name|conn_req_aux
argument_list|(
name|cn
argument_list|)
specifier|register
expr|struct
name|connection
operator|*
name|cn
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|cn
operator|->
name|cn_connect
operator|.
name|cc_dc
operator|.
name|dc_result
condition|)
block|{
case|case
name|DS_RESULT
case|:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"D-BIND.RETRY(ASYNC) RESULT"
operator|)
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_state
operator|=
name|CN_OPEN
expr_stmt|;
break|break;
case|case
name|DS_ERROR
case|:
comment|/* 	    * Get the DirectoryBindError 	    */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"D-BIND.RETRY(ASYNC) ERROR"
operator|)
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_state
operator|=
name|CN_FAILED
expr_stmt|;
name|cn
operator|->
name|cn_ad
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|cn
operator|->
name|cn_state
operator|=
name|CN_FAILED
expr_stmt|;
name|cn
operator|->
name|cn_ad
operator|=
literal|0
expr_stmt|;
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Association rejected"
operator|)
argument_list|)
expr_stmt|;
comment|/* ADT 	    LLOG (log_dsap,LLOG_NOTICE,( "Association rejected: [%s]", 	      DErrString(??))); */
break|break;
block|}
comment|/* switch acc->acc_result */
if|if
condition|(
name|cn
operator|->
name|cn_state
operator|==
name|CN_OPEN
condition|)
block|{
name|struct
name|TSAPdisconnect
name|td_s
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|td_s
decl_stmt|;
if|if
condition|(
name|TSetQueuesOK
argument_list|(
name|cn
operator|->
name|cn_ad
argument_list|,
literal|1
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
name|td_log
argument_list|(
name|td
argument_list|,
literal|"TSetQueuesOK (outgoing)"
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_last_used
operator|=
name|timenow
expr_stmt|;
name|dsa_reliable
argument_list|(
name|cn
argument_list|,
name|TRUE
argument_list|,
name|cn
operator|->
name|cn_last_used
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
block|{
name|char
name|buf
index|[
name|LINESIZE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Bound using %s DSP context (%d)"
argument_list|,
name|cn
operator|->
name|cn_ctx
operator|==
name|DS_CTX_QUIPU_DSP
condition|?
literal|"QUIPU"
else|:
literal|"X500"
argument_list|,
name|cn
operator|->
name|cn_ad
argument_list|)
expr_stmt|;
name|pslog
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
name|buf
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|cn
operator|->
name|cn_dn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|OK
operator|)
return|;
block|}
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
end_block

end_unit

