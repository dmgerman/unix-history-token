begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* task_select.c - tidy connection mesh and select next DSA activity */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/task_select.c,v 7.5 91/03/09 11:57:09 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/quipu/RCS/task_select.c,v 7.5 91/03/09 11:57:09 mrose Exp $  *  *  * $Log:	task_select.c,v $  * Revision 7.5  91/03/09  11:57:09  mrose  * update  *   * Revision 7.4  91/02/22  09:40:02  mrose  * Interim 6.8  *   * Revision 7.3  90/10/17  11:54:56  mrose  * sync  *   * Revision 7.2  90/07/09  14:46:43  mrose  * sync  *   * Revision 7.1  89/12/19  16:20:51  mrose  * sync  *   * Revision 7.0  89/11/23  22:18:15  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/connection.h"
end_include

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|time_t
name|conn_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|time_t
name|nsap_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|time_t
name|slave_timeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|time_t
name|timenow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|lastedb_update
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|pending_ops
init|=
name|NULLOPER
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|task_act
modifier|*
name|task_select
parameter_list|(
name|secs_p
parameter_list|)
name|int
modifier|*
name|secs_p
decl_stmt|;
block|{
name|struct
name|connection
modifier|*
name|cn
decl_stmt|;
name|struct
name|connection
modifier|*
name|cn_tmp
decl_stmt|;
name|struct
name|connection
modifier|*
modifier|*
name|next_cn
decl_stmt|;
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
name|struct
name|task_act
modifier|*
modifier|*
name|next_tk
decl_stmt|;
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
name|int
name|timeout_tmp
decl_stmt|;
name|char
name|process_edbs
init|=
name|TRUE
decl_stmt|;
name|char
name|do_timeout
decl_stmt|;
name|int
name|suspended
init|=
name|FALSE
decl_stmt|;
name|struct
name|task_act
modifier|*
name|ret_tk
init|=
name|NULLTASK
decl_stmt|;
specifier|extern
name|char
name|startup_update
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secs_p
operator|)
operator|=
name|NOTOK
expr_stmt|;
name|conns_used
operator|=
literal|0
expr_stmt|;
comment|/*     DLOG(log_dsap, LLOG_DEBUG, ("task_select connections:"));     conn_list_log(connlist); */
for|for
control|(
name|cn
operator|=
name|connlist
init|;
name|cn
operator|!=
name|NULLCONN
condition|;
name|cn
operator|=
name|cn_tmp
control|)
block|{
name|cn_tmp
operator|=
name|cn
operator|->
name|cn_next
expr_stmt|;
comment|/* Nasty but necessary in conn_extract() 				   manages to get itself called somehow */
name|do_timeout
operator|=
name|FALSE
expr_stmt|;
name|conn_log
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|next_tk
operator|=
operator|&
operator|(
name|cn
operator|->
name|cn_tasklist
operator|)
expr_stmt|;
for|for
control|(
name|tk
operator|=
name|cn
operator|->
name|cn_tasklist
init|;
name|tk
operator|!=
name|NULLTASK
condition|;
name|tk
operator|=
operator|(
operator|*
name|next_tk
operator|)
control|)
block|{
if|if
condition|(
name|tk
operator|->
name|tk_timed
condition|)
block|{
if|if
condition|(
name|tk
operator|->
name|tk_timeout
operator|<=
name|timenow
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|struct
name|UTCtime
name|ut
decl_stmt|;
name|struct
name|UTCtime
name|ut2
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"task has timelimit of %ld"
operator|,
name|tk
operator|->
name|tk_timeout
operator|)
argument_list|)
expr_stmt|;
name|tm2ut
argument_list|(
name|gmtime
argument_list|(
operator|&
operator|(
name|tk
operator|->
name|tk_timeout
operator|)
argument_list|)
argument_list|,
operator|&
name|ut
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"converted timelimit = %s"
operator|,
name|utct2str
argument_list|(
operator|&
operator|(
name|ut
operator|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tm2ut
argument_list|(
name|gmtime
argument_list|(
operator|&
operator|(
name|timenow
operator|)
argument_list|)
argument_list|,
operator|&
name|ut2
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"time now = %s"
operator|,
name|utct2str
argument_list|(
operator|&
operator|(
name|ut2
operator|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
operator|*
name|next_tk
operator|)
operator|=
name|tk
operator|->
name|tk_next
expr_stmt|;
name|timeout_task
argument_list|(
name|tk
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|timeout_tmp
operator|=
operator|(
name|int
operator|)
name|tk
operator|->
name|tk_timeout
operator|-
name|timenow
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|secs_p
operator|)
operator|==
name|NOTOK
operator|)
operator|||
operator|(
operator|(
operator|*
name|secs_p
operator|)
operator|>
name|timeout_tmp
operator|)
condition|)
block|{
operator|(
operator|*
name|secs_p
operator|)
operator|=
name|timeout_tmp
expr_stmt|;
block|}
block|}
block|}
name|next_tk
operator|=
operator|&
operator|(
name|tk
operator|->
name|tk_next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cn
operator|->
name|cn_state
operator|==
name|CN_OPEN
condition|)
block|{
name|next_tk
operator|=
operator|&
operator|(
name|cn
operator|->
name|cn_tasklist
operator|)
expr_stmt|;
for|for
control|(
name|tk
operator|=
name|cn
operator|->
name|cn_tasklist
init|;
name|tk
operator|!=
name|NULLTASK
condition|;
name|tk
operator|=
operator|(
operator|*
name|next_tk
operator|)
control|)
block|{
name|next_tk
operator|=
operator|&
operator|(
name|tk
operator|->
name|tk_next
operator|)
expr_stmt|;
if|if
condition|(
name|tk
operator|->
name|tk_state
operator|==
name|TK_ACTIVE
condition|)
block|{
if|if
condition|(
operator|(
name|ret_tk
operator|==
name|NULLTASK
operator|)
operator|||
operator|(
name|tk
operator|->
name|tk_prio
operator|>
name|ret_tk
operator|->
name|tk_prio
operator|)
operator|||
operator|(
operator|(
name|tk
operator|->
name|tk_prio
operator|==
name|ret_tk
operator|->
name|tk_prio
operator|)
operator|&&
operator|(
operator|(
operator|!
name|ret_tk
operator|->
name|tk_timed
operator|)
operator|||
operator|(
operator|(
name|tk
operator|->
name|tk_timed
operator|)
operator|&&
operator|(
name|tk
operator|->
name|tk_timeout
operator|<
name|ret_tk
operator|->
name|tk_timeout
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|ret_tk
operator|=
name|tk
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tk
operator|->
name|tk_state
operator|==
name|TK_SUSPEND
condition|)
block|{
comment|/* 		    *  A task suspended to allow the network to be polled. 		    *  Set suspended to force polling. 		    */
name|tk
operator|->
name|tk_state
operator|=
name|TK_ACTIVE
expr_stmt|;
name|suspended
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cn
operator|->
name|cn_tasklist
operator|==
name|NULLTASK
condition|)
block|{
if|if
condition|(
name|cn
operator|->
name|cn_initiator
condition|)
block|{
if|if
condition|(
name|cn
operator|->
name|cn_operlist
operator|==
name|NULLOPER
condition|)
block|{
if|if
condition|(
operator|(
name|cn
operator|->
name|cn_last_used
operator|+
name|conn_timeout
operator|)
operator|<=
name|timenow
condition|)
block|{
name|do_timeout
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|timeout_tmp
operator|=
call|(
name|int
call|)
argument_list|(
name|cn
operator|->
name|cn_last_used
operator|+
name|conn_timeout
argument_list|)
operator|-
name|timenow
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|secs_p
operator|)
operator|==
name|NOTOK
operator|)
operator|||
operator|(
operator|(
operator|*
name|secs_p
operator|)
operator|>
name|timeout_tmp
operator|)
condition|)
block|{
operator|(
operator|*
name|secs_p
operator|)
operator|=
name|timeout_tmp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|timeout_tmp
operator|=
name|conn_timeout
expr_stmt|;
comment|/* safety catch */
if|if
condition|(
operator|(
name|tk
operator|=
name|cn
operator|->
name|cn_operlist
operator|->
name|on_task
operator|)
operator|!=
name|NULLTASK
condition|)
block|{
if|if
condition|(
name|tk
operator|->
name|tk_timed
condition|)
block|{
name|timeout_tmp
operator|=
operator|(
name|int
operator|)
name|tk
operator|->
name|tk_timeout
operator|-
name|timenow
expr_stmt|;
if|if
condition|(
name|timeout_tmp
operator|<
literal|0
condition|)
name|timeout_tmp
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
operator|*
name|secs_p
operator|)
operator|==
name|NOTOK
operator|)
operator|||
operator|(
operator|(
operator|*
name|secs_p
operator|)
operator|>
name|timeout_tmp
operator|)
condition|)
block|{
operator|(
operator|*
name|secs_p
operator|)
operator|=
name|timeout_tmp
expr_stmt|;
block|}
name|cn
operator|->
name|cn_last_used
operator|=
name|timenow
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|cn
operator|->
name|cn_last_used
operator|=
name|timenow
expr_stmt|;
name|process_edbs
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cn
operator|->
name|cn_last_used
operator|+
name|nsap_timeout
operator|)
operator|<=
name|timenow
condition|)
block|{
if|if
condition|(
operator|(
name|cn
operator|->
name|cn_state
operator|==
name|CN_CONNECTING1
operator|)
operator|||
operator|(
name|cn
operator|->
name|cn_state
operator|==
name|CN_CONNECTING2
operator|)
condition|)
name|conn_retry
argument_list|(
name|cn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cn
operator|->
name|cn_state
operator|==
name|CN_CLOSING
condition|)
block|{
if|if
condition|(
name|conn_release_retry
argument_list|(
name|cn
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
comment|/* had its chance - abort */
name|do_ds_unbind
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|conn_rel_abort
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|conn_extract
argument_list|(
name|cn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cn
operator|->
name|cn_state
operator|==
name|CN_OPENING
condition|)
block|{
comment|/* something started to associate - then gave up !!! */
name|conn_rel_abort
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|conn_extract
argument_list|(
name|cn
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|secs_p
operator|)
operator|=
name|nsap_timeout
expr_stmt|;
block|}
else|else
block|{
name|timeout_tmp
operator|=
call|(
name|int
call|)
argument_list|(
name|cn
operator|->
name|cn_last_used
operator|+
name|nsap_timeout
argument_list|)
operator|-
name|timenow
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|secs_p
operator|)
operator|==
name|NOTOK
operator|)
operator|||
operator|(
operator|(
operator|*
name|secs_p
operator|)
operator|>
name|timeout_tmp
operator|)
condition|)
block|{
operator|(
operator|*
name|secs_p
operator|)
operator|=
name|timeout_tmp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|do_timeout
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Timing out connection %d"
operator|,
name|cn
operator|->
name|cn_ad
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn_release
argument_list|(
name|cn
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
operator|*
name|secs_p
operator|)
operator|=
name|nsap_timeout
expr_stmt|;
name|conns_used
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|conns_used
operator|++
expr_stmt|;
block|}
block|}
comment|/* *  Open the connection with the highest priority operation *  waiting on it... * *  Get DSA Info operations are highest priority, followed by *  BIND_COMPARE, and X500, and finally GetEDB operations. */
name|next_cn
operator|=
operator|&
operator|(
name|connwaitlist
operator|)
expr_stmt|;
for|for
control|(
name|cn
operator|=
name|connwaitlist
init|;
name|cn
operator|!=
name|NULLCONN
condition|;
name|cn
operator|=
operator|(
operator|*
name|next_cn
operator|)
control|)
block|{
if|if
condition|(
name|conns_used
operator|>=
name|MAX_CONNS
condition|)
break|break;
for|for
control|(
name|on
operator|=
name|cn
operator|->
name|cn_operlist
init|;
name|on
operator|!=
name|NULLOPER
condition|;
name|on
operator|=
name|on
operator|->
name|on_next_conn
control|)
block|{
if|if
condition|(
name|on
operator|->
name|on_type
operator|==
name|ON_TYPE_GET_DSA_INFO
condition|)
block|{
operator|(
operator|*
name|next_cn
operator|)
operator|=
name|cn
operator|->
name|cn_next
expr_stmt|;
if|if
condition|(
name|conn_request
argument_list|(
name|cn
argument_list|)
operator|==
name|OK
condition|)
block|{
name|conns_used
operator|++
expr_stmt|;
name|cn
operator|->
name|cn_next
operator|=
name|connlist
expr_stmt|;
name|connlist
operator|=
name|cn
expr_stmt|;
name|cn
operator|->
name|cn_last_used
operator|=
name|timenow
expr_stmt|;
comment|/* Do something with the operations */
block|}
else|else
block|{
comment|/* Do something with the operations */
block|}
break|break;
block|}
block|}
if|if
condition|(
name|on
operator|==
name|NULLOPER
condition|)
name|next_cn
operator|=
operator|&
operator|(
name|cn
operator|->
name|cn_next
operator|)
expr_stmt|;
block|}
name|next_cn
operator|=
operator|&
operator|(
name|connwaitlist
operator|)
expr_stmt|;
for|for
control|(
name|cn
operator|=
name|connwaitlist
init|;
name|cn
operator|!=
name|NULLCONN
condition|;
name|cn
operator|=
operator|(
operator|*
name|next_cn
operator|)
control|)
block|{
if|if
condition|(
name|conns_used
operator|>=
operator|(
name|MAX_CONNS
operator|-
name|CONNS_RESERVED_DI
operator|)
condition|)
break|break;
for|for
control|(
name|on
operator|=
name|cn
operator|->
name|cn_operlist
init|;
name|on
operator|!=
name|NULLOPER
condition|;
name|on
operator|=
name|on
operator|->
name|on_next_conn
control|)
block|{
if|if
condition|(
name|on
operator|->
name|on_type
operator|!=
name|ON_TYPE_GET_EDB
condition|)
block|{
operator|(
operator|*
name|next_cn
operator|)
operator|=
name|cn
operator|->
name|cn_next
expr_stmt|;
if|if
condition|(
name|conn_request
argument_list|(
name|cn
argument_list|)
operator|==
name|OK
condition|)
block|{
name|conns_used
operator|++
expr_stmt|;
name|cn
operator|->
name|cn_next
operator|=
name|connlist
expr_stmt|;
name|connlist
operator|=
name|cn
expr_stmt|;
name|cn
operator|->
name|cn_last_used
operator|=
name|timenow
expr_stmt|;
comment|/* Do something with the operations */
block|}
else|else
block|{
comment|/* Do something with the operations */
block|}
break|break;
block|}
block|}
if|if
condition|(
name|on
operator|==
name|NULLOPER
condition|)
name|next_cn
operator|=
operator|&
operator|(
name|cn
operator|->
name|cn_next
operator|)
expr_stmt|;
block|}
name|next_cn
operator|=
operator|&
operator|(
name|connwaitlist
operator|)
expr_stmt|;
for|for
control|(
name|cn
operator|=
name|connwaitlist
init|;
name|cn
operator|!=
name|NULLCONN
condition|;
name|cn
operator|=
operator|(
operator|*
name|next_cn
operator|)
control|)
block|{
if|if
condition|(
name|conns_used
operator|>=
operator|(
name|MAX_CONNS
operator|-
name|CONNS_RESERVED_DI
operator|-
name|CONNS_RESERVED_X500
operator|)
condition|)
break|break;
operator|(
operator|*
name|next_cn
operator|)
operator|=
name|cn
operator|->
name|cn_next
expr_stmt|;
if|if
condition|(
name|conn_request
argument_list|(
name|cn
argument_list|)
operator|==
name|OK
condition|)
block|{
name|conns_used
operator|++
expr_stmt|;
name|cn
operator|->
name|cn_next
operator|=
name|connlist
expr_stmt|;
name|connlist
operator|=
name|cn
expr_stmt|;
name|cn
operator|->
name|cn_last_used
operator|=
name|timenow
expr_stmt|;
comment|/* Do something with the operations */
block|}
else|else
block|{
comment|/* Do something with the operations */
block|}
block|}
if|if
condition|(
name|process_edbs
condition|)
block|{
comment|/* 	*  Nothing is happening that would be disturbed by writing back 	*  a retrieved EDB so it is a good time to process them. 	*/
if|if
condition|(
operator|!
name|get_edb_ops
operator|&&
name|pending_ops
condition|)
block|{
name|get_edb_ops
operator|=
name|pending_ops
expr_stmt|;
name|pending_ops
operator|=
name|NULLOPER
expr_stmt|;
if|if
condition|(
name|oper_chain
argument_list|(
name|get_edb_ops
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Could not chain a pending operation"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secs_p
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* service network and then try next one */
name|pending_ops
operator|=
name|get_edb_ops
operator|->
name|on_next_task
expr_stmt|;
name|get_edb_ops
operator|->
name|on_next_task
operator|=
name|NULLOPER
expr_stmt|;
name|oper_free
argument_list|(
name|get_edb_ops
argument_list|)
expr_stmt|;
name|get_edb_ops
operator|=
name|NULLOPER
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|get_edb_ops
condition|)
block|{
if|if
condition|(
name|get_edb_ops
operator|->
name|on_state
operator|==
name|ON_COMPLETE
condition|)
block|{
if|if
condition|(
name|get_edb_ops
operator|->
name|on_type
operator|==
name|ON_TYPE_GET_EDB
condition|)
name|process_edb
argument_list|(
name|get_edb_ops
argument_list|)
expr_stmt|;
else|else
comment|/* ON_TYPE_SHADOW */
name|process_shadow
argument_list|(
name|get_edb_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_edb_ops
condition|)
block|{
name|pending_ops
operator|=
name|get_edb_ops
operator|->
name|on_next_task
expr_stmt|;
name|get_edb_ops
operator|->
name|on_next_task
operator|=
name|NULLOPER
expr_stmt|;
name|oper_conn_extract
argument_list|(
name|get_edb_ops
argument_list|)
expr_stmt|;
name|oper_free
argument_list|(
name|get_edb_ops
argument_list|)
expr_stmt|;
name|get_edb_ops
operator|=
name|NULLOPER
expr_stmt|;
block|}
operator|(
operator|*
name|secs_p
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* Schedule next one ! */
block|}
elseif|else
if|if
condition|(
name|get_edb_ops
operator|->
name|on_state
operator|==
name|ON_ABANDONED
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"Get edb has been abandoned"
operator|)
argument_list|)
expr_stmt|;
name|pending_ops
operator|=
name|get_edb_ops
operator|->
name|on_next_task
expr_stmt|;
name|get_edb_ops
operator|->
name|on_next_task
operator|=
name|NULLOPER
expr_stmt|;
name|oper_free
argument_list|(
name|get_edb_ops
argument_list|)
expr_stmt|;
name|get_edb_ops
operator|=
name|NULLOPER
expr_stmt|;
operator|(
operator|*
name|secs_p
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* Schedule next one ! */
block|}
block|}
elseif|else
if|if
condition|(
name|startup_update
condition|)
block|{
comment|/* see if cache timer has expired - if so resend edb ops... */
if|if
condition|(
operator|(
name|timenow
operator|-
name|lastedb_update
operator|)
operator|>=
name|slave_timeout
condition|)
name|slave_update
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|get_edb_ops
operator|==
name|NULLOPER
operator|)
operator|&&
name|startup_update
condition|)
block|{
comment|/* make sure we are awake for the next EDB update */
if|if
condition|(
operator|(
name|timeout_tmp
operator|=
name|lastedb_update
operator|+
name|slave_timeout
operator|-
name|timenow
operator|)
operator|>=
literal|0
condition|)
if|if
condition|(
operator|(
operator|(
operator|*
name|secs_p
operator|)
operator|==
name|NOTOK
operator|)
operator|||
operator|(
operator|(
operator|*
name|secs_p
operator|)
operator|>
name|timeout_tmp
operator|)
condition|)
operator|(
operator|*
name|secs_p
operator|)
operator|=
name|timeout_tmp
expr_stmt|;
block|}
if|if
condition|(
name|suspended
condition|)
block|{
comment|/* 	*  A task suspended in order for the network to be checked. 	*  Force this to happen by setting the selected task to NULL 	*  and the polling time of the network to 0 secs. 	*/
name|ret_tk
operator|=
name|NULLTASK
expr_stmt|;
operator|(
operator|*
name|secs_p
operator|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ret_tk
operator|)
return|;
block|}
end_function

begin_macro
name|timeout_task
argument_list|(
argument|tk
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|task_act
modifier|*
name|tk
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
init|=
operator|&
operator|(
name|tk
operator|->
name|tk_resp
operator|.
name|di_error
operator|.
name|de_err
operator|)
decl_stmt|;
name|struct
name|ds_search_task
modifier|*
name|tmp
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"timeout_task"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|on
operator|=
name|tk
operator|->
name|tk_operlist
init|;
name|on
operator|!=
name|NULLOPER
condition|;
name|on
operator|=
name|on
operator|->
name|on_next_task
control|)
block|{
comment|/* Time out operations started by task */
name|on
operator|->
name|on_state
operator|=
name|ON_ABANDONED
expr_stmt|;
name|on
operator|->
name|on_task
operator|=
name|NULLTASK
expr_stmt|;
block|}
if|if
condition|(
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|.
name|dca_dsarg
operator|.
name|arg_type
operator|!=
name|OP_SEARCH
condition|)
block|{
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
if|if
condition|(
name|tk
operator|->
name|tk_timed
operator|==
name|TRUE
condition|)
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_TIMELIMITEXCEEDED
expr_stmt|;
else|else
comment|/* tk->tk_timed == 2 */
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_ADMINLIMITEXCEEDED
expr_stmt|;
name|task_error
argument_list|(
name|tk
argument_list|)
expr_stmt|;
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Do search collation */
if|if
condition|(
operator|(
name|tk
operator|->
name|tk_state
operator|==
name|TK_ACTIVE
operator|)
operator|&&
operator|(
name|tk
operator|->
name|local_st
operator|==
name|NULL_ST
operator|)
condition|)
block|{
comment|/* nothing happened yet... */
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
if|if
condition|(
name|tk
operator|->
name|tk_timed
operator|==
name|TRUE
condition|)
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_TIMELIMITEXCEEDED
expr_stmt|;
else|else
comment|/* tk->tk_timed == 2 */
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_ADMINLIMITEXCEEDED
expr_stmt|;
name|task_error
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* send the results we have got... */
name|tk
operator|->
name|tk_result
operator|=
operator|&
operator|(
name|tk
operator|->
name|tk_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|)
expr_stmt|;
name|tk
operator|->
name|tk_result
operator|->
name|dcr_dsres
operator|.
name|result_type
operator|=
name|tk
operator|->
name|tk_dx
operator|.
name|dx_arg
operator|.
name|dca_dsarg
operator|.
name|arg_type
expr_stmt|;
name|tk
operator|->
name|tk_resp
operator|.
name|di_type
operator|=
name|DI_RESULT
expr_stmt|;
if|if
condition|(
name|tk
operator|->
name|tk_timed
operator|==
name|TRUE
condition|)
name|tk
operator|->
name|tk_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_sr
operator|.
name|CSR_limitproblem
operator|=
name|LSR_TIMELIMITEXCEEDED
expr_stmt|;
else|else
comment|/* tk->tk_timed == 2 */
name|tk
operator|->
name|tk_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_sr
operator|.
name|CSR_limitproblem
operator|=
name|LSR_ADMINSIZEEXCEEDED
expr_stmt|;
comment|/* Go through sub-tasks and add a POQ for each */
for|for
control|(
name|tmp
operator|=
name|tk
operator|->
name|referred_st
init|;
name|tmp
operator|!=
name|NULL_ST
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|st_next
control|)
name|add_cref2poq
argument_list|(
operator|&
name|tk
operator|->
name|tk_result
operator|->
name|dcr_dsres
operator|.
name|res_sr
argument_list|,
name|tmp
operator|->
name|st_cr
argument_list|)
expr_stmt|;
name|task_result
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
name|task_extract
argument_list|(
name|tk
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|schedule_operation
argument_list|(
name|x
argument_list|)
specifier|register
expr|struct
name|oper_act
operator|*
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
if|if
condition|(
name|on
operator|=
name|pending_ops
condition|)
comment|/* assign */
block|{
for|for
control|(
init|;
name|on
operator|->
name|on_next_task
operator|!=
name|NULLOPER
condition|;
name|on
operator|=
name|on
operator|->
name|on_next_task
control|)
empty_stmt|;
name|on
operator|->
name|on_next_task
operator|=
name|x
expr_stmt|;
block|}
else|else
name|pending_ops
operator|=
name|x
expr_stmt|;
block|}
end_block

end_unit

