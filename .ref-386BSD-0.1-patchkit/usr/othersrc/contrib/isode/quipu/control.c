begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* control.c - */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/control.c,v 7.3 91/02/22 09:38:36 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/quipu/RCS/control.c,v 7.3 91/02/22 09:38:36 mrose Interim $  *  *  * $Log:	control.c,v $  * Revision 7.3  91/02/22  09:38:36  mrose  * Interim 6.8  *   * Revision 7.2  90/07/09  14:45:31  mrose  * sync  *   * Revision 7.1  90/03/15  11:18:45  mrose  * quipu-sync  *   * Revision 7.0  89/11/23  22:16:58  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* the routine dsa_control is called when the modifyentry operation    is performed, with and 'add attribute' request and the attribute type    is 'control'.  The value decides what to control    This is strictly non standard, but gives the dua control of the dsa. */
end_comment

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/entry.h"
end_include

begin_include
include|#
directive|include
file|"quipu/dsp.h"
end_include

begin_include
include|#
directive|include
file|"quipu/ds_error.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_STATS
end_ifndef

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_stat
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|dsa_control
argument_list|(
argument|as
argument_list|,
argument|error
argument_list|,
argument|dn
argument_list|)
end_macro

begin_decl_stmt
name|Attr_Sequence
name|as
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|DSError
modifier|*
name|error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DN
name|dn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|DN
name|dn2
decl_stmt|;
name|Entry
name|theentry
decl_stmt|;
specifier|extern
name|Entry
name|database_root
decl_stmt|;
name|SFD
name|attempt_restart
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|manager
argument_list|(
name|dn
argument_list|)
condition|)
block|{
name|error
operator|->
name|dse_type
operator|=
name|DSE_SECURITYERROR
expr_stmt|;
name|error
operator|->
name|ERR_SECURITY
operator|.
name|DSE_sc_problem
operator|=
name|DSE_SC_ACCESSRIGHTS
expr_stmt|;
return|return
operator|(
name|DS_ERROR_REMOTE
operator|)
return|;
block|}
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|as
operator|->
name|attr_value
operator|->
name|avseq_av
operator|.
name|av_struct
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STATS
name|LLOG
argument_list|(
name|log_stat
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"DSA control: %s"
operator|,
name|str
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* -dump<directory> */
name|str
operator|=
name|SkipSpace
argument_list|(
operator|++
name|str
argument_list|)
expr_stmt|;
comment|/*  		directory_dump (str, database_root); */
return|return
operator|(
name|DS_OK
operator|)
return|;
case|case
literal|'t'
case|:
comment|/* -tailor<string> */
name|str
operator|=
name|SkipSpace
argument_list|(
operator|++
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsa_tai_string
argument_list|(
name|str
argument_list|)
operator|==
name|OK
condition|)
block|{
name|isodexport
argument_list|(
name|NULLCP
argument_list|)
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'a'
case|:
comment|/* -abort */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"*** abort signal ***"
operator|)
argument_list|)
expr_stmt|;
name|stop_listeners
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'b'
case|:
comment|/* -restart */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_FATAL
argument_list|,
operator|(
literal|"*** restart signal ***"
operator|)
argument_list|)
expr_stmt|;
name|attempt_restart
argument_list|(
name|NOTOK
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* should not be reached */
case|case
literal|'r'
case|:
comment|/* -refresh<entry> */
name|str
operator|=
name|SkipSpace
argument_list|(
operator|++
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
name|str
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|dn2
operator|=
name|NULLDN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dn2
operator|=
name|str2dn
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
break|break;
if|if
condition|(
name|refresh_from_disk
argument_list|(
name|dn2
argument_list|)
operator|==
name|OK
condition|)
return|return
operator|(
name|DS_OK
operator|)
return|;
break|break;
case|case
literal|'f'
case|:
comment|/* -resync<entry> */
name|str
operator|=
name|SkipSpace
argument_list|(
operator|++
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
name|str
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|dn2
operator|=
name|NULLDN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dn2
operator|=
name|str2dn
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
break|break;
if|if
condition|(
operator|(
name|theentry
operator|=
name|local_find_entry
argument_list|(
name|dn2
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULLENTRY
condition|)
ifdef|#
directive|ifdef
name|TURBO_DISK
ifdef|#
directive|ifdef
name|TURBO_AVL
block|{
name|Entry
name|akid
init|=
operator|(
name|Entry
operator|)
name|avl_getone
argument_list|(
name|theentry
operator|->
name|e_children
argument_list|)
decl_stmt|;
if|if
condition|(
name|turbo_writeall
argument_list|(
name|akid
argument_list|)
operator|==
name|OK
condition|)
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
name|turbo_writeall
argument_list|(
name|theentry
operator|->
name|e_child
argument_list|)
operator|==
name|OK
condition|)
return|return
operator|(
name|DS_OK
operator|)
return|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|TURBO_AVL
block|{
name|Entry
name|akid
init|=
operator|(
name|Entry
operator|)
name|avl_getone
argument_list|(
name|theentry
operator|->
name|e_children
argument_list|)
decl_stmt|;
if|if
condition|(
name|journal
argument_list|(
name|akid
argument_list|)
operator|==
name|OK
condition|)
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
name|journal
argument_list|(
name|theentry
operator|->
name|e_child
argument_list|)
operator|==
name|OK
condition|)
return|return
operator|(
name|DS_OK
operator|)
return|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
case|case
literal|'l'
case|:
comment|/* -lock<entry> */
name|str
operator|=
name|SkipSpace
argument_list|(
operator|++
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
name|str
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|dn2
operator|=
name|NULLDN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dn2
operator|=
name|str2dn
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
break|break;
if|if
condition|(
operator|(
name|theentry
operator|=
name|local_find_entry
argument_list|(
name|dn2
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULLENTRY
condition|)
block|{
name|theentry
operator|->
name|e_lock
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'u'
case|:
comment|/* -unlock<entry> */
name|str
operator|=
name|SkipSpace
argument_list|(
operator|++
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
name|str
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|dn2
operator|=
name|NULLDN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dn2
operator|=
name|str2dn
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
break|break;
if|if
condition|(
operator|(
name|theentry
operator|=
name|local_find_entry
argument_list|(
name|dn2
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULLENTRY
condition|)
block|{
name|theentry
operator|->
name|e_lock
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|DS_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* -slave */
comment|/* 		 * When we go async return of OK will mean that a getedb 		 * operation has been scheduled, NOT that it has succeeded. 		 */
name|str
operator|=
name|SkipSpace
argument_list|(
operator|++
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
name|NULL
condition|)
block|{
name|slave_update
argument_list|()
expr_stmt|;
return|return
name|DS_OK
return|;
block|}
if|if
condition|(
name|lexequ
argument_list|(
name|str
argument_list|,
literal|"shadow"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|shadow_update
argument_list|()
expr_stmt|;
return|return
name|DS_OK
return|;
block|}
if|if
condition|(
name|lexequ
argument_list|(
name|str
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|dn2
operator|=
name|NULLDN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dn2
operator|=
name|str2dn
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
break|break;
if|if
condition|(
name|update_aux
argument_list|(
name|dn2
argument_list|,
name|dn2
operator|==
name|NULLDN
argument_list|)
operator|==
name|OK
condition|)
return|return
name|DS_OK
return|;
break|break;
default|default:
break|break;
block|}
name|error
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|error
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_UNWILLINGTOPERFORM
expr_stmt|;
return|return
operator|(
name|DS_ERROR_REMOTE
operator|)
return|;
block|}
end_block

end_unit

