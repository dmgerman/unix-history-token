begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftamsystem.c - FTAM responder routines */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/ftam2/RCS/ftamsystem.c,v 7.7 91/02/22 09:24:08 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/ftam2/RCS/ftamsystem.c,v 7.7 91/02/22 09:24:08 mrose Interim $  *  *  * $Log:	ftamsystem.c,v $  * Revision 7.7  91/02/22  09:24:08  mrose  * Interim 6.8  *   * Revision 7.6  91/01/14  13:32:45  mrose  * kerberos  *   * Revision 7.5  91/01/13  12:27:07  mrose  * NBS  *   * Revision 7.4  90/11/21  11:30:52  mrose  * sun  *   * Revision 7.3  90/11/05  13:29:57  mrose  * nist  *   * Revision 7.2  90/07/01  21:03:35  mrose  * pepsy  *   * Revision 7.1  90/01/16  22:37:20  mrose  * very last time  *   * Revision 7.0  89/11/23  21:54:40  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NULL_INITIATOR
argument_list|)
end_if

begin_define
define|#
directive|define
name|NULL_INITIATOR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"ftamsystem.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NULL_INITIATOR
end_ifdef

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"logger.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_function_decl
name|struct
name|group
modifier|*
name|getgrnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ANON
end_ifndef

begin_define
define|#
directive|define
name|ANON
value|"ftp"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|UNIX DATA */
end_comment

begin_decl_stmt
name|int
name|myuid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|myhomelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|myhome
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dev_t
name|null_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|null_ino
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wtmp
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|clok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|utmp
name|uts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|lseek
argument_list|()
decl_stmt|,
name|time
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|VFS DATA */
end_comment

begin_decl_stmt
name|struct
name|vfsmap
name|vfs
index|[]
init|=
block|{
comment|/* VFS_UBF */
literal|"FTAM-3"
block|,
name|NULLOID
block|,
name|NULLCP
block|,
name|VF_WARN
block|,
literal|0
block|,
name|S_IFREG
block|,
name|binarypeek
block|,
literal|'b'
block|,
name|VFS_XXX
block|,
name|FA_ACC_UA
block|,
operator|-
literal|1
block|,
name|binarycheck
block|,
name|_ZFTAM_3_ParametersDOCS
block|,
literal|"unstructured binary file"
block|,
comment|/* VFS_UTF */
literal|"FTAM-1"
block|,
name|NULLOID
block|,
name|NULLCP
block|,
name|VF_WARN
block|,
literal|0
block|,
name|S_IFREG
block|,
name|textpeek
block|,
literal|'t'
block|,
name|VFS_UBF
block|,
name|FA_ACC_UA
block|,
operator|-
literal|1
block|,
name|textcheck
block|,
name|_ZFTAM_1_ParametersDOCS
block|,
literal|"unstructured text file"
block|,
comment|/* VFS_FDF */
literal|"NBS-9"
block|,
name|NULLOID
block|,
name|NULLCP
block|,
name|VF_NULL
block|,
literal|0
block|,
name|S_IFDIR
block|,
name|fdfpeek
block|,
literal|'d'
block|,
name|VFS_XXX
block|,
name|FA_ACC_UA
block|,
literal|1
block|,
name|NULLIFP
block|,
name|_ZNBS_9_ParametersDOCS
block|,
literal|"file directory file"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_decl_stmt
name|int
name|vfs_fdf
init|=
name|VFS_FDF
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|REGIME DATA */
end_comment

begin_decl_stmt
name|int
name|fqos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|units
init|=
name|FUNIT_READ
operator||
name|FUNIT_WRITE
operator||
name|FUNIT_LIMITED
operator||
name|FUNIT_ENHANCED
operator||
name|FUNIT_GROUPING
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|attrs
init|=
name|FATTR_STORAGE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fadusize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|ACTIVITY DATA */
end_comment

begin_decl_stmt
name|int
name|myfd
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle to file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|myfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
name|myst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|statok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vfsmap
modifier|*
name|myvf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* active contents type */
end_comment

begin_decl_stmt
name|caddr_t
name|myparam
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   .. */
end_comment

begin_decl_stmt
name|int
name|myaccess
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current access request */
end_comment

begin_decl_stmt
name|char
modifier|*
name|initiator
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current initiator identity */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NULL_INITIATOR
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|null_initiator
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   none given, do EurOSInet style */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|FADUidentity
name|mylocation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current location */
end_comment

begin_decl_stmt
name|int
name|mymode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current processing mode */
end_comment

begin_decl_stmt
name|int
name|myoperation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   .. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_decl_stmt
name|AEI
name|mycalling
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current calling AET */
end_comment

begin_decl_stmt
name|AEI
name|myresponding
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current responding AET */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|account
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current account */
end_comment

begin_decl_stmt
name|int
name|mygid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "inner" account */
end_comment

begin_decl_stmt
name|int
name|mylock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current concurrency control */
end_comment

begin_decl_stmt
name|struct
name|FTAMconcurrency
name|myconctl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   .. */
end_comment

begin_decl_stmt
name|int
name|mylockstyle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current locking style */
end_comment

begin_decl_stmt
name|int
name|mycontext
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current access context */
end_comment

begin_decl_stmt
name|int
name|mylevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   .. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RemoteHost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|password
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ftp_default
init|=
name|VFS_UBF
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|REGIME */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_define
define|#
directive|define
name|seterr
parameter_list|(
name|id
parameter_list|,
name|ob
parameter_list|,
name|so
parameter_list|,
name|des
parameter_list|)
define|\
value|{ \     dp -> ftd_identifier = (id); \     dp -> ftd_observer = (ob), dp -> ftd_source = (so); \     (void) strncpy (dp -> ftd_data, des, FTD_SIZE);\     dp -> ftd_cc = strlen(dp -> ftd_data);\     goto bad2; \ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|seterr
parameter_list|(
name|id
parameter_list|,
name|ob
parameter_list|,
name|so
parameter_list|,
name|des
parameter_list|)
define|\
value|{ \     dp -> ftd_identifier = (id); \     dp -> ftd_observer = (ob), dp -> ftd_source = (so); \     goto bad2; \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ftam_start
parameter_list|(
name|fts
parameter_list|)
specifier|register
name|struct
name|FTAMstart
modifier|*
name|fts
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
name|int
name|guest
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|struct
name|isodocument
modifier|*
name|id
decl_stmt|;
specifier|register
name|struct
name|vfsmap
modifier|*
name|vf
decl_stmt|;
specifier|register
name|struct
name|FTAMcontent
modifier|*
name|fx
decl_stmt|;
name|struct
name|FTAMdiagnostic
name|diags
index|[
name|NFDIAG
index|]
decl_stmt|;
specifier|register
name|struct
name|FTAMdiagnostic
modifier|*
name|dp
init|=
name|diags
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|clok
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"/dev/null"
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|)
name|null_dev
operator|=
name|st
operator|.
name|st_dev
operator|,
name|null_ino
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
else|else
name|null_dev
operator|=
operator|(
name|dev_t
operator|)
literal|0
operator|,
name|null_ino
operator|=
operator|(
name|ino_t
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|vf
operator|=
name|vfs
init|;
name|vf
operator|->
name|vf_entry
condition|;
name|vf
operator|++
control|)
if|if
condition|(
name|id
operator|=
name|getisodocumentbyentry
argument_list|(
name|vf
operator|->
name|vf_entry
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|vf
operator|->
name|vf_oid
operator|=
name|oid_cpy
argument_list|(
name|id
operator|->
name|id_type
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: out of memory"
argument_list|,
name|vf
operator|->
name|vf_entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vf
operator|->
name|vf_flags
operator|&
name|VF_WARN
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"%s: unknown"
argument_list|,
name|vf
operator|->
name|vf_entry
argument_list|)
expr_stmt|;
name|ftamfd
operator|=
name|fts
operator|->
name|fts_sd
expr_stmt|;
if|if
condition|(
operator|(
name|class
operator|=
name|fts
operator|->
name|fts_class
operator|)
operator|&
name|FCLASS_TM
condition|)
name|class
operator|=
name|FCLASS_TM
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|&
name|FCLASS_TRANSFER
condition|)
name|class
operator|=
name|FCLASS_TRANSFER
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|&
name|FCLASS_MANAGE
condition|)
name|class
operator|=
name|FCLASS_MANAGE
expr_stmt|;
else|else
name|seterr
argument_list|(
name|FS_ACS_CLASS
argument_list|,
name|EREF_RFSU
argument_list|,
name|EREF_IFSU
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|units
operator|&=
name|fts
operator|->
name|fts_units
expr_stmt|;
name|attrs
operator|&=
name|fts
operator|->
name|fts_attrs
expr_stmt|;
if|if
condition|(
operator|(
name|fqos
operator|=
name|fts
operator|->
name|fts_fqos
operator|)
operator|!=
name|FQOS_NORECOVERY
condition|)
name|seterr
argument_list|(
name|FS_ACS_ROLLBACK
argument_list|,
name|EREF_RFPM
argument_list|,
name|EREF_IFSU
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fadusize
operator|=
name|fts
operator|->
name|fts_ssdusize
operator|)
operator|<
literal|0
condition|)
name|fadusize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fx
operator|=
name|fts
operator|->
name|fts_contents
operator|.
name|fc_contents
operator|,
name|i
operator|=
name|fts
operator|->
name|fts_contents
operator|.
name|fc_ncontent
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|fx
operator|++
operator|,
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fx
operator|->
name|fc_result
operator|!=
name|PC_ACCEPT
condition|)
continue|continue;
for|for
control|(
name|vf
operator|=
name|vfs
init|;
name|vf
operator|->
name|vf_entry
condition|;
name|vf
operator|++
control|)
if|if
condition|(
name|vf
operator|->
name|vf_oid
operator|&&
name|oid_cmp
argument_list|(
name|vf
operator|->
name|vf_oid
argument_list|,
name|fx
operator|->
name|fc_dtn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vf
operator|->
name|vf_flags
operator||=
name|VF_OK
expr_stmt|;
name|vf
operator|->
name|vf_id
operator|=
name|fx
operator|->
name|fc_id
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|vf
operator|->
name|vf_entry
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"%s: unknown document-type"
argument_list|,
name|oid2ode
argument_list|(
name|fx
operator|->
name|fc_dtn
argument_list|)
argument_list|)
expr_stmt|;
name|fx
operator|->
name|fc_result
operator|=
name|PC_REJECTED
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|initiator
operator|=
name|fts
operator|->
name|fts_initiator
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|NULL_INITIATOR
name|initiator
operator|=
name|ANON
expr_stmt|;
name|null_initiator
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|seterr
argument_list|(
name|FS_ACS_IDENTITY
argument_list|,
name|EREF_RFSU
argument_list|,
name|EREF_IFSU
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fts
operator|->
name|fts_initiator
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
comment|/* scan initiator for remote host */
if|if
condition|(
operator|(
name|RemoteHost
operator|=
name|rindex
argument_list|(
name|initiator
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"missing remote host name in \"%s\""
argument_list|,
name|initiator
argument_list|)
expr_stmt|;
name|seterr
argument_list|(
name|FS_ACS_IDENTITY
argument_list|,
name|EREF_RFSU
argument_list|,
name|EREF_IFSU
argument_list|,
literal|"missing remote hostname"
argument_list|)
expr_stmt|;
block|}
operator|*
name|RemoteHost
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|initiator
argument_list|,
literal|"ANON"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|initiator
argument_list|,
name|ANON
argument_list|)
operator|==
literal|0
condition|)
block|{
name|initiator
operator|=
literal|"ANONYMOUS"
expr_stmt|;
comment|/* FTP guest name */
block|}
name|password
operator|=
operator|(
name|fts
operator|->
name|fts_password
operator|==
name|NULL
operator|)
condition|?
literal|"guest"
else|:
name|fts
operator|->
name|fts_password
expr_stmt|;
name|account
operator|=
name|fts
operator|->
name|fts_account
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"attemping connection with TCP host \"%s\" for user \"%s\""
argument_list|,
name|RemoteHost
argument_list|,
name|initiator
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftp_login
argument_list|(
name|RemoteHost
argument_list|,
name|initiator
argument_list|,
name|password
argument_list|,
name|account
argument_list|)
operator|==
name|NOTOK
condition|)
name|seterr
argument_list|(
name|FS_ACS_IDENTITY
argument_list|,
name|EREF_RFSU
argument_list|,
name|EREF_IFSU
argument_list|,
name|ftp_error
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|myhome
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|myhomelen
operator|=
name|strlen
argument_list|(
name|myhome
argument_list|)
expr_stmt|;
else|#
directive|else
name|guest
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NULL_INITIATOR
if|if
condition|(
operator|!
name|baduser
argument_list|(
name|NULLCP
argument_list|,
name|initiator
argument_list|)
operator|&&
name|baduser
argument_list|(
literal|"ftamguests"
argument_list|,
name|initiator
argument_list|)
condition|)
block|{
name|initiator
operator|=
name|ANON
expr_stmt|;
name|null_initiator
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|initiator
argument_list|,
literal|"ANON"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|initiator
argument_list|,
name|ANON
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|ANON
argument_list|)
operator|)
operator|&&
name|pw
operator|->
name|pw_uid
operator|==
literal|0
condition|)
name|pw
operator|=
name|NULL
expr_stmt|;
name|guest
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|pw
operator|=
name|baduser
argument_list|(
literal|"ftamusers"
argument_list|,
name|initiator
argument_list|)
condition|?
name|NULL
else|:
name|getpwnam
argument_list|(
name|initiator
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|seterr
argument_list|(
name|FS_ACS_USER
argument_list|,
name|EREF_RFSU
argument_list|,
name|EREF_IFSU
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|guest
operator|&&
name|fts
operator|->
name|fts_password
operator|==
name|NULL
operator|)
operator|||
operator|*
name|pw
operator|->
name|pw_passwd
operator|==
name|NULL
operator|||
operator|(
operator|!
name|guest
operator|&&
operator|!
name|chkpassword
argument_list|(
name|initiator
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|,
name|fts
operator|->
name|fts_password
argument_list|)
operator|)
condition|)
name|seterr
argument_list|(
name|FS_ACS_PASSWORD
argument_list|,
name|EREF_RFSU
argument_list|,
name|EREF_IFSU
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"initiator=%s, account=%s"
argument_list|,
name|initiator
argument_list|,
name|fts
operator|->
name|fts_account
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|account
operator|=
name|fts
operator|->
name|fts_account
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|fts
operator|->
name|fts_account
argument_list|)
operator|>
literal|1
operator|)
condition|)
block|{
specifier|register
name|struct
name|group
modifier|*
name|gr
init|=
name|getgrnam
argument_list|(
name|account
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|gp
decl_stmt|;
if|if
condition|(
name|gr
operator|==
name|NULL
condition|)
block|{
name|bad_account
label|:
empty_stmt|;
name|seterr
argument_list|(
name|FS_ACS_ACCT
argument_list|,
name|EREF_RFPM
argument_list|,
name|EREF_IFSU
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gr
operator|->
name|gr_gid
operator|!=
name|pw
operator|->
name|pw_gid
condition|)
block|{
for|for
control|(
name|gp
operator|=
name|gr
operator|->
name|gr_mem
init|;
operator|*
name|gp
condition|;
name|gp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|gp
argument_list|,
name|initiator
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|gp
condition|)
goto|goto
name|bad_account
goto|;
block|}
name|fts
operator|->
name|fts_account
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACS_MGMT
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFPM
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"unable to change to %s: %s"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|wtmp
operator|=
name|open
argument_list|(
literal|"/usr/adm/wtmp"
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
name|char
name|line
index|[
literal|32
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"ftam%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCPYN
argument_list|(
name|uts
operator|.
name|ut_line
argument_list|,
name|line
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
operator|(
name|void
operator|)
name|SCPYN
argument_list|(
name|uts
operator|.
name|ut_name
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|SCPYN
argument_list|(
name|uts
operator|.
name|ut_name
argument_list|,
name|initiator
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS5
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|bsd43_ut_host
argument_list|)
operator|(
name|void
operator|)
name|SCPYN
argument_list|(
name|uts
operator|.
name|ut_host
argument_list|,
name|na2str
argument_list|(
name|fts
operator|->
name|fts_callingaddr
operator|.
name|pa_addr
operator|.
name|sa_addr
operator|.
name|ta_addrs
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|uts
operator|.
name|ut_type
operator|=
name|USER_PROCESS
expr_stmt|;
endif|#
directive|endif
name|uts
operator|.
name|ut_time
operator|=
name|clok
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|wtmp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|uts
argument_list|,
sizeof|sizeof
name|uts
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYS5
argument_list|)
operator|||
name|defined
argument_list|(
name|bsd43_ut_host
argument_list|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|wtmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
name|cflag
operator|||
name|guest
condition|)
block|{
operator|(
name|void
operator|)
name|setisobject
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* for PDU pretty-printing 					   AND for A-ASSOCIATE.RESPONSE!!! */
if|if
condition|(
name|chroot
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
operator|!
name|debug
condition|)
name|dp
operator|=
name|diags
expr_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACS_MGMT
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFPM
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACS_USER
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFSU
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
block|}
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"unable to change root to %s: %s"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|dp
operator|++
expr_stmt|;
else|else
goto|goto
name|bad1
goto|;
block|}
ifdef|#
directive|ifdef
name|NULL_INITIATOR
elseif|else
if|if
condition|(
name|null_initiator
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|pw
operator|->
name|pw_dir
operator|=
literal|"/pub"
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_ACS_MGMT
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFPM
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_IFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"unable to change to %s: %s"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
else|else
block|{
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_INFORM
expr_stmt|;
name|dp
operator|->
name|ftd_identifier
operator|=
name|FS_GEN_NOREASON
expr_stmt|;
name|dp
operator|->
name|ftd_observer
operator|=
name|EREF_RFSU
operator|,
name|dp
operator|->
name|ftd_source
operator|=
name|EREF_RFSU
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
if|if
condition|(
name|guest
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|,
literal|"ANONymous user permitted, access restrictions apply"
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ftd_cc
operator|=
name|strlen
argument_list|(
name|dp
operator|->
name|ftd_data
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|pw
operator|->
name|pw_dir
operator|=
literal|"/"
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|myhome
argument_list|,
literal|"%s/"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|myhomelen
operator|=
name|strlen
argument_list|(
name|myhome
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS5
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|seteuid
argument_list|(
name|myuid
operator|=
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|myuid
operator|=
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|0022
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|FInitializeResponse
argument_list|(
name|ftamfd
argument_list|,
name|FSTATE_SUCCESS
argument_list|,
name|FACTION_SUCCESS
argument_list|,
name|NULLOID
argument_list|,
name|NULLAEI
argument_list|,
name|NULLPA
argument_list|,
name|fts
operator|->
name|fts_manage
argument_list|,
name|class
argument_list|,
name|units
argument_list|,
name|attrs
argument_list|,
name|NULLPE
argument_list|,
name|fqos
argument_list|,
operator|&
name|fts
operator|->
name|fts_contents
argument_list|,
name|diags
argument_list|,
name|dp
operator|-
name|diags
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-INITIALIZE.RESPONSE"
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"accepting association"
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|diags
argument_list|,
name|dp
operator|-
name|diags
argument_list|)
expr_stmt|;
return|return;
name|bad2
label|:
empty_stmt|;
name|dp
operator|->
name|ftd_type
operator|=
name|DIAG_PERM
expr_stmt|;
name|dp
operator|->
name|ftd_delay
operator|=
name|DIAG_NODELAY
expr_stmt|;
ifndef|#
directive|ifndef
name|BRIDGE
name|dp
operator|->
name|ftd_cc
operator|=
literal|0
expr_stmt|;
name|bad1
label|:
empty_stmt|;
endif|#
directive|endif
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"rejecting association"
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|diags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FInitializeResponse
argument_list|(
name|ftamfd
argument_list|,
name|FSTATE_FAILURE
argument_list|,
name|FACTION_PERM
argument_list|,
name|NULLOID
argument_list|,
name|NULLAEI
argument_list|,
name|NULLPA
argument_list|,
name|fts
operator|->
name|fts_manage
argument_list|,
name|class
argument_list|,
name|units
argument_list|,
literal|0
argument_list|,
name|NULLPE
argument_list|,
name|fqos
argument_list|,
operator|(
expr|struct
name|FTAMcontentlist
operator|*
operator|)
literal|0
argument_list|,
name|diags
argument_list|,
literal|1
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-INITIALIZE.RESPONSE(reject)"
argument_list|)
expr_stmt|;
name|closewtmp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|ftam_indication
parameter_list|(
name|fti
parameter_list|)
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
decl_stmt|;
block|{
switch|switch
condition|(
name|fti
operator|->
name|fti_type
condition|)
block|{
case|case
name|FTI_FINISH
case|:
name|ftam_finishindication
argument_list|(
operator|&
name|fti
operator|->
name|fti_finish
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_ABORT
case|:
name|ftam_abortindication
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_BULKBEGIN
case|:
name|ftam_bulkbeginindication
argument_list|(
operator|&
name|fti
operator|->
name|fti_group
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_READWRITE
case|:
name|ftam_readwriteindication
argument_list|(
operator|&
name|fti
operator|->
name|fti_readwrite
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_DATA
case|:
name|ftam_dataindication
argument_list|(
operator|&
name|fti
operator|->
name|fti_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_DATAEND
case|:
name|ftam_dataendindication
argument_list|(
operator|&
name|fti
operator|->
name|fti_dataend
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_CANCEL
case|:
name|ftam_cancelindication
argument_list|(
operator|&
name|fti
operator|->
name|fti_cancel
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_TRANSEND
case|:
name|ftam_transendindication
argument_list|(
operator|&
name|fti
operator|->
name|fti_transend
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_BULKEND
case|:
name|ftam_bulkendindication
argument_list|(
operator|&
name|fti
operator|->
name|fti_group
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTI_MANAGEMENT
case|:
name|ftam_managementindication
argument_list|(
operator|&
name|fti
operator|->
name|fti_group
argument_list|)
expr_stmt|;
break|break;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown indication type=%d"
argument_list|,
name|fti
operator|->
name|fti_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|TERMINATION */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|ftam_finishindication
argument_list|(
argument|ftf
argument_list|)
expr|struct
name|FTAMfinish
operator|*
name|ftf
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|long
name|now
decl_stmt|;
name|struct
name|FTAMcharging
name|fcs
decl_stmt|;
specifier|register
name|struct
name|FTAMcharging
modifier|*
name|fc
init|=
operator|&
name|fcs
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|fc
value|((struct FTAMcharging *) 0)
endif|#
directive|endif
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|ftp_quit
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"F-TERMINATE.INDICATION"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fc
operator|->
name|fc_ncharge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|account
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|fc
operator|->
name|fc_charges
index|[
name|fc
operator|->
name|fc_ncharge
index|]
operator|.
name|fc_resource
operator|=
literal|"elapsed time"
expr_stmt|;
name|fc
operator|->
name|fc_charges
index|[
name|fc
operator|->
name|fc_ncharge
index|]
operator|.
name|fc_unit
operator|=
literal|"seconds"
expr_stmt|;
name|fc
operator|->
name|fc_charges
index|[
name|fc
operator|->
name|fc_ncharge
operator|++
index|]
operator|.
name|fc_value
operator|=
call|(
name|int
call|)
argument_list|(
name|now
operator|-
name|clok
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|FTerminateResponse
argument_list|(
name|ftamfd
argument_list|,
name|NULLPE
argument_list|,
name|fc
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
name|ftam_adios
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-TERMINATE.RESPONSE"
argument_list|)
expr_stmt|;
name|FTFFREE
argument_list|(
name|ftf
argument_list|)
expr_stmt|;
name|closewtmp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|closewtmp
argument_list|()
end_macro

begin_block
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS5
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|bsd43_ut_host
argument_list|)
name|long
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|wtmp
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|wtmp
argument_list|,
literal|0L
argument_list|,
name|L_XTND
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCPYN
argument_list|(
name|uts
operator|.
name|ut_name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCPYN
argument_list|(
name|uts
operator|.
name|ut_host
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|uts
operator|.
name|ut_time
operator|=
name|now
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|wtmp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|uts
argument_list|,
sizeof|sizeof
name|uts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|wtmp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*
comment|ABORT */
end_comment

begin_expr_stmt
specifier|static
name|ftam_abortindication
argument_list|(
name|fta
argument_list|)
specifier|register
expr|struct
name|FTAMabort
operator|*
name|fta
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"F-%s-ABORT.INDICATION %d"
argument_list|,
name|fta
operator|->
name|fta_peer
condition|?
literal|"U"
else|:
literal|"P"
argument_list|,
name|fta
operator|->
name|fta_action
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|fta
operator|->
name|fta_diags
argument_list|,
name|fta
operator|->
name|fta_ndiag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|ftp_abort
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ftp_quit
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fta
operator|->
name|fta_action
operator|!=
name|FACTION_PERM
operator|&&
operator|!
name|fta
operator|->
name|fta_peer
condition|)
operator|(
name|void
operator|)
name|FUAbortRequest
argument_list|(
name|ftamfd
argument_list|,
name|FACTION_PERM
argument_list|,
operator|(
expr|struct
name|FTAMdiagnostic
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|ftis
argument_list|)
expr_stmt|;
name|closewtmp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

