begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftam-ls.c - interactive initiator FTAM -- "ls" */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/ftam2/RCS/ftam-ls.c,v 7.5 91/02/22 09:23:45 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/ftam2/RCS/ftam-ls.c,v 7.5 91/02/22 09:23:45 mrose Interim $  *  *  * $Log:	ftam-ls.c,v $  * Revision 7.5  91/02/22  09:23:45  mrose  * Interim 6.8  *   * Revision 7.4  91/01/13  12:26:56  mrose  * NBS  *   * Revision 7.3  90/11/21  11:30:26  mrose  * sun  *   * Revision 7.2  90/11/05  13:29:46  mrose  * nist  *   * Revision 7.1  90/07/01  21:03:12  mrose  * pepsy  *   * Revision 7.0  89/11/23  21:54:21  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"FTAM-types.h"
end_include

begin_include
include|#
directive|include
file|"ftamuser.h"
end_include

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dashl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|didrecurse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|silent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|now
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|longtimeago
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|toomany
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfilent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|filent
modifier|*
name|filents
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|filcmp
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_function_decl
name|FILE
modifier|*
name|fdopen
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|lsfp
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE
end_ifndef

begin_function
name|int
name|f_fls
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|doingpipe
decl_stmt|,
name|result
decl_stmt|;
name|SFP
name|pstat
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|pp
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|pp
operator|=
name|vec
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|getline
argument_list|(
literal|"output to file/program: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
operator|||
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
return|return
name|OK
return|;
block|}
name|cp
operator|=
name|vec
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|popen
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"unable to start"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
name|doingpipe
operator|=
literal|1
expr_stmt|;
name|pstat
operator|=
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|xglob1val
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|OK
return|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|cp
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|cp
argument_list|,
literal|"unable to write"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
name|doingpipe
operator|=
literal|0
expr_stmt|;
block|}
name|vec
index|[
literal|0
index|]
operator|=
name|pp
operator|+
literal|1
expr_stmt|;
name|lsfp
operator|=
name|fp
expr_stmt|;
name|result
operator|=
name|f_ls
argument_list|(
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|doingpipe
condition|)
block|{
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pstat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|lsfp
operator|=
name|stdout
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|f_ls
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|invis
decl_stmt|,
name|multi
decl_stmt|,
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|int
name|fd
decl_stmt|;
else|#
directive|else
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dashl
operator|=
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"dir"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|attrs
operator|&
name|FATTR_STORAGE
operator|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"no support for storage attributes"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|longtimeago
operator|=
name|now
operator|-
literal|6L
operator|*
literal|30L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
return|return
name|NOTOK
return|;
else|#
directive|else
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNIX
case|:
operator|*
name|vec
operator|++
operator|=
literal|"."
expr_stmt|;
operator|*
name|vec
operator|--
operator|=
name|NULL
expr_stmt|;
name|invis
operator|=
operator|!
name|dashl
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|getline
argument_list|(
literal|"file: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
operator|||
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
return|return
name|OK
return|;
name|invis
operator|=
literal|0
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
else|else
name|invis
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
operator|(
name|fd
operator|=
name|dataconn
argument_list|(
literal|"LIST"
argument_list|)
operator|)
operator|==
name|NOTOK
operator|||
operator|(
name|lsfp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftam_error
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
return|return
name|DONE
return|;
block|}
endif|#
directive|endif
name|result
operator|=
name|OK
expr_stmt|;
if|if
condition|(
name|vec
operator|=
name|xglob
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|gp
decl_stmt|;
name|didrecurse
operator|=
literal|0
expr_stmt|;
name|multi
operator|=
name|vec
index|[
literal|1
index|]
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|vec
init|;
operator|*
name|gp
operator|&&
operator|!
name|interrupted
condition|;
name|gp
operator|++
control|)
block|{
name|result
operator|=
name|ls
argument_list|(
operator|*
name|gp
argument_list|,
operator|*
name|gp
argument_list|,
literal|1
argument_list|,
name|gp
operator|==
name|vec
argument_list|,
name|gp
index|[
literal|1
index|]
operator|==
name|NULL
argument_list|,
name|invis
argument_list|,
name|multi
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftamfd
operator|==
name|NOTOK
operator|||
name|result
operator|==
name|NOTOK
condition|)
break|break;
block|}
name|blkfree
argument_list|(
name|vec
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|lsfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|ls
parameter_list|(
name|file
parameter_list|,
name|entry
parameter_list|,
name|top
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|,
name|invis
parameter_list|,
name|multi
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|,
decl|*
name|entry
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|top
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|,
name|invis
decl_stmt|,
name|multi
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|recurse
decl_stmt|;
name|long
name|mtime
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|UTC
name|ut
decl_stmt|;
name|struct
name|FTAMgroup
name|ftgs
decl_stmt|;
specifier|register
name|struct
name|FTAMgroup
modifier|*
name|ftg
init|=
operator|&
name|ftgs
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
name|struct
name|vfsmap
modifier|*
name|vf
init|=
operator|&
name|vfs
index|[
name|VFS_FDF
index|]
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftg
argument_list|,
sizeof|sizeof
expr|*
name|ftg
argument_list|)
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_BEGIN
operator||
name|FTG_END
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|=
literal|0
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_SELECT
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftse
operator|->
name|ftse_attrs
decl_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|FA_FILENAME
expr_stmt|;
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|file
expr_stmt|;
name|ftse
operator|->
name|ftse_access
operator|=
name|FA_PERM_READATTR
expr_stmt|;
name|FCINIT
argument_list|(
operator|&
name|ftse
operator|->
name|ftse_conctl
argument_list|)
expr_stmt|;
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_RDATTR
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMreadattr
modifier|*
name|ftra
init|=
operator|&
name|ftg
operator|->
name|ftg_readattr
decl_stmt|;
name|ftra
operator|->
name|ftra_attrnames
operator|=
name|FA_FILENAME
operator||
name|FA_CONTENTS
expr_stmt|;
if|if
condition|(
name|dashl
condition|)
ifdef|#
directive|ifdef
name|DEBUG
name|ftra
operator|->
name|ftra_attrnames
operator||=
name|FA_STORAGE
operator||
operator|(
name|attrs
operator|&
name|FATTR_SECURITY
condition|?
name|FA_SECURITY
else|:
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|ftra
operator|->
name|ftra_attrnames
operator||=
name|FA_ID_CREATE
operator||
name|FA_DATE_MODIFY
operator||
name|FA_ACCOUNT
operator||
name|FA_FILESIZE
expr_stmt|;
endif|#
directive|endif
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DESELECT
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
if|if
condition|(
name|FManageRequest
argument_list|(
name|ftamfd
argument_list|,
name|ftg
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-MANAGE.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ftg
operator|=
operator|&
name|fti
operator|->
name|fti_group
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftse
operator|->
name|ftse_attrs
decl_stmt|;
if|if
condition|(
name|multi
operator|&&
name|ftse
operator|->
name|ftse_state
operator|!=
name|FSTATE_SUCCESS
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|fa
operator|->
name|fa_files
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftse
operator|->
name|ftse_diags
argument_list|,
name|ftse
operator|->
name|ftse_ndiag
argument_list|,
literal|1
argument_list|,
name|ftse
operator|->
name|ftse_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftse
operator|->
name|ftse_state
operator|!=
name|FSTATE_SUCCESS
condition|)
goto|goto
name|you_lose
goto|;
name|file
operator|=
name|fa
operator|->
name|fa_files
index|[
literal|0
index|]
expr_stmt|;
block|}
name|recurse
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_RDATTR
condition|)
block|{
specifier|register
name|struct
name|FTAMreadattr
modifier|*
name|ftra
init|=
operator|&
name|ftg
operator|->
name|ftg_readattr
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftra
operator|->
name|ftra_attrs
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftra
operator|->
name|ftra_diags
argument_list|,
name|ftra
operator|->
name|ftra_ndiag
argument_list|,
literal|1
argument_list|,
name|ftra
operator|->
name|ftra_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftra
operator|->
name|ftra_action
operator|!=
name|FACTION_SUCCESS
condition|)
name|fa
operator|->
name|fa_present
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_present
operator|&=
operator|~
name|fa
operator|->
name|fa_novalue
expr_stmt|;
if|if
condition|(
name|top
operator|&&
operator|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_FILENAME
operator|)
operator|&&
name|vf
operator|->
name|vf_oid
operator|&&
operator|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_CONTENTS
operator|)
operator|&&
name|oid_cmp
argument_list|(
name|vf
operator|->
name|vf_oid
argument_list|,
name|fa
operator|->
name|fa_contents
argument_list|)
operator|==
literal|0
condition|)
block|{
name|recurse
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|didrecurse
operator|&&
operator|!
name|first
condition|)
ifdef|#
directive|ifdef
name|BRIDGE
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|invis
condition|)
name|invis
operator|=
name|recurse
operator|&&
operator|!
name|multi
expr_stmt|;
comment|/* recurse depends on top */
if|if
condition|(
name|dashl
operator|&&
operator|!
name|invis
operator|&&
operator|!
name|recurse
condition|)
block|{
name|s
operator|=
operator|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_ID_CREATE
operator|)
condition|?
name|fa
operator|->
name|fa_id_create
else|:
name|NULL
expr_stmt|;
name|ut
operator|=
operator|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_DATE_MODIFY
operator|)
condition|?
operator|&
name|fa
operator|->
name|fa_date_modify
else|:
name|NULLUTC
expr_stmt|;
if|if
condition|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_CONTENTS
condition|)
block|{
specifier|register
name|struct
name|vfsmap
modifier|*
name|uf
decl_stmt|;
for|for
control|(
name|uf
operator|=
name|vfs
init|;
name|uf
operator|->
name|vf_entry
condition|;
name|uf
operator|++
control|)
if|if
condition|(
name|oid_cmp
argument_list|(
name|uf
operator|->
name|vf_oid
argument_list|,
name|fa
operator|->
name|fa_contents
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"%c "
argument_list|,
name|uf
operator|->
name|vf_entry
condition|?
name|uf
operator|->
name|vf_stat
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"%-8.8s %-8.8s %8d "
argument_list|,
name|s
condition|?
name|s
else|:
literal|""
argument_list|,
operator|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_ACCOUNT
operator|)
condition|?
name|fa
operator|->
name|fa_account
else|:
literal|""
argument_list|,
operator|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_FILESIZE
operator|)
condition|?
name|fa
operator|->
name|fa_filesize
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ut
condition|)
block|{
name|mtime
operator|=
name|gtime
argument_list|(
name|ut2tm
argument_list|(
name|ut
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ctime
argument_list|(
operator|&
name|mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
operator|<
name|longtimeago
operator|||
name|mtime
operator|>
name|now
condition|)
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"%-7.7s %-4.4s "
argument_list|,
name|s
operator|+
literal|4
argument_list|,
name|s
operator|+
literal|20
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"%-12.12s "
argument_list|,
name|s
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"             "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|invis
condition|)
block|{
name|char
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|top
operator|&&
operator|(
name|fa
operator|->
name|fa_present
operator|&
name|FA_FILENAME
operator|)
condition|?
name|fa
operator|->
name|fa_files
index|[
literal|0
index|]
else|:
name|entry
expr_stmt|;
ifdef|#
directive|ifdef
name|BRIDGE
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"%s%s\r\n"
argument_list|,
name|dp
argument_list|,
name|multi
operator|&&
name|recurse
condition|?
literal|":"
else|:
literal|""
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"%s%s\n"
argument_list|,
name|dp
argument_list|,
name|multi
operator|&&
name|recurse
condition|?
literal|":"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DESELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMdeselect
modifier|*
name|ftde
init|=
operator|&
name|ftg
operator|->
name|ftg_deselect
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftde
operator|->
name|ftde_diags
argument_list|,
name|ftde
operator|->
name|ftde_ndiag
argument_list|,
literal|1
argument_list|,
name|ftde
operator|->
name|ftde_action
argument_list|)
expr_stmt|;
name|ftam_chrg
argument_list|(
operator|&
name|ftde
operator|->
name|ftde_charges
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recurse
condition|)
block|{
name|struct
name|FADUidentity
name|faduids
decl_stmt|;
specifier|register
name|struct
name|FADUidentity
modifier|*
name|faduid
init|=
operator|&
name|faduids
decl_stmt|;
name|faduid
operator|->
name|fa_type
operator|=
name|FA_FIRSTLAST
expr_stmt|;
name|faduid
operator|->
name|fa_firstlast
operator|=
name|FA_FIRST
expr_stmt|;
operator|(
name|void
operator|)
name|fdffnx
argument_list|(
name|NOTOK
argument_list|,
operator|(
expr|struct
name|PSAPdata
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getvf
argument_list|(
name|file
argument_list|,
name|NULLCP
argument_list|,
name|faduid
argument_list|,
name|vf
argument_list|,
name|fdffnx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fdfls
argument_list|(
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fdffnx
argument_list|(
name|NOTOK
argument_list|,
operator|(
expr|struct
name|PSAPdata
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|didrecurse
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|top
operator|&&
operator|!
name|last
operator|&&
name|didrecurse
condition|)
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|you_lose
label|:
empty_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|fdfls
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|w
decl_stmt|;
name|int
name|columns
decl_stmt|,
name|width
decl_stmt|,
name|lines
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|filent
modifier|*
name|fi
decl_stmt|,
modifier|*
modifier|*
name|xi
decl_stmt|,
modifier|*
modifier|*
name|yi
decl_stmt|;
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNIX
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
operator|*
name|file
operator|==
literal|'/'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s/"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|i
operator|=
name|bp
operator|-
name|buffer
expr_stmt|;
for|for
control|(
name|xi
operator|=
operator|&
name|filents
init|;
name|fi
operator|=
operator|*
name|xi
condition|;
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|fi
operator|->
name|fi_name
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fi
operator|->
name|fi_entry
operator|=
name|fi
operator|->
name|fi_name
operator|+
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|dashl
operator|&&
operator|!
name|silent
operator|&&
operator|*
name|fi
operator|->
name|fi_entry
operator|==
literal|'.'
condition|)
block|{
operator|*
name|xi
operator|=
name|fi
operator|->
name|fi_next
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|fi_name
condition|)
name|free
argument_list|(
name|fi
operator|->
name|fi_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|fi_oid
condition|)
name|oid_free
argument_list|(
name|fi
operator|->
name|fi_oid
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fi
argument_list|)
expr_stmt|;
name|nfilent
operator|--
expr_stmt|;
block|}
else|else
name|xi
operator|=
operator|&
name|fi
operator|->
name|fi_next
expr_stmt|;
block|}
block|}
else|else
name|bp
operator|=
name|buffer
expr_stmt|;
break|break;
default|default:
name|bp
operator|=
name|buffer
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|nfilent
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|fi
operator|=
name|filents
expr_stmt|;
if|if
condition|(
name|dashl
condition|)
operator|(
name|void
operator|)
name|ls
argument_list|(
name|fi
operator|->
name|fi_name
argument_list|,
name|fi
operator|->
name|fi_entry
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|BRIDGE
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"%s\r\n"
argument_list|,
name|fi
operator|->
name|fi_entry
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"%s\n"
argument_list|,
name|fi
operator|->
name|fi_entry
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|xi
operator|=
operator|(
expr|struct
name|filent
operator|*
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|nfilent
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|xi
argument_list|)
expr_stmt|;
if|if
condition|(
name|xi
condition|)
block|{
for|for
control|(
name|fi
operator|=
name|filents
operator|,
name|yi
operator|=
name|xi
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|fi_next
control|)
operator|*
name|yi
operator|++
operator|=
name|fi
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|xi
argument_list|,
name|nfilent
argument_list|,
sizeof|sizeof
expr|*
name|xi
argument_list|,
name|filcmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dashl
condition|)
block|{
if|if
condition|(
name|xi
condition|)
block|{
for|for
control|(
name|filents
operator|=
name|NULL
operator|,
name|yi
operator|--
init|;
name|yi
operator|>=
name|xi
condition|;
name|yi
operator|--
control|)
block|{
name|fi
operator|=
operator|*
name|yi
expr_stmt|;
name|fi
operator|->
name|fi_next
operator|=
name|filents
expr_stmt|;
name|filents
operator|=
name|fi
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|xi
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|fi
operator|=
name|filents
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|fi_next
control|)
operator|(
name|void
operator|)
name|ls
argument_list|(
name|fi
operator|->
name|fi_name
argument_list|,
name|fi
operator|->
name|fi_entry
argument_list|,
literal|0
argument_list|,
name|fi
operator|==
name|filents
argument_list|,
name|fi
operator|->
name|fi_next
operator|==
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|xi
condition|)
block|{
for|for
control|(
name|fi
operator|=
name|filents
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|fi_next
control|)
ifdef|#
directive|ifdef
name|BRIDGE
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"%s\r\n"
argument_list|,
name|fi
operator|->
name|fi_entry
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"%s\n"
argument_list|,
name|fi
operator|->
name|fi_entry
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|width
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|yi
operator|=
name|xi
init|;
name|fi
operator|=
operator|*
name|yi
condition|;
name|yi
operator|++
control|)
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
name|fi
operator|->
name|fi_entry
argument_list|)
operator|)
operator|>
name|width
condition|)
name|width
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|lsfp
operator|!=
name|stdout
condition|)
block|{
name|columns
operator|=
literal|1
expr_stmt|;
name|lines
operator|=
name|nfilent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|columns
operator|=
name|ncols
argument_list|(
name|lsfp
argument_list|)
operator|/
operator|(
name|width
operator|=
operator|(
name|width
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
operator|==
literal|0
condition|)
name|columns
operator|=
literal|1
expr_stmt|;
name|lines
operator|=
operator|(
name|nfilent
operator|+
name|columns
operator|-
literal|1
operator|)
operator|/
name|columns
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
block|{
name|fi
operator|=
name|xi
index|[
name|w
operator|=
name|j
operator|*
name|lines
operator|+
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|lsfp
argument_list|,
literal|"%s"
argument_list|,
name|fi
operator|->
name|fi_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|+
name|lines
operator|>=
name|nfilent
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\r'
argument_list|,
name|lsfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|lsfp
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|lsfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
for|for
control|(
name|w
operator|=
name|strlen
argument_list|(
name|fi
operator|->
name|fi_entry
argument_list|)
init|;
name|w
operator|<
name|width
condition|;
name|w
operator|=
operator|(
name|w
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
control|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|lsfp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|xi
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|fdffnx
parameter_list|(
name|fd
parameter_list|,
name|px
parameter_list|,
name|status
parameter_list|)
name|int
name|fd
decl_stmt|;
specifier|register
name|struct
name|PSAPdata
modifier|*
name|px
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|PE
name|pe
decl_stmt|,
modifier|*
name|pep
decl_stmt|;
specifier|register
name|struct
name|filent
modifier|*
name|fi
decl_stmt|;
if|if
condition|(
name|px
operator|==
name|NULL
condition|)
block|{
specifier|register
name|struct
name|filent
modifier|*
name|gi
decl_stmt|;
for|for
control|(
name|fi
operator|=
name|filents
init|;
name|fi
condition|;
name|fi
operator|=
name|gi
control|)
block|{
name|gi
operator|=
name|fi
operator|->
name|fi_next
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|fi_name
condition|)
empty_stmt|;
name|free
argument_list|(
name|fi
operator|->
name|fi_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|fi_oid
condition|)
name|oid_free
argument_list|(
name|fi
operator|->
name|fi_oid
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fi
argument_list|)
expr_stmt|;
block|}
name|filents
operator|=
name|NULL
operator|,
name|nfilent
operator|=
name|toomany
operator|=
literal|0
expr_stmt|;
name|silent
operator|=
name|status
expr_stmt|;
return|return
name|OK
return|;
block|}
for|for
control|(
name|pep
operator|=
name|px
operator|->
name|px_info
operator|,
name|i
operator|=
name|px
operator|->
name|px_ninfo
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|pep
operator|++
operator|,
name|i
operator|--
control|)
block|{
name|int
name|result
decl_stmt|;
name|struct
name|type_DOCS_NBS__9__Datatype1
modifier|*
name|d9
decl_stmt|;
name|struct
name|FTAMattributes
name|fas
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|fas
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
operator|*
name|pep
operator|)
operator|==
name|NULLPE
condition|)
continue|continue;
name|d9
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|decode_DOCS_NBS__9__Datatype1
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|d9
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|silent
condition|)
name|globerr
operator|=
name|PY_pepy
expr_stmt|;
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
if|if
condition|(
name|d9
condition|)
name|free_DOCS_NBS__9__Datatype1
argument_list|(
name|d9
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|debug
condition|)
name|WATCHP
argument_list|(
name|DOCS_NBS__9__Datatype1
argument_list|,
name|pe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fa
argument_list|,
sizeof|sizeof
expr|*
name|fa
argument_list|)
expr_stmt|;
name|result
operator|=
name|fdf_d2attrs
argument_list|(
name|ftamfd
argument_list|,
name|d9
argument_list|,
name|fa
argument_list|,
operator|&
name|ftis
argument_list|)
expr_stmt|;
name|free_DOCS_NBS__9__Datatype1
argument_list|(
name|d9
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
block|{
specifier|register
name|struct
name|FTAMabort
modifier|*
name|fta
init|=
operator|&
name|ftis
operator|.
name|fti_abort
decl_stmt|;
if|if
condition|(
name|silent
condition|)
name|globerr
operator|=
literal|"unable to interpret datatype"
expr_stmt|;
else|else
name|ftam_diag
argument_list|(
name|fta
operator|->
name|fta_diags
argument_list|,
name|fta
operator|->
name|fta_ndiag
argument_list|,
name|fta
operator|->
name|fta_peer
argument_list|,
name|FACTION_PERM
argument_list|)
expr_stmt|;
name|FAFREE
argument_list|(
name|fa
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fi
operator|=
operator|(
expr|struct
name|filent
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|toomany
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|silent
condition|)
name|globerr
operator|=
literal|"too many files, listing truncated"
expr_stmt|;
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"too many files, listing truncated"
argument_list|)
expr_stmt|;
name|toomany
operator|++
expr_stmt|;
block|}
name|FAFREE
argument_list|(
name|fa
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|fa
operator|->
name|fa_present
operator|&
operator|(
name|FA_FILENAME
operator||
name|FA_CONTENTS
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|silent
condition|)
name|globerr
operator|=
literal|"no filename/contents found in FDF entry"
expr_stmt|;
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"no filename/contents found in FDF entry"
argument_list|)
expr_stmt|;
name|FAFREE
argument_list|(
name|fa
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fi
operator|->
name|fi_name
operator|=
name|fa
operator|->
name|fa_files
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|fi
operator|->
name|fi_name
operator|==
literal|'/'
operator|&&
operator|*
operator|(
name|fi
operator|->
name|fi_name
operator|+
literal|1
operator|)
operator|==
literal|'/'
condition|)
name|fi
operator|->
name|fi_entry
operator|=
name|fi
operator|->
name|fi_name
operator|+
literal|1
expr_stmt|;
else|else
name|fi
operator|->
name|fi_entry
operator|=
name|fi
operator|->
name|fi_name
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
literal|0
index|]
operator|=
name|NULLCP
expr_stmt|;
name|fi
operator|->
name|fi_oid
operator|=
name|fa
operator|->
name|fa_contents
expr_stmt|;
name|fa
operator|->
name|fa_contents
operator|=
name|NULLOID
expr_stmt|;
name|fi
operator|->
name|fi_next
operator|=
name|filents
expr_stmt|;
name|filents
operator|=
name|fi
operator|,
name|nfilent
operator|++
expr_stmt|;
name|FAFREE
argument_list|(
name|fa
argument_list|)
expr_stmt|;
block|}
name|PXFREE
argument_list|(
name|px
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|filcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|filent
modifier|*
modifier|*
name|a
decl_stmt|,
decl|*
modifier|*
name|b
decl_stmt|;
end_function

begin_block
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|fi_entry
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|fi_entry
argument_list|)
return|;
block|}
end_block

end_unit

