begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* turbo_avl.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/dsap/common/RCS/turbo_avl.c,v 7.1 91/02/22 09:20:36 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/dsap/common/RCS/turbo_avl.c,v 7.1 91/02/22 09:20:36 mrose Interim $  *  *  * $Log:	turbo_avl.c,v $  * Revision 7.1  91/02/22  09:20:36  mrose  * Interim 6.8  *   * Revision 7.0  90/12/19  09:41:32  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"manifest.h"
end_include

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/attr.h"
end_include

begin_include
include|#
directive|include
file|"quipu/entry.h"
end_include

begin_include
include|#
directive|include
file|"quipu/turbo.h"
end_include

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ROTATERIGHT
parameter_list|(
name|x
parameter_list|)
value|{ \ 	Avlnode *tmp;\ 	if ( *x == NULL || (*x)->avl_left == NULL ) {\ 		(void) printf("RR error\n"); exit(1); \ 	}\ 	tmp = (*x)->avl_left;\ 	(*x)->avl_left = tmp->avl_right;\ 	tmp->avl_right = *x;\ 	*x = tmp;\ }
end_define

begin_define
define|#
directive|define
name|ROTATELEFT
parameter_list|(
name|x
parameter_list|)
value|{ \ 	Avlnode *tmp;\ 	if ( *x == NULL || (*x)->avl_right == NULL ) {\ 		(void) printf("RL error\n"); exit(1); \ 	}\ 	tmp = (*x)->avl_right;\ 	(*x)->avl_right = tmp->avl_left;\ 	tmp->avl_left = *x;\ 	*x = tmp;\ }
end_define

begin_expr_stmt
specifier|static
name|ravl_insert
argument_list|(
argument|iroot
argument_list|,
argument|data
argument_list|,
argument|taller
argument_list|,
argument|fcmp
argument_list|,
argument|fdup
argument_list|,
argument|depth
argument_list|)
name|Avlnode
operator|*
operator|*
name|iroot
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|taller
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|fcmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* comparison function */
end_comment

begin_decl_stmt
name|IFP
name|fdup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function to call for duplicates */
end_comment

begin_decl_stmt
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rc
decl_stmt|,
name|cmp
decl_stmt|,
name|tallersub
decl_stmt|;
name|Avlnode
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|*
name|iroot
operator|==
literal|0
condition|)
block|{
operator|*
name|iroot
operator|=
operator|(
name|Avlnode
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Avlnode
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_left
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_right
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_data
operator|=
name|data
expr_stmt|;
operator|*
name|taller
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
name|cmp
operator|=
call|(
modifier|*
name|fcmp
call|)
argument_list|(
name|data
argument_list|,
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_data
argument_list|)
expr_stmt|;
comment|/* equal - duplicate name */
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
operator|*
name|taller
operator|=
literal|0
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|fdup
call|)
argument_list|(
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_data
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
comment|/* go right */
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|ravl_insert
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_right
operator|)
argument_list|,
name|data
argument_list|,
operator|&
name|tallersub
argument_list|,
name|fcmp
argument_list|,
name|fdup
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|tallersub
condition|)
switch|switch
condition|(
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
condition|)
block|{
case|case
name|LH
case|:
comment|/* left high - balance is restored */
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
operator|*
name|taller
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EH
case|:
comment|/* equal height - now right heavy */
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|RH
expr_stmt|;
operator|*
name|taller
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RH
case|:
comment|/* right heavy to start - right balance */
name|r
operator|=
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_right
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|avl_bf
condition|)
block|{
case|case
name|LH
case|:
comment|/* double rotation left */
name|l
operator|=
name|r
operator|->
name|avl_left
expr_stmt|;
switch|switch
condition|(
name|l
operator|->
name|avl_bf
condition|)
block|{
case|case
name|LH
case|:
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|r
operator|->
name|avl_bf
operator|=
name|RH
expr_stmt|;
break|break;
case|case
name|EH
case|:
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|r
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
break|break;
case|case
name|RH
case|:
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|LH
expr_stmt|;
name|r
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
break|break;
block|}
name|l
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|ROTATERIGHT
argument_list|(
operator|(
operator|&
name|r
operator|)
argument_list|)
argument_list|(
operator|*
name|iroot
argument_list|)
operator|->
name|avl_right
operator|=
name|r
expr_stmt|;
name|ROTATELEFT
argument_list|(
name|iroot
argument_list|)
operator|*
name|taller
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EH
case|:
comment|/* This should never happen */
break|break;
case|case
name|RH
case|:
comment|/* single rotation left */
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|r
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|ROTATELEFT
argument_list|(
name|iroot
argument_list|)
operator|*
name|taller
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
block|}
else|else
operator|*
name|taller
operator|=
literal|0
expr_stmt|;
block|}
comment|/* go left */
else|else
block|{
name|rc
operator|=
name|ravl_insert
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_left
operator|)
argument_list|,
name|data
argument_list|,
operator|&
name|tallersub
argument_list|,
name|fcmp
argument_list|,
name|fdup
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|tallersub
condition|)
switch|switch
condition|(
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
condition|)
block|{
case|case
name|LH
case|:
comment|/* left high to start - left balance */
name|l
operator|=
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_left
expr_stmt|;
switch|switch
condition|(
name|l
operator|->
name|avl_bf
condition|)
block|{
case|case
name|LH
case|:
comment|/* single rotation right */
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|l
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|ROTATERIGHT
argument_list|(
name|iroot
argument_list|)
operator|*
name|taller
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EH
case|:
comment|/* this should never happen */
break|break;
case|case
name|RH
case|:
comment|/* double rotation right */
name|r
operator|=
name|l
operator|->
name|avl_right
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|avl_bf
condition|)
block|{
case|case
name|LH
case|:
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|RH
expr_stmt|;
name|l
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
break|break;
case|case
name|EH
case|:
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|l
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
break|break;
case|case
name|RH
case|:
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|l
operator|->
name|avl_bf
operator|=
name|LH
expr_stmt|;
break|break;
block|}
name|r
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|ROTATELEFT
argument_list|(
operator|(
operator|&
name|l
operator|)
argument_list|)
argument_list|(
operator|*
name|iroot
argument_list|)
operator|->
name|avl_left
operator|=
name|l
expr_stmt|;
name|ROTATERIGHT
argument_list|(
name|iroot
argument_list|)
operator|*
name|taller
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EH
case|:
comment|/* equal height - now left heavy */
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|LH
expr_stmt|;
operator|*
name|taller
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RH
case|:
comment|/* right high - balance is restored */
operator|(
operator|*
name|iroot
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
operator|*
name|taller
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|taller
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * avl_insert -- insert a node containing data data into the avl tree  * with root root.  fcmp is a function to call to compare the data portion  * of two nodes.  it should take two arguments and return<,>, or == 0,  * depending on whether its first argument is<,>, or == its second  * argument (like strcmp, e.g.).  fdup is a function to call when a duplicate  * node is inserted.  it should return OK, or NOTOK and its return value  * will be the return value from avl_insert in the case of a duplicate node.  * the function will be called with the original node's data as its first  * argument and with the incoming duplicate node's data as its second  * argument.  this could be used, for example, to keep a count with each  * node.  *  * NOTE: this routine may malloc memory  */
end_comment

begin_macro
name|avl_insert
argument_list|(
argument|root
argument_list|,
argument|data
argument_list|,
argument|fcmp
argument_list|,
argument|fdup
argument_list|)
end_macro

begin_decl_stmt
name|Avlnode
modifier|*
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|fcmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|fdup
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|taller
decl_stmt|;
return|return
operator|(
name|ravl_insert
argument_list|(
name|root
argument_list|,
name|data
argument_list|,
operator|&
name|taller
argument_list|,
name|fcmp
argument_list|,
name|fdup
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* called from delete when root's right subtree has been shortened */
end_comment

begin_expr_stmt
specifier|static
name|right_balance
argument_list|(
argument|root
argument_list|)
name|Avlnode
operator|*
operator|*
name|root
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|shorter
decl_stmt|;
name|Avlnode
modifier|*
name|r
decl_stmt|,
modifier|*
name|l
decl_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
condition|)
block|{
case|case
name|RH
case|:
comment|/* was right high - equal now */
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|shorter
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EH
case|:
comment|/* was equal - left high now */
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|LH
expr_stmt|;
name|shorter
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LH
case|:
comment|/* was right high - balance */
name|l
operator|=
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_left
expr_stmt|;
switch|switch
condition|(
name|l
operator|->
name|avl_bf
condition|)
block|{
case|case
name|RH
case|:
comment|/* double rotation left */
name|r
operator|=
name|l
operator|->
name|avl_right
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|avl_bf
condition|)
block|{
case|case
name|RH
case|:
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|l
operator|->
name|avl_bf
operator|=
name|LH
expr_stmt|;
break|break;
case|case
name|EH
case|:
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|l
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
break|break;
case|case
name|LH
case|:
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|RH
expr_stmt|;
name|l
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
break|break;
block|}
name|r
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|ROTATELEFT
argument_list|(
operator|(
operator|&
name|l
operator|)
argument_list|)
argument_list|(
operator|*
name|root
argument_list|)
operator|->
name|avl_left
operator|=
name|l
expr_stmt|;
name|ROTATERIGHT
argument_list|(
argument|root
argument_list|)
name|shorter
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EH
case|:
comment|/* right rotation */
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|LH
expr_stmt|;
name|l
operator|->
name|avl_bf
operator|=
name|RH
expr_stmt|;
name|ROTATERIGHT
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|shorter
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LH
case|:
comment|/* single rotation right */
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|l
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|ROTATERIGHT
argument_list|(
argument|root
argument_list|)
name|shorter
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
operator|(
name|shorter
operator|)
return|;
block|}
end_block

begin_comment
comment|/* called from delete when root's left subtree has gotten shorter */
end_comment

begin_expr_stmt
specifier|static
name|left_balance
argument_list|(
argument|root
argument_list|)
name|Avlnode
operator|*
operator|*
name|root
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|shorter
decl_stmt|;
name|Avlnode
modifier|*
name|r
decl_stmt|,
modifier|*
name|l
decl_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
condition|)
block|{
case|case
name|LH
case|:
comment|/* was left high - equal now */
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|shorter
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EH
case|:
comment|/* was equal - right high now */
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|RH
expr_stmt|;
name|shorter
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RH
case|:
comment|/* was right high - balance */
name|r
operator|=
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_right
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|avl_bf
condition|)
block|{
case|case
name|LH
case|:
comment|/* double rotation left */
name|l
operator|=
name|r
operator|->
name|avl_left
expr_stmt|;
switch|switch
condition|(
name|l
operator|->
name|avl_bf
condition|)
block|{
case|case
name|LH
case|:
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|r
operator|->
name|avl_bf
operator|=
name|RH
expr_stmt|;
break|break;
case|case
name|EH
case|:
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|r
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
break|break;
case|case
name|RH
case|:
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|LH
expr_stmt|;
name|r
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
break|break;
block|}
name|l
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|ROTATERIGHT
argument_list|(
operator|(
operator|&
name|r
operator|)
argument_list|)
argument_list|(
operator|*
name|root
argument_list|)
operator|->
name|avl_right
operator|=
name|r
expr_stmt|;
name|ROTATELEFT
argument_list|(
argument|root
argument_list|)
name|shorter
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EH
case|:
comment|/* single rotation left */
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|RH
expr_stmt|;
name|r
operator|->
name|avl_bf
operator|=
name|LH
expr_stmt|;
name|ROTATELEFT
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|shorter
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RH
case|:
comment|/* single rotation left */
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|r
operator|->
name|avl_bf
operator|=
name|EH
expr_stmt|;
name|ROTATELEFT
argument_list|(
argument|root
argument_list|)
name|shorter
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
operator|(
name|shorter
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|caddr_t
name|ravl_delete
parameter_list|(
name|root
parameter_list|,
name|data
parameter_list|,
name|fcmp
parameter_list|,
name|shorter
parameter_list|)
name|Avlnode
modifier|*
modifier|*
name|root
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|IFP
name|fcmp
decl_stmt|;
name|int
modifier|*
name|shorter
decl_stmt|;
block|{
name|int
name|shortersubtree
init|=
literal|0
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|caddr_t
name|savedata
decl_stmt|;
name|Avlnode
modifier|*
name|minnode
decl_stmt|,
modifier|*
name|savenode
decl_stmt|;
if|if
condition|(
operator|*
name|root
operator|==
name|NULLAVL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cmp
operator|=
call|(
modifier|*
name|fcmp
call|)
argument_list|(
name|data
argument_list|,
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_data
argument_list|)
expr_stmt|;
comment|/* found it! */
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|savenode
operator|=
operator|*
name|root
expr_stmt|;
name|savedata
operator|=
name|savenode
operator|->
name|avl_data
expr_stmt|;
comment|/* simple cases: no left child */
if|if
condition|(
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_left
operator|==
literal|0
condition|)
block|{
operator|*
name|root
operator|=
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_right
expr_stmt|;
operator|*
name|shorter
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|savenode
argument_list|)
expr_stmt|;
return|return
operator|(
name|savedata
operator|)
return|;
comment|/* no right child */
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_right
operator|==
literal|0
condition|)
block|{
operator|*
name|root
operator|=
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_left
expr_stmt|;
operator|*
name|shorter
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|savenode
argument_list|)
expr_stmt|;
return|return
operator|(
name|savedata
operator|)
return|;
block|}
comment|/*  		 * avl_getmin will return to us the smallest node greater 		 * than the one we are trying to delete.  deleting this node 		 * from the right subtree is guaranteed to end in one of the 		 * simple cases above. 		 */
name|minnode
operator|=
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_right
expr_stmt|;
while|while
condition|(
name|minnode
operator|->
name|avl_left
operator|!=
name|NULLAVL
condition|)
name|minnode
operator|=
name|minnode
operator|->
name|avl_left
expr_stmt|;
comment|/* swap the data */
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_data
operator|=
name|minnode
operator|->
name|avl_data
expr_stmt|;
name|minnode
operator|->
name|avl_data
operator|=
name|savedata
expr_stmt|;
name|savedata
operator|=
name|ravl_delete
argument_list|(
operator|&
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_right
argument_list|,
name|data
argument_list|,
name|fcmp
argument_list|,
operator|&
name|shortersubtree
argument_list|)
expr_stmt|;
if|if
condition|(
name|shortersubtree
condition|)
operator|*
name|shorter
operator|=
name|right_balance
argument_list|(
name|root
argument_list|)
expr_stmt|;
else|else
operator|*
name|shorter
operator|=
literal|0
expr_stmt|;
comment|/* go left */
block|}
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|savedata
operator|=
name|ravl_delete
argument_list|(
operator|&
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_left
argument_list|,
name|data
argument_list|,
name|fcmp
argument_list|,
operator|&
name|shortersubtree
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|shorter
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* left subtree shorter? */
if|if
condition|(
name|shortersubtree
condition|)
operator|*
name|shorter
operator|=
name|left_balance
argument_list|(
name|root
argument_list|)
expr_stmt|;
else|else
operator|*
name|shorter
operator|=
literal|0
expr_stmt|;
comment|/* go right */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|savedata
operator|=
name|ravl_delete
argument_list|(
operator|&
operator|(
operator|*
name|root
operator|)
operator|->
name|avl_right
argument_list|,
name|data
argument_list|,
name|fcmp
argument_list|,
operator|&
name|shortersubtree
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|shorter
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|shortersubtree
condition|)
operator|*
name|shorter
operator|=
name|right_balance
argument_list|(
name|root
argument_list|)
expr_stmt|;
else|else
operator|*
name|shorter
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|savedata
operator|)
return|;
block|}
end_function

begin_function
name|caddr_t
name|avl_delete
parameter_list|(
name|root
parameter_list|,
name|data
parameter_list|,
name|fcmp
parameter_list|)
name|Avlnode
modifier|*
modifier|*
name|root
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|IFP
name|fcmp
decl_stmt|;
block|{
name|int
name|shorter
decl_stmt|;
return|return
operator|(
name|ravl_delete
argument_list|(
name|root
argument_list|,
name|data
argument_list|,
name|fcmp
argument_list|,
operator|&
name|shorter
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|avl_inapply
argument_list|(
argument|root
argument_list|,
argument|fn
argument_list|,
argument|arg
argument_list|,
argument|stopflag
argument_list|)
end_macro

begin_decl_stmt
name|Avlnode
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|fn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stopflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|root
operator|==
literal|0
condition|)
return|return
operator|(
name|AVL_NOMORE
operator|)
return|;
if|if
condition|(
name|root
operator|->
name|avl_left
operator|!=
literal|0
condition|)
if|if
condition|(
name|avl_inapply
argument_list|(
name|root
operator|->
name|avl_left
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|,
name|stopflag
argument_list|)
operator|==
name|stopflag
condition|)
return|return
operator|(
name|stopflag
operator|)
return|;
if|if
condition|(
call|(
modifier|*
name|fn
call|)
argument_list|(
name|root
operator|->
name|avl_data
argument_list|,
name|arg
argument_list|)
operator|==
name|stopflag
condition|)
return|return
operator|(
name|stopflag
operator|)
return|;
if|if
condition|(
name|root
operator|->
name|avl_right
operator|==
literal|0
condition|)
return|return
operator|(
name|AVL_NOMORE
operator|)
return|;
else|else
return|return
operator|(
name|avl_inapply
argument_list|(
name|root
operator|->
name|avl_right
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|,
name|stopflag
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|avl_postapply
argument_list|(
argument|root
argument_list|,
argument|fn
argument_list|,
argument|arg
argument_list|,
argument|stopflag
argument_list|)
end_macro

begin_decl_stmt
name|Avlnode
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|fn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stopflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|root
operator|==
literal|0
condition|)
return|return
operator|(
name|AVL_NOMORE
operator|)
return|;
if|if
condition|(
name|root
operator|->
name|avl_left
operator|!=
literal|0
condition|)
if|if
condition|(
name|avl_postapply
argument_list|(
name|root
operator|->
name|avl_left
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|,
name|stopflag
argument_list|)
operator|==
name|stopflag
condition|)
return|return
operator|(
name|stopflag
operator|)
return|;
if|if
condition|(
name|root
operator|->
name|avl_right
operator|!=
literal|0
condition|)
if|if
condition|(
name|avl_postapply
argument_list|(
name|root
operator|->
name|avl_right
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|,
name|stopflag
argument_list|)
operator|==
name|stopflag
condition|)
return|return
operator|(
name|stopflag
operator|)
return|;
return|return
operator|(
call|(
modifier|*
name|fn
call|)
argument_list|(
name|root
operator|->
name|avl_data
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|avl_preapply
argument_list|(
argument|root
argument_list|,
argument|fn
argument_list|,
argument|arg
argument_list|,
argument|stopflag
argument_list|)
end_macro

begin_decl_stmt
name|Avlnode
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|fn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stopflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|root
operator|==
literal|0
condition|)
return|return
operator|(
name|AVL_NOMORE
operator|)
return|;
if|if
condition|(
call|(
modifier|*
name|fn
call|)
argument_list|(
name|root
operator|->
name|avl_data
argument_list|,
name|arg
argument_list|)
operator|==
name|stopflag
condition|)
return|return
operator|(
name|stopflag
operator|)
return|;
if|if
condition|(
name|root
operator|->
name|avl_left
operator|!=
literal|0
condition|)
if|if
condition|(
name|avl_preapply
argument_list|(
name|root
operator|->
name|avl_left
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|,
name|stopflag
argument_list|)
operator|==
name|stopflag
condition|)
return|return
operator|(
name|stopflag
operator|)
return|;
if|if
condition|(
name|root
operator|->
name|avl_right
operator|==
literal|0
condition|)
return|return
operator|(
name|AVL_NOMORE
operator|)
return|;
else|else
return|return
operator|(
name|avl_preapply
argument_list|(
name|root
operator|->
name|avl_right
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|,
name|stopflag
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * avl_apply -- avl tree root is traversed, function fn is called with  * arguments arg and the data portion of each node.  if fn returns stopflag,  * the traversal is cut short, otherwise it continues.  Do not use -6 as  * a stopflag.  */
end_comment

begin_macro
name|avl_apply
argument_list|(
argument|root
argument_list|,
argument|fn
argument_list|,
argument|arg
argument_list|,
argument|stopflag
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|Avlnode
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|fn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stopflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|AVL_INORDER
case|:
return|return
operator|(
name|avl_inapply
argument_list|(
name|root
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|,
name|stopflag
argument_list|)
operator|)
return|;
case|case
name|AVL_PREORDER
case|:
return|return
operator|(
name|avl_preapply
argument_list|(
name|root
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|,
name|stopflag
argument_list|)
operator|)
return|;
case|case
name|AVL_POSTORDER
case|:
return|return
operator|(
name|avl_postapply
argument_list|(
name|root
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|,
name|stopflag
argument_list|)
operator|)
return|;
default|default:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Invalid traversal type %d"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * avl_prefixapply - traverse avl tree root, applying function fprefix  * to any nodes that match.  fcmp is called with data as its first arg  * and the current node's data as its second arg.  it should return  * 0 if they match,< 0 if data is less, and> 0 if data is greater.  * the idea is to efficiently find all nodes that are prefixes of  * some key...  */
end_comment

begin_macro
name|avl_prefixapply
argument_list|(
argument|root
argument_list|,
argument|data
argument_list|,
argument|fmatch
argument_list|,
argument|marg
argument_list|,
argument|fcmp
argument_list|,
argument|carg
argument_list|)
end_macro

begin_decl_stmt
name|Avlnode
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|fmatch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|marg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|fcmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|carg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|0
condition|)
return|return;
name|cmp
operator|=
call|(
modifier|*
name|fcmp
call|)
argument_list|(
name|data
argument_list|,
name|root
operator|->
name|avl_data
argument_list|,
name|carg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|fmatch
call|)
argument_list|(
name|root
operator|->
name|avl_data
argument_list|,
name|marg
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|avl_left
operator|!=
literal|0
condition|)
name|avl_prefixapply
argument_list|(
name|root
operator|->
name|avl_left
argument_list|,
name|data
argument_list|,
name|fmatch
argument_list|,
name|marg
argument_list|,
name|fcmp
argument_list|,
name|carg
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|avl_right
operator|!=
literal|0
condition|)
name|avl_prefixapply
argument_list|(
name|root
operator|->
name|avl_right
argument_list|,
name|data
argument_list|,
name|fmatch
argument_list|,
name|marg
argument_list|,
name|fcmp
argument_list|,
name|carg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|root
operator|->
name|avl_left
operator|!=
literal|0
condition|)
name|avl_prefixapply
argument_list|(
name|root
operator|->
name|avl_left
argument_list|,
name|data
argument_list|,
name|fmatch
argument_list|,
name|marg
argument_list|,
name|fcmp
argument_list|,
name|carg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|root
operator|->
name|avl_right
operator|!=
literal|0
condition|)
name|avl_prefixapply
argument_list|(
name|root
operator|->
name|avl_right
argument_list|,
name|data
argument_list|,
name|fmatch
argument_list|,
name|marg
argument_list|,
name|fcmp
argument_list|,
name|carg
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_comment
comment|/*  * avl_free -- traverse avltree root, freeing the memory it is using.  * the dfree() is called to free the data portion of each node.  The  * number of items actually freed is returned.  */
end_comment

begin_macro
name|avl_free
argument_list|(
argument|root
argument_list|,
argument|dfree
argument_list|)
end_macro

begin_decl_stmt
name|Avlnode
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|dfree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nleft
decl_stmt|,
name|nright
decl_stmt|;
if|if
condition|(
name|root
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nleft
operator|=
name|nright
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|avl_left
operator|!=
literal|0
condition|)
name|nleft
operator|=
name|avl_free
argument_list|(
name|root
operator|->
name|avl_left
argument_list|,
name|dfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|avl_right
operator|!=
literal|0
condition|)
name|nright
operator|=
name|avl_free
argument_list|(
name|root
operator|->
name|avl_right
argument_list|,
name|dfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfree
condition|)
call|(
modifier|*
name|dfree
call|)
argument_list|(
name|root
operator|->
name|avl_data
argument_list|)
expr_stmt|;
return|return
operator|(
name|nleft
operator|+
name|nright
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * avl_find -- search avltree root for a node with data data.  the function  * cmp is used to compare things.  it is called with data as its first arg   * and the current node data as its second.  it should return 0 if they match,  *< 0 if arg1 is less than arg2 and> 0 if arg1 is greater than arg2.  */
end_comment

begin_function
name|caddr_t
name|avl_find
parameter_list|(
name|root
parameter_list|,
name|data
parameter_list|,
name|fcmp
parameter_list|)
name|Avlnode
modifier|*
name|root
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|IFP
name|fcmp
decl_stmt|;
block|{
name|int
name|cmp
decl_stmt|;
while|while
condition|(
name|root
operator|!=
literal|0
operator|&&
operator|(
name|cmp
operator|=
call|(
modifier|*
name|fcmp
call|)
argument_list|(
name|data
argument_list|,
name|root
operator|->
name|avl_data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|root
operator|=
name|root
operator|->
name|avl_left
expr_stmt|;
else|else
name|root
operator|=
name|root
operator|->
name|avl_right
expr_stmt|;
block|}
return|return
operator|(
name|root
condition|?
name|root
operator|->
name|avl_data
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|caddr_t
modifier|*
name|avl_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|avl_maxlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|avl_nextlist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AVL_GRABSIZE
value|100
end_define

begin_comment
comment|/* ARGSUSED 1 */
end_comment

begin_expr_stmt
specifier|static
name|avl_buildlist
argument_list|(
argument|data
argument_list|,
argument|arg
argument_list|)
name|caddr_t
name|data
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|slots
decl_stmt|;
if|if
condition|(
name|avl_list
operator|==
operator|(
name|caddr_t
operator|*
operator|)
literal|0
condition|)
block|{
name|avl_list
operator|=
operator|(
name|caddr_t
operator|*
operator|)
name|malloc
argument_list|(
name|AVL_GRABSIZE
operator|*
sizeof|sizeof
argument_list|(
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|slots
operator|=
name|AVL_GRABSIZE
expr_stmt|;
name|avl_maxlist
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|avl_maxlist
operator|==
name|slots
condition|)
block|{
name|slots
operator|+=
name|AVL_GRABSIZE
expr_stmt|;
name|avl_list
operator|=
operator|(
name|caddr_t
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|avl_list
argument_list|,
operator|(
name|unsigned
operator|)
name|slots
operator|*
sizeof|sizeof
argument_list|(
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|avl_list
index|[
name|avl_maxlist
operator|++
index|]
operator|=
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|caddr_t
name|avl_getfirst
parameter_list|(
name|root
parameter_list|)
name|Avlnode
modifier|*
name|root
decl_stmt|;
block|{
if|if
condition|(
name|avl_list
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|avl_list
argument_list|)
expr_stmt|;
name|avl_list
operator|=
operator|(
name|caddr_t
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|avl_maxlist
operator|=
literal|0
expr_stmt|;
name|avl_nextlist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|root
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|avl_apply
argument_list|(
name|root
argument_list|,
name|avl_buildlist
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|AVL_INORDER
argument_list|)
expr_stmt|;
return|return
operator|(
name|avl_list
index|[
name|avl_nextlist
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_function
name|caddr_t
name|avl_getnext
parameter_list|()
block|{
if|if
condition|(
name|avl_list
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|avl_nextlist
operator|==
name|avl_maxlist
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|avl_list
argument_list|)
expr_stmt|;
name|avl_list
operator|=
operator|(
name|caddr_t
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|avl_list
index|[
name|avl_nextlist
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_macro
name|avl_dup_error
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
end_block

end_unit

