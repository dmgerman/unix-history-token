begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftp_lib.c - FTP subroutines */
end_comment

begin_comment
comment|/*   * $Header: /f/osi/ftam-ftp/RCS/ftp_lib.c,v 7.2 91/02/22 09:23:29 mrose Interim $  *  *  * $Log:	ftp_lib.c,v $  * Revision 7.2  91/02/22  09:23:29  mrose  * Interim 6.8  *   * Revision 7.1  90/12/23  18:39:51  mrose  * update  *   * Revision 7.0  89/11/23  21:55:06  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *	The MITRE Corporation (hereafter MITRE) makes this software available   *	on an "as is" basis.  No guarantees, either explicit or implied, are   *	given as to performance or suitability.    *  */
end_comment

begin_comment
comment|/*  * Library interface routines.  Design of routines is specific for  * FTAM.  */
end_comment

begin_comment
comment|/*  * FTP User Program -- Command Routines.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<arpa/ftp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|"ftp_var.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"logger.h"
end_include

begin_function_decl
name|void
name|advise
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NULLCP
end_ifndef

begin_define
define|#
directive|define
name|NULLCP
value|((char *) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FTP_PORT
value|21
end_define

begin_comment
comment|/* Virtual filesystem file types */
end_comment

begin_define
define|#
directive|define
name|VFS_UBF
value|0
end_define

begin_comment
comment|/* offset to FTAM-3 */
end_comment

begin_define
define|#
directive|define
name|VFS_UTF
value|1
end_define

begin_comment
comment|/*  ..       FTAM-1 */
end_comment

begin_define
define|#
directive|define
name|VFS_FDF
value|2
end_define

begin_comment
comment|/*  ..       NBS-9 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOTOK
end_ifndef

begin_define
define|#
directive|define
name|NOTOK
value|(-1)
end_define

begin_define
define|#
directive|define
name|OK
value|0
end_define

begin_define
define|#
directive|define
name|DONE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTOK */
end_comment

begin_comment
comment|/*  * ftp_login: establish command connection with remote host  * then execute login process.  */
end_comment

begin_function
name|int
name|ftp_login
parameter_list|(
name|host
parameter_list|,
name|user
parameter_list|,
name|passwd
parameter_list|,
name|acct
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|,
decl|*
name|user
decl_stmt|,
modifier|*
name|passwd
decl_stmt|,
modifier|*
name|acct
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|connected
condition|)
return|return
name|NOTOK
return|;
comment|/* already connected */
name|ftp_init
argument_list|()
expr_stmt|;
comment|/* initialize control state structures */
if|if
condition|(
name|hookup
argument_list|(
name|host
argument_list|,
name|FTP_PORT
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
comment|/* execute login process */
if|if
condition|(
name|login
argument_list|(
name|user
argument_list|,
name|passwd
argument_list|,
name|acct
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*  * ftp_quit: send quit command and shutdown communications link.  */
end_comment

begin_function
name|int
name|ftp_quit
parameter_list|()
block|{
specifier|extern
name|FILE
modifier|*
name|cout
decl_stmt|;
specifier|extern
name|int
name|data
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|OK
return|;
name|n
operator|=
name|command
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cout
argument_list|)
expr_stmt|;
name|connected
operator|=
literal|0
expr_stmt|;
name|data
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|n
operator|==
name|COMPLETE
condition|)
return|return
name|OK
return|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*  * ftp_abort: send abort command  */
end_comment

begin_function
name|int
name|ftp_abort
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|NOTOK
return|;
name|n
operator|=
name|command
argument_list|(
literal|"ABOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|COMPLETE
condition|)
return|return
name|OK
return|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*  * ftp_exist: perform NLST command and count number of records in data  * stream.  If 0 or reply code is failure, file does not exist.  If 1  * or more and reply code is COMPLETE, file exists.  ftp_directory is  * a global flag.  It is set if more than 1 record in data stream and  * reply code is COMPLETE.  Yes this is hokey but it works for all the  * test systems and is faster than trying a case sensitive, then case  * insensitive scan then falling back on record counts in the case of  * directories.  */
end_comment

begin_function
name|int
name|ftp_exist
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|count
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fdopen
argument_list|()
decl_stmt|;
name|char
name|lineX
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|ftp_directory
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|NOTOK
return|;
comment|/* set ascii transfer */
if|if
condition|(
name|ftp_type
argument_list|(
name|VFS_FDF
argument_list|)
operator|!=
name|OK
condition|)
return|return
name|NOTOK
return|;
comment|/* begin list transfer */
if|if
condition|(
operator|(
name|fd
operator|=
name|recvrequest
argument_list|(
literal|"NLST"
argument_list|,
name|filename
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getreply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ftp_error
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/* count number of records (lines) in data transfer */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|lineX
argument_list|,
name|BUFSIZ
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|;
name|count
operator|++
control|)
empty_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* transfer complete reply */
name|n
operator|=
name|getreply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|COMPLETE
condition|)
comment|/* directory command not accepted */
return|return
name|NOTOK
return|;
comment|/* if more than one record in reply, guess that it is a directory */
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|ftp_directory
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"directory found"
argument_list|)
expr_stmt|;
block|}
comment|/* if any records in reply, assume that file existed */
if|if
condition|(
name|count
condition|)
return|return
name|OK
return|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/* Basicly set transfer type to ascii and issue NLST command  * and returning the socket descriptor for the data stream.  */
end_comment

begin_function
name|int
name|ftp_ls
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|NOTOK
return|;
comment|/* set ascii transfer */
if|if
condition|(
name|ftp_type
argument_list|(
name|VFS_FDF
argument_list|)
operator|!=
name|OK
condition|)
return|return
name|NOTOK
return|;
comment|/* begin list transfer */
if|if
condition|(
operator|(
name|fd
operator|=
name|recvrequest
argument_list|(
literal|"NLST"
argument_list|,
name|dir
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ftp_delete
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|NOTOK
return|;
comment|/* send delete command, return OK if complete, NOTOK otherwise */
if|if
condition|(
name|command
argument_list|(
literal|"DELE %s"
argument_list|,
name|file
argument_list|)
operator|==
name|COMPLETE
condition|)
return|return
name|OK
return|;
comment|/* Hummm, try directory delete */
if|if
condition|(
name|command
argument_list|(
literal|"XRMD %s"
argument_list|,
name|file
argument_list|)
operator|==
name|COMPLETE
condition|)
return|return
name|OK
return|;
comment|/* No dice, return error */
return|return
name|NOTOK
return|;
block|}
end_function

begin_function
name|int
name|ftp_mkdir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|NOTOK
return|;
comment|/* send MKDIR command, return OK if complete, NOTOK otherwise */
if|if
condition|(
name|command
argument_list|(
literal|"XMKD %s"
argument_list|,
name|dir
argument_list|)
operator|==
name|COMPLETE
condition|)
return|return
name|OK
return|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_function
name|int
name|ftp_rename
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|NOTOK
return|;
comment|/* send RNFR command followed by RNTO if successful */
if|if
condition|(
operator|(
name|n
operator|=
name|command
argument_list|(
literal|"RNFR %s"
argument_list|,
name|from
argument_list|)
operator|)
operator|==
name|CONTINUE
condition|)
name|n
operator|=
name|command
argument_list|(
literal|"RNTO %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|COMPLETE
condition|)
return|return
name|OK
return|;
return|return
name|NOTOK
return|;
block|}
end_block

begin_function
name|int
name|ftp_write
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|NOTOK
return|;
return|return
operator|(
name|sendrequest
argument_list|(
literal|"STOR"
argument_list|,
name|file
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ftp_append
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|NOTOK
return|;
return|return
operator|(
name|sendrequest
argument_list|(
literal|"APPE"
argument_list|,
name|file
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ftp_read
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|NOTOK
return|;
return|return
operator|(
name|recvrequest
argument_list|(
literal|"RETR"
argument_list|,
name|file
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ftp_type
parameter_list|(
name|modeX
parameter_list|)
name|int
name|modeX
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|char
name|cmd
index|[
literal|10
index|]
decl_stmt|;
comment|/* The current transfer type is stored in ``type''. 	 * The TYPE command is issued if the type changes.          * (this cuts down on the number of FTP transactions).          */
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|NOTOK
return|;
name|n
operator|=
name|COMPLETE
expr_stmt|;
switch|switch
condition|(
name|modeX
condition|)
block|{
comment|/* unstructured binary file */
case|case
name|VFS_UBF
case|:
if|if
condition|(
name|type
operator|==
name|TYPE_L
condition|)
break|break;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"TYPE L %s"
argument_list|,
name|bytename
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_L
expr_stmt|;
name|n
operator|=
name|command
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* unstructured text file */
case|case
name|VFS_UTF
case|:
comment|/* directory file */
case|case
name|VFS_FDF
case|:
default|default:
if|if
condition|(
name|type
operator|==
name|TYPE_A
condition|)
break|break;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"TYPE A"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_A
expr_stmt|;
name|n
operator|=
name|command
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|COMPLETE
condition|)
return|return
name|OK
return|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_function
name|int
name|ftp_reply
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
comment|/* process an FTP response */
name|n
operator|=
name|getreply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|COMPLETE
condition|)
return|return
name|OK
return|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_function
name|int
name|ftp_create
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|connected
condition|)
return|return
name|NOTOK
return|;
comment|/* open file */
name|fd
operator|=
name|sendrequest
argument_list|(
literal|"STOR"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
comment|/* close file (create empty file) */
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|n
operator|=
name|getreply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|COMPLETE
condition|)
return|return
name|OK
return|;
return|return
name|NOTOK
return|;
block|}
end_function

end_unit

