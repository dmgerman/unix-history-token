begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/pepsy/RCS/main.c,v 7.4 91/02/22 09:49:05 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/pepsy/RCS/main.c,v 7.4 91/02/22 09:49:05 mrose Interim $  *  *  * $Log:	main.c,v $  * Revision 7.4  91/02/22  09:49:05  mrose  * Interim 6.8  *   * Revision 7.3  90/12/23  17:24:34  mrose  * patches  *   * Revision 7.2  90/11/04  19:18:40  mrose  * update  *   * Revision 7.1  90/10/17  11:59:49  mrose  * sync  *   * Revision 7.0  90/07/01  19:54:21  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PEPSY_REALS
end_ifdef

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_define
define|#
directive|define
name|F_SMALL
value|(1.0e-10)
end_define

begin_comment
comment|/* How accurate should reals agree */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"psap.h"
end_include

begin_include
include|#
directive|include
file|"T1-types.h"
end_include

begin_include
include|#
directive|include
file|"T2-types.h"
end_include

begin_include
include|#
directive|include
file|"T3-types.h"
end_include

begin_include
include|#
directive|include
file|"test_table.h"
end_include

begin_comment
comment|/* compactly generate the new item of data */
end_comment

begin_define
define|#
directive|define
name|new
parameter_list|(
name|x
parameter_list|)
value|((x *)calloc(1, sizeof (x)))
end_define

begin_define
define|#
directive|define
name|NULLQB
value|(struct qbuf *)0
end_define

begin_function_decl
name|char
modifier|*
name|fill
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|idname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|clname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|prntbits
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pclen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|prntos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|prntstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|print_pe
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|modtyp
name|_ZBIT_1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|bitstr2strb
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|PE
name|mkpelist
argument_list|()
decl_stmt|,
name|mkpe
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|OID
name|mkoid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|type_UNIV_EXTERNAL
modifier|*
name|mkext
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|rep_elem
modifier|*
name|mkrep_elem
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|rep_int
modifier|*
name|mkrep_int
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|t_test
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Iteration of the test */
end_comment

begin_define
define|#
directive|define
name|NullParm
value|((char	*) 0)
end_define

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|succ
decl_stmt|,
name|fail
decl_stmt|;
name|succ
operator|=
name|fail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
name|MAXTCASE
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|t_case
index|[
name|i
index|]
operator|.
name|tst_entry
operator|<
literal|0
condition|)
continue|continue;
for|for
control|(
name|t_test
operator|=
name|t_case
index|[
name|i
index|]
operator|.
name|tst_tests
init|;
name|t_test
operator|>
literal|0
condition|;
name|t_test
operator|--
control|)
block|{
if|if
condition|(
name|ed_tst
argument_list|(
name|i
argument_list|)
operator|!=
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Failed\n"
argument_list|)
expr_stmt|;
name|fail
operator|++
expr_stmt|;
block|}
else|else
name|succ
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fail
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Failed\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Total %d  = %d successes %d failures\n"
argument_list|,
name|fail
operator|+
name|succ
argument_list|,
name|succ
argument_list|,
name|fail
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PEP_TEST
name|tailorfree
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|i
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|t_test
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Test %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed_tst
argument_list|(
name|i
argument_list|)
operator|!=
name|OK
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Failed\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PEP_TEST
name|tailorfree
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|fail
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a test of encoding/decoding on type number tynum  */
end_comment

begin_macro
name|ed_tst
argument_list|(
argument|tynum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|tynum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PE
name|pe
decl_stmt|;
name|char
modifier|*
name|parm1
decl_stmt|,
modifier|*
name|parm2
decl_stmt|;
if|if
condition|(
name|tynum
operator|<
literal|0
operator|||
name|tynum
operator|>=
name|MAXTCASE
condition|)
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"ed_tst illegal type %d\n"
argument_list|,
name|tynum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parm1
operator|=
name|fill
argument_list|(
name|tynum
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"calloc did not work\n"
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|encode
parameter_list|(
name|tynum
parameter_list|,
name|x
parameter_list|,
name|parm
parameter_list|)
define|\
value|enc_f(t_case[tynum].tst_entry,&_ZT1_mod, (x), 1, 0, NULLCP, (parm))
if|if
condition|(
name|encode
argument_list|(
name|tynum
argument_list|,
operator|&
name|pe
argument_list|,
name|parm1
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"encode:failed on %s: %s\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
define|#
directive|define
name|decode
parameter_list|(
name|tynum
parameter_list|,
name|x
parameter_list|,
name|parm
parameter_list|)
define|\
value|dec_f(t_case[tynum].tst_entry,&_ZT1_mod, (x), 1, (int *) 0, (char **)NULL, (parm))
if|if
condition|(
name|decode
argument_list|(
name|tynum
argument_list|,
name|pe
argument_list|,
operator|&
name|parm2
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"decode:failed on %s: %s\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|tcmp
argument_list|(
name|tynum
argument_list|,
name|parm1
argument_list|,
name|parm2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: not transfered properly\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|#
directive|if
name|PRNT
define|#
directive|define
name|print
parameter_list|(
name|tynum
parameter_list|,
name|x
parameter_list|)
define|\
value|prnt_f(t_case[tynum].tst_entry,&_ZT1_mod, (x), 1, (int *) 0, (char **)0)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n\"%s\" t_test = %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|t_test
argument_list|)
expr_stmt|;
if|if
condition|(
name|print
argument_list|(
name|tynum
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Print:failed on %s: %s\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
define|#
directive|define
name|fre_space
parameter_list|(
name|tynum
parameter_list|,
name|parm
parameter_list|)
define|\
value|fre_obj(parm, _ZT1_mod.md_dtab[t_case[tynum].tst_entry],&_ZT1_mod, 1)
if|if
condition|(
name|fre_space
argument_list|(
name|tynum
argument_list|,
name|parm1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
if|if
condition|(
name|fre_space
argument_list|(
name|tynum
argument_list|,
name|parm2
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*SUPPRESS 218*/
end_comment

begin_comment
comment|/*  * fill in some test data for the given type  */
end_comment

begin_function
name|char
modifier|*
name|fill
parameter_list|(
name|tynum
parameter_list|)
name|int
name|tynum
decl_stmt|;
block|{
name|char
modifier|*
name|parm
decl_stmt|;
specifier|static
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|parm
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"calloc did not work\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|tynum
condition|)
block|{
case|case
name|TY_MPDU
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_MPDU *)parm)
if|if
condition|(
operator|(
name|Xparm
operator|->
name|a__seq
operator|=
name|new
argument_list|(
expr|struct
name|element_T1_1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"calloc did not work\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|Xparm
operator|->
name|a__seq
operator|->
name|fred
operator|=
literal|10
expr_stmt|;
name|Xparm
operator|->
name|a__seq
operator|->
name|george
operator|=
literal|1
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_EMBEDDED
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Embedded *)parm)
name|Xparm
operator|->
name|anMPDU
operator|=
operator|(
expr|struct
name|type_T1_MPDU
operator|*
operator|)
name|fill
argument_list|(
name|TY_MPDU
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|ei
operator|=
literal|6966
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_STRINGS
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Strings *)parm)
name|Xparm
operator|->
name|ostring
operator|=
name|str2qb
argument_list|(
literal|"12\376\0\377a6"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|bstring
operator|=
name|strb2bitstr
argument_list|(
literal|"\270\017\010\020\040\100"
argument_list|,
literal|50
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|nstring
operator|=
name|str2qb
argument_list|(
literal|"123456"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|pstring
operator|=
name|str2qb
argument_list|(
literal|"hello, world"
argument_list|,
literal|12
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|tstring
operator|=
name|str2qb
argument_list|(
literal|"teletex"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t61string
operator|=
name|str2qb
argument_list|(
literal|"T.61"
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|vstring
operator|=
name|str2qb
argument_list|(
literal|"visible"
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|vis__string
operator|=
name|str2qb
argument_list|(
literal|"visible again"
argument_list|,
literal|13
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|i646string
operator|=
name|str2qb
argument_list|(
literal|"who knows what this is"
argument_list|,
literal|22
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|ia5string
operator|=
name|str2qb
argument_list|(
literal|"This is ASCII\n\r"
argument_list|,
literal|15
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|graphstring
operator|=
name|str2qb
argument_list|(
literal|"This is a graphic string"
argument_list|,
literal|24
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|genstring
operator|=
name|str2qb
argument_list|(
literal|"This is a general string"
argument_list|,
literal|24
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_EMB_STRINGS
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Emb__Strings *)parm)
name|Xparm
operator|->
name|atest
operator|=
literal|2001
expr_stmt|;
name|Xparm
operator|->
name|ctest
operator|=
name|strb2bitstr
argument_list|(
literal|"\03\010\252\125"
argument_list|,
literal|24
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|btest
operator|=
name|str2qb
argument_list|(
literal|"Good bye"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|big__test
operator|=
operator|(
expr|struct
name|type_T1_Strings
operator|*
operator|)
name|fill
argument_list|(
name|TY_STRINGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Xparm
operator|->
name|emb__test
operator|=
name|new
argument_list|(
expr|struct
name|element_T1_0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"calloc did not work\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|Xparm
operator|->
name|emb__test
operator|->
name|em__int
operator|=
operator|-
literal|101
expr_stmt|;
name|Xparm
operator|->
name|emb__test
operator|->
name|em__oct
operator|=
name|str2qb
argument_list|(
literal|"Embedded octet string"
argument_list|,
literal|21
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|emb__test
operator|->
name|em__bit
operator|=
name|strb2bitstr
argument_list|(
literal|"\377\252\125\370\01"
argument_list|,
literal|40
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_IMPLICIT
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Impl__Tags *)parm)
name|Xparm
operator|->
name|i__impl
operator|=
operator|-
literal|1
expr_stmt|;
name|Xparm
operator|->
name|o__impl
operator|=
name|str2qb
argument_list|(
literal|"I'm an implicit tagged octet string"
argument_list|,
literal|36
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|b__impl
operator|=
name|strb2bitstr
argument_list|(
literal|"\0\0\01\230\01"
argument_list|,
literal|40
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|f__impl
operator|=
literal|0xff
expr_stmt|;
comment|/* True */
name|Xparm
operator|->
name|obj__impl
operator|=
operator|(
expr|struct
name|type_T1_Emb__Strings
operator|*
operator|)
name|fill
argument_list|(
name|TY_EMB_STRINGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Xparm
operator|->
name|i__emb__test
operator|=
name|new
argument_list|(
expr|struct
name|element_T1_2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"calloc did not work\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|Xparm
operator|->
name|i__emb__test
operator|->
name|i__em__int
operator|=
operator|-
literal|101
expr_stmt|;
name|Xparm
operator|->
name|i__emb__test
operator|->
name|i__em__oct
operator|=
name|str2qb
argument_list|(
literal|"Implicit Embedded"
argument_list|,
literal|18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|i__emb__test
operator|->
name|i__em__bit
operator|=
name|strb2bitstr
argument_list|(
literal|"\200\200\200\200"
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|Xparm
break|break;
case|case
name|TY_EXPLICIT
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Expl__Tags *)parm)
name|Xparm
operator|->
name|i__expl
operator|=
literal|35051
expr_stmt|;
name|Xparm
operator|->
name|o__expl
operator|=
name|str2qb
argument_list|(
literal|"explicit tagged octet string"
argument_list|,
literal|28
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|b__expl
operator|=
name|strb2bitstr
argument_list|(
literal|"\070\070\070\077"
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|f__expl
operator|=
literal|0xf0
expr_stmt|;
comment|/* True */
name|Xparm
operator|->
name|obj__expl
operator|=
operator|(
expr|struct
name|type_T1_Emb__Strings
operator|*
operator|)
name|fill
argument_list|(
name|TY_EMB_STRINGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Xparm
operator|->
name|i__exp__test
operator|=
name|new
argument_list|(
expr|struct
name|element_T1_3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"calloc did not work\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|Xparm
operator|->
name|i__exp__test
operator|->
name|i__ex__int
operator|=
operator|-
literal|9
expr_stmt|;
name|Xparm
operator|->
name|i__exp__test
operator|->
name|i__ex__oct
operator|=
name|str2qb
argument_list|(
literal|"Explicit Embedded"
argument_list|,
literal|18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|i__exp__test
operator|->
name|i__ex__bit
operator|=
name|strb2bitstr
argument_list|(
literal|"\03\03\03\03\277"
argument_list|,
literal|40
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|Xparm
break|break;
case|case
name|TY_SEQOF
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Seqof__Test *)parm)
name|count
operator|=
literal|2
expr_stmt|;
name|Xparm
operator|->
name|sqof__test1
operator|=
operator|(
expr|struct
name|element_T1_4
operator|*
operator|)
name|fill
argument_list|(
name|TY_ELEMENT4
argument_list|)
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
name|Xparm
operator|->
name|stof__test1
operator|=
operator|(
expr|struct
name|member_T1_2
operator|*
operator|)
name|fill
argument_list|(
name|TY_MEMBER2
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|i__test1
operator|=
literal|33
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
name|Xparm
operator|->
name|sqof__test2
operator|=
operator|(
expr|struct
name|element_T1_6
operator|*
operator|)
name|fill
argument_list|(
name|TY_ELEMENT6
argument_list|)
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
name|Xparm
operator|->
name|stof__test2
operator|=
operator|(
expr|struct
name|member_T1_4
operator|*
operator|)
name|fill
argument_list|(
name|TY_MEMBER4
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|i__test2
operator|=
literal|99
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_ELEMENT4
case|:
define|#
directive|define
name|Xparm
value|((struct element_T1_4 *)parm)
name|Xparm
operator|->
name|element_T1_5
operator|=
operator|(
expr|struct
name|type_T1_Expl__Tags
operator|*
operator|)
name|fill
argument_list|(
name|TY_EXPLICIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|Xparm
operator|->
name|next
operator|=
operator|(
expr|struct
name|element_T1_4
operator|*
operator|)
name|fill
argument_list|(
name|TY_ELEMENT4
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_MEMBER2
case|:
define|#
directive|define
name|Xparm
value|((struct member_T1_2 *)parm)
name|Xparm
operator|->
name|member_T1_3
operator|=
operator|(
expr|struct
name|type_T1_Expl__Tags
operator|*
operator|)
name|fill
argument_list|(
name|TY_EXPLICIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|Xparm
operator|->
name|next
operator|=
operator|(
expr|struct
name|member_T1_2
operator|*
operator|)
name|fill
argument_list|(
name|TY_MEMBER2
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_ELEMENT6
case|:
define|#
directive|define
name|Xparm
value|((struct element_T1_6 *)parm)
name|Xparm
operator|->
name|element_T1_7
operator|=
operator|(
expr|struct
name|element_T1_8
operator|*
operator|)
name|fill
argument_list|(
name|TY_ELEMENT8
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|Xparm
operator|->
name|next
operator|=
operator|(
expr|struct
name|element_T1_6
operator|*
operator|)
name|fill
argument_list|(
name|TY_ELEMENT6
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_ELEMENT8
case|:
define|#
directive|define
name|Xparm
value|((struct element_T1_8 *)parm)
name|Xparm
operator|->
name|sqof__in
operator|=
operator|(
expr|struct
name|type_T1_Expl__Tags
operator|*
operator|)
name|fill
argument_list|(
name|TY_EXPLICIT
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|sqof__i
operator|=
literal|212121
expr_stmt|;
name|Xparm
operator|->
name|sqof__o
operator|=
name|str2qb
argument_list|(
literal|"Element8 Embedded"
argument_list|,
literal|18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_MEMBER4
case|:
define|#
directive|define
name|Xparm
value|((struct member_T1_4 *)parm)
name|Xparm
operator|->
name|member_T1_5
operator|=
operator|(
expr|struct
name|element_T1_9
operator|*
operator|)
name|fill
argument_list|(
name|TY_ELEMENT9
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|Xparm
operator|->
name|next
operator|=
operator|(
expr|struct
name|member_T1_4
operator|*
operator|)
name|fill
argument_list|(
name|TY_MEMBER4
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_ELEMENT9
case|:
define|#
directive|define
name|Xparm
value|((struct element_T1_9 *)parm)
name|Xparm
operator|->
name|stof__in
operator|=
operator|(
expr|struct
name|type_T1_Expl__Tags
operator|*
operator|)
name|fill
argument_list|(
name|TY_EXPLICIT
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|stof__i
operator|=
operator|-
literal|12345
expr_stmt|;
name|Xparm
operator|->
name|stof__o
operator|=
name|str2qb
argument_list|(
literal|"XYZabcde Embedded"
argument_list|,
literal|18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_CHOICE
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Choice__Test *)parm)
name|Xparm
operator|->
name|c1
operator|=
operator|(
expr|struct
name|choice_T1_0
operator|*
operator|)
name|fill
argument_list|(
name|TY_CHOICE0
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|c2
operator|=
operator|(
expr|struct
name|choice_T1_1
operator|*
operator|)
name|fill
argument_list|(
name|TY_CHOICE1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|c3
operator|=
operator|(
expr|struct
name|choice_T1_2
operator|*
operator|)
name|fill
argument_list|(
name|TY_CHOICE2
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|c4
operator|=
operator|(
expr|struct
name|element_T1_11
operator|*
operator|)
name|fill
argument_list|(
name|TY_ELEMENT11
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_CHOICE0
case|:
define|#
directive|define
name|Xparm
value|((struct choice_T1_0 *)parm)
switch|switch
condition|(
name|Xparm
operator|->
name|offset
operator|=
operator|(
name|t_test
operator|+
literal|10
operator|)
operator|%
name|choice_T1_0_obj__c1
operator|+
literal|1
condition|)
block|{
case|case
name|choice_T1_0_i__c1
case|:
name|Xparm
operator|->
name|un
operator|.
name|i__c1
operator|=
literal|10101
expr_stmt|;
break|break;
case|case
name|choice_T1_0_o__c1
case|:
name|Xparm
operator|->
name|un
operator|.
name|o__c1
operator|=
name|str2qb
argument_list|(
literal|"Andrew Worsley!!!"
argument_list|,
literal|18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_T1_0_b__c1
case|:
name|Xparm
operator|->
name|un
operator|.
name|b__c1
operator|=
name|strb2bitstr
argument_list|(
literal|"\02\02\02\07\077"
argument_list|,
literal|40
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_T1_0_f__c1
case|:
name|Xparm
operator|->
name|un
operator|.
name|f__c1
operator|=
literal|0x11
expr_stmt|;
break|break;
case|case
name|choice_T1_0_obj__c1
case|:
name|Xparm
operator|->
name|un
operator|.
name|obj__c1
operator|=
operator|(
expr|struct
name|type_T1_Emb__Strings
operator|*
operator|)
name|fill
argument_list|(
name|TY_EMB_STRINGS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"TY_CHOICE0:illegal offset %d\n"
argument_list|,
name|Xparm
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_CHOICE1
case|:
define|#
directive|define
name|Xparm
value|((struct choice_T1_1 *)parm)
switch|switch
condition|(
name|Xparm
operator|->
name|offset
operator|=
operator|(
name|t_test
operator|+
literal|11
operator|)
operator|%
name|choice_T1_1_obj__c2
operator|+
literal|1
condition|)
block|{
case|case
name|choice_T1_1_i__c2
case|:
name|Xparm
operator|->
name|un
operator|.
name|i__c2
operator|=
literal|1212
expr_stmt|;
break|break;
case|case
name|choice_T1_1_o__c2
case|:
name|Xparm
operator|->
name|un
operator|.
name|o__c2
operator|=
name|str2qb
argument_list|(
literal|"Richard Worsley!!"
argument_list|,
literal|18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_T1_1_b__c2
case|:
name|Xparm
operator|->
name|un
operator|.
name|b__c2
operator|=
name|strb2bitstr
argument_list|(
literal|"\02\01\01\07\077"
argument_list|,
literal|40
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_T1_1_f__c2
case|:
name|Xparm
operator|->
name|un
operator|.
name|f__c2
operator|=
literal|0x12
expr_stmt|;
break|break;
case|case
name|choice_T1_1_obj__c2
case|:
name|Xparm
operator|->
name|un
operator|.
name|obj__c2
operator|=
operator|(
expr|struct
name|type_T1_Emb__Strings
operator|*
operator|)
name|fill
argument_list|(
name|TY_EMB_STRINGS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"TY_CHOICE1:illegal offset %d\n"
argument_list|,
name|Xparm
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_CHOICE2
case|:
define|#
directive|define
name|Xparm
value|((struct choice_T1_2 *)parm)
switch|switch
condition|(
name|Xparm
operator|->
name|offset
operator|=
operator|(
name|t_test
operator|+
literal|12
operator|)
operator|%
name|choice_T1_2_i__c3
operator|+
literal|1
condition|)
block|{
case|case
name|choice_T1_2_i__c3
case|:
name|Xparm
operator|->
name|un
operator|.
name|i__c3
operator|=
literal|689364
expr_stmt|;
break|break;
case|case
name|choice_T1_2_seq__c3
case|:
name|Xparm
operator|->
name|un
operator|.
name|seq__c3
operator|=
operator|(
expr|struct
name|element_T1_10
operator|*
operator|)
name|fill
argument_list|(
name|TY_ELEMENT10
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_T1_2_set__c3
case|:
name|Xparm
operator|->
name|un
operator|.
name|set__c3
operator|=
operator|(
expr|struct
name|member_T1_6
operator|*
operator|)
name|fill
argument_list|(
name|TY_MEMBER6
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"TY_CHOICE2:illegal offset %d\n"
argument_list|,
name|Xparm
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_CHOICE3
case|:
define|#
directive|define
name|Xparm
value|((struct choice_T1_3 *)parm)
switch|switch
condition|(
name|Xparm
operator|->
name|offset
operator|=
operator|(
name|t_test
operator|+
literal|13
operator|)
operator|%
name|choice_T1_3_sc__b__i
operator|+
literal|1
condition|)
block|{
case|case
name|choice_T1_3_sc__a__i
case|:
name|Xparm
operator|->
name|un
operator|.
name|sc__a__i
operator|=
literal|16891
expr_stmt|;
break|break;
case|case
name|choice_T1_3_sc__b__i
case|:
name|Xparm
operator|->
name|un
operator|.
name|sc__b__i
operator|=
literal|13151
expr_stmt|;
break|break;
case|case
name|choice_T1_3_c4__i
case|:
name|Xparm
operator|->
name|un
operator|.
name|c4__i
operator|=
literal|10938
expr_stmt|;
break|break;
case|case
name|choice_T1_3_c4__obj
case|:
name|Xparm
operator|->
name|un
operator|.
name|c4__obj
operator|=
operator|(
expr|struct
name|type_T1_Expl__Tags
operator|*
operator|)
name|fill
argument_list|(
name|TY_EXPLICIT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"TY_CHOICE3:illegal offset %d\n"
argument_list|,
name|Xparm
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_ELEMENT10
case|:
define|#
directive|define
name|Xparm
value|((struct element_T1_10 *)parm)
name|Xparm
operator|->
name|seq__c3__in
operator|=
operator|(
expr|struct
name|type_T1_Expl__Tags
operator|*
operator|)
name|fill
argument_list|(
name|TY_EXPLICIT
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|seq__c3__i
operator|=
literal|40938
expr_stmt|;
name|Xparm
operator|->
name|seq__c3__o
operator|=
name|str2qb
argument_list|(
literal|"James Worsley!!!!"
argument_list|,
literal|18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_MEMBER6
case|:
define|#
directive|define
name|Xparm
value|((struct member_T1_6 *)parm)
name|Xparm
operator|->
name|set__c3__in
operator|=
operator|(
expr|struct
name|type_T1_Expl__Tags
operator|*
operator|)
name|fill
argument_list|(
name|TY_EXPLICIT
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|set__c3__i
operator|=
literal|0x40938
expr_stmt|;
name|Xparm
operator|->
name|set__c3__o
operator|=
name|str2qb
argument_list|(
literal|"Patrick Worsley!!"
argument_list|,
literal|18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_ELEMENT11
case|:
define|#
directive|define
name|Xparm
value|((struct element_T1_11 *)parm)
name|Xparm
operator|->
name|c4__choice
operator|=
operator|(
expr|struct
name|choice_T1_3
operator|*
operator|)
name|fill
argument_list|(
name|TY_CHOICE3
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_OPTIONAL
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Opt__Strings *)parm)
if|if
condition|(
name|t_test
operator|&
name|opt_T1_Opt__Strings_a__opt
condition|)
block|{
name|Xparm
operator|->
name|optionals
operator||=
name|opt_T1_Opt__Strings_a__opt
expr_stmt|;
name|Xparm
operator|->
name|a__opt
operator|=
literal|192837
expr_stmt|;
block|}
if|if
condition|(
name|t_test
operator|&
name|opt_T1_Opt__Strings_d__opt
condition|)
block|{
name|Xparm
operator|->
name|optionals
operator||=
name|opt_T1_Opt__Strings_d__opt
expr_stmt|;
name|Xparm
operator|->
name|d__opt
operator|=
literal|1
expr_stmt|;
block|}
name|Xparm
operator|->
name|b__opt
operator|=
name|str2qb
argument_list|(
literal|"Susan Hannah Sibel"
argument_list|,
literal|19
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
operator|(
name|t_test
operator|+
literal|1
operator|)
operator|&
name|opt_T1_Opt__Strings_d__opt
condition|)
block|{
name|Xparm
operator|->
name|c__opt
operator|=
name|strb2bitstr
argument_list|(
literal|"\012\017\02\07\077"
argument_list|,
literal|40
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t_test
operator|&
name|opt_T1_Opt__Strings_e__opt
condition|)
block|{
name|Xparm
operator|->
name|optionals
operator||=
name|opt_T1_Opt__Strings_e__opt
expr_stmt|;
name|Xparm
operator|->
name|e__opt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t_test
operator|+
literal|12
operator|)
operator|*
name|t_test
operator|&
name|opt_T1_Opt__Strings_a__opt
condition|)
block|{
name|Xparm
operator|->
name|big__opt
operator|=
operator|(
expr|struct
name|type_T1_Strings
operator|*
operator|)
name|fill
argument_list|(
name|TY_STRINGS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t_test
operator|+
literal|2
operator|)
operator|*
name|t_test
operator|&
name|opt_T1_Opt__Strings_a__opt
condition|)
block|{
name|Xparm
operator|->
name|emb__opt
operator|=
operator|(
expr|struct
name|element_T1_12
operator|*
operator|)
name|fill
argument_list|(
name|TY_ELEMENT12
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t_test
operator|+
literal|4
operator|)
operator|*
name|t_test
operator|&
name|opt_T1_Opt__Strings_a__opt
condition|)
block|{
name|Xparm
operator|->
name|st__opt
operator|=
operator|(
expr|struct
name|member_T1_7
operator|*
operator|)
name|fill
argument_list|(
name|TY_MEMBER7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t_test
operator|+
literal|8
operator|)
operator|*
name|t_test
operator|&
name|opt_T1_Opt__Strings_a__opt
condition|)
block|{
name|Xparm
operator|->
name|obj__opt
operator|=
operator|(
expr|struct
name|type_T1_MPDU
operator|*
operator|)
name|fill
argument_list|(
name|TY_MPDU
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t_test
operator|&
name|opt_T1_Opt__Strings_etag__opt
condition|)
block|{
name|Xparm
operator|->
name|optionals
operator||=
name|opt_T1_Opt__Strings_etag__opt
expr_stmt|;
name|Xparm
operator|->
name|etag__opt
operator|=
literal|2983461
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t_test
operator|+
literal|6
operator|)
operator|*
name|t_test
operator|&
name|opt_T1_Opt__Strings_a__opt
condition|)
block|{
name|Xparm
operator|->
name|ch__opt
operator|=
operator|(
expr|struct
name|choice_T1_4
operator|*
operator|)
name|fill
argument_list|(
name|TY_CHOICE4
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_ELEMENT12
case|:
define|#
directive|define
name|Xparm
value|((struct element_T1_12 *)parm)
if|if
condition|(
operator|(
name|t_test
operator|+
literal|10
operator|)
operator|*
name|t_test
operator|&
name|opt_T1_element_T1_12_oem__int
condition|)
block|{
name|Xparm
operator|->
name|optionals
operator||=
name|opt_T1_element_T1_12_oem__int
expr_stmt|;
name|Xparm
operator|->
name|oem__int
operator|=
literal|197336
expr_stmt|;
block|}
if|if
condition|(
name|t_test
operator|*
operator|(
name|t_test
operator|+
literal|22
operator|)
operator|&
name|opt_T1_Opt__Strings_a__opt
condition|)
block|{
name|Xparm
operator|->
name|oem__oct
operator|=
name|str2qb
argument_list|(
literal|"Ling Worsley"
argument_list|,
literal|13
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t_test
operator|*
operator|(
name|t_test
operator|+
literal|16
operator|)
operator|&
name|opt_T1_Opt__Strings_d__opt
condition|)
block|{
name|Xparm
operator|->
name|oem__bit
operator|=
name|strb2bitstr
argument_list|(
literal|"\0142\0117\02\017\07"
argument_list|,
literal|40
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_MEMBER7
case|:
define|#
directive|define
name|Xparm
value|((struct member_T1_7 *)parm)
if|if
condition|(
operator|(
name|t_test
operator|+
literal|12
operator|)
operator|*
name|t_test
operator|&
name|opt_T1_member_T1_7_st__int0
condition|)
block|{
name|Xparm
operator|->
name|optionals
operator||=
name|opt_T1_member_T1_7_st__int0
expr_stmt|;
name|Xparm
operator|->
name|st__int0
operator|=
literal|85659
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t_test
operator|+
literal|12
operator|)
operator|*
name|t_test
operator|&
name|opt_T1_member_T1_7_st__int1
condition|)
block|{
name|Xparm
operator|->
name|optionals
operator||=
name|opt_T1_member_T1_7_st__int1
expr_stmt|;
name|Xparm
operator|->
name|st__int1
operator|=
literal|664388
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t_test
operator|+
literal|12
operator|)
operator|*
name|t_test
operator|&
name|opt_T1_member_T1_7_st__int2
condition|)
block|{
name|Xparm
operator|->
name|optionals
operator||=
name|opt_T1_member_T1_7_st__int2
expr_stmt|;
name|Xparm
operator|->
name|st__int2
operator|=
literal|967768
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_CHOICE4
case|:
define|#
directive|define
name|Xparm
value|((struct choice_T1_4 *)parm)
switch|switch
condition|(
name|Xparm
operator|->
name|offset
operator|=
operator|(
name|t_test
operator|+
literal|14
operator|)
operator|%
name|choice_T1_4_ch__2
operator|+
literal|1
condition|)
block|{
case|case
name|choice_T1_4_ch__1
case|:
name|Xparm
operator|->
name|un
operator|.
name|ch__1
operator|=
literal|74576
expr_stmt|;
break|break;
case|case
name|choice_T1_4_ch__2
case|:
name|Xparm
operator|->
name|un
operator|.
name|ch__2
operator|=
literal|28828
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"TY_CHOICE4:illegal offset %d\n"
argument_list|,
name|Xparm
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_EXTREF
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_E__ref *)parm)
name|Xparm
operator|->
name|a__ref
operator|=
operator|(
expr|struct
name|type_T2_Info
operator|*
operator|)
name|fill
argument_list|(
name|TY_T2_INFO
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|b__ref
operator|=
operator|(
expr|struct
name|type_T2_Info
operator|*
operator|)
name|fill
argument_list|(
name|TY_T2_INFO
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|c__ref
operator|=
operator|(
expr|struct
name|type_T1_Choice__Test
operator|*
operator|)
name|fill
argument_list|(
name|TY_CHOICE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t_test
operator|+
literal|20
operator|)
operator|*
name|t_test
operator|&
literal|0x2
condition|)
block|{
name|Xparm
operator|->
name|d__ref
operator|=
operator|(
expr|struct
name|type_T2_Info
operator|*
operator|)
name|fill
argument_list|(
name|TY_T2_INFO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t_test
operator|+
literal|20
operator|)
operator|*
name|t_test
operator|&
literal|0x1
condition|)
block|{
name|Xparm
operator|->
name|e__ref
operator|=
operator|(
expr|struct
name|type_T2_Info
operator|*
operator|)
name|fill
argument_list|(
name|TY_T2_INFO
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_T2_INFO
case|:
define|#
directive|define
name|Xparm
value|((struct type_T2_Info *)parm)
name|Xparm
operator|->
name|a1
operator|=
literal|101910
expr_stmt|;
name|Xparm
operator|->
name|a2
operator|=
operator|-
literal|304985
expr_stmt|;
name|Xparm
operator|->
name|a3
operator|=
literal|13
expr_stmt|;
name|Xparm
operator|->
name|a4
operator|=
operator|(
expr|struct
name|type_T2_MPDU
operator|*
operator|)
name|fill
argument_list|(
name|TY_T2_MPDU
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_T2_MPDU
case|:
define|#
directive|define
name|Xparm
value|((struct type_T2_MPDU *)parm)
name|Xparm
operator|->
name|a__seq
operator|=
operator|(
expr|struct
name|element_T2_0
operator|*
operator|)
name|fill
argument_list|(
name|TY_T2_ELEM0
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_T2_ELEM0
case|:
define|#
directive|define
name|Xparm
value|((struct element_T2_0 *)parm)
name|Xparm
operator|->
name|fred
operator|=
literal|998877
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_OPTIMISED
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Optimised *)parm)
name|Xparm
operator|->
name|o1
operator|=
name|strb2bitstr
argument_list|(
literal|"\0241\0227\032\011\0237"
argument_list|,
literal|40
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|o2
operator|=
name|str2qb
argument_list|(
literal|"Peckling Worsley!!!!"
argument_list|,
literal|20
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|o3
operator|=
operator|(
expr|struct
name|type_T1_MPDU
operator|*
operator|)
name|fill
argument_list|(
name|TY_MPDU
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|o4
operator|=
operator|(
name|PE
operator|)
name|mkpelist
argument_list|(
name|t_test
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|element_T1_14
operator|=
operator|(
expr|struct
name|member_T1_9
operator|*
operator|)
name|fill
argument_list|(
name|TY_MEMBER9
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_MEMBER9
case|:
define|#
directive|define
name|Xparm
value|((struct member_T1_9 *)parm)
name|Xparm
operator|->
name|o5
operator|=
name|mkpelist
argument_list|(
name|t_test
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|o6
operator|=
name|mkpelist
argument_list|(
name|t_test
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|o7
operator|=
name|mkoid
argument_list|(
name|t_test
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_EXTERNAL
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Ext__typ *)parm)
name|Xparm
operator|->
name|ext
operator|=
name|mkext
argument_list|(
name|t_test
operator|*
literal|8
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|a__ny
operator|=
name|mkpe
argument_list|(
name|t_test
operator|*
literal|8
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|ext__impl
operator|=
name|mkext
argument_list|(
name|t_test
operator|*
literal|6
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|any__impl
operator|=
name|mkpe
argument_list|(
name|t_test
operator|*
literal|8
operator|+
literal|3
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|ext__expl
operator|=
name|mkext
argument_list|(
name|t_test
operator|*
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|any__expl
operator|=
name|mkpe
argument_list|(
name|t_test
operator|*
literal|8
operator|+
literal|5
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_SEXTERNAL
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_SExt *)parm)
name|free
argument_list|(
name|parm
argument_list|)
expr_stmt|;
comment|/* don't need it */
name|Xparm
operator|=
name|mkext
argument_list|(
literal|21
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_ETAGOBJ
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Etags *)parm)
switch|switch
condition|(
name|Xparm
operator|->
name|offset
operator|=
operator|(
name|t_test
operator|+
literal|4
operator|)
operator|%
name|type_T1_Etags_bE
operator|+
literal|1
condition|)
block|{
case|case
name|type_T1_Etags_aE
case|:
name|Xparm
operator|->
name|un
operator|.
name|aE
operator|=
literal|10283
expr_stmt|;
break|break;
case|case
name|type_T1_Etags_bE
case|:
name|Xparm
operator|->
name|un
operator|.
name|bE
operator|=
literal|40986
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"TY_ETAGOBJ:illegal offset %d\n"
argument_list|,
name|Xparm
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
comment|/* This has to be changed when posy is upgraded to handle DEFAULTS properly */
case|case
name|TY_DEFAULT
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Def__Strings *)parm)
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|&
literal|2
condition|)
name|Xparm
operator|->
name|a__def
operator|=
name|int_T1_a__def_a__def__0
expr_stmt|;
else|else
name|Xparm
operator|->
name|a__def
operator|=
name|int_T1_a__def_a__def__1
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|&
literal|4
condition|)
name|Xparm
operator|->
name|b__def
operator|=
name|str2qb
argument_list|(
literal|"Susan Sibel !!!!"
argument_list|,
literal|17
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|&
literal|8
condition|)
name|Xparm
operator|->
name|b__def
operator|=
name|str2qb
argument_list|(
literal|"hello, world"
argument_list|,
literal|12
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|b__def
operator|=
name|NULLQB
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|&
literal|8
condition|)
name|Xparm
operator|->
name|c__def
operator|=
name|strb2bitstr
argument_list|(
name|int2strb
argument_list|(
name|bit_T1_c__def_c__def__two
argument_list|,
literal|9
argument_list|)
argument_list|,
literal|9
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|c__def
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|&
literal|0x10
condition|)
name|Xparm
operator|->
name|okay
operator|=
literal|0
expr_stmt|;
else|else
name|Xparm
operator|->
name|okay
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|&
literal|0x20
condition|)
name|Xparm
operator|->
name|e__def
operator|=
literal|0
expr_stmt|;
else|else
name|Xparm
operator|->
name|e__def
operator|=
literal|1
expr_stmt|;
name|Xparm
operator|->
name|big__def
operator|=
operator|(
expr|struct
name|type_T1_Strings
operator|*
operator|)
name|fill
argument_list|(
name|TY_STRINGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|*
name|t_test
operator|&
literal|0x10
condition|)
name|Xparm
operator|->
name|emb__def
operator|=
name|NULL
expr_stmt|;
else|else
name|Xparm
operator|->
name|emb__def
operator|=
operator|(
expr|struct
name|element_T1_13
operator|*
operator|)
name|fill
argument_list|(
name|TY_ELEMENT13
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|*
name|t_test
operator|&
literal|0x20
condition|)
name|Xparm
operator|->
name|st__def
operator|=
name|NULL
expr_stmt|;
else|else
name|Xparm
operator|->
name|st__def
operator|=
operator|(
expr|struct
name|member_T1_8
operator|*
operator|)
name|fill
argument_list|(
name|TY_MEMBER8
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_ELEMENT13
case|:
define|#
directive|define
name|Xparm
value|((struct element_T1_13 *)parm)
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|*
name|t_test
operator|&
literal|1
condition|)
name|Xparm
operator|->
name|colour
operator|=
name|int_T1_colour_green
expr_stmt|;
else|else
name|Xparm
operator|->
name|colour
operator|=
name|int_T1_colour_red
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|&
literal|040
condition|)
name|Xparm
operator|->
name|oem__oct
operator|=
name|str2qb
argument_list|(
literal|"Julia Dzuikas !!!!"
argument_list|,
literal|19
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|oem__oct
operator|=
name|NULLQB
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|*
name|t_test
operator|&
literal|2
condition|)
name|Xparm
operator|->
name|version
operator|=
name|strb2bitstr
argument_list|(
name|int2strb
argument_list|(
operator|(
literal|1
operator|<<
name|bit_T1_version_basic
operator|)
operator||
operator|(
literal|1
operator|<<
name|bit_T1_version_patch1
operator|)
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|version
operator|=
name|strb2bitstr
argument_list|(
name|int2strb
argument_list|(
operator|(
literal|1
operator|<<
name|bit_T1_version_basic
operator|)
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_MEMBER8
case|:
define|#
directive|define
name|Xparm
value|((struct member_T1_8 *)parm)
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|*
name|t_test
operator|&
literal|4
condition|)
name|Xparm
operator|->
name|wine
operator|=
name|int_T1_wine_burgundy
expr_stmt|;
else|else
name|Xparm
operator|->
name|wine
operator|=
name|int_T1_wine_claret
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|*
name|t_test
operator|&
literal|010
condition|)
name|Xparm
operator|->
name|beer
operator|=
name|int_T1_beer_vb
expr_stmt|;
else|else
name|Xparm
operator|->
name|beer
operator|=
name|int_T1_beer_hieneken
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
name|t_test
operator|*
name|t_test
operator|&
literal|020
condition|)
name|Xparm
operator|->
name|spirit
operator|=
name|int_T1_spirit_vodka
expr_stmt|;
else|else
name|Xparm
operator|->
name|spirit
operator|=
name|int_T1_spirit_brandy
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_STEST
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Stest *)parm)
if|if
condition|(
name|t_test
operator|*
operator|(
name|t_test
operator|+
literal|2
operator|)
operator|*
name|t_test
operator|&
literal|4
condition|)
name|Xparm
operator|->
name|st1
operator|=
operator|(
expr|struct
name|type_T1_Sint
operator|*
operator|)
name|fill
argument_list|(
name|TY_SINT
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|st1
operator|=
operator|(
expr|struct
name|type_T1_Sint
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|t_test
operator|*
operator|(
name|t_test
operator|+
literal|2
operator|)
operator|*
name|t_test
operator|&
literal|010
condition|)
name|Xparm
operator|->
name|st2
operator|=
name|str2qb
argument_list|(
literal|"goodbye, world"
argument_list|,
literal|14
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|st2
operator|=
name|str2qb
argument_list|(
literal|"xxxxxxx, world"
argument_list|,
literal|14
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_SINT
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Sint *)parm)
if|if
condition|(
name|t_test
operator|*
operator|(
name|t_test
operator|+
literal|4
operator|)
operator|*
name|t_test
operator|&
literal|4
condition|)
name|Xparm
operator|->
name|parm
operator|=
literal|33
expr_stmt|;
else|else
name|Xparm
operator|->
name|parm
operator|=
literal|44
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_ETYPE
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Enum__type *)parm)
switch|switch
condition|(
name|t_test
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|Xparm
operator|->
name|parm
operator|=
name|int_T1_Enum__type_pork
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|Xparm
operator|->
name|parm
operator|=
name|int_T1_Enum__type_beef
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Xparm
operator|->
name|parm
operator|=
name|int_T1_Enum__type_chicken
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|Xparm
operator|->
name|parm
operator|=
name|int_T1_Enum__type_lamb
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"fill:ETYPE: Self consistency failure\n"
argument_list|,
name|t_test
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_ENUM_TEST
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_T__enum *)parm)
name|i
operator|=
name|t_test
expr_stmt|;
name|Xparm
operator|->
name|ae1
operator|=
operator|(
expr|struct
name|type_T1_Enum__type
operator|*
operator|)
name|fill
argument_list|(
name|TY_ETYPE
argument_list|)
expr_stmt|;
name|t_test
operator|++
expr_stmt|;
name|Xparm
operator|->
name|ae2
operator|=
operator|(
expr|struct
name|type_T1_Enum__type
operator|*
operator|)
name|fill
argument_list|(
name|TY_ETYPE
argument_list|)
expr_stmt|;
name|t_test
operator|++
expr_stmt|;
name|Xparm
operator|->
name|ae3
operator|=
operator|(
expr|struct
name|type_T1_Enum__type
operator|*
operator|)
name|fill
argument_list|(
name|TY_ETYPE
argument_list|)
expr_stmt|;
name|t_test
operator|++
expr_stmt|;
if|if
condition|(
name|t_test
operator|&
literal|1
condition|)
name|Xparm
operator|->
name|ae5
operator|=
operator|(
expr|struct
name|type_T1_Enum__type
operator|*
operator|)
name|fill
argument_list|(
name|TY_ETYPE
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|ae4
operator|=
operator|(
expr|struct
name|type_T1_Enum__type
operator|*
operator|)
name|fill
argument_list|(
name|TY_ETYPE
argument_list|)
expr_stmt|;
name|t_test
operator|++
expr_stmt|;
if|if
condition|(
name|t_test
operator|&
literal|2
condition|)
name|Xparm
operator|->
name|ae4
operator|->
name|parm
operator|=
name|int_T1_Enum__type_chicken
expr_stmt|;
comment|/* Default */
name|t_test
operator|=
name|i
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
ifdef|#
directive|ifdef
name|PEPSY_REALS
case|case
name|TY_REAL
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_Real *)parm)
switch|switch
condition|(
name|t_test
operator|%
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|Xparm
operator|->
name|parm
operator|=
operator|-
literal|2.28789
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|Xparm
operator|->
name|parm
operator|=
literal|927639.98009
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Xparm
operator|->
name|parm
operator|=
literal|0.0
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"fill:TY_REAL:Internal error %d\n"
argument_list|,
name|t_test
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_REAL_TEST
case|:
define|#
directive|define
name|Xparm
value|((struct type_T1_T__real *)parm)
name|i
operator|=
name|t_test
expr_stmt|;
name|Xparm
operator|->
name|r1
operator|=
operator|(
expr|struct
name|type_T1_Real
operator|*
operator|)
name|fill
argument_list|(
name|TY_REAL
argument_list|)
expr_stmt|;
name|t_test
operator|++
expr_stmt|;
name|Xparm
operator|->
name|r2
operator|=
operator|(
expr|struct
name|type_T1_Real
operator|*
operator|)
name|fill
argument_list|(
name|TY_REAL
argument_list|)
expr_stmt|;
name|t_test
operator|++
expr_stmt|;
name|Xparm
operator|->
name|r3
operator|=
operator|(
expr|struct
name|type_T1_Real
operator|*
operator|)
name|fill
argument_list|(
name|TY_REAL
argument_list|)
expr_stmt|;
name|t_test
operator|++
expr_stmt|;
name|Xparm
operator|->
name|r4
operator|=
operator|(
expr|struct
name|type_T1_Real
operator|*
operator|)
name|fill
argument_list|(
name|TY_REAL
argument_list|)
expr_stmt|;
name|t_test
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
comment|/* Default */
name|Xparm
operator|->
name|r4
operator|->
name|parm
operator|=
literal|3.1415962
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|2
condition|)
block|{
comment|/* Optional */
name|Xparm
operator|->
name|r5
operator|=
operator|(
expr|struct
name|type_T1_Real
operator|*
operator|)
name|fill
argument_list|(
name|TY_REAL
argument_list|)
expr_stmt|;
block|}
name|t_test
operator|=
name|i
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
comment|/* all strings have to be malloc'ed out ! */
case|case
name|TY_OPTPEPY
case|:
case|case
name|TY_DEFPEPY
case|:
define|#
directive|define
name|Xparm
value|((struct pepy_refs1 *)parm)
name|Xparm
operator|->
name|t_int
operator|=
literal|12354
operator|+
name|t_test
expr_stmt|;
name|Xparm
operator|->
name|t_int1
operator|=
literal|12354
operator|+
name|t_test
expr_stmt|;
name|Xparm
operator|->
name|t_enum
operator|=
name|t_test
operator|+
literal|1
expr_stmt|;
name|Xparm
operator|->
name|t_enum1
operator|=
name|t_test
operator|+
literal|1
expr_stmt|;
name|Xparm
operator|->
name|t_qbuf
operator|=
name|str2qb
argument_list|(
literal|"Some is out there!"
argument_list|,
literal|18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_qbuf1
operator|=
name|str2qb
argument_list|(
literal|"Some is out there!"
argument_list|,
literal|18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_string
operator|=
name|strdup
argument_list|(
literal|"hello, world\n"
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_string1
operator|=
name|strdup
argument_list|(
literal|"hello, world\n"
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"\0001234567890"
argument_list|,
name|p
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_ostring
operator|=
name|p
expr_stmt|;
name|Xparm
operator|->
name|t_olen
operator|=
name|t_test
operator|+
literal|4
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"\0001234567890"
argument_list|,
name|p
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_ostring1
operator|=
name|p
expr_stmt|;
name|Xparm
operator|->
name|t_olen1
operator|=
name|t_test
operator|+
literal|4
expr_stmt|;
name|Xparm
operator|->
name|t_bool
operator|=
name|t_test
operator|%
literal|2
expr_stmt|;
name|Xparm
operator|->
name|t_bool1
operator|=
name|t_test
operator|%
literal|2
expr_stmt|;
name|Xparm
operator|->
name|t_real
operator|=
name|sqrt
argument_list|(
name|t_test
operator|*
literal|3.1415962
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_real1
operator|=
name|sqrt
argument_list|(
name|t_test
operator|*
literal|3.1415962
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_oid
operator|=
name|mkoid
argument_list|(
name|t_test
argument_list|)
expr_stmt|;
if|if
condition|(
name|tynum
operator|!=
name|TY_OPTPEPY
condition|)
name|Xparm
operator|->
name|t_oid1
operator|=
name|mkoid
argument_list|(
name|t_test
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_pe
operator|=
name|strb2bitstr
argument_list|(
literal|"\0221\0327\052\211\0237\200"
argument_list|,
literal|41
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_pe1
operator|=
name|strb2bitstr
argument_list|(
literal|"\0221\0327\052\211\0237\200"
argument_list|,
literal|41
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_any
operator|=
name|mkpe
argument_list|(
name|t_test
operator|*
literal|8
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"\0001234567890"
argument_list|,
name|p
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_bstring
operator|=
name|p
expr_stmt|;
name|Xparm
operator|->
name|t_blen
operator|=
name|t_test
operator|*
literal|8
operator|+
literal|8
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_PEPY
case|:
define|#
directive|define
name|Xparm
value|((struct pepy_refs *)parm)
name|Xparm
operator|->
name|t_int
operator|=
literal|12354
operator|+
name|t_test
expr_stmt|;
name|Xparm
operator|->
name|t_enum
operator|=
name|t_test
operator|+
literal|1
expr_stmt|;
name|Xparm
operator|->
name|t_qbuf
operator|=
name|str2qb
argument_list|(
literal|"Some is out there!"
argument_list|,
literal|18
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_string
operator|=
name|strdup
argument_list|(
literal|"hello, world\n"
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"\0001234567890"
argument_list|,
name|p
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_ostring
operator|=
name|p
expr_stmt|;
name|Xparm
operator|->
name|t_olen
operator|=
name|t_test
operator|+
literal|4
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"\0001234567890"
argument_list|,
name|p
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_bstring
operator|=
name|p
expr_stmt|;
name|Xparm
operator|->
name|t_blen
operator|=
name|t_test
operator|*
literal|8
operator|+
literal|4
expr_stmt|;
name|Xparm
operator|->
name|t_bool
operator|=
name|t_test
operator|%
literal|2
expr_stmt|;
name|Xparm
operator|->
name|t_real
operator|=
name|sqrt
argument_list|(
name|t_test
operator|*
literal|3.1415962
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_oid
operator|=
name|mkoid
argument_list|(
name|t_test
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_pe
operator|=
name|strb2bitstr
argument_list|(
literal|"\0221\0327\052\011\0237\200"
argument_list|,
literal|41
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_any
operator|=
name|mkpe
argument_list|(
name|t_test
operator|*
literal|8
operator|+
literal|3
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_def
operator|=
operator|(
expr|struct
name|pepy_refs1
operator|*
operator|)
name|fill
argument_list|(
name|TY_DEFPEPY
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_opt
operator|=
operator|(
expr|struct
name|pepy_refs1
operator|*
operator|)
name|fill
argument_list|(
name|TY_OPTPEPY
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUMOPT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
name|t_test
operator|+
name|i
operator|)
operator|%
literal|2
operator|==
literal|1
condition|)
name|BITSET
argument_list|(
name|Xparm
operator|->
name|t_opt
operator|->
name|opt_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|BITCLR
argument_list|(
name|Xparm
operator|->
name|t_opt
operator|->
name|opt_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_S_COMPD
case|:
define|#
directive|define
name|Xparm
value|((struct pepy_refs1 *)parm)
name|Xparm
operator|->
name|t_int
operator|=
literal|12354
operator|+
name|t_test
expr_stmt|;
name|Xparm
operator|->
name|t_enum
operator|=
name|t_test
operator|+
literal|1
expr_stmt|;
name|Xparm
operator|->
name|t_int1
operator|=
literal|12354
operator|+
name|t_test
expr_stmt|;
name|Xparm
operator|->
name|t_enum1
operator|=
name|t_test
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUMOPT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|OPT_INT1
operator|&&
name|i
operator|!=
name|OPT_INT2
operator|&&
name|i
operator|!=
name|OPT_ENUM1
operator|&&
name|i
operator|!=
name|OPT_ENUM2
condition|)
continue|continue;
if|if
condition|(
operator|(
name|t_test
operator|+
name|i
operator|)
operator|%
literal|2
operator|==
literal|1
condition|)
name|BITSET
argument_list|(
name|Xparm
operator|->
name|opt_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|BITCLR
argument_list|(
name|Xparm
operator|->
name|opt_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
endif|#
directive|endif
case|case
name|TY_ACTION
case|:
case|case
name|TY_REPEAT
case|:
define|#
directive|define
name|Xparm
value|((struct repeats *)parm)
name|Xparm
operator|->
name|rp_sq1
operator|=
name|mkrep_int
argument_list|(
name|t_test
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|rp_sq2
operator|=
name|mkrep_elem
argument_list|(
name|t_test
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|rp_st1
operator|=
name|mkrep_int
argument_list|(
name|t_test
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|rp_st2
operator|=
name|mkrep_elem
argument_list|(
literal|2
operator|*
name|t_test
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t_test
operator|%
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|Xparm
operator|->
name|rp_choice
operator|=
name|RP_INT
expr_stmt|;
name|Xparm
operator|->
name|rp_int
operator|=
name|t_test
operator|*
name|t_test
operator|-
literal|10
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|Xparm
operator|->
name|rp_choice
operator|=
name|RP_BOOL
expr_stmt|;
name|Xparm
operator|->
name|rp_bool
operator|=
operator|(
name|t_test
operator|+
literal|1
operator|)
operator|%
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Xparm
operator|->
name|rp_choice
operator|=
name|RP_OSTRING
expr_stmt|;
name|Xparm
operator|->
name|rp_ostring
operator|=
name|strdup
argument_list|(
literal|"lets go home"
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|rp_int
operator|=
name|strlen
argument_list|(
name|Xparm
operator|->
name|rp_ostring
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"fill:TY_REPEAT:Internal error %d\n"
argument_list|,
name|t_test
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_VPDEFINED
case|:
define|#
directive|define
name|Xparm
value|((struct pepy_refs *)parm)
name|Xparm
operator|->
name|t_int
operator|=
literal|9354
operator|+
name|t_test
expr_stmt|;
name|Xparm
operator|->
name|t_enum
operator|=
name|t_test
operator|+
literal|1
expr_stmt|;
name|Xparm
operator|->
name|t_qbuf
operator|=
name|str2qb
argument_list|(
literal|"Some one is out there!"
argument_list|,
literal|22
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_string
operator|=
name|strdup
argument_list|(
literal|"hello there, world\n"
argument_list|)
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"\0001234567890"
argument_list|,
name|p
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_ostring
operator|=
name|p
expr_stmt|;
name|Xparm
operator|->
name|t_olen
operator|=
name|t_test
operator|+
literal|4
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"\0001234567890"
argument_list|,
name|p
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_bstring
operator|=
name|p
expr_stmt|;
name|Xparm
operator|->
name|t_blen
operator|=
name|t_test
operator|*
literal|8
operator|+
literal|4
expr_stmt|;
name|Xparm
operator|->
name|t_pe
operator|=
name|strb2bitstr
argument_list|(
literal|"\0221\0327\052\211\0237\200"
argument_list|,
name|t_test
operator|+
literal|33
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_bool
operator|=
name|t_test
operator|%
literal|2
expr_stmt|;
name|Xparm
operator|->
name|t_real
operator|=
name|sqrt
argument_list|(
operator|(
name|float
operator|)
name|t_test
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_oid
operator|=
name|mkoid
argument_list|(
name|t_test
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|t_any
operator|=
name|mkpe
argument_list|(
name|t_test
operator|*
literal|7
operator|+
literal|3
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_FUNC
case|:
define|#
directive|define
name|Xparm
value|((struct codedata *)parm)
name|Xparm
operator|->
name|cd_a
operator|=
name|mkpe
argument_list|(
name|t_test
operator|+
literal|2
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_b
operator|=
name|mkpe
argument_list|(
name|t_test
operator|+
literal|3
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_c
operator|=
name|mkpe
argument_list|(
name|t_test
operator|+
literal|5
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_d
operator|=
name|mkpe
argument_list|(
name|t_test
operator|+
literal|7
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_int
operator|=
name|t_test
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|t_test
operator|%
literal|2
condition|)
name|Xparm
operator|->
name|cd_string
operator|=
name|strdup
argument_list|(
literal|"hello there, world\n"
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|cd_string
operator|=
name|strdup
argument_list|(
literal|"hello world\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NCD_OPT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|t_test
operator|+
name|i
operator|)
operator|%
literal|2
operator|==
literal|1
condition|)
name|BITSET
argument_list|(
name|Xparm
operator|->
name|cd_opt_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|BITCLR
argument_list|(
name|Xparm
operator|->
name|cd_opt_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|Xparm
operator|->
name|cd_left
operator|=
operator|(
expr|struct
name|codedata
operator|*
operator|)
name|fill
argument_list|(
name|TY_OPTFUNC
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_right
operator|=
operator|(
expr|struct
name|codedata
operator|*
operator|)
name|fill
argument_list|(
name|TY_DFTFUNC
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_OPTFUNC
case|:
define|#
directive|define
name|Xparm
value|((struct codedata *)parm)
if|if
condition|(
operator|(
name|t_test
operator|+
literal|2
operator|)
operator|%
literal|3
condition|)
name|Xparm
operator|->
name|cd_a
operator|=
name|mkpe
argument_list|(
name|t_test
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t_test
operator|+
literal|1
operator|)
operator|%
literal|3
condition|)
name|Xparm
operator|->
name|cd_b
operator|=
name|mkpe
argument_list|(
name|t_test
operator|+
literal|3
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_c
operator|=
name|mkpe
argument_list|(
name|t_test
operator|+
literal|5
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_d
operator|=
name|mkpe
argument_list|(
name|t_test
operator|+
literal|7
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_int
operator|=
name|t_test
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|t_test
operator|%
literal|2
condition|)
name|Xparm
operator|->
name|cd_string
operator|=
name|strdup
argument_list|(
literal|"hello there, world\n"
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|cd_string
operator|=
name|NULLCP
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NCD_OPT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|t_test
operator|+
name|i
operator|)
operator|%
literal|2
operator|==
literal|1
condition|)
name|BITSET
argument_list|(
name|Xparm
operator|->
name|cd_opt_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|BITCLR
argument_list|(
name|Xparm
operator|->
name|cd_opt_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
case|case
name|TY_DFTFUNC
case|:
define|#
directive|define
name|Xparm
value|((struct codedata *)parm)
if|if
condition|(
operator|(
name|t_test
operator|+
literal|2
operator|)
operator|%
literal|3
condition|)
name|Xparm
operator|->
name|cd_a
operator|=
name|mkpe
argument_list|(
name|t_test
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t_test
operator|+
literal|1
operator|)
operator|%
literal|3
condition|)
name|Xparm
operator|->
name|cd_b
operator|=
name|mkpe
argument_list|(
name|t_test
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_c
operator|=
name|mkpe
argument_list|(
name|t_test
operator|*
literal|2
operator|+
literal|3
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_d
operator|=
name|mkpe
argument_list|(
name|t_test
operator|*
literal|2
operator|+
literal|4
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_int
operator|=
name|t_test
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|t_test
operator|%
literal|2
condition|)
name|Xparm
operator|->
name|cd_string
operator|=
name|strdup
argument_list|(
literal|"hello there, world\n"
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|cd_string
operator|=
name|strdup
argument_list|(
literal|"Some is out"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NCD_OPT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|t_test
operator|+
name|i
operator|)
operator|%
literal|2
operator|==
literal|1
condition|)
name|BITSET
argument_list|(
name|Xparm
operator|->
name|cd_opt_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|BITCLR
argument_list|(
name|Xparm
operator|->
name|cd_opt_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm
ifdef|#
directive|ifdef
name|PEPSY_REALS
case|case
name|TY_ASIMPLE
case|:
define|#
directive|define
name|Xparm
value|((struct codedata *)parm)
name|Xparm
operator|->
name|cd_a
operator|=
name|mkpe
argument_list|(
name|t_test
operator|+
literal|2
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_int
operator|=
literal|2
operator|*
name|t_test
operator|-
literal|1
expr_stmt|;
name|Xparm
operator|->
name|cd_int1
operator|=
literal|2
operator|*
name|t_test
operator|-
literal|1
expr_stmt|;
name|Xparm
operator|->
name|cd_int2
operator|=
literal|2
operator|*
name|t_test
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|t_test
operator|%
literal|2
condition|)
name|Xparm
operator|->
name|cd_string
operator|=
name|strdup
argument_list|(
literal|"hello there, world\n"
argument_list|)
expr_stmt|;
else|else
name|Xparm
operator|->
name|cd_string
operator|=
name|strdup
argument_list|(
literal|"hello world\n"
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_string1
operator|=
name|strdup
argument_list|(
literal|"hello world\n"
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_string2
operator|=
name|strdup
argument_list|(
literal|"hello world\n"
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_bool
operator|=
name|t_test
operator|%
literal|2
expr_stmt|;
name|Xparm
operator|->
name|cd_real
operator|=
name|t_test
operator|*
literal|3.1415962
expr_stmt|;
name|Xparm
operator|->
name|cd_oid
operator|=
name|mkoid
argument_list|(
name|t_test
operator|*
literal|2
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_oid1
operator|=
name|mkoid
argument_list|(
name|t_test
operator|*
literal|2
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_oid2
operator|=
name|mkoid
argument_list|(
name|t_test
operator|*
literal|2
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_bit
operator|=
name|strb2bitstr
argument_list|(
literal|"\0221\0327\052\211\0237\200"
argument_list|,
name|t_test
operator|+
literal|30
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Xparm
operator|->
name|cd_right
operator|=
operator|(
expr|struct
name|codedata
operator|*
operator|)
name|fill
argument_list|(
name|TY_DFTFUNC
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|Xparm
endif|#
directive|endif
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"fill:unknown type %d\n"
argument_list|,
name|tynum
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|parm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * compare two structures for differences of fields indicating an  * error  */
end_comment

begin_macro
name|tcmp
argument_list|(
argument|tynum
argument_list|,
argument|parm1
argument_list|,
argument|parm2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|tynum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|parm1
decl_stmt|,
modifier|*
name|parm2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|tynum
condition|)
block|{
case|case
name|TY_MPDU
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_MPDU *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_MPDU *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|a__seq
operator|&&
operator|!
name|Xparm2
operator|->
name|a__seq
operator|||
operator|!
name|Xparm1
operator|->
name|a__seq
operator|&&
name|Xparm2
operator|->
name|a__seq
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"a__seq missing/present\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|a__seq
operator|&&
name|Xparm2
operator|->
name|a__seq
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|a__seq
operator|->
name|fred
operator|!=
name|Xparm2
operator|->
name|a__seq
operator|->
name|fred
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s->a__seq->fred %d != %d\n"
argument_list|,
name|Xparm1
operator|->
name|a__seq
operator|->
name|fred
argument_list|,
name|Xparm2
operator|->
name|a__seq
operator|->
name|fred
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|a__seq
operator|->
name|george
operator|!=
name|Xparm2
operator|->
name|a__seq
operator|->
name|george
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s a__seq->george %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|a__seq
operator|->
name|george
argument_list|,
name|Xparm2
operator|->
name|a__seq
operator|->
name|george
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_EMBEDDED
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Embedded *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Embedded *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|anMPDU
operator|&&
operator|!
name|Xparm2
operator|->
name|anMPDU
operator|||
operator|!
name|Xparm1
operator|->
name|anMPDU
operator|&&
name|Xparm2
operator|->
name|anMPDU
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"anMPDU missing/present\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|anMPDU
operator|&&
name|Xparm2
operator|->
name|anMPDU
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_MPDU
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|anMPDU
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|anMPDU
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|ei
operator|!=
name|Xparm2
operator|->
name|ei
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s ei %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|ei
argument_list|,
name|Xparm2
operator|->
name|ei
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_STRINGS
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Strings *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Strings *)parm2)
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|ostring
argument_list|,
name|Xparm2
operator|->
name|ostring
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ostring octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|bstring
argument_list|,
name|Xparm2
operator|->
name|bstring
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"bstring bitstring different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|nstring
argument_list|,
name|Xparm2
operator|->
name|nstring
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"nstring octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|pstring
argument_list|,
name|Xparm2
operator|->
name|pstring
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"pstring octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|tstring
argument_list|,
name|Xparm2
operator|->
name|tstring
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"tstring octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|t61string
argument_list|,
name|Xparm2
operator|->
name|t61string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"t61string octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|vstring
argument_list|,
name|Xparm2
operator|->
name|vstring
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"vstring octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|vis__string
argument_list|,
name|Xparm2
operator|->
name|vis__string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"vis__string octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|i646string
argument_list|,
name|Xparm2
operator|->
name|i646string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"i646string octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|ia5string
argument_list|,
name|Xparm2
operator|->
name|ia5string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ia5string octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|graphstring
argument_list|,
name|Xparm2
operator|->
name|graphstring
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"graphstring octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|genstring
argument_list|,
name|Xparm2
operator|->
name|genstring
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"genstring octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_EMB_STRINGS
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Emb__Strings *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Emb__Strings *)parm2)
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|btest
argument_list|,
name|Xparm2
operator|->
name|btest
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"btest octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|ctest
argument_list|,
name|Xparm2
operator|->
name|ctest
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ctest bitstring different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|atest
operator|!=
name|Xparm2
operator|->
name|atest
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"atest integers different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|big__test
operator|&&
name|Xparm2
operator|->
name|big__test
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_STRINGS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|big__test
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|big__test
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|big__test
operator|||
name|Xparm2
operator|->
name|big__test
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"big__test one Strings missing!\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|emb__test
operator|->
name|em__oct
argument_list|,
name|Xparm2
operator|->
name|emb__test
operator|->
name|em__oct
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"emb__test->em__oct octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|emb__test
operator|->
name|em__bit
argument_list|,
name|Xparm2
operator|->
name|emb__test
operator|->
name|em__bit
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"emb__test->em__bit bitstring different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|emb__test
operator|->
name|em__int
operator|!=
name|Xparm2
operator|->
name|emb__test
operator|->
name|em__int
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"emb__test->em__int integers different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_IMPLICIT
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Impl__Tags *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Impl__Tags *)parm2)
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|o__impl
argument_list|,
name|Xparm2
operator|->
name|o__impl
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"o__impl octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|b__impl
argument_list|,
name|Xparm2
operator|->
name|b__impl
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"b__impl bitstring different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|i__impl
operator|!=
name|Xparm2
operator|->
name|i__impl
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"i__impl integers different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|obj__impl
operator|&&
name|Xparm2
operator|->
name|obj__impl
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_EMB_STRINGS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|obj__impl
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|obj__impl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|obj__impl
operator|||
name|Xparm2
operator|->
name|obj__impl
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"obj__impl one Embedded Strings missing!\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|i__emb__test
operator|->
name|i__em__oct
argument_list|,
name|Xparm2
operator|->
name|i__emb__test
operator|->
name|i__em__oct
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"i__emb__test->i__em__oct octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|i__emb__test
operator|->
name|i__em__bit
argument_list|,
name|Xparm2
operator|->
name|i__emb__test
operator|->
name|i__em__bit
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"i__emb__test->i__em__bit bitstring different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|i__emb__test
operator|->
name|i__em__int
operator|!=
name|Xparm2
operator|->
name|i__emb__test
operator|->
name|i__em__int
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"i__emb__test->i__em__int integers different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
break|break;
case|case
name|TY_EXPLICIT
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Expl__Tags *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Expl__Tags *)parm2)
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|o__expl
argument_list|,
name|Xparm2
operator|->
name|o__expl
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"o__expl octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|b__expl
argument_list|,
name|Xparm2
operator|->
name|b__expl
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"b__expl bitstring different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|i__expl
operator|!=
name|Xparm2
operator|->
name|i__expl
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"i__expl integers different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|obj__expl
operator|&&
name|Xparm2
operator|->
name|obj__expl
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_EMB_STRINGS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|obj__expl
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|obj__expl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|obj__expl
operator|||
name|Xparm2
operator|->
name|obj__expl
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"obj__expl one Embedded Strings missing!\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|i__exp__test
operator|->
name|i__ex__oct
argument_list|,
name|Xparm2
operator|->
name|i__exp__test
operator|->
name|i__ex__oct
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"i__exp__test->i__ex__oct octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|i__exp__test
operator|->
name|i__ex__bit
argument_list|,
name|Xparm2
operator|->
name|i__exp__test
operator|->
name|i__ex__bit
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"i__exp__test->i__ex__bit bitstring different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|i__exp__test
operator|->
name|i__ex__int
operator|!=
name|Xparm2
operator|->
name|i__exp__test
operator|->
name|i__ex__int
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"i__exp__test->i__ex__int integers different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
break|break;
case|case
name|TY_SEQOF
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Seqof__Test *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Seqof__Test *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|sqof__test1
operator|&&
name|Xparm2
operator|->
name|sqof__test1
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ELEMENT4
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|sqof__test1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|sqof__test1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|sqof__test1
operator|||
name|Xparm2
operator|->
name|sqof__test1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"sqof__test1 one missing"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|stof__test1
operator|&&
name|Xparm2
operator|->
name|stof__test1
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_MEMBER2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|stof__test1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|stof__test1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|stof__test1
operator|||
name|Xparm2
operator|->
name|stof__test1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"stof__test1 one missing"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|i__test1
operator|!=
name|Xparm2
operator|->
name|i__test1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"i__test1 integers different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|sqof__test2
operator|&&
name|Xparm2
operator|->
name|sqof__test2
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ELEMENT6
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|sqof__test2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|sqof__test2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|sqof__test2
operator|||
name|Xparm2
operator|->
name|sqof__test2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"sqof__test2 one missing"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|stof__test2
operator|&&
name|Xparm2
operator|->
name|stof__test2
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_MEMBER4
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|stof__test2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|stof__test2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|stof__test2
operator|||
name|Xparm2
operator|->
name|stof__test2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"stof__test2 one missing"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|i__test2
operator|!=
name|Xparm2
operator|->
name|i__test2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"i__test2 integers different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_ELEMENT4
case|:
define|#
directive|define
name|Xparm1
value|((struct element_T1_4 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct element_T1_4 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|element_T1_5
operator|&&
name|Xparm2
operator|->
name|element_T1_5
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_EXPLICIT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|element_T1_5
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|element_T1_5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|element_T1_5
operator|||
name|Xparm2
operator|->
name|element_T1_5
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"element_T1_5 one missing"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|next
operator|&&
name|Xparm2
operator|->
name|next
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ELEMENT4
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|next
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|next
operator|||
name|Xparm2
operator|->
name|next
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: next one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_MEMBER2
case|:
define|#
directive|define
name|Xparm1
value|((struct member_T1_2 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct member_T1_2 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|member_T1_3
operator|&&
name|Xparm2
operator|->
name|member_T1_3
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_EXPLICIT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|member_T1_3
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|member_T1_3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|member_T1_3
operator|||
name|Xparm2
operator|->
name|member_T1_3
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: member_T1_3 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|next
operator|&&
name|Xparm2
operator|->
name|next
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_MEMBER2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|next
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|next
operator|||
name|Xparm2
operator|->
name|next
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: next one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_ELEMENT6
case|:
define|#
directive|define
name|Xparm1
value|((struct element_T1_6 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct element_T1_6 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|element_T1_7
operator|&&
name|Xparm2
operator|->
name|element_T1_7
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ELEMENT8
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|element_T1_7
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|element_T1_7
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|element_T1_7
operator|||
name|Xparm2
operator|->
name|element_T1_7
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: element_T1_7 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|next
operator|&&
name|Xparm2
operator|->
name|next
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ELEMENT6
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|next
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|next
operator|||
name|Xparm2
operator|->
name|next
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: next one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_ELEMENT8
case|:
define|#
directive|define
name|Xparm1
value|((struct element_T1_8 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct element_T1_8 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|sqof__in
operator|&&
name|Xparm2
operator|->
name|sqof__in
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_EXPLICIT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|sqof__in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|sqof__in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|sqof__in
operator|||
name|Xparm2
operator|->
name|sqof__in
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: sqof__in one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|sqof__i
operator|!=
name|Xparm2
operator|->
name|sqof__i
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"sqof__i integers different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|sqof__o
argument_list|,
name|Xparm2
operator|->
name|sqof__o
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"sqof__o octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_MEMBER4
case|:
define|#
directive|define
name|Xparm1
value|((struct member_T1_4 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct member_T1_4 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|member_T1_5
operator|&&
name|Xparm2
operator|->
name|member_T1_5
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ELEMENT9
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|member_T1_5
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|member_T1_5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|member_T1_5
operator|||
name|Xparm2
operator|->
name|member_T1_5
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: member_T1_5 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|next
operator|&&
name|Xparm2
operator|->
name|next
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_MEMBER4
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|next
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|next
operator|||
name|Xparm2
operator|->
name|next
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: next one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_ELEMENT9
case|:
define|#
directive|define
name|Xparm1
value|((struct element_T1_9 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct element_T1_9 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|stof__in
operator|&&
name|Xparm2
operator|->
name|stof__in
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_EXPLICIT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|stof__in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|stof__in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|stof__in
operator|||
name|Xparm2
operator|->
name|stof__in
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: stof__in one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|stof__i
operator|!=
name|Xparm2
operator|->
name|stof__i
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"stof__i integers different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|stof__o
argument_list|,
name|Xparm2
operator|->
name|stof__o
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"stof__o octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_CHOICE
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Choice__Test *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Choice__Test *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|c1
operator|&&
name|Xparm2
operator|->
name|c1
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_CHOICE0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|c1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|c1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|c1
operator|||
name|Xparm2
operator|->
name|c1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: c1 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|c2
operator|&&
name|Xparm2
operator|->
name|c2
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_CHOICE1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|c2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|c2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|c2
operator|||
name|Xparm2
operator|->
name|c2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: c2 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|c3
operator|&&
name|Xparm2
operator|->
name|c3
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_CHOICE2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|c3
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|c3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|c3
operator|||
name|Xparm2
operator|->
name|c3
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: c3 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|c4
operator|&&
name|Xparm2
operator|->
name|c4
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ELEMENT11
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|c4
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|c4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|c4
operator|||
name|Xparm2
operator|->
name|c4
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: c4 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_CHOICE0
case|:
define|#
directive|define
name|Xparm1
value|((struct choice_T1_0 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct choice_T1_0 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|offset
operator|!=
name|Xparm2
operator|->
name|offset
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: offset mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|offset
argument_list|,
name|Xparm2
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|Xparm1
operator|->
name|offset
condition|)
block|{
case|case
name|choice_T1_0_i__c1
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|i__c1
operator|!=
name|Xparm2
operator|->
name|un
operator|.
name|i__c1
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: i__c1 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|un
operator|.
name|i__c1
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|i__c1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_0_o__c1
case|:
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|un
operator|.
name|o__c1
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|o__c1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"o__c1 octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_0_b__c1
case|:
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|un
operator|.
name|b__c1
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|b__c1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"un.b__c1 bitstring different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_0_f__c1
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|f__c1
operator|&&
operator|!
name|Xparm2
operator|->
name|un
operator|.
name|f__c1
operator|||
operator|!
name|Xparm1
operator|->
name|un
operator|.
name|f__c1
operator|&&
name|Xparm2
operator|->
name|un
operator|.
name|f__c1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"f__c1 Boolean different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_0_obj__c1
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|obj__c1
operator|&&
name|Xparm2
operator|->
name|un
operator|.
name|obj__c1
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_EMB_STRINGS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|un
operator|.
name|obj__c1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|un
operator|.
name|obj__c1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|obj__c1
operator|||
name|Xparm2
operator|->
name|un
operator|.
name|obj__c1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: un.obj__c1 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"TY_CHOICE0:illegal offset %d\n"
argument_list|,
name|Xparm1
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_CHOICE1
case|:
define|#
directive|define
name|Xparm1
value|((struct choice_T1_1 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct choice_T1_1 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|offset
operator|!=
name|Xparm2
operator|->
name|offset
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: offset mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|offset
argument_list|,
name|Xparm2
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|Xparm1
operator|->
name|offset
condition|)
block|{
case|case
name|choice_T1_1_i__c2
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|i__c2
operator|!=
name|Xparm2
operator|->
name|un
operator|.
name|i__c2
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: i__c2 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|un
operator|.
name|i__c2
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|i__c2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_1_o__c2
case|:
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|un
operator|.
name|o__c2
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|o__c2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"o__c2 octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_1_b__c2
case|:
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|un
operator|.
name|b__c2
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|b__c2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"un.b__c2 bitstring different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_1_f__c2
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|f__c2
operator|&&
operator|!
name|Xparm2
operator|->
name|un
operator|.
name|f__c2
operator|||
operator|!
name|Xparm1
operator|->
name|un
operator|.
name|f__c2
operator|&&
name|Xparm2
operator|->
name|un
operator|.
name|f__c2
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: f__c2 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|un
operator|.
name|f__c2
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|f__c2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_1_obj__c2
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|obj__c2
operator|&&
name|Xparm2
operator|->
name|un
operator|.
name|obj__c2
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_EMB_STRINGS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|un
operator|.
name|obj__c2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|un
operator|.
name|obj__c2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|obj__c2
operator|||
name|Xparm2
operator|->
name|un
operator|.
name|obj__c2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: un.obj__c2 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"TY_CHOICE1:illegal offset %d\n"
argument_list|,
name|Xparm1
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_CHOICE2
case|:
define|#
directive|define
name|Xparm1
value|((struct choice_T1_2 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct choice_T1_2 *)parm2)
switch|switch
condition|(
name|Xparm1
operator|->
name|offset
condition|)
block|{
case|case
name|choice_T1_2_i__c3
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|i__c3
operator|!=
name|Xparm2
operator|->
name|un
operator|.
name|i__c3
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: i__c3 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|un
operator|.
name|i__c3
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|i__c3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_2_seq__c3
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|seq__c3
operator|&&
name|Xparm2
operator|->
name|un
operator|.
name|seq__c3
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ELEMENT10
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|un
operator|.
name|seq__c3
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|un
operator|.
name|seq__c3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|seq__c3
operator|||
name|Xparm2
operator|->
name|un
operator|.
name|seq__c3
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: un.seq__c3 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_2_set__c3
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|set__c3
operator|&&
name|Xparm2
operator|->
name|un
operator|.
name|set__c3
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_MEMBER6
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|un
operator|.
name|set__c3
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|un
operator|.
name|set__c3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|set__c3
operator|||
name|Xparm2
operator|->
name|un
operator|.
name|set__c3
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: un.set__c3 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"TY_CHOICE2:illegal offset %d\n"
argument_list|,
name|Xparm1
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_CHOICE3
case|:
define|#
directive|define
name|Xparm1
value|((struct choice_T1_3 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct choice_T1_3 *)parm2)
switch|switch
condition|(
name|Xparm1
operator|->
name|offset
condition|)
block|{
case|case
name|choice_T1_3_sc__a__i
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|sc__a__i
operator|!=
name|Xparm2
operator|->
name|un
operator|.
name|sc__a__i
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: sc__a__i mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|un
operator|.
name|sc__a__i
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|sc__a__i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_3_sc__b__i
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|sc__b__i
operator|!=
name|Xparm2
operator|->
name|un
operator|.
name|sc__b__i
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: sc__b__i mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|un
operator|.
name|sc__b__i
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|sc__b__i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_3_c4__i
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|c4__i
operator|!=
name|Xparm2
operator|->
name|un
operator|.
name|c4__i
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: c4__i mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|un
operator|.
name|c4__i
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|c4__i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_3_c4__obj
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|c4__obj
operator|&&
name|Xparm2
operator|->
name|un
operator|.
name|c4__obj
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_EXPLICIT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|un
operator|.
name|c4__obj
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|un
operator|.
name|c4__obj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|c4__obj
operator|||
name|Xparm2
operator|->
name|un
operator|.
name|c4__obj
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: un.c4__obj one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"TY_CHOICE3:illegal offset %d\n"
argument_list|,
name|Xparm1
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_ELEMENT10
case|:
define|#
directive|define
name|Xparm1
value|((struct element_T1_10 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct element_T1_10 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|seq__c3__in
operator|&&
name|Xparm2
operator|->
name|seq__c3__in
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_EXPLICIT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|seq__c3__in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|seq__c3__in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|seq__c3__in
operator|||
name|Xparm2
operator|->
name|seq__c3__in
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: seq__c3__in one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|seq__c3__i
operator|!=
name|Xparm2
operator|->
name|seq__c3__i
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: seq__c3__i mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|seq__c3__i
argument_list|,
name|Xparm2
operator|->
name|seq__c3__i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|seq__c3__o
argument_list|,
name|Xparm2
operator|->
name|seq__c3__o
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"seq__c3__o octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_MEMBER6
case|:
define|#
directive|define
name|Xparm1
value|((struct member_T1_6 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct member_T1_6 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|set__c3__in
operator|&&
name|Xparm2
operator|->
name|set__c3__in
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_EXPLICIT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|set__c3__in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|set__c3__in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|set__c3__in
operator|||
name|Xparm2
operator|->
name|set__c3__in
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: set__c3__in one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|set__c3__i
operator|!=
name|Xparm2
operator|->
name|set__c3__i
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: set__c3__i mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|set__c3__i
argument_list|,
name|Xparm2
operator|->
name|set__c3__i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|set__c3__o
argument_list|,
name|Xparm2
operator|->
name|set__c3__o
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"set__c3__o octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_ELEMENT11
case|:
define|#
directive|define
name|Xparm1
value|((struct element_T1_11 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct element_T1_11 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|c4__choice
operator|&&
name|Xparm2
operator|->
name|c4__choice
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_CHOICE3
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|c4__choice
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|c4__choice
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|c4__choice
operator|||
name|Xparm2
operator|->
name|c4__choice
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: c4__choice one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_OPTIONAL
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Opt__Strings *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Opt__Strings *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|optionals
operator|&
name|opt_T1_Opt__Strings_a__opt
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|a__opt
operator|!=
name|Xparm2
operator|->
name|a__opt
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: a__opt mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|a__opt
argument_list|,
name|Xparm2
operator|->
name|a__opt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|optionals
operator|&
name|opt_T1_Opt__Strings_d__opt
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|d__opt
operator|&&
operator|!
name|Xparm2
operator|->
name|d__opt
operator|||
operator|!
name|Xparm1
operator|->
name|d__opt
operator|&&
name|Xparm2
operator|->
name|d__opt
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: d__opt mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|d__opt
argument_list|,
name|Xparm2
operator|->
name|d__opt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|b__opt
operator|!=
name|NULLQB
operator|&&
name|Xparm2
operator|->
name|b__opt
operator|!=
name|NULLQB
condition|)
block|{
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|b__opt
argument_list|,
name|Xparm2
operator|->
name|b__opt
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"b__opt octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|b__opt
operator|!=
name|NULLQB
operator|&&
name|Xparm2
operator|->
name|b__opt
operator|==
name|NULLQB
operator|||
name|Xparm1
operator|->
name|b__opt
operator|==
name|NULLQB
operator|&&
name|Xparm2
operator|->
name|b__opt
operator|!=
name|NULLQB
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: b__opt one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|c__opt
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|c__opt
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|c__opt
argument_list|,
name|Xparm2
operator|->
name|c__opt
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:c__opt bitstring different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|optionals
operator|&
name|opt_T1_Opt__Strings_e__opt
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|e__opt
operator|&&
operator|!
name|Xparm2
operator|->
name|e__opt
operator|||
operator|!
name|Xparm1
operator|->
name|e__opt
operator|&&
name|Xparm2
operator|->
name|e__opt
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: e__opt mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|e__opt
argument_list|,
name|Xparm2
operator|->
name|e__opt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|big__opt
operator|&&
name|Xparm2
operator|->
name|big__opt
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_STRINGS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|big__opt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|big__opt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|big__opt
operator|&&
operator|!
name|Xparm2
operator|->
name|big__opt
operator|||
operator|!
name|Xparm1
operator|->
name|big__opt
operator|&&
name|Xparm2
operator|->
name|big__opt
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: big__opt one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|emb__opt
operator|&&
name|Xparm2
operator|->
name|emb__opt
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ELEMENT12
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|emb__opt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|emb__opt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|emb__opt
operator|&&
operator|!
name|Xparm2
operator|->
name|emb__opt
operator|||
operator|!
name|Xparm1
operator|->
name|emb__opt
operator|&&
name|Xparm2
operator|->
name|emb__opt
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: emb__opt one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|st__opt
operator|&&
name|Xparm2
operator|->
name|st__opt
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_MEMBER7
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|st__opt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|st__opt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|st__opt
operator|&&
operator|!
name|Xparm2
operator|->
name|st__opt
operator|||
operator|!
name|Xparm1
operator|->
name|st__opt
operator|&&
name|Xparm2
operator|->
name|st__opt
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: st__opt one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|obj__opt
operator|&&
name|Xparm2
operator|->
name|obj__opt
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_MPDU
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|obj__opt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|obj__opt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|obj__opt
operator|&&
operator|!
name|Xparm2
operator|->
name|obj__opt
operator|||
operator|!
name|Xparm1
operator|->
name|obj__opt
operator|&&
name|Xparm2
operator|->
name|obj__opt
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: obj__opt one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|optionals
operator|&
name|opt_T1_Opt__Strings_etag__opt
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|etag__opt
operator|!=
name|Xparm2
operator|->
name|etag__opt
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: etag__opt mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|etag__opt
argument_list|,
name|Xparm2
operator|->
name|etag__opt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|ch__opt
operator|&&
name|Xparm2
operator|->
name|ch__opt
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_CHOICE4
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|ch__opt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|ch__opt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|ch__opt
operator|&&
operator|!
name|Xparm2
operator|->
name|ch__opt
operator|||
operator|!
name|Xparm1
operator|->
name|ch__opt
operator|&&
name|Xparm2
operator|->
name|ch__opt
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: ch__opt one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_ELEMENT12
case|:
define|#
directive|define
name|Xparm1
value|((struct element_T1_12 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct element_T1_12 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|optionals
operator|&
name|opt_T1_element_T1_12_oem__int
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|oem__int
operator|!=
name|Xparm2
operator|->
name|oem__int
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: oem__int mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|oem__int
argument_list|,
name|Xparm2
operator|->
name|oem__int
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|oem__oct
operator|!=
name|NULLQB
operator|&&
name|Xparm2
operator|->
name|oem__oct
operator|!=
name|NULLQB
condition|)
block|{
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|oem__oct
argument_list|,
name|Xparm2
operator|->
name|oem__oct
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"oem__oct octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|oem__oct
operator|!=
name|NULLQB
operator|&&
name|Xparm2
operator|->
name|oem__oct
operator|==
name|NULLQB
operator|||
name|Xparm1
operator|->
name|oem__oct
operator|==
name|NULLQB
operator|&&
name|Xparm2
operator|->
name|oem__oct
operator|!=
name|NULLQB
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: oem__oct one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|oem__bit
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|oem__bit
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|oem__bit
argument_list|,
name|Xparm2
operator|->
name|oem__bit
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:oem__bit bitstring different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_MEMBER7
case|:
define|#
directive|define
name|Xparm1
value|((struct member_T1_7 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct member_T1_7 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|optionals
operator|&
name|opt_T1_member_T1_7_st__int0
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|st__int0
operator|!=
name|Xparm2
operator|->
name|st__int0
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: st__int0 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|st__int0
argument_list|,
name|Xparm2
operator|->
name|st__int0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|optionals
operator|&
name|opt_T1_member_T1_7_st__int1
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|st__int1
operator|!=
name|Xparm2
operator|->
name|st__int1
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: st__int1 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|st__int1
argument_list|,
name|Xparm2
operator|->
name|st__int1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|optionals
operator|&
name|opt_T1_member_T1_7_st__int2
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|st__int2
operator|!=
name|Xparm2
operator|->
name|st__int2
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: st__int2 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|st__int2
argument_list|,
name|Xparm2
operator|->
name|st__int2
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_CHOICE4
case|:
define|#
directive|define
name|Xparm1
value|((struct choice_T1_4 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct choice_T1_4 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|offset
operator|!=
name|Xparm2
operator|->
name|offset
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: offset mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|offset
argument_list|,
name|Xparm2
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|Xparm1
operator|->
name|offset
condition|)
block|{
case|case
name|choice_T1_4_ch__1
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|ch__1
operator|!=
name|Xparm2
operator|->
name|un
operator|.
name|ch__1
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: ch__1 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|un
operator|.
name|ch__1
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|ch__1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|choice_T1_4_ch__2
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|ch__2
operator|!=
name|Xparm2
operator|->
name|un
operator|.
name|ch__2
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: ch__2 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|un
operator|.
name|ch__2
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|ch__2
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"tcmp:TY_CHOICE4:illegal offset %d\n"
argument_list|,
name|Xparm1
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_EXTREF
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_E__ref *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_E__ref *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|a__ref
operator|&&
name|Xparm2
operator|->
name|a__ref
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_T2_INFO
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|a__ref
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|a__ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|a__ref
operator|==
name|NULL
operator|||
name|Xparm2
operator|->
name|a__ref
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: a__ref one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|b__ref
operator|&&
name|Xparm2
operator|->
name|b__ref
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_T2_INFO
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|b__ref
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|b__ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|b__ref
operator|==
name|NULL
operator|||
name|Xparm2
operator|->
name|b__ref
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: b__ref one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|c__ref
operator|&&
name|Xparm2
operator|->
name|c__ref
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_CHOICE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|c__ref
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|c__ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|c__ref
operator|==
name|NULL
operator|||
name|Xparm2
operator|->
name|c__ref
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: c__ref one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|d__ref
operator|&&
name|Xparm2
operator|->
name|d__ref
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_T2_INFO
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|d__ref
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|d__ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|d__ref
operator|&&
operator|!
name|Xparm2
operator|->
name|d__ref
operator|||
operator|!
name|Xparm1
operator|->
name|d__ref
operator|&&
name|Xparm2
operator|->
name|d__ref
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: d__ref one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|e__ref
operator|&&
name|Xparm2
operator|->
name|e__ref
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_T2_INFO
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|e__ref
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|e__ref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|e__ref
operator|&&
operator|!
name|Xparm2
operator|->
name|e__ref
operator|||
operator|!
name|Xparm1
operator|->
name|e__ref
operator|&&
name|Xparm2
operator|->
name|e__ref
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: e__ref one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_T2_INFO
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T2_Info *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T2_Info *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|a1
operator|!=
name|Xparm2
operator|->
name|a1
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: a1 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|a1
argument_list|,
name|Xparm2
operator|->
name|a1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|a2
operator|!=
name|Xparm2
operator|->
name|a2
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: a2 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|a2
argument_list|,
name|Xparm2
operator|->
name|a2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|a3
operator|!=
name|Xparm2
operator|->
name|a3
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: a3 mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|a3
argument_list|,
name|Xparm2
operator|->
name|a3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|a4
operator|&&
name|Xparm2
operator|->
name|a4
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_T2_MPDU
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|a4
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|a4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|a4
operator|==
name|NULL
operator|||
name|Xparm2
operator|->
name|a4
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: a4 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_T2_MPDU
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T2_MPDU *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T2_MPDU *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|a__seq
operator|&&
name|Xparm2
operator|->
name|a__seq
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_T2_ELEM0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|a__seq
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|a__seq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|a__seq
operator|==
name|NULL
operator|||
name|Xparm2
operator|->
name|a__seq
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: a__seq one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_T2_ELEM0
case|:
define|#
directive|define
name|Xparm1
value|((struct element_T2_0 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct element_T2_0 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|fred
operator|!=
name|Xparm2
operator|->
name|fred
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: fred mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|fred
argument_list|,
name|Xparm2
operator|->
name|fred
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_OPTIMISED
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Optimised *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Optimised *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|o1
operator|==
name|NULLPE
operator|||
name|Xparm2
operator|->
name|o1
operator|==
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: o1 one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|o1
argument_list|,
name|Xparm2
operator|->
name|o1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:o1 bitstring different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|o2
operator|!=
name|NULLQB
operator|&&
name|Xparm2
operator|->
name|o2
operator|!=
name|NULLQB
condition|)
block|{
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|o2
argument_list|,
name|Xparm2
operator|->
name|o2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"o2 octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: o2 one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|o3
operator|&&
name|Xparm2
operator|->
name|o3
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_MPDU
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|o3
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|o3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|o3
operator|==
name|NULL
operator|||
name|Xparm2
operator|->
name|o3
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: o3 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|o4
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|o4
operator|==
name|NULLPE
operator|||
name|Xparm1
operator|->
name|o4
operator|==
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|o4
operator|!=
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: o4 one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|o4
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|o4
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|o4
argument_list|,
name|Xparm2
operator|->
name|o4
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:o4 SET of ANY different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|element_T1_14
operator|&&
name|Xparm2
operator|->
name|element_T1_14
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_MEMBER9
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|element_T1_14
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|element_T1_14
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|element_T1_14
operator|==
name|NULL
operator|||
name|Xparm2
operator|->
name|element_T1_14
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: element_T1_14 one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_MEMBER9
case|:
define|#
directive|define
name|Xparm1
value|((struct member_T1_9 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct member_T1_9 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|o5
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|o5
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|o5
argument_list|,
name|Xparm2
operator|->
name|o5
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:o5 SET of ANY different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: o5 one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|o6
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|o6
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|o6
argument_list|,
name|Xparm2
operator|->
name|o6
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:o6 SET of ANY different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: o6 one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|o7
operator|!=
name|NULLOID
operator|&&
name|Xparm2
operator|->
name|o7
operator|!=
name|NULLOID
condition|)
block|{
if|if
condition|(
name|oid_cmp
argument_list|(
name|Xparm1
operator|->
name|o7
argument_list|,
name|Xparm2
operator|->
name|o7
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:o7 OID different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: o7 one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_EXTERNAL
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Ext__typ *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Ext__typ *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|ext
operator|!=
name|NULL
operator|&&
name|Xparm2
operator|->
name|ext
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ext_cmp
argument_list|(
name|Xparm1
operator|->
name|ext
argument_list|,
name|Xparm2
operator|->
name|ext
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:ext EXTERNAL different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: ext one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|a__ny
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|a__ny
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|a__ny
argument_list|,
name|Xparm2
operator|->
name|a__ny
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:a__ny ANY different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: a__ny one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|ext__impl
operator|!=
name|NULL
operator|&&
name|Xparm2
operator|->
name|ext__impl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ext_cmp
argument_list|(
name|Xparm1
operator|->
name|ext__impl
argument_list|,
name|Xparm2
operator|->
name|ext__impl
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:ext__impl EXTERNAL different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: ext__impl one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|any__impl
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|any__impl
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|any__impl
argument_list|,
name|Xparm2
operator|->
name|any__impl
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:any__impl ANY different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: any__impl one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|ext__expl
operator|!=
name|NULL
operator|&&
name|Xparm2
operator|->
name|ext__expl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ext_cmp
argument_list|(
name|Xparm1
operator|->
name|ext__expl
argument_list|,
name|Xparm2
operator|->
name|ext__expl
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:ext__expl EXTERNAL different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: ext__expl one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|any__expl
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|any__expl
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|any__expl
argument_list|,
name|Xparm2
operator|->
name|any__expl
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:any__expl ANY different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: any__expl one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_SEXTERNAL
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_SExt *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_SExt *)parm2)
if|if
condition|(
name|Xparm1
operator|!=
name|NULL
operator|&&
name|Xparm2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ext_cmp
argument_list|(
name|Xparm1
argument_list|,
name|Xparm2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:ext EXTERNAL different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: ext one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_ETAGOBJ
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Etags *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Etags *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|offset
operator|!=
name|Xparm2
operator|->
name|offset
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: offset mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|offset
argument_list|,
name|Xparm2
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|Xparm1
operator|->
name|offset
condition|)
block|{
case|case
name|type_T1_Etags_aE
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|aE
operator|!=
name|Xparm2
operator|->
name|un
operator|.
name|aE
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: un.aE mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|un
operator|.
name|aE
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|aE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|type_T1_Etags_bE
case|:
if|if
condition|(
name|Xparm1
operator|->
name|un
operator|.
name|bE
operator|!=
name|Xparm2
operator|->
name|un
operator|.
name|bE
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: un.bE mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|un
operator|.
name|bE
argument_list|,
name|Xparm2
operator|->
name|un
operator|.
name|bE
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"TY_ETAGOBJ:illegal offset %d\n"
argument_list|,
name|Xparm1
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
comment|/* This has to be changed when posy is upgraded to handle DEFAULTS properly */
case|case
name|TY_DEFAULT
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Def__Strings *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Def__Strings *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|a__def
operator|!=
name|Xparm2
operator|->
name|a__def
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: a__def mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|a__def
argument_list|,
name|Xparm2
operator|->
name|a__def
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|b__def
operator|!=
name|NULLQB
operator|&&
name|Xparm2
operator|->
name|b__def
operator|!=
name|NULLQB
condition|)
block|{
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|b__def
argument_list|,
name|Xparm2
operator|->
name|b__def
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"b__def octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|b__def
operator|==
name|NULLQB
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: b__def one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|c__def
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|c__def
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|c__def
argument_list|,
name|Xparm2
operator|->
name|c__def
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:c__def bitstring different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|c__def
operator|==
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: c__def restored version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|okay
operator|!=
name|Xparm2
operator|->
name|okay
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: okay mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|okay
argument_list|,
name|Xparm2
operator|->
name|okay
argument_list|)
expr_stmt|;
block|}
comment|/* Can't test NULL .... 	if (Xparm1->e__opt != Xparm2->e__opt) { 	    d++; 	    (void) printf("%s: e__opt mismatch %d != %d", t_case[tynum].tst_name, 		Xparm1->e__opt, Xparm2->e__opt); 	} 	*/
if|if
condition|(
name|Xparm1
operator|->
name|big__def
operator|&&
name|Xparm2
operator|->
name|big__def
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_STRINGS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|big__def
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|big__def
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: big__def one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|emb__def
operator|&&
name|Xparm2
operator|->
name|emb__def
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ELEMENT13
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|emb__def
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|emb__def
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|emb__def
operator|!=
name|NULL
operator|||
name|Xparm2
operator|->
name|emb__def
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: emb__def one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|st__def
operator|&&
name|Xparm2
operator|->
name|st__def
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_MEMBER8
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|st__def
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|st__def
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|st__def
operator|!=
name|NULL
operator|||
name|Xparm2
operator|->
name|st__def
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: st__def one missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_ELEMENT13
case|:
define|#
directive|define
name|Xparm1
value|((struct element_T1_13 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct element_T1_13 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|colour
operator|!=
name|Xparm2
operator|->
name|colour
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: colour mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|colour
argument_list|,
name|Xparm2
operator|->
name|colour
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|oem__oct
operator|!=
name|NULLQB
operator|&&
name|Xparm2
operator|->
name|oem__oct
operator|!=
name|NULLQB
condition|)
block|{
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|oem__oct
argument_list|,
name|Xparm2
operator|->
name|oem__oct
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"oem__oct octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|oem__oct
operator|!=
name|NULLQB
operator|||
name|Xparm2
operator|->
name|oem__oct
operator|!=
name|NULLQB
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"oem__oct: one missing 0x%x, 0x%x\n"
argument_list|,
name|Xparm1
operator|->
name|oem__oct
argument_list|,
name|Xparm1
operator|->
name|oem__oct
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|version
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|version
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|version
argument_list|,
name|Xparm2
operator|->
name|version
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:version bitstring different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|version
operator|==
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: version decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_MEMBER8
case|:
define|#
directive|define
name|Xparm1
value|((struct member_T1_8 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct member_T1_8 *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|wine
operator|!=
name|Xparm2
operator|->
name|wine
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: wine mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|wine
argument_list|,
name|Xparm2
operator|->
name|wine
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|beer
operator|!=
name|Xparm2
operator|->
name|beer
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: beer mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|beer
argument_list|,
name|Xparm2
operator|->
name|beer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|spirit
operator|!=
name|Xparm2
operator|->
name|spirit
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: spirit mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|spirit
argument_list|,
name|Xparm2
operator|->
name|spirit
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_STEST
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Stest *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Stest *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|st1
operator|!=
name|NULL
operator|&&
name|Xparm2
operator|->
name|st1
operator|!=
name|NULL
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_SINT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|st1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|st1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|st1
operator|==
name|NULL
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|st2
operator|!=
name|NULL
operator|&&
name|Xparm2
operator|->
name|st2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|st2
argument_list|,
name|Xparm2
operator|->
name|st2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:st2 octet string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|st2
operator|==
name|NULL
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: missing"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_SINT
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Sint *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Sint *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|parm
operator|!=
name|Xparm2
operator|->
name|parm
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:parm %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|parm
argument_list|,
name|Xparm2
operator|->
name|parm
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_ETYPE
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Enum__type *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Enum__type *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|parm
operator|!=
name|Xparm2
operator|->
name|parm
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:parm %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|parm
argument_list|,
name|Xparm2
operator|->
name|parm
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_ENUM_TEST
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_T__enum *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_T__enum *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|ae1
operator|&&
name|Xparm2
operator|->
name|ae1
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ETYPE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|ae1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|ae1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:ae1 missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|ae2
operator|&&
name|Xparm2
operator|->
name|ae2
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ETYPE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|ae2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|ae2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:ae2 missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|ae3
operator|&&
name|Xparm2
operator|->
name|ae3
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ETYPE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|ae3
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|ae3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:ae3 missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
comment|/* Default */
if|if
condition|(
name|Xparm1
operator|->
name|ae4
operator|&&
name|Xparm2
operator|->
name|ae4
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ETYPE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|ae4
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|ae4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:ae4 missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
comment|/* Optional */
if|if
condition|(
name|Xparm1
operator|->
name|ae5
operator|&&
name|Xparm2
operator|->
name|ae5
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_ETYPE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|ae5
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|ae5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|ae5
operator|||
name|Xparm2
operator|->
name|ae5
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:ae5 missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
ifdef|#
directive|ifdef
name|PEPSY_REALS
case|case
name|TY_REAL
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_Real *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_Real *)parm2)
comment|/* Horrible floating point test for roughly equal */
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|parm
argument_list|)
operator|<
name|F_SMALL
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|parm
operator|-
name|Xparm2
operator|->
name|parm
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:parm %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|parm
argument_list|,
name|Xparm2
operator|->
name|parm
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
operator|(
name|Xparm1
operator|->
name|parm
operator|-
name|Xparm2
operator|->
name|parm
operator|)
operator|/
name|Xparm1
operator|->
name|parm
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:parm %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|parm
argument_list|,
name|Xparm2
operator|->
name|parm
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_REAL_TEST
case|:
define|#
directive|define
name|Xparm1
value|((struct type_T1_T__real *)parm1)
define|#
directive|define
name|Xparm2
value|((struct type_T1_T__real *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|r1
operator|&&
name|Xparm2
operator|->
name|r1
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_REAL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|r1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|r1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:r1 missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|r2
operator|&&
name|Xparm2
operator|->
name|r2
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_REAL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|r2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|r2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:r2 missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|r3
operator|&&
name|Xparm2
operator|->
name|r3
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_REAL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|r3
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|r3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:r3 missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
comment|/* Default */
if|if
condition|(
name|Xparm1
operator|->
name|r4
operator|&&
name|Xparm2
operator|->
name|r4
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_REAL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|r4
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|r4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:r4 missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
comment|/* Optional */
if|if
condition|(
name|Xparm1
operator|->
name|r5
operator|&&
name|Xparm2
operator|->
name|r5
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_REAL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|r5
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|r5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|r5
operator|||
name|Xparm2
operator|->
name|r5
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:r5 missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_PEPY
case|:
define|#
directive|define
name|Xparm1
value|((struct pepy_refs *)parm1)
define|#
directive|define
name|Xparm2
value|((struct pepy_refs *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|t_int
operator|!=
name|Xparm2
operator|->
name|t_int
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_int mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_int
argument_list|,
name|Xparm2
operator|->
name|t_int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_enum
operator|!=
name|Xparm2
operator|->
name|t_enum
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_enum mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_enum
argument_list|,
name|Xparm2
operator|->
name|t_enum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|t_qbuf
argument_list|,
name|Xparm2
operator|->
name|t_qbuf
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"t_qbuf octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_bool
operator|!=
name|Xparm2
operator|->
name|t_bool
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_bool mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_bool
argument_list|,
name|Xparm2
operator|->
name|t_bool
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PEPSY_REALS
comment|/* Horrible floating point test for roughly equal */
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|t_real
argument_list|)
operator|<
name|F_SMALL
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|t_real
operator|-
name|Xparm2
operator|->
name|t_real
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_real %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_real
argument_list|,
name|Xparm2
operator|->
name|t_real
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
operator|(
name|Xparm1
operator|->
name|t_real
operator|-
name|Xparm2
operator|->
name|t_real
operator|)
operator|/
name|Xparm1
operator|->
name|t_real
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_real %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_real
argument_list|,
name|Xparm2
operator|->
name|t_real
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|Xparm1
operator|->
name|t_any
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|t_any
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|t_any
argument_list|,
name|Xparm2
operator|->
name|t_any
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_any different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_oid
operator|!=
name|NULLOID
operator|&&
name|Xparm2
operator|->
name|t_oid
operator|!=
name|NULLOID
condition|)
block|{
if|if
condition|(
name|oid_cmp
argument_list|(
name|Xparm1
operator|->
name|t_oid
argument_list|,
name|Xparm2
operator|->
name|t_oid
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_oid OID different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_oid one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_bstring
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_bstring
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|bitstr_cmp
argument_list|(
name|Xparm1
operator|->
name|t_bstring
argument_list|,
name|Xparm1
operator|->
name|t_blen
argument_list|,
name|Xparm2
operator|->
name|t_bstring
argument_list|,
name|Xparm2
operator|->
name|t_blen
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_blen string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_bstring
operator|==
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_bstring decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_ostring
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_ostring
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_olen
operator|!=
name|Xparm2
operator|->
name|t_olen
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_olen string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|Xparm1
operator|->
name|t_ostring
argument_list|,
name|Xparm2
operator|->
name|t_ostring
argument_list|,
name|Xparm1
operator|->
name|t_olen
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_ostring string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_ostring
operator|==
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_ostring decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_string
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_string
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|Xparm1
operator|->
name|t_string
argument_list|,
name|Xparm2
operator|->
name|t_string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_string string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_string
operator|==
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_string decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_pe
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|t_pe
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|t_pe
argument_list|,
name|Xparm2
operator|->
name|t_pe
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_pe bitstring different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_pe
operator|==
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_pe decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_def
operator|&&
name|Xparm2
operator|->
name|t_def
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_DEFPEPY
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|t_def
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|t_def
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|t_def
operator|||
name|Xparm2
operator|->
name|t_def
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_def missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_opt
operator|&&
name|Xparm2
operator|->
name|t_opt
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_OPTPEPY
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|t_opt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|t_opt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUMOPT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|t_opt
operator|->
name|opt_set
argument_list|,
name|i
argument_list|)
operator|!=
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|t_opt
operator|->
name|opt_set
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_opt missing optional %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|t_opt
operator|||
name|Xparm2
operator|->
name|t_opt
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_opt missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_DEFPEPY
case|:
case|case
name|TY_OPTPEPY
case|:
define|#
directive|define
name|Xparm1
value|((struct pepy_refs1 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct pepy_refs1 *)parm2)
if|if
condition|(
name|tynum
operator|==
name|TY_DEFPEPY
operator|||
operator|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_INT1
argument_list|)
operator|!=
literal|0
operator|&&
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_INT1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_int
operator|!=
name|Xparm2
operator|->
name|t_int
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_int mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_int
argument_list|,
name|Xparm2
operator|->
name|t_int
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tynum
operator|==
name|TY_DEFPEPY
operator|||
operator|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_INT2
argument_list|)
operator|!=
literal|0
operator|&&
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_INT2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_int1
operator|!=
name|Xparm2
operator|->
name|t_int1
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_int1 mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_int1
argument_list|,
name|Xparm2
operator|->
name|t_int1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tynum
operator|==
name|TY_DEFPEPY
operator|||
operator|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM1
argument_list|)
operator|!=
literal|0
operator|&&
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_enum
operator|!=
name|Xparm2
operator|->
name|t_enum
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_enum mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_enum
argument_list|,
name|Xparm2
operator|->
name|t_enum
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tynum
operator|==
name|TY_DEFPEPY
operator|||
operator|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM2
argument_list|)
operator|!=
literal|0
operator|&&
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_enum1
operator|!=
name|Xparm2
operator|->
name|t_enum1
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_enum1 mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_enum1
argument_list|,
name|Xparm2
operator|->
name|t_enum1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|t_qbuf
argument_list|,
name|Xparm2
operator|->
name|t_qbuf
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"t_qbuf octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|t_qbuf1
argument_list|,
name|Xparm2
operator|->
name|t_qbuf1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"t_qbuf1 octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tynum
operator|==
name|TY_DEFPEPY
operator|||
operator|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_BOOL1
argument_list|)
operator|!=
literal|0
operator|&&
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_BOOL1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_bool
operator|!=
name|Xparm2
operator|->
name|t_bool
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_bool mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_bool
argument_list|,
name|Xparm2
operator|->
name|t_bool
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tynum
operator|==
name|TY_OPTPEPY
condition|)
block|{
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_BOOL2
argument_list|)
operator|!=
literal|0
operator|&&
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_BOOL2
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_bool1
operator|!=
name|Xparm2
operator|->
name|t_bool1
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_bool1 mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_bool1
argument_list|,
name|Xparm2
operator|->
name|t_bool1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_BOOL2
argument_list|)
operator|!=
literal|0
operator|||
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_BOOL2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_bool1 missing %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|Xparm2
operator|->
name|opt_set
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PEPSY_REALS
comment|/* Horrible floating point test for roughly equal */
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|t_real
argument_list|)
operator|<
name|F_SMALL
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|t_real
operator|-
name|Xparm2
operator|->
name|t_real
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_real %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_real
argument_list|,
name|Xparm2
operator|->
name|t_real
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tynum
operator|==
name|TY_DEFPEPY
operator|&&
name|fabs
argument_list|(
operator|(
name|Xparm1
operator|->
name|t_real
operator|-
name|Xparm2
operator|->
name|t_real
operator|)
operator|/
name|Xparm1
operator|->
name|t_real
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_real %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_real
argument_list|,
name|Xparm2
operator|->
name|t_real
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|t_real1
argument_list|)
operator|<
name|F_SMALL
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|t_real1
operator|-
name|Xparm2
operator|->
name|t_real1
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_real1 %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_real1
argument_list|,
name|Xparm2
operator|->
name|t_real1
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tynum
operator|==
name|TY_DEFPEPY
operator|&&
name|fabs
argument_list|(
operator|(
name|Xparm1
operator|->
name|t_real1
operator|-
name|Xparm2
operator|->
name|t_real1
operator|)
operator|/
name|Xparm1
operator|->
name|t_real1
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_real1 %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_real1
argument_list|,
name|Xparm2
operator|->
name|t_real1
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|Xparm1
operator|->
name|t_any
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|t_any
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|t_any
argument_list|,
name|Xparm2
operator|->
name|t_any
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_any different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_oid
operator|!=
name|NULLOID
operator|&&
name|Xparm2
operator|->
name|t_oid
operator|!=
name|NULLOID
condition|)
block|{
if|if
condition|(
name|oid_cmp
argument_list|(
name|Xparm1
operator|->
name|t_oid
argument_list|,
name|Xparm2
operator|->
name|t_oid
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_oid OID different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_oid one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_oid1
operator|!=
name|NULLOID
operator|&&
name|Xparm2
operator|->
name|t_oid1
operator|!=
name|NULLOID
condition|)
block|{
if|if
condition|(
name|oid_cmp
argument_list|(
name|Xparm1
operator|->
name|t_oid1
argument_list|,
name|Xparm2
operator|->
name|t_oid1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_oid1 OID different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_bstring
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_bstring
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|bitstr_cmp
argument_list|(
name|Xparm1
operator|->
name|t_bstring
argument_list|,
name|Xparm1
operator|->
name|t_blen
argument_list|,
name|Xparm2
operator|->
name|t_bstring
argument_list|,
name|Xparm2
operator|->
name|t_blen
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_blen string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_bstring
operator|==
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_bstring decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_bstring1
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_bstring1
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|bitstr_cmp
argument_list|(
name|Xparm1
operator|->
name|t_bstring1
argument_list|,
name|Xparm1
operator|->
name|t_blen1
argument_list|,
name|Xparm2
operator|->
name|t_bstring1
argument_list|,
name|Xparm2
operator|->
name|t_blen1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_blen1 string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tynum
operator|==
name|TY_DEFPEPY
operator|&&
name|Xparm2
operator|->
name|t_bstring1
operator|==
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_bstring1 decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_ostring
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_ostring
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_olen
operator|!=
name|Xparm2
operator|->
name|t_olen
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_olen string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|Xparm1
operator|->
name|t_ostring
argument_list|,
name|Xparm2
operator|->
name|t_ostring
argument_list|,
name|Xparm1
operator|->
name|t_olen
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_ostring string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_ostring
operator|==
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_ostring decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_ostring1
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_ostring1
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_olen1
operator|!=
name|Xparm2
operator|->
name|t_olen1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_olen1 string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|Xparm1
operator|->
name|t_ostring1
argument_list|,
name|Xparm2
operator|->
name|t_ostring1
argument_list|,
name|Xparm1
operator|->
name|t_olen1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_ostring string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_ostring1
operator|==
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_ostring1 decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_string
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_string
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|Xparm1
operator|->
name|t_string
argument_list|,
name|Xparm2
operator|->
name|t_string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_string string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_string
operator|==
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_string decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_string1
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_string1
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|Xparm1
operator|->
name|t_string1
argument_list|,
name|Xparm2
operator|->
name|t_string1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_string1 string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_string1
operator|==
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_string1 decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_pe
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|t_pe
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|t_pe
argument_list|,
name|Xparm2
operator|->
name|t_pe
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_pe bitstring different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_pe
operator|==
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_pe decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_pe1
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|t_pe1
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|t_pe1
argument_list|,
name|Xparm2
operator|->
name|t_pe1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_pe1 bitstring different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_pe1
operator|==
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_pe1 decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_S_COMPD
case|:
define|#
directive|define
name|Xparm1
value|((struct pepy_refs1 *)parm1)
define|#
directive|define
name|Xparm2
value|((struct pepy_refs1 *)parm2)
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_INT1
argument_list|)
operator|!=
literal|0
operator|&&
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_INT1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_int
operator|!=
name|Xparm2
operator|->
name|t_int
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_int mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_int
argument_list|,
name|Xparm2
operator|->
name|t_int
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_INT1
argument_list|)
operator|!=
literal|0
operator|||
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_INT1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_int missing %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|Xparm2
operator|->
name|opt_set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_INT2
argument_list|)
operator|!=
literal|0
operator|&&
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_INT2
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_int1
operator|!=
name|Xparm2
operator|->
name|t_int1
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_int1 mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_int1
argument_list|,
name|Xparm2
operator|->
name|t_int1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_INT2
argument_list|)
operator|!=
literal|0
operator|||
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_INT2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_int1 missing %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|Xparm2
operator|->
name|opt_set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM1
argument_list|)
operator|!=
literal|0
operator|&&
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_enum
operator|!=
name|Xparm2
operator|->
name|t_enum
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_enum mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_enum
argument_list|,
name|Xparm2
operator|->
name|t_enum
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM1
argument_list|)
operator|!=
literal|0
operator|||
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_int missing %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|Xparm2
operator|->
name|opt_set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM2
argument_list|)
operator|!=
literal|0
operator|&&
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM2
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_enum1
operator|!=
name|Xparm2
operator|->
name|t_enum1
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_enum1 mismatch %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_enum1
argument_list|,
name|Xparm2
operator|->
name|t_enum1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM2
argument_list|)
operator|!=
literal|0
operator|||
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|OPT_ENUM2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_int missing %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|Xparm2
operator|->
name|opt_set
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|NUMOPT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|OPT_INT1
operator|&&
name|i
operator|!=
name|OPT_INT2
operator|&&
name|i
operator|!=
name|OPT_ENUM1
operator|&&
name|i
operator|!=
name|OPT_ENUM2
condition|)
continue|continue;
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|opt_set
argument_list|,
name|i
argument_list|)
operator|!=
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|opt_set
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_opt missing optional %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
endif|#
directive|endif
case|case
name|TY_ACTION
case|:
case|case
name|TY_REPEAT
case|:
define|#
directive|define
name|Xparm1
value|((struct repeats *)parm1)
define|#
directive|define
name|Xparm2
value|((struct repeats *)parm2)
if|if
condition|(
name|ri_cmp
argument_list|(
name|Xparm1
operator|->
name|rp_sq1
argument_list|,
name|Xparm2
operator|->
name|rp_sq1
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:rp_sq1 mangled\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|re_cmp
argument_list|(
name|Xparm1
operator|->
name|rp_sq2
argument_list|,
name|Xparm2
operator|->
name|rp_sq2
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:rp_sq2 mangled\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ri_cmp
argument_list|(
name|Xparm1
operator|->
name|rp_st1
argument_list|,
name|Xparm2
operator|->
name|rp_st1
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:rp_st1 mangled\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|re_cmp
argument_list|(
name|Xparm1
operator|->
name|rp_st2
argument_list|,
name|Xparm2
operator|->
name|rp_st2
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:rp_st2 mangled\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|rp_choice
operator|!=
name|Xparm2
operator|->
name|rp_choice
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:rp_choice wrong %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|rp_choice
argument_list|,
name|Xparm2
operator|->
name|rp_choice
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|Xparm1
operator|->
name|rp_choice
condition|)
block|{
case|case
name|RP_INT
case|:
if|if
condition|(
name|Xparm1
operator|->
name|rp_int
operator|!=
name|Xparm2
operator|->
name|rp_int
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:rp_int wrong %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|rp_int
argument_list|,
name|Xparm2
operator|->
name|rp_int
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RP_BOOL
case|:
if|if
condition|(
name|Xparm1
operator|->
name|rp_bool
operator|&&
operator|!
name|Xparm2
operator|->
name|rp_bool
operator|||
operator|!
name|Xparm1
operator|->
name|rp_bool
operator|&&
name|Xparm2
operator|->
name|rp_bool
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:RP_BOOL wrong %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|rp_bool
argument_list|,
name|Xparm2
operator|->
name|rp_bool
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RP_OSTRING
case|:
if|if
condition|(
operator|!
name|Xparm1
operator|->
name|rp_ostring
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:initial rp_ostring missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Xparm2
operator|->
name|rp_ostring
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:final rp_ostring missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|Xparm1
operator|->
name|rp_ostring
argument_list|,
name|Xparm2
operator|->
name|rp_ostring
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:rp_ostring not equal %s != %s\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|rp_ostring
argument_list|,
name|Xparm2
operator|->
name|rp_ostring
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:bad choice found\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_VPDEFINED
case|:
define|#
directive|define
name|Xparm1
value|((struct pepy_refs *)parm1)
define|#
directive|define
name|Xparm2
value|((struct pepy_refs *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|t_int
operator|!=
name|Xparm2
operator|->
name|t_int
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_int mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_int
argument_list|,
name|Xparm2
operator|->
name|t_int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_enum
operator|!=
name|Xparm2
operator|->
name|t_enum
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_enum mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_enum
argument_list|,
name|Xparm2
operator|->
name|t_enum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qb_cmp
argument_list|(
name|Xparm1
operator|->
name|t_qbuf
argument_list|,
name|Xparm2
operator|->
name|t_qbuf
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"t_qbuf octet string different\n"
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_bool
operator|!=
name|Xparm2
operator|->
name|t_bool
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_bool mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_bool
argument_list|,
name|Xparm2
operator|->
name|t_bool
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PEPSY_REALS
comment|/* Horrible floating point test for roughly equal */
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|t_real
argument_list|)
operator|<
name|F_SMALL
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|t_real
operator|-
name|Xparm2
operator|->
name|t_real
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_real %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_real
argument_list|,
name|Xparm2
operator|->
name|t_real
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
operator|(
name|Xparm1
operator|->
name|t_real
operator|-
name|Xparm2
operator|->
name|t_real
operator|)
operator|/
name|Xparm1
operator|->
name|t_real
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_real %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|t_real
argument_list|,
name|Xparm2
operator|->
name|t_real
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|Xparm1
operator|->
name|t_any
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|t_any
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|t_any
argument_list|,
name|Xparm2
operator|->
name|t_any
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_any different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_oid
operator|!=
name|NULLOID
operator|&&
name|Xparm2
operator|->
name|t_oid
operator|!=
name|NULLOID
condition|)
block|{
if|if
condition|(
name|oid_cmp
argument_list|(
name|Xparm1
operator|->
name|t_oid
argument_list|,
name|Xparm2
operator|->
name|t_oid
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_oid OID different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_oid one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_bstring
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_bstring
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|bitstr_cmp
argument_list|(
name|Xparm1
operator|->
name|t_bstring
argument_list|,
name|Xparm1
operator|->
name|t_blen
argument_list|,
name|Xparm2
operator|->
name|t_bstring
argument_list|,
name|Xparm2
operator|->
name|t_blen
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_blen string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_bstring
operator|==
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_bstring decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_pe
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|t_pe
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|t_pe
argument_list|,
name|Xparm2
operator|->
name|t_pe
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_pe bitstring different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|t_pe
operator|==
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_pe decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_ostring
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_ostring
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|t_olen
operator|!=
name|Xparm2
operator|->
name|t_olen
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_olen string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|Xparm1
operator|->
name|t_ostring
argument_list|,
name|Xparm2
operator|->
name|t_ostring
argument_list|,
name|Xparm1
operator|->
name|t_olen
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_ostring string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_ostring missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|t_string
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|t_string
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|Xparm1
operator|->
name|t_string
argument_list|,
name|Xparm2
operator|->
name|t_string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:t_string string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: t_string decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_FUNC
case|:
define|#
directive|define
name|Xparm1
value|((struct codedata *)parm1)
define|#
directive|define
name|Xparm2
value|((struct codedata *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|cd_a
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_a
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_a
argument_list|,
name|Xparm2
operator|->
name|cd_a
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_a different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_a missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_b
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_b
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_b
argument_list|,
name|Xparm2
operator|->
name|cd_b
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_b different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_b missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_c
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_c
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_c
argument_list|,
name|Xparm2
operator|->
name|cd_c
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_c different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_c missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_d
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_d
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_d
argument_list|,
name|Xparm2
operator|->
name|cd_d
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_d different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_d missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_int
operator|!=
name|Xparm2
operator|->
name|cd_int
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_int mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|cd_int
argument_list|,
name|Xparm2
operator|->
name|cd_int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_string
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|cd_string
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|Xparm1
operator|->
name|cd_string
argument_list|,
name|Xparm2
operator|->
name|cd_string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_string string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_string missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_left
operator|&&
name|Xparm2
operator|->
name|cd_left
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_OPTFUNC
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|cd_left
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|cd_left
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|cd_left
operator|||
name|Xparm2
operator|->
name|cd_left
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_left missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_right
operator|&&
name|Xparm2
operator|->
name|cd_right
condition|)
block|{
name|d
operator|+=
name|tcmp
argument_list|(
name|TY_DFTFUNC
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm1
operator|->
name|cd_right
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Xparm2
operator|->
name|cd_right
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|cd_right
operator|||
name|Xparm2
operator|->
name|cd_right
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_right missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_OPTFUNC
case|:
define|#
directive|define
name|Xparm1
value|((struct codedata *)parm1)
define|#
directive|define
name|Xparm2
value|((struct codedata *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|cd_a
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_a
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_a
argument_list|,
name|Xparm2
operator|->
name|cd_a
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_a different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|cd_a
operator|!=
name|NULLPE
operator|||
name|Xparm2
operator|->
name|cd_a
operator|!=
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_a missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_b
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_b
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_b
argument_list|,
name|Xparm2
operator|->
name|cd_b
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_b different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|cd_b
operator|!=
name|NULLPE
operator|||
name|Xparm2
operator|->
name|cd_b
operator|!=
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_b missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|NCD_OPT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|cd_opt_set
argument_list|,
name|i
argument_list|)
operator|!=
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|cd_opt_set
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: flag bit %d differs\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|cd_opt_set
argument_list|,
name|CD_C
argument_list|)
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|cd_c
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_c
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_c
argument_list|,
name|Xparm2
operator|->
name|cd_c
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_c different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_c missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|cd_opt_set
argument_list|,
name|CD_D
argument_list|)
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|cd_d
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_d
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_d
argument_list|,
name|Xparm2
operator|->
name|cd_d
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_d different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_d missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|cd_opt_set
argument_list|,
name|CD_INT
argument_list|)
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|cd_int
operator|!=
name|Xparm2
operator|->
name|cd_int
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_int mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|cd_int
argument_list|,
name|Xparm2
operator|->
name|cd_int
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_string
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|cd_string
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|Xparm1
operator|->
name|cd_string
argument_list|,
name|Xparm2
operator|->
name|cd_string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_string string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|cd_string
operator|!=
name|NULLCP
operator|||
name|Xparm2
operator|->
name|cd_string
operator|!=
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_string missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
case|case
name|TY_DFTFUNC
case|:
define|#
directive|define
name|Xparm1
value|((struct codedata *)parm1)
define|#
directive|define
name|Xparm2
value|((struct codedata *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|cd_a
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_a
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_a
argument_list|,
name|Xparm2
operator|->
name|cd_a
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_a different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|cd_a
operator|!=
name|NULLPE
operator|||
name|Xparm2
operator|->
name|cd_a
operator|!=
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_a missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_b
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_b
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_b
argument_list|,
name|Xparm2
operator|->
name|cd_b
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_b different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm1
operator|->
name|cd_b
operator|!=
name|NULLPE
operator|||
name|Xparm2
operator|->
name|cd_b
operator|!=
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_b missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|NCD_OPT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|==
name|CD_INT
condition|)
continue|continue;
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|cd_opt_set
argument_list|,
name|i
argument_list|)
operator|!=
name|BITTEST
argument_list|(
name|Xparm2
operator|->
name|cd_opt_set
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: flag bit %d differs\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|cd_opt_set
argument_list|,
name|CD_C
argument_list|)
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|cd_c
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_c
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_c
argument_list|,
name|Xparm2
operator|->
name|cd_c
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_c different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_c missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BITTEST
argument_list|(
name|Xparm1
operator|->
name|cd_opt_set
argument_list|,
name|CD_D
argument_list|)
condition|)
block|{
if|if
condition|(
name|Xparm1
operator|->
name|cd_d
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_d
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_d
argument_list|,
name|Xparm2
operator|->
name|cd_d
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_d different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_d missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_int
operator|!=
name|Xparm2
operator|->
name|cd_int
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_int mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|cd_int
argument_list|,
name|Xparm2
operator|->
name|cd_int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_string
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|cd_string
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|Xparm1
operator|->
name|cd_string
argument_list|,
name|Xparm2
operator|->
name|cd_string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_string string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_string missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
ifdef|#
directive|ifdef
name|PEPSY_REALS
case|case
name|TY_ASIMPLE
case|:
define|#
directive|define
name|Xparm1
value|((struct codedata *)parm1)
define|#
directive|define
name|Xparm2
value|((struct codedata *)parm2)
if|if
condition|(
name|Xparm1
operator|->
name|cd_a
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_a
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|pe_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_a
argument_list|,
name|Xparm2
operator|->
name|cd_a
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_a different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_a missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_int
operator|!=
name|Xparm2
operator|->
name|cd_int
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_int mismatch %d != %d"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|cd_int
argument_list|,
name|Xparm2
operator|->
name|cd_int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_string
operator|!=
name|NULLCP
operator|&&
name|Xparm2
operator|->
name|cd_string
operator|!=
name|NULLCP
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|Xparm1
operator|->
name|cd_string
argument_list|,
name|Xparm2
operator|->
name|cd_string
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_string string different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_string missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_bool
operator|&&
operator|!
name|Xparm2
operator|->
name|cd_bool
operator|||
operator|!
name|Xparm1
operator|->
name|cd_bool
operator|&&
name|Xparm2
operator|->
name|cd_bool
condition|)
block|{
name|d
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_bool wrong %d != %d\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|cd_bool
argument_list|,
name|Xparm2
operator|->
name|cd_bool
argument_list|)
expr_stmt|;
block|}
comment|/* Horrible floating point test for roughly equal */
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|cd_real
argument_list|)
operator|<
name|F_SMALL
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|Xparm1
operator|->
name|cd_real
operator|-
name|Xparm2
operator|->
name|cd_real
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_real %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|cd_real
argument_list|,
name|Xparm2
operator|->
name|cd_real
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
operator|(
name|Xparm1
operator|->
name|cd_real
operator|-
name|Xparm2
operator|->
name|cd_real
operator|)
operator|/
name|Xparm1
operator|->
name|cd_real
argument_list|)
operator|>
name|F_SMALL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_real %f != %f\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|,
name|Xparm1
operator|->
name|cd_real
argument_list|,
name|Xparm2
operator|->
name|cd_real
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_oid
operator|!=
name|NULLOID
operator|&&
name|Xparm2
operator|->
name|cd_oid
operator|!=
name|NULLOID
condition|)
block|{
if|if
condition|(
name|oid_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_oid
argument_list|,
name|Xparm2
operator|->
name|cd_oid
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_oid OID different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_oid one missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Xparm1
operator|->
name|cd_bit
operator|!=
name|NULLPE
operator|&&
name|Xparm2
operator|->
name|cd_bit
operator|!=
name|NULLPE
condition|)
block|{
if|if
condition|(
name|bit_cmp
argument_list|(
name|Xparm1
operator|->
name|cd_bit
argument_list|,
name|Xparm2
operator|->
name|cd_bit
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:cd_bit bitstring different\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Xparm2
operator|->
name|cd_bit
operator|==
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: cd_bit decoded version missing\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
break|break;
undef|#
directive|undef
name|Xparm1
undef|#
directive|undef
name|Xparm2
endif|#
directive|endif
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"tcmp:unknown type %d\n"
argument_list|,
name|tynum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"tcmp:failed on %s\n"
argument_list|,
name|t_case
index|[
name|tynum
index|]
operator|.
name|tst_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|d
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Compare two possible null qbuf lists and return non zero if they are  * different  * Pretty complex to allow for all sorts of weird cases  * Doesn't work for a qbuf which doesn't have a head ! Don't really know what  * is the proper form of a queue buf. MArshall's doco doesn't say  */
end_comment

begin_macro
name|qb_cmp
argument_list|(
argument|qb1
argument_list|,
argument|qb2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|qbuf
modifier|*
name|qb1
decl_stmt|,
modifier|*
name|qb2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|qbuf
modifier|*
name|qp1
decl_stmt|,
modifier|*
name|qp2
decl_stmt|;
name|char
modifier|*
name|po1
decl_stmt|,
modifier|*
name|po2
decl_stmt|;
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
if|if
condition|(
name|qb1
operator|==
name|NULL
operator|&&
name|qb2
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|qb1
operator|==
name|NULL
operator|||
name|qb2
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|qp1
operator|=
name|qb1
operator|->
name|qb_forw
expr_stmt|;
name|qp2
operator|=
name|qb2
operator|->
name|qb_forw
expr_stmt|;
name|po1
operator|=
name|qp1
operator|->
name|qb_data
expr_stmt|;
name|po2
operator|=
name|qp2
operator|->
name|qb_data
expr_stmt|;
name|len1
operator|=
name|qp1
operator|->
name|qb_len
expr_stmt|;
name|len2
operator|=
name|qp2
operator|->
name|qb_len
expr_stmt|;
while|while
condition|(
name|qp1
operator|!=
name|qb1
operator|&&
name|qp2
operator|!=
name|qb2
condition|)
block|{
if|if
condition|(
name|len1
operator|<
name|len2
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|po1
argument_list|,
name|po2
argument_list|,
name|len1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|len2
operator|-=
name|len1
expr_stmt|;
name|po2
operator|+=
name|len1
expr_stmt|;
name|qp1
operator|=
name|qp1
operator|->
name|qb_forw
expr_stmt|;
name|po1
operator|=
name|qp1
operator|->
name|qb_data
expr_stmt|;
name|len1
operator|=
name|qp1
operator|->
name|qb_len
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|po1
argument_list|,
name|po2
argument_list|,
name|len1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|len1
operator|-=
name|len2
expr_stmt|;
name|po1
operator|+=
name|len2
expr_stmt|;
name|qp2
operator|=
name|qp2
operator|->
name|qb_forw
expr_stmt|;
name|po2
operator|=
name|qp2
operator|->
name|qb_data
expr_stmt|;
name|len2
operator|=
name|qp2
operator|->
name|qb_len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len1
operator|==
literal|0
condition|)
name|qp1
operator|=
name|qp1
operator|->
name|qb_forw
expr_stmt|;
if|if
condition|(
name|len2
operator|==
literal|0
condition|)
name|qp2
operator|=
name|qp2
operator|->
name|qb_forw
expr_stmt|;
while|while
condition|(
name|qp1
operator|!=
name|qb1
operator|&&
name|qp1
operator|->
name|qb_len
operator|==
literal|0
condition|)
name|qp1
operator|=
name|qp1
operator|->
name|qb_forw
expr_stmt|;
while|while
condition|(
name|qp2
operator|!=
name|qb2
operator|&&
name|qp2
operator|->
name|qb_len
operator|==
literal|0
condition|)
name|qp2
operator|=
name|qp2
operator|->
name|qb_forw
expr_stmt|;
if|if
condition|(
name|qp1
operator|==
name|qb1
operator|&&
name|qp2
operator|==
name|qb2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* perfect match */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * compare two bitstrings. Including the little bits left at the end but  * not the bits not in the strings  */
end_comment

begin_macro
name|bit_cmp
argument_list|(
argument|b1
argument_list|,
argument|b2
argument_list|)
end_macro

begin_decl_stmt
name|PE
name|b1
decl_stmt|,
name|b2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
if|if
condition|(
name|b1
operator|==
name|NULLPE
operator|&&
name|b2
operator|==
name|NULLPE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|b1
operator|==
name|NULLPE
operator|||
name|b2
operator|==
name|NULLPE
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|cp1
operator|=
name|bitstr2strb
argument_list|(
name|b1
argument_list|,
operator|&
name|len1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|cp2
operator|=
name|bitstr2strb
argument_list|(
name|b2
argument_list|,
operator|&
name|len2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cp1
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|len1
operator|!=
name|len2
operator|||
name|bcmp
argument_list|(
name|cp1
argument_list|,
name|cp2
argument_list|,
name|len1
operator|/
literal|8
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|cp1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|len1
operator|%
literal|8
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|mask
decl_stmt|;
comment|/* Check those last few bits */
name|i
operator|=
name|len1
operator|/
literal|8
expr_stmt|;
name|mask
operator|=
operator|(
literal|0xff00
operator|>>
name|len1
operator|%
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|cp1
index|[
name|i
index|]
operator|&
name|mask
operator|)
operator|!=
operator|(
name|cp2
index|[
name|i
index|]
operator|&
name|mask
operator|)
condition|)
block|{
name|free
argument_list|(
name|cp1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|free
argument_list|(
name|cp1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * compare to strings of given number of bits for equality  */
end_comment

begin_macro
name|bitstr_cmp
argument_list|(
argument|cp1
argument_list|,
argument|len1
argument_list|,
argument|cp2
argument_list|,
argument|len2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|len1
operator|!=
name|len2
operator|||
name|bcmp
argument_list|(
name|cp1
argument_list|,
name|cp2
argument_list|,
name|len1
operator|/
literal|8
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|len1
operator|%
literal|8
condition|)
block|{
comment|/* Check those last few bits */
name|i
operator|=
name|len1
operator|/
literal|8
expr_stmt|;
name|mask
operator|=
operator|(
literal|0xff00
operator|>>
name|len1
operator|%
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|cp1
index|[
name|i
index|]
operator|&
name|mask
operator|)
operator|!=
operator|(
name|cp2
index|[
name|i
index|]
operator|&
name|mask
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MKMASK
value|0x7
end_define

begin_define
define|#
directive|define
name|MKSHIFT
value|6
end_define

begin_comment
comment|/*  * Generate a randomish list of PElement s for use as ANY or SET  OF ANY ....  */
end_comment

begin_function
name|PE
name|mkpelist
parameter_list|(
name|i
parameter_list|)
block|{
name|PE
name|pe
decl_stmt|,
name|fpe
init|=
name|NULL
decl_stmt|;
name|fpe
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_PRIV
argument_list|,
name|PE_FORM_CONS
argument_list|,
operator|(
name|PElementID
operator|)
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|pe
operator|=
name|mkpe
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pe_next
operator|=
name|fpe
operator|->
name|pe_cons
expr_stmt|;
name|fpe
operator|->
name|pe_cons
operator|=
name|pe
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|fpe
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate a randomish PElement  */
end_comment

begin_function
name|PE
name|mkpe
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|int
name|id
decl_stmt|,
name|class
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|id
operator|=
name|i
operator|*
name|i
operator|+
literal|1
expr_stmt|;
name|class
operator|=
name|PE_CLASS_PRIV
expr_stmt|;
switch|switch
condition|(
operator|(
name|i
operator|*
name|i
operator|>>
name|MKSHIFT
operator|)
operator|&
name|MKMASK
condition|)
block|{
case|case
literal|5
case|:
case|case
literal|0
case|:
name|pe
operator|=
name|flag2prim
argument_list|(
name|i
operator|&
literal|0x1
argument_list|,
operator|(
name|PElementClass
operator|)
name|class
argument_list|,
operator|(
name|PElementID
operator|)
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|1
case|:
name|pe
operator|=
name|num2prim
argument_list|(
operator|(
name|integer
operator|)
name|i
argument_list|,
operator|(
name|PElementClass
operator|)
name|class
argument_list|,
operator|(
name|PElementID
operator|)
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
case|case
literal|2
case|:
name|pe
operator|=
name|str2prim
argument_list|(
literal|"mkpelist:testdata"
argument_list|,
literal|17
argument_list|,
operator|(
name|PElementClass
operator|)
name|class
argument_list|,
operator|(
name|PElementID
operator|)
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pe
operator|=
name|strb2bitstr
argument_list|(
literal|"\021\0245\375\0124"
argument_list|,
literal|4
argument_list|,
operator|(
name|PElementClass
operator|)
name|class
argument_list|,
operator|(
name|PElementID
operator|)
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|pe
operator|=
name|mkpelist
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"mkpelist:internal error %d case not handled\n"
argument_list|,
operator|(
name|i
operator|*
name|i
operator|>>
name|MKSHIFT
operator|)
operator|&
name|MKMASK
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pe
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OID_SIZE
value|6
end_define

begin_comment
comment|/*  * make an OID for testing  */
end_comment

begin_function
name|OID
name|mkoid
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|OID
name|oid
decl_stmt|;
name|int
name|oid_cnt
init|=
name|i
operator|%
name|OID_SIZE
decl_stmt|;
if|if
condition|(
operator|(
name|oid
operator|=
name|new
argument_list|(
expr|struct
name|OIDentifier
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"mkoid:calloc did not work\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|oid_cnt
operator|<
literal|2
condition|)
name|oid_cnt
operator|=
literal|2
expr_stmt|;
comment|/* At least two integers long */
name|oid
operator|->
name|oid_nelem
operator|=
name|oid_cnt
expr_stmt|;
if|if
condition|(
operator|(
name|oid
operator|->
name|oid_elements
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|oid_cnt
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"mkoid:calloc 2 did not work\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|oid_cnt
operator|>
literal|2
condition|)
block|{
name|oid
operator|->
name|oid_elements
index|[
name|oid_cnt
operator|-
literal|1
index|]
operator|=
name|oid_cnt
operator|*
name|i
operator|+
literal|33
expr_stmt|;
name|oid_cnt
operator|--
expr_stmt|;
block|}
name|oid
operator|->
name|oid_elements
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|oid
operator|->
name|oid_elements
index|[
literal|1
index|]
operator|=
literal|17
expr_stmt|;
return|return
operator|(
name|oid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Produce an External structure initialised to test values  * for testing EXTERNAL encoding routines  */
end_comment

begin_function
name|struct
name|type_UNIV_EXTERNAL
modifier|*
name|mkext
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|int
name|k
decl_stmt|;
name|struct
name|type_UNIV_EXTERNAL
modifier|*
name|p
decl_stmt|;
name|k
operator|=
name|i
operator|+
literal|2
expr_stmt|;
name|k
operator|*=
name|k
expr_stmt|;
comment|/* generate a more random looking number */
name|k
operator|%=
literal|51
expr_stmt|;
comment|/* Keep it in a reasonable bounds to avoid overflow */
if|if
condition|(
operator|(
name|p
operator|=
name|new
argument_list|(
expr|struct
name|type_UNIV_EXTERNAL
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|p
operator|->
name|encoding
operator|=
name|new
argument_list|(
expr|struct
name|choice_UNIV_0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"mkext:malloc:out of memory\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|0x1
condition|)
name|p
operator|->
name|direct__reference
operator|=
name|mkoid
argument_list|(
name|i
operator|*
literal|3
argument_list|)
expr_stmt|;
name|p
operator|->
name|indirect__reference
operator|=
name|k
operator|&
literal|0x7c
expr_stmt|;
name|p
operator|->
name|data__value__descriptor
operator|=
name|str2qb
argument_list|(
literal|"A very wild type of data"
argument_list|,
literal|25
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|encoding
operator|->
name|offset
operator|=
operator|(
name|k
operator|%
name|choice_UNIV_0_arbitrary
operator|)
operator|+
literal|1
condition|)
block|{
case|case
name|choice_UNIV_0_arbitrary
case|:
name|p
operator|->
name|encoding
operator|->
name|un
operator|.
name|single__ASN1__type
operator|=
name|mkpe
argument_list|(
name|k
operator|%
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_UNIV_0_single__ASN1__type
case|:
name|p
operator|->
name|encoding
operator|->
name|un
operator|.
name|single__ASN1__type
operator|=
name|mkpe
argument_list|(
name|k
operator|%
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
name|choice_UNIV_0_octet__aligned
case|:
name|p
operator|->
name|encoding
operator|->
name|un
operator|.
name|octet__aligned
operator|=
name|str2qb
argument_list|(
literal|"Some test data"
argument_list|,
literal|15
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"mkext:internal error: bad offset %d\n"
argument_list|,
name|p
operator|->
name|encoding
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * compare two external types to see if they are identical - return zero if  * they are and non zero if they are different  */
end_comment

begin_expr_stmt
name|ext_cmp
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
specifier|register
expr|struct
name|type_UNIV_EXTERNAL
operator|*
name|e1
operator|,
operator|*
name|e2
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|e1
operator|->
name|direct__reference
operator|!=
name|NULLOID
operator|&&
name|e2
operator|->
name|direct__reference
operator|!=
name|NULLOID
condition|)
block|{
if|if
condition|(
name|oid_cmp
argument_list|(
name|e1
operator|->
name|direct__reference
argument_list|,
name|e2
operator|->
name|direct__reference
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|e1
operator|->
name|direct__reference
operator|!=
name|NULLOID
operator|||
name|e2
operator|->
name|direct__reference
operator|!=
name|NULLOID
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|e1
operator|->
name|indirect__reference
operator|!=
name|e2
operator|->
name|indirect__reference
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|e1
operator|->
name|data__value__descriptor
operator|!=
name|NULLQB
operator|&&
name|e2
operator|->
name|data__value__descriptor
operator|!=
name|NULLQB
condition|)
block|{
if|if
condition|(
name|qb_cmp
argument_list|(
name|e1
operator|->
name|data__value__descriptor
argument_list|,
name|e2
operator|->
name|data__value__descriptor
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|e1
operator|->
name|data__value__descriptor
operator|!=
name|NULLQB
operator|||
name|e2
operator|->
name|data__value__descriptor
operator|!=
name|NULLQB
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|e1
operator|->
name|encoding
operator|==
name|NULL
operator|||
name|e2
operator|->
name|encoding
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|e1
operator|->
name|encoding
operator|->
name|offset
operator|!=
name|e2
operator|->
name|encoding
operator|->
name|offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|e1
operator|->
name|encoding
operator|->
name|offset
condition|)
block|{
case|case
name|choice_UNIV_0_single__ASN1__type
case|:
if|if
condition|(
name|e1
operator|->
name|encoding
operator|->
name|un
operator|.
name|single__ASN1__type
operator|==
name|NULLPE
operator|||
name|e2
operator|->
name|encoding
operator|->
name|un
operator|.
name|single__ASN1__type
operator|==
name|NULLPE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|pe_cmp
argument_list|(
name|e1
operator|->
name|encoding
operator|->
name|un
operator|.
name|single__ASN1__type
argument_list|,
name|e2
operator|->
name|encoding
operator|->
name|un
operator|.
name|single__ASN1__type
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|choice_UNIV_0_octet__aligned
case|:
if|if
condition|(
name|e1
operator|->
name|encoding
operator|->
name|un
operator|.
name|octet__aligned
operator|==
name|NULLQB
operator|||
name|e2
operator|->
name|encoding
operator|->
name|un
operator|.
name|octet__aligned
operator|==
name|NULLQB
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|qb_cmp
argument_list|(
name|e1
operator|->
name|encoding
operator|->
name|un
operator|.
name|octet__aligned
argument_list|,
name|e2
operator|->
name|encoding
operator|->
name|un
operator|.
name|octet__aligned
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|choice_UNIV_0_arbitrary
case|:
if|if
condition|(
name|e1
operator|->
name|encoding
operator|->
name|un
operator|.
name|arbitrary
operator|==
name|NULLPE
operator|||
name|e2
operator|->
name|encoding
operator|->
name|un
operator|.
name|arbitrary
operator|==
name|NULLPE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|pe_cmp
argument_list|(
name|e1
operator|->
name|encoding
operator|->
name|un
operator|.
name|arbitrary
argument_list|,
name|e2
operator|->
name|encoding
operator|->
name|un
operator|.
name|arbitrary
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"ext_cmp:illegal offset value %d\n"
argument_list|,
name|e1
operator|->
name|encoding
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * print the PE structure pointed to by pe  */
end_comment

begin_macro
name|print_pe
argument_list|(
argument|pe
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|PE
name|pe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pe
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
literal|4
operator|*
name|n
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_errno
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" errno = %d"
argument_list|,
name|pe
operator|->
name|pe_errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_class
operator|==
name|PE_CLASS_UNIV
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|idname
argument_list|(
operator|(
name|int
operator|)
name|pe
operator|->
name|pe_id
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pe
operator|->
name|pe_class
operator|==
name|PE_CLASS_CONT
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"[%d]"
argument_list|,
name|pe
operator|->
name|pe_id
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"[%s %d]"
argument_list|,
name|clname
argument_list|(
operator|(
name|int
operator|)
name|pe
operator|->
name|pe_class
argument_list|)
argument_list|,
name|pe
operator|->
name|pe_id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_form
operator|!=
literal|0x0
condition|)
block|{
if|if
condition|(
name|pe
operator|->
name|pe_cons
operator|!=
name|NULLPE
condition|)
name|print_pe
argument_list|(
name|pe
operator|->
name|pe_cons
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
literal|4
operator|*
name|n
argument_list|,
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pe
operator|->
name|pe_id
condition|)
block|{
case|case
name|PE_PRIM_BOOL
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|prim2flag
argument_list|(
name|pe
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_PRIM_INT
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|prim2num
argument_list|(
name|pe
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_PRIM_BITS
case|:
name|prntbits
argument_list|(
name|pe
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_PRIM_OCTS
case|:
operator|(
name|void
operator|)
name|prntos
argument_list|(
name|pe
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_PRIM_NULL
case|:
break|break;
case|case
name|PE_DEFN_NUMS
case|:
case|case
name|PE_DEFN_PRTS
case|:
case|case
name|PE_DEFN_T61S
case|:
case|case
name|PE_DEFN_VTXS
case|:
case|case
name|PE_DEFN_IA5S
case|:
case|case
name|PE_DEFN_GFXS
case|:
case|case
name|PE_DEFN_VISS
case|:
case|case
name|PE_DEFN_GENS
case|:
case|case
name|PE_DEFN_CHRS
case|:
operator|(
name|void
operator|)
name|prntstr
argument_list|(
name|pe
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_PRIM_OID
case|:
case|case
name|PE_CONS_EXTN
case|:
case|case
name|PE_PRIM_REAL
case|:
case|case
name|PE_PRIM_ENUM
case|:
case|case
name|PE_PRIM_ENCR
case|:
case|case
name|PE_CONS_SEQ
case|:
case|case
name|PE_CONS_SET
case|:
case|case
name|PE_DEFN_UTCT
case|:
case|case
name|PE_DEFN_GENT
case|:
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Unimplemented %d "
argument_list|,
name|pe
operator|->
name|pe_id
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe
operator|->
name|pe_next
operator|!=
name|NULLPE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s"
argument_list|,
literal|4
operator|*
name|n
argument_list|,
literal|"pe_next:\n"
argument_list|)
expr_stmt|;
name|print_pe
argument_list|(
name|pe
operator|->
name|pe_next
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * return the string describing that class  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|clname
parameter_list|(
name|cl
parameter_list|)
name|int
name|cl
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
switch|switch
condition|(
name|cl
condition|)
block|{
case|case
name|PE_CLASS_UNIV
case|:
name|p
operator|=
literal|"Universal"
expr_stmt|;
break|break;
case|case
name|PE_CLASS_APPL
case|:
name|p
operator|=
literal|"Application"
expr_stmt|;
break|break;
case|case
name|PE_CLASS_CONT
case|:
name|p
operator|=
literal|"Context"
expr_stmt|;
break|break;
case|case
name|PE_CLASS_PRIV
case|:
name|p
operator|=
literal|"Private"
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown Class %d"
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return the string describing that identity or the number itself  * Assuming a Universal class  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|idname
parameter_list|(
name|id
parameter_list|)
name|int
name|id
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|PE_PRIM_BOOL
case|:
name|p
operator|=
literal|"Boolean"
expr_stmt|;
break|break;
case|case
name|PE_PRIM_INT
case|:
name|p
operator|=
literal|"Integer"
expr_stmt|;
break|break;
case|case
name|PE_PRIM_BITS
case|:
name|p
operator|=
literal|"Bit String"
expr_stmt|;
break|break;
case|case
name|PE_PRIM_OCTS
case|:
name|p
operator|=
literal|"Octet String"
expr_stmt|;
break|break;
case|case
name|PE_PRIM_NULL
case|:
name|p
operator|=
literal|"Null"
expr_stmt|;
break|break;
case|case
name|PE_PRIM_OID
case|:
name|p
operator|=
literal|"Object Descriptor"
expr_stmt|;
break|break;
case|case
name|PE_CONS_EXTN
case|:
name|p
operator|=
literal|"External"
expr_stmt|;
break|break;
case|case
name|PE_PRIM_REAL
case|:
name|p
operator|=
literal|"Real"
expr_stmt|;
break|break;
case|case
name|PE_PRIM_ENUM
case|:
name|p
operator|=
literal|"Enumerated Type"
expr_stmt|;
break|break;
case|case
name|PE_PRIM_ENCR
case|:
name|p
operator|=
literal|"Encrypted Type"
expr_stmt|;
break|break;
case|case
name|PE_CONS_SEQ
case|:
name|p
operator|=
literal|"Sequence"
expr_stmt|;
break|break;
case|case
name|PE_CONS_SET
case|:
name|p
operator|=
literal|"Set"
expr_stmt|;
break|break;
case|case
name|PE_DEFN_NUMS
case|:
name|p
operator|=
literal|"Numeric String"
expr_stmt|;
break|break;
case|case
name|PE_DEFN_PRTS
case|:
name|p
operator|=
literal|"Printable String"
expr_stmt|;
break|break;
case|case
name|PE_DEFN_T61S
case|:
name|p
operator|=
literal|"T.61 String"
expr_stmt|;
break|break;
case|case
name|PE_DEFN_VTXS
case|:
name|p
operator|=
literal|"Videotex String"
expr_stmt|;
break|break;
case|case
name|PE_DEFN_IA5S
case|:
name|p
operator|=
literal|"IA5 String"
expr_stmt|;
break|break;
case|case
name|PE_DEFN_UTCT
case|:
name|p
operator|=
literal|"UTC Time"
expr_stmt|;
break|break;
case|case
name|PE_DEFN_GENT
case|:
name|p
operator|=
literal|"Generalised Time"
expr_stmt|;
break|break;
case|case
name|PE_DEFN_GFXS
case|:
name|p
operator|=
literal|"Graphics String"
expr_stmt|;
break|break;
case|case
name|PE_DEFN_VISS
case|:
name|p
operator|=
literal|"Visable String"
expr_stmt|;
break|break;
case|case
name|PE_DEFN_GENS
case|:
name|p
operator|=
literal|"General String"
expr_stmt|;
break|break;
case|case
name|PE_DEFN_CHRS
case|:
name|p
operator|=
literal|"Character String"
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown Universal %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print out the value of a bits string  */
end_comment

begin_expr_stmt
specifier|static
name|prntbits
argument_list|(
argument|pe
argument_list|)
name|PE
name|pe
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|pe
operator|->
name|pe_nbits
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"prntbits:Bad bistring\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Bits:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bit_test
argument_list|(
name|pe
argument_list|,
name|i
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Dump a bunch of hex digits printing out those that are printable  * Print out a given length of octets as hex (with the ASCII  * characters given if they have any  */
end_comment

begin_expr_stmt
specifier|static
name|pclen
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cnt
operator|%
literal|8
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%d:"
argument_list|,
name|cnt
operator|/
literal|8
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|s
operator|&
literal|0x7f
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%02x(%c)"
argument_list|,
operator|*
name|s
operator|&
literal|0xff
argument_list|,
operator|*
name|s
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%02x"
argument_list|,
operator|*
name|s
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print out an octet string  */
end_comment

begin_expr_stmt
specifier|static
name|prntos
argument_list|(
argument|pe
argument_list|)
name|PE
name|pe
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
if|if
condition|(
operator|(
name|qb
operator|=
name|prim2qb
argument_list|(
name|pe
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bad
label|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"prntos:bad octet string\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|qb_pullup
argument_list|(
name|qb
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|qb
operator|->
name|qb_forw
operator|->
name|qb_data
operator|==
name|NULL
operator|||
name|qb
operator|->
name|qb_forw
operator|->
name|qb_len
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
name|pclen
argument_list|(
name|qb
operator|->
name|qb_forw
operator|->
name|qb_data
argument_list|,
name|qb
operator|->
name|qb_forw
operator|->
name|qb_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * print out a string which should be printable  */
end_comment

begin_expr_stmt
specifier|static
name|prntstr
argument_list|(
argument|pe
argument_list|)
name|PE
name|pe
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
if|if
condition|(
operator|(
name|qb
operator|=
name|prim2qb
argument_list|(
name|pe
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bad
label|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"prntstr:bad string\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|qb_pullup
argument_list|(
name|qb
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|qb
operator|->
name|qb_forw
operator|->
name|qb_data
operator|==
name|NULL
operator|||
name|qb
operator|->
name|qb_forw
operator|->
name|qb_len
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\"%s\""
argument_list|,
name|qb
operator|->
name|qb_forw
operator|->
name|qb_data
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * build a link list of struct rep_int containing the speicified number of  * elements  */
end_comment

begin_function
name|struct
name|rep_int
modifier|*
name|mkrep_int
parameter_list|(
name|cnt
parameter_list|)
name|int
name|cnt
decl_stmt|;
block|{
name|struct
name|rep_int
modifier|*
name|hd
decl_stmt|,
modifier|*
name|tl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|hd
operator|=
name|NULLREP_INT
operator|,
name|tl
operator|=
name|NULL
init|;
name|cnt
operator|--
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|new
argument_list|(
expr|struct
name|rep_int
argument_list|)
operator|)
operator|==
name|NULLREP_INT
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"mkrep_int:malloc failed\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|i
operator|=
name|t_test
operator|*
name|cnt
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|tl
condition|)
block|{
name|tl
operator|->
name|r
operator|=
name|p
expr_stmt|;
name|tl
operator|=
name|p
expr_stmt|;
block|}
else|else
name|hd
operator|=
name|tl
operator|=
name|p
expr_stmt|;
block|}
return|return
operator|(
name|hd
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|test_str
index|[]
init|=
block|{
literal|"The quick"
block|,
literal|"brown"
block|,
literal|"fox jumps over"
block|,
literal|"The Lazy"
block|,
literal|"dog"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * build a link list of struct rep_elem containing the speicified number of  * elements  */
end_comment

begin_function
name|struct
name|rep_elem
modifier|*
name|mkrep_elem
parameter_list|(
name|cnt
parameter_list|)
name|int
name|cnt
decl_stmt|;
block|{
name|struct
name|rep_elem
modifier|*
name|hd
decl_stmt|,
modifier|*
name|tl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
for|for
control|(
name|str
operator|=
name|test_str
operator|,
name|hd
operator|=
name|NULLREP_ELEM
operator|,
name|tl
operator|=
name|NULL
init|;
name|cnt
operator|--
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|new
argument_list|(
expr|struct
name|rep_elem
argument_list|)
operator|)
operator|==
name|NULLREP_ELEM
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"mkrep_elem:malloc failed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
name|NULLCP
condition|)
name|str
operator|=
name|test_str
expr_stmt|;
name|p
operator|->
name|r_int
operator|=
name|t_test
operator|+
name|cnt
operator|+
literal|3
expr_stmt|;
name|p
operator|->
name|r_ostring
operator|=
name|strdup
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
name|p
operator|->
name|r_bstring
operator|=
name|strdup
argument_list|(
literal|"1234567890abcdefghijklmnopqrstuvwxyz"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl
condition|)
block|{
name|tl
operator|->
name|r_next
operator|=
name|p
expr_stmt|;
name|tl
operator|=
name|p
expr_stmt|;
block|}
else|else
name|hd
operator|=
name|tl
operator|=
name|p
expr_stmt|;
block|}
return|return
operator|(
name|hd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return non zero if the to lists are different - also  * prints a message about the difference found  */
end_comment

begin_macro
name|ri_cmp
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|rep_int
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|1
init|;
name|p1
operator|&&
name|p2
condition|;
name|cnt
operator|++
control|)
block|{
if|if
condition|(
name|p1
operator|->
name|i
operator|!=
name|p2
operator|->
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ri_cmp: Integers differ in %d item (%d != %d)\n"
argument_list|,
name|cnt
argument_list|,
name|p1
operator|->
name|i
argument_list|,
name|p2
operator|->
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p1
operator|=
name|p1
operator|->
name|r
expr_stmt|;
name|p2
operator|=
name|p2
operator|->
name|r
expr_stmt|;
block|}
if|if
condition|(
name|p1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ri_cmp: 1st list has more items (> %d)\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ri_cmp: 2nd list has more items (> %d)\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * return non zero if the to lists are different - also  * prints a message about the difference found  */
end_comment

begin_macro
name|re_cmp
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|rep_elem
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|1
init|;
name|p1
operator|&&
name|p2
condition|;
name|cnt
operator|++
control|)
block|{
if|if
condition|(
name|p1
operator|->
name|r_int
operator|!=
name|p2
operator|->
name|r_int
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"re_cmp: Integers differ in %d item (%d != %d)\n"
argument_list|,
name|cnt
argument_list|,
name|p1
operator|->
name|r_int
argument_list|,
name|p2
operator|->
name|r_int
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|p1
operator|->
name|r_ostring
argument_list|,
name|p2
operator|->
name|r_ostring
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"re_cmp: strings differ in %d item (%s != %s)\n"
argument_list|,
name|cnt
argument_list|,
name|p1
operator|->
name|r_ostring
argument_list|,
name|p2
operator|->
name|r_ostring
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bitscmp
argument_list|(
name|p1
operator|->
name|r_bstring
argument_list|,
name|p2
operator|->
name|r_bstring
argument_list|,
name|p1
operator|->
name|r_int
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"re_cmp: bit strings differ in %d item\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p1
operator|=
name|p1
operator|->
name|r_next
expr_stmt|;
name|p2
operator|=
name|p2
operator|->
name|r_next
expr_stmt|;
block|}
if|if
condition|(
name|p1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"re_cmp: 1st list has more items (> %d)\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"re_cmp: 2nd list has more items (> %d)\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

