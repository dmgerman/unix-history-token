begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* util.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/pepsy/RCS/util.c,v 7.7 91/02/22 09:50:13 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/pepsy/RCS/util.c,v 7.7 91/02/22 09:50:13 mrose Interim $  *  *  * $Log:	util.c,v $  * Revision 7.7  91/02/22  09:50:13  mrose  * Interim 6.8  *   * Revision 7.6  90/12/11  10:41:13  mrose  * sync  *   * Revision 7.5  90/11/04  19:21:19  mrose  * update  *   * Revision 7.4  90/10/23  20:43:20  mrose  * update  *   * Revision 7.3  90/08/18  00:44:30  mrose  * touch-up  *   * Revision 7.2  90/08/08  14:14:45  mrose  * update  *   * Revision 7.1  90/07/09  14:53:23  mrose  * sync  *   * Revision 7.0  90/07/01  19:54:33  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pepsy-driver.h"
end_include

begin_include
include|#
directive|include
file|"psap.h"
end_include

begin_include
include|#
directive|include
file|"pepsy.h"
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PEPYPARM
end_ifndef

begin_define
define|#
directive|define
name|PEPYPARM
value|char *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|char
modifier|*
name|pr_petype
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_comment
comment|/* VARARGS4 */
end_comment

begin_function
name|int
name|pepsylose
parameter_list|(
name|module
parameter_list|,
name|p
parameter_list|,
name|pe
parameter_list|,
name|str
parameter_list|)
name|modtyp
modifier|*
name|module
decl_stmt|;
name|tpe
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|PE
name|pe
decl_stmt|;
block|{
return|return
name|pepsylose
argument_list|(
name|module
argument_list|,
name|p
argument_list|,
name|pe
argument_list|,
name|str
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|pepsylose
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|type
decl_stmt|;
name|modtyp
modifier|*
name|module
decl_stmt|;
name|tpe
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|module
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|modtyp
operator|*
argument_list|)
expr_stmt|;
name|p
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|tpe
operator|*
argument_list|)
expr_stmt|;
name|pe
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|PE
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"%s: module %s"
argument_list|,
name|buffer
argument_list|,
name|module
condition|?
name|module
operator|->
name|md_name
else|:
literal|"<none>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|cp
operator|=
name|PY_pepy
operator|+
name|strlen
argument_list|(
name|PY_pepy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" %s/class=%s/id=%d"
argument_list|,
name|pr_petype
argument_list|(
name|p
operator|->
name|pe_type
argument_list|)
argument_list|,
name|pe_classlist
index|[
name|p
operator|->
name|pe_flags
operator|&
name|FL_CLASS
index|]
argument_list|,
name|p
operator|->
name|pe_tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe
operator|&&
name|pe
operator|->
name|pe_class
operator|>=
literal|0
operator|&&
name|pe
operator|->
name|pe_class
operator|<
name|pe_maxclass
condition|)
block|{
name|cp
operator|=
name|PY_pepy
operator|+
name|strlen
argument_list|(
name|PY_pepy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" got %s/%d"
argument_list|,
name|pe_classlist
index|[
name|pe
operator|->
name|pe_class
index|]
argument_list|,
name|pe
operator|->
name|pe_id
argument_list|)
expr_stmt|;
block|}
name|SLOG
argument_list|(
name|psap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"%s"
operator|,
name|PY_pepy
operator|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_comment
comment|/* VARARGS4 */
end_comment

begin_function
name|int
name|ppepsylose
parameter_list|(
name|module
parameter_list|,
name|p
parameter_list|,
name|pe
parameter_list|,
name|str
parameter_list|)
name|modtyp
modifier|*
name|module
decl_stmt|;
name|ptpe
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|PE
name|pe
decl_stmt|;
block|{
return|return
name|ppepsylose
argument_list|(
name|module
argument_list|,
name|p
argument_list|,
name|pe
argument_list|,
name|str
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|ppepsylose
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|type
decl_stmt|;
name|modtyp
modifier|*
name|module
decl_stmt|;
name|ptpe
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|module
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|modtyp
operator|*
argument_list|)
expr_stmt|;
name|p
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|ptpe
operator|*
argument_list|)
expr_stmt|;
name|pe
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|PE
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|PY_pepy
argument_list|,
literal|"%s: module %s"
argument_list|,
name|buffer
argument_list|,
name|module
condition|?
name|module
operator|->
name|md_name
else|:
literal|"<none>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|cp
operator|=
name|PY_pepy
operator|+
name|strlen
argument_list|(
name|PY_pepy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" %s/class=%s/id=%d"
argument_list|,
name|pr_petype
argument_list|(
name|p
operator|->
name|pe_type
argument_list|)
argument_list|,
name|pe_classlist
index|[
name|p
operator|->
name|pe_flags
operator|&
name|FL_CLASS
index|]
argument_list|,
name|p
operator|->
name|pe_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pe_typename
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"(%s)"
argument_list|,
name|p
operator|->
name|pe_typename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe
operator|&&
name|pe
operator|->
name|pe_class
operator|>=
literal|0
operator|&&
name|pe
operator|->
name|pe_class
operator|<
name|pe_maxclass
condition|)
block|{
name|cp
operator|=
name|PY_pepy
operator|+
name|strlen
argument_list|(
name|PY_pepy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|" got %s/%d"
argument_list|,
name|pe_classlist
index|[
name|pe
operator|->
name|pe_class
index|]
argument_list|,
name|pe
operator|->
name|pe_id
argument_list|)
expr_stmt|;
block|}
name|SLOG
argument_list|(
name|psap_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
operator|(
literal|"%s"
operator|,
name|PY_pepy
operator|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Useful little routines  */
end_comment

begin_comment
comment|/*  * print out the message and if the arguement is greater than 0  * terminate  */
end_comment

begin_macro
name|ferr
argument_list|(
argument|n
argument_list|,
argument|mesg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|mesg
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|exit
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print out the message and number and if the arguement is greater  * than 0 terminate  */
end_comment

begin_macro
name|ferrd
argument_list|(
argument|n
argument_list|,
argument|mesg
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
name|mesg
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|exit
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * 0 = Encoding table, 1 = Decoding table, 2 = Printing table  */
end_comment

begin_define
define|#
directive|define
name|TYP_ENC
value|0
end_define

begin_define
define|#
directive|define
name|TYP_DEC
value|1
end_define

begin_define
define|#
directive|define
name|TYP_PRINT
value|2
end_define

begin_define
define|#
directive|define
name|TYP_LAST
value|2
end_define

begin_macro
name|dmp_tpe
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|,
argument|mod
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|modtyp
modifier|*
name|mod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module it is from */
end_comment

begin_decl_stmt
name|tpe
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|typ
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|tpe
modifier|*
modifier|*
name|par
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: (%s)"
argument_list|,
name|s
argument_list|,
name|mod
operator|->
name|md_name
argument_list|)
expr_stmt|;
comment|/*      * Calculate what table it is in - we assume they are in order of      * increasing address      */
name|par
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|typ
operator|=
literal|0
init|;
name|typ
operator|<=
name|TYP_LAST
condition|;
name|typ
operator|++
control|)
block|{
switch|switch
condition|(
name|typ
condition|)
block|{
case|case
name|TYP_ENC
case|:
if|if
condition|(
name|mod
operator|->
name|md_etab
operator|!=
name|NULL
operator|&&
name|mod
operator|->
name|md_etab
index|[
literal|0
index|]
operator|<
name|p
condition|)
block|{
name|par
operator|=
name|mod
operator|->
name|md_etab
expr_stmt|;
name|name
operator|=
literal|"Encoding:"
expr_stmt|;
block|}
break|break;
case|case
name|TYP_DEC
case|:
if|if
condition|(
name|mod
operator|->
name|md_dtab
operator|!=
name|NULL
operator|&&
name|mod
operator|->
name|md_dtab
index|[
literal|0
index|]
operator|<
name|p
condition|)
block|{
name|par
operator|=
name|mod
operator|->
name|md_dtab
expr_stmt|;
name|name
operator|=
literal|"Decoding:"
expr_stmt|;
block|}
break|break;
case|case
name|TYP_PRINT
case|:
if|if
condition|(
name|mod
operator|->
name|md_ptab
operator|!=
name|NULL
operator|&&
name|mod
operator|->
name|md_ptab
index|[
literal|0
index|]
operator|<
operator|(
name|ptpe
operator|*
operator|)
name|p
condition|)
block|{
operator|(
name|ptpe
operator|*
operator|*
operator|)
name|par
operator|=
name|mod
operator|->
name|md_ptab
expr_stmt|;
name|name
operator|=
literal|"Printing:"
expr_stmt|;
block|}
break|break;
default|default:
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"dmp_tpe:typ = %d internal error\n"
argument_list|,
name|typ
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|par
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"can't find entry 0x%x\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev
operator|=
name|par
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mod
operator|->
name|md_nentries
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|par
operator|>
name|p
condition|)
break|break;
name|par
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|par
operator|==
name|prev
condition|)
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"dmp_tpe:par == prev == 0x%x internal error\n"
argument_list|,
operator|(
name|int
operator|)
name|par
argument_list|)
expr_stmt|;
name|par
operator|--
expr_stmt|;
name|j
operator|=
name|p
operator|-
operator|*
name|par
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s type %d + %d "
argument_list|,
name|name
argument_list|,
name|par
operator|-
name|prev
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|pr_entry
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|NENTRY
parameter_list|(
name|x
parameter_list|)
value|((sizeof (x)/sizeof (x[0])))
end_define

begin_comment
comment|/*  * Print out a tpe entry  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ntypes
index|[]
init|=
block|{
literal|"PE_START"
block|,
literal|"PE_END"
block|,
literal|"illegal 1"
block|,
literal|"illegal 2"
block|,
literal|"XOBJECT"
block|,
literal|"illegal 4"
block|,
literal|"illegal 5"
block|,
literal|"UCODE"
block|,
literal|"MALLOC"
block|,
literal|"SCTRL"
block|,
literal|"CH_ACT"
block|,
literal|"OPTL"
block|,
literal|"BOPTIONAL"
block|,
literal|"FFN_CALL"
block|,}
decl_stmt|,
modifier|*
name|otypes
index|[]
init|=
block|{
literal|"ANY"
block|,
literal|"INTEGER"
block|,
literal|"BOOLEAN"
block|,
literal|"OBJECT"
block|,
literal|"BITSTRING"
block|,
literal|"OCTETSTRING"
block|,
literal|"SET_START"
block|,
literal|"SEQ_START"
block|,
literal|"SEQOF_START"
block|,
literal|"SETOF_START"
block|,
literal|"CHOICE_START"
block|,
literal|"UNKNOWN"
block|,
literal|"T_NULL"
block|,
literal|"T_OID"
block|,
literal|"ETAG"
block|,
literal|"IMP_OBJ"
block|,
literal|"EXTOBJ"
block|,
literal|"EXTMOD"
block|,
literal|"OBJID"
block|,
literal|"DFLT_F"
block|,
literal|"DFLT_B"
block|,
literal|"T_STRING"
block|,
literal|"OCTET_PTR"
block|,
literal|"OCTET_LEN"
block|,
literal|"BITSTR_PTR"
block|,
literal|"BITSTR_LEN"
block|,
literal|"FN_CALL"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|pr_petype
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|nbuf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|PE_START
operator|&&
name|type
operator|<
name|NENTRY
argument_list|(
name|ntypes
argument_list|)
operator|-
literal|1
condition|)
return|return
name|ntypes
index|[
name|type
operator|+
literal|1
index|]
return|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|TYPE_DATA
operator|&&
name|type
operator|<
name|NENTRY
argument_list|(
name|otypes
argument_list|)
operator|+
name|TYPE_DATA
condition|)
return|return
name|otypes
index|[
name|type
operator|-
name|TYPE_DATA
index|]
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"%d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|nbuf
return|;
block|}
end_function

begin_macro
name|pr_entry
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|tpe
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s, "
argument_list|,
name|pr_petype
argument_list|(
name|p
operator|->
name|pe_type
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d, %d, %d}\n"
argument_list|,
name|p
operator|->
name|pe_ucode
argument_list|,
name|p
operator|->
name|pe_tag
argument_list|,
name|p
operator|->
name|pe_flags
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p_pr_entry
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|ptpe
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|->
name|pe_type
operator|>=
name|PE_START
operator|&&
name|p
operator|->
name|pe_type
operator|<
name|NENTRY
argument_list|(
name|ntypes
argument_list|)
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"{%s, "
argument_list|,
name|ntypes
index|[
name|p
operator|->
name|pe_type
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|pe_type
operator|>=
name|TYPE_DATA
operator|&&
name|p
operator|->
name|pe_type
operator|<
name|NENTRY
argument_list|(
name|otypes
argument_list|)
operator|+
name|TYPE_DATA
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"{%s, "
argument_list|,
name|otypes
index|[
name|p
operator|->
name|pe_type
operator|-
name|TYPE_DATA
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"{%d, "
argument_list|,
name|p
operator|->
name|pe_type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d, %d, %d}\n"
argument_list|,
name|p
operator|->
name|pe_ucode
argument_list|,
name|p
operator|->
name|pe_tag
argument_list|,
name|p
operator|->
name|pe_flags
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * null function for what evr purposes  */
end_comment

begin_macro
name|f_null
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|/*  * compare a given number of bits pointed to by the two character  * pointers return 0 if they are the same non zero otherwise  */
end_comment

begin_expr_stmt
name|bitscmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|p1
operator|,
operator|*
name|p2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|len
operator|>=
literal|8
operator|&&
name|bcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len
operator|/
literal|8
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|len
operator|%
literal|8
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check those last few bits */
name|i
operator|=
name|len
operator|/
literal|8
expr_stmt|;
name|mask
operator|=
operator|(
literal|0xff00
operator|>>
name|len
operator|%
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|p1
index|[
name|i
index|]
operator|&
name|mask
operator|)
operator|!=
operator|(
name|p2
index|[
name|i
index|]
operator|&
name|mask
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a< b ? a : b)
end_define

begin_comment
comment|/*  * compare an octet string and a qb and return 0 if they are the same  * and non zero otherwise  */
end_comment

begin_expr_stmt
name|ostrcmp
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|qb
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|qbuf
modifier|*
name|qp
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|qb
operator|==
name|NULL
operator|||
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|qp
operator|=
name|qb
expr_stmt|;
do|do
block|{
if|if
condition|(
name|qp
operator|->
name|qb_data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|qb_len
operator|<
literal|0
condition|)
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"ostrcmp:qb_len %d< 0"
argument_list|,
name|qp
operator|->
name|qb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|qb_len
operator|>
name|len
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|bcmp
argument_list|(
name|qp
operator|->
name|qb_data
argument_list|,
name|p
argument_list|,
name|qp
operator|->
name|qb_len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|len
operator|-=
name|qp
operator|->
name|qb_len
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|+=
name|qp
operator|->
name|qb_len
expr_stmt|;
block|}
name|qp
operator|=
name|qp
operator|->
name|qb_forw
expr_stmt|;
block|}
do|while
condition|(
name|qp
operator|!=
name|qb
condition|)
do|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Is data present for the optional item? 1 for yes 0 for no  */
end_comment

begin_macro
name|hasdata
argument_list|(
argument|parm
argument_list|,
argument|p
argument_list|,
argument|mod
argument_list|,
argument|popt
argument_list|,
argument|optcnt
argument_list|)
end_macro

begin_decl_stmt
name|PEPYPARM
name|parm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tpe
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|modtyp
modifier|*
name|mod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module it is from */
end_comment

begin_decl_stmt
name|int
modifier|*
name|popt
decl_stmt|,
name|optcnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|pe_type
condition|)
block|{
case|case
name|INTEGER
case|:
case|case
name|REALTYPE
case|:
case|case
name|BOOLEAN
case|:
case|case
name|T_NULL
case|:
if|if
condition|(
name|DEFAULT
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* Default's don't have bit map */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|.
name|pe_type
operator|==
name|DFLT_B
operator|&&
name|same
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|parm
argument_list|,
name|mod
argument_list|)
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|.
name|pe_type
operator|==
name|DFLT_F
operator|&&
name|same
argument_list|(
name|p
argument_list|,
name|p
operator|-
literal|1
argument_list|,
name|parm
argument_list|,
name|mod
argument_list|)
condition|)
goto|goto
name|next
goto|;
break|break;
block|}
if|if
condition|(
operator|!
name|TESTBIT
argument_list|(
operator|*
name|popt
argument_list|,
name|optcnt
operator|++
argument_list|)
condition|)
goto|goto
name|next
goto|;
comment|/* Missing so skip */
break|break;
case|case
name|ETAG
case|:
if|if
condition|(
operator|!
name|hasdata
argument_list|(
name|parm
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|mod
argument_list|,
name|popt
argument_list|,
name|optcnt
argument_list|)
condition|)
goto|goto
name|next
goto|;
break|break;
case|case
name|IMP_OBJ
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|.
name|pe_type
operator|==
name|SOBJECT
operator|&&
name|parm
operator|==
name|NULL
operator|||
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
index|[
literal|1
index|]
operator|.
name|pe_ucode
operator|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|next
goto|;
break|break;
case|case
name|FN_CALL
case|:
comment|/* function call */
if|if
condition|(
operator|(
name|val
operator|=
operator|(
name|FN_PTR
argument_list|(
name|mod
argument_list|,
name|p
argument_list|)
operator|)
operator|(
name|parm
operator|,
operator|(
name|PE
operator|*
operator|)
literal|0
operator|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"hasdata:FN_CALL:call failed"
argument_list|)
return|;
if|if
condition|(
name|val
operator|!=
name|OK
condition|)
goto|goto
name|next
goto|;
break|break;
default|default:
if|if
condition|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|next
goto|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|next
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * determine if the default value is the same as the value in the  * structure and if so return greater than zero (meaning don't encode this  * item). On error return NOTOK  */
end_comment

begin_macro
name|same
argument_list|(
argument|typ
argument_list|,
argument|dflt
argument_list|,
argument|parm
argument_list|,
argument|mod
argument_list|)
end_macro

begin_decl_stmt
name|tpe
modifier|*
name|typ
decl_stmt|,
modifier|*
name|dflt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|parm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|modtyp
modifier|*
name|mod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module it is from */
end_comment

begin_block
block|{
name|int
name|val
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
switch|switch
condition|(
name|typ
operator|->
name|pe_type
condition|)
block|{
case|case
name|INTEGER
case|:
name|val
operator|=
name|IVAL
argument_list|(
name|mod
argument_list|,
name|dflt
argument_list|)
operator|==
operator|*
operator|(
name|integer
operator|*
operator|)
operator|(
name|parm
operator|+
name|typ
operator|->
name|pe_ucode
operator|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|PEPSY_REALS
case|case
name|REALTYPE
case|:
name|val
operator|=
name|RVAL
argument_list|(
name|mod
argument_list|,
name|dflt
argument_list|)
operator|==
operator|*
operator|(
name|double
operator|*
operator|)
operator|(
name|parm
operator|+
name|typ
operator|->
name|pe_ucode
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|BOOLEAN
case|:
name|val
operator|=
name|IVAL
argument_list|(
name|mod
argument_list|,
name|dflt
argument_list|)
operator|==
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
name|parm
operator|+
name|typ
operator|->
name|pe_ucode
operator|)
expr_stmt|;
break|break;
case|case
name|T_NULL
case|:
name|val
operator|=
literal|1
expr_stmt|;
comment|/* Only one value */
break|break;
case|case
name|SBITSTRING
case|:
if|if
condition|(
operator|(
name|pe
operator|=
operator|(
name|PE
operator|)
name|parm
operator|)
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
goto|goto
name|bstring
goto|;
case|case
name|BITSTRING
case|:
if|if
condition|(
operator|(
name|pe
operator|=
operator|*
operator|(
name|PE
operator|*
operator|)
operator|(
name|parm
operator|+
name|typ
operator|->
name|pe_ucode
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|bstring
label|:
if|if
condition|(
operator|(
name|p1
operator|=
name|bitstr2strb
argument_list|(
name|pe
argument_list|,
operator|&
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|typ
argument_list|,
name|pe
argument_list|,
literal|"same:bad bitstring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
comment|/* Should really abort encoding here but how can we comunicate this 	     * to the routine that calls us? 	     */
block|}
name|bstring2
label|:
if|if
condition|(
name|val
operator|!=
name|IVAL
argument_list|(
name|mod
argument_list|,
name|dflt
argument_list|)
operator|||
name|bitscmp
argument_list|(
name|PVAL
argument_list|(
name|mod
argument_list|,
name|dflt
argument_list|)
argument_list|,
name|p1
argument_list|,
name|val
argument_list|)
condition|)
name|val
operator|=
literal|0
expr_stmt|;
else|else
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|typ
operator|->
name|pe_type
operator|!=
name|BITSTR_PTR
condition|)
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BITSTR_PTR
case|:
if|if
condition|(
name|typ
index|[
literal|1
index|]
operator|.
name|pe_type
operator|!=
name|BITSTR_LEN
condition|)
return|return
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|typ
argument_list|,
name|pe
argument_list|,
literal|"same:missing BITSTR_LEN\n"
argument_list|)
return|;
if|if
condition|(
operator|(
name|p1
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|typ
operator|->
name|pe_ucode
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|val
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|parm
operator|+
operator|(
name|typ
operator|+
literal|1
operator|)
operator|->
name|pe_ucode
operator|)
expr_stmt|;
goto|goto
name|bstring2
goto|;
case|case
name|SOCTETSTRING
case|:
if|if
condition|(
operator|(
name|qb
operator|=
operator|(
expr|struct
name|qbuf
operator|*
operator|)
name|parm
operator|)
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
goto|goto
name|ostring
goto|;
case|case
name|OCTETSTRING
case|:
if|if
condition|(
operator|(
name|qb
operator|=
operator|*
operator|(
expr|struct
name|qbuf
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|typ
operator|->
name|pe_ucode
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ostring
label|:
if|if
condition|(
name|ostrcmp
argument_list|(
name|PVAL
argument_list|(
name|mod
argument_list|,
name|dflt
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|IVAL
argument_list|(
name|mod
argument_list|,
name|dflt
argument_list|)
argument_list|,
name|qb
argument_list|)
condition|)
name|val
operator|=
literal|0
expr_stmt|;
else|else
name|val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OCTET_PTR
case|:
if|if
condition|(
name|typ
index|[
literal|1
index|]
operator|.
name|pe_type
operator|!=
name|OCTET_LEN
condition|)
return|return
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|typ
argument_list|,
name|pe
argument_list|,
literal|"same:missing OCTET_LEN\n"
argument_list|)
return|;
if|if
condition|(
operator|(
name|p1
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|typ
operator|->
name|pe_ucode
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|len
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|parm
operator|+
operator|(
name|typ
operator|+
literal|1
operator|)
operator|->
name|pe_ucode
operator|)
expr_stmt|;
goto|goto
name|o1string
goto|;
case|case
name|T_STRING
case|:
if|if
condition|(
operator|(
name|p1
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|typ
operator|->
name|pe_ucode
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|o1string
label|:
if|if
condition|(
name|len
operator|!=
name|IVAL
argument_list|(
name|mod
argument_list|,
name|dflt
argument_list|)
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|PVAL
argument_list|(
name|mod
argument_list|,
name|dflt
argument_list|)
argument_list|,
name|p1
argument_list|,
name|len
argument_list|)
condition|)
name|val
operator|=
literal|0
expr_stmt|;
else|else
name|val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OBJECT
case|:
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|typ
operator|->
name|pe_ucode
operator|)
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
comment|/* to conform with pepy's way of 				 * doing default */
break|break;
block|}
name|val
operator|=
name|same
argument_list|(
name|mod
operator|->
name|md_etab
index|[
name|typ
operator|->
name|pe_tag
index|]
operator|+
literal|1
argument_list|,
name|dflt
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|typ
operator|->
name|pe_ucode
operator|)
argument_list|,
name|mod
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOBJECT
case|:
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
literal|1
expr_stmt|;
comment|/* to conform with pepy's way of 				 * doing default */
break|break;
block|}
name|val
operator|=
name|same
argument_list|(
name|mod
operator|->
name|md_etab
index|[
name|typ
operator|->
name|pe_tag
index|]
operator|+
literal|1
argument_list|,
name|dflt
argument_list|,
name|parm
argument_list|,
name|mod
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMP_OBJ
case|:
name|typ
operator|++
expr_stmt|;
comment|/* fall through */
case|case
name|ANY
case|:
case|case
name|SANY
case|:
case|case
name|SEXTOBJ
case|:
case|case
name|EXTOBJ
case|:
case|case
name|OBJID
case|:
case|case
name|SOBJID
case|:
case|case
name|SEQ_START
case|:
case|case
name|SET_START
case|:
case|case
operator|-
literal|1
case|:
comment|/* Just use the pepy method of null 				 * pointers */
comment|/* 	 * This is the posy/pepy hack way of doing things at the 	 * moment 	 */
name|val
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|typ
operator|->
name|pe_ucode
operator|)
operator|==
name|NULL
expr_stmt|;
break|break;
case|case
name|FN_CALL
case|:
comment|/* function call */
if|if
condition|(
operator|(
name|val
operator|=
operator|(
name|FN_PTR
argument_list|(
name|mod
argument_list|,
name|typ
argument_list|)
operator|)
operator|(
name|parm
operator|,
operator|(
name|PE
operator|*
operator|)
literal|0
operator|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|typ
argument_list|,
name|NULLPE
argument_list|,
literal|"same:FN_CALL:call failed"
argument_list|)
return|;
if|if
condition|(
name|val
operator|!=
name|OK
condition|)
name|val
operator|=
literal|1
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|typ
argument_list|,
name|NULLPE
argument_list|,
literal|"same: %d not implemented\n"
argument_list|,
name|typ
operator|->
name|pe_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the next tpe entry in the sequence. Count a sequence as  * one element  */
end_comment

begin_function
name|tpe
modifier|*
name|next_tpe
parameter_list|(
name|p
parameter_list|)
name|tpe
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|level
decl_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pe_type
operator|==
name|PE_END
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|NULLMODTYP
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"next_tpe:internal error: unexpected PE_END found"
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
do|do
block|{
name|again
label|:
switch|switch
condition|(
name|p
operator|->
name|pe_type
condition|)
block|{
case|case
name|SSEQ_START
case|:
case|case
name|SSEQOF_START
case|:
case|case
name|SSET_START
case|:
case|case
name|SSETOF_START
case|:
case|case
name|SCHOICE_START
case|:
case|case
name|SEQ_START
case|:
case|case
name|SEQOF_START
case|:
case|case
name|SET_START
case|:
case|case
name|SETOF_START
case|:
case|case
name|CHOICE_START
case|:
name|level
operator|++
expr_stmt|;
break|break;
case|case
name|UCODE
case|:
case|case
name|MEMALLOC
case|:
case|case
name|SCTRL
case|:
case|case
name|CH_ACT
case|:
case|case
name|INTEGER
case|:
case|case
name|REALTYPE
case|:
case|case
name|BOOLEAN
case|:
case|case
name|SANY
case|:
case|case
name|ANY
case|:
case|case
name|T_NULL
case|:
case|case
name|OBJECT
case|:
case|case
name|SOBJECT
case|:
case|case
name|BITSTRING
case|:
case|case
name|BITSTR_LEN
case|:
case|case
name|SBITSTRING
case|:
case|case
name|OCTETSTRING
case|:
case|case
name|T_STRING
case|:
case|case
name|OCTET_LEN
case|:
case|case
name|SOCTETSTRING
case|:
case|case
name|OBJID
case|:
case|case
name|SOBJID
case|:
case|case
name|OPTL
case|:
case|case
name|EXTMOD
case|:
case|case
name|DFLT_B
case|:
case|case
name|FN_CALL
case|:
case|case
name|FFN_CALL
case|:
break|break;
case|case
name|IMP_OBJ
case|:
case|case
name|ETAG
case|:
case|case
name|EXTOBJ
case|:
case|case
name|SEXTOBJ
case|:
case|case
name|DFLT_F
case|:
case|case
name|OCTET_PTR
case|:
case|case
name|BITSTR_PTR
case|:
case|case
name|BOPTIONAL
case|:
case|case
name|FREE_ONLY
case|:
name|p
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|PE_END
case|:
name|level
operator|--
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"next_tpe: unknown type %d\n"
argument_list|,
name|p
operator|->
name|pe_type
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|level
operator|>
literal|0
operator|||
name|p
operator|->
name|pe_type
operator|==
name|DFLT_B
condition|)
do|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is there a match at for this tag and class pair. Return 1 if yes 0  * if no We will search through contained objects and through choices  */
end_comment

begin_macro
name|ismatch
argument_list|(
argument|p
argument_list|,
argument|mod
argument_list|,
argument|cl
argument_list|,
argument|tag
argument_list|)
end_macro

begin_decl_stmt
name|tpe
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|modtyp
modifier|*
name|mod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module it is from */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|cl
decl_stmt|,
name|tag
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|!
name|ISDTYPE
argument_list|(
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|pe_type
condition|)
block|{
case|case
name|SOBJECT
case|:
case|case
name|OBJECT
case|:
comment|/* Needs to be changed for optional and default */
return|return
operator|(
name|ismatch
argument_list|(
name|p
operator|=
name|mod
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
operator|+
literal|1
argument_list|,
name|mod
argument_list|,
name|cl
argument_list|,
name|tag
argument_list|)
operator|)
return|;
case|case
name|SEXTOBJ
case|:
case|case
name|EXTOBJ
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|.
name|pe_type
operator|!=
name|EXTMOD
condition|)
block|{
name|dmp_tpe
argument_list|(
literal|"ismatch: missing EXTMOD"
argument_list|,
name|p
argument_list|,
name|mod
argument_list|)
expr_stmt|;
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"ismatch:internal error\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ismatch
argument_list|(
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
operator|+
literal|1
argument_list|,
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|cl
argument_list|,
name|tag
argument_list|)
operator|)
return|;
case|case
name|CHOICE_START
case|:
case|case
name|SCHOICE_START
case|:
for|for
control|(
name|p
operator|++
init|;
name|p
operator|->
name|pe_type
operator|!=
name|PE_END
condition|;
name|p
operator|=
name|next_tpe
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|ISDTYPE
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ismatch
argument_list|(
name|p
argument_list|,
name|mod
argument_list|,
name|cl
argument_list|,
name|tag
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SANY
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|FN_CALL
case|:
case|case
name|ANY
case|:
if|if
condition|(
name|STAG
argument_list|(
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* else fall through - not sure if this is needed */
default|default:
return|return
operator|(
name|tag
operator|==
name|TAG
argument_list|(
name|p
argument_list|)
operator|&&
name|cl
operator|==
name|CLASS
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * find the data entry that goes with this DFLT_F entry  * bascially skip over any ETAGS that (an arbitary number but almost always 1)  */
end_comment

begin_function
name|tpe
modifier|*
name|fdflt_f
parameter_list|(
name|p
parameter_list|)
specifier|register
name|tpe
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|pe_type
operator|!=
name|DFLT_F
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"fdlt_f:Internal Error missing DFLT_F\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|++
init|;
name|p
operator|->
name|pe_type
operator|!=
name|PE_END
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|pe_type
operator|!=
name|ETAG
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"fdlt_f:Internal Error PE_END found\n"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * find the DFLT_B entry  */
end_comment

begin_function
name|tpe
modifier|*
name|fdflt_b
parameter_list|(
name|p
parameter_list|)
specifier|register
name|tpe
modifier|*
name|p
decl_stmt|;
block|{
for|for
control|(
name|p
operator|++
init|;
name|p
operator|->
name|pe_type
operator|!=
name|PE_END
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|pe_type
operator|==
name|DFLT_B
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"fdflt_b:Internal Error PE_END found\n"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

end_unit

