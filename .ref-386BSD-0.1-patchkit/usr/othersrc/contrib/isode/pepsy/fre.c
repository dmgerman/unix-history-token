begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* fre.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/pepsy/RCS/fre.c,v 7.10 91/03/09 11:55:08 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/pepsy/RCS/fre.c,v 7.10 91/03/09 11:55:08 mrose Exp $  *  *  * $Log:	fre.c,v $  * Revision 7.10  91/03/09  11:55:08  mrose  * update  *   * Revision 7.9  91/02/22  09:48:58  mrose  * Interim 6.8  *   * Revision 7.8  91/01/07  12:41:20  mrose  * update  *   * Revision 7.7  90/12/23  17:24:30  mrose  * patches  *   * Revision 7.6  90/11/11  10:53:52  mrose  * update  *   * Revision 7.5  90/11/04  19:17:06  mrose  * update  *   * Revision 7.4  90/10/23  20:43:01  mrose  * update  *   * Revision 7.3  90/08/18  00:44:26  mrose  * touch-up  *   * Revision 7.2  90/07/27  08:48:48  mrose  * update  *   * Revision 7.1  90/07/09  14:52:38  mrose  * sync  *   * Revision 7.0  90/07/01  19:54:20  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_comment
comment|/*  * These routines are the driving routines for freeing of the data  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pepsy-driver.h"
end_include

begin_comment
comment|/* for PEPSY_VERSION defn */
end_comment

begin_include
include|#
directive|include
file|"psap.h"
end_include

begin_include
include|#
directive|include
file|"pepsy.h"
end_include

begin_function_decl
specifier|extern
name|tpe
modifier|*
name|next_tpe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|pepsylose
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NEXT_TPE
parameter_list|(
name|p
parameter_list|)
value|p = next_tpe(p)
end_define

begin_define
define|#
directive|define
name|CHKTAG
parameter_list|(
name|mod
parameter_list|,
name|p
parameter_list|,
name|pe
parameter_list|)
value|ismatch(p, mod, pe->pe_class, pe->pe_id)
end_define

begin_comment
comment|/*  * free an objects data. Basic algorithm is to walk through it twice  * first time freeing all the "children" of the data structure - then  * the second time free the structure itself  */
end_comment

begin_macro
name|fre_obj
argument_list|(
argument|parm
argument_list|,
argument|p
argument_list|,
argument|mod
argument_list|,
argument|dofree
argument_list|)
end_macro

begin_decl_stmt
name|modtyp
modifier|*
name|mod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tpe
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|parm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dofree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|malptr
init|=
name|NULL
decl_stmt|;
comment|/* Have we seen a malloc */
name|int
name|ndofree
init|=
name|dofree
decl_stmt|;
comment|/* Does the function below deallocate space */
if|if
condition|(
name|parm
operator|==
literal|0
condition|)
return|return
operator|(
name|OK
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|pe_type
operator|!=
name|PE_START
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_obj: missing PE_START\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
for|for
control|(
name|p
operator|++
init|;
name|p
operator|->
name|pe_type
operator|!=
name|PE_END
condition|;
name|NEXT_TPE
argument_list|(
name|p
argument_list|)
control|)
block|{
name|again
label|:
comment|/* 	 * we have to have all these cases here because it is different to the 	 * situation when the entry is not the main entry of the typereference. 	 */
switch|switch
condition|(
name|p
operator|->
name|pe_type
condition|)
block|{
case|case
name|MEMALLOC
case|:
if|if
condition|(
name|dofree
condition|)
block|{
name|malptr
operator|=
name|parm
expr_stmt|;
name|ndofree
operator|=
literal|0
expr_stmt|;
comment|/* we are deallocating space on this level */
block|}
break|break;
default|default:
if|if
condition|(
name|fre_type
argument_list|(
name|parm
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|ndofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
name|malptr
operator|&&
name|dofree
condition|)
block|{
comment|/* If we saw a malloc free item */
name|free
argument_list|(
name|malptr
argument_list|)
expr_stmt|;
name|malptr
operator|=
name|NULLCP
expr_stmt|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Handle freeing of single type field. All the more general routines  * fall back to this so we can put the code to free something just  * here once and it will handle all the cases else where  */
end_comment

begin_macro
name|fre_type
argument_list|(
argument|parm
argument_list|,
argument|p
argument_list|,
argument|mod
argument_list|,
argument|dofree
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|parm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tpe
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|modtyp
modifier|*
name|mod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module it is from */
end_comment

begin_decl_stmt
name|int
name|dofree
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|parm
operator|==
literal|0
condition|)
return|return
name|OK
return|;
name|again
label|:
switch|switch
condition|(
name|p
operator|->
name|pe_type
condition|)
block|{
case|case
name|MEMALLOC
case|:
break|break;
case|case
name|PE_END
case|:
case|case
name|PE_START
case|:
case|case
name|UCODE
case|:
break|break;
case|case
name|BOPTIONAL
case|:
case|case
name|FREE_ONLY
case|:
comment|/* this next entry is for us */
case|case
name|DFLT_F
case|:
name|p
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|ETAG
case|:
switch|switch
condition|(
name|p
operator|->
name|pe_ucode
condition|)
block|{
default|default:
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|fre_type
argument_list|(
name|parm
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|dofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
break|break;
case|case
name|SEQ_START
case|:
case|case
name|SET_START
case|:
if|if
condition|(
name|fre_seq
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SEQOF_START
case|:
case|case
name|SETOF_START
case|:
if|if
condition|(
name|fre_seqof
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SSEQ_START
case|:
case|case
name|SSET_START
case|:
if|if
condition|(
name|fre_seq
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|dofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SSEQOF_START
case|:
case|case
name|SSETOF_START
case|:
if|if
condition|(
name|fre_seqof
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|dofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|IMP_OBJ
case|:
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pe_type
operator|==
name|EXTOBJ
condition|)
block|{
if|if
condition|(
name|fre_obj
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
operator|(
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|pe_type
operator|==
name|SEXTOBJ
condition|)
block|{
if|if
condition|(
name|fre_obj
argument_list|(
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
operator|(
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|dofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|pe_type
operator|==
name|SOBJECT
condition|)
block|{
if|if
condition|(
name|fre_obj
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|mod
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|mod
argument_list|,
name|dofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|fre_obj
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|mod
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SOBJECT
case|:
if|if
condition|(
name|fre_obj
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|mod
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|mod
argument_list|,
name|dofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|OBJECT
case|:
if|if
condition|(
name|fre_obj
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|mod
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SCHOICE_START
case|:
if|if
condition|(
name|fre_choice
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|dofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|CHOICE_START
case|:
if|if
condition|(
name|fre_choice
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SEXTOBJ
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|.
name|pe_type
operator|!=
name|EXTMOD
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_type:missing EXTMOD"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|fre_obj
argument_list|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
operator|(
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|dofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|EXTOBJ
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|.
name|pe_type
operator|!=
name|EXTMOD
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_type:missing EXTMOD"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|fre_obj
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
operator|(
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|INTEGER
case|:
case|case
name|BOOLEAN
case|:
case|case
name|T_NULL
case|:
case|case
name|REALTYPE
case|:
break|break;
case|case
name|SANY
case|:
comment|/* 	 * These tests of the pointer don't appear necessary from the 	 * definition of encoding and decoding but ISODE generates 	 * freeing code that does these checks and ISODE's ps layer 	 * definitely requires it 	 */
if|if
condition|(
name|parm
operator|!=
name|NULL
condition|)
block|{
name|pe_free
argument_list|(
operator|(
name|PE
operator|)
name|parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|ANY
case|:
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pe_free
argument_list|(
operator|*
operator|(
name|PE
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|PE
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
operator|)
operator|=
name|NULLPE
expr_stmt|;
block|}
break|break;
case|case
name|SOCTETSTRING
case|:
if|if
condition|(
name|parm
operator|!=
name|NULL
condition|)
block|{
name|qb_free
argument_list|(
operator|(
expr|struct
name|qbuf
operator|*
operator|)
name|parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|T_STRING
case|:
case|case
name|OCTET_PTR
case|:
case|case
name|BITSTR_PTR
case|:
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
operator|=
name|NULLCP
expr_stmt|;
block|}
break|break;
case|case
name|OCTETSTRING
case|:
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
operator|!=
name|NULL
condition|)
block|{
name|qb_free
argument_list|(
operator|*
operator|(
expr|struct
name|qbuf
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|qbuf
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
operator|=
operator|(
expr|struct
name|qbuf
operator|*
operator|)
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|SBITSTRING
case|:
if|if
condition|(
name|parm
operator|!=
name|NULL
condition|)
block|{
name|pe_free
argument_list|(
operator|(
name|PE
operator|)
name|parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|BITSTRING
case|:
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pe_free
argument_list|(
operator|*
operator|(
name|PE
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|PE
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
operator|=
name|NULLPE
expr_stmt|;
block|}
break|break;
case|case
name|SOBJID
case|:
if|if
condition|(
name|parm
operator|!=
name|NULL
condition|)
block|{
name|oid_free
argument_list|(
operator|(
name|OID
operator|)
name|parm
argument_list|)
expr_stmt|;
name|parm
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|OBJID
case|:
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
operator|!=
name|NULL
condition|)
block|{
name|oid_free
argument_list|(
operator|*
operator|(
name|OID
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|OID
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
operator|=
name|NULLOID
expr_stmt|;
block|}
break|break;
case|case
name|FN_CALL
case|:
break|break;
comment|/* can't do anything with this */
case|case
name|FFN_CALL
case|:
if|if
condition|(
operator|(
name|FN_PTR
argument_list|(
name|mod
argument_list|,
name|p
argument_list|)
operator|)
operator|(
name|parm
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_type:FN_CALL:call failed"
argument_list|)
return|;
break|break;
default|default:
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_type: %d not implemented\n"
argument_list|,
name|p
operator|->
name|pe_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * free elements of a sequential type. e.g. sequence or set  */
end_comment

begin_expr_stmt
specifier|static
name|fre_seq
argument_list|(
argument|parm
argument_list|,
argument|p
argument_list|,
argument|mod
argument_list|,
argument|dofree
argument_list|)
name|char
operator|*
name|parm
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|tpe
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|modtyp
modifier|*
name|mod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module it is from */
end_comment

begin_decl_stmt
name|int
name|dofree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
modifier|*
name|popt
init|=
name|NULL
decl_stmt|;
comment|/* Pointer to optional field */
name|int
name|optcnt
init|=
literal|0
decl_stmt|;
comment|/* Number of optionals bits so far */
name|char
modifier|*
name|malptr
init|=
name|NULL
decl_stmt|;
comment|/* Have we seen a malloc */
name|int
name|ndofree
init|=
name|dofree
decl_stmt|;
comment|/* Does the function below deallocate space */
if|if
condition|(
name|parm
operator|==
literal|0
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|p
operator|->
name|pe_type
operator|!=
name|SEQ_START
operator|&&
name|p
operator|->
name|pe_type
operator|!=
name|SET_START
operator|&&
name|p
operator|->
name|pe_type
operator|!=
name|SSEQ_START
operator|&&
name|p
operator|->
name|pe_type
operator|!=
name|SSET_START
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_seq: bad starting item %d\n"
argument_list|,
name|p
operator|->
name|pe_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pe_type
operator|==
name|DFLT_B
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|pe_type
operator|!=
name|PE_END
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|pe_type
condition|)
block|{
case|case
name|MEMALLOC
case|:
if|if
condition|(
name|dofree
condition|)
block|{
name|malptr
operator|=
name|parm
expr_stmt|;
name|ndofree
operator|=
literal|0
expr_stmt|;
comment|/* we are deallocating space on this level */
block|}
break|break;
case|case
name|OPTL
case|:
name|popt
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
expr_stmt|;
break|break;
case|case
name|ETAG
case|:
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
name|UCODE
case|:
break|break;
case|case
name|SET_START
case|:
case|case
name|SEQ_START
case|:
if|if
condition|(
name|fre_seq
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SETOF_START
case|:
case|case
name|SEQOF_START
case|:
if|if
condition|(
name|fre_seqof
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SSEQ_START
case|:
case|case
name|SSET_START
case|:
if|if
condition|(
name|fre_seq
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|ndofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SSEQOF_START
case|:
case|case
name|SSETOF_START
case|:
if|if
condition|(
name|fre_seqof
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|ndofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|IMP_OBJ
case|:
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
name|SOBJECT
case|:
if|if
condition|(
name|fre_obj
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|mod
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|mod
argument_list|,
name|ndofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|OBJECT
case|:
if|if
condition|(
name|fre_obj
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|mod
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SCHOICE_START
case|:
if|if
condition|(
name|fre_choice
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|ndofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|CHOICE_START
case|:
if|if
condition|(
name|fre_choice
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SEXTOBJ
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|.
name|pe_type
operator|!=
name|EXTMOD
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_seq:missing EXTMOD"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|fre_obj
argument_list|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
operator|(
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|ndofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|EXTOBJ
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|.
name|pe_type
operator|!=
name|EXTMOD
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_seq:missing EXTMOD"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|fre_obj
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
operator|(
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
default|default:
if|if
condition|(
name|fre_type
argument_list|(
name|parm
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|ndofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
block|}
name|next
label|:
name|NEXT_TPE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|malptr
operator|&&
name|dofree
condition|)
block|{
comment|/* If we saw a malloc free item */
name|free
argument_list|(
name|malptr
argument_list|)
expr_stmt|;
name|malptr
operator|=
name|NULLCP
expr_stmt|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * free all the fields in a SET OF/SEQUENCE OF type structure. We  * must follow the linked list until the end  */
end_comment

begin_expr_stmt
specifier|static
name|fre_seqof
argument_list|(
argument|parm
argument_list|,
argument|p
argument_list|,
argument|mod
argument_list|,
argument|dofree
argument_list|)
name|char
operator|*
name|parm
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|tpe
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|modtyp
modifier|*
name|mod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module it is from */
end_comment

begin_decl_stmt
name|int
name|dofree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tpe
modifier|*
name|start
decl_stmt|;
comment|/* first entry in list */
name|char
modifier|*
name|oparm
decl_stmt|;
if|if
condition|(
name|parm
operator|==
literal|0
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|p
operator|->
name|pe_type
operator|!=
name|SEQOF_START
operator|&&
name|p
operator|->
name|pe_type
operator|!=
name|SETOF_START
operator|&&
name|p
operator|->
name|pe_type
operator|!=
name|SSEQOF_START
operator|&&
name|p
operator|->
name|pe_type
operator|!=
name|SSETOF_START
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_seqof: illegal field"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
for|for
control|(
name|start
operator|=
name|p
init|;
operator|(
name|char
operator|*
operator|)
name|parm
operator|!=
name|NULL
condition|;
name|p
operator|=
name|start
control|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pe_type
operator|==
name|DFLT_B
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|pe_type
operator|!=
name|PE_END
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|pe_type
condition|)
block|{
case|case
name|MEMALLOC
case|:
break|break;
case|case
name|ETAG
case|:
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
name|UCODE
case|:
break|break;
case|case
name|SEQ_START
case|:
case|case
name|SET_START
case|:
if|if
condition|(
name|fre_seq
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SEQOF_START
case|:
case|case
name|SETOF_START
case|:
if|if
condition|(
name|fre_seqof
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SSEQ_START
case|:
case|case
name|SSET_START
case|:
if|if
condition|(
name|fre_seq
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|dofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SSEQOF_START
case|:
case|case
name|SSETOF_START
case|:
if|if
condition|(
name|fre_seqof
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|dofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|IMP_OBJ
case|:
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
name|SOBJECT
case|:
if|if
condition|(
name|fre_obj
argument_list|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|mod
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|mod
argument_list|,
literal|0
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|OBJECT
case|:
if|if
condition|(
name|fre_obj
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|mod
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SCHOICE_START
case|:
if|if
condition|(
name|fre_choice
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
literal|0
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|CHOICE_START
case|:
if|if
condition|(
name|fre_choice
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|SEXTOBJ
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|.
name|pe_type
operator|!=
name|EXTMOD
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_seqof: missing EXTMOD"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|fre_obj
argument_list|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
argument_list|,
operator|(
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
case|case
name|EXTOBJ
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|.
name|pe_type
operator|!=
name|EXTMOD
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_seqof: missing EXTMOD"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|fre_obj
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
argument_list|,
operator|(
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|->
name|md_dtab
index|[
name|p
operator|->
name|pe_tag
index|]
argument_list|,
name|EXT2MOD
argument_list|(
name|mod
argument_list|,
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
default|default:
if|if
condition|(
name|fre_type
argument_list|(
name|parm
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
literal|1
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
break|break;
block|}
name|NEXT_TPE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|oparm
operator|=
name|parm
expr_stmt|;
name|parm
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
expr_stmt|;
comment|/* Any more ? */
if|if
condition|(
name|dofree
condition|)
block|{
name|free
argument_list|(
name|oparm
argument_list|)
expr_stmt|;
name|oparm
operator|=
name|NULLCP
expr_stmt|;
block|}
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * free the item of the choice. Use the SCTRL field to determine  * which item is present and then call the appropriate routine to  * free it  */
end_comment

begin_expr_stmt
specifier|static
name|fre_choice
argument_list|(
argument|parm
argument_list|,
argument|p
argument_list|,
argument|mod
argument_list|,
argument|dofree
argument_list|)
name|char
operator|*
name|parm
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|tpe
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|modtyp
modifier|*
name|mod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module it is from */
end_comment

begin_decl_stmt
name|int
name|dofree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|malptr
init|=
name|NULL
decl_stmt|;
comment|/* Have we seen a malloc */
name|int
name|ndofree
init|=
name|dofree
decl_stmt|;
comment|/* Does the function below deallocate space */
if|if
condition|(
name|parm
operator|==
literal|0
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|p
operator|->
name|pe_type
operator|!=
name|CHOICE_START
operator|&&
name|p
operator|->
name|pe_type
operator|!=
name|SCHOICE_START
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_choice:CHOICE_START missing found %d\n"
argument_list|,
name|p
operator|->
name|pe_type
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pe_type
operator|==
name|DFLT_B
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pe_type
operator|==
name|MEMALLOC
condition|)
block|{
if|if
condition|(
name|dofree
condition|)
block|{
name|malptr
operator|=
name|parm
expr_stmt|;
name|ndofree
operator|=
literal|0
expr_stmt|;
comment|/* we are deallocating space on this level */
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|pe_type
operator|!=
name|SCTRL
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_choice: missing SCTRL information\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|cnt
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|parm
operator|+
name|p
operator|->
name|pe_ucode
operator|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_choice:offset negative %d"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
for|for
control|(
name|p
operator|++
init|;
name|p
operator|->
name|pe_type
operator|!=
name|PE_END
condition|;
name|NEXT_TPE
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|ISDTYPE
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fre_type
argument_list|(
name|parm
argument_list|,
name|p
argument_list|,
name|mod
argument_list|,
name|ndofree
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
if|if
condition|(
name|malptr
operator|&&
name|dofree
condition|)
block|{
comment|/* If we saw a malloc free item */
name|free
argument_list|(
name|malptr
argument_list|)
expr_stmt|;
name|malptr
operator|=
name|NULLCP
expr_stmt|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
name|cnt
operator|--
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"fre_choice: no choice taken"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * look out for FN_CALL - if this entry is really a FN_CALL return non zero  * else return 0  * Basically we have to stop FN_CALL being tested by hasdata which will call  * the decoding function which is illegal and gives rubbish.  */
end_comment

begin_macro
name|callsfn
argument_list|(
argument|p
argument_list|,
argument|mod
argument_list|)
end_macro

begin_decl_stmt
name|tpe
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|modtyp
modifier|*
name|mod
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|p
operator|->
name|pe_type
operator|!=
name|PE_END
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|pe_type
condition|)
block|{
case|case
name|ETAG
case|:
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
name|FN_CALL
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
case|case
name|INTEGER
case|:
case|case
name|REALTYPE
case|:
case|case
name|BOOLEAN
case|:
case|case
name|T_NULL
case|:
case|case
name|IMP_OBJ
case|:
case|case
name|OBJECT
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|pepsylose
argument_list|(
name|mod
argument_list|,
name|p
argument_list|,
name|NULLPE
argument_list|,
literal|"callsfn:Corrupted tables:PE_END found\n"
argument_list|)
expr_stmt|;
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"callsfn:Mangled tables\n"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

end_unit

