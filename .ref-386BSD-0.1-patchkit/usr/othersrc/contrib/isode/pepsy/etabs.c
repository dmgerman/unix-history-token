begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* etabs.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/pepsy/RCS/etabs.c,v 7.8 91/02/22 09:48:54 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/pepsy/RCS/etabs.c,v 7.8 91/02/22 09:48:54 mrose Interim $  *  *  * $Log:	etabs.c,v $  * Revision 7.8  91/02/22  09:48:54  mrose  * Interim 6.8  *   * Revision 7.7  91/01/08  12:49:27  mrose  * update  *   * Revision 7.6  90/12/11  10:33:33  mrose  * sync  *   * Revision 7.5  90/11/11  10:53:43  mrose  * update  *   * Revision 7.4  90/11/04  19:18:31  mrose  * update  *   * Revision 7.3  90/08/18  00:44:20  mrose  * touch-up  *   * Revision 7.2  90/07/27  08:49:15  mrose  * update  *   * Revision 7.1  90/07/09  14:52:33  mrose  * sync  *   * Revision 7.0  90/07/01  19:54:18  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"pepsydefs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_include
include|#
directive|include
file|"mine.h"
end_include

begin_decl_stmt
name|s_table
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|s_table
modifier|*
name|lookup_list
argument_list|()
decl_stmt|,
modifier|*
name|proc_def
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|c_tag
argument_list|()
decl_stmt|,
modifier|*
name|c_class
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ec_tag
argument_list|()
decl_stmt|,
modifier|*
name|ec_class
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|strip_last
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|get_val
argument_list|()
decl_stmt|,
modifier|*
name|get_comp
argument_list|()
decl_stmt|,
modifier|*
name|get_string
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|s_table
modifier|*
name|get_offset
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|my_strcat
argument_list|()
decl_stmt|,
modifier|*
name|strp2name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|my_new_str
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|mymodule
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|modsym
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|genlabel
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|notidtoid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|code2name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|yp2name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|YV
name|calc_yv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|SY
name|syfind
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|s_table
modifier|*
name|en_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|s_table
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|rm_indirect
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getfield
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|setfield
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|cons_type
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* int     explicit; */
end_comment

begin_decl_stmt
name|s_table
modifier|*
name|save_ptr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|YT
name|gen_etag
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|WORDSIZE
value|20
end_define

begin_define
define|#
directive|define
name|MAXNAME
value|256
end_define

begin_comment
comment|/* maximum size of a identifier */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|str_yp_code
index|[]
init|=
block|{
literal|"Undefined"
block|,
literal|"Boolean"
block|,
literal|"Integer"
block|,
literal|"Named number list"
block|,
literal|"Bitstring"
block|,
literal|"Named Bitstring list"
block|,
literal|"Octet String"
block|,
literal|"Null"
block|,
literal|"Sequence"
block|,
literal|"Sequence of"
block|,
literal|"Sequence list"
block|,
literal|"Set"
block|,
literal|"Set of"
block|,
literal|"Set list"
block|,
literal|"Choice"
block|,
literal|"Any"
block|,
literal|"Object Identifier"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"Identifier"
block|,  }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * table encode a type. generate tables for the encoding of a type  */
end_comment

begin_macro
name|tenc_typ
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|,
argument|id
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|s_table
modifier|*
name|ptr1
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|;
name|YP
name|y
decl_stmt|;
name|YAL
name|yal
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|<
literal|0
operator|||
name|yp
operator|->
name|yp_code
operator|>
name|YP_REAL
condition|)
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ: unimplemented type %d\n"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULL
condition|)
block|{
name|ferr
argument_list|(
literal|0
argument_list|,
literal|"tenc_typ:NULL argument\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Preserve the type of the containing object */
if|if
condition|(
name|type
condition|)
name|t
operator|=
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ:SETLIST can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_bef_alist
condition|)
block|{
name|yal
operator|->
name|yal_type
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|yal
operator|->
name|yal_enc
condition|)
name|gen_act
argument_list|(
name|fp
argument_list|,
name|yp
operator|->
name|yp_bef_alist
operator|->
name|yal_enc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_aft_alist
condition|)
block|{
name|yal
operator|->
name|yal_type
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_control_act
condition|)
name|yal
operator|->
name|yal_type
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|yal
operator|=
name|yp
operator|->
name|yp_optional_act
condition|)
name|yal
operator|->
name|yal_type
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|gdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|G_ENC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PARMVAL
operator|)
operator|&&
name|yp
operator|->
name|yp_parm
condition|)
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_parm
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_parm
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|strdup
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|f
operator|=
name|yp
operator|->
name|yp_varexp
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|==
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator|)
condition|)
block|{
name|char
modifier|*
name|f1
decl_stmt|;
name|char
modifier|*
name|bitno
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_optional_act
operator|&&
name|yp
operator|->
name|yp_optional_act
operator|->
name|yal_enc
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ BOPTIONAL, %d, 0, FL_USELECT},\n"
argument_list|,
name|yp
operator|->
name|yp_optional_act
operator|->
name|yal_enc
operator|->
name|a_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|f1
operator|=
name|getfldbit
argument_list|(
name|yp
operator|->
name|yp_optcontrol
argument_list|,
operator|&
name|bitno
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ:BOPTIONAL: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ BOPTIONAL, AOFFSET(%s, %s), %s, 0},\n"
argument_list|,
name|t
argument_list|,
name|f1
argument_list|,
name|bitno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* handle explicit tags - one day may have to change this if anyone      * ever defines a type with more than one explicit tag      */
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ ETAG, 0, "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s, %s },\n"
argument_list|,
name|ec_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|ec_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_yfn
operator|&&
name|yp
operator|->
name|yp_yfn
operator|->
name|yfn_enc
condition|)
block|{
name|gen_fn
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|yp
operator|->
name|yp_yfn
operator|->
name|yfn_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_aft_alist
operator|&&
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_enc
condition|)
name|gen_act
argument_list|(
name|fp
argument_list|,
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_enc
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_UNDF
case|:
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:Undefined type\n"
argument_list|)
expr_stmt|;
case|case
name|YP_BOOL
case|:
name|p1
operator|=
literal|"BOOLEAN"
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:BOOL: must specify a field [[ b .. ]]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_intexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
break|break;
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:BOOL: couldn't determine type\n"
argument_list|)
expr_stmt|;
case|case
name|YP_INTLIST
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_ENUMLIST
case|:
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:INT: must specify a field [[ i .. ]]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_intexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"INTEGER"
expr_stmt|;
break|break;
block|}
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:INT: couldn't determine type\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_REAL
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:REAL: must specify a field [[ r .. ]]\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_strexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"REALTYPE"
expr_stmt|;
break|break;
block|}
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:REAL: couldn't determine type\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
operator|&&
name|yp
operator|->
name|yp_intexp
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:BIT: must specify a field [[ x .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BITSTR_PTR"
expr_stmt|;
name|prnte
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:BIT: must specify a field [[ x .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BITSTR_LEN"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_strexp
operator|==
name|NULLCP
operator|&&
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_intexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"BITSTRING"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SBITSTRING, 0, %s, %s },\n"
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OCT
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
block|{
switch|switch
condition|(
name|yp
operator|->
name|yp_prfexp
condition|)
block|{
case|case
literal|'q'
case|:
comment|/* [[ q parm->qbufptr ]] */
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|p1
operator|=
literal|"SOCTETSTRING"
expr_stmt|;
else|else
name|p1
operator|=
literal|"OCTETSTRING"
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* [[ s ptr ]] */
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:OCT: must specify a field [[ s .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"T_STRING"
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* [[ o ptr $ length ]] */
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:OCT: must specify a field [[ s .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OCTET_PTR"
expr_stmt|;
name|prnte
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:OCT: must specify a field [[ s .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OCTET_LEN"
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ: Unknown Octet string specifier %c\n"
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|f
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|p1
operator|=
literal|"OCTETSTRING"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SOCTETSTRING, 0, %s, %s },\n"
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OID
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_strexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"OBJID"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SOBJID, 0, %s, %s },\n"
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
if|if
condition|(
name|yp
operator|->
name|yp_strexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|yp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|||
operator|(
name|yp
operator|->
name|yp_strexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"ANY"
expr_stmt|;
break|break;
block|}
name|t
operator|=
name|NULL
expr_stmt|;
name|p1
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SANY, 0, %s, %s },\n"
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_NULL
case|:
name|p1
operator|=
literal|"T_NULL"
expr_stmt|;
name|t
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PARMVAL
operator|)
operator|&&
name|yp
operator|->
name|yp_prfexp
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"\n[[ ? reference ]] [[ p reference ]] is illegal\n\t only one allowed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_prfexp
condition|)
block|{
comment|/* [[ ? parm->field ]] - complex to process */
name|gen_identry
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|gen_ventry
argument_list|)
expr_stmt|;
break|break;
block|}
block|{
comment|/* Predefined Universal Type */
name|struct
name|univ_typ
modifier|*
name|p
decl_stmt|,
modifier|*
name|univtyp
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|univtyp
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|univ_flags
operator|&
name|UNF_EXTMOD
condition|)
block|{
name|yp
operator|->
name|yp_module
operator|=
name|p
operator|->
name|univ_mod
expr_stmt|;
goto|goto
name|do_obj
goto|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* No offset type */
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
name|prstfield
argument_list|(
name|fp
argument_list|,
name|p
operator|->
name|univ_tab
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|int2tstr
argument_list|(
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
operator|->
name|yv_number
argument_list|)
argument_list|,
name|c_flags
argument_list|(
name|yp
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			(void) fprintf(fp, "\t{ S%s, 0, %d, %s },\n", 				p->univ_tab, 				yp->yp_tag->yt_value->yv_number, 				c_flags(yp, yp->yp_tag->yt_class)); 			 */
else|else
name|prstfield
argument_list|(
name|fp
argument_list|,
name|p
operator|->
name|univ_tab
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|int2tstr
argument_list|(
name|p
operator|->
name|univ_id
argument_list|)
argument_list|,
name|c_flags
argument_list|(
name|yp
argument_list|,
name|p
operator|->
name|univ_class
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			(void) fprintf(fp, "\t{ S%s, 0, %d, %s },\n", 				p->univ_tab, p->univ_id, 				c_flags(yp, p->univ_class)); 			 */
break|break;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
name|prtfield
argument_list|(
name|fp
argument_list|,
name|p
operator|->
name|univ_tab
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|int2tstr
argument_list|(
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
operator|->
name|yv_number
argument_list|)
argument_list|,
name|c_flags
argument_list|(
name|yp
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		    (void) fprintf(fp, "\t{ %s, OFFSET(%s, %s), %d, %s },\n", 			    p->univ_tab, t, f, 			    yp->yp_tag->yt_value->yv_number, 			    c_flags(yp, yp->yp_tag->yt_class)); 		     */
else|else
name|prtfield
argument_list|(
name|fp
argument_list|,
name|p
operator|->
name|univ_tab
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|int2tstr
argument_list|(
name|p
operator|->
name|univ_id
argument_list|)
argument_list|,
name|c_flags
argument_list|(
name|yp
argument_list|,
name|p
operator|->
name|univ_class
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		    (void) fprintf(fp, "\t{ %s, OFFSET(%s, %s), %d, %s },\n", 			    p->univ_tab, t, f, p->univ_id, 			    c_flags(yp, p->univ_class)); 		     */
break|break;
block|}
block|}
name|do_obj
label|:
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ IMP_OBJ, 0, %s, %s },\n"
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* No offset type */
name|prstfield
argument_list|(
name|fp
argument_list|,
literal|"OBJECT"
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|concat
argument_list|(
literal|"_Z"
argument_list|,
name|proc_name
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		(void) fprintf(fp, "\t{ SOBJECT, 0, _Z%s, %s },\n", 		      proc_name(yp->yp_identifier, 0), c_class(yp)); 		 */
block|}
else|else
name|prtfield
argument_list|(
name|fp
argument_list|,
literal|"OBJECT"
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|concat
argument_list|(
literal|"_Z"
argument_list|,
name|proc_name
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		(void) fprintf(fp, 			"\t{ OBJECT, OFFSET(%s, %s), _Z%s, %s },\n", 		t, f, proc_name(yp->yp_identifier, 0), c_class(yp)); 		*/
block|}
else|else
block|{
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* No offset type */
name|prstfield
argument_list|(
name|fp
argument_list|,
literal|"EXTOBJ"
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|concat
argument_list|(
literal|"_Z"
argument_list|,
name|strp2name
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		(void) fprintf(fp, "\t{ SEXTOBJ, 0, _Z%s, %s },\n", 			strp2name(yp->yp_identifier, yp->yp_module), 			c_class(yp)); 		 */
block|}
else|else
name|prtfield
argument_list|(
name|fp
argument_list|,
literal|"EXTOBJ"
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|concat
argument_list|(
literal|"_Z"
argument_list|,
name|strp2name
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		(void) fprintf(fp, 			"\t{ EXTOBJ, OFFSET(%s, %s), _Z%s, %s },\n", 		  t, f, strp2name(yp->yp_identifier, yp->yp_module), 			c_class(yp)); 		 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ EXTMOD, %d, 0, 0 },\n"
argument_list|,
name|gen_modref
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_SEQLIST
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
comment|/* support for -h flag */
name|cons_type
operator|++
expr_stmt|;
name|save_ptr
operator|=
name|en_ptr
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|==
name|NULL
operator|&&
name|type
operator|!=
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:YP_SEQLIST:NULL varexp pointer\n"
argument_list|)
expr_stmt|;
name|prcte
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
literal|"SEQ_START"
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
comment|/* compute the type of data */
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ:SEQLIST: can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:YP_SEQLIST:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|optfield
argument_list|(
name|y
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ OPTL, OFFSET(%s, optionals), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
name|tenc_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
name|en_ptr
operator|=
name|save_ptr
expr_stmt|;
name|cons_type
operator|--
expr_stmt|;
break|break;
case|case
name|YP_SETLIST
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
comment|/* support for -h flag */
name|cons_type
operator|++
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_varexp
operator|==
name|NULL
operator|&&
name|type
operator|!=
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:YP_SETLIST:NULL varexp pointer\n"
argument_list|)
expr_stmt|;
name|prcte
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
literal|"SET_START"
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ:SETLIST can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:YP_SETLIST:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|optfield
argument_list|(
name|y
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ OPTL, OFFSET(%s, optionals), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
name|tenc_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
name|en_ptr
operator|=
name|save_ptr
expr_stmt|;
name|cons_type
operator|--
expr_stmt|;
break|break;
case|case
name|YP_SEQTYPE
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
name|cons_type
operator|++
expr_stmt|;
name|save_ptr
operator|=
name|en_ptr
expr_stmt|;
name|prcte
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
literal|"SEQOF_START"
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ:SETLIST can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:YP_SEQTYPE:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
name|tenc_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
block|{
name|char
modifier|*
name|f1
decl_stmt|;
if|if
condition|(
operator|(
name|f1
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ:SEQ OF: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, %s), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|,
name|f1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_structname
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, next), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
name|en_ptr
operator|=
name|save_ptr
expr_stmt|;
name|cons_type
operator|--
expr_stmt|;
break|break;
case|case
name|YP_SETTYPE
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
name|cons_type
operator|++
expr_stmt|;
name|save_ptr
operator|=
name|en_ptr
expr_stmt|;
name|prcte
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
literal|"SETOF_START"
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ:SETTYPE can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:YP_SETTYPE:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
name|tenc_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
block|{
name|char
modifier|*
name|f1
decl_stmt|;
if|if
condition|(
operator|(
name|f1
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ:SET OF: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, %s), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|,
name|f1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_structname
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, OFFSET(%s, next), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
name|en_ptr
operator|=
name|save_ptr
expr_stmt|;
name|cons_type
operator|--
expr_stmt|;
break|break;
case|case
name|YP_CHOICE
case|:
name|p1
operator|=
name|NULL
expr_stmt|;
comment|/* support for -h flag */
if|if
condition|(
name|hflag
operator|&&
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|&&
operator|!
name|y
operator|->
name|yp_next
condition|)
block|{
name|tenc_typ
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
break|break;
block|}
name|cons_type
operator|++
expr_stmt|;
name|save_ptr
operator|=
name|en_ptr
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|type
operator|&&
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|prstfield
argument_list|(
name|fp
argument_list|,
literal|"CHOICE_START"
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prtfield
argument_list|(
name|fp
argument_list|,
literal|"CHOICE_START"
argument_list|,
name|t
argument_list|,
name|type
condition|?
name|f
else|:
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|yp
operator|->
name|yp_type
condition|)
block|{
name|char
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
block|{
comment|/* we have a [[ P type ]] specification */
if|if
condition|(
operator|(
name|t1
operator|=
name|rm_indirect
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ:CHOICE can't extract direct type from %s\n"
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_structname
operator|=
name|strdup
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:YP_CHOICE:no declexp\n"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_structname
operator|=
name|my_strcat
argument_list|(
literal|"struct "
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
else|else
name|yp
operator|->
name|yp_structname
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_control_act
operator|&&
name|yp
operator|->
name|yp_control_act
operator|->
name|yal_enc
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SCTRL, %d, 0, FL_USELECT },\n"
argument_list|,
name|yp
operator|->
name|yp_control_act
operator|->
name|yal_enc
operator|->
name|a_num
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
block|{
name|char
modifier|*
name|f1
decl_stmt|;
if|if
condition|(
operator|(
name|f1
operator|=
name|getfield
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntenc_typ:CHOICE: can't extract field from %s\n"
argument_list|,
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SCTRL, OFFSET(%s, %s), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|,
name|f1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_structname
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ SCTRL, OFFSET(%s, offset), 0, 0 },\n"
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
else|else
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"\nCHOICE missing SCTRL\n"
argument_list|)
expr_stmt|;
name|tenc_loop
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|id
argument_list|,
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ PE_END, 0, 0, 0 },\n"
argument_list|)
expr_stmt|;
name|en_ptr
operator|=
name|save_ptr
expr_stmt|;
name|cons_type
operator|--
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ: yp_code = %d  not implemented\n"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
name|prnte
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_aft_alist
operator|&&
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_enc
condition|)
name|gen_act
argument_list|(
name|fp
argument_list|,
name|yp
operator|->
name|yp_aft_alist
operator|->
name|yal_enc
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|fflags
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|6
block|,
literal|0
block|,
literal|10
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * calculate the tag string of the given type and return it  */
end_comment

begin_function
name|char
modifier|*
name|c_tag
parameter_list|(
name|yp
parameter_list|)
name|YP
name|yp
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|WORDSIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
block|{
name|i
operator|=
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
operator|->
name|yv_number
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|<
literal|0
operator|||
name|yp
operator|->
name|yp_code
operator|>
name|YP_REAL
operator|||
name|yp
operator|->
name|yp_code
operator|==
name|YP_CHOICE
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|=
name|fflags
index|[
name|yp
operator|->
name|yp_code
index|]
expr_stmt|;
comment|/* Choice now legal argument - to allow prte_* routines to work */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|yp
operator|->
name|yp_code
operator|!=
name|YP_CHOICE
condition|)
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"c_tag:Unknown Tag %d"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * calculate the tag string of the explicit tag and return it  */
end_comment

begin_function
name|char
modifier|*
name|ec_tag
parameter_list|(
name|yp
parameter_list|)
name|YP
name|yp
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|WORDSIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|)
operator|||
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"ec_tag:internal error:called with out explicit tag\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
operator|->
name|yv_number
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * produce a string that represents the class/flags field for a given  * yp entry taking the class to be that given in cl  */
end_comment

begin_function
name|char
modifier|*
name|c_flags
parameter_list|(
name|yp
parameter_list|,
name|cl
parameter_list|)
name|YP
name|yp
decl_stmt|;
name|int
name|cl
decl_stmt|;
block|{
name|char
modifier|*
name|p1
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|STRSIZE
index|]
decl_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
break|break;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
operator|&&
operator|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|!=
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"FL_OPTIONAL"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
name|p1
operator|=
literal|"FL_DEFAULT"
expr_stmt|;
block|}
else|else
name|p1
operator|=
literal|"0"
expr_stmt|;
return|return
operator|(
name|p1
operator|)
return|;
default|default:
break|break;
block|}
name|p1
operator|=
name|class2str
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
operator|&&
operator|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|!=
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator|)
operator|)
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|p1
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
name|p1
operator|=
name|strncat
argument_list|(
name|buf
argument_list|,
literal|"|FL_OPTIONAL"
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|p1
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
name|p1
operator|=
name|strncat
argument_list|(
name|buf
argument_list|,
literal|"|FL_DEFAULT"
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * turn the class number into its corresponding string  */
end_comment

begin_function
name|char
modifier|*
name|class2str
parameter_list|(
name|cl
parameter_list|)
name|int
name|cl
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
switch|switch
condition|(
name|cl
condition|)
block|{
case|case
name|PE_CLASS_UNIV
case|:
name|p1
operator|=
literal|"FL_UNIVERSAL"
expr_stmt|;
break|break;
case|case
name|PE_CLASS_APPL
case|:
name|p1
operator|=
literal|"FL_APPLICATION"
expr_stmt|;
break|break;
case|case
name|PE_CLASS_PRIV
case|:
name|p1
operator|=
literal|"FL_PRIVATE"
expr_stmt|;
break|break;
case|case
name|PE_CLASS_CONT
case|:
name|p1
operator|=
literal|"FL_CONTEXT"
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"class2str: illegal class found %d\n"
argument_list|,
name|cl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * calculate a string specifying the class for the given type and  * return it  */
end_comment

begin_function
name|char
modifier|*
name|c_class
parameter_list|(
name|yp
parameter_list|)
name|YP
name|yp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|&&
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
block|{
name|i
operator|=
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|PE_CLASS_UNIV
expr_stmt|;
block|}
return|return
operator|(
name|c_flags
argument_list|(
name|yp
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * calculate a string specifying the class for the explicit tag and  * return it  */
end_comment

begin_function
name|char
modifier|*
name|ec_class
parameter_list|(
name|yp
parameter_list|)
name|YP
name|yp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|STRSIZE
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|)
operator|||
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPLICIT
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"ec_class:internal error:called with out explicit tag\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
break|break;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
operator|&&
operator|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|!=
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator|)
operator|)
condition|)
block|{
name|p1
operator|=
literal|"FL_OPTIONAL"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
name|p1
operator|=
literal|"FL_DEFAULT"
expr_stmt|;
block|}
else|else
name|p1
operator|=
literal|"0"
expr_stmt|;
return|return
operator|(
name|p1
operator|)
return|;
default|default:
break|break;
block|}
name|i
operator|=
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|PE_CLASS_UNIV
case|:
name|p1
operator|=
literal|"FL_UNIVERSAL"
expr_stmt|;
break|break;
case|case
name|PE_CLASS_APPL
case|:
name|p1
operator|=
literal|"FL_APPLICATION"
expr_stmt|;
break|break;
case|case
name|PE_CLASS_PRIV
case|:
name|p1
operator|=
literal|"FL_PRIVATE"
expr_stmt|;
break|break;
case|case
name|PE_CLASS_CONT
case|:
name|p1
operator|=
literal|"FL_CONTEXT"
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"c_class: illegal class found %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
operator|)
operator|&&
operator|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|!=
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator|)
operator|)
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|p1
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
name|p1
operator|=
name|strncat
argument_list|(
name|buf
argument_list|,
literal|"|FL_OPTIONAL"
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|p1
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
name|p1
operator|=
name|strncat
argument_list|(
name|buf
argument_list|,
literal|"|FL_DEFAULT"
argument_list|,
name|STRSIZE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate tables for encoding a contructed type  */
end_comment

begin_macro
name|tenc_loop
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|,
argument|id
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
name|yp
operator|!=
name|NULL
condition|;
name|yp
operator|=
name|yp
operator|->
name|yp_next
control|)
block|{
name|tenc_typ
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Print the string and exit if argument greater than zero  */
end_comment

begin_macro
name|ferr
argument_list|(
argument|i
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print the integer and exit if argument greater than zero  */
end_comment

begin_macro
name|ferrd
argument_list|(
argument|i
argument_list|,
argument|s
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print the string and exit if argument greater than zero  */
end_comment

begin_macro
name|ferrs
argument_list|(
argument|i
argument_list|,
argument|s
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * return a copy of the string s minus its last character  */
end_comment

begin_function
name|char
modifier|*
name|strip_last
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|t
operator|=
name|new_string
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|t
init|;
operator|*
name|r
operator|!=
literal|'\0'
condition|;
name|r
operator|++
control|)
empty_stmt|;
empty_stmt|;
operator|*
operator|--
name|r
operator|=
literal|'\0'
expr_stmt|;
return|return
name|t
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * add the declaration specified by the strings type and id to the  * start of the declaration list  */
end_comment

begin_macro
name|add_list
argument_list|(
argument|type
argument_list|,
argument|id
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|,
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|s_table
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
operator|(
name|prev
operator|=
operator|(
name|s_table
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|s_table
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"add_list: Out of memory\n"
argument_list|)
expr_stmt|;
name|prev
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|prev
operator|->
name|name
operator|=
name|id
expr_stmt|;
name|prev
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|prev
operator|->
name|defined
operator|=
literal|0
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|prev
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print the declaration list  */
end_comment

begin_macro
name|print_list
argument_list|()
end_macro

begin_block
block|{
name|s_table
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|prev
operator|=
name|head
init|;
name|prev
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|prev
operator|->
name|next
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"type is %s\n"
argument_list|,
name|prev
operator|->
name|type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"name is %s\n"
argument_list|,
name|prev
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * parse the declaration in the string s returning the type in v1 and  * the name in v2  */
end_comment

begin_macro
name|parse_decl
argument_list|(
argument|s
argument_list|,
argument|v1
argument_list|,
argument|v2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|s
decl_stmt|,
modifier|*
modifier|*
name|v1
decl_stmt|,
modifier|*
modifier|*
name|v2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|*
name|s
init|;
operator|*
name|t
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isalnum
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|'_'
operator|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
operator|*
name|s
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
init|;
operator|*
name|t
operator|!=
literal|'*'
condition|;
name|t
operator|++
control|)
empty_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|v1
operator|=
name|my_strcat
argument_list|(
operator|*
name|s
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|3
argument_list|,
operator|(
literal|"the type is %s\n"
operator|,
operator|*
name|v1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|t
operator|==
literal|'*'
condition|)
name|t
operator|++
expr_stmt|;
for|for
control|(
operator|*
name|s
operator|=
name|t
init|;
name|isalnum
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|'_'
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
operator|*
name|v2
operator|=
name|new_string
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
comment|/* don't really need new_string */
name|Printf
argument_list|(
literal|2
argument_list|,
operator|(
literal|"the name is %s\n"
operator|,
operator|*
name|v2
operator|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|t
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * return the next identifier in the string s  */
end_comment

begin_function
name|char
modifier|*
name|get_val
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|*
name|s
init|;
operator|*
name|t
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isalnum
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|'_'
operator|||
operator|*
name|t
operator|==
literal|'.'
operator|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
operator|*
name|s
operator|=
name|t
init|;
name|isalnum
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|'_'
operator|||
operator|*
name|t
operator|==
literal|'.'
condition|;
name|t
operator|++
control|)
empty_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
operator|*
name|s
expr_stmt|;
name|Printf
argument_list|(
literal|3
argument_list|,
operator|(
literal|"arg is |%s|\n"
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
operator|++
name|t
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * return the next component (sequence of characters up to the next  * ';' or '\0') of the string s  */
end_comment

begin_function
name|char
modifier|*
name|get_comp
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|*
name|s
init|;
operator|*
name|t
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isalnum
argument_list|(
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|'_'
operator|||
operator|*
name|t
operator|==
literal|';'
operator|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
operator|*
name|s
operator|=
name|t
init|;
operator|*
name|t
operator|!=
literal|'\0'
operator|&&
operator|*
name|t
operator|!=
literal|';'
condition|;
name|t
operator|++
control|)
empty_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
operator|*
name|s
expr_stmt|;
name|Printf
argument_list|(
literal|3
argument_list|,
operator|(
literal|"component is |%s|\n"
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
operator|++
name|t
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * return a copy of that part of the string s which may contain  * definitions for the variables generated by posy  */
end_comment

begin_function
name|char
modifier|*
name|get_string
parameter_list|(
name|s
parameter_list|,
name|direction
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|direction
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|t1
decl_stmt|;
if|if
condition|(
name|direction
operator|&
name|YP_ENCODER
condition|)
return|return
name|new_string
argument_list|(
name|s
argument_list|)
return|;
if|if
condition|(
name|direction
operator|&
name|YP_DECODER
condition|)
block|{
name|t
operator|=
name|new_string
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|t1
operator|=
name|t
init|;
operator|!
operator|(
name|isalnum
argument_list|(
operator|*
name|t1
argument_list|)
operator|||
operator|*
name|t1
operator|==
literal|'_'
operator|)
condition|;
name|t1
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|t1
operator|==
literal|'i'
operator|&&
operator|*
operator|++
name|t1
operator|==
literal|'f'
operator|&&
operator|*
operator|++
name|t1
operator|==
literal|' '
condition|)
block|{
comment|/* MEMALLOC code */
for|for
control|(
init|;
operator|*
name|t1
operator|!=
literal|'}'
condition|;
name|t1
operator|++
control|)
comment|/* skip MEMALLOC code */
empty_stmt|;
name|t1
operator|++
expr_stmt|;
name|Printf
argument_list|(
literal|4
argument_list|,
operator|(
literal|"returning the string %s\n"
operator|,
name|t1
operator|)
argument_list|)
expr_stmt|;
return|return
name|t1
return|;
block|}
else|else
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Determine wether this list contains any items that will generate  * an optional field. If so return non zero  */
end_comment

begin_macro
name|optfield
argument_list|(
argument|yp
argument_list|)
end_macro

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
name|yp
condition|;
name|yp
operator|=
name|yp
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
block|{
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|==
operator|(
name|YP_OPTIONAL
operator||
name|YP_OPTCONTROL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_NULL
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|gen_dflts
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|YP
name|y
decl_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
break|break;
case|case
name|YP_CHOICE
case|:
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
operator|!=
name|NULL
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|gen_dflts
argument_list|(
name|fp
argument_list|,
name|y
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Output definitions for default entries */
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|defdflt
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_yfn
condition|)
name|declfns
argument_list|(
name|fp
argument_list|,
name|yp
operator|->
name|yp_yfn
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute the concatenation into a temporary buffer of two strings  * after having run notid on them first  */
end_comment

begin_function
name|char
modifier|*
name|strp2name
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|STRSIZE
operator|*
literal|2
operator|+
literal|5
index|]
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
name|STRSIZE
operator|||
name|strlen
argument_list|(
name|s2
argument_list|)
operator|>
name|STRSIZE
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"strp2name:string to big\n"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|p
operator|=
name|notidtoid
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|p
operator|=
name|notidtoid
argument_list|(
name|s2
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Output the definitions for default entries and initialise the yp's  * to have pointers which reference these definitions for use by  * gdflt routine.  */
end_comment

begin_macro
name|defdflt
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|YV
name|yv
decl_stmt|;
name|YV
name|yv1
decl_stmt|;
name|SY
name|sy
decl_stmt|;
name|YP
name|yp1
decl_stmt|;
name|int
name|size
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|struct
name|univ_typ
modifier|*
name|p
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
operator|)
operator|==
literal|0
condition|)
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"defdflt:called with out a default code = %d\n"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
name|yv
operator|=
name|yp
operator|->
name|yp_default
expr_stmt|;
name|yp1
operator|=
name|yp
expr_stmt|;
comment|/* Find the bottom definition */
name|code
operator|=
name|yp1
operator|->
name|yp_code
expr_stmt|;
while|while
condition|(
name|code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
operator|(
name|sy
operator|=
name|syfind
argument_list|(
name|yp1
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|univtyp
argument_list|(
name|yp1
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|p
operator|->
name|univ_type
operator|<=
name|YP_UNDF
condition|)
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"defdflt:IDEFINED:cannot find definition of symbol %s\n"
argument_list|,
name|yp1
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
name|code
operator|=
name|p
operator|->
name|univ_type
expr_stmt|;
break|break;
block|}
name|yp1
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
name|code
operator|=
name|yp1
operator|->
name|yp_code
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|YP_BOOL
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
case|case
name|YV_BOOL
case|:
comment|/* None needed */
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
operator|(
name|yv1
operator|=
name|calc_yv
argument_list|(
name|yp1
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"defdflt:BOOL/INT:cannot find definition of %s\n"
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
block|}
comment|/* None Needed */
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"defdflt:INT/BOOL:unimplemented value code = %d\n"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_REAL
case|:
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_REAL
case|:
name|yv1
operator|=
name|yv
expr_stmt|;
goto|goto
name|dumpdef3
goto|;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
operator|(
name|yv1
operator|=
name|calc_yv
argument_list|(
name|yp1
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"defdflt:REAL:cannot find definition of %s\n"
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
block|}
goto|goto
name|dumpdef3
goto|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"defdflt:REAL:unimplemented value code = %d\n"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
comment|/* 	     * This is an illegal value for a bit string ! - BUT ACSE 	     * uses it ! 	     */
comment|/* gdflt also patched to support it */
case|case
name|YV_IDEFINED
case|:
name|ferrs
argument_list|(
literal|0
argument_list|,
literal|"warning:bitstring default specified illegally with identifier %s\n"
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yv1
operator|=
name|calc_yv
argument_list|(
name|yp1
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"defdflt:BIT:cannot find definition of %s\n"
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
block|}
comment|/* doesn't work fix posy-yacc.y */
name|size
operator|=
name|numtobstr
argument_list|(
name|yv1
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
goto|goto
name|dumpdef1
goto|;
case|case
name|YV_NUMBER
case|:
name|size
operator|=
name|numtobstr
argument_list|(
name|yv
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
goto|goto
name|dumpdef1
goto|;
case|case
name|YV_VALIST
case|:
if|if
condition|(
operator|(
name|size
operator|=
name|valisttobs
argument_list|(
name|yp1
argument_list|,
name|yv
argument_list|,
operator|&
name|str
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"defdflt:bad default value for bit string %s\n"
argument_list|,
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|?
name|yp
operator|->
name|yp_identifier
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
goto|goto
name|dumpdef1
goto|;
case|case
name|YV_HSTRING
case|:
name|str
operator|=
name|yv
operator|->
name|yv_xstring
expr_stmt|;
name|size
operator|=
name|yv
operator|->
name|yv_xlength
operator|*
literal|4
expr_stmt|;
goto|goto
name|dumpdef1
goto|;
case|case
name|YV_BSTRING
case|:
name|str
operator|=
name|yv
operator|->
name|yv_xstring
expr_stmt|;
name|size
operator|=
name|yv
operator|->
name|yv_xlength
expr_stmt|;
goto|goto
name|dumpdef1
goto|;
default|default:
comment|/* Could be a syntax error */
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"defdflt:BIT:illegal value code = %d\n"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_IDEFINED
case|:
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"defdflt:IDEFINED:internal error on symbol %s\n"
argument_list|,
name|yp1
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OCT
case|:
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
name|size
operator|=
name|numtobstr
argument_list|(
name|yv
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
goto|goto
name|dumpdef2
goto|;
case|case
name|YV_STRING
case|:
name|str
operator|=
name|yv
operator|->
name|yv_string
expr_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
goto|goto
name|dumpdef2
goto|;
case|case
name|YV_HSTRING
case|:
name|str
operator|=
name|yv
operator|->
name|yv_xstring
expr_stmt|;
name|size
operator|=
operator|(
name|yv
operator|->
name|yv_xlength
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
goto|goto
name|dumpdef2
goto|;
case|case
name|YV_BSTRING
case|:
name|str
operator|=
name|yv
operator|->
name|yv_xstring
expr_stmt|;
name|size
operator|=
operator|(
name|yv
operator|->
name|yv_xlength
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
comment|/* round up */
goto|goto
name|dumpdef2
goto|;
default|default:
comment|/* Could be a syntax error */
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"defdflt:OCT:illegal value code = %d\n"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_NULL
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
case|case
name|YP_ANY
case|:
case|case
name|YP_OID
case|:
comment|/* None yet */
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"defdflt:unknown type %d\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
return|return;
name|dumpdef1
label|:
comment|/* Bitstrings */
name|label
operator|=
name|genlabel
argument_list|(
name|name
argument_list|,
name|yp
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_action0
operator|=
name|label
expr_stmt|;
name|yp
operator|->
name|yp_act0_lineno
operator|=
name|size
expr_stmt|;
name|i
operator|=
operator|(
name|size
operator|+
name|NBPC
operator|-
literal|1
operator|)
operator|/
name|NBPC
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nstatic char %s[] = "
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|printable
argument_list|(
name|str
argument_list|,
name|i
argument_list|)
condition|)
name|prstr
argument_list|(
name|fp
argument_list|,
name|str
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|prhstr
argument_list|(
name|fp
argument_list|,
name|str
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
return|return;
name|dumpdef2
label|:
comment|/* Octet strings (and aliases) */
name|label
operator|=
name|genlabel
argument_list|(
name|name
argument_list|,
name|yp
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_action0
operator|=
name|label
expr_stmt|;
name|yp
operator|->
name|yp_act0_lineno
operator|=
name|size
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nstatic char %s[] = "
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|printable
argument_list|(
name|str
argument_list|,
name|size
argument_list|)
condition|)
name|prstr
argument_list|(
name|fp
argument_list|,
name|str
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|prhstr
argument_list|(
name|fp
argument_list|,
name|str
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
return|return;
name|dumpdef3
label|:
comment|/* Reals */
name|label
operator|=
name|genlabel
argument_list|(
name|name
argument_list|,
name|yp
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_action0
operator|=
name|label
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nstatic double %s = %f;\n"
argument_list|,
name|label
argument_list|,
name|yv1
operator|->
name|yv_real
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * generate the default entry for encoding/decoding fields. This  * should contain the default value which the encoder will know means  * default encoding  */
end_comment

begin_macro
name|gdflt
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|,
argument|which
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which type of entries to generate 				 * G_ENC encode G_DEC decode */
end_comment

begin_block
block|{
name|YV
name|yv
decl_stmt|;
name|YV
name|yv1
decl_stmt|;
name|SY
name|sy
decl_stmt|;
name|YP
name|yp1
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|ndflt
decl_stmt|;
name|struct
name|univ_typ
modifier|*
name|p
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|G_ENC
condition|)
name|ndflt
operator|=
literal|"DFLT_F"
expr_stmt|;
else|else
name|ndflt
operator|=
literal|"DFLT_B"
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
operator|)
operator|==
literal|0
condition|)
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"gdflt:called with out a default code = %d\n"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
name|yv
operator|=
name|yp
operator|->
name|yp_default
expr_stmt|;
name|yp1
operator|=
name|yp
expr_stmt|;
comment|/* Find the bottom definition */
name|code
operator|=
name|yp1
operator|->
name|yp_code
expr_stmt|;
while|while
condition|(
name|code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
operator|(
name|sy
operator|=
name|syfind
argument_list|(
name|yp1
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|univtyp
argument_list|(
name|yp1
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|p
operator|->
name|univ_type
operator|<=
name|YP_UNDF
condition|)
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"gdflt:IDEFINED:cannot find definition of symbol %s\n"
argument_list|,
name|yp1
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
name|code
operator|=
name|p
operator|->
name|univ_type
expr_stmt|;
break|break;
block|}
name|yp1
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
name|code
operator|=
name|yp1
operator|->
name|yp_code
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|YP_BOOL
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
case|case
name|YV_BOOL
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s,	%d,	0,	0 },\n"
argument_list|,
name|ndflt
argument_list|,
name|yp
operator|->
name|yp_default
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
operator|(
name|yv1
operator|=
name|calc_yv
argument_list|(
name|yp1
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"gdflt:BOOL/INT:cannot find definition of %s\n"
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s,	%d,	0,	0 },\n"
argument_list|,
name|ndflt
argument_list|,
name|yv1
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"gdflt:INT/BOOL:unimplemented value code = %d\n"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
ifdef|#
directive|ifdef
name|ILLEGAL_DEFAULTS
case|case
name|YV_IDEFINED
case|:
comment|/* supporting illegal default 				 * specification */
endif|#
directive|endif
case|case
name|YV_NUMBER
case|:
case|case
name|YV_HSTRING
case|:
case|case
name|YV_BSTRING
case|:
case|case
name|YV_VALIST
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s,	%d,	%d,	0 },\n"
argument_list|,
name|ndflt
argument_list|,
name|yp
operator|->
name|yp_act0_lineno
argument_list|,
name|addptr
argument_list|(
name|yp
operator|->
name|yp_action0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Could be a syntax error */
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"gdflt:BIT:illegal value code = %d\n"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_IDEFINED
case|:
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"gdflt:IDEFINED:internal error on symbol %s\n"
argument_list|,
name|yp1
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_REAL
case|:
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
ifdef|#
directive|ifdef
name|ILLEGAL_DEFAULTS
case|case
name|YV_IDEFINED
case|:
comment|/* Illegal according to ASN.1 but we can do it 				 * so why not support it 				 */
endif|#
directive|endif
case|case
name|YV_REAL
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s,	0,	%d,	0 },\n"
argument_list|,
name|ndflt
argument_list|,
name|addptr
argument_list|(
name|concat
argument_list|(
literal|"&"
argument_list|,
name|yp
operator|->
name|yp_action0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Could be a syntax error */
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"gdflt:REAL:illegal value code = %d\n"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_OCT
case|:
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
case|case
name|YV_STRING
case|:
case|case
name|YV_HSTRING
case|:
case|case
name|YV_BSTRING
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s,	%d,	%d,	0 },\n"
argument_list|,
name|ndflt
argument_list|,
name|yp
operator|->
name|yp_act0_lineno
argument_list|,
name|addptr
argument_list|(
name|yp
operator|->
name|yp_action0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Could be a syntax error */
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"gdflt:OCT:illegal value code = %d\n"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_NULL
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
case|case
name|YP_ANY
case|:
case|case
name|YP_OID
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s,	0,	0,	0 },\n"
argument_list|,
name|ndflt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"gdflt:unknown type %d\n"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Calculate the value associated with the given identifier id by  * looking at the value definitions associated with type definition  * yp. Returns the value definition if found or NULL if not.  */
end_comment

begin_function
name|YV
name|calc_yv
parameter_list|(
name|yp
parameter_list|,
name|id
parameter_list|)
name|YP
name|yp
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
block|{
name|YV
name|yv
decl_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
operator|!=
name|NULL
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
operator|&&
name|strcmp
argument_list|(
name|yv
operator|->
name|yv_named
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|yv
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ******* This does not work. posy needs to be fixed for case of  * '01'b ***** Turn a Literal number value in yv into a bistring  * initialisation. Return the length of the bit string or less than  * zero on error. Set the (char *) pointer, whose address is in  * ppstr, to point to a string containing the a reference to a  * character array which contains the bits.  */
end_comment

begin_macro
name|numtobstr
argument_list|(
argument|yv
argument_list|,
argument|ppstr
argument_list|)
end_macro

begin_decl_stmt
name|YV
name|yv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ppstr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ibits
decl_stmt|,
name|lastb
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|NBPI
operator|/
name|NBPC
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|NBPI
operator|/
name|NBPC
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lastb
operator|=
operator|-
literal|1
expr_stmt|;
name|ibits
operator|=
name|yv
operator|->
name|yv_number
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBPI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
name|ibits
condition|)
block|{
name|buf
index|[
name|i
operator|/
name|NBPC
index|]
operator||=
literal|1
operator|<<
operator|(
name|NBPC
operator|-
literal|1
operator|-
operator|(
name|i
operator|%
name|NBPC
operator|)
operator|)
expr_stmt|;
name|lastb
operator|=
name|i
expr_stmt|;
block|}
block|}
operator|*
name|ppstr
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|lastb
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|ROUNDUP
value|10
end_define

begin_comment
comment|/*  * Take a list of Values (YV_VALIST) which should contain a list of  * bits and convert them into a bitstring initialisation. As in  * numtobstr return the size of the bit string or a negative number  * if there is an error. Put a reference to a character array which  * contains the definition of the bits in the character pointer whose  * address is in ppstr. yp is the definition of the type which  * contains the names of all the defined bits.  */
end_comment

begin_macro
name|valisttobs
argument_list|(
argument|yp
argument_list|,
argument|yv
argument_list|,
argument|ppstr
argument_list|)
end_macro

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YV
name|yv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ppstr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|YV
name|yv1
decl_stmt|,
name|yv2
decl_stmt|;
name|int
name|lastb
decl_stmt|,
name|val
decl_stmt|,
name|nsize
decl_stmt|,
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|lastb
operator|=
operator|-
literal|1
expr_stmt|;
name|size
operator|=
name|ROUNDUP
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"valisttobs:malloc:failed on %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|yv1
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|yv1
operator|!=
name|NULL
condition|;
name|yv1
operator|=
name|yv1
operator|->
name|yv_next
control|)
block|{
if|if
condition|(
operator|(
name|yv2
operator|=
name|calc_yv
argument_list|(
name|yp
argument_list|,
name|yv1
operator|->
name|yv_identifier
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|val
operator|=
name|yv2
operator|->
name|yv_number
expr_stmt|;
comment|/* Bug here probably */
if|if
condition|(
name|size
operator|<
name|val
operator|/
name|NBPC
condition|)
block|{
name|nsize
operator|=
name|val
operator|/
name|NBPC
operator|+
name|ROUNDUP
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|nsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ferrd
argument_list|(
literal|1
argument_list|,
literal|"valisttobs:realloc:failed on %d\n"
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|buf
operator|+
name|size
argument_list|,
name|nsize
operator|-
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
name|nsize
expr_stmt|;
block|}
name|buf
index|[
name|val
operator|/
name|NBPC
index|]
operator||=
literal|1
operator|<<
operator|(
name|NBPC
operator|-
literal|1
operator|-
operator|(
name|val
operator|%
name|NBPC
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|lastb
condition|)
name|lastb
operator|=
name|val
expr_stmt|;
block|}
operator|*
name|ppstr
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|lastb
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Print the string out in a format acceptable as a quoted string in  * a C program including the quotes. Using \ escapes for unprintable  * characters  */
end_comment

begin_macro
name|prstr
argument_list|(
argument|fp
argument_list|,
argument|str
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|str
operator|&
literal|0xff
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
operator|*
name|str
operator|&
literal|0xff
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\\%0o"
argument_list|,
operator|*
name|str
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
define|#
directive|define
name|MAXPLINE
value|16
block|}
end_block

begin_comment
comment|/*  * output a initialisation for a character array as unsigned hex  * numbers  */
end_comment

begin_macro
name|prhstr
argument_list|(
argument|fp
argument_list|,
argument|str
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|npline
decl_stmt|;
comment|/* number on this line */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|npline
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|npline
operator|>=
name|MAXPLINE
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|npline
operator|=
literal|0
expr_stmt|;
block|}
name|npline
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" 0x%02x,"
argument_list|,
operator|*
name|str
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * determine if the string is printable i.e. only sensible to be read  * as a character string. 1 (true) if it is 0, if it isn't  */
end_comment

begin_macro
name|printable
argument_list|(
argument|str
argument_list|,
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|str
operator|&
literal|0xff
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* look for the first non printable 				 * character */
name|str
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * generate a unique identifier  using the name given and the name if  * present in yp. Return a pointer to it in a space malloc'ed out  */
end_comment

begin_function
name|char
modifier|*
name|genlabel
parameter_list|(
name|name
parameter_list|,
name|yp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|YP
name|yp
decl_stmt|;
block|{
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
specifier|static
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p1
operator|=
name|notidtoid
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
block|{
name|p2
operator|=
name|notidtoid
argument_list|(
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"L%s_%s_%d"
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|cnt
operator|++
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"L%s_X_%d"
argument_list|,
name|p1
argument_list|,
name|cnt
operator|++
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
return|return
operator|(
name|my_new_str
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate a ptr table reference for the given module table entry  */
end_comment

begin_macro
name|gen_modref
argument_list|(
argument|mod
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mod
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|p1
operator|=
name|notidtoid
argument_list|(
name|mod
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"&%s%s%s"
argument_list|,
name|PREFIX
argument_list|,
name|p1
argument_list|,
name|MODTYP_SUFFIX
argument_list|)
expr_stmt|;
name|ind
operator|=
name|addptr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ind
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|setfield
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|getfield
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nsetfield: can't extract field from %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|strdup
argument_list|(
name|f
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * print a normal table entry  */
end_comment

begin_macro
name|prnte
argument_list|(
argument|fp
argument_list|,
argument|t
argument_list|,
argument|f
argument_list|,
argument|yp
argument_list|,
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parent type */
end_comment

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* field name */
end_comment

begin_decl_stmt
name|YP
modifier|*
name|yp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* object */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table entry name */
end_comment

begin_block
block|{
if|if
condition|(
name|p1
operator|==
name|NULL
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"prnte: called with a NULL p1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|prstfield
argument_list|(
name|fp
argument_list|,
name|p1
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prtfield
argument_list|(
name|fp
argument_list|,
name|p1
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * generate the entry allowing for defined types and then call the given  * function to generate the base entry  * Algorithm:  * If we can find the base type   *   i) generate any ETAG that subsequent definitions might have  *   ii) call the function to generate the base entry  *   iii) and  the function checks that it matches the type of the value pass  * else - can't find the base type - probably because it is external  *   i)  generate a warning and exit  */
end_comment

begin_macro
name|gen_identry
argument_list|(
argument|fp
argument_list|,
argument|t
argument_list|,
argument|f
argument_list|,
argument|yp
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|YP
name|yp1
decl_stmt|;
name|int
name|code
decl_stmt|;
name|SY
name|sy
decl_stmt|;
name|YT
name|pd_yt
init|=
name|NULLYT
decl_stmt|;
comment|/* Passed down tag if any */
name|YT
name|yt
decl_stmt|;
name|struct
name|univ_typ
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|flags
decl_stmt|;
comment|/* the flags if any which each subtype must have */
name|int
name|save_flags
decl_stmt|;
name|yp1
operator|=
name|yp
expr_stmt|;
name|code
operator|=
name|yp1
operator|->
name|yp_code
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
name|flags
operator|=
literal|"|FL_OPTIONAL"
expr_stmt|;
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|flags
operator|=
literal|"|FL_DEFAULT"
expr_stmt|;
else|else
name|flags
operator|=
literal|""
expr_stmt|;
comment|/* any explicit tag for original yp type is handled before this      * routine is called so don't call gen_etag for it here      * but we do need to initialise pd_yt for the case of an IMPLICIT TAG.      */
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_TAG
operator||
name|YP_IMPLICIT
operator|)
operator|)
operator|==
operator|(
name|YP_TAG
operator||
name|YP_IMPLICIT
operator|)
condition|)
name|pd_yt
operator|=
name|yp
operator|->
name|yp_tag
expr_stmt|;
while|while
condition|(
name|code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
operator|(
name|sy
operator|=
name|syfind
argument_list|(
name|yp1
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|univtyp
argument_list|(
name|yp1
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|p
operator|->
name|univ_type
operator|<=
name|YP_UNDF
condition|)
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"\ngen_identry:symbol %s is not defined in this file:\npepsy cannot support value passing for this type, sorry\n"
argument_list|,
name|yp1
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
name|code
operator|=
name|p
operator|->
name|univ_type
expr_stmt|;
break|break;
block|}
name|yp1
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
comment|/* check for Explicit tags& generate ETAG entries */
name|pd_yt
operator|=
name|gen_etag
argument_list|(
name|fp
argument_list|,
name|pd_yt
argument_list|,
name|yp1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|code
operator|=
name|yp1
operator|->
name|yp_code
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
block|{
comment|/* how do we check type is consistent with value passed ? */
name|yp1
operator|=
name|new_type
argument_list|(
name|code
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|yp1
operator|->
name|yp_flags
operator||=
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_DEFAULT
operator|)
expr_stmt|;
if|if
condition|(
name|pd_yt
operator|==
name|NULLYT
condition|)
block|{
name|yp1
operator|->
name|yp_tag
operator|=
name|new_tag
argument_list|(
name|p
operator|->
name|univ_class
argument_list|)
expr_stmt|;
name|yp1
operator|->
name|yp_tag
operator|->
name|yt_value
operator|=
name|new_value
argument_list|(
name|YV_NUMBER
argument_list|)
expr_stmt|;
name|yp1
operator|->
name|yp_tag
operator|->
name|yt_value
operator|->
name|yv_number
operator|=
name|p
operator|->
name|univ_id
expr_stmt|;
block|}
else|else
name|yp1
operator|->
name|yp_tag
operator|=
name|pd_yt
expr_stmt|;
name|yp1
operator|->
name|yp_flags
operator||=
name|YP_TAG
operator||
name|YP_IMPLICIT
expr_stmt|;
call|(
modifier|*
name|fn
call|)
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|yp1
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* lets free the yp1 allocated above */
if|if
condition|(
name|pd_yt
operator|==
name|NULLYT
condition|)
block|{
name|free
argument_list|(
name|yp1
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yp1
operator|->
name|yp_tag
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|yp1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* check type is consistent with value passed some where??*/
name|save_flags
operator|=
name|yp1
operator|->
name|yp_flags
expr_stmt|;
name|yp1
operator|->
name|yp_flags
operator||=
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_DEFAULT
operator|)
expr_stmt|;
if|if
condition|(
name|pd_yt
condition|)
block|{
name|yt
operator|=
name|yp1
operator|->
name|yp_tag
expr_stmt|;
name|yp1
operator|->
name|yp_tag
operator|=
name|pd_yt
expr_stmt|;
name|yp1
operator|->
name|yp_flags
operator||=
name|YP_TAG
operator||
name|YP_IMPLICIT
expr_stmt|;
block|}
call|(
modifier|*
name|fn
call|)
argument_list|(
name|fp
argument_list|,
name|yp
argument_list|,
name|yp1
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd_yt
condition|)
block|{
comment|/* restore the tag for later */
name|yp1
operator|->
name|yp_tag
operator|=
name|yt
expr_stmt|;
block|}
name|yp1
operator|->
name|yp_flags
operator|=
name|save_flags
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * generate the ETAG entry if needed for following the given defined type  * down to what it is. Given that its use above has an IMPLICIT tag pd_yt  * if it is non Null  */
end_comment

begin_function
name|YT
name|gen_etag
parameter_list|(
name|fp
parameter_list|,
name|pd_yt
parameter_list|,
name|yp
parameter_list|,
name|flags
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|YT
name|pd_yt
decl_stmt|;
name|YP
name|yp
decl_stmt|;
name|char
modifier|*
name|flags
decl_stmt|;
block|{
name|YT
name|yt
decl_stmt|;
name|yt
operator|=
name|yp
operator|->
name|yp_tag
expr_stmt|;
if|if
condition|(
name|yt
operator|&&
name|yt
operator|->
name|yt_value
condition|)
block|{
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_TAG
operator||
name|YP_IMPLICIT
operator|)
operator|)
operator|==
name|YP_TAG
condition|)
block|{
comment|/* EXPLICIT TAG so generate an ETAG */
if|if
condition|(
name|pd_yt
condition|)
name|yt
operator|=
name|pd_yt
expr_stmt|;
comment|/* if we have a value passed down use that */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ ETAG, 0, %d, %s%s },\n"
argument_list|,
name|yt
operator|->
name|yt_value
operator|->
name|yv_number
argument_list|,
name|class2str
argument_list|(
name|yt
operator|->
name|yt_class
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|pd_yt
operator|=
name|NULLYT
expr_stmt|;
comment|/* non't pass on any value */
block|}
elseif|else
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_TAG
operator||
name|YP_IMPLICIT
operator|)
operator|)
operator|==
name|YP_TAG
operator||
name|YP_IMPLICIT
condition|)
block|{
comment|/* otherwise it is implicit and so pass its tag down 	     * unless we already have a tag being passed in which case 	     * the passed down tag overrides this current tag 	     */
if|if
condition|(
name|pd_yt
operator|==
name|NULLYT
condition|)
name|pd_yt
operator|=
name|yt
expr_stmt|;
block|}
block|}
return|return
operator|(
name|pd_yt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate the table entry for a value passing defined type which  * is equivalent to the given primative type  */
end_comment

begin_macro
name|gen_ventry
argument_list|(
argument|fp
argument_list|,
argument|oyp
argument_list|,
argument|yp
argument_list|,
argument|t
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|oyp
decl_stmt|,
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|char
name|s
init|=
name|oyp
operator|->
name|yp_prfexp
decl_stmt|;
comment|/* type of value passing */
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
operator|&&
name|s
operator|!=
literal|'q'
operator|&&
name|s
operator|!=
literal|'a'
condition|)
name|ferrs
argument_list|(
literal|1
argument_list|,
literal|"gen_ventry: must specify a field for primative value- not %s\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
literal|'q'
case|:
comment|/* [[ q parm->qbufptr ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_OCT
condition|)
name|warning
argument_list|(
literal|"qbuf pointer passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|p1
operator|=
literal|"SOCTETSTRING"
expr_stmt|;
else|else
name|p1
operator|=
literal|"OCTETSTRING"
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* [[ s ptr ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_OCT
condition|)
name|warning
argument_list|(
literal|"string pointer passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"T_STRING"
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* [[ o ptr $ length ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_OCT
condition|)
name|warning
argument_list|(
literal|"octet/length pair passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OCTET_PTR"
expr_stmt|;
name|prnte
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|oyp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"gen_ventry:OCT: must specify a field [[ s .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OCTET_LEN"
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* [[ x ptr $ length ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BIT
operator|&&
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BITLIST
condition|)
name|warning
argument_list|(
literal|"bit string/length pair passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BITSTR_PTR"
expr_stmt|;
name|prnte
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|ferr
argument_list|(
literal|1
argument_list|,
literal|"tenc_typ:BIT: must specify a field [[ x .. ]]\n"
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BITSTR_LEN"
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* [[ r REAL ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_REAL
condition|)
name|warning
argument_list|(
literal|"Real passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"REALTYPE"
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* [[ i INTEGER ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_INT
operator|&&
name|yp
operator|->
name|yp_code
operator|!=
name|YP_INTLIST
operator|&&
name|yp
operator|->
name|yp_code
operator|!=
name|YP_ENUMLIST
condition|)
name|warning
argument_list|(
literal|"integer passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oyp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"INTEGER"
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* [[ t Bitvector ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BIT
operator|&&
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BITLIST
condition|)
name|warning
argument_list|(
literal|"Bitvector (PE) passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oyp
operator|->
name|yp_varexp
operator|&&
operator|!
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|p1
operator|=
literal|"BITSTRING"
expr_stmt|;
else|else
name|p1
operator|=
literal|"SBITSTRING"
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* [[ b BOOLEAN ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BOOL
condition|)
name|warning
argument_list|(
literal|"Boolean passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oyp
operator|->
name|yp_intexp
condition|)
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_intexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"BOOLEAN"
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* [[ O Object Identifier ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_OID
condition|)
name|warning
argument_list|(
literal|"Object Identifier pointer passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
name|p1
operator|=
literal|"OBJID"
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* [[ a ANY ]] */
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_ANY
condition|)
name|warning
argument_list|(
literal|"PE pointer passed for a %s by type %s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|,
name|yp2name
argument_list|(
name|oyp
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|setfield
argument_list|(
name|oyp
operator|->
name|yp_strexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|p1
operator|=
literal|"SANY"
expr_stmt|;
else|else
name|p1
operator|=
literal|"ANY"
expr_stmt|;
break|break;
default|default:
name|ferrd
argument_list|(
literal|"gen_vident:unknown Value passed %d\n"
argument_list|,
operator|(
name|int
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
name|prnte
argument_list|(
name|fp
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|yp
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * generate a table entry for a function call that handles this type  */
end_comment

begin_macro
name|gen_fn
argument_list|(
argument|fp
argument_list|,
argument|yp
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of routine to generate */
end_comment

begin_block
block|{
name|gen_identry
argument_list|(
name|fp
argument_list|,
name|fn
argument_list|,
name|NULLCP
argument_list|,
name|yp
argument_list|,
name|gen_fnentry
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * generate a table entry for a function call that handles this type  */
end_comment

begin_macro
name|gen_fnentry
argument_list|(
argument|fp
argument_list|,
argument|oyp
argument_list|,
argument|yp
argument_list|,
argument|fn
argument_list|,
argument|dummy
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|oyp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of routine to generate */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dummy
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ FN_CALL, %d, %s, %s },\n"
argument_list|,
name|addptr
argument_list|(
name|fn
argument_list|)
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * declare the functions that are used  * One day generate ANSII C definitions as well  */
end_comment

begin_macro
name|declfns
argument_list|(
argument|fp
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YFN
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fn
operator|->
name|yfn_enc
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"extern int	%s();\n"
argument_list|,
name|fn
operator|->
name|yfn_enc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fn
operator|->
name|yfn_dec
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"extern int	%s();\n"
argument_list|,
name|fn
operator|->
name|yfn_dec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fn
operator|->
name|yfn_prt
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"extern int	%s();\n"
argument_list|,
name|fn
operator|->
name|yfn_prt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fn
operator|->
name|yfn_fre
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"extern int	%s();\n"
argument_list|,
name|fn
operator|->
name|yfn_fre
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * generate the table entry to handle an action - UCODE  */
end_comment

begin_macro
name|gen_act
argument_list|(
argument|fp
argument_list|,
argument|act
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Action
name|act
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ UCODE, %d, 0, 0 }, /* line %d */\n"
argument_list|,
name|act
operator|->
name|a_num
argument_list|,
name|act
operator|->
name|a_line
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print out the field entry for a type where all the parameters are given  */
end_comment

begin_macro
name|prtfield
argument_list|(
argument|fp
argument_list|,
argument|typ
argument_list|,
argument|t
argument_list|,
argument|f
argument_list|,
argument|cl
argument_list|,
argument|fl
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|typ
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|,
modifier|*
name|cl
decl_stmt|,
modifier|*
name|fl
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cl
operator|==
name|NULLCP
condition|)
name|cl
operator|=
literal|"0"
expr_stmt|;
if|if
condition|(
name|f
operator|&&
name|t
condition|)
block|{
if|if
condition|(
operator|*
name|f
operator|==
literal|'&'
condition|)
name|f
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, OFFSET(%s, %s), %s, %s },\n"
argument_list|,
name|typ
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|cl
argument_list|,
name|fl
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ %s, 0, %s, %s },\n"
argument_list|,
name|typ
argument_list|,
name|cl
argument_list|,
name|fl
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print out the field entry for a Simple type where all the parameters  * are given  */
end_comment

begin_macro
name|prstfield
argument_list|(
argument|fp
argument_list|,
argument|typ
argument_list|,
argument|t
argument_list|,
argument|f
argument_list|,
argument|cl
argument_list|,
argument|fl
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|typ
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|,
modifier|*
name|cl
decl_stmt|,
modifier|*
name|fl
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cl
operator|==
name|NULLCP
condition|)
name|cl
operator|=
literal|"0"
expr_stmt|;
if|if
condition|(
name|f
operator|&&
name|t
operator|&&
operator|*
name|f
operator|==
literal|'&'
condition|)
block|{
name|f
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ S%s, OFFSET(%s, %s), %s, %s },\n"
argument_list|,
name|typ
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|cl
argument_list|,
name|fl
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t{ S%s, 0, %s, %s },\n"
argument_list|,
name|typ
argument_list|,
name|cl
argument_list|,
name|fl
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * convert an integer into a temporary string. Useful for calling  * the printing routines with  */
end_comment

begin_function
name|char
modifier|*
name|int2tstr
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|STRSIZE
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|codetab
index|[]
init|=
block|{
literal|"Undefined"
block|,
literal|"BOOLEAN"
block|,
literal|"INTEGER"
block|,
literal|"INTEGER (named numbers)"
block|,
literal|"BIT STRING"
block|,
literal|"BIT STRING (named bits)"
block|,
literal|"OCTET STRING"
block|,
literal|"NULL"
block|,
literal|"SEQUENCE"
block|,
literal|"SEQUENCE OF"
block|,
literal|"SEQUENCE"
block|,
literal|"SET"
block|,
literal|"SET OF"
block|,
literal|"SET"
block|,
literal|"CHOICE"
block|,
literal|"ANY"
block|,
literal|"OBJECT IDENTIFIER"
block|,
literal|"Defined type"
block|,
literal|"ENUMERATED"
block|,
literal|"REAL"
block|,
literal|"Imported type"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * produce a user readable name for a yp_code value  */
end_comment

begin_function
name|char
modifier|*
name|code2name
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|STRSIZE
index|]
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
operator|||
name|code
operator|>
name|YP_IMPTYPE
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown code (%d)"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
return|return
operator|(
name|codetab
index|[
name|code
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * print out a description of the yp type for the user that is good enough  * for them to identifier the entry if possible  */
end_comment

begin_function
name|char
modifier|*
name|yp2name
parameter_list|(
name|yp
parameter_list|)
name|YP
name|yp
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|STRSIZE
operator|*
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_module
condition|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s."
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_identifier
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s"
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"(no identifier)"
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_modid
condition|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" (%s)"
argument_list|,
name|sprintoid
argument_list|(
name|yp
operator|->
name|yp_modid
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s"
argument_list|,
name|code2name
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" %s"
argument_list|,
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_lineno
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" on line %d"
argument_list|,
name|yp
operator|->
name|yp_lineno
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate a table entry for the given compound type. It determines wether to  * generate a simple type (prstfield) or not.  */
end_comment

begin_macro
name|prcte
argument_list|(
argument|fp
argument_list|,
argument|type
argument_list|,
argument|t
argument_list|,
argument|f
argument_list|,
argument|yp
argument_list|,
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zero if we are foundation type of the table */
end_comment

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parent type */
end_comment

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* field name */
end_comment

begin_decl_stmt
name|YP
modifier|*
name|yp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* object */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table entry name */
end_comment

begin_block
block|{
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|type
operator|&&
name|noindirect
argument_list|(
name|f
argument_list|)
condition|)
name|prstfield
argument_list|(
name|fp
argument_list|,
name|p1
argument_list|,
name|t
argument_list|,
name|f
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prtfield
argument_list|(
name|fp
argument_list|,
name|p1
argument_list|,
name|t
argument_list|,
name|type
condition|?
name|f
else|:
name|NULLCP
argument_list|,
name|c_tag
argument_list|(
name|yp
argument_list|)
argument_list|,
name|c_class
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

