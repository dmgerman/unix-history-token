begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zmisc.c */
end_comment

begin_comment
comment|/* Miscellaneous operators for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"gp.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"dstack.h"
end_include

begin_comment
comment|/* for name lookup in bind */
end_comment

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"packed.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_comment
comment|/* for gstype1.h */
end_comment

begin_include
include|#
directive|include
file|"gstype1.h"
end_include

begin_comment
comment|/* Import the C getenv function */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|getenv
argument_list|(
name|P1
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bind */
end_comment

begin_function
name|int
name|zbind
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|bsp
init|=
name|op
decl_stmt|;
comment|/* bottom of stack */
name|ref
modifier|*
name|defp
init|=
name|op
decl_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_array
case|:
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
break|break;
case|case
name|t_oparray
case|:
name|defp
operator|=
operator|&
name|op_array_table
operator|.
name|value
operator|.
name|refs
index|[
name|op_index
argument_list|(
name|op
argument_list|)
operator|-
name|op_def_count
index|]
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
operator|++
name|bsp
expr_stmt|;
comment|/* We must not make the top-level procedure read-only, */
comment|/* but we must bind it even if it is read-only already. */
operator|*
name|bsp
operator|=
operator|*
name|defp
expr_stmt|;
comment|/* Here are the invariants for the following loop: */
comment|/*	op< bsp<= ostop; */
comment|/*	for every pointer p such that op< p<= bsp, */
comment|/*	  *p is an array (or packedarray) ref. */
define|#
directive|define
name|r_is_ex_oper
parameter_list|(
name|rp
parameter_list|)
define|\
value|((r_btype(rp) == t_operator || r_type(rp) == t_oparray)&&\    r_has_attr(rp, a_executable))
while|while
condition|(
name|bsp
operator|>
name|op
condition|)
block|{
while|while
condition|(
name|r_size
argument_list|(
name|bsp
argument_list|)
condition|)
block|{
name|ref
modifier|*
name|tp
init|=
name|bsp
operator|->
name|value
operator|.
name|refs
decl_stmt|;
name|r_inc_size
argument_list|(
name|bsp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|ushort
operator|*
operator|)
name|tp
operator|>
name|packed_max_full_ref
condition|)
block|{
comment|/* Check for a packed executable name */
name|ushort
name|elt
init|=
operator|*
operator|(
name|ushort
operator|*
operator|)
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|elt
operator|&
operator|~
operator|(
name|ushort
operator|)
name|packed_max_name_index
operator|)
operator|==
name|pt_tag
argument_list|(
name|pt_executable_name
argument_list|)
condition|)
block|{
name|ref
name|nref
decl_stmt|;
name|ref
modifier|*
name|pvalue
decl_stmt|;
name|name_index_ref
argument_list|(
name|elt
operator|&
name|packed_max_name_index
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pvalue
operator|=
name|dict_find_name
argument_list|(
operator|&
name|nref
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|r_is_ex_oper
argument_list|(
name|pvalue
argument_list|)
condition|)
comment|/* Note: can't undo this by restore! */
operator|*
operator|(
name|ushort
operator|*
operator|)
name|tp
operator|=
name|pt_tag
argument_list|(
name|pt_executable_operator
argument_list|)
operator|+
name|op_index
argument_list|(
name|pvalue
argument_list|)
expr_stmt|;
block|}
name|bsp
operator|->
name|value
operator|.
name|refs
operator|=
operator|(
name|ref
operator|*
operator|)
operator|(
operator|(
name|ushort
operator|*
operator|)
name|tp
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|bsp
operator|->
name|value
operator|.
name|refs
operator|++
operator|,
name|r_type
argument_list|(
name|tp
argument_list|)
condition|)
block|{
case|case
name|t_name
case|:
comment|/* bind the name if an operator */
if|if
condition|(
name|r_has_attr
argument_list|(
name|tp
argument_list|,
name|a_executable
argument_list|)
condition|)
block|{
name|ref
modifier|*
name|pvalue
decl_stmt|;
if|if
condition|(
operator|(
name|pvalue
operator|=
name|dict_find_name
argument_list|(
name|tp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|r_is_ex_oper
argument_list|(
name|pvalue
argument_list|)
condition|)
name|ref_assign_old
argument_list|(
name|tp
argument_list|,
name|pvalue
argument_list|,
literal|"bind"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|t_array
case|:
comment|/* push into array if procedure */
if|if
condition|(
operator|!
name|r_has_attr
argument_list|(
name|tp
argument_list|,
name|a_write
argument_list|)
condition|)
break|break;
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
if|if
condition|(
name|r_has_attr
argument_list|(
name|tp
argument_list|,
name|a_executable
argument_list|)
operator|&&
name|bsp
operator|<
name|ostop
condition|)
block|{
comment|/* Make reference read-only */
name|r_clear_attrs
argument_list|(
name|tp
argument_list|,
name|a_write
argument_list|)
expr_stmt|;
operator|*
operator|++
name|bsp
operator|=
operator|*
name|tp
expr_stmt|;
block|}
block|}
block|}
name|bsp
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currenttime */
end_comment

begin_function
name|int
name|zcurrenttime
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|long
name|date_time
index|[
literal|2
index|]
decl_stmt|;
name|gp_get_clock
argument_list|(
name|date_time
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|op
argument_list|,
name|date_time
index|[
literal|0
index|]
operator|*
literal|1440.0
operator|+
name|date_time
index|[
literal|1
index|]
operator|/
literal|60000.0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* getenv */
end_comment

begin_function
name|int
name|zgetenv
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|str
operator|=
name|ref_to_string
argument_list|(
name|op
argument_list|,
literal|"getenv name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|value
operator|=
name|getenv
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|alloc_free
argument_list|(
name|str
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|"getenv name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
comment|/* not found */
block|{
name|make_bool
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|code
operator|=
name|string_to_ref
argument_list|(
name|value
argument_list|,
name|op
argument_list|,
literal|"getenv value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* makeoperator */
end_comment

begin_function
name|int
name|zmakeoperator
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_name
argument_list|)
expr_stmt|;
name|check_proc
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_array_count
operator|==
name|r_size
argument_list|(
operator|&
name|op_array_table
argument_list|)
condition|)
return|return
name|e_limitcheck
return|;
name|ref_assign_old
argument_list|(
operator|&
name|op_array_table
operator|.
name|value
operator|.
name|refs
index|[
name|op_array_count
index|]
argument_list|,
name|op
argument_list|,
literal|"makeoperator"
argument_list|)
expr_stmt|;
name|op_array_nx_table
index|[
name|op_array_count
index|]
operator|=
name|name_index
argument_list|(
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r_set_type_attrs
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|t_oparray
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
name|r_set_size
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|op_def_count
operator|+
name|op_array_count
argument_list|)
expr_stmt|;
name|op_array_count
operator|++
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* setdebug */
end_comment

begin_function
name|int
name|zsetdebug
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_read_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_boolean
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r_size
argument_list|(
name|op
operator|-
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|gs_debug
index|[
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|bytes
index|[
name|i
index|]
operator|&
literal|127
index|]
operator|=
name|op
operator|->
name|value
operator|.
name|index
expr_stmt|;
block|}
endif|#
directive|endif
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* type1encrypt, type1decrypt */
end_comment

begin_decl_stmt
name|private
name|int
name|type1crypt
argument_list|(
name|P2
argument_list|(
name|os_ptr
argument_list|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|P4
argument_list|(
name|byte
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|uint
argument_list|,
name|ushort
operator|*
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ztype1encrypt
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|type1crypt
argument_list|(
name|op
argument_list|,
name|gs_type1_encrypt
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ztype1decrypt
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|type1crypt
argument_list|(
name|op
argument_list|,
name|gs_type1_decrypt
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|private
name|int
name|type1crypt
argument_list|(
specifier|register
name|os_ptr
name|op
argument_list|,
name|int
argument_list|(
operator|*
name|proc
argument_list|)
argument_list|(
name|P4
argument_list|(
name|byte
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|uint
argument_list|,
name|ushort
operator|*
argument_list|)
argument_list|)
argument_list|)
block|{
name|crypt_state
name|state
decl_stmt|;
name|uint
name|ssize
decl_stmt|;
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|2
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|state
operator|=
name|op
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|intval
expr_stmt|;
if|if
condition|(
name|op
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|intval
operator|!=
name|state
condition|)
return|return
name|e_rangecheck
return|;
comment|/* state value was truncated */
name|check_read_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|check_write_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|ssize
operator|=
name|r_size
argument_list|(
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_size
argument_list|(
name|op
argument_list|)
operator|<
name|ssize
condition|)
return|return
name|e_rangecheck
return|;
call|(
name|void
call|)
argument_list|(
operator|*
name|proc
argument_list|)
argument_list|(
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|bytes
argument_list|,
name|ssize
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
comment|/* can't fail */
name|op
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|intval
operator|=
name|state
expr_stmt|;
name|op
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|op
expr_stmt|;
name|r_set_size
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* usertime */
end_comment

begin_function
name|int
name|zusertime
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|long
name|date_time
index|[
literal|2
index|]
decl_stmt|;
name|gp_get_clock
argument_list|(
name|date_time
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|date_time
index|[
literal|0
index|]
operator|*
literal|86400000L
operator|+
name|date_time
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zmisc_op_defs
index|[]
init|=
block|{
block|{
literal|"1bind"
block|,
name|zbind
block|}
block|,
block|{
literal|"0currenttime"
block|,
name|zcurrenttime
block|}
block|,
block|{
literal|"1getenv"
block|,
name|zgetenv
block|}
block|,
block|{
literal|"2makeoperator"
block|,
name|zmakeoperator
block|}
block|,
block|{
literal|"2setdebug"
block|,
name|zsetdebug
block|}
block|,
block|{
literal|"3type1encrypt"
block|,
name|ztype1encrypt
block|}
block|,
block|{
literal|"3type1decrypt"
block|,
name|ztype1decrypt
block|}
block|,
block|{
literal|"0usertime"
block|,
name|zusertime
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

