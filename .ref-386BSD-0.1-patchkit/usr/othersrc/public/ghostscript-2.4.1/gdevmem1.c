begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevmem1.c */
end_comment

begin_comment
comment|/* Generic and monobit "memory" (stored bitmap) device */
end_comment

begin_comment
comment|/* for Ghostscript library. */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gs.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_comment
comment|/* semi-public definitions */
end_comment

begin_include
include|#
directive|include
file|"gdevmem.h"
end_include

begin_comment
comment|/* private definitions */
end_comment

begin_comment
comment|/* Define the chunk size for monobit operations. */
end_comment

begin_if
if|#
directive|if
name|arch_is_big_endian
end_if

begin_define
define|#
directive|define
name|mono_chunk
value|uint
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|mono_chunk
value|ushort
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------ Generic code ------ */
end_comment

begin_comment
comment|/* Return the appropriate memory device for a given */
end_comment

begin_comment
comment|/* number of bits per pixel (0 if none suitable). */
end_comment

begin_function
name|gx_device_memory
modifier|*
name|gdev_mem_device_for_bits
parameter_list|(
name|int
name|bits_per_pixel
parameter_list|)
block|{
switch|switch
condition|(
name|bits_per_pixel
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|&
name|mem_mono_device
return|;
case|case
literal|2
case|:
return|return
operator|&
name|mem_mapped2_color_device
return|;
case|case
literal|4
case|:
return|return
operator|&
name|mem_mapped4_color_device
return|;
case|case
literal|8
case|:
return|return
operator|&
name|mem_mapped8_color_device
return|;
case|case
literal|16
case|:
return|return
operator|&
name|mem_true16_color_device
return|;
case|case
literal|24
case|:
return|return
operator|&
name|mem_true24_color_device
return|;
case|case
literal|32
case|:
return|return
operator|&
name|mem_true32_color_device
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the size of the bitmap storage, */
end_comment

begin_comment
comment|/* including the space for the scan line pointer table. */
end_comment

begin_comment
comment|/* Note that scan lines are padded to a multiple of 4 bytes. */
end_comment

begin_function
name|ulong
name|gdev_mem_bitmap_size
parameter_list|(
name|gx_device_memory
modifier|*
name|dev
parameter_list|)
block|{
name|unsigned
name|raster
init|=
operator|(
operator|(
name|dev
operator|->
name|width
operator|*
name|dev
operator|->
name|color_info
operator|.
name|depth
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
decl_stmt|;
name|mdev
operator|->
name|raster
operator|=
name|raster
expr_stmt|;
return|return
operator|(
name|ulong
operator|)
name|dev
operator|->
name|height
operator|*
operator|(
name|raster
operator|+
sizeof|sizeof
argument_list|(
name|byte
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 'Open' the memory device and create the scan line table. */
end_comment

begin_function
name|int
name|mem_open
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|byte
modifier|*
name|scan_line
init|=
name|mdev
operator|->
name|base
decl_stmt|;
name|uint
name|raster
init|=
name|mdev
operator|->
name|raster
decl_stmt|;
name|byte
modifier|*
modifier|*
name|pptr
init|=
operator|(
name|byte
operator|*
operator|*
operator|)
operator|(
name|scan_line
operator|+
operator|(
name|uint
operator|)
name|dev
operator|->
name|height
operator|*
name|raster
operator|)
decl_stmt|;
name|byte
modifier|*
modifier|*
name|pend
init|=
name|pptr
operator|+
name|dev
operator|->
name|height
decl_stmt|;
name|mdev
operator|->
name|line_ptrs
operator|=
name|pptr
expr_stmt|;
while|while
condition|(
name|pptr
operator|<
name|pend
condition|)
block|{
operator|*
name|pptr
operator|++
operator|=
name|scan_line
expr_stmt|;
name|scan_line
operator|+=
name|raster
expr_stmt|;
block|}
name|mdev
operator|->
name|bytes_le
operator|=
if|#
directive|if
name|arch_is_big_endian
literal|0
else|#
directive|else
comment|/* NOTE: mem_mono_get_bits relies on the fact that */
comment|/* sizeof(mono_chunk) == 2! */
operator|(
name|mdev
operator|->
name|color_info
operator|.
name|depth
operator|<
literal|8
condition|?
sizeof|sizeof
argument_list|(
name|mono_chunk
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
empty_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the initial transformation matrix */
end_comment

begin_function
name|void
name|mem_get_initial_matrix
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|)
block|{
operator|*
name|pmat
operator|=
name|mdev
operator|->
name|initial_matrix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Test whether a device is a memory device */
end_comment

begin_function
name|int
name|gs_device_is_memory
parameter_list|(
specifier|const
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
comment|/* We can't just compare the procs, or even an individual proc, */
comment|/* because we might be tracing.  Compare the device name, */
comment|/* and hope for the best. */
specifier|const
name|char
modifier|*
name|name
init|=
name|dev
operator|->
name|dname
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
operator|!=
literal|"image("
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Ensure that the data bytes are in big-endian order. */
end_comment

begin_comment
comment|/* This is never called on big-endian platforms; */
end_comment

begin_comment
comment|/* on little-endian platforms, the chunk size is ushort, */
end_comment

begin_comment
comment|/* regardless of the size of an int. */
end_comment

begin_function
name|void
name|gdev_mem_ensure_byte_order
parameter_list|(
name|gx_device_memory
modifier|*
name|dev
parameter_list|)
block|{
if|#
directive|if
operator|!
name|arch_is_big_endian
if|if
condition|(
operator|!
name|dev
operator|->
name|bytes_le
condition|)
return|return;
comment|/* already in order */
name|memswab
argument_list|(
name|dev
operator|->
name|base
argument_list|,
name|dev
operator|->
name|base
argument_list|,
name|dev
operator|->
name|raster
operator|*
name|dev
operator|->
name|height
argument_list|)
expr_stmt|;
name|dev
operator|->
name|bytes_le
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Copy one or more scan lines to a client. */
end_comment

begin_undef
undef|#
directive|undef
name|chunk
end_undef

begin_define
define|#
directive|define
name|chunk
value|byte
end_define

begin_function
name|int
name|mem_get_bits
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|y
parameter_list|,
name|byte
modifier|*
name|str
parameter_list|,
name|uint
name|size
parameter_list|,
name|int
name|pad_to_word
parameter_list|)
block|{
name|uint
name|bytes_per_line
init|=
name|gx_device_bytes_per_scan_line
argument_list|(
name|dev
argument_list|,
name|pad_to_word
argument_list|)
decl_stmt|;
name|byte
modifier|*
name|src
init|=
name|scan_line_base
argument_list|(
name|mdev
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|byte
modifier|*
name|dest
init|=
name|str
decl_stmt|;
name|uint
name|count
init|=
name|min
argument_list|(
name|size
operator|/
name|bytes_per_line
argument_list|,
name|dev
operator|->
name|height
operator|-
name|y
argument_list|)
decl_stmt|;
name|int
name|swap
init|=
name|mdev
operator|->
name|bytes_le
decl_stmt|;
if|if
condition|(
operator|!
name|mdev
operator|->
name|raster
condition|)
comment|/* compute it now */
operator|(
name|void
operator|)
name|gdev_mem_bitmap_size
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_per_line
operator|==
name|mdev
operator|->
name|raster
condition|)
block|{
if|if
condition|(
name|swap
operator|&&
name|pad_to_word
operator|>=
literal|0
condition|)
name|memswab
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|bytes_per_line
operator|*
name|count
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes_per_line
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* know pad_to_word == 0 */
block|{
name|uint
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|count
init|;
name|c
operator|--
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|swap
condition|)
block|{
comment|/* We have to take extra care if */
comment|/* bytes_per_line is odd. */
if|if
condition|(
name|bytes_per_line
operator|&
literal|1
condition|)
block|{
name|memswab
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|bytes_per_line
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dest
index|[
name|bytes_per_line
operator|-
literal|1
index|]
operator|=
name|src
index|[
name|bytes_per_line
index|]
expr_stmt|;
block|}
else|else
name|memswab
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|bytes_per_line
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes_per_line
argument_list|)
expr_stmt|;
name|src
operator|+=
name|mdev
operator|->
name|raster
expr_stmt|;
name|dest
operator|+=
name|bytes_per_line
expr_stmt|;
block|}
block|}
return|return
operator|(
name|swap
operator|&&
name|pad_to_word
operator|<
literal|0
condition|?
name|swap
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------ Monochrome ------ */
end_comment

begin_comment
comment|/* Procedures */
end_comment

begin_function_decl
name|private
name|dev_proc_copy_mono
parameter_list|(
name|mem_mono_copy_mono
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_fill_rectangle
parameter_list|(
name|mem_mono_fill_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The device descriptor. */
end_comment

begin_decl_stmt
name|private
name|gx_device_procs
name|mem_mono_procs
init|=
name|mem_procs
argument_list|(
name|gx_default_map_rgb_color
argument_list|,
name|gx_default_map_color_rgb
argument_list|,
name|mem_mono_copy_mono
argument_list|,
name|gx_default_copy_color
argument_list|,
name|mem_mono_fill_rectangle
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The instance is public. */
end_comment

begin_decl_stmt
name|gx_device_memory
name|mem_mono_device
init|=
name|mem_device
argument_list|(
literal|"image(mono)"
argument_list|,
literal|1
argument_list|,
name|mem_mono_procs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert x coordinate to byte offset in scan line. */
end_comment

begin_define
define|#
directive|define
name|x_to_byte
parameter_list|(
name|x
parameter_list|)
value|((x)>> 3)
end_define

begin_comment
comment|/* Fill a rectangle with a color. */
end_comment

begin_undef
undef|#
directive|undef
name|chunk
end_undef

begin_define
define|#
directive|define
name|chunk
value|mono_chunk
end_define

begin_function
name|private
name|int
name|mem_mono_fill_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|uint
name|bit
decl_stmt|;
name|chunk
name|right_mask
decl_stmt|;
name|byte
name|fill
decl_stmt|;
name|declare_scan_ptr
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|check_rect
argument_list|()
expr_stmt|;
name|setup_rect
argument_list|(
name|dest
argument_list|)
expr_stmt|;
define|#
directive|define
name|write_loop
parameter_list|(
name|stat
parameter_list|)
define|\
value|{ int line_count = h;\    chunk *ptr = dest;\    do { stat; inc_chunk_ptr(ptr, draster); }\    while ( --line_count );\  }
define|#
directive|define
name|write_partial
parameter_list|(
name|msk
parameter_list|)
define|\
value|if ( fill ) write_loop(*ptr |= msk)\    else write_loop(*ptr&= ~msk)
switch|switch
condition|(
name|color
condition|)
block|{
case|case
literal|0
case|:
name|fill
operator|=
name|mdev
operator|->
name|invert
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fill
operator|=
operator|~
name|mdev
operator|->
name|invert
expr_stmt|;
break|break;
case|case
name|gx_no_color_index
case|:
return|return
literal|0
return|;
comment|/* transparent */
default|default:
return|return
operator|-
literal|1
return|;
comment|/* invalid */
block|}
name|bit
operator|=
name|x
operator|&
name|chunk_bit_mask
expr_stmt|;
if|if
condition|(
name|bit
operator|+
name|w
operator|<=
name|chunk_bits
condition|)
block|{
comment|/* Only one word. */
name|right_mask
operator|=
operator|(
name|w
operator|==
name|chunk_bits
condition|?
name|chunk_all_bits
else|:
name|chunk_hi_bits
argument_list|(
name|w
argument_list|)
operator|)
operator|>>
name|bit
expr_stmt|;
block|}
else|else
block|{
name|int
name|byte_count
decl_stmt|;
if|if
condition|(
name|bit
condition|)
block|{
comment|/* We have to split the following statement */
comment|/* into two because of a bug in the DEC */
comment|/* VAX/VMS C compiler. */
name|chunk
name|mask
init|=
name|chunk_all_bits
decl_stmt|;
name|mask
operator|>>=
name|bit
expr_stmt|;
name|write_partial
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|dest
operator|++
expr_stmt|;
name|w
operator|+=
name|bit
operator|-
name|chunk_bits
expr_stmt|;
block|}
name|right_mask
operator|=
name|chunk_hi_bits
argument_list|(
name|w
operator|&
name|chunk_bit_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|byte_count
operator|=
operator|(
name|w
operator|>>
literal|3
operator|)
operator|&
operator|-
name|chunk_bytes
operator|)
operator|!=
literal|0
condition|)
block|{
name|write_loop
argument_list|(
name|memset
argument_list|(
name|ptr
argument_list|,
name|fill
argument_list|,
name|byte_count
argument_list|)
argument_list|)
expr_stmt|;
name|inc_chunk_ptr
argument_list|(
name|dest
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|right_mask
condition|)
name|write_partial
argument_list|(
name|right_mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a monochrome bitmap. */
end_comment

begin_comment
comment|/* Fetch a chunk from the source. */
end_comment

begin_comment
comment|/* Note that the source data are always stored big-endian. */
end_comment

begin_comment
comment|/* Note also that the macros always cast cptr, */
end_comment

begin_comment
comment|/* so it doesn't matter what the type of cptr is. */
end_comment

begin_undef
undef|#
directive|undef
name|chunk
end_undef

begin_if
if|#
directive|if
name|arch_is_big_endian
end_if

begin_define
define|#
directive|define
name|chunk
value|uint
end_define

begin_define
define|#
directive|define
name|cfetch
parameter_list|(
name|cptr
parameter_list|)
value|(*(chunk *)(cptr))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|chunk
value|ushort
end_define

begin_define
define|#
directive|define
name|cfetch
parameter_list|(
name|cptr
parameter_list|)
value|(((chunk)*(byte *)(cptr)<< 8) + ((byte *)(cptr))[1])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fetch a chunk that straddles a chunk boundary. */
end_comment

begin_comment
comment|/*** #if arch_is_big_endian ***/
end_comment

begin_define
define|#
directive|define
name|cfetch2
parameter_list|(
name|cptr
parameter_list|,
name|cskew
parameter_list|,
name|skew
parameter_list|)
define|\
value|((cfetch(cptr)<< cskew) + (cfetch((chunk *)(cptr) + 1)>> skew))
end_define

begin_comment
comment|/*** #else #  define cfetch2(cptr, cskew, skew)\     (cskew<= 8 ?\      (cfetch(cptr)<< cskew) + (((byte *)(cptr))[2]>> (skew - 8)) :\      (((byte *)(cptr))[1]<< cskew) + (cfetch((chunk *)(cptr) + 1)>> skew)) #endif ***/
end_comment

begin_comment
comment|/* copy_function and copy_shift get added together for dispatch */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|copy_or
init|=
literal|0
block|,
name|copy_store
block|,
name|copy_and
block|,
name|copy_funny
block|}
name|copy_function
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|copy_right
init|=
literal|0
block|,
name|copy_left
init|=
literal|4
block|}
name|copy_shift
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|short
name|invert
decl_stmt|;
name|ushort
name|op
decl_stmt|;
comment|/* copy_function */
block|}
name|copy_mode
typedef|;
end_typedef

begin_comment
comment|/* Map from<c0,c1,invert> to copy_mode. */
end_comment

begin_define
define|#
directive|define
name|cm
parameter_list|(
name|i
parameter_list|,
name|op
parameter_list|)
value|{ i, (ushort)op }
end_define

begin_decl_stmt
name|private
name|copy_mode
name|copy_modes
index|[
literal|9
operator|*
literal|2
index|]
init|=
block|{
name|cm
argument_list|(
operator|-
literal|1
argument_list|,
name|copy_funny
argument_list|)
block|,
comment|/* NN */
name|cm
argument_list|(
operator|-
literal|1
argument_list|,
name|copy_and
argument_list|)
block|,
comment|/* N0 */
name|cm
argument_list|(
literal|0
argument_list|,
name|copy_or
argument_list|)
block|,
comment|/* N1 */
name|cm
argument_list|(
literal|0
argument_list|,
name|copy_and
argument_list|)
block|,
comment|/* 0N */
name|cm
argument_list|(
literal|0
argument_list|,
name|copy_funny
argument_list|)
block|,
comment|/* 00 */
name|cm
argument_list|(
literal|0
argument_list|,
name|copy_store
argument_list|)
block|,
comment|/* 01 */
name|cm
argument_list|(
operator|-
literal|1
argument_list|,
name|copy_or
argument_list|)
block|,
comment|/* 1N */
name|cm
argument_list|(
operator|-
literal|1
argument_list|,
name|copy_store
argument_list|)
block|,
comment|/* 10 */
name|cm
argument_list|(
literal|0
argument_list|,
name|copy_funny
argument_list|)
block|,
comment|/* 11 */
name|cm
argument_list|(
operator|-
literal|1
argument_list|,
name|copy_funny
argument_list|)
block|,
comment|/* NNi */
name|cm
argument_list|(
literal|0
argument_list|,
name|copy_or
argument_list|)
block|,
comment|/* N1i */
name|cm
argument_list|(
operator|-
literal|1
argument_list|,
name|copy_and
argument_list|)
block|,
comment|/* N0i */
name|cm
argument_list|(
operator|-
literal|1
argument_list|,
name|copy_or
argument_list|)
block|,
comment|/* 1Ni */
name|cm
argument_list|(
literal|0
argument_list|,
name|copy_funny
argument_list|)
block|,
comment|/* 11i */
name|cm
argument_list|(
operator|-
literal|1
argument_list|,
name|copy_store
argument_list|)
block|,
comment|/* 10i */
name|cm
argument_list|(
literal|0
argument_list|,
name|copy_and
argument_list|)
block|,
comment|/* 0Ni */
name|cm
argument_list|(
literal|0
argument_list|,
name|copy_store
argument_list|)
block|,
comment|/* 01i */
name|cm
argument_list|(
literal|0
argument_list|,
argument|copy_funny
argument_list|)
comment|/* 00i */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|mem_mono_copy_mono
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|sraster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|zero
parameter_list|,
name|gx_color_index
name|one
parameter_list|)
block|{
specifier|register
name|byte
modifier|*
name|bptr
decl_stmt|;
comment|/* actually chunk * */
name|int
name|dbit
decl_stmt|,
name|wleft
decl_stmt|;
name|uint
name|mask
decl_stmt|;
name|copy_mode
name|mode
decl_stmt|;
define|#
directive|define
name|function
value|(copy_function)(mode.op)
name|declare_scan_ptr_as
argument_list|(
name|dbptr
argument_list|,
name|byte
operator|*
argument_list|)
expr_stmt|;
define|#
directive|define
name|optr
value|((chunk *)dbptr)
specifier|register
name|int
name|skew
decl_stmt|;
specifier|register
name|uint
name|invert
decl_stmt|;
name|check_rect
argument_list|()
expr_stmt|;
if|#
directive|if
name|gx_no_color_value
operator|!=
operator|-
literal|1
comment|/* hokey! */
if|if
condition|(
name|zero
operator|==
name|gx_no_color_index
condition|)
name|zero
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|one
operator|==
name|gx_no_color_index
condition|)
name|one
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|izero
value|(int)zero
define|#
directive|define
name|ione
value|(int)one
name|mode
operator|=
name|copy_modes
index|[
operator|(
name|mdev
operator|->
name|invert
operator|&
literal|9
operator|)
operator|+
name|izero
operator|+
name|izero
operator|+
name|izero
operator|+
name|ione
operator|+
literal|4
index|]
expr_stmt|;
undef|#
directive|undef
name|izero
undef|#
directive|undef
name|ione
name|invert
operator|=
operator|(
name|uint
operator|)
operator|(
name|int
operator|)
name|mode
operator|.
name|invert
expr_stmt|;
comment|/* load register */
name|setup_rect_as
argument_list|(
name|dbptr
argument_list|,
name|byte
operator|*
argument_list|)
expr_stmt|;
name|bptr
operator|=
name|base
operator|+
operator|(
operator|(
name|sourcex
operator|&
operator|~
name|chunk_bit_mask
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|dbit
operator|=
name|x
operator|&
name|chunk_bit_mask
expr_stmt|;
name|skew
operator|=
name|dbit
operator|-
operator|(
name|sourcex
operator|&
name|chunk_bit_mask
operator|)
expr_stmt|;
comment|/* We have to split the following statement */
comment|/* into two because of a bug in the DEC */
comment|/* VAX/VMS C compiler. */
name|mask
operator|=
name|chunk_all_bits
expr_stmt|;
name|mask
operator|>>=
name|dbit
expr_stmt|;
comment|/* Macros for writing partial chunks. */
comment|/* The destination pointer is always named optr, */
comment|/* and must be declared as chunk *. */
comment|/* cinvert may be temporarily redefined. */
define|#
directive|define
name|cinvert
parameter_list|(
name|bits
parameter_list|)
value|((bits) ^ invert)
define|#
directive|define
name|write_or_masked
parameter_list|(
name|bits
parameter_list|,
name|mask
parameter_list|,
name|off
parameter_list|)
define|\
value|optr[off] |= (cinvert(bits)& mask)
define|#
directive|define
name|write_store_masked
parameter_list|(
name|bits
parameter_list|,
name|mask
parameter_list|,
name|off
parameter_list|)
define|\
value|optr[off] = ((optr[off]& ~mask) | (cinvert(bits)& mask))
define|#
directive|define
name|write_and_masked
parameter_list|(
name|bits
parameter_list|,
name|mask
parameter_list|,
name|off
parameter_list|)
define|\
value|optr[off]&= (cinvert(bits) | ~mask)
comment|/* Macros for writing full chunks. */
define|#
directive|define
name|write_or
parameter_list|(
name|bits
parameter_list|)
value|*optr |= cinvert(bits)
define|#
directive|define
name|write_store
parameter_list|(
name|bits
parameter_list|)
value|*optr = cinvert(bits)
define|#
directive|define
name|write_and
parameter_list|(
name|bits
parameter_list|)
value|*optr&= cinvert(bits)
comment|/* Macro for incrementing to next chunk. */
define|#
directive|define
name|next_x_chunk
define|\
value|bptr += chunk_bytes; dbptr += chunk_bytes
comment|/* Common macro for the end of each scan line. */
define|#
directive|define
name|end_y_loop
parameter_list|(
name|sdelta
parameter_list|,
name|ddelta
parameter_list|)
define|\
value|if ( --h == 0 ) break;\   bptr += sdelta; dbptr += ddelta
if|if
condition|(
operator|(
name|wleft
operator|=
name|w
operator|+
name|dbit
operator|-
name|chunk_bits
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* The entire operation fits in one (destination) chunk. */
comment|/* Some machines can't handle w == chunk_bits! */
if|#
directive|if
name|arch_cant_shift_full_chunk
if|if
condition|(
name|w
operator|!=
name|chunk_bits
condition|)
endif|#
directive|endif
name|mask
operator|-=
name|mask
operator|>>
name|w
expr_stmt|;
define|#
directive|define
name|write_single
parameter_list|(
name|wr_op
parameter_list|,
name|src
parameter_list|)
define|\
value|for ( ; ; )\    { wr_op(src, mask, 0);\      end_y_loop(sraster, draster);\    }
define|#
directive|define
name|write1_loop
parameter_list|(
name|src
parameter_list|)
define|\
value|switch ( function ) {\     case copy_or: write_single(write_or_masked, src); break;\     case copy_store: write_single(write_store_masked, src); break;\     case copy_and: write_single(write_and_masked, src); break;\     default: goto funny;\   }
if|if
condition|(
name|skew
operator|>=
literal|0
condition|)
comment|/* single -> single, right/no shift */
block|{
name|write1_loop
argument_list|(
name|cfetch
argument_list|(
name|bptr
argument_list|)
operator|>>
name|skew
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wleft
operator|<=
name|skew
condition|)
comment|/* single -> single, left shift */
block|{
name|skew
operator|=
operator|-
name|skew
expr_stmt|;
name|write1_loop
argument_list|(
name|cfetch
argument_list|(
name|bptr
argument_list|)
operator|<<
name|skew
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* double -> single */
block|{
name|int
name|cskew
init|=
operator|-
name|skew
decl_stmt|;
name|skew
operator|+=
name|chunk_bits
expr_stmt|;
name|write1_loop
argument_list|(
name|cfetch2
argument_list|(
name|bptr
argument_list|,
name|cskew
argument_list|,
name|skew
argument_list|)
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|write1_loop
undef|#
directive|undef
name|write_single
block|}
elseif|else
if|if
condition|(
name|wleft
operator|<=
name|skew
condition|)
block|{
comment|/* 1 source chunk -> 2 destination chunks. */
comment|/* This is an important special case for */
comment|/* both characters and halftone tiles. */
specifier|register
name|uint
name|bits
decl_stmt|;
name|uint
name|rmask
init|=
name|chunk_hi_bits
argument_list|(
name|wleft
argument_list|)
decl_stmt|;
name|int
name|cskew
init|=
name|chunk_bits
operator|-
name|skew
decl_stmt|;
define|#
directive|define
name|write_1to2
parameter_list|(
name|wr_op
parameter_list|)
define|\
value|for ( ; ; )\    { bits = cfetch(bptr) ^ invert;\      wr_op(bits>> skew, mask, 0);\      wr_op(bits<< cskew, rmask, 1);\      end_y_loop(sraster, draster);\    }
undef|#
directive|undef
name|cinvert
define|#
directive|define
name|cinvert
parameter_list|(
name|bits
parameter_list|)
value|(bits)
comment|/* pre-inverted here */
switch|switch
condition|(
name|function
condition|)
block|{
case|case
name|copy_or
case|:
name|write_1to2
argument_list|(
name|write_or_masked
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_store
case|:
name|write_1to2
argument_list|(
name|write_store_masked
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_and
case|:
name|write_1to2
argument_list|(
name|write_and_masked
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|funny
goto|;
block|}
undef|#
directive|undef
name|cinvert
define|#
directive|define
name|cinvert
parameter_list|(
name|bits
parameter_list|)
value|((bits) ^ invert)
undef|#
directive|undef
name|write_1to2
block|}
else|else
block|{
comment|/* More than one source chunk and more than one */
comment|/* destination chunk are involved. */
name|uint
name|rmask
init|=
name|chunk_hi_bits
argument_list|(
name|wleft
operator|&
name|chunk_bit_mask
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|wleft
operator|&
operator|~
name|chunk_bit_mask
operator|)
operator|>>
literal|3
decl_stmt|;
name|uint
name|sskip
init|=
name|sraster
operator|-
name|words
decl_stmt|;
name|uint
name|dskip
init|=
name|draster
operator|-
name|words
decl_stmt|;
specifier|register
name|uint
name|bits
decl_stmt|;
if|if
condition|(
name|skew
operator|==
literal|0
condition|)
comment|/* optimize the aligned case */
block|{
define|#
directive|define
name|write_aligned
parameter_list|(
name|wr_op
parameter_list|,
name|wr_op_masked
parameter_list|)
define|\
value|for ( ; ; )\    { int count = wleft;\
comment|/* Do first partial chunk. */
value|\      wr_op_masked(cfetch(bptr), mask, 0);\
comment|/* Do full chunks. */
value|\      while ( (count -= chunk_bits)>= 0 )\       { next_x_chunk; wr_op(cfetch(bptr)); }\
comment|/* Do last chunk */
value|\      if ( count> -chunk_bits )\       { wr_op_masked(cfetch(bptr + chunk_bytes), rmask, 1); }\      end_y_loop(sskip, dskip);\    }
switch|switch
condition|(
name|function
condition|)
block|{
case|case
name|copy_or
case|:
name|write_aligned
argument_list|(
name|write_or
argument_list|,
name|write_or_masked
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_store
case|:
name|write_aligned
argument_list|(
name|write_store
argument_list|,
name|write_store_masked
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_and
case|:
name|write_aligned
argument_list|(
name|write_and
argument_list|,
name|write_and_masked
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|funny
goto|;
block|}
undef|#
directive|undef
name|write_aligned
block|}
else|else
comment|/* not aligned */
block|{
name|int
name|ccase
init|=
operator|(
name|skew
operator|>=
literal|0
condition|?
name|copy_right
else|:
operator|(
operator|(
name|bptr
operator|+=
name|chunk_bytes
operator|)
expr|,
name|copy_left
operator|)
operator|)
operator|+
name|function
decl_stmt|;
name|int
name|cskew
init|=
operator|-
name|skew
operator|&
name|chunk_bit_mask
decl_stmt|;
name|skew
operator|&=
name|chunk_bit_mask
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|count
init|=
name|wleft
decl_stmt|;
define|#
directive|define
name|prefetch_right
define|\
value|bits = cfetch(bptr)>> skew
define|#
directive|define
name|prefetch_left
define|\
value|bits = cfetch2(bptr - chunk_bytes, cskew, skew)
define|#
directive|define
name|write_unaligned
parameter_list|(
name|wr_op
parameter_list|,
name|wr_op_masked
parameter_list|)
define|\
value|wr_op_masked(bits, mask, 0);\
comment|/* Do full chunks. */
value|\   while ( count>= chunk_bits )\     { bits = cfetch2(bptr, cskew, skew);\       next_x_chunk; wr_op(bits); count -= chunk_bits;\     }\
comment|/* Do last chunk */
value|\   if ( count> 0 )\     { bits = cfetch(bptr)<< cskew;\       if ( count> skew ) bits += cfetch(bptr + chunk_bytes)>> skew;\       wr_op_masked(bits, rmask, 1);\     }
switch|switch
condition|(
name|ccase
condition|)
block|{
case|case
name|copy_or
operator|+
name|copy_left
case|:
name|prefetch_left
expr_stmt|;
goto|goto
name|uor
goto|;
case|case
name|copy_or
operator|+
name|copy_right
case|:
name|prefetch_right
expr_stmt|;
name|uor
label|:
name|write_unaligned
argument_list|(
name|write_or
argument_list|,
name|write_or_masked
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_store
operator|+
name|copy_left
case|:
name|prefetch_left
expr_stmt|;
goto|goto
name|ustore
goto|;
case|case
name|copy_store
operator|+
name|copy_right
case|:
name|prefetch_right
expr_stmt|;
name|ustore
label|:
name|write_unaligned
argument_list|(
name|write_store
argument_list|,
name|write_store_masked
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_and
operator|+
name|copy_left
case|:
name|prefetch_left
expr_stmt|;
goto|goto
name|uand
goto|;
case|case
name|copy_and
operator|+
name|copy_right
case|:
name|prefetch_right
expr_stmt|;
name|uand
label|:
name|write_unaligned
argument_list|(
name|write_and
argument_list|,
name|write_and_masked
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|funny
goto|;
block|}
name|end_y_loop
argument_list|(
name|sskip
argument_list|,
name|dskip
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|write_unaligned
undef|#
directive|undef
name|prefetch_left
undef|#
directive|undef
name|prefetch_right
block|}
block|}
block|}
undef|#
directive|undef
name|end_y_loop
undef|#
directive|undef
name|next_x_chunk
return|return
literal|0
return|;
comment|/* Handle the funny cases that aren't supposed to happen. */
name|funny
label|:
return|return
operator|(
name|invert
condition|?
operator|-
literal|1
else|:
name|mem_mono_fill_rectangle
argument_list|(
name|dev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|zero
argument_list|)
operator|)
return|;
undef|#
directive|undef
name|optr
block|}
end_function

end_unit

