begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gxpath2.c */
end_comment

begin_comment
comment|/* Path tracing procedures for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"math_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxarith.h"
end_include

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
name|private
name|int
name|copy_path
argument_list|(
name|P3
argument_list|(
name|gx_path
operator|*
argument_list|,
name|gx_path
operator|*
argument_list|,
name|fixed
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|flatten_recur
argument_list|(
name|P8
argument_list|(
name|gx_path
operator|*
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the current point of a path. */
end_comment

begin_function
name|int
name|gx_path_current_point
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|gs_fixed_point
modifier|*
name|ppt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ppath
operator|->
name|position_valid
condition|)
name|return_error
argument_list|(
name|gs_error_nocurrentpoint
argument_list|)
expr_stmt|;
comment|/* Copying the coordinates individually */
comment|/* is much faster on a PC, and almost as fast on other machines.... */
name|ppt
operator|->
name|x
operator|=
name|ppath
operator|->
name|position
operator|.
name|x
operator|,
name|ppt
operator|->
name|y
operator|=
name|ppath
operator|->
name|position
operator|.
name|y
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read the bounding box of a path. */
end_comment

begin_function
name|int
name|gx_path_bbox
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|gs_fixed_rect
modifier|*
name|pbox
parameter_list|)
block|{
if|if
condition|(
name|ppath
operator|->
name|first_subpath
operator|==
literal|0
condition|)
block|{
comment|/* The path is empty, use the current point if any. */
name|gx_path_current_point
argument_list|(
name|ppath
argument_list|,
operator|&
name|pbox
operator|->
name|p
argument_list|)
expr_stmt|;
return|return
name|gx_path_current_point
argument_list|(
name|ppath
argument_list|,
operator|&
name|pbox
operator|->
name|q
argument_list|)
return|;
block|}
comment|/* The stored bounding box may not be up to date. */
comment|/* Correct it now if necessary. */
if|if
condition|(
name|ppath
operator|->
name|box_last
operator|==
name|ppath
operator|->
name|current_subpath
operator|->
name|last
condition|)
block|{
comment|/* Box is up to date */
operator|*
name|pbox
operator|=
name|ppath
operator|->
name|bbox
expr_stmt|;
block|}
else|else
block|{
name|gs_fixed_rect
name|box
decl_stmt|;
specifier|register
name|segment
modifier|*
name|pseg
init|=
name|ppath
operator|->
name|box_last
decl_stmt|;
if|if
condition|(
name|pseg
operator|==
literal|0
condition|)
comment|/* box is uninitialized */
block|{
name|pseg
operator|=
operator|(
name|segment
operator|*
operator|)
name|ppath
operator|->
name|first_subpath
expr_stmt|;
name|box
operator|.
name|p
operator|.
name|x
operator|=
name|box
operator|.
name|q
operator|.
name|x
operator|=
name|pseg
operator|->
name|pt
operator|.
name|x
expr_stmt|;
name|box
operator|.
name|p
operator|.
name|y
operator|=
name|box
operator|.
name|q
operator|.
name|y
operator|=
name|pseg
operator|->
name|pt
operator|.
name|y
expr_stmt|;
block|}
else|else
block|{
name|box
operator|=
name|ppath
operator|->
name|bbox
expr_stmt|;
name|pseg
operator|=
name|pseg
operator|->
name|next
expr_stmt|;
block|}
comment|/* Macro for adjusting the bounding box when adding a point */
define|#
directive|define
name|adjust_bbox
parameter_list|(
name|pt
parameter_list|)
define|\
value|if ( (pt).x< box.p.x ) box.p.x = (pt).x;\   else if ( (pt).x> box.q.x ) box.q.x = (pt).x;\   if ( (pt).y< box.p.y ) box.p.y = (pt).y;\   else if ( (pt).y> box.q.y ) box.q.y = (pt).y
while|while
condition|(
name|pseg
condition|)
block|{
switch|switch
condition|(
name|pseg
operator|->
name|type
condition|)
block|{
case|case
name|s_curve
case|:
define|#
directive|define
name|pcurve
value|((curve_segment *)pseg)
name|adjust_bbox
argument_list|(
name|pcurve
operator|->
name|p1
argument_list|)
expr_stmt|;
name|adjust_bbox
argument_list|(
name|pcurve
operator|->
name|p2
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|pcurve
comment|/* falls through */
default|default:
name|adjust_bbox
argument_list|(
name|pseg
operator|->
name|pt
argument_list|)
expr_stmt|;
block|}
name|pseg
operator|=
name|pseg
operator|->
name|next
expr_stmt|;
block|}
undef|#
directive|undef
name|adjust_bbox
name|ppath
operator|->
name|bbox
operator|=
name|box
expr_stmt|;
name|ppath
operator|->
name|box_last
operator|=
name|ppath
operator|->
name|current_subpath
operator|->
name|last
expr_stmt|;
operator|*
name|pbox
operator|=
name|box
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Test if a path has any curves. */
end_comment

begin_function
name|int
name|gx_path_has_curves
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
return|return
name|ppath
operator|->
name|curve_count
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Test if a path has any segments. */
end_comment

begin_function
name|int
name|gx_path_is_void
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
return|return
name|ppath
operator|->
name|first_subpath
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Test if a path is a rectangle. */
end_comment

begin_comment
comment|/* If so, return its bounding box. */
end_comment

begin_comment
comment|/* Note that this must recognize open as well as closed rectangles. */
end_comment

begin_function
name|int
name|gx_path_is_rectangle
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|gs_fixed_rect
modifier|*
name|pbox
parameter_list|)
block|{
name|subpath
modifier|*
name|pseg0
decl_stmt|;
name|segment
modifier|*
name|pseg1
decl_stmt|,
modifier|*
name|pseg2
decl_stmt|,
modifier|*
name|pseg3
decl_stmt|,
modifier|*
name|pseg4
decl_stmt|;
if|if
condition|(
name|ppath
operator|->
name|subpath_count
operator|==
literal|1
operator|&&
operator|(
name|pseg1
operator|=
operator|(
name|pseg0
operator|=
name|ppath
operator|->
name|first_subpath
operator|)
operator|->
name|next
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|pseg2
operator|=
name|pseg1
operator|->
name|next
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|pseg3
operator|=
name|pseg2
operator|->
name|next
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|pseg4
operator|=
name|pseg3
operator|->
name|next
operator|)
operator|==
literal|0
operator|||
name|pseg4
operator|->
name|type
operator|==
name|s_line_close
operator|)
operator|&&
name|ppath
operator|->
name|curve_count
operator|==
literal|0
condition|)
block|{
name|fixed
name|x0
init|=
name|pseg0
operator|->
name|pt
operator|.
name|x
decl_stmt|,
name|y0
init|=
name|pseg0
operator|->
name|pt
operator|.
name|y
decl_stmt|;
name|fixed
name|x2
init|=
name|pseg2
operator|->
name|pt
operator|.
name|x
decl_stmt|,
name|y2
init|=
name|pseg2
operator|->
name|pt
operator|.
name|y
decl_stmt|;
if|if
condition|(
operator|(
name|x0
operator|==
name|pseg1
operator|->
name|pt
operator|.
name|x
operator|&&
name|pseg1
operator|->
name|pt
operator|.
name|y
operator|==
name|y2
operator|&&
name|x2
operator|==
name|pseg3
operator|->
name|pt
operator|.
name|x
operator|&&
name|pseg3
operator|->
name|pt
operator|.
name|y
operator|==
name|y0
operator|)
operator|||
operator|(
name|x0
operator|==
name|pseg3
operator|->
name|pt
operator|.
name|x
operator|&&
name|pseg3
operator|->
name|pt
operator|.
name|y
operator|==
name|y2
operator|&&
name|x2
operator|==
name|pseg1
operator|->
name|pt
operator|.
name|x
operator|&&
name|pseg1
operator|->
name|pt
operator|.
name|y
operator|==
name|y0
operator|)
condition|)
block|{
comment|/* Path is a rectangle.  Return bounding box. */
if|if
condition|(
name|x0
operator|<
name|x2
condition|)
name|pbox
operator|->
name|p
operator|.
name|x
operator|=
name|x0
operator|,
name|pbox
operator|->
name|q
operator|.
name|x
operator|=
name|x2
expr_stmt|;
else|else
name|pbox
operator|->
name|p
operator|.
name|x
operator|=
name|x2
operator|,
name|pbox
operator|->
name|q
operator|.
name|x
operator|=
name|x0
expr_stmt|;
if|if
condition|(
name|y0
operator|<
name|y2
condition|)
name|pbox
operator|->
name|p
operator|.
name|y
operator|=
name|y0
operator|,
name|pbox
operator|->
name|q
operator|.
name|y
operator|=
name|y2
expr_stmt|;
else|else
name|pbox
operator|->
name|p
operator|.
name|y
operator|=
name|y2
operator|,
name|pbox
operator|->
name|q
operator|.
name|y
operator|=
name|y0
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a path */
end_comment

begin_function
name|int
name|gx_path_copy
parameter_list|(
name|gx_path
modifier|*
name|ppath_old
parameter_list|,
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
return|return
name|copy_path
argument_list|(
name|ppath_old
argument_list|,
name|ppath
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Translate an already-constructed path (in device space). */
end_comment

begin_comment
comment|/* Don't bother to translate the cbox. */
end_comment

begin_function
name|int
name|gx_path_translate
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|fixed
name|dx
parameter_list|,
name|fixed
name|dy
parameter_list|)
block|{
name|segment
modifier|*
name|pseg
decl_stmt|;
define|#
directive|define
name|translate_xy
parameter_list|(
name|pt
parameter_list|)
define|\
value|pt.x += dx, pt.y += dy
name|translate_xy
argument_list|(
name|ppath
operator|->
name|bbox
operator|.
name|p
argument_list|)
expr_stmt|;
name|translate_xy
argument_list|(
name|ppath
operator|->
name|bbox
operator|.
name|q
argument_list|)
expr_stmt|;
name|translate_xy
argument_list|(
name|ppath
operator|->
name|position
argument_list|)
expr_stmt|;
name|pseg
operator|=
operator|(
name|segment
operator|*
operator|)
operator|(
name|ppath
operator|->
name|first_subpath
operator|)
expr_stmt|;
while|while
condition|(
name|pseg
condition|)
block|{
switch|switch
condition|(
name|pseg
operator|->
name|type
condition|)
block|{
case|case
name|s_curve
case|:
block|{
name|curve_segment
modifier|*
name|pc
init|=
operator|(
name|curve_segment
operator|*
operator|)
name|pseg
decl_stmt|;
name|translate_xy
argument_list|(
name|pc
operator|->
name|p1
argument_list|)
expr_stmt|;
name|translate_xy
argument_list|(
name|pc
operator|->
name|p2
argument_list|)
expr_stmt|;
block|}
default|default:
name|translate_xy
argument_list|(
name|pseg
operator|->
name|pt
argument_list|)
expr_stmt|;
block|}
name|pseg
operator|=
name|pseg
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Flatten a path */
end_comment

begin_function
name|private
name|fixed
name|scale_flatness
parameter_list|(
name|floatp
name|flatness
parameter_list|)
block|{
comment|/* See the flattening algorithm below for an explanation of */
comment|/* the following computation. */
name|fixed
name|scaled_flat
init|=
name|float2fixed
argument_list|(
name|flatness
argument_list|)
decl_stmt|;
return|return
operator|(
name|scaled_flat
operator|>
name|int2fixed
argument_list|(
literal|100
argument_list|)
condition|?
name|int2fixed
argument_list|(
literal|100
argument_list|)
else|:
name|scaled_flat
operator|<=
name|float2fixed
argument_list|(
literal|0.2
argument_list|)
condition|?
name|float2fixed
argument_list|(
literal|0.2
argument_list|)
else|:
name|scaled_flat
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gx_path_flatten
parameter_list|(
name|gx_path
modifier|*
name|ppath_old
parameter_list|,
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|floatp
name|flatness
parameter_list|)
block|{
return|return
name|copy_path
argument_list|(
name|ppath_old
argument_list|,
name|ppath
argument_list|,
name|scale_flatness
argument_list|(
name|flatness
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a flattened curve to a path. */
end_comment

begin_function
name|int
name|gx_path_add_flattened_curve
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|fixed
name|x1
parameter_list|,
name|fixed
name|y1
parameter_list|,
name|fixed
name|x2
parameter_list|,
name|fixed
name|y2
parameter_list|,
name|fixed
name|x3
parameter_list|,
name|fixed
name|y3
parameter_list|,
name|floatp
name|flatness
parameter_list|)
block|{
return|return
name|flatten_recur
argument_list|(
name|ppath
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|,
name|scale_flatness
argument_list|(
name|flatness
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy a path, optionally flattening it. */
end_comment

begin_comment
comment|/* If the copy fails, free the new path. */
end_comment

begin_function
name|private
name|int
name|copy_path
parameter_list|(
name|gx_path
modifier|*
name|ppath_old
parameter_list|,
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|fixed
name|scaled_flat
parameter_list|)
block|{
name|gx_path
name|old
decl_stmt|;
name|segment
modifier|*
name|pseg
decl_stmt|;
name|int
name|code
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'p'
index|]
condition|)
name|gx_dump_path
argument_list|(
name|ppath_old
argument_list|,
literal|"before copy_path"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|old
operator|=
operator|*
name|ppath_old
expr_stmt|;
name|gx_path_init
argument_list|(
name|ppath
argument_list|,
operator|&
name|ppath_old
operator|->
name|memory_procs
argument_list|)
expr_stmt|;
name|pseg
operator|=
operator|(
name|segment
operator|*
operator|)
operator|(
name|old
operator|.
name|first_subpath
operator|)
expr_stmt|;
while|while
condition|(
name|pseg
condition|)
block|{
switch|switch
condition|(
name|pseg
operator|->
name|type
condition|)
block|{
case|case
name|s_start
case|:
name|code
operator|=
name|gx_path_add_point
argument_list|(
name|ppath
argument_list|,
name|pseg
operator|->
name|pt
operator|.
name|x
argument_list|,
name|pseg
operator|->
name|pt
operator|.
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
name|s_curve
case|:
block|{
name|curve_segment
modifier|*
name|pc
init|=
operator|(
name|curve_segment
operator|*
operator|)
name|pseg
decl_stmt|;
if|if
condition|(
name|scaled_flat
operator|==
literal|0
condition|)
comment|/* don't flatten */
name|code
operator|=
name|gx_path_add_curve
argument_list|(
name|ppath
argument_list|,
name|pc
operator|->
name|p1
operator|.
name|x
argument_list|,
name|pc
operator|->
name|p1
operator|.
name|y
argument_list|,
name|pc
operator|->
name|p2
operator|.
name|x
argument_list|,
name|pc
operator|->
name|p2
operator|.
name|y
argument_list|,
name|pc
operator|->
name|pt
operator|.
name|x
argument_list|,
name|pc
operator|->
name|pt
operator|.
name|y
argument_list|)
expr_stmt|;
else|else
name|code
operator|=
name|flatten_recur
argument_list|(
name|ppath
argument_list|,
name|pc
operator|->
name|p1
operator|.
name|x
argument_list|,
name|pc
operator|->
name|p1
operator|.
name|y
argument_list|,
name|pc
operator|->
name|p2
operator|.
name|x
argument_list|,
name|pc
operator|->
name|p2
operator|.
name|y
argument_list|,
name|pc
operator|->
name|pt
operator|.
name|x
argument_list|,
name|pc
operator|->
name|pt
operator|.
name|y
argument_list|,
name|scaled_flat
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|s_line
case|:
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|pseg
operator|->
name|pt
operator|.
name|x
argument_list|,
name|pseg
operator|->
name|pt
operator|.
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
name|s_line_close
case|:
name|code
operator|=
name|gx_path_close_subpath
argument_list|(
name|ppath
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|code
condition|)
block|{
name|gx_path_release
argument_list|(
name|ppath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppath
operator|==
name|ppath_old
condition|)
operator|*
name|ppath_old
operator|=
name|old
expr_stmt|;
return|return
name|code
return|;
block|}
name|pseg
operator|=
name|pseg
operator|->
name|next
expr_stmt|;
block|}
name|ppath
operator|->
name|position
operator|=
name|old
operator|.
name|position
expr_stmt|;
comment|/* restore current point */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'p'
index|]
condition|)
name|gx_dump_path
argument_list|(
name|ppath
argument_list|,
literal|"after copy_path"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internal routine to flatten a curve. */
end_comment

begin_comment
comment|/* This calls itself recursively, using binary subdivision, */
end_comment

begin_comment
comment|/* until the approximation is good enough to satisfy the */
end_comment

begin_comment
comment|/* flatness requirement.  The starting point is ppath->position, */
end_comment

begin_comment
comment|/* which gets updated as line segments are added. */
end_comment

begin_comment
comment|/* Table of f(i) = 256 * sqrt(1 + (i/64)^2). */
end_comment

begin_comment
comment|/* This is good to within 1% or better. */
end_comment

begin_define
define|#
directive|define
name|sqrt_index_shift
value|6
end_define

begin_comment
comment|/* scaling of index */
end_comment

begin_define
define|#
directive|define
name|sqrt_value_shift
value|8
end_define

begin_comment
comment|/* scaling of value */
end_comment

begin_decl_stmt
name|private
name|int
name|scaled_sqrt_tab
index|[
literal|65
index|]
init|=
block|{
literal|256
block|,
literal|256
block|,
literal|256
block|,
literal|256
block|,
literal|256
block|,
literal|256
block|,
literal|257
block|,
literal|257
block|,
literal|257
block|,
literal|258
block|,
literal|259
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|262
block|,
literal|262
block|,
literal|263
block|,
literal|264
block|,
literal|265
block|,
literal|267
block|,
literal|268
block|,
literal|269
block|,
literal|270
block|,
literal|272
block|,
literal|273
block|,
literal|274
block|,
literal|276
block|,
literal|277
block|,
literal|279
block|,
literal|281
block|,
literal|282
block|,
literal|284
block|,
literal|286
block|,
literal|288
block|,
literal|289
block|,
literal|291
block|,
literal|293
block|,
literal|295
block|,
literal|297
block|,
literal|299
block|,
literal|301
block|,
literal|304
block|,
literal|306
block|,
literal|308
block|,
literal|310
block|,
literal|312
block|,
literal|315
block|,
literal|317
block|,
literal|320
block|,
literal|322
block|,
literal|324
block|,
literal|327
block|,
literal|329
block|,
literal|332
block|,
literal|334
block|,
literal|337
block|,
literal|340
block|,
literal|342
block|,
literal|345
block|,
literal|348
block|,
literal|350
block|,
literal|353
block|,
literal|356
block|,
literal|359
block|,
literal|362
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|flatten_sample
argument_list|(
name|P8
argument_list|(
name|gx_path
operator|*
argument_list|,
name|int
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|flatten_recur
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|fixed
name|x1
parameter_list|,
name|fixed
name|y1
parameter_list|,
name|fixed
name|x2
parameter_list|,
name|fixed
name|y2
parameter_list|,
name|fixed
name|x3
parameter_list|,
name|fixed
name|y3
parameter_list|,
name|fixed
name|scaled_flat
parameter_list|)
block|{
name|fixed
name|x0
init|=
name|ppath
operator|->
name|position
operator|.
name|x
decl_stmt|,
name|y0
init|=
name|ppath
operator|->
name|position
operator|.
name|y
decl_stmt|;
name|top
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'2'
index|]
condition|)
name|dprintf4
argument_list|(
literal|"[2]x0=%f y0=%f x1=%f y1=%f\n"
argument_list|,
name|fixed2float
argument_list|(
name|x0
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|y0
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|x1
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|y1
argument_list|)
argument_list|)
operator|,
name|dprintf4
argument_list|(
literal|"   x2=%f y2=%f x3=%f y3=%f\n"
argument_list|,
name|fixed2float
argument_list|(
name|x2
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|y2
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|x3
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|y3
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Compute the maximum distance of the curve from 	 * the line (x0,y0)->(x3,y3).  We do this conservatively 	 * by observing that the curve is enclosed by the 	 * quadrilateral of its control points, so we simply 	 * compute the distances of (x1,y1) and (x2,y2) 	 * from the line.  Letting dx = x3-x0 and dy = y3-y0, 	 * the distance of (xp,yp) from the line is 	 * abs(N)/sqrt(D), where N = dy*(xp-x0)-dx*(yp-y0) and 	 * D = dx*dx+dy*dy; hence we want to test abs(N)<= sqrt(D)*F, 	 * where F is the flatness parameter from the graphics state. 	 * We can do this more efficiently by letting t=dy/dx, and 	 * testing abs(N1)<= sqrt(D1)*f, where N1=t*(xp-x0)-(yp-y0) and 	 * D1 = 1+t*t.  If dx< dy, we swap x and y for this 	 * computation.  This guarantees abs(t)<= 1, which allows us to 	 * compute sqrt(1+t*t) by table lookup on the high bits of abs(t). 	 */
block|{
name|fixed
name|dx3
init|=
name|x3
operator|-
name|x0
decl_stmt|;
name|fixed
name|adx3
init|=
name|any_abs
argument_list|(
name|dx3
argument_list|)
decl_stmt|;
name|fixed
name|dy3
init|=
name|y3
operator|-
name|y0
decl_stmt|;
name|fixed
name|ady3
init|=
name|any_abs
argument_list|(
name|dy3
argument_list|)
decl_stmt|;
comment|/* We have to be quite careful to ensure that */
comment|/* none of the multiplications will overflow. */
define|#
directive|define
name|short_max
value|0x7ff0L
define|#
directive|define
name|reduce_3
parameter_list|(
name|ad3
parameter_list|,
name|maxv
parameter_list|)
define|\
value|while ( ad3> maxv )\     adx3>>= 1, ady3>>= 1,\     dx3 = arith_rshift_1(dx3), dy3 = arith_rshift_1(dy3)
define|#
directive|define
name|reduce_d
parameter_list|(
name|d
parameter_list|)
define|\
value|for ( shift = 0; (d< 0 ? d< -short_max : d> short_max); shift++ )\     d = arith_rshift_1(d)
if|if
condition|(
name|adx3
operator|>
name|ady3
condition|)
block|{
name|fixed
name|d
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|dist
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|reduce_3
argument_list|(
name|ady3
argument_list|,
name|short_max
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|scaled_sqrt_tab
index|[
operator|(
name|ady3
operator|<<
name|sqrt_index_shift
operator|)
operator|/
name|adx3
index|]
operator|*
name|scaled_flat
operator|)
operator|>>
name|sqrt_value_shift
expr_stmt|;
name|dx
operator|=
name|x1
operator|-
name|x0
operator|,
name|dy
operator|=
name|y1
operator|-
name|y0
expr_stmt|;
name|reduce_d
argument_list|(
name|dx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dist
operator|=
operator|(
operator|(
name|dx
operator|*
name|dy3
operator|/
name|dx3
operator|)
operator|<<
name|shift
operator|)
operator|-
name|dy
operator|)
operator|<
literal|0
condition|?
operator|-
name|dist
else|:
name|dist
operator|)
operator|>
name|d
condition|)
goto|goto
name|sub
goto|;
comment|/* not flat enough */
name|dx
operator|=
name|x2
operator|-
name|x0
operator|,
name|dy
operator|=
name|y2
operator|-
name|y0
expr_stmt|;
name|reduce_d
argument_list|(
name|dx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dist
operator|=
operator|(
operator|(
name|dx
operator|*
name|dy3
operator|/
name|dx3
operator|)
operator|<<
name|shift
operator|)
operator|-
name|dy
operator|)
operator|<
literal|0
condition|?
operator|-
name|dist
else|:
name|dist
operator|)
operator|>
name|d
condition|)
goto|goto
name|sub
goto|;
comment|/* not flat enough */
block|}
elseif|else
if|if
condition|(
name|ady3
operator|!=
literal|0
condition|)
block|{
name|fixed
name|d
decl_stmt|,
name|dy
decl_stmt|,
name|dx
decl_stmt|,
name|dist
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|reduce_3
argument_list|(
name|adx3
argument_list|,
name|short_max
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|scaled_sqrt_tab
index|[
operator|(
name|adx3
operator|<<
name|sqrt_index_shift
operator|)
operator|/
name|ady3
index|]
operator|*
name|scaled_flat
operator|)
operator|>>
name|sqrt_value_shift
expr_stmt|;
name|dy
operator|=
name|y1
operator|-
name|y0
operator|,
name|dx
operator|=
name|x1
operator|-
name|x0
expr_stmt|;
name|reduce_d
argument_list|(
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dist
operator|=
operator|(
operator|(
name|dy
operator|*
name|dx3
operator|/
name|dy3
operator|)
operator|<<
name|shift
operator|)
operator|-
name|dx
operator|)
operator|<
literal|0
condition|?
operator|-
name|dist
else|:
name|dist
operator|)
operator|>
name|d
condition|)
goto|goto
name|sub
goto|;
comment|/* not flat enough */
name|dy
operator|=
name|y2
operator|-
name|y0
operator|,
name|dx
operator|=
name|x2
operator|-
name|x0
expr_stmt|;
name|reduce_d
argument_list|(
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dist
operator|=
operator|(
operator|(
name|dy
operator|*
name|dx3
operator|/
name|dy3
operator|)
operator|<<
name|shift
operator|)
operator|-
name|dx
operator|)
operator|<
literal|0
condition|?
operator|-
name|dist
else|:
name|dist
operator|)
operator|>
name|d
condition|)
goto|goto
name|sub
goto|;
comment|/* not flat enough */
block|}
else|else
comment|/* adx3 = ady3 = 0 */
block|{
comment|/* (x0,y0) is the same point as (x3,y3). */
comment|/* This is an anomalous case.  If the entire curve */
comment|/* is a single point, stop now, otherwise subdivide. */
if|if
condition|(
name|x1
operator|!=
name|x0
operator|||
name|y1
operator|!=
name|y0
operator|||
name|x2
operator|!=
name|x0
operator|||
name|y2
operator|!=
name|y0
condition|)
goto|goto
name|sub
goto|;
block|}
block|}
comment|/* Curve is flat enough.  Add a line and exit. */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'2'
index|]
condition|)
name|dprintf2
argument_list|(
literal|"[2]\t*** x=%f, y=%f ***\n"
argument_list|,
name|fixed2float
argument_list|(
name|x3
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|y3
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
return|;
comment|/* Curve isn't flat enough.  Break into two pieces and recur. */
comment|/* Algorithm is from "The Beta2-split: A special case of the */
comment|/* Beta-spline Curve and Surface Representation," B. A. Barsky */
comment|/* and A. D. DeRose, IEEE, 1985, courtesy of Crispin Goswell. */
name|sub
label|:
comment|/* We have to define midpoint carefully to avoid overflow. */
comment|/* (If it overflows, something really pathological is going on, */
comment|/* but we could get infinite recursion that way.... */
define|#
directive|define
name|midpoint
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|(arith_rshift_1(a) + arith_rshift_1(b) + ((a)& (b)& 1))
block|{
name|fixed
name|x01
init|=
name|midpoint
argument_list|(
name|x0
argument_list|,
name|x1
argument_list|)
decl_stmt|,
name|y01
init|=
name|midpoint
argument_list|(
name|y0
argument_list|,
name|y1
argument_list|)
decl_stmt|;
name|fixed
name|x12
init|=
name|midpoint
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
decl_stmt|,
name|y12
init|=
name|midpoint
argument_list|(
name|y1
argument_list|,
name|y2
argument_list|)
decl_stmt|;
name|fixed
name|x02
init|=
name|midpoint
argument_list|(
name|x01
argument_list|,
name|x12
argument_list|)
decl_stmt|,
name|y02
init|=
name|midpoint
argument_list|(
name|y01
argument_list|,
name|y12
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
comment|/* Update x/y1, x/y2, and x/y0 now for the second half. */
name|x2
operator|=
name|midpoint
argument_list|(
name|x2
argument_list|,
name|x3
argument_list|)
operator|,
name|y2
operator|=
name|midpoint
argument_list|(
name|y2
argument_list|,
name|y3
argument_list|)
expr_stmt|;
name|x1
operator|=
name|midpoint
argument_list|(
name|x12
argument_list|,
name|x2
argument_list|)
operator|,
name|y1
operator|=
name|midpoint
argument_list|(
name|y12
argument_list|,
name|y2
argument_list|)
expr_stmt|;
name|code
operator|=
name|flatten_recur
argument_list|(
name|ppath
argument_list|,
name|x01
argument_list|,
name|y01
argument_list|,
name|x02
argument_list|,
name|y02
argument_list|,
operator|(
name|x0
operator|=
name|midpoint
argument_list|(
name|x02
argument_list|,
name|x1
argument_list|)
operator|)
argument_list|,
operator|(
name|y0
operator|=
name|midpoint
argument_list|(
name|y02
argument_list|,
name|y1
argument_list|)
operator|)
argument_list|,
name|scaled_flat
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
goto|goto
name|top
goto|;
block|}
end_function

begin_comment
comment|/* Flatten a segment of the path by repeated sampling. */
end_comment

begin_comment
comment|/* For some reason, this produces better results, */
end_comment

begin_comment
comment|/* even though flatten_recur is careful to check the flatness.... */
end_comment

begin_comment
comment|/* n is the number of points to sample, including the endpoints; */
end_comment

begin_comment
comment|/* we require n>= 3. */
end_comment

begin_function
name|private
name|int
name|flatten_sample
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|int
name|n
parameter_list|,
name|fixed
name|x1
parameter_list|,
name|fixed
name|y1
parameter_list|,
name|fixed
name|x2
parameter_list|,
name|fixed
name|y2
parameter_list|,
name|fixed
name|x3
parameter_list|,
name|fixed
name|y3
parameter_list|)
block|{
specifier|const
name|fixed
name|x0
init|=
name|ppath
operator|->
name|position
operator|.
name|x
decl_stmt|,
name|y0
init|=
name|ppath
operator|->
name|position
operator|.
name|y
decl_stmt|;
specifier|const
name|fixed
name|cx
init|=
literal|3
operator|*
operator|(
name|x1
operator|-
name|x0
operator|)
decl_stmt|,
name|bx
init|=
literal|3
operator|*
operator|(
name|x2
operator|-
name|x1
operator|)
operator|-
name|cx
decl_stmt|,
name|ax
init|=
name|x3
operator|-
name|bx
operator|-
name|cx
operator|-
name|x0
decl_stmt|;
specifier|const
name|fixed
name|cy
init|=
literal|3
operator|*
operator|(
name|y1
operator|-
name|y0
operator|)
decl_stmt|,
name|by
init|=
literal|3
operator|*
operator|(
name|y2
operator|-
name|y1
operator|)
operator|-
name|cy
decl_stmt|,
name|ay
init|=
name|y3
operator|-
name|by
operator|-
name|cy
operator|-
name|y0
decl_stmt|;
specifier|const
name|float
name|dt
init|=
literal|1.0
operator|/
call|(
name|float
call|)
argument_list|(
name|n
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|float
name|t
init|=
name|dt
operator|*
call|(
name|float
call|)
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|fixed
name|x
init|=
name|x0
operator|+
call|(
name|fixed
call|)
argument_list|(
name|t
operator|*
operator|(
name|cx
operator|+
name|t
operator|*
operator|(
name|bx
operator|+
name|t
operator|*
name|ax
operator|)
operator|)
argument_list|)
decl_stmt|;
specifier|const
name|fixed
name|y
init|=
name|y0
operator|+
call|(
name|fixed
call|)
argument_list|(
name|t
operator|*
operator|(
name|cy
operator|+
name|t
operator|*
operator|(
name|by
operator|+
name|t
operator|*
name|ay
operator|)
operator|)
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|)
condition|)
return|return
name|code
return|;
block|}
return|return
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reverse a path. */
end_comment

begin_comment
comment|/* We know ppath != ppath_old. */
end_comment

begin_function
name|int
name|gx_path_reverse
parameter_list|(
name|gx_path
modifier|*
name|ppath_old
parameter_list|,
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
name|subpath
modifier|*
name|psub
init|=
name|ppath_old
operator|->
name|first_subpath
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'p'
index|]
condition|)
name|gx_dump_path
argument_list|(
name|ppath_old
argument_list|,
literal|"before reversepath"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gx_path_init
argument_list|(
name|ppath
argument_list|,
operator|&
name|ppath_old
operator|->
name|memory_procs
argument_list|)
expr_stmt|;
name|nsp
label|:
while|while
condition|(
name|psub
condition|)
block|{
name|segment
modifier|*
name|pseg
init|=
name|psub
operator|->
name|last
decl_stmt|;
name|segment
modifier|*
name|prev
decl_stmt|;
name|int
name|code
init|=
name|gx_path_add_point
argument_list|(
name|ppath
argument_list|,
name|pseg
operator|->
name|pt
operator|.
name|x
argument_list|,
name|pseg
operator|->
name|pt
operator|.
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
block|{
name|gx_path_release
argument_list|(
name|ppath
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
for|for
control|(
init|;
condition|;
name|pseg
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|pseg
operator|->
name|prev
expr_stmt|;
switch|switch
condition|(
name|pseg
operator|->
name|type
condition|)
block|{
case|case
name|s_start
case|:
comment|/* Finished subpath */
if|if
condition|(
name|psub
operator|->
name|closed
condition|)
name|code
operator|=
name|gx_path_close_subpath
argument_list|(
name|ppath
argument_list|)
expr_stmt|;
name|psub
operator|=
operator|(
name|subpath
operator|*
operator|)
name|psub
operator|->
name|last
operator|->
name|next
expr_stmt|;
goto|goto
name|nsp
goto|;
case|case
name|s_curve
case|:
block|{
name|curve_segment
modifier|*
name|pc
init|=
operator|(
name|curve_segment
operator|*
operator|)
name|pseg
decl_stmt|;
name|code
operator|=
name|gx_path_add_curve
argument_list|(
name|ppath
argument_list|,
name|pc
operator|->
name|p2
operator|.
name|x
argument_list|,
name|pc
operator|->
name|p2
operator|.
name|y
argument_list|,
name|pc
operator|->
name|p1
operator|.
name|x
argument_list|,
name|pc
operator|->
name|p1
operator|.
name|y
argument_list|,
name|prev
operator|->
name|pt
operator|.
name|x
argument_list|,
name|prev
operator|->
name|pt
operator|.
name|y
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|s_line
case|:
case|case
name|s_line_close
case|:
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|prev
operator|->
name|pt
operator|.
name|x
argument_list|,
name|prev
operator|->
name|pt
operator|.
name|y
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|code
condition|)
block|{
name|gx_path_release
argument_list|(
name|ppath
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
block|}
block|}
name|ppath
operator|->
name|position
operator|=
name|ppath_old
operator|->
name|position
expr_stmt|;
comment|/* restore current point */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'p'
index|]
condition|)
name|gx_dump_path
argument_list|(
name|ppath
argument_list|,
literal|"after reversepath"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

