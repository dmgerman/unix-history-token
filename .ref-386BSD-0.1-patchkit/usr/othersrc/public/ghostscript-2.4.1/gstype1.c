begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1990, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gstype1.c */
end_comment

begin_comment
comment|/* Adobe Type 1 font routines for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"math_.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxarith.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzdevice.h"
end_include

begin_comment
comment|/* for gxchar */
end_comment

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_comment
comment|/* ditto */
end_comment

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_include
include|#
directive|include
file|"gxchar.h"
end_include

begin_include
include|#
directive|include
file|"gxfont.h"
end_include

begin_include
include|#
directive|include
file|"gxtype1.h"
end_include

begin_include
include|#
directive|include
file|"gxop1.h"
end_include

begin_comment
comment|/* Define the amount of thickening to be applied to characters. */
end_comment

begin_define
define|#
directive|define
name|type1_fill_adjust
value|0.25
end_define

begin_comment
comment|/* Encrypt a string. */
end_comment

begin_function
name|int
name|gs_type1_encrypt
parameter_list|(
name|byte
modifier|*
name|dest
parameter_list|,
name|byte
modifier|*
name|src
parameter_list|,
name|uint
name|len
parameter_list|,
name|crypt_state
modifier|*
name|pstate
parameter_list|)
block|{
specifier|register
name|crypt_state
name|state
init|=
operator|*
name|pstate
decl_stmt|;
specifier|register
name|byte
modifier|*
name|from
init|=
name|src
decl_stmt|;
specifier|register
name|byte
modifier|*
name|to
init|=
name|dest
decl_stmt|;
specifier|register
name|uint
name|count
init|=
name|len
decl_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|encrypt_next
argument_list|(
operator|*
name|from
argument_list|,
name|state
argument_list|,
operator|*
name|to
argument_list|)
expr_stmt|;
name|from
operator|++
operator|,
name|to
operator|++
operator|,
name|count
operator|--
expr_stmt|;
block|}
operator|*
name|pstate
operator|=
name|state
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Decrypt a string. */
end_comment

begin_function
name|int
name|gs_type1_decrypt
parameter_list|(
name|byte
modifier|*
name|dest
parameter_list|,
name|byte
modifier|*
name|src
parameter_list|,
name|uint
name|len
parameter_list|,
name|crypt_state
modifier|*
name|pstate
parameter_list|)
block|{
specifier|register
name|crypt_state
name|state
init|=
operator|*
name|pstate
decl_stmt|;
specifier|register
name|byte
modifier|*
name|from
init|=
name|src
decl_stmt|;
specifier|register
name|byte
modifier|*
name|to
init|=
name|dest
decl_stmt|;
specifier|register
name|uint
name|count
init|=
name|len
decl_stmt|;
while|while
condition|(
name|count
condition|)
block|{
comment|/* If from == to, we can't use the obvious */
comment|/*	decrypt_next(*from, state, *to);	*/
specifier|register
name|byte
name|ch
init|=
operator|*
name|from
operator|++
decl_stmt|;
name|decrypt_next
argument_list|(
name|ch
argument_list|,
name|state
argument_list|,
operator|*
name|to
argument_list|)
expr_stmt|;
name|to
operator|++
operator|,
name|count
operator|--
expr_stmt|;
block|}
operator|*
name|pstate
operator|=
name|state
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Define the structures for the state of a Type 1 interpreter. */
end_comment

begin_comment
comment|/* This is the interpreter state that must be saved and restored */
end_comment

begin_comment
comment|/* when calling a CharString subroutine. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|byte
modifier|*
name|ip
decl_stmt|;
name|crypt_state
name|dstate
decl_stmt|;
block|}
name|ip_state
typedef|;
end_typedef

begin_comment
comment|/* Define the stem hint tables. */
end_comment

begin_comment
comment|/* Each stem hint table is kept sorted. */
end_comment

begin_define
define|#
directive|define
name|max_stems
value|3
end_define

begin_comment
comment|/* arbitrary */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|fixed
name|v0
decl_stmt|,
name|v1
decl_stmt|;
comment|/* coordinates (widened a little) */
name|gs_fixed_point
name|adjust_lower
decl_stmt|,
name|adjust_upper
decl_stmt|;
comment|/* adjustments */
block|}
name|stem_hint
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|count
decl_stmt|;
name|stem_hint
modifier|*
name|current
decl_stmt|;
comment|/* cache cursor for search */
name|stem_hint
name|data
index|[
name|max_stems
index|]
decl_stmt|;
block|}
name|stem_hint_table
typedef|;
end_typedef

begin_comment
comment|/* This is the full state of the Type 1 interpreter. */
end_comment

begin_define
define|#
directive|define
name|ostack_size
value|24
end_define

begin_comment
comment|/* per documentation */
end_comment

begin_define
define|#
directive|define
name|ipstack_size
value|10
end_define

begin_comment
comment|/* per documentation */
end_comment

begin_struct
struct|struct
name|gs_type1_state_s
block|{
comment|/* The following are set at initialization */
name|gs_show_enum
modifier|*
name|penum
decl_stmt|;
comment|/* show enumerator */
name|gs_state
modifier|*
name|pgs
decl_stmt|;
comment|/* graphics state */
name|gs_type1_data
modifier|*
name|pdata
decl_stmt|;
comment|/* font-specific data */
name|int
name|charpath_flag
decl_stmt|;
comment|/* 0 for show, 1 for false */
comment|/* charpath, 2 for true charpath */
name|int
name|paint_type
decl_stmt|;
comment|/* 0/3 for fill, 1/2 for stroke */
name|fixed_coeff
name|fc
decl_stmt|;
comment|/* cached fixed coefficients */
name|float
name|flatness
decl_stmt|;
comment|/* flatness for character curves */
comment|/* The following are updated dynamically */
name|fixed
name|ostack
index|[
name|ostack_size
index|]
decl_stmt|;
comment|/* the Type 1 operand stack */
name|int
name|os_count
decl_stmt|;
comment|/* # of occupied stack entries */
name|ip_state
name|ipstack
index|[
name|ipstack_size
operator|+
literal|1
index|]
decl_stmt|;
comment|/* control stack */
name|int
name|ips_count
decl_stmt|;
comment|/* # of occupied entries */
name|gs_fixed_point
name|lsb
decl_stmt|;
comment|/* left side bearing */
name|gs_fixed_point
name|width
decl_stmt|;
comment|/* character width */
name|int
name|seac_base
decl_stmt|;
comment|/* base character code for seac, */
comment|/* or -1 */
comment|/* The following are set dynamically, */
comment|/* but not actually used yet. */
name|int
name|in_dotsection
decl_stmt|;
comment|/* true if inside dotsection */
name|stem_hint_table
name|hstem_hints
decl_stmt|;
comment|/* horizontal stem hints */
name|stem_hint_table
name|vstem_hints
decl_stmt|;
comment|/* vertical stem hints */
block|}
struct|;
end_struct

begin_comment
comment|/* Export the size of the structure */
end_comment

begin_decl_stmt
specifier|const
name|uint
name|gs_type1_state_sizeof
init|=
sizeof|sizeof
argument_list|(
name|gs_type1_state
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Imported procedures */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|gx_matrix_to_fixed_coeff
argument_list|(
name|P3
argument_list|(
name|gs_matrix
operator|*
argument_list|,
name|fixed_coeff
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize a Type 1 interpreter. */
end_comment

begin_comment
comment|/* The caller must supply a string to the first call of gs_type1_interpret. */
end_comment

begin_function
name|int
name|gs_type1_init
parameter_list|(
specifier|register
name|gs_type1_state
modifier|*
name|pis
parameter_list|,
name|gs_show_enum
modifier|*
name|penum
parameter_list|,
name|int
name|charpath_flag
parameter_list|,
name|int
name|paint_type
parameter_list|,
name|gs_type1_data
modifier|*
name|pdata
parameter_list|)
block|{
name|gs_state
modifier|*
name|pgs
init|=
name|penum
operator|->
name|pgs
decl_stmt|;
name|pis
operator|->
name|penum
operator|=
name|penum
expr_stmt|;
name|pis
operator|->
name|pgs
operator|=
name|pgs
expr_stmt|;
name|pis
operator|->
name|pdata
operator|=
name|pdata
expr_stmt|;
name|pis
operator|->
name|charpath_flag
operator|=
name|charpath_flag
expr_stmt|;
name|pis
operator|->
name|paint_type
operator|=
name|paint_type
expr_stmt|;
name|pis
operator|->
name|os_count
operator|=
literal|0
expr_stmt|;
name|pis
operator|->
name|ips_count
operator|=
literal|1
expr_stmt|;
name|pis
operator|->
name|seac_base
operator|=
operator|-
literal|1
expr_stmt|;
name|pis
operator|->
name|in_dotsection
operator|=
literal|0
expr_stmt|;
name|pis
operator|->
name|hstem_hints
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|pis
operator|->
name|hstem_hints
operator|.
name|current
operator|=
operator|&
name|pis
operator|->
name|hstem_hints
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
name|pis
operator|->
name|vstem_hints
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|pis
operator|->
name|vstem_hints
operator|.
name|current
operator|=
operator|&
name|pis
operator|->
name|vstem_hints
operator|.
name|data
index|[
literal|0
index|]
expr_stmt|;
name|gx_matrix_to_fixed_coeff
argument_list|(
operator|&
name|ctm_only
argument_list|(
name|pgs
argument_list|)
argument_list|,
operator|&
name|pis
operator|->
name|fc
argument_list|,
name|max_coeff_bits
argument_list|)
expr_stmt|;
comment|/* Set the current point of the path to the origin, */
comment|/* in anticipation of the initial [h]sbw. */
block|{
name|gx_path
modifier|*
name|ppath
init|=
name|pgs
operator|->
name|path
decl_stmt|;
name|ppath
operator|->
name|position
operator|.
name|x
operator|=
name|pgs
operator|->
name|ctm
operator|.
name|tx_fixed
expr_stmt|;
name|ppath
operator|->
name|position
operator|.
name|y
operator|=
name|pgs
operator|->
name|ctm
operator|.
name|ty_fixed
expr_stmt|;
block|}
comment|/* Set the flatness to a value that is likely to produce */
comment|/* reasonably good-looking curves, regardless of its */
comment|/* current value in the graphics state. */
if|if
condition|(
operator|(
name|pis
operator|->
name|flatness
operator|=
name|pgs
operator|->
name|flatness
operator|)
operator|>
literal|1.0
condition|)
block|{
comment|/* With the conventional 1000-unit characters, */
comment|/* a small "o" will be about 250 units, */
comment|/* so set the flatness to 10 units. */
name|float
name|cxx
init|=
name|pgs
operator|->
name|ctm
operator|.
name|xx
decl_stmt|,
name|cyy
init|=
name|pgs
operator|->
name|ctm
operator|.
name|yy
decl_stmt|;
if|if
condition|(
name|cxx
operator|<
literal|0
condition|)
name|cxx
operator|=
operator|-
name|cxx
expr_stmt|;
if|if
condition|(
name|cyy
operator|<
literal|0
condition|)
name|cyy
operator|=
operator|-
name|cyy
expr_stmt|;
if|if
condition|(
name|cyy
operator|>
name|cxx
condition|)
name|cxx
operator|=
name|cyy
expr_stmt|;
if|if
condition|(
name|is_skewed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|)
condition|)
block|{
name|float
name|cxy
init|=
name|pgs
operator|->
name|ctm
operator|.
name|xy
decl_stmt|,
name|cyx
init|=
name|pgs
operator|->
name|ctm
operator|.
name|yx
decl_stmt|;
if|if
condition|(
name|cxy
operator|<
literal|0
condition|)
name|cxy
operator|=
operator|-
name|cxy
expr_stmt|;
if|if
condition|(
name|cyx
operator|<
literal|0
condition|)
name|cyx
operator|=
operator|-
name|cyx
expr_stmt|;
if|if
condition|(
name|cxy
operator|>
name|cxx
condition|)
name|cxx
operator|=
name|cxy
expr_stmt|;
if|if
condition|(
name|cyx
operator|>
name|cxx
condition|)
name|cxx
operator|=
name|cyx
expr_stmt|;
block|}
name|pis
operator|->
name|flatness
operator|=
operator|(
name|cxx
operator|>
literal|0.1
condition|?
name|cxx
operator|*
literal|10
else|:
literal|1.0
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Tracing for type 1 interpreter */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|dc
parameter_list|(
name|str
parameter_list|)
value|if ( gs_debug['1'] ) type1_trace(cip, c, str);
end_define

begin_function
name|private
name|void
name|near
name|type1_trace
parameter_list|(
name|byte
modifier|*
name|cip
parameter_list|,
name|byte
name|c
parameter_list|,
name|char
name|_ds
modifier|*
name|str
parameter_list|)
block|{
name|dprintf3
argument_list|(
literal|"[1]%lx: %02x %s\n"
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|cip
operator|-
literal|1
argument_list|)
argument_list|,
name|c
argument_list|,
operator|(
name|char
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dc
parameter_list|(
name|str
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the state used by operator procedures. */
end_comment

begin_comment
comment|/* These macros refer to a current instance (s) of gs_op1_state. */
end_comment

begin_define
define|#
directive|define
name|sppath
value|s.ppath
end_define

begin_define
define|#
directive|define
name|sfc
value|s.fc
end_define

begin_define
define|#
directive|define
name|ptx
value|s.px
end_define

begin_define
define|#
directive|define
name|pty
value|s.py
end_define

begin_define
define|#
directive|define
name|sctx
value|s.ctx
end_define

begin_define
define|#
directive|define
name|scty
value|s.cty
end_define

begin_comment
comment|/* Accumulate relative coordinates */
end_comment

begin_comment
comment|/****** THESE ARE NOT ACCURATE FOR NON-INTEGER DELTAS. ******/
end_comment

begin_comment
comment|/* This probably doesn't make any difference in practice. */
end_comment

begin_define
define|#
directive|define
name|c_fixed
parameter_list|(
name|d
parameter_list|,
name|c
parameter_list|)
value|m_fixed(arg2int(d), c, sfc)
end_define

begin_define
define|#
directive|define
name|accum_x
parameter_list|(
name|dx
parameter_list|)
define|\
value|ptx += c_fixed(dx, sfc.xx);\     if ( sfc.skewed ) pty += c_fixed(dx, sfc.xy)
end_define

begin_define
define|#
directive|define
name|accum_y
parameter_list|(
name|dy
parameter_list|)
define|\
value|pty += c_fixed(dy, sfc.yy);\     if ( sfc.skewed ) ptx += c_fixed(dy, sfc.yx)
end_define

begin_define
define|#
directive|define
name|accum_xy
parameter_list|(
name|dx
parameter_list|,
name|dy
parameter_list|)
define|\
value|accum_xy_proc(&s, dx, dy)
end_define

begin_define
define|#
directive|define
name|s
value|(*ps)
end_define

begin_define
define|#
directive|define
name|arg2int
parameter_list|(
name|f
parameter_list|)
value|fixed2int_var(f)
end_define

begin_function
name|private
name|void
name|near
name|accum_xy_proc
parameter_list|(
specifier|register
name|is_ptr
name|ps
parameter_list|,
name|fixed
name|dx
parameter_list|,
name|fixed
name|dy
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|idy
decl_stmt|;
name|ptx
operator|+=
name|m_fixed
argument_list|(
operator|(
name|idx
operator|=
name|arg2int
argument_list|(
name|dx
argument_list|)
operator|)
argument_list|,
name|sfc
operator|.
name|xx
argument_list|,
name|sfc
argument_list|)
operator|,
name|pty
operator|+=
name|m_fixed
argument_list|(
operator|(
name|idy
operator|=
name|arg2int
argument_list|(
name|dy
argument_list|)
operator|)
argument_list|,
name|sfc
operator|.
name|yy
argument_list|,
name|sfc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfc
operator|.
name|skewed
condition|)
name|ptx
operator|+=
name|m_fixed
argument_list|(
name|idy
argument_list|,
name|sfc
operator|.
name|yx
argument_list|,
name|sfc
argument_list|)
operator|,
name|pty
operator|+=
name|m_fixed
argument_list|(
name|idx
argument_list|,
name|sfc
operator|.
name|xy
argument_list|,
name|sfc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We round all endpoints of lines or curves */
end_comment

begin_comment
comment|/* to the center of the nearest quarter-pixel, and suppress null lines. */
end_comment

begin_comment
comment|/* (Rounding to the half-pixel causes too many dropouts.) */
end_comment

begin_comment
comment|/* This saves a lot of rendering work for small characters. */
end_comment

begin_define
define|#
directive|define
name|pixel_rounded
parameter_list|(
name|fx
parameter_list|)
define|\
value|(((fx) | float2fixed(0.125))& float2fixed(-0.125))
end_define

begin_define
define|#
directive|define
name|must_draw_to
parameter_list|(
name|lpx
parameter_list|,
name|lpy
parameter_list|,
name|px
parameter_list|,
name|py
parameter_list|)
define|\
value|((lpx = pixel_rounded(px)), (lpy = pixel_rounded(py)),\    (psub = sppath->current_subpath) == 0 ||\    (pseg = psub->last)->type == s_line_close ||\    lpx != pseg->pt.x || lpy != pseg->pt.y)
end_define

begin_comment
comment|/* ------ Operator procedures ------ */
end_comment

begin_comment
comment|/* We put these before the interpreter to save having to write */
end_comment

begin_comment
comment|/* prototypes for all of them. */
end_comment

begin_function
name|int
name|gs_op1_closepath
parameter_list|(
specifier|register
name|is_ptr
name|ps
parameter_list|)
block|{
comment|/* Note that this does NOT reset the current point! */
name|int
name|code
init|=
name|gx_path_close_subpath
argument_list|(
name|sppath
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
name|gx_path_add_point
argument_list|(
name|sppath
argument_list|,
name|ptx
argument_list|,
name|pty
argument_list|)
return|;
comment|/* put the point where it was */
block|}
end_function

begin_function
name|int
name|gs_op1_sbw
parameter_list|(
specifier|register
name|is_ptr
name|ps
parameter_list|,
name|fixed
name|sbx
parameter_list|,
name|fixed
name|sby
parameter_list|,
name|fixed
name|wx
parameter_list|,
name|fixed
name|wy
parameter_list|)
block|{
specifier|register
name|gs_type1_state
modifier|*
name|pis
init|=
name|ps
operator|->
name|pis
decl_stmt|;
name|gs_show_enum
modifier|*
name|penum
init|=
name|pis
operator|->
name|penum
decl_stmt|;
if|if
condition|(
name|penum
operator|->
name|sb_set
condition|)
name|pis
operator|->
name|lsb
operator|=
name|penum
operator|->
name|metrics_sb
expr_stmt|;
else|else
name|pis
operator|->
name|lsb
operator|.
name|x
operator|=
name|sbx
operator|,
name|pis
operator|->
name|lsb
operator|.
name|y
operator|=
name|sby
expr_stmt|;
if|if
condition|(
name|penum
operator|->
name|width_set
condition|)
name|pis
operator|->
name|width
operator|=
name|penum
operator|->
name|metrics_width
expr_stmt|;
else|else
name|pis
operator|->
name|width
operator|.
name|x
operator|=
name|wx
operator|,
name|pis
operator|->
name|width
operator|.
name|y
operator|=
name|wy
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'1'
index|]
condition|)
name|dprintf4
argument_list|(
literal|"[1]sb=(%g,%g) w=(%g,%g)\n"
argument_list|,
name|fixed2float
argument_list|(
name|pis
operator|->
name|lsb
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pis
operator|->
name|lsb
operator|.
name|y
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pis
operator|->
name|width
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pis
operator|->
name|width
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|accum_xy
argument_list|(
name|pis
operator|->
name|lsb
operator|.
name|x
argument_list|,
name|pis
operator|->
name|lsb
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|gs_op1_hsbw
parameter_list|(
specifier|register
name|is_ptr
name|ps
parameter_list|,
name|fixed
name|sbx
parameter_list|,
name|fixed
name|wx
parameter_list|)
block|{
return|return
name|gs_op1_sbw
argument_list|(
name|ps
argument_list|,
name|sbx
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|,
name|wx
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|gs_op1_rrcurveto
parameter_list|(
specifier|register
name|is_ptr
name|ps
parameter_list|,
name|fixed
name|dx1
parameter_list|,
name|fixed
name|dy1
parameter_list|,
name|fixed
name|dx2
parameter_list|,
name|fixed
name|dy2
parameter_list|,
name|fixed
name|dx3
parameter_list|,
name|fixed
name|dy3
parameter_list|)
block|{
name|fixed
name|ptx1
decl_stmt|,
name|pty1
decl_stmt|,
name|ptx2
decl_stmt|,
name|pty2
decl_stmt|;
comment|/* Following declarations are only for must_draw_to */
name|fixed
name|lpx
decl_stmt|,
name|lpy
decl_stmt|;
name|subpath
modifier|*
name|psub
decl_stmt|;
name|segment
modifier|*
name|pseg
decl_stmt|;
name|accum_xy
argument_list|(
name|dx1
argument_list|,
name|dy1
argument_list|)
expr_stmt|;
name|ptx1
operator|=
name|ptx
operator|,
name|pty1
operator|=
name|pty
expr_stmt|;
name|accum_xy
argument_list|(
name|dx2
argument_list|,
name|dy2
argument_list|)
expr_stmt|;
name|ptx2
operator|=
name|ptx
operator|,
name|pty2
operator|=
name|pty
expr_stmt|;
name|accum_xy
argument_list|(
name|dx3
argument_list|,
name|dy3
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_draw_to
argument_list|(
name|lpx
argument_list|,
name|lpy
argument_list|,
name|ptx
argument_list|,
name|pty
argument_list|)
condition|)
return|return
name|gx_path_add_flattened_curve
argument_list|(
name|sppath
argument_list|,
name|ptx1
argument_list|,
name|pty1
argument_list|,
name|ptx2
argument_list|,
name|pty2
argument_list|,
name|lpx
argument_list|,
name|lpy
argument_list|,
name|ps
operator|->
name|pis
operator|->
name|flatness
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|s
end_undef

begin_comment
comment|/* ------ Main interpreter ------ */
end_comment

begin_comment
comment|/* Continue interpreting a Type 1 CharString. */
end_comment

begin_comment
comment|/* If str != 0, it is taken as the byte string to interpret. */
end_comment

begin_comment
comment|/* Return 0 on successful completion,<0 on error, */
end_comment

begin_comment
comment|/* or>0 when client intervention is required. */
end_comment

begin_comment
comment|/* The int * argument is where the character is stored for seac, */
end_comment

begin_comment
comment|/* or the othersubr # for callothersubr. */
end_comment

begin_decl_stmt
name|private
name|void
name|near
name|type1_hstem
argument_list|(
name|P3
argument_list|(
name|gs_type1_state
operator|*
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|near
name|type1_vstem
argument_list|(
name|P3
argument_list|(
name|gs_type1_state
operator|*
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|stem_hint
modifier|*
name|near
name|type1_stem
argument_list|(
name|P3
argument_list|(
name|stem_hint_table
operator|*
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|near
name|type1_endchar
argument_list|(
name|P3
argument_list|(
name|gs_type1_state
operator|*
argument_list|,
name|gs_state
operator|*
argument_list|,
name|gx_path
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|gs_type1_interpret
parameter_list|(
specifier|register
name|gs_type1_state
modifier|*
name|pis
parameter_list|,
name|byte
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|pindex
parameter_list|)
block|{
name|gs_state
modifier|*
name|pgs
init|=
name|pis
operator|->
name|pgs
decl_stmt|;
name|gs_type1_data
modifier|*
name|pdata
init|=
name|pis
operator|->
name|pdata
decl_stmt|;
name|gs_op1_state
name|s
decl_stmt|;
name|fixed
name|cstack
index|[
name|ostack_size
index|]
decl_stmt|;
define|#
directive|define
name|cs0
value|cstack[0]
define|#
directive|define
name|ics0
value|fixed2int_var(cs0)
define|#
directive|define
name|cs1
value|cstack[1]
define|#
directive|define
name|ics1
value|fixed2int_var(cs1)
define|#
directive|define
name|cs2
value|cstack[2]
define|#
directive|define
name|ics2
value|fixed2int_var(cs2)
define|#
directive|define
name|cs3
value|cstack[3]
define|#
directive|define
name|ics3
value|fixed2int_var(cs3)
define|#
directive|define
name|cs4
value|cstack[4]
define|#
directive|define
name|ics4
value|fixed2int_var(cs4)
define|#
directive|define
name|cs5
value|cstack[5]
define|#
directive|define
name|ics5
value|fixed2int_var(cs5)
specifier|register
name|fixed
name|_ss
modifier|*
name|csp
decl_stmt|;
define|#
directive|define
name|clear
value|csp = cstack - 1
name|ip_state
modifier|*
name|ipsp
init|=
operator|&
name|pis
operator|->
name|ipstack
index|[
name|pis
operator|->
name|ips_count
operator|-
literal|1
index|]
decl_stmt|;
specifier|register
name|byte
modifier|*
name|cip
decl_stmt|;
specifier|register
name|crypt_state
name|state
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
name|fixed
name|ftx
init|=
name|pgs
operator|->
name|ctm
operator|.
name|tx_fixed
decl_stmt|,
name|fty
init|=
name|pgs
operator|->
name|ctm
operator|.
name|ty_fixed
decl_stmt|;
name|fixed
name|lpx
decl_stmt|,
name|lpy
decl_stmt|;
name|subpath
modifier|*
name|psub
decl_stmt|;
name|segment
modifier|*
name|pseg
decl_stmt|;
name|sppath
operator|=
name|pgs
operator|->
name|path
expr_stmt|;
name|s
operator|.
name|pis
operator|=
name|pis
expr_stmt|;
name|sfc
operator|=
name|pis
operator|->
name|fc
expr_stmt|;
name|ptx
operator|=
name|sppath
operator|->
name|position
operator|.
name|x
expr_stmt|;
name|pty
operator|=
name|sppath
operator|->
name|position
operator|.
name|y
expr_stmt|;
comment|/* Copy the operand stack out of the saved state. */
if|if
condition|(
name|pis
operator|->
name|os_count
operator|==
literal|0
condition|)
block|{
name|clear
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|cstack
argument_list|,
name|pis
operator|->
name|ostack
argument_list|,
name|pis
operator|->
name|os_count
operator|*
sizeof|sizeof
argument_list|(
name|fixed
argument_list|)
argument_list|)
expr_stmt|;
name|csp
operator|=
operator|&
name|cstack
index|[
name|pis
operator|->
name|os_count
operator|-
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|str
operator|==
literal|0
condition|)
goto|goto
name|cont
goto|;
name|cip
operator|=
name|str
expr_stmt|;
name|call
label|:
name|state
operator|=
name|crypt_charstring_seed
expr_stmt|;
block|{
name|int
name|skip
init|=
name|pdata
operator|->
name|lenIV
decl_stmt|;
comment|/* Skip initial random bytes */
for|for
control|(
init|;
name|skip
operator|>
literal|0
condition|;
operator|--
name|skip
control|)
block|{
name|decrypt_skip_next
argument_list|(
operator|*
name|cip
argument_list|,
name|state
argument_list|)
expr_stmt|;
operator|++
name|cip
expr_stmt|;
block|}
block|}
goto|goto
name|top
goto|;
name|cont
label|:
name|cip
operator|=
name|ipsp
operator|->
name|ip
expr_stmt|;
name|state
operator|=
name|ipsp
operator|->
name|dstate
expr_stmt|;
name|top
label|:
while|while
condition|(
literal|1
condition|)
block|{
name|uint
name|c0
decl_stmt|;
name|c
operator|=
name|decrypt_this
argument_list|(
operator|(
name|c0
operator|=
operator|*
name|cip
operator|++
operator|)
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|decrypt_skip_next
argument_list|(
name|c0
argument_list|,
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|char_command
operator|)
name|c
condition|)
block|{
define|#
directive|define
name|cnext
value|clear; break
case|case
name|c_hstem
case|:
name|dc
argument_list|(
literal|"hstem"
argument_list|)
name|type1_hstem
argument_list|(
name|pis
argument_list|,
name|cs0
argument_list|,
name|cs1
argument_list|)
expr_stmt|;
name|cnext
expr_stmt|;
case|case
name|c_vstem
case|:
name|dc
argument_list|(
literal|"vstem"
argument_list|)
name|type1_vstem
argument_list|(
name|pis
argument_list|,
name|cs0
argument_list|,
name|cs1
argument_list|)
expr_stmt|;
name|cnext
expr_stmt|;
case|case
name|c_vmoveto
case|:
name|dc
argument_list|(
literal|"vmoveto"
argument_list|)
name|accum_y
argument_list|(
name|cs0
argument_list|)
expr_stmt|;
name|move
label|:
comment|/* Round to the nearest center of a quarter-pixel. */
if|if
condition|(
name|must_draw_to
argument_list|(
name|lpx
argument_list|,
name|lpy
argument_list|,
name|ptx
argument_list|,
name|pty
argument_list|)
condition|)
name|code
operator|=
name|gx_path_add_point
argument_list|(
name|sppath
argument_list|,
name|lpx
argument_list|,
name|lpy
argument_list|)
expr_stmt|;
goto|goto
name|cc
goto|;
case|case
name|c_rlineto
case|:
name|dc
argument_list|(
literal|"rlineto"
argument_list|)
name|accum_xy
argument_list|(
name|cs0
argument_list|,
name|cs1
argument_list|)
expr_stmt|;
name|line
label|:
comment|/* Round to the nearest center of a quarter-pixel. */
if|if
condition|(
name|must_draw_to
argument_list|(
name|lpx
argument_list|,
name|lpy
argument_list|,
name|ptx
argument_list|,
name|pty
argument_list|)
condition|)
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|sppath
argument_list|,
name|lpx
argument_list|,
name|lpy
argument_list|)
expr_stmt|;
name|cc
label|:
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pp
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'1'
index|]
condition|)
name|dprintf2
argument_list|(
literal|"[1]pt=(%g,%g)\n"
argument_list|,
name|fixed2float
argument_list|(
name|ptx
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pty
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cnext
expr_stmt|;
case|case
name|c_hlineto
case|:
name|dc
argument_list|(
literal|"hlineto"
argument_list|)
name|accum_x
argument_list|(
name|cs0
argument_list|)
expr_stmt|;
goto|goto
name|line
goto|;
case|case
name|c_vlineto
case|:
name|dc
argument_list|(
literal|"vlineto"
argument_list|)
name|accum_y
argument_list|(
name|cs0
argument_list|)
expr_stmt|;
goto|goto
name|line
goto|;
case|case
name|c_rrcurveto
case|:
name|dc
argument_list|(
literal|"rrcurveto"
argument_list|)
name|code
operator|=
name|gs_op1_rrcurveto
argument_list|(
operator|&
name|s
argument_list|,
name|cs0
argument_list|,
name|cs1
argument_list|,
name|cs2
argument_list|,
name|cs3
argument_list|,
name|cs4
argument_list|,
name|cs5
argument_list|)
expr_stmt|;
goto|goto
name|cc
goto|;
case|case
name|c_closepath
case|:
name|dc
argument_list|(
literal|"closepath"
argument_list|)
name|code
operator|=
name|gs_op1_closepath
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
goto|goto
name|cc
goto|;
case|case
name|c_callsubr
case|:
name|dc
argument_list|(
literal|"callsubr"
argument_list|)
block|{
name|int
name|index
init|=
name|fixed2int_var
argument_list|(
operator|*
name|csp
argument_list|)
decl_stmt|;
name|byte
modifier|*
name|nip
decl_stmt|;
name|code
operator|=
call|(
modifier|*
name|pdata
operator|->
name|subr_proc
call|)
argument_list|(
name|pdata
argument_list|,
name|index
argument_list|,
operator|&
name|nip
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
name|return_error
argument_list|(
name|code
argument_list|)
expr_stmt|;
operator|--
name|csp
expr_stmt|;
name|ipsp
operator|->
name|ip
operator|=
name|cip
operator|,
name|ipsp
operator|->
name|dstate
operator|=
name|state
expr_stmt|;
operator|++
name|ipsp
expr_stmt|;
name|cip
operator|=
name|nip
expr_stmt|;
block|}
goto|goto
name|call
goto|;
case|case
name|c_return
case|:
name|dc
argument_list|(
literal|"return"
argument_list|)
operator|--
name|ipsp
expr_stmt|;
goto|goto
name|cont
goto|;
case|case
name|c_escape
case|:
name|dc
argument_list|(
literal|"escape:"
argument_list|)
name|decrypt_next
argument_list|(
operator|*
name|cip
argument_list|,
name|state
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|cip
expr_stmt|;
switch|switch
condition|(
operator|(
name|char_extended_command
operator|)
name|c
condition|)
block|{
case|case
name|ce_dotsection
case|:
name|dc
argument_list|(
literal|"  dotsection"
argument_list|)
name|pis
operator|->
name|in_dotsection
operator|=
operator|!
name|pis
operator|->
name|in_dotsection
expr_stmt|;
name|cnext
expr_stmt|;
case|case
name|ce_vstem3
case|:
name|dc
argument_list|(
literal|"  vstem3"
argument_list|)
name|type1_vstem
argument_list|(
name|pis
argument_list|,
name|cs0
argument_list|,
name|cs1
argument_list|)
expr_stmt|;
name|type1_vstem
argument_list|(
name|pis
argument_list|,
name|cs2
argument_list|,
name|cs3
argument_list|)
expr_stmt|;
name|type1_vstem
argument_list|(
name|pis
argument_list|,
name|cs4
argument_list|,
name|cs5
argument_list|)
expr_stmt|;
name|cnext
expr_stmt|;
case|case
name|ce_hstem3
case|:
name|dc
argument_list|(
literal|"  hstem3"
argument_list|)
name|type1_hstem
argument_list|(
name|pis
argument_list|,
name|cs0
argument_list|,
name|cs1
argument_list|)
expr_stmt|;
name|type1_hstem
argument_list|(
name|pis
argument_list|,
name|cs2
argument_list|,
name|cs3
argument_list|)
expr_stmt|;
name|type1_hstem
argument_list|(
name|pis
argument_list|,
name|cs4
argument_list|,
name|cs5
argument_list|)
expr_stmt|;
name|cnext
expr_stmt|;
case|case
name|ce_seac
case|:
name|dc
argument_list|(
literal|"  seac"
argument_list|)
comment|/* Do the accent now.  When it finishes */
comment|/* (detected in endchar), do the base character. */
name|pis
operator|->
name|seac_base
operator|=
name|ics3
expr_stmt|;
comment|/* Adjust the origin of the coordinate system */
comment|/* for the accent (endchar puts it back). */
name|ptx
operator|=
name|ftx
operator|,
name|pty
operator|=
name|fty
expr_stmt|;
name|cs1
operator|-=
name|cs0
expr_stmt|;
comment|/* subtract off asb */
name|accum_xy
argument_list|(
name|cs1
argument_list|,
name|cs2
argument_list|)
expr_stmt|;
name|sppath
operator|->
name|position
operator|.
name|x
operator|=
name|ptx
expr_stmt|;
name|sppath
operator|->
name|position
operator|.
name|y
operator|=
name|pty
expr_stmt|;
name|pis
operator|->
name|os_count
operator|=
literal|0
expr_stmt|;
comment|/* clear */
comment|/* Give control back to the caller, who must */
comment|/* re-invoke the interpreter with the seac string. */
operator|*
name|pindex
operator|=
name|ics4
expr_stmt|;
return|return
name|type1_result_seac
return|;
case|case
name|ce_sbw
case|:
name|dc
argument_list|(
literal|"  sbw"
argument_list|)
name|code
operator|=
name|gs_op1_sbw
argument_list|(
operator|&
name|s
argument_list|,
name|cs0
argument_list|,
name|cs1
argument_list|,
name|cs2
argument_list|,
name|cs3
argument_list|)
expr_stmt|;
goto|goto
name|cc
goto|;
case|case
name|ce_div
case|:
name|dc
argument_list|(
literal|"  div"
argument_list|)
name|csp
index|[
operator|-
literal|1
index|]
operator|=
name|float2fixed
argument_list|(
operator|(
name|float
operator|)
name|csp
index|[
operator|-
literal|1
index|]
operator|/
operator|(
name|float
operator|)
operator|*
name|csp
argument_list|)
expr_stmt|;
operator|--
name|csp
expr_stmt|;
goto|goto
name|pushed
goto|;
case|case
name|ce_undoc15
case|:
name|dc
argument_list|(
literal|"  undoc15"
argument_list|)
comment|/* 			 * NOTE: this opcode is not documented by Adobe, 			 * but is used in some Adobe fonts.  I have no idea 			 * what it is supposed to do. 			 */
name|cnext
expr_stmt|;
case|case
name|ce_callothersubr
case|:
name|dc
argument_list|(
literal|"  callothersubr"
argument_list|)
block|{
name|int
name|scount
init|=
name|csp
operator|-
name|cstack
decl_stmt|;
operator|*
name|pindex
operator|=
name|fixed2int_var
argument_list|(
operator|*
name|csp
argument_list|)
expr_stmt|;
comment|/* Update path position so it will be right */
comment|/* when we come back in. */
name|sppath
operator|->
name|position
operator|.
name|x
operator|=
name|ptx
expr_stmt|;
name|sppath
operator|->
name|position
operator|.
name|y
operator|=
name|pty
expr_stmt|;
comment|/* Exit to caller */
name|ipsp
operator|->
name|ip
operator|=
name|cip
operator|,
name|ipsp
operator|->
name|dstate
operator|=
name|state
expr_stmt|;
name|pis
operator|->
name|os_count
operator|=
name|scount
expr_stmt|;
name|pis
operator|->
name|ips_count
operator|=
name|ipsp
operator|-
operator|&
name|pis
operator|->
name|ipstack
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|scount
condition|)
name|memcpy
argument_list|(
name|pis
operator|->
name|ostack
argument_list|,
name|cstack
argument_list|,
name|scount
operator|*
sizeof|sizeof
argument_list|(
name|fixed
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type1_result_callothersubr
return|;
block|}
case|case
name|ce_pop
case|:
name|dc
argument_list|(
literal|"  pop"
argument_list|)
operator|++
name|csp
expr_stmt|;
name|code
operator|=
call|(
modifier|*
name|pdata
operator|->
name|pop_proc
call|)
argument_list|(
name|pdata
argument_list|,
name|csp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
name|return_error
argument_list|(
name|code
argument_list|)
expr_stmt|;
goto|goto
name|pushed
goto|;
case|case
name|ce_setcurrentpoint
case|:
name|dc
argument_list|(
literal|"  setcurrentpoint"
argument_list|)
name|ptx
operator|=
name|ftx
operator|,
name|pty
operator|=
name|fty
expr_stmt|;
name|accum_xy
argument_list|(
name|cs0
argument_list|,
name|cs1
argument_list|)
expr_stmt|;
goto|goto
name|pp
goto|;
default|default:
name|return_error
argument_list|(
name|gs_error_invalidfont
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|c_hsbw
case|:
name|dc
argument_list|(
literal|"hsbw"
argument_list|)
name|code
operator|=
name|gs_op1_hsbw
argument_list|(
operator|&
name|s
argument_list|,
name|cs0
argument_list|,
name|cs1
argument_list|)
expr_stmt|;
goto|goto
name|cc
goto|;
case|case
name|c_endchar
case|:
name|dc
argument_list|(
literal|"endchar"
argument_list|)
if|if
condition|(
name|pis
operator|->
name|seac_base
operator|>=
literal|0
condition|)
block|{
comment|/* We just finished the accent of a seac. */
comment|/* Do the base character. */
operator|*
name|pindex
operator|=
name|pis
operator|->
name|seac_base
expr_stmt|;
name|pis
operator|->
name|seac_base
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Restore the coordinate system origin */
name|sppath
operator|->
name|position
operator|.
name|x
operator|=
name|ftx
expr_stmt|;
name|sppath
operator|->
name|position
operator|.
name|y
operator|=
name|fty
expr_stmt|;
name|pis
operator|->
name|os_count
operator|=
literal|0
expr_stmt|;
comment|/* clear */
comment|/* Clear the ipstack, in case the accent ended */
comment|/* inside a subroutine. */
name|pis
operator|->
name|ips_count
operator|=
literal|1
expr_stmt|;
comment|/* Give control back to the caller, who must */
comment|/* re-invoke the interpreter with the */
comment|/* base character string. */
return|return
name|type1_result_seac
return|;
block|}
comment|/* This is a real endchar.  Handle it below. */
return|return
name|type1_endchar
argument_list|(
name|pis
argument_list|,
name|pgs
argument_list|,
name|sppath
argument_list|)
return|;
case|case
name|c_undoc15
case|:
name|dc
argument_list|(
literal|"  undoc15"
argument_list|)
comment|/* 		 * NOTE: this opcode is not documented by Adobe, 		 * but is used in some Adobe fonts.  I have no idea 		 * what it is supposed to do. 		 */
name|cnext
expr_stmt|;
case|case
name|c_rmoveto
case|:
name|dc
argument_list|(
literal|"rmoveto"
argument_list|)
name|accum_xy
argument_list|(
name|cs0
argument_list|,
name|cs1
argument_list|)
expr_stmt|;
goto|goto
name|move
goto|;
case|case
name|c_hmoveto
case|:
name|dc
argument_list|(
literal|"hmoveto"
argument_list|)
name|accum_x
argument_list|(
name|cs0
argument_list|)
expr_stmt|;
goto|goto
name|move
goto|;
case|case
name|c_vhcurveto
case|:
name|dc
argument_list|(
literal|"vhcurveto"
argument_list|)
name|code
operator|=
name|gs_op1_rrcurveto
argument_list|(
operator|&
name|s
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|,
name|cs0
argument_list|,
name|cs1
argument_list|,
name|cs2
argument_list|,
name|cs3
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|cc
goto|;
case|case
name|c_hvcurveto
case|:
name|dc
argument_list|(
literal|"hvcurveto"
argument_list|)
name|code
operator|=
name|gs_op1_rrcurveto
argument_list|(
operator|&
name|s
argument_list|,
name|cs0
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|,
name|cs1
argument_list|,
name|cs2
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|,
name|cs3
argument_list|)
expr_stmt|;
goto|goto
name|cc
goto|;
comment|/* Fill up the dispatch up to 32. */
case|case
name|c_undef0
case|:
case|case
name|c_undef2
case|:
case|case
name|c_undef16
case|:
case|case
name|c_undef17
case|:
case|case
name|c_undef18
case|:
case|case
name|c_undef19
case|:
case|case
name|c_undef20
case|:
case|case
name|c_undef23
case|:
case|case
name|c_undef24
case|:
case|case
name|c_undef25
case|:
case|case
name|c_undef26
case|:
case|case
name|c_undef27
case|:
case|case
name|c_undef28
case|:
case|case
name|c_undef29
case|:
name|return_error
argument_list|(
name|gs_error_invalidfont
argument_list|)
expr_stmt|;
comment|/* Fill up the dispatch for 1-byte numbers. */
define|#
directive|define
name|icase
parameter_list|(
name|n
parameter_list|)
value|case n:
define|#
directive|define
name|ncase
parameter_list|(
name|n
parameter_list|)
value|case n: *++csp = int2fixed(c_value_num1(n)); goto pushed;
define|#
directive|define
name|icase10
parameter_list|(
name|n
parameter_list|)
define|\
value|icase(n) icase(n+1) icase(n+2) icase(n+3) icase(n+4)\   icase(n+5) icase(n+6) icase(n+7) icase(n+8) icase(n+9)
define|#
directive|define
name|ncase10
parameter_list|(
name|n
parameter_list|)
define|\
value|ncase(n) ncase(n+1) ncase(n+2) ncase(n+3) ncase(n+4)\   ncase(n+5) ncase(n+6) ncase(n+7) ncase(n+8) ncase(n+9)
name|icase
argument_list|(
literal|32
argument_list|)
name|icase
argument_list|(
literal|33
argument_list|)
name|icase
argument_list|(
literal|34
argument_list|)
name|icase
argument_list|(
literal|35
argument_list|)
name|icase
argument_list|(
literal|36
argument_list|)
name|icase
argument_list|(
literal|37
argument_list|)
name|icase
argument_list|(
literal|38
argument_list|)
name|icase
argument_list|(
literal|39
argument_list|)
name|icase10
argument_list|(
literal|40
argument_list|)
name|icase10
argument_list|(
literal|50
argument_list|)
name|icase10
argument_list|(
literal|60
argument_list|)
name|icase10
argument_list|(
literal|70
argument_list|)
name|icase10
argument_list|(
literal|80
argument_list|)
name|icase10
argument_list|(
literal|90
argument_list|)
name|icase10
argument_list|(
literal|100
argument_list|)
name|icase10
argument_list|(
literal|110
argument_list|)
goto|goto
name|pi
goto|;
name|ncase10
argument_list|(
literal|120
argument_list|)
name|ncase10
argument_list|(
literal|130
argument_list|)
name|ncase10
argument_list|(
literal|140
argument_list|)
name|ncase10
argument_list|(
literal|150
argument_list|)
name|icase10
argument_list|(
literal|160
argument_list|)
name|icase10
argument_list|(
literal|170
argument_list|)
name|icase10
argument_list|(
literal|180
argument_list|)
name|icase10
argument_list|(
literal|190
argument_list|)
name|icase10
argument_list|(
literal|200
argument_list|)
name|icase10
argument_list|(
literal|210
argument_list|)
name|icase10
argument_list|(
literal|220
argument_list|)
name|icase10
argument_list|(
literal|230
argument_list|)
name|icase
argument_list|(
literal|240
argument_list|)
name|icase
argument_list|(
literal|241
argument_list|)
name|icase
argument_list|(
literal|242
argument_list|)
name|icase
argument_list|(
literal|243
argument_list|)
name|icase
argument_list|(
literal|244
argument_list|)
name|icase
argument_list|(
literal|245
argument_list|)
name|icase
argument_list|(
literal|246
argument_list|)
name|pi
label|:
operator|*
operator|++
name|csp
operator|=
name|int2fixed
argument_list|(
name|c_value_num1
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|pushed
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'1'
index|]
condition|)
name|dprintf3
argument_list|(
literal|"[1]%d: (%d) %f\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|csp
operator|-
name|cstack
argument_list|)
argument_list|,
name|c
argument_list|,
name|fixed2float
argument_list|(
operator|*
name|csp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* Handle 2-byte positive numbers. */
define|#
directive|define
name|case_num2
parameter_list|(
name|n
parameter_list|)
define|\
value|case c_num2+n: *++csp = int2fixed(c_value_num2(c_num2+n, 0))
name|case_num2
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|pos2
goto|;
name|case_num2
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|pos2
goto|;
name|case_num2
argument_list|(
literal|2
argument_list|)
expr_stmt|;
goto|goto
name|pos2
goto|;
name|case_num2
argument_list|(
literal|3
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|case_num2
name|pos2
label|:
block|{
name|c0
operator|=
operator|*
name|cip
operator|++
expr_stmt|;
operator|*
name|csp
operator|+=
name|int2fixed
argument_list|(
name|decrypt_this
argument_list|(
name|c0
argument_list|,
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|decrypt_skip_next
argument_list|(
name|c0
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
goto|goto
name|pushed
goto|;
comment|/* Handle 2-byte negative numbers. */
define|#
directive|define
name|case_num3
parameter_list|(
name|n
parameter_list|)
define|\
value|case c_num3+n: *++csp = int2fixed(c_value_num3(c_num3+n, 0))
name|case_num3
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|neg2
goto|;
name|case_num3
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|neg2
goto|;
name|case_num3
argument_list|(
literal|2
argument_list|)
expr_stmt|;
goto|goto
name|neg2
goto|;
name|case_num3
argument_list|(
literal|3
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|case_num3
name|neg2
label|:
block|{
name|c0
operator|=
operator|*
name|cip
operator|++
expr_stmt|;
operator|*
name|csp
operator|-=
name|int2fixed
argument_list|(
name|decrypt_this
argument_list|(
name|c0
argument_list|,
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|decrypt_skip_next
argument_list|(
name|c0
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
goto|goto
name|pushed
goto|;
comment|/* Handle 5-byte numbers. */
case|case
name|c_num4
case|:
block|{
name|uint
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|long
name|lw
decl_stmt|;
name|decrypt_next
argument_list|(
operator|*
name|cip
argument_list|,
name|state
argument_list|,
name|c0
argument_list|)
expr_stmt|;
name|decrypt_next
argument_list|(
name|cip
index|[
literal|1
index|]
argument_list|,
name|state
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|decrypt_next
argument_list|(
name|cip
index|[
literal|2
index|]
argument_list|,
name|state
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|decrypt_next
argument_list|(
name|cip
index|[
literal|3
index|]
argument_list|,
name|state
argument_list|,
name|lw
argument_list|)
expr_stmt|;
name|cip
operator|+=
literal|4
expr_stmt|;
name|lw
operator|+=
operator|(
name|ulong
operator|)
name|c0
operator|<<
literal|24
expr_stmt|;
name|lw
operator|+=
operator|(
name|ulong
operator|)
name|c1
operator|<<
literal|16
expr_stmt|;
name|lw
operator|+=
name|c2
operator|<<
literal|8
expr_stmt|;
operator|*
operator|++
name|csp
operator|=
name|int2fixed
argument_list|(
name|lw
argument_list|)
expr_stmt|;
if|if
condition|(
name|lw
operator|!=
name|fixed2long
argument_list|(
operator|*
name|csp
argument_list|)
condition|)
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
block|}
goto|goto
name|pushed
goto|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add a horizontal stem hint. */
end_comment

begin_function
name|private
name|void
name|near
name|type1_hstem
parameter_list|(
name|gs_type1_state
modifier|*
name|pis
parameter_list|,
name|fixed
name|y
parameter_list|,
name|fixed
name|dy
parameter_list|)
block|{
name|stem_hint
modifier|*
name|psh
decl_stmt|;
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
name|y
operator|+=
name|dy
operator|,
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
name|psh
operator|=
name|type1_stem
argument_list|(
operator|&
name|pis
operator|->
name|hstem_hints
argument_list|,
name|y
argument_list|,
name|dy
argument_list|)
expr_stmt|;
if|if
condition|(
name|psh
operator|==
literal|0
condition|)
return|return;
comment|/* Compute adjustments here */
block|}
end_function

begin_comment
comment|/* Add a vertical stem hint. */
end_comment

begin_function
name|private
name|void
name|near
name|type1_vstem
parameter_list|(
name|gs_type1_state
modifier|*
name|pis
parameter_list|,
name|fixed
name|x
parameter_list|,
name|fixed
name|dx
parameter_list|)
block|{
name|stem_hint
modifier|*
name|psh
decl_stmt|;
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
name|x
operator|+=
name|dx
operator|,
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|psh
operator|=
name|type1_stem
argument_list|(
operator|&
name|pis
operator|->
name|vstem_hints
argument_list|,
name|x
argument_list|,
name|dx
argument_list|)
expr_stmt|;
if|if
condition|(
name|psh
operator|==
literal|0
condition|)
return|return;
comment|/* Compute adjustments here */
block|}
end_function

begin_comment
comment|/* Add a stem hint, keeping the table sorted. */
end_comment

begin_comment
comment|/* Return the stem hint pointer, or 0 if the table is full. */
end_comment

begin_function
name|private
name|stem_hint
modifier|*
name|near
name|type1_stem
parameter_list|(
name|stem_hint_table
modifier|*
name|psht
parameter_list|,
name|fixed
name|v0
parameter_list|,
name|fixed
name|d
parameter_list|)
block|{
name|stem_hint
modifier|*
name|bot
init|=
operator|&
name|psht
operator|->
name|data
index|[
literal|0
index|]
decl_stmt|;
name|stem_hint
modifier|*
name|top
init|=
name|bot
operator|+
name|psht
operator|->
name|count
decl_stmt|;
if|if
condition|(
name|psht
operator|->
name|count
operator|>=
name|max_stems
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|top
operator|>
name|bot
operator|&&
name|v0
operator|<
name|top
index|[
operator|-
literal|1
index|]
operator|.
name|v0
condition|)
block|{
operator|*
name|top
operator|=
name|top
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|top
operator|--
expr_stmt|;
block|}
name|top
operator|->
name|v0
operator|=
name|v0
operator|,
name|top
operator|->
name|v1
operator|=
name|v0
operator|+
name|d
expr_stmt|;
name|psht
operator|->
name|count
operator|++
expr_stmt|;
return|return
name|top
return|;
block|}
end_function

begin_comment
comment|/* Handle the end of a character.  We break this out into a separate */
end_comment

begin_comment
comment|/* procedure so as not to overwhelm the optimizing compilers. */
end_comment

begin_function
name|private
name|int
name|near
name|type1_endchar
parameter_list|(
name|gs_type1_state
modifier|*
name|pis
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
name|int
name|use_stroke
init|=
name|pis
operator|->
name|paint_type
operator|==
literal|1
operator|||
name|pis
operator|->
name|paint_type
operator|==
literal|2
decl_stmt|;
name|fixed
name|ftx
init|=
name|pgs
operator|->
name|ctm
operator|.
name|tx_fixed
decl_stmt|,
name|fty
init|=
name|pgs
operator|->
name|ctm
operator|.
name|ty_fixed
decl_stmt|;
name|int
name|code
decl_stmt|;
comment|/* Set the current point to the character origin: */
comment|/* the 'show' loop will take care of adding in */
comment|/* the width we supply to setcharwidth/cachedevice. */
name|gx_path_add_point
argument_list|(
name|ppath
argument_list|,
name|ftx
argument_list|,
name|fty
argument_list|)
expr_stmt|;
if|if
condition|(
name|pis
operator|->
name|charpath_flag
condition|)
block|{
name|code
operator|=
name|gs_setcharwidth
argument_list|(
name|pis
operator|->
name|penum
argument_list|,
name|pgs
argument_list|,
name|fixed2float
argument_list|(
name|pis
operator|->
name|width
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pis
operator|->
name|width
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* Merge the path into its parent */
return|return
name|gx_path_add_path
argument_list|(
name|pgs
operator|->
name|saved
operator|->
name|path
argument_list|,
name|ppath
argument_list|)
return|;
block|}
block|{
name|gs_rect
name|bbox
decl_stmt|;
name|code
operator|=
name|gs_pathbbox
argument_list|(
name|pgs
argument_list|,
operator|&
name|bbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
comment|/* must be a null path */
block|{
name|bbox
operator|.
name|p
operator|.
name|x
operator|=
name|bbox
operator|.
name|p
operator|.
name|y
operator|=
name|bbox
operator|.
name|q
operator|.
name|x
operator|=
name|bbox
operator|.
name|q
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'1'
index|]
condition|)
name|dprintf4
argument_list|(
literal|"[1]bbox=(%g,%g),(%g,%g)\n"
argument_list|,
name|bbox
operator|.
name|p
operator|.
name|x
argument_list|,
name|bbox
operator|.
name|p
operator|.
name|y
argument_list|,
name|bbox
operator|.
name|q
operator|.
name|x
argument_list|,
name|bbox
operator|.
name|q
operator|.
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
comment|/* Expand the bounding box to encompass */
comment|/* the width of the stroke (if stroking). */
comment|/* setcachedevice also adds 1 or 2 pixels, */
comment|/* so we don't have to worry about rounding. */
if|if
condition|(
name|use_stroke
condition|)
block|{
name|float
name|adjust
init|=
name|gs_currentlinewidth
argument_list|(
name|pgs
argument_list|)
decl_stmt|;
if|if
condition|(
name|adjust
operator|<
literal|1
condition|)
name|adjust
operator|=
literal|1
expr_stmt|;
comment|/****** SHOULD SCALE ******/
name|bbox
operator|.
name|p
operator|.
name|x
operator|-=
name|adjust
expr_stmt|;
name|bbox
operator|.
name|p
operator|.
name|y
operator|-=
name|adjust
expr_stmt|;
name|bbox
operator|.
name|q
operator|.
name|x
operator|+=
name|adjust
expr_stmt|;
name|bbox
operator|.
name|q
operator|.
name|y
operator|+=
name|adjust
expr_stmt|;
block|}
block|}
name|code
operator|=
name|gs_setcachedevice
argument_list|(
name|pis
operator|->
name|penum
argument_list|,
name|pgs
argument_list|,
name|fixed2float
argument_list|(
name|pis
operator|->
name|width
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pis
operator|->
name|width
operator|.
name|y
argument_list|)
argument_list|,
name|bbox
operator|.
name|p
operator|.
name|x
argument_list|,
name|bbox
operator|.
name|p
operator|.
name|y
argument_list|,
name|bbox
operator|.
name|q
operator|.
name|x
argument_list|,
name|bbox
operator|.
name|q
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
comment|/* We've already constructed the path: */
comment|/* translate it so it matches the cache device. */
name|gx_path_translate
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
name|pgs
operator|->
name|ctm
operator|.
name|tx_fixed
operator|-
name|ftx
argument_list|,
name|pgs
operator|->
name|ctm
operator|.
name|ty_fixed
operator|-
name|fty
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/****** 	 ****** The adjust parameter is a hack to make 	 ****** characters come out more bold, since we 	 ****** don't look at the hints. 	 ******/
name|gx_color_load
argument_list|(
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
return|return
operator|(
name|use_stroke
condition|?
name|gs_stroke
argument_list|(
name|pgs
argument_list|)
else|:
name|gs_fill_adjust
argument_list|(
name|pgs
argument_list|,
name|float2fixed
argument_list|(
name|type1_fill_adjust
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pop a (fixed) number off the internal stack. */
end_comment

begin_comment
comment|/* The client uses this to get the arguments for an OtherSubr. */
end_comment

begin_function
name|int
name|gs_type1_pop
parameter_list|(
name|gs_type1_state
modifier|*
name|pis
parameter_list|,
name|fixed
modifier|*
name|pf
parameter_list|)
block|{
operator|*
name|pf
operator|=
name|pis
operator|->
name|ostack
index|[
operator|--
operator|(
name|pis
operator|->
name|os_count
operator|)
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

