begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* interp.c */
end_comment

begin_comment
comment|/* Ghostscript language interpreter */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"estack.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"dstack.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"packed.h"
end_include

begin_include
include|#
directive|include
file|"save.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* Imported operator procedures */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|obj_le
argument_list|(
name|P2
argument_list|(
name|os_ptr
argument_list|,
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zop_add
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zop_def
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zop_sub
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The procedure to call if an operator requests rescheduling. */
end_comment

begin_comment
comment|/* This causes an error unless the context machinery has been installed. */
end_comment

begin_function
name|private
name|int
name|no_reschedule
parameter_list|()
block|{
return|return
name|e_invalidcontext
return|;
block|}
end_function

begin_expr_stmt
name|int
argument_list|(
operator|*
name|gs_interp_reschedule_proc
argument_list|)
argument_list|(
name|P0
argument_list|()
argument_list|)
operator|=
name|no_reschedule
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The procedure to call for time-slicing. */
end_comment

begin_comment
comment|/* This is a no-op unless the context machinery has been installed. */
end_comment

begin_function
name|private
name|int
name|no_time_slice
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|int
argument_list|(
operator|*
name|gs_interp_time_slice_proc
argument_list|)
argument_list|(
name|P0
argument_list|()
argument_list|)
operator|=
name|no_time_slice
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|interp
argument_list|(
name|P1
argument_list|(
name|ref
operator|*
name|pref
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|interp_exit
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|i_interp_exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|copy_stack
argument_list|(
name|P3
argument_list|(
name|ref
operator|*
argument_list|,
name|uint
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Configuration parameters */
end_comment

begin_define
define|#
directive|define
name|max_ostack
value|800
end_define

begin_define
define|#
directive|define
name|max_estack
value|150
end_define

begin_define
define|#
directive|define
name|max_dstack
value|20
end_define

begin_define
define|#
directive|define
name|num_clear_dstack
value|2
end_define

begin_comment
comment|/* See estack.h for a description of the execution stack. */
end_comment

begin_comment
comment|/* The logic for managing icount and iref below assumes that */
end_comment

begin_comment
comment|/* there are no control operators which pop and then push */
end_comment

begin_comment
comment|/* information on the execution stack. */
end_comment

begin_comment
comment|/* Stacks */
end_comment

begin_define
define|#
directive|define
name|os_guard_under
value|10
end_define

begin_define
define|#
directive|define
name|os_guard_over
value|10
end_define

begin_decl_stmt
name|private
name|ref
name|ostack
index|[
name|os_guard_under
operator|+
name|max_ostack
operator|+
name|os_guard_over
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ref
name|estack
index|[
name|max_estack
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ref
name|dstack
index|[
name|max_dstack
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|os_ptr
name|osp_nargs
index|[
name|os_max_nargs
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for checking osp */
end_comment

begin_comment
comment|/* Stack pointers */
end_comment

begin_decl_stmt
name|os_ptr
name|osbot
decl_stmt|,
name|osp
decl_stmt|,
name|ostop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|es_ptr
name|esbot
decl_stmt|,
name|esp
decl_stmt|,
name|estop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|es_ptr
name|esfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cache pointer to currentfile */
end_comment

begin_decl_stmt
name|ds_ptr
name|dsp
decl_stmt|,
name|dstop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The object that caused an error */
end_comment

begin_decl_stmt
name|ref
name|error_object
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Object related to error handling */
end_comment

begin_decl_stmt
specifier|extern
name|ref
name|name_errordict
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ref
name|name_ErrorNames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extended types.  The interpreter may replace the type of operators */
end_comment

begin_comment
comment|/* in procedures with these, to speed up the interpretation loop. */
end_comment

begin_define
define|#
directive|define
name|tx_op
value|t_next_index
end_define

begin_decl_stmt
specifier|extern
name|int
name|zadd
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zdef
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zdup
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zexch
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zif
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zifelse
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zle
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zpop
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zroll
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zsub
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|op_proc_p
name|special_ops
index|[]
init|=
block|{
name|zadd
block|,
name|zdef
block|,
name|zdup
block|,
name|zexch
block|,
name|zif
block|,
name|zifelse
block|,
name|zle
block|,
name|zpop
block|,
name|zroll
block|,
name|zsub
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|tx_op_add
init|=
name|tx_op
block|,
name|tx_op_def
block|,
name|tx_op_dup
block|,
name|tx_op_exch
block|,
name|tx_op_if
block|,
name|tx_op_ifelse
block|,
name|tx_op_le
block|,
name|tx_op_pop
block|,
name|tx_op_roll
block|,
name|tx_op_sub
block|,
name|tx_next_op
block|}
name|special_op_types
typedef|;
end_typedef

begin_define
define|#
directive|define
name|num_special_ops
value|((int)tx_next_op - tx_op)
end_define

begin_define
define|#
directive|define
name|t_invalid
value|tx_next_op
end_define

begin_comment
comment|/* first invalid type */
end_comment

begin_comment
comment|/* The following is a special "error" code that is used internally */
end_comment

begin_comment
comment|/* to cause the interpreter to exit. */
end_comment

begin_define
define|#
directive|define
name|e_InterpreterExit
value|(-100)
end_define

begin_comment
comment|/* Initialize the interpreter */
end_comment

begin_function
name|void
name|interp_init
parameter_list|(
name|int
name|ndict
parameter_list|)
block|{
comment|/* Initialize the guard entries on the operand stack */
comment|/* with objects that have invalid type and attributes. */
name|osbot
operator|=
name|ostack
operator|+
name|os_guard_under
expr_stmt|;
name|osp
operator|=
name|osbot
operator|-
literal|1
operator|,
name|ostop
operator|=
name|osbot
operator|+
operator|(
name|max_ostack
operator|-
literal|1
operator|)
expr_stmt|;
block|{
specifier|register
name|os_ptr
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|ostack
init|;
name|op
operator|<
name|osbot
condition|;
name|op
operator|++
control|)
name|make_tav
argument_list|(
name|op
argument_list|,
name|t_invalid
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|os_max_nargs
condition|;
name|i
operator|++
control|)
name|op_nargs_check
argument_list|(
name|i
argument_list|)
operator|=
name|osbot
operator|+
name|i
operator|-
literal|1
expr_stmt|;
block|}
name|esbot
operator|=
name|estack
operator|,
name|esp
operator|=
name|estack
operator|-
literal|1
operator|,
name|estop
operator|=
name|estack
operator|+
operator|(
name|max_estack
operator|-
literal|1
operator|)
expr_stmt|;
name|esfile
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the dictionary stack to the first ndict */
comment|/* dictionaries.  ndict is a parameter because during */
comment|/* initialization, only systemdict exists. */
name|dsp
operator|=
name|dstack
operator|+
name|ndict
operator|-
literal|1
operator|,
name|dstop
operator|=
name|dstack
operator|+
operator|(
name|max_dstack
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up an operator during initialization, */
end_comment

begin_comment
comment|/* changing its type if appropriate. */
end_comment

begin_function
name|void
name|interp_fix_op
parameter_list|(
name|ref
modifier|*
name|opref
parameter_list|)
block|{
specifier|register
name|int
name|i
init|=
name|num_special_ops
decl_stmt|;
name|op_proc_p
name|proc
init|=
name|real_opproc
argument_list|(
name|opref
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
operator|&&
name|proc
operator|!=
name|special_ops
index|[
name|i
index|]
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|make_tav
argument_list|(
name|opref
argument_list|,
name|tx_op
operator|+
name|i
argument_list|,
name|a_executable
argument_list|,
name|opproc
argument_list|,
operator|(
name|dummy_op_proc_p
operator|)
name|proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invoke the interpreter.  If execution completes normally, return 0. */
end_comment

begin_comment
comment|/* if an error occurs, then if user_errors is true and the error is a */
end_comment

begin_comment
comment|/* recoverable one (not an overflow condition), let the user handle it; */
end_comment

begin_comment
comment|/* otherwise, return the error code. */
end_comment

begin_function
name|int
name|gs_interpret
parameter_list|(
name|ref
modifier|*
name|pref
parameter_list|,
name|int
name|user_errors
parameter_list|)
block|{
name|ref
modifier|*
name|epref
init|=
name|pref
decl_stmt|;
name|ref
name|erref
decl_stmt|;
name|ref
modifier|*
name|perrordict
decl_stmt|,
modifier|*
name|pErrorNames
decl_stmt|;
name|int
name|code
decl_stmt|,
name|ccode
decl_stmt|;
name|ref
name|saref
decl_stmt|;
comment|/* Push a special exit procedure on the execution stack */
name|es_ptr
name|esp0
init|=
operator|++
name|esp
decl_stmt|;
name|make_oper
argument_list|(
name|esp0
argument_list|,
name|i_interp_exit
argument_list|,
operator|(
name|dummy_op_proc_p
operator|)
name|interp_exit
argument_list|)
expr_stmt|;
name|retry
label|:
name|code
operator|=
name|interp
argument_list|(
name|epref
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|e_InterpreterExit
condition|)
return|return
literal|0
return|;
comment|/* Adjust osp in case of operand stack underflow */
if|if
condition|(
name|osp
operator|<
name|osbot
operator|-
literal|1
condition|)
name|osp
operator|=
name|osbot
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|user_errors
condition|)
return|return
name|code
return|;
if|if
condition|(
name|dict_find
argument_list|(
operator|&
name|systemdict
argument_list|,
operator|&
name|name_errordict
argument_list|,
operator|&
name|perrordict
argument_list|)
operator|<=
literal|0
operator|||
name|dict_find
argument_list|(
operator|&
name|systemdict
argument_list|,
operator|&
name|name_ErrorNames
argument_list|,
operator|&
name|pErrorNames
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|code
return|;
comment|/* errordict or ErrorNames not found?? */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|e_dictstackoverflow
case|:
if|if
condition|(
name|osp
operator|+
literal|1
operator|>=
name|ostop
condition|)
return|return
name|e_stackoverflow
return|;
name|ccode
operator|=
name|copy_stack
argument_list|(
name|dstack
argument_list|,
name|dsp
operator|-
name|dstack
operator|+
literal|1
argument_list|,
operator|&
name|saref
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccode
operator|<
literal|0
condition|)
return|return
name|ccode
return|;
name|dsp
operator|=
operator|&
name|dstack
index|[
name|num_clear_dstack
operator|-
literal|1
index|]
expr_stmt|;
operator|*
operator|++
name|osp
operator|=
name|saref
expr_stmt|;
break|break;
case|case
name|e_execstackoverflow
case|:
if|if
condition|(
name|osp
operator|+
literal|1
operator|>=
name|ostop
condition|)
return|return
name|e_stackoverflow
return|;
name|ccode
operator|=
name|copy_stack
argument_list|(
name|estack
argument_list|,
name|esp
operator|-
name|estack
operator|+
literal|1
argument_list|,
operator|&
name|saref
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccode
operator|<
literal|0
condition|)
return|return
name|ccode
return|;
name|esp
operator|=
name|esp0
expr_stmt|;
operator|*
operator|++
name|osp
operator|=
name|saref
expr_stmt|;
break|break;
case|case
name|e_stackoverflow
case|:
name|ccode
operator|=
name|copy_stack
argument_list|(
name|ostack
argument_list|,
name|osp
operator|-
name|osbot
operator|+
literal|1
argument_list|,
operator|&
name|saref
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccode
operator|<
literal|0
condition|)
return|return
name|ccode
return|;
name|osp
operator|=
name|osbot
expr_stmt|;
operator|*
name|osbot
operator|=
name|saref
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|-
name|code
operator|>
name|r_size
argument_list|(
name|pErrorNames
argument_list|)
condition|)
return|return
name|code
return|;
comment|/* unknown error??? */
if|if
condition|(
name|dict_find
argument_list|(
name|perrordict
argument_list|,
operator|&
name|pErrorNames
operator|->
name|value
operator|.
name|refs
index|[
operator|-
name|code
operator|-
literal|1
index|]
argument_list|,
operator|&
name|epref
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|code
return|;
comment|/* error name not in errordict??? */
name|erref
operator|=
operator|*
name|epref
expr_stmt|;
name|epref
operator|=
operator|&
name|erref
expr_stmt|;
comment|/* Push the error object on the operand stack */
operator|*
operator|++
name|osp
operator|=
name|error_object
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
end_function

begin_function
name|private
name|int
name|interp_exit
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|e_InterpreterExit
return|;
block|}
end_function

begin_comment
comment|/* Copy the contents of an overflowed stack into an array. */
end_comment

begin_function
name|private
name|int
name|copy_stack
parameter_list|(
name|ref
modifier|*
name|stk
parameter_list|,
name|uint
name|size
parameter_list|,
name|ref
modifier|*
name|arr
parameter_list|)
block|{
name|ref
modifier|*
name|abody
init|=
name|alloc_refs
argument_list|(
name|size
argument_list|,
literal|"overflowed stack"
argument_list|)
decl_stmt|;
if|if
condition|(
name|abody
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|refcpy_to_new
argument_list|(
name|abody
argument_list|,
name|stk
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|make_tasv
argument_list|(
name|arr
argument_list|,
name|t_array
argument_list|,
name|a_all
argument_list|,
name|size
argument_list|,
name|refs
argument_list|,
name|abody
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Main interpreter. */
end_comment

begin_comment
comment|/* If execution terminates normally, return e_InterpreterExit. */
end_comment

begin_comment
comment|/* If an error occurs, leave the current object in error_object */
end_comment

begin_comment
comment|/* and return a (negative) error code. */
end_comment

begin_define
define|#
directive|define
name|return_with_error
parameter_list|(
name|code
parameter_list|,
name|objp
parameter_list|)
define|\
value|{ esp = iesp; osp = iosp; error_object = *(objp); return_error(code); }
end_define

begin_function
name|private
name|int
name|interp
parameter_list|(
name|ref
modifier|*
name|pref
comment|/* object to interpret */
parameter_list|)
block|{
specifier|register
name|ref
modifier|*
name|iref
init|=
name|pref
decl_stmt|;
specifier|register
name|int
name|icount
init|=
literal|0
decl_stmt|;
comment|/* # of consecutive tokens at iref */
specifier|register
name|os_ptr
name|iosp
init|=
name|osp
decl_stmt|;
comment|/* private copy of osp */
specifier|register
name|es_ptr
name|iesp
init|=
name|esp
decl_stmt|;
comment|/* private copy of esp */
name|int
name|code
decl_stmt|;
name|ref
name|token
decl_stmt|;
comment|/* token read from file or string, */
comment|/* must be declared in this scope */
specifier|register
name|ref
modifier|*
name|pvalue
decl_stmt|;
name|os_ptr
name|whichp
decl_stmt|;
name|esfile
operator|=
literal|0
expr_stmt|;
comment|/* clear cache */
comment|/* We want to recognize executable arrays here, */
comment|/* so we push the argument on the estack and enter */
comment|/* the loop at the bottom. */
if|if
condition|(
name|iesp
operator|>=
name|estop
condition|)
name|return_with_error
argument_list|(
name|e_execstackoverflow
argument_list|,
name|pref
argument_list|)
expr_stmt|;
operator|*
operator|++
name|iesp
operator|=
operator|*
name|pref
expr_stmt|;
goto|goto
name|bot
goto|;
comment|/* At this point, if icount> 0, iref and icount correspond */
comment|/* to the top entry on the execution stack: icount is the */
comment|/* count of sequential entries remaining AFTER the current one. */
define|#
directive|define
name|add1_short
parameter_list|(
name|pref
parameter_list|)
value|(ref *)((ushort *)(pref) + 1)
define|#
directive|define
name|store_state
parameter_list|(
name|ep
parameter_list|)
define|\
value|( icount> 0 ? (ep->value.refs = iref + 1, r_set_size(ep, icount)) : 0 )
define|#
directive|define
name|store_state_short
parameter_list|(
name|ep
parameter_list|)
define|\
value|( icount> 0 ? (ep->value.refs = add1_short(iref), r_set_size(ep, icount)) : 0 )
define|#
directive|define
name|next
parameter_list|()
define|\
value|if ( --icount> 0 ) { iref++; goto top; } else goto out
define|#
directive|define
name|next_short
parameter_list|()
define|\
value|if ( --icount<= 0 ) { if ( icount< 0 ) goto up; iesp--; }\   iref = add1_short(iref); goto top;
name|top
label|:
comment|/* 	 * This is the top of the interpreter loop. 	 * iref points to the ref being interpreted. 	 * Note that this might be an element of a packed array, 	 * not a real ref: we carefully arranged the first 16 bits of 	 * a ref and of a packed array element so they could be distinguished 	 * from each other.  (See ghost.h and packed.h for more detail.) 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'I'
index|]
operator|||
name|gs_debug
index|[
literal|'i'
index|]
operator|&&
operator|(
operator|*
operator|(
name|ushort
operator|*
operator|)
name|iref
operator|<=
name|packed_max_full_ref
condition|?
name|r_type
argument_list|(
name|iref
argument_list|)
operator|==
name|t_name
else|:
operator|*
operator|(
name|short
operator|*
operator|)
name|iref
operator|<
literal|0
operator|)
condition|)
block|{
name|void
name|debug_print_ref
argument_list|(
name|P1
argument_list|(
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|edepth
init|=
name|iesp
operator|-
name|esbot
decl_stmt|;
name|char
name|depth
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|depth
argument_list|,
literal|"%2d"
argument_list|,
name|edepth
argument_list|)
expr_stmt|;
name|dputs
argument_list|(
name|depth
argument_list|)
expr_stmt|;
name|edepth
operator|-=
name|strlen
argument_list|(
name|depth
argument_list|)
expr_stmt|;
do|do
block|{
name|dputc
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|edepth
operator|>
literal|0
condition|)
do|;
comment|/* indent */
name|dprintf3
argument_list|(
literal|"%lx(%2d)<%2d>: "
argument_list|,
operator|(
name|ulong
operator|)
name|iref
argument_list|,
name|icount
argument_list|,
call|(
name|uint
call|)
argument_list|(
name|iosp
operator|-
name|osbot
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|debug_print_ref
argument_list|(
name|iref
argument_list|)
expr_stmt|;
if|if
condition|(
name|iosp
operator|>=
name|osbot
condition|)
block|{
name|dputs
argument_list|(
literal|" // "
argument_list|)
expr_stmt|;
name|debug_print_ref
argument_list|(
name|iosp
argument_list|)
expr_stmt|;
block|}
name|dputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|dstderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Object that have attributes (arrays, dictionaries, files, and strings) */
comment|/* use lit and exec; other objects use plain and plain_exec. */
define|#
directive|define
name|lit
parameter_list|(
name|t
parameter_list|)
value|type_xe_value(t, a_execute)
define|#
directive|define
name|exec
parameter_list|(
name|t
parameter_list|)
value|type_xe_value(t, a_execute + a_executable)
define|#
directive|define
name|nox
parameter_list|(
name|t
parameter_list|)
value|type_xe_value(t, 0)
define|#
directive|define
name|nox_exec
parameter_list|(
name|t
parameter_list|)
value|type_xe_value(t, a_executable)
define|#
directive|define
name|plain
parameter_list|(
name|t
parameter_list|)
value|type_xe_value(t, 0)
define|#
directive|define
name|plain_exec
parameter_list|(
name|t
parameter_list|)
value|type_xe_value(t, a_executable)
comment|/* 	 * We have to populate enough cases of the switch statement to force 	 * some compilers to use a dispatch rather than a testing loop. 	 * What a nuisance! 	 */
switch|switch
condition|(
name|r_type_xe
argument_list|(
name|iref
argument_list|)
condition|)
block|{
comment|/* Access errors. */
define|#
directive|define
name|cases_nox
parameter_list|()
define|\
value|case nox_exec(t_array): case nox_exec(t_dictionary):\   case nox_exec(t_file): case nox_exec(t_string):\   case nox_exec(t_mixedarray): case nox_exec(t_shortarray)
name|cases_nox
argument_list|()
operator|:
name|return_with_error
argument_list|(
name|e_invalidaccess
argument_list|,
name|iref
argument_list|)
expr_stmt|;
comment|/* 	 * Literal objects.  We have to enumerate all the types. 	 * In fact, we have to include some extra plain_exec entries 	 * just to populate the switch.  We break them up into groups 	 * to avoid overflowing some preprocessors. 	 */
define|#
directive|define
name|cases_lit_1
parameter_list|()
define|\
value|case lit(t_array): case nox(t_array):\   case plain(t_boolean): case plain_exec(t_boolean):\   case plain(t_condition): case plain_exec(t_condition):\   case lit(t_dictionary): case nox(t_dictionary)
define|#
directive|define
name|cases_lit_2
parameter_list|()
define|\
value|case lit(t_file): case nox(t_file):\   case plain(t_fontID): case plain_exec(t_fontID):\   case plain(t_gstate): case plain_exec(t_gstate):\   case plain(t_integer): case plain_exec(t_integer)
define|#
directive|define
name|cases_lit_3
parameter_list|()
define|\
value|case plain(t_lock): case plain_exec(t_lock):\   case plain(t_mark): case plain_exec(t_mark):\   case plain(t_name):\   case plain(t_null):\   case plain(t_oparray):\   case plain(t_operator)
define|#
directive|define
name|cases_lit_4
parameter_list|()
define|\
value|case plain(t_real): case plain_exec(t_real):\   case plain(t_save): case plain_exec(t_save):\   case lit(t_string): case nox(t_string)
define|#
directive|define
name|cases_lit_5
parameter_list|()
define|\
value|case lit(t_mixedarray): case nox(t_mixedarray):\   case lit(t_shortarray): case nox(t_shortarray):\   case plain(t_color): case plain_exec(t_color):\   case plain(t_device): case plain_exec(t_device)
name|cases_lit_1
argument_list|()
operator|:
name|cases_lit_2
argument_list|()
operator|:
name|cases_lit_3
argument_list|()
operator|:
name|cases_lit_4
argument_list|()
operator|:
name|cases_lit_5
argument_list|()
operator|:
break|break;
comment|/* Special operators. */
case|case
name|plain_exec
argument_list|(
name|tx_op_add
argument_list|)
case|:
name|x_add
label|:
if|if
condition|(
operator|(
name|code
operator|=
name|zop_add
argument_list|(
name|iosp
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|return_with_error
argument_list|(
name|code
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|iosp
operator|--
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
case|case
name|plain_exec
argument_list|(
name|tx_op_def
argument_list|)
case|:
name|x_def
label|:
if|if
condition|(
operator|(
name|code
operator|=
name|zop_def
argument_list|(
name|iosp
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|return_with_error
argument_list|(
name|code
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|iosp
operator|-=
literal|2
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
case|case
name|plain_exec
argument_list|(
name|tx_op_dup
argument_list|)
case|:
name|x_dup
label|:
if|if
condition|(
name|iosp
operator|<
name|op_nargs_check
argument_list|(
literal|1
argument_list|)
condition|)
name|return_with_error
argument_list|(
name|e_stackunderflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|iosp
operator|++
expr_stmt|;
name|ref_assign
argument_list|(
name|iosp
argument_list|,
name|iosp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
case|case
name|plain_exec
argument_list|(
name|tx_op_exch
argument_list|)
case|:
name|x_exch
label|:
if|if
condition|(
name|iosp
operator|<
name|op_nargs_check
argument_list|(
literal|2
argument_list|)
condition|)
name|return_with_error
argument_list|(
name|e_stackunderflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|ref_assign
argument_list|(
operator|&
name|token
argument_list|,
name|iosp
argument_list|)
expr_stmt|;
name|ref_assign
argument_list|(
name|iosp
argument_list|,
name|iosp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ref_assign
argument_list|(
name|iosp
operator|-
literal|1
argument_list|,
operator|&
name|token
argument_list|)
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
case|case
name|plain_exec
argument_list|(
name|tx_op_if
argument_list|)
case|:
name|x_if
label|:
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|iosp
operator|-
literal|1
argument_list|,
name|t_boolean
argument_list|)
condition|)
name|return_with_error
argument_list|(
name|e_typecheck
argument_list|,
name|iref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iosp
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|index
condition|)
block|{
name|iosp
operator|-=
literal|2
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|iesp
operator|>=
name|estop
condition|)
name|return_with_error
argument_list|(
name|e_execstackoverflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|store_state
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
name|whichp
operator|=
name|iosp
expr_stmt|;
name|iosp
operator|-=
literal|2
expr_stmt|;
goto|goto
name|ifup
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_ifelse
argument_list|)
case|:
name|x_ifelse
label|:
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|iosp
operator|-
literal|2
argument_list|,
name|t_boolean
argument_list|)
condition|)
name|return_with_error
argument_list|(
name|e_typecheck
argument_list|,
name|iref
argument_list|)
expr_stmt|;
if|if
condition|(
name|iesp
operator|>=
name|estop
condition|)
name|return_with_error
argument_list|(
name|e_execstackoverflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|store_state
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
name|whichp
operator|=
operator|(
name|iosp
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|index
condition|?
name|iosp
operator|-
literal|1
else|:
name|iosp
operator|)
expr_stmt|;
name|iosp
operator|-=
literal|3
expr_stmt|;
comment|/* Open code "up" for the array case(s) */
name|ifup
label|:
switch|switch
condition|(
name|r_type_xe
argument_list|(
name|whichp
argument_list|)
condition|)
block|{
case|case
name|exec
argument_list|(
name|t_file
argument_list|)
case|:
name|esfile
operator|=
literal|0
expr_stmt|;
comment|/* clear currentfile cache */
default|default:
name|ref_assign
argument_list|(
name|iesp
operator|+
literal|1
argument_list|,
name|whichp
argument_list|)
expr_stmt|;
name|iref
operator|=
name|iesp
operator|+
literal|1
expr_stmt|;
name|icount
operator|=
literal|0
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|exec
argument_list|(
name|t_array
argument_list|)
case|:
case|case
name|exec
argument_list|(
name|t_mixedarray
argument_list|)
case|:
case|case
name|exec
argument_list|(
name|t_shortarray
argument_list|)
case|:
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|icount
operator|=
name|r_size
argument_list|(
name|whichp
argument_list|)
operator|-
literal|1
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|icount
operator|<
literal|0
condition|)
goto|goto
name|up
goto|;
comment|/* 0-element proc */
name|iref
operator|=
name|whichp
operator|->
name|value
operator|.
name|refs
expr_stmt|;
comment|/* 1-element proc */
goto|goto
name|top
goto|;
block|}
operator|++
name|iesp
expr_stmt|;
comment|/* Do a ref_assign, but also set iref. */
name|iesp
operator|->
name|tas
operator|=
name|whichp
operator|->
name|tas
expr_stmt|;
name|iref
operator|=
name|iesp
operator|->
name|value
operator|.
name|refs
operator|=
name|whichp
operator|->
name|value
operator|.
name|refs
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_le
argument_list|)
case|:
name|x_le
label|:
name|code
operator|=
name|obj_le
argument_list|(
name|iosp
operator|-
literal|1
argument_list|,
name|iosp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
name|return_with_error
argument_list|(
name|code
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|iosp
operator|--
expr_stmt|;
name|make_bool
argument_list|(
name|iosp
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
case|case
name|plain_exec
argument_list|(
name|tx_op_pop
argument_list|)
case|:
name|x_pop
label|:
if|if
condition|(
name|iosp
operator|<
name|op_nargs_check
argument_list|(
literal|1
argument_list|)
condition|)
name|return_with_error
argument_list|(
name|e_stackunderflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|iosp
operator|--
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
case|case
name|plain_exec
argument_list|(
name|tx_op_roll
argument_list|)
case|:
name|x_roll
label|:
if|if
condition|(
operator|(
name|code
operator|=
name|zroll
argument_list|(
name|iosp
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|return_with_error
argument_list|(
name|code
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|iosp
operator|-=
literal|2
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
case|case
name|plain_exec
argument_list|(
name|tx_op_sub
argument_list|)
case|:
name|x_sub
label|:
if|if
condition|(
operator|(
name|code
operator|=
name|zop_sub
argument_list|(
name|iosp
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|return_with_error
argument_list|(
name|code
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|iosp
operator|--
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
comment|/* Executable types. */
case|case
name|plain_exec
argument_list|(
name|t_null
argument_list|)
case|:
goto|goto
name|bot
goto|;
case|case
name|plain_exec
argument_list|(
name|t_oparray
argument_list|)
case|:
comment|/* Replace with the definition and go again. */
name|pvalue
operator|=
operator|&
name|op_array_table
operator|.
name|value
operator|.
name|refs
index|[
name|op_index
argument_list|(
name|iref
argument_list|)
operator|-
name|op_def_count
index|]
expr_stmt|;
name|prst
label|:
comment|/* Prepare to call the procedure (array) in *pvalue. */
name|store_state
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
name|pr
label|:
comment|/* Call the array in *pvalue.  State has been stored. */
if|if
condition|(
operator|(
name|icount
operator|=
name|r_size
argument_list|(
name|pvalue
argument_list|)
operator|-
literal|1
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|icount
operator|<
literal|0
condition|)
goto|goto
name|up
goto|;
comment|/* 0-element proc */
name|iref
operator|=
name|pvalue
operator|->
name|value
operator|.
name|refs
expr_stmt|;
comment|/* 1-element proc */
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|iesp
operator|>=
name|estop
condition|)
name|return_with_error
argument_list|(
name|e_execstackoverflow
argument_list|,
name|pvalue
argument_list|)
expr_stmt|;
operator|++
name|iesp
expr_stmt|;
comment|/* Do a ref_assign, but also set iref. */
name|iesp
operator|->
name|tas
operator|=
name|pvalue
operator|->
name|tas
expr_stmt|;
name|iref
operator|=
name|iesp
operator|->
name|value
operator|.
name|refs
operator|=
name|pvalue
operator|->
name|value
operator|.
name|refs
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|plain_exec
argument_list|(
name|t_operator
argument_list|)
case|:
block|{
name|esp
operator|=
name|iesp
expr_stmt|;
comment|/* save for operator */
name|osp
operator|=
name|iosp
expr_stmt|;
comment|/* ditto */
comment|/* Operator routines take osp as an argument. */
comment|/* This is just a convenience, since they adjust */
comment|/* osp themselves to reflect the results. */
comment|/* Operators that (net) push information on the */
comment|/* operand stack must check for overflow: */
comment|/* this normally happens automatically through */
comment|/* the push macro (in oper.h). */
comment|/* Operators that do not typecheck their operands */
comment|/* must check explicitly for stack underflow. */
comment|/* Note that each case must set iosp = osp: */
comment|/* this is so we can switch on code without having to */
comment|/* store it and reload it (for dumb compilers). */
switch|switch
condition|(
name|code
operator|=
operator|(
operator|*
name|real_opproc
argument_list|(
name|iref
argument_list|)
operator|)
operator|(
name|iosp
operator|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal case */
name|iosp
operator|=
name|osp
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
case|case
name|o_push_estack
case|:
comment|/* store the state and go to up */
name|iosp
operator|=
name|osp
expr_stmt|;
name|store_state
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
name|iesp
operator|=
name|esp
expr_stmt|;
goto|goto
name|up
goto|;
case|case
name|o_pop_estack
case|:
comment|/* just go to up */
name|iosp
operator|=
name|osp
expr_stmt|;
if|if
condition|(
name|esp
operator|==
name|iesp
condition|)
goto|goto
name|bot
goto|;
name|iesp
operator|=
name|esp
expr_stmt|;
goto|goto
name|up
goto|;
case|case
name|o_reschedule
case|:
name|store_state
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
goto|goto
name|res
goto|;
case|case
name|e_typecheck
case|:
comment|/* This might be an operand stack */
comment|/* underflow: check the required # of */
comment|/* operands now. */
if|if
condition|(
name|osp
operator|<
name|osbot
operator|-
literal|1
operator|+
name|op_num_args
argument_list|(
name|iref
argument_list|)
condition|)
name|code
operator|=
name|e_stackunderflow
expr_stmt|;
comment|/* (falls through) */
block|}
name|iosp
operator|=
name|osp
expr_stmt|;
name|return_with_error
argument_list|(
name|code
argument_list|,
name|iref
argument_list|)
expr_stmt|;
block|}
case|case
name|plain_exec
argument_list|(
name|t_name
argument_list|)
case|:
name|pvalue
operator|=
name|iref
operator|->
name|value
operator|.
name|pname
operator|->
name|pvalue
expr_stmt|;
if|if
condition|(
operator|!
name|pv_valid
argument_list|(
name|pvalue
argument_list|)
condition|)
block|{
name|ref
modifier|*
name|pdvalue
decl_stmt|;
if|if
condition|(
operator|(
name|pdvalue
operator|=
name|dict_find_name
argument_list|(
name|iref
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|return_with_error
argument_list|(
name|e_undefined
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|pvalue
operator|=
name|pdvalue
expr_stmt|;
block|}
comment|/* Dispatch on the type of the value. */
comment|/* Again, we have to over-populate the switch. */
switch|switch
condition|(
name|r_type_xe
argument_list|(
name|pvalue
argument_list|)
condition|)
block|{
name|cases_nox
argument_list|()
operator|:
comment|/* access errors */
name|return_with_error
argument_list|(
name|e_invalidaccess
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|cases_lit_1
argument_list|()
operator|:
name|cases_lit_2
argument_list|()
operator|:
name|cases_lit_3
argument_list|()
operator|:
name|cases_lit_4
argument_list|()
operator|:
name|cases_lit_5
argument_list|()
operator|:
comment|/* Just push the value */
if|if
condition|(
name|iosp
operator|>=
name|ostop
condition|)
name|return_with_error
argument_list|(
name|e_stackoverflow
argument_list|,
name|pvalue
argument_list|)
expr_stmt|;
operator|++
name|iosp
expr_stmt|;
name|ref_assign
argument_list|(
name|iosp
argument_list|,
name|pvalue
argument_list|)
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
case|case
name|exec
argument_list|(
name|t_array
argument_list|)
case|:
case|case
name|exec
argument_list|(
name|t_mixedarray
argument_list|)
case|:
case|case
name|exec
argument_list|(
name|t_shortarray
argument_list|)
case|:
comment|/* This is an executable procedure, execute it. */
goto|goto
name|prst
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_add
argument_list|)
case|:
goto|goto
name|x_add
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_def
argument_list|)
case|:
goto|goto
name|x_def
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_dup
argument_list|)
case|:
goto|goto
name|x_dup
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_exch
argument_list|)
case|:
goto|goto
name|x_exch
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_if
argument_list|)
case|:
goto|goto
name|x_if
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_ifelse
argument_list|)
case|:
goto|goto
name|x_ifelse
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_le
argument_list|)
case|:
goto|goto
name|x_le
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_pop
argument_list|)
case|:
goto|goto
name|x_pop
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_roll
argument_list|)
case|:
goto|goto
name|x_roll
goto|;
case|case
name|plain_exec
argument_list|(
name|tx_op_sub
argument_list|)
case|:
goto|goto
name|x_sub
goto|;
case|case
name|plain_exec
argument_list|(
name|t_null
argument_list|)
case|:
goto|goto
name|bot
goto|;
case|case
name|plain_exec
argument_list|(
name|t_oparray
argument_list|)
case|:
name|pvalue
operator|=
operator|&
name|op_array_table
operator|.
name|value
operator|.
name|refs
index|[
name|op_index
argument_list|(
name|pvalue
argument_list|)
operator|-
name|op_def_count
index|]
expr_stmt|;
goto|goto
name|prst
goto|;
case|case
name|plain_exec
argument_list|(
name|t_operator
argument_list|)
case|:
block|{
comment|/* Shortcut for operators. */
comment|/* See above for the logic. */
name|esp
operator|=
name|iesp
expr_stmt|;
name|osp
operator|=
name|iosp
expr_stmt|;
switch|switch
condition|(
name|code
operator|=
operator|(
operator|*
name|real_opproc
argument_list|(
name|pvalue
argument_list|)
operator|)
operator|(
name|iosp
operator|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal case */
name|iosp
operator|=
name|osp
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
case|case
name|o_push_estack
case|:
comment|/* store the state and go to up */
name|iosp
operator|=
name|osp
expr_stmt|;
name|store_state
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
name|iesp
operator|=
name|esp
expr_stmt|;
goto|goto
name|up
goto|;
case|case
name|o_pop_estack
case|:
comment|/* just go to up */
name|iosp
operator|=
name|osp
expr_stmt|;
if|if
condition|(
name|esp
operator|==
name|iesp
condition|)
goto|goto
name|bot
goto|;
name|iesp
operator|=
name|esp
expr_stmt|;
goto|goto
name|up
goto|;
case|case
name|o_reschedule
case|:
name|store_state
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
goto|goto
name|res
goto|;
case|case
name|e_typecheck
case|:
if|if
condition|(
name|osp
operator|<
name|osbot
operator|-
literal|1
operator|+
name|op_num_args
argument_list|(
name|pvalue
argument_list|)
condition|)
name|code
operator|=
name|e_stackunderflow
expr_stmt|;
block|}
name|iosp
operator|=
name|osp
expr_stmt|;
name|return_with_error
argument_list|(
name|code
argument_list|,
name|pvalue
argument_list|)
expr_stmt|;
block|}
case|case
name|plain_exec
argument_list|(
name|t_name
argument_list|)
case|:
case|case
name|exec
argument_list|(
name|t_file
argument_list|)
case|:
case|case
name|exec
argument_list|(
name|t_string
argument_list|)
case|:
default|default:
comment|/* Not a procedure, reinterpret it. */
name|store_state
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
name|icount
operator|=
literal|0
expr_stmt|;
name|iref
operator|=
name|pvalue
expr_stmt|;
goto|goto
name|top
goto|;
block|}
case|case
name|exec
argument_list|(
name|t_file
argument_list|)
case|:
block|{
comment|/* Executable file.  Read the next token and interpret it. */
name|stream
modifier|*
name|s
decl_stmt|;
name|code
operator|=
name|file_check_read
argument_list|(
name|iref
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
name|return_with_error
argument_list|(
name|code
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|rt
label|:
if|if
condition|(
name|iosp
operator|>=
name|ostop
condition|)
comment|/* check early */
name|return_with_error
argument_list|(
name|e_stackoverflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|osp
operator|=
name|iosp
expr_stmt|;
comment|/* scan_token uses ostack */
switch|switch
condition|(
name|code
operator|=
name|scan_token
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|(
name|ref
operator|*
operator|)
operator|(
name|iosp
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* read a token */
comment|/* It's worth checking for literals, which make up */
comment|/* the majority of input tokens, before storing the */
comment|/* state on the e-stack.  Note that because of //, */
comment|/* the token may have *any* type and attributes. */
switch|switch
condition|(
name|r_type
argument_list|(
name|iosp
operator|+
literal|1
argument_list|)
condition|)
block|{
case|case
name|t_name
case|:
case|case
name|t_string
case|:
if|if
condition|(
name|r_has_attr
argument_list|(
name|iosp
operator|+
literal|1
argument_list|,
name|a_executable
argument_list|)
condition|)
break|break;
comment|/* Executable arrays aren't executed at the */
comment|/* top level -- they're treated as literals. */
case|case
name|t_array
case|:
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
case|case
name|t_integer
case|:
case|case
name|t_real
case|:
operator|++
name|iosp
expr_stmt|;
goto|goto
name|rt
goto|;
block|}
name|store_state
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
comment|/* Push the file on the e-stack */
if|if
condition|(
name|iesp
operator|>=
name|estop
condition|)
name|return_with_error
argument_list|(
name|e_execstackoverflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
operator|++
name|iesp
expr_stmt|;
name|ref_assign
argument_list|(
name|iesp
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|iref
operator|=
name|iosp
operator|+
literal|1
expr_stmt|;
name|icount
operator|=
literal|0
expr_stmt|;
goto|goto
name|top
goto|;
case|case
literal|1
case|:
comment|/* end of file */
name|code
operator|=
name|file_close
argument_list|(
name|iref
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
name|return_with_error
argument_list|(
name|code
argument_list|,
name|iref
argument_list|)
expr_stmt|;
goto|goto
name|bot
goto|;
default|default:
comment|/* error */
name|return_with_error
argument_list|(
name|code
argument_list|,
name|iref
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|exec
argument_list|(
name|t_string
argument_list|)
case|:
block|{
comment|/* Executable string.  Read a token and interpret it. */
name|stream
name|ss
decl_stmt|;
name|sread_string
argument_list|(
operator|&
name|ss
argument_list|,
name|iref
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|iref
argument_list|)
argument_list|)
expr_stmt|;
name|osp
operator|=
name|iosp
expr_stmt|;
comment|/* scan_token uses ostack */
switch|switch
condition|(
name|code
operator|=
name|scan_token
argument_list|(
operator|&
name|ss
argument_list|,
literal|1
argument_list|,
operator|&
name|token
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* read a token */
name|store_state
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
comment|/* Push the updated string back on the e-stack */
if|if
condition|(
name|iesp
operator|>=
name|estop
condition|)
name|return_with_error
argument_list|(
name|e_execstackoverflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
operator|++
name|iesp
expr_stmt|;
name|iesp
operator|->
name|tas
operator|.
name|type_attrs
operator|=
name|iref
operator|->
name|tas
operator|.
name|type_attrs
expr_stmt|;
name|iesp
operator|->
name|value
operator|.
name|bytes
operator|=
name|ss
operator|.
name|cptr
operator|+
literal|1
expr_stmt|;
name|r_set_size
argument_list|(
name|iesp
argument_list|,
name|ss
operator|.
name|cbuf
operator|+
name|ss
operator|.
name|bsize
operator|-
name|ss
operator|.
name|cptr
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iref
operator|=
operator|&
name|token
expr_stmt|;
name|icount
operator|=
literal|0
expr_stmt|;
goto|goto
name|top
goto|;
case|case
literal|1
case|:
comment|/* end of string */
goto|goto
name|bot
goto|;
default|default:
comment|/* error */
name|return_with_error
argument_list|(
name|code
argument_list|,
name|iref
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle packed arrays here by re-dispatching. */
comment|/* This also picks up some anomalous cases of non-packed arrays. */
default|default:
switch|switch
condition|(
operator|*
operator|(
name|ushort
operator|*
operator|)
name|iref
operator|>>
name|packed_type_shift
condition|)
block|{
case|case
name|pt_full_ref
case|:
case|case
name|pt_full_ref
operator|+
literal|1
case|:
if|if
condition|(
name|iosp
operator|>=
name|ostop
condition|)
name|return_with_error
argument_list|(
name|e_stackoverflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
operator|++
name|iosp
expr_stmt|;
comment|/* We know that refs are properly aligned: */
comment|/* see packed.h for details. */
name|ref_assign
argument_list|(
name|iosp
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
case|case
name|pt_executable_operator
case|:
block|{
name|uint
name|index
init|=
operator|*
operator|(
name|ushort
operator|*
operator|)
name|iref
operator|&
name|packed_int_mask
decl_stmt|;
name|op_index_ref
argument_list|(
name|index
argument_list|,
operator|&
name|token
argument_list|)
expr_stmt|;
name|store_state_short
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
name|icount
operator|=
literal|0
expr_stmt|;
name|iref
operator|=
operator|&
name|token
expr_stmt|;
block|}
goto|goto
name|top
goto|;
case|case
name|pt_integer
case|:
if|if
condition|(
name|iosp
operator|>=
name|ostop
condition|)
name|return_with_error
argument_list|(
name|e_stackoverflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
operator|++
name|iosp
expr_stmt|;
name|make_int
argument_list|(
name|iosp
argument_list|,
operator|(
operator|*
operator|(
name|short
operator|*
operator|)
name|iref
operator|&
name|packed_int_mask
operator|)
operator|+
name|packed_min_intval
argument_list|)
expr_stmt|;
name|next_short
argument_list|()
expr_stmt|;
case|case
name|pt_literal_name
case|:
case|case
name|pt_literal_name
operator|+
literal|1
case|:
if|if
condition|(
name|iosp
operator|>=
name|ostop
condition|)
name|return_with_error
argument_list|(
name|e_stackoverflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
operator|++
name|iosp
expr_stmt|;
name|name_index_ref
argument_list|(
operator|(
name|uint
operator|)
operator|*
operator|(
name|ushort
operator|*
operator|)
name|iref
operator|&
name|packed_max_name_index
argument_list|,
name|iosp
argument_list|)
expr_stmt|;
name|next_short
argument_list|()
expr_stmt|;
case|case
name|pt_executable_name
case|:
case|case
name|pt_executable_name
operator|+
literal|1
case|:
block|{
name|ref
name|nref
decl_stmt|;
name|name_index_ref
argument_list|(
operator|(
name|uint
operator|)
operator|*
operator|(
name|ushort
operator|*
operator|)
name|iref
operator|&
name|packed_max_name_index
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
name|pvalue
operator|=
name|nref
operator|.
name|value
operator|.
name|pname
operator|->
name|pvalue
expr_stmt|;
if|if
condition|(
operator|!
name|pv_valid
argument_list|(
name|pvalue
argument_list|)
condition|)
block|{
name|ref
modifier|*
name|pdvalue
decl_stmt|;
if|if
condition|(
operator|(
name|pdvalue
operator|=
name|dict_find_name
argument_list|(
operator|&
name|nref
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|return_with_error
argument_list|(
name|e_undefined
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
name|pvalue
operator|=
name|pdvalue
expr_stmt|;
block|}
switch|switch
condition|(
name|r_type_xe
argument_list|(
name|pvalue
argument_list|)
condition|)
block|{
case|case
name|exec
argument_list|(
name|t_array
argument_list|)
case|:
case|case
name|exec
argument_list|(
name|t_mixedarray
argument_list|)
case|:
case|case
name|exec
argument_list|(
name|t_shortarray
argument_list|)
case|:
comment|/* This is an executable procedure, */
comment|/* execute it. */
name|store_state_short
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
goto|goto
name|pr
goto|;
default|default:
comment|/* handles other literals */
comment|/* Not a procedure, reinterpret it. */
name|store_state_short
argument_list|(
name|iesp
argument_list|)
expr_stmt|;
name|icount
operator|=
literal|0
expr_stmt|;
name|iref
operator|=
name|pvalue
expr_stmt|;
goto|goto
name|top
goto|;
block|}
block|}
comment|/* default can't happen here */
block|}
block|}
comment|/* Literal type, just push it. */
if|if
condition|(
name|iosp
operator|>=
name|ostop
condition|)
name|return_with_error
argument_list|(
name|e_stackoverflow
argument_list|,
name|iref
argument_list|)
expr_stmt|;
operator|++
name|iosp
expr_stmt|;
name|ref_assign
argument_list|(
name|iosp
argument_list|,
name|iref
argument_list|)
expr_stmt|;
name|bot
label|:
name|next
argument_list|()
expr_stmt|;
name|out
label|:
comment|/* At most 1 more token in the current procedure. */
comment|/* (We already decremented icount.) */
if|if
condition|(
operator|!
name|icount
condition|)
block|{
comment|/* Pop the execution stack for tail recursion. */
name|iesp
operator|--
expr_stmt|;
name|iref
operator|++
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|up
label|:
comment|/* See if there is anything left on the execution stack. */
switch|switch
condition|(
name|r_type_xe
argument_list|(
name|iesp
argument_list|)
condition|)
block|{
default|default:
name|iref
operator|=
name|iesp
operator|--
expr_stmt|;
name|icount
operator|=
literal|0
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|exec
argument_list|(
name|t_array
argument_list|)
case|:
case|case
name|exec
argument_list|(
name|t_mixedarray
argument_list|)
case|:
case|case
name|exec
argument_list|(
name|t_shortarray
argument_list|)
case|:
empty_stmt|;
block|}
name|iref
operator|=
name|iesp
operator|->
name|value
operator|.
name|refs
expr_stmt|;
comment|/* next element of array */
name|icount
operator|=
name|r_size
argument_list|(
name|iesp
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|icount
operator|<=
literal|0
condition|)
comment|/*<= 1 more elements */
block|{
name|iesp
operator|--
expr_stmt|;
comment|/* pop, or tail recursion */
if|if
condition|(
name|icount
operator|<
literal|0
condition|)
goto|goto
name|up
goto|;
block|}
goto|goto
name|top
goto|;
name|res
label|:
comment|/* Some operator has asked for context rescheduling. */
name|code
operator|=
call|(
modifier|*
name|gs_interp_reschedule_proc
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
name|return_with_error
argument_list|(
name|code
argument_list|,
name|iref
argument_list|)
expr_stmt|;
comment|/* Reload state information from memory. */
name|iosp
operator|=
name|osp
expr_stmt|;
name|iesp
operator|=
name|esp
expr_stmt|;
goto|goto
name|up
goto|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|interp_op_defs
index|[]
init|=
block|{
comment|/* Internal operators */
block|{
literal|"0%interp_exit"
block|,
name|interp_exit
block|,
operator|&
name|i_interp_exit
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

