begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevpcfb.c */
end_comment

begin_comment
comment|/* IBM PC EGA and VGA display drivers for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"dos_.h"
end_include

begin_typedef
typedef|typedef
name|union
name|REGS
name|registers
typedef|;
end_typedef

begin_comment
comment|/* This is fundamentally an EGA driver with some parameters */
end_comment

begin_comment
comment|/* that allow it to drive larger displays. */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gs.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USE_ASM
end_ifndef

begin_define
define|#
directive|define
name|USE_ASM
value|0
end_define

begin_comment
comment|/* don't use assembly language */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the short (integer) version of "transparent" color. */
end_comment

begin_comment
comment|/* ****** Depends on gx_no_color_index being all 1's. ******/
end_comment

begin_define
define|#
directive|define
name|no_color
value|((int)gx_no_color_index)
end_define

begin_comment
comment|/* For testing, the EGA may be defined as a monochrome, 8-color, or */
end_comment

begin_comment
comment|/* 16-color device. */
end_comment

begin_define
define|#
directive|define
name|ega_bits_of_color
value|2
end_define

begin_comment
comment|/* 0, 1, or 2 */
end_comment

begin_comment
comment|/* Range of r-g-b values */
end_comment

begin_define
define|#
directive|define
name|rgb_max
value|ega_bits_of_color
end_define

begin_comment
comment|/* Procedures */
end_comment

begin_comment
comment|/* See gxdevice.h for the definitions of the procedures. */
end_comment

begin_expr_stmt
name|dev_proc_open_device
argument_list|(
name|ega_open
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_close_device
argument_list|(
name|ega_close
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_map_rgb_color
argument_list|(
name|ega_map_rgb_color
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_map_color_rgb
argument_list|(
name|ega_map_color_rgb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_fill_rectangle
argument_list|(
name|ega_fill_rectangle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_tile_rectangle
argument_list|(
name|ega_tile_rectangle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ega_write_dot
argument_list|(
name|P4
argument_list|(
name|gx_device
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|gx_color_index
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|dev_proc_copy_mono
argument_list|(
name|ega_copy_mono
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_copy_color
argument_list|(
name|ega_copy_color
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_get_bits
argument_list|(
name|ega_get_bits
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Type for frame buffer pointers. */
end_comment

begin_comment
comment|/* Note that 'far' gets defined as null on 32-bit systems. */
end_comment

begin_typedef
typedef|typedef
name|byte
name|far
modifier|*
name|fb_ptr
typedef|;
end_typedef

begin_comment
comment|/* The device descriptor */
end_comment

begin_typedef
typedef|typedef
name|struct
name|gx_device_ega_s
name|gx_device_ega
typedef|;
end_typedef

begin_struct
struct|struct
name|gx_device_ega_s
block|{
name|gx_device_common
expr_stmt|;
name|int
name|raster
decl_stmt|;
comment|/* frame buffer bytes per line */
name|int
name|fb_seg_mult
decl_stmt|;
comment|/* multiplier for segment part */
comment|/* of frame buffer pointer */
name|int
name|fb_byte_mult
decl_stmt|;
comment|/* multiplier for word part ditto */
define|#
directive|define
name|mk_fb_ptr
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|(fb_dev->fb_byte_mult == 0 ?\    (fb_ptr)MK_PTR(regen + (y) * (fb_dev->fb_seg_mult), (x)>> 3) :\    (fb_ptr)MK_PTR(regen + ((y)>> 4) * (fb_dev->fb_seg_mult),\ 		 (((y)& 15) * fb_dev->fb_byte_mult) + ((x)>> 3)))
comment|/* Define the largest height that can be processed */
comment|/* within a single 64K segment.  If fb_dev->height> max_rop_height, */
comment|/* we may have to break up operations into pieces. */
name|unsigned
name|max_rop_height
decl_stmt|;
name|int
name|video_mode
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Macro for casting gx_device argument */
end_comment

begin_define
define|#
directive|define
name|fb_dev
value|((gx_device_ega *)dev)
end_define

begin_comment
comment|/* Procedure record */
end_comment

begin_decl_stmt
name|private
name|gx_device_procs
name|ega_procs
init|=
block|{
name|ega_open
block|,
name|gx_default_get_initial_matrix
block|,
name|gx_default_sync_output
block|,
name|gx_default_output_page
block|,
name|ega_close
block|,
name|ega_map_rgb_color
block|,
name|ega_map_color_rgb
block|,
name|ega_fill_rectangle
block|,
name|ega_tile_rectangle
block|,
name|ega_copy_mono
block|,
name|ega_copy_color
block|,
name|gx_default_draw_line
block|,
name|ega_get_bits
block|,
name|gx_default_get_props
block|,
name|gx_default_put_props
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro for creating instances */
end_comment

begin_comment
comment|/* The initial parameters map an appropriate fraction of */
end_comment

begin_comment
comment|/* the screen to an 8.5" x 11" coordinate space. */
end_comment

begin_comment
comment|/* This may or may not be what is desired! */
end_comment

begin_define
define|#
directive|define
name|ega_device
parameter_list|(
name|dev_name
parameter_list|,
name|fb_raster
parameter_list|,
name|screen_height
parameter_list|,
name|aspect_ratio
parameter_list|,
name|video_mode
parameter_list|)
define|\
value|{	sizeof(gx_device_ega),\&ega_procs,\ 	dev_name,\ 	fb_raster * 8, screen_height,\ 	  (screen_height * (aspect_ratio)) / 11.0,
comment|/* x density */
value|\ 	  screen_height / 11.0,
comment|/* y density */
value|\ 	no_margins,\ 	   {	(rgb_max ? 3 : 1),
comment|/* num_components */
value|\ 		4,
comment|/* depth */
value|\ 		(rgb_max ? rgb_max : 1),
comment|/* gray_max */
value|\ 		rgb_max,\ 		3,
comment|/* dither_gray */
value|\ 		(rgb_max ? rgb_max + 1 : 0)
comment|/* dither_rgb */
value|\ 	   },\ 	0,
comment|/* not opened yet */
value|\ 	fb_raster,\ 	(fb_raster& 15 ? fb_raster : fb_raster>> 4),\ 	(fb_raster& 15 ? fb_raster : 0),\ 	((unsigned)(0xffff - fb_raster) / fb_raster),\ 	video_mode\    }
end_define

begin_comment
comment|/* All the known instances */
end_comment

begin_comment
comment|/* EGA */
end_comment

begin_decl_stmt
name|gx_device_ega
name|gs_ega_device
init|=
name|ega_device
argument_list|(
literal|"ega"
argument_list|,
literal|80
argument_list|,
literal|350
argument_list|,
literal|48.0
operator|/
literal|35.0
argument_list|,
literal|0x10
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VGA */
end_comment

begin_decl_stmt
name|gx_device_ega
name|gs_vga_device
init|=
name|ega_device
argument_list|(
literal|"vga"
argument_list|,
literal|80
argument_list|,
literal|480
argument_list|,
literal|1.0
argument_list|,
literal|0x12
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Trident SuperVGA, 800x600, 16-color mode */
end_comment

begin_decl_stmt
name|gx_device_ega
name|gs_tvga16_device
init|=
name|ega_device
argument_list|(
literal|"tvga16"
argument_list|,
literal|100
argument_list|,
literal|600
argument_list|,
literal|1.0
argument_list|,
literal|0x5b
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tseng Labs SuperVGA, 800x600, 16-color mode */
end_comment

begin_decl_stmt
name|gx_device_ega
name|gs_tseng16_device
init|=
name|ega_device
argument_list|(
literal|"tseng16"
argument_list|,
literal|100
argument_list|,
literal|600
argument_list|,
literal|1.0
argument_list|,
literal|0x29
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EIZO MDB-10 */
end_comment

begin_decl_stmt
name|gx_device_ega
name|gs_mdb10_device
init|=
name|ega_device
argument_list|(
literal|"mdb10"
argument_list|,
literal|128
argument_list|,
literal|768
argument_list|,
literal|1.0
argument_list|,
literal|0x37
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the color spectrum */
end_comment

begin_define
define|#
directive|define
name|black
value|0
end_define

begin_define
define|#
directive|define
name|blue
value|1
end_define

begin_define
define|#
directive|define
name|green
value|2
end_define

begin_define
define|#
directive|define
name|cyan
value|3
end_define

begin_define
define|#
directive|define
name|red
value|4
end_define

begin_define
define|#
directive|define
name|magenta
value|5
end_define

begin_define
define|#
directive|define
name|brown
value|6
end_define

begin_define
define|#
directive|define
name|white
value|7
end_define

begin_define
define|#
directive|define
name|dgray
value|8
end_define

begin_comment
comment|/* dark gray is not very usable */
end_comment

begin_define
define|#
directive|define
name|lblue
value|9
end_define

begin_define
define|#
directive|define
name|lgreen
value|10
end_define

begin_define
define|#
directive|define
name|lcyan
value|11
end_define

begin_define
define|#
directive|define
name|lred
value|12
end_define

begin_define
define|#
directive|define
name|lmagenta
value|13
end_define

begin_define
define|#
directive|define
name|yellow
value|14
end_define

begin_define
define|#
directive|define
name|bwhite
value|15
end_define

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
name|private
name|int
name|ega_get_mode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|ega_set_mode
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Save the EGA mode */
end_comment

begin_decl_stmt
name|private
name|int
name|ega_save_mode
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reinitialize the EGA for text mode */
end_comment

begin_function
name|int
name|ega_close
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|ega_save_mode
operator|>=
literal|0
condition|)
name|ega_set_mode
argument_list|(
name|ega_save_mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Map a r-g-b color to an EGA color code. */
end_comment

begin_function
name|gx_color_index
name|ega_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_value
name|r
parameter_list|,
name|gx_color_value
name|g
parameter_list|,
name|gx_color_value
name|b
parameter_list|)
block|{
define|#
directive|define
name|c12
value|(gx_max_color_value / 2)
define|#
directive|define
name|c13
value|(gx_max_color_value / 3)
define|#
directive|define
name|c23
value|(gx_max_color_value - c13)
define|#
directive|define
name|cmono
parameter_list|()
value|((gx_color_index)mono_color[r>> (gx_color_value_bits - 2)])
if|#
directive|if
name|ega_bits_of_color
operator|==
literal|0
comment|/* monochrome */
specifier|static
name|byte
name|mono_color
index|[
literal|4
index|]
init|=
block|{
name|black
block|,
name|white
block|,
name|white
block|,
name|bwhite
block|}
decl_stmt|;
return|return
name|cmono
argument_list|()
return|;
else|#
directive|else
if|#
directive|if
name|ega_bits_of_color
operator|==
literal|1
specifier|static
name|byte
name|mono_color
index|[
literal|4
index|]
init|=
block|{
name|black
block|,
name|white
block|,
name|white
block|,
name|bwhite
block|}
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|g
operator|&&
name|g
operator|==
name|b
condition|)
return|return
name|cmono
argument_list|()
return|;
return|return
call|(
name|gx_color_index
call|)
argument_list|(
operator|(
name|r
operator|>
name|c12
condition|?
literal|4
else|:
literal|0
operator|)
operator||
operator|(
name|g
operator|>
name|c12
condition|?
literal|10
else|:
literal|0
operator|)
operator||
operator|(
name|b
operator|>
name|c12
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
return|;
else|#
directive|else
specifier|static
name|byte
name|g0
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
name|black
block|,
name|blue
block|,
name|lblue
block|}
block|,
block|{
name|red
block|,
name|magenta
block|,
name|lmagenta
block|}
block|,
block|{
name|lred
block|,
name|lmagenta
block|,
name|lmagenta
block|}
block|}
decl_stmt|;
specifier|static
name|byte
name|g1
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
name|green
block|,
name|cyan
block|,
name|lcyan
block|}
block|,
block|{
name|brown
block|,
name|white
block|,
name|lcyan
block|}
block|,
block|{
name|yellow
block|,
name|yellow
block|,
name|lmagenta
block|}
block|}
decl_stmt|;
specifier|static
name|byte
name|g2
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
name|lgreen
block|,
name|lgreen
block|,
name|lcyan
block|}
block|,
block|{
name|lgreen
block|,
name|lgreen
block|,
name|lcyan
block|}
block|,
block|{
name|yellow
block|,
name|yellow
block|,
name|bwhite
block|}
block|}
decl_stmt|;
return|return
call|(
name|gx_color_index
call|)
argument_list|(
operator|(
name|g
operator|>=
name|c23
condition|?
name|g2
else|:
name|g
operator|>=
name|c13
condition|?
name|g1
else|:
name|g0
operator|)
index|[
name|r
operator|>=
name|c23
condition|?
literal|2
else|:
name|r
operator|>=
name|c13
condition|?
literal|1
else|:
literal|0
index|]
index|[
name|b
operator|>=
name|c23
condition|?
literal|2
else|:
name|b
operator|>=
name|c13
condition|?
literal|1
else|:
literal|0
index|]
argument_list|)
return|;
endif|#
directive|endif
endif|#
directive|endif
undef|#
directive|undef
name|c12
undef|#
directive|undef
name|c13
undef|#
directive|undef
name|c23
block|}
end_function

begin_comment
comment|/* Map a color code to r-g-b. */
end_comment

begin_function
name|int
name|ega_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|gx_color_value
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
define|#
directive|define
name|icolor
value|(int)color
if|#
directive|if
name|rgb_max
operator|>
literal|1
name|gx_color_value
name|one
init|=
operator|(
name|icolor
operator|&
literal|8
condition|?
name|gx_max_color_value
else|:
name|gx_max_color_value
operator|/
literal|3
operator|)
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|one
value|(gx_max_color_value / 2 + 1)
endif|#
directive|endif
name|prgb
index|[
literal|0
index|]
operator|=
operator|(
name|icolor
operator|&
literal|4
condition|?
name|one
else|:
literal|0
operator|)
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
operator|(
name|icolor
operator|&
literal|2
condition|?
name|one
else|:
literal|0
operator|)
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
operator|(
name|icolor
operator|&
literal|1
condition|?
name|one
else|:
literal|0
operator|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|one
undef|#
directive|undef
name|icolor
block|}
end_function

begin_comment
comment|/* Macro for validating rectangle parameters x, y, w, h */
end_comment

begin_define
define|#
directive|define
name|validate_rect
parameter_list|()
define|\
value|if ( w<= 0 || h<= 0 ) return 0;\   if ( x< 0 || y< 0 || x + w> dev->width || y + h> dev->height ) return -1
end_define

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Read the device mode */
end_comment

begin_function
name|private
name|int
name|ega_get_mode
parameter_list|()
block|{
name|registers
name|regs
decl_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0xf
expr_stmt|;
name|int86
argument_list|(
literal|0x10
argument_list|,
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
return|return
name|regs
operator|.
name|h
operator|.
name|al
return|;
block|}
end_function

begin_comment
comment|/* Set the device mode */
end_comment

begin_function
name|private
name|void
name|ega_set_mode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|registers
name|regs
decl_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|al
operator|=
name|mode
expr_stmt|;
name|int86
argument_list|(
literal|0x10
argument_list|,
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Structure for operation parameters. */
end_comment

begin_comment
comment|/* Note that this structure is known to assembly code. */
end_comment

begin_comment
comment|/* Not all parameters are used for every operation. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rop_params_s
block|{
name|fb_ptr
name|dest
decl_stmt|;
comment|/* pointer to frame buffer */
name|int
name|draster
decl_stmt|;
comment|/* raster of frame buffer */
name|byte
name|far
modifier|*
name|src
decl_stmt|;
comment|/* pointer to source data */
name|int
name|sraster
decl_stmt|;
comment|/* source raster */
name|int
name|width
decl_stmt|;
comment|/* width in bytes */
name|int
name|height
decl_stmt|;
comment|/* height in scan lines */
name|int
name|shift
decl_stmt|;
comment|/* amount to right shift source */
name|int
name|invert
decl_stmt|;
comment|/* 0 or -1 to invert source */
name|int
name|data
decl_stmt|;
comment|/* data for fill */
block|}
name|rop_params
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|rop_params
name|_ss
modifier|*
name|rop_ptr
typedef|;
end_typedef

begin_comment
comment|/* Assembly language routines */
end_comment

begin_if
if|#
directive|if
name|USE_ASM
end_if

begin_decl_stmt
name|void
name|memsetcol
argument_list|(
name|P1
argument_list|(
name|rop_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dest, draster, height, data */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|memsetcol
value|cmemsetcol
end_define

begin_function
name|private
name|void
name|cmemsetcol
parameter_list|(
name|rop_ptr
name|rop
parameter_list|)
block|{
name|byte
name|far
modifier|*
name|addr
init|=
name|rop
operator|->
name|dest
decl_stmt|;
name|int
name|yc
init|=
name|rop
operator|->
name|height
decl_stmt|;
name|byte
name|data
init|=
name|rop
operator|->
name|data
decl_stmt|;
name|int
name|draster
init|=
name|rop
operator|->
name|draster
decl_stmt|;
while|while
condition|(
name|yc
operator|--
condition|)
block|{
name|byte_discard
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
name|data
expr_stmt|;
name|addr
operator|+=
name|draster
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_ASM
end_if

begin_decl_stmt
name|void
name|memsetrect
argument_list|(
name|P1
argument_list|(
name|rop_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dest, draster, width, height, data */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|memsetrect
value|cmemsetrect
end_define

begin_function
name|private
name|void
name|cmemsetrect
parameter_list|(
name|rop_ptr
name|rop
parameter_list|)
block|{
name|int
name|yc
init|=
name|rop
operator|->
name|height
decl_stmt|;
name|int
name|width
init|=
name|rop
operator|->
name|width
decl_stmt|;
if|if
condition|(
name|yc
operator|<=
literal|0
operator|||
name|width
operator|<=
literal|0
condition|)
return|return;
block|{
name|byte
name|far
modifier|*
name|addr
init|=
name|rop
operator|->
name|dest
decl_stmt|;
name|byte
name|data
init|=
name|rop
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|width
operator|>
literal|5
condition|)
comment|/* use memset */
block|{
name|int
name|skip
init|=
name|rop
operator|->
name|draster
decl_stmt|;
do|do
block|{
name|memset
argument_list|(
name|addr
argument_list|,
name|data
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|skip
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|yc
condition|)
do|;
block|}
else|else
comment|/* avoid the fixed overhead */
block|{
name|int
name|skip
init|=
name|rop
operator|->
name|draster
operator|-
name|width
decl_stmt|;
do|do
block|{
name|int
name|cnt
init|=
name|width
decl_stmt|;
do|do
block|{
operator|*
name|addr
operator|++
operator|=
name|data
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|cnt
condition|)
do|;
name|addr
operator|+=
name|skip
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|yc
condition|)
do|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_ASM
end_if

begin_decl_stmt
name|void
name|memrwcol
argument_list|(
name|P1
argument_list|(
name|rop_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dest, draster, src, sraster, height, shift, invert */
end_comment

begin_define
define|#
directive|define
name|memrwcol0
parameter_list|(
name|rop
parameter_list|)
value|memrwcol(rop)
end_define

begin_comment
comment|/* same except shift = 0 */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|memrwcol
value|cmemrwcol
end_define

begin_define
define|#
directive|define
name|memrwcol0
value|cmemrwcol0
end_define

begin_function
name|private
name|void
name|cmemrwcol
parameter_list|(
name|rop_ptr
name|rop
parameter_list|)
block|{
name|byte
name|far
modifier|*
name|dp
init|=
name|rop
operator|->
name|dest
decl_stmt|,
modifier|*
name|sp
init|=
name|rop
operator|->
name|src
decl_stmt|;
name|int
name|yc
init|=
name|rop
operator|->
name|height
decl_stmt|;
name|int
name|shift
init|=
name|rop
operator|->
name|shift
decl_stmt|;
name|byte
name|invert
init|=
name|rop
operator|->
name|invert
decl_stmt|;
name|int
name|sraster
init|=
name|rop
operator|->
name|sraster
decl_stmt|,
name|draster
init|=
name|rop
operator|->
name|draster
decl_stmt|;
while|while
condition|(
name|yc
operator|--
condition|)
block|{
name|byte_discard
argument_list|(
operator|*
name|dp
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
operator|(
operator|(
operator|*
name|sp
operator|>>
name|shift
operator|)
operator|+
operator|(
operator|*
name|sp
operator|<<
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
operator|)
operator|^
name|invert
expr_stmt|;
name|dp
operator|+=
name|draster
operator|,
name|sp
operator|+=
name|sraster
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|cmemrwcol0
parameter_list|(
name|rop_ptr
name|rop
parameter_list|)
block|{
name|byte
name|far
modifier|*
name|dp
init|=
name|rop
operator|->
name|dest
decl_stmt|,
modifier|*
name|sp
init|=
name|rop
operator|->
name|src
decl_stmt|;
name|int
name|yc
init|=
name|rop
operator|->
name|height
decl_stmt|;
name|byte
name|invert
init|=
name|rop
operator|->
name|invert
decl_stmt|;
name|int
name|sraster
init|=
name|rop
operator|->
name|sraster
decl_stmt|,
name|draster
init|=
name|rop
operator|->
name|draster
decl_stmt|;
if|if
condition|(
name|yc
operator|>
literal|0
condition|)
do|do
block|{
name|byte_discard
argument_list|(
operator|*
name|dp
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
operator|*
name|sp
operator|^
name|invert
expr_stmt|;
name|dp
operator|+=
name|draster
operator|,
name|sp
operator|+=
name|sraster
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|yc
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_ASM
end_if

begin_decl_stmt
name|void
name|memrwcol2
argument_list|(
name|P1
argument_list|(
name|rop_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dest, draster, src, sraster, height, shift, invert */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|memrwcol2
value|cmemrwcol2
end_define

begin_function
name|private
name|void
name|cmemrwcol2
parameter_list|(
name|rop_ptr
name|rop
parameter_list|)
block|{
name|byte
name|far
modifier|*
name|dp
init|=
name|rop
operator|->
name|dest
decl_stmt|,
modifier|*
name|sp
init|=
name|rop
operator|->
name|src
decl_stmt|;
name|int
name|yc
init|=
name|rop
operator|->
name|height
decl_stmt|;
name|int
name|shift
init|=
name|rop
operator|->
name|shift
decl_stmt|;
name|byte
name|invert
init|=
name|rop
operator|->
name|invert
decl_stmt|;
name|int
name|sraster
init|=
name|rop
operator|->
name|sraster
decl_stmt|,
name|draster
init|=
name|rop
operator|->
name|draster
decl_stmt|;
while|while
condition|(
name|yc
operator|--
condition|)
block|{
name|byte_discard
argument_list|(
operator|*
name|dp
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
operator|(
operator|(
name|sp
index|[
literal|1
index|]
operator|>>
name|shift
operator|)
operator|+
operator|(
operator|*
name|sp
operator|<<
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
operator|)
operator|^
name|invert
expr_stmt|;
name|dp
operator|+=
name|draster
operator|,
name|sp
operator|+=
name|sraster
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward definitions */
end_comment

begin_decl_stmt
name|void
name|fill_rectangle
argument_list|(
name|P4
argument_list|(
name|rop_ptr
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fill_row
argument_list|(
name|P3
argument_list|(
argument|byte far *
argument_list|,
argument|int
argument_list|,
argument|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the device port and register numbers, and the regen map base */
end_comment

begin_define
define|#
directive|define
name|out2
parameter_list|(
name|port
parameter_list|,
name|index
parameter_list|,
name|data
parameter_list|)
define|\
value|(outportb(port, index), outportb((port)+1, data))
end_define

begin_define
define|#
directive|define
name|seq_addr
value|0x3c4
end_define

begin_define
define|#
directive|define
name|s_map
value|2
end_define

begin_define
define|#
directive|define
name|set_s_map
parameter_list|(
name|mask
parameter_list|)
value|out2(seq_addr, s_map, mask)
end_define

begin_define
define|#
directive|define
name|graph_addr
value|0x3ce
end_define

begin_define
define|#
directive|define
name|g_const
value|0
end_define

begin_comment
comment|/* set/reset */
end_comment

begin_define
define|#
directive|define
name|set_g_const
parameter_list|(
name|color
parameter_list|)
value|out2(graph_addr, g_const, color)
end_define

begin_define
define|#
directive|define
name|g_const_map
value|1
end_define

begin_comment
comment|/* enable set/reset */
end_comment

begin_define
define|#
directive|define
name|set_g_const_map
parameter_list|(
name|map
parameter_list|)
value|out2(graph_addr, g_const_map, map)
end_define

begin_define
define|#
directive|define
name|g_function
value|3
end_define

begin_define
define|#
directive|define
name|set_g_function
parameter_list|(
name|func
parameter_list|)
value|out2(graph_addr, g_function, func)
end_define

begin_define
define|#
directive|define
name|g_read_plane
value|4
end_define

begin_define
define|#
directive|define
name|set_g_read_plane
parameter_list|(
name|plane
parameter_list|)
value|out2(graph_addr, g_read_plane, plane)
end_define

begin_define
define|#
directive|define
name|gf_WRITE
value|0
end_define

begin_define
define|#
directive|define
name|gf_AND
value|8
end_define

begin_define
define|#
directive|define
name|gf_OR
value|0x10
end_define

begin_define
define|#
directive|define
name|gf_XOR
value|0x18
end_define

begin_define
define|#
directive|define
name|g_mode
value|5
end_define

begin_define
define|#
directive|define
name|set_g_mode
parameter_list|(
name|mode
parameter_list|)
value|out2(graph_addr, g_mode, mode)
end_define

begin_define
define|#
directive|define
name|gm_DATA
value|0
end_define

begin_define
define|#
directive|define
name|gm_FILL
value|2
end_define

begin_define
define|#
directive|define
name|g_mask
value|8
end_define

begin_define
define|#
directive|define
name|set_g_mask
parameter_list|(
name|mask
parameter_list|)
value|out2(graph_addr, g_mask, mask)
end_define

begin_define
define|#
directive|define
name|regen
value|0xa000
end_define

begin_comment
comment|/* Clean up after writing */
end_comment

begin_define
define|#
directive|define
name|dot_end
parameter_list|()
define|\
value|set_g_mask(0xff)
end_define

begin_comment
comment|/* all bits on */
end_comment

begin_comment
comment|/* Initialize the EGA for graphics mode */
end_comment

begin_function
name|int
name|ega_open
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|ega_save_mode
operator|<
literal|0
condition|)
name|ega_save_mode
operator|=
name|ega_get_mode
argument_list|()
expr_stmt|;
name|ega_set_mode
argument_list|(
name|fb_dev
operator|->
name|video_mode
argument_list|)
expr_stmt|;
name|set_s_map
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* enable all maps */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write a dot using the EGA color codes. */
end_comment

begin_comment
comment|/* This doesn't have to be efficient. */
end_comment

begin_function
name|int
name|ega_write_dot
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|byte
name|data
init|=
operator|(
name|byte
operator|)
name|color
decl_stmt|;
return|return
name|ega_copy_color
argument_list|(
name|dev
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Macro for testing bit-inclusion */
end_comment

begin_define
define|#
directive|define
name|bit_included_in
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|!((x)&~(y))
end_define

begin_comment
comment|/* Copy a monochrome bitmap.  The colors are given explicitly. */
end_comment

begin_comment
comment|/* Color = gx_no_color_index means transparent (no effect on the image). */
end_comment

begin_function
name|int
name|ega_copy_mono
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|izero
parameter_list|,
name|gx_color_index
name|ione
parameter_list|)
block|{
name|rop_params
name|params
decl_stmt|;
define|#
directive|define
name|czero
value|(int)izero
define|#
directive|define
name|cone
value|(int)ione
name|int
name|dleft
decl_stmt|,
name|count
decl_stmt|;
name|byte
name|mask
decl_stmt|,
name|rmask
decl_stmt|;
name|fb_ptr
name|save_dest
decl_stmt|;
name|int
name|other_color
init|=
operator|-
literal|1
decl_stmt|;
name|validate_rect
argument_list|()
expr_stmt|;
while|while
condition|(
name|h
operator|>
name|fb_dev
operator|->
name|max_rop_height
condition|)
block|{
name|unsigned
name|mrh
init|=
name|fb_dev
operator|->
name|max_rop_height
decl_stmt|;
name|int
name|code
init|=
name|ega_copy_mono
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|sourcex
argument_list|,
name|raster
argument_list|,
name|id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|mrh
argument_list|,
name|izero
argument_list|,
name|ione
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
return|return
name|code
return|;
name|base
operator|=
operator|(
name|byte
operator|*
operator|)
operator|(
operator|(
name|byte
name|huge
operator|*
operator|)
name|base
operator|+
name|raster
operator|*
operator|(
name|long
operator|)
name|mrh
operator|)
expr_stmt|;
name|id
operator|=
name|gx_no_bitmap_id
expr_stmt|;
name|y
operator|+=
name|mrh
expr_stmt|;
name|h
operator|-=
name|mrh
expr_stmt|;
block|}
name|params
operator|.
name|dest
operator|=
name|mk_fb_ptr
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|params
operator|.
name|draster
operator|=
name|fb_dev
operator|->
name|raster
expr_stmt|;
name|params
operator|.
name|src
operator|=
name|base
operator|+
operator|(
name|sourcex
operator|>>
literal|3
operator|)
expr_stmt|;
name|params
operator|.
name|sraster
operator|=
name|raster
expr_stmt|;
name|params
operator|.
name|height
operator|=
name|h
expr_stmt|;
name|params
operator|.
name|shift
operator|=
operator|(
name|x
operator|-
name|sourcex
operator|)
operator|&
literal|7
expr_stmt|;
comment|/* Analyze the 16 possible cases: each of izero and ione may be */
comment|/* 0, 0xf, transparent, or some other color. */
switch|switch
condition|(
name|czero
condition|)
block|{
case|case
name|no_color
case|:
switch|switch
condition|(
name|cone
condition|)
block|{
default|default:
comment|/* (T, other) */
comment|/* Must do 2 passes */
name|other_color
operator|=
name|cone
expr_stmt|;
name|save_dest
operator|=
name|params
operator|.
name|dest
expr_stmt|;
comment|/* falls through */
case|case
literal|0
case|:
comment|/* (T, 0) */
name|set_g_function
argument_list|(
name|gf_AND
argument_list|)
expr_stmt|;
name|params
operator|.
name|invert
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/* (T, 0xf) */
name|set_g_function
argument_list|(
name|gf_OR
argument_list|)
expr_stmt|;
name|params
operator|.
name|invert
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|no_color
case|:
comment|/* (T, T) */
return|return
literal|0
return|;
comment|/* nothing to do */
block|}
break|break;
case|case
literal|0
case|:
name|params
operator|.
name|invert
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cone
condition|)
block|{
default|default:
comment|/* (0, other) */
name|set_g_const
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set_g_const_map
argument_list|(
name|cone
operator|^
literal|0xf
argument_list|)
expr_stmt|;
comment|/* falls through */
case|case
literal|0xf
case|:
comment|/* (0, 0xf) */
break|break;
case|case
name|no_color
case|:
comment|/* (0, T) */
name|set_g_function
argument_list|(
name|gf_AND
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0xf
case|:
name|params
operator|.
name|invert
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|cone
condition|)
block|{
case|case
literal|0
case|:
comment|/* (0xf, 0) */
break|break;
default|default:
comment|/* (0xf, other) */
name|set_g_const
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
name|set_g_const_map
argument_list|(
name|cone
argument_list|)
expr_stmt|;
break|break;
case|case
name|no_color
case|:
comment|/* (0xf, T) */
name|set_g_function
argument_list|(
name|gf_OR
argument_list|)
expr_stmt|;
comment|/* falls through */
block|}
break|break;
default|default:
switch|switch
condition|(
name|cone
condition|)
block|{
default|default:
comment|/* (other, not T) */
if|if
condition|(
name|bit_included_in
argument_list|(
name|czero
argument_list|,
name|cone
argument_list|)
condition|)
block|{
name|set_g_const
argument_list|(
name|czero
argument_list|)
expr_stmt|;
name|set_g_const_map
argument_list|(
name|czero
operator|^
name|cone
operator|^
literal|0xf
argument_list|)
expr_stmt|;
name|params
operator|.
name|invert
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|bit_included_in
argument_list|(
name|cone
argument_list|,
name|czero
argument_list|)
condition|)
block|{
name|set_g_const
argument_list|(
name|cone
argument_list|)
expr_stmt|;
name|set_g_const_map
argument_list|(
name|cone
operator|^
name|czero
operator|^
literal|0xf
argument_list|)
expr_stmt|;
name|params
operator|.
name|invert
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* No way around it, fill with one color first. */
name|save_dest
operator|=
name|params
operator|.
name|dest
expr_stmt|;
name|fill_rectangle
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|,
name|x
operator|&
literal|7
argument_list|,
name|w
argument_list|,
name|cone
argument_list|)
expr_stmt|;
name|params
operator|.
name|dest
operator|=
name|save_dest
expr_stmt|;
name|set_g_function
argument_list|(
name|gf_XOR
argument_list|)
expr_stmt|;
name|set_s_map
argument_list|(
name|czero
operator|^
name|cone
argument_list|)
expr_stmt|;
name|other_color
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* must reset s_map at end */
name|params
operator|.
name|invert
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|no_color
case|:
comment|/* (other, T) */
comment|/* Must do 2 passes */
name|other_color
operator|=
name|czero
expr_stmt|;
name|save_dest
operator|=
name|params
operator|.
name|dest
expr_stmt|;
name|set_g_function
argument_list|(
name|gf_AND
argument_list|)
expr_stmt|;
name|params
operator|.
name|invert
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
block|}
comment|/* Actually copy the bits. */
name|dleft
operator|=
literal|8
operator|-
operator|(
name|x
operator|&
literal|7
operator|)
expr_stmt|;
name|mask
operator|=
literal|0xff
operator|>>
operator|(
literal|8
operator|-
name|dleft
operator|)
expr_stmt|;
name|count
operator|=
name|w
operator|-
name|dleft
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|mask
operator|-=
name|mask
operator|>>
name|w
operator|,
name|rmask
operator|=
literal|0
expr_stmt|;
else|else
name|rmask
operator|=
literal|0xff00
operator|>>
operator|(
name|count
operator|&
literal|7
operator|)
expr_stmt|;
comment|/* params: dest, src, sraster, height, shift, invert */
comment|/* Smashes params.src, params.dest, count. */
name|copy
label|:
name|set_g_mask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|shift
operator|==
literal|0
condition|)
comment|/* optimize the aligned case */
block|{
comment|/* Do left column */
name|memrwcol0
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
comment|/* Do center */
if|if
condition|(
operator|(
name|count
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|)
block|{
name|set_g_mask
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
do|do
block|{
name|params
operator|.
name|src
operator|++
operator|,
name|params
operator|.
name|dest
operator|++
expr_stmt|;
name|memrwcol0
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|count
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|)
do|;
block|}
comment|/* Do right column */
if|if
condition|(
name|rmask
condition|)
block|{
name|params
operator|.
name|src
operator|++
operator|,
name|params
operator|.
name|dest
operator|++
expr_stmt|;
name|set_g_mask
argument_list|(
name|rmask
argument_list|)
expr_stmt|;
name|memrwcol0
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Do left column */
name|int
name|sleft
init|=
literal|8
operator|-
operator|(
name|sourcex
operator|&
literal|7
operator|)
decl_stmt|;
if|if
condition|(
name|sleft
operator|>=
name|dleft
condition|)
block|{
comment|/* Source fits in one byte */
name|memrwcol
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|<=
name|sleft
condition|)
block|{
comment|/* Source fits in one byte, thin case */
name|memrwcol
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
goto|goto
name|fin
goto|;
block|}
else|else
block|{
name|memrwcol2
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
name|params
operator|.
name|src
operator|++
expr_stmt|;
block|}
comment|/* Do center */
if|if
condition|(
operator|(
name|count
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|)
block|{
name|set_g_mask
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
do|do
block|{
name|params
operator|.
name|dest
operator|++
expr_stmt|;
name|memrwcol2
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
name|params
operator|.
name|src
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|count
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|)
do|;
block|}
comment|/* Do right column */
if|if
condition|(
name|rmask
condition|)
block|{
name|set_g_mask
argument_list|(
name|rmask
argument_list|)
expr_stmt|;
name|params
operator|.
name|dest
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|+
literal|8
operator|<=
name|params
operator|.
name|shift
condition|)
name|memrwcol
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
else|else
name|memrwcol2
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
block|}
name|fin
label|:
if|if
condition|(
name|other_color
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|other_color
operator|>=
literal|0
condition|)
block|{
comment|/* Do the second pass on (T, other) or (other, T). */
name|count
operator|=
name|w
operator|-
name|dleft
expr_stmt|;
name|params
operator|.
name|src
operator|=
name|base
operator|+
operator|(
name|sourcex
operator|>>
literal|3
operator|)
expr_stmt|;
name|params
operator|.
name|dest
operator|=
name|save_dest
expr_stmt|;
name|params
operator|.
name|invert
operator|^=
operator|-
literal|1
expr_stmt|;
name|set_s_map
argument_list|(
name|other_color
argument_list|)
expr_stmt|;
name|set_g_function
argument_list|(
name|gf_OR
argument_list|)
expr_stmt|;
name|other_color
operator|=
operator|-
literal|2
expr_stmt|;
goto|goto
name|copy
goto|;
block|}
else|else
block|{
comment|/* Finished second pass, restore s_map */
name|set_s_map
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|set_g_function
argument_list|(
name|gf_WRITE
argument_list|)
expr_stmt|;
name|set_g_const_map
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dot_end
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|czero
undef|#
directive|undef
name|cone
block|}
end_function

begin_comment
comment|/* Copy a color pixelmap.  This is just like a bitmap, */
end_comment

begin_comment
comment|/* except that each pixel takes 4 bits instead of 1. */
end_comment

begin_function
name|int
name|ega_copy_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|byte
modifier|*
name|line
init|=
name|base
operator|+
operator|(
name|sourcex
operator|>>
literal|1
operator|)
decl_stmt|;
name|unsigned
name|lmask
init|=
literal|0x80
operator|>>
operator|(
name|x
operator|&
literal|7
operator|)
decl_stmt|;
name|int
name|bitx
init|=
name|sourcex
operator|&
literal|1
decl_stmt|;
name|int
name|ex
init|=
name|w
operator|+
name|bitx
decl_stmt|;
name|fb_ptr
name|fbline
decl_stmt|;
name|validate_rect
argument_list|()
expr_stmt|;
while|while
condition|(
name|h
operator|>
name|fb_dev
operator|->
name|max_rop_height
condition|)
block|{
name|unsigned
name|mrh
init|=
name|fb_dev
operator|->
name|max_rop_height
decl_stmt|;
name|int
name|code
init|=
name|ega_copy_color
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|sourcex
argument_list|,
name|raster
argument_list|,
name|id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|mrh
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
return|return
name|code
return|;
name|base
operator|=
operator|(
name|byte
operator|*
operator|)
operator|(
operator|(
name|byte
name|huge
operator|*
operator|)
name|base
operator|+
name|raster
operator|*
operator|(
name|long
operator|)
name|mrh
operator|)
expr_stmt|;
name|id
operator|=
name|gx_no_bitmap_id
expr_stmt|;
name|y
operator|+=
name|mrh
expr_stmt|;
name|h
operator|-=
name|mrh
expr_stmt|;
block|}
name|fbline
operator|=
name|mk_fb_ptr
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|set_g_mode
argument_list|(
name|gm_FILL
argument_list|)
expr_stmt|;
name|outportb
argument_list|(
name|graph_addr
argument_list|,
name|g_mask
argument_list|)
expr_stmt|;
comment|/* first half of set_g_mask */
while|while
condition|(
operator|--
name|h
operator|>=
literal|0
condition|)
block|{
name|byte
modifier|*
name|bptr
init|=
name|line
decl_stmt|;
name|int
name|px
init|=
name|bitx
decl_stmt|;
comment|/* Turbo C will put an unsigned in a register, */
comment|/* but not a byte! */
specifier|register
name|unsigned
name|mask
init|=
name|lmask
decl_stmt|;
name|fb_ptr
name|fbptr
init|=
name|fbline
decl_stmt|;
do|do
block|{
name|byte_discard
argument_list|(
operator|*
name|fbptr
argument_list|)
expr_stmt|;
comment|/* latch frame buffer data */
name|outportb
argument_list|(
name|graph_addr
operator|+
literal|1
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* 2nd half of set_g_mask */
operator|*
name|fbptr
operator|=
operator|(
name|px
operator|&
literal|1
condition|?
operator|*
name|bptr
operator|++
operator|&
literal|0xf
else|:
operator|*
name|bptr
operator|>>
literal|4
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|>>=
literal|1
operator|)
operator|==
literal|0
condition|)
name|mask
operator|=
literal|0x80
operator|,
name|fbptr
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|px
operator|<
name|ex
condition|)
do|;
name|line
operator|+=
name|raster
expr_stmt|;
name|fbline
operator|+=
name|fb_dev
operator|->
name|raster
expr_stmt|;
block|}
name|set_g_mode
argument_list|(
name|gm_DATA
argument_list|)
expr_stmt|;
name|dot_end
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fill a rectangle. */
end_comment

begin_function
name|int
name|ega_fill_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|rop_params
name|params
decl_stmt|;
name|validate_rect
argument_list|()
expr_stmt|;
while|while
condition|(
name|h
operator|>
name|fb_dev
operator|->
name|max_rop_height
condition|)
block|{
name|unsigned
name|mrh
init|=
name|fb_dev
operator|->
name|max_rop_height
decl_stmt|;
name|int
name|code
init|=
name|ega_fill_rectangle
argument_list|(
name|dev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|mrh
argument_list|,
name|color
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
return|return
name|code
return|;
name|y
operator|+=
name|mrh
expr_stmt|;
name|h
operator|-=
name|mrh
expr_stmt|;
block|}
name|params
operator|.
name|dest
operator|=
name|mk_fb_ptr
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|1
condition|)
block|{
name|set_g_const
argument_list|(
operator|(
name|int
operator|)
name|color
argument_list|)
expr_stmt|;
name|fill_row
argument_list|(
name|params
operator|.
name|dest
argument_list|,
name|x
operator|&
literal|7
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|params
operator|.
name|draster
operator|=
name|fb_dev
operator|->
name|raster
expr_stmt|;
name|params
operator|.
name|height
operator|=
name|h
expr_stmt|;
name|fill_rectangle
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|,
name|x
operator|&
literal|7
argument_list|,
name|w
argument_list|,
operator|(
name|int
operator|)
name|color
argument_list|)
expr_stmt|;
block|}
name|dot_end
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Tile a rectangle.  Note that the two colors must both be supplied, */
end_comment

begin_comment
comment|/* i.e. neither one can be gx_no_color_index (transparent): */
end_comment

begin_comment
comment|/* a transparent color means that the tile is colored, not a mask. */
end_comment

begin_function
name|int
name|ega_tile_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_bitmap
modifier|*
name|tile
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|czero
parameter_list|,
name|gx_color_index
name|cone
parameter_list|,
name|int
name|px
parameter_list|,
name|int
name|py
parameter_list|)
define|#
directive|define
name|zero
value|(int)czero
define|#
directive|define
name|one
value|(int)cone
block|{
name|rop_params
name|params
decl_stmt|;
name|int
name|xmod
decl_stmt|,
name|width_bytes
decl_stmt|;
name|int
name|tile_height
init|=
name|tile
operator|->
name|size
operator|.
name|y
decl_stmt|;
name|int
name|xbit
decl_stmt|;
name|int
name|lcount
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|rmask
decl_stmt|;
name|byte
name|narrow
decl_stmt|;
name|byte
name|again
decl_stmt|;
name|int
name|const_bits
decl_stmt|,
name|maps
decl_stmt|;
name|int
name|ymod
decl_stmt|,
name|yleft
decl_stmt|;
while|while
condition|(
name|h
operator|>
name|fb_dev
operator|->
name|max_rop_height
condition|)
block|{
name|int
name|mod_height
init|=
name|fb_dev
operator|->
name|max_rop_height
operator|/
name|tile_height
operator|*
name|tile_height
decl_stmt|;
name|int
name|code
init|=
name|ega_tile_rectangle
argument_list|(
name|dev
argument_list|,
name|tile
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|mod_height
argument_list|,
name|czero
argument_list|,
name|cone
argument_list|,
name|px
argument_list|,
name|py
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
return|return
name|code
return|;
name|y
operator|+=
name|mod_height
expr_stmt|;
name|h
operator|-=
name|mod_height
expr_stmt|;
block|}
comment|/* We only handle the easiest cases directly. */
if|if
condition|(
operator|(
name|tile
operator|->
name|size
operator|.
name|x
operator|&
literal|7
operator|)
operator|||
name|one
operator|==
operator|-
literal|1
operator|||
name|zero
operator|==
operator|-
literal|1
operator|||
name|px
operator|||
name|py
condition|)
return|return
name|gx_default_tile_rectangle
argument_list|(
name|dev
argument_list|,
name|tile
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|czero
argument_list|,
name|cone
argument_list|,
name|px
argument_list|,
name|py
argument_list|)
return|;
comment|/* Following is similar to aligned case of copy_mono */
name|validate_rect
argument_list|()
expr_stmt|;
name|params
operator|.
name|dest
operator|=
name|mk_fb_ptr
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|params
operator|.
name|draster
operator|=
name|fb_dev
operator|->
name|raster
expr_stmt|;
name|params
operator|.
name|sraster
operator|=
name|tile
operator|->
name|raster
expr_stmt|;
name|params
operator|.
name|shift
operator|=
literal|0
expr_stmt|;
name|xbit
operator|=
name|x
operator|&
literal|7
expr_stmt|;
comment|/* Set up the graphics registers */
name|const_bits
operator|=
operator|(
name|zero
operator|^
name|one
operator|)
operator|^
literal|0xf
expr_stmt|;
if|if
condition|(
name|const_bits
condition|)
block|{
name|set_g_const
argument_list|(
name|zero
argument_list|)
expr_stmt|;
comment|/* either color will do */
name|set_g_const_map
argument_list|(
name|const_bits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|maps
operator|=
name|zero
operator|&
operator|~
name|one
operator|)
operator|!=
literal|0
condition|)
block|{
name|set_s_map
argument_list|(
name|maps
operator|+=
name|const_bits
argument_list|)
expr_stmt|;
name|params
operator|.
name|invert
operator|=
operator|-
literal|1
expr_stmt|;
name|again
operator|=
name|one
operator|&
operator|~
name|zero
expr_stmt|;
block|}
else|else
block|{
name|maps
operator|=
name|one
operator|&
operator|~
name|zero
expr_stmt|;
name|set_s_map
argument_list|(
name|maps
operator|+=
name|const_bits
argument_list|)
expr_stmt|;
name|params
operator|.
name|invert
operator|=
literal|0
expr_stmt|;
name|again
operator|=
literal|0
expr_stmt|;
block|}
name|xmod
operator|=
operator|(
name|x
operator|%
name|tile
operator|->
name|size
operator|.
name|x
operator|)
operator|>>
literal|3
expr_stmt|;
name|width_bytes
operator|=
name|tile
operator|->
name|size
operator|.
name|x
operator|>>
literal|3
expr_stmt|;
name|mask
operator|=
literal|0xff
operator|>>
name|xbit
expr_stmt|;
if|if
condition|(
name|w
operator|+
name|xbit
operator|<=
literal|8
condition|)
name|mask
operator|-=
name|mask
operator|>>
name|w
operator|,
name|rmask
operator|=
literal|0
operator|,
name|narrow
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|rmask
operator|=
operator|(
literal|0xff00
operator|>>
operator|(
operator|(
name|w
operator|+
name|x
operator|)
operator|&
literal|7
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|xbit
condition|)
name|w
operator|+=
name|xbit
operator|-
literal|8
expr_stmt|;
else|else
name|mask
operator|=
literal|0
operator|,
operator|--
name|xmod
operator|,
operator|--
name|params
operator|.
name|dest
expr_stmt|;
name|narrow
operator|=
literal|0
expr_stmt|;
block|}
name|ymod
operator|=
name|y
operator|%
name|tile_height
expr_stmt|;
name|tile
label|:
name|yleft
operator|=
name|tile_height
operator|-
name|ymod
expr_stmt|;
name|params
operator|.
name|src
operator|=
name|tile
operator|->
name|data
operator|+
name|ymod
operator|*
name|params
operator|.
name|sraster
operator|+
name|xmod
expr_stmt|;
name|lcount
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|narrow
condition|)
comment|/* Optimize narrow case */
block|{
name|set_g_mask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcount
operator|>
name|yleft
condition|)
block|{
name|params
operator|.
name|height
operator|=
name|yleft
expr_stmt|;
name|memrwcol0
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
name|params
operator|.
name|dest
operator|+=
name|yleft
operator|*
name|params
operator|.
name|draster
expr_stmt|;
name|params
operator|.
name|src
operator|=
name|tile
operator|->
name|data
operator|+
name|xmod
expr_stmt|;
name|params
operator|.
name|height
operator|=
name|tile_height
expr_stmt|;
name|lcount
operator|-=
name|yleft
expr_stmt|;
while|while
condition|(
name|lcount
operator|>=
name|tile_height
condition|)
block|{
name|memrwcol0
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
name|params
operator|.
name|dest
operator|+=
name|tile_height
operator|*
name|params
operator|.
name|draster
expr_stmt|;
name|lcount
operator|-=
name|tile_height
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lcount
condition|)
block|{
name|params
operator|.
name|height
operator|=
name|lcount
expr_stmt|;
name|memrwcol0
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fb_ptr
name|line
init|=
name|params
operator|.
name|dest
decl_stmt|;
name|int
name|xpos
init|=
name|width_bytes
operator|-
name|xmod
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|xleft
init|=
name|xpos
decl_stmt|;
name|int
name|count
init|=
name|w
decl_stmt|;
name|params
operator|.
name|height
operator|=
operator|(
name|lcount
operator|>
name|yleft
condition|?
name|yleft
else|:
name|lcount
operator|)
expr_stmt|;
comment|/* Do first byte, if not a full byte. */
if|if
condition|(
name|mask
condition|)
block|{
name|set_g_mask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|memrwcol0
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
comment|/* Do full bytes */
if|if
condition|(
operator|(
name|count
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|)
block|{
name|set_g_mask
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|--
name|xleft
condition|)
name|xleft
operator|=
name|width_bytes
operator|,
name|params
operator|.
name|src
operator|-=
name|width_bytes
expr_stmt|;
operator|++
name|params
operator|.
name|src
operator|,
operator|++
name|params
operator|.
name|dest
expr_stmt|;
name|memrwcol0
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|count
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|)
do|;
block|}
comment|/* Do last byte */
if|if
condition|(
name|rmask
condition|)
block|{
if|if
condition|(
operator|!
operator|--
name|xleft
condition|)
name|xleft
operator|=
name|width_bytes
operator|,
name|params
operator|.
name|src
operator|-=
name|width_bytes
expr_stmt|;
name|set_g_mask
argument_list|(
name|rmask
argument_list|)
expr_stmt|;
operator|++
name|params
operator|.
name|src
operator|,
operator|++
name|params
operator|.
name|dest
expr_stmt|;
name|memrwcol0
argument_list|(
operator|(
name|rop_ptr
operator|)
operator|&
name|params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lcount
operator|-=
name|params
operator|.
name|height
operator|)
operator|==
literal|0
condition|)
break|break;
name|params
operator|.
name|dest
operator|=
name|line
operator|+=
name|params
operator|.
name|height
operator|*
name|params
operator|.
name|draster
expr_stmt|;
name|params
operator|.
name|src
operator|=
name|tile
operator|->
name|data
operator|+
name|xmod
expr_stmt|;
name|yleft
operator|=
name|tile_height
expr_stmt|;
block|}
block|}
comment|/* Now do the second color if needed */
if|if
condition|(
name|again
condition|)
block|{
name|maps
operator|=
name|again
operator|+
name|const_bits
expr_stmt|;
name|set_s_map
argument_list|(
name|maps
argument_list|)
expr_stmt|;
name|again
operator|=
literal|0
expr_stmt|;
name|params
operator|.
name|dest
operator|=
name|mk_fb_ptr
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|params
operator|.
name|dest
operator|--
expr_stmt|;
name|params
operator|.
name|invert
operator|=
literal|0
expr_stmt|;
goto|goto
name|tile
goto|;
block|}
if|if
condition|(
name|maps
operator|!=
literal|0xf
condition|)
name|set_s_map
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_bits
condition|)
name|set_g_const_map
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dot_end
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read scan lines back from the frame buffer. */
end_comment

begin_function
name|int
name|ega_get_bits
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|y
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|size
parameter_list|,
name|int
name|pad_to_word
parameter_list|)
block|{
comment|/* We don't have to worry about padding, because we read back */
comment|/* 4 bits per pixel and the frame buffer width is always */
comment|/* a multiple of 8 pixels. */
name|uint
name|bytes_per_row
init|=
name|dev
operator|->
name|width
operator|>>
literal|1
decl_stmt|;
name|uint
name|count
init|=
name|min
argument_list|(
name|dev
operator|->
name|height
operator|-
name|y
argument_list|,
name|size
operator|/
name|bytes_per_row
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|plane
decl_stmt|;
name|byte
modifier|*
name|drow
init|=
name|data
decl_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|count
init|;
name|j
operator|--
condition|;
name|drow
operator|+=
name|bytes_per_row
operator|,
name|y
operator|++
control|)
for|for
control|(
name|plane
operator|=
literal|0
init|;
name|plane
operator|<
literal|4
condition|;
name|plane
operator|++
control|)
block|{
name|fb_ptr
name|src
init|=
name|mk_fb_ptr
argument_list|(
literal|0
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|ushort
modifier|*
name|dest
init|=
operator|(
name|ushort
operator|*
operator|)
name|drow
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Plane 0 is the least significant plane. */
comment|/* We know we're on a little-endian machine.... */
specifier|static
name|ushort
name|spread4
index|[
literal|16
index|]
init|=
block|{
literal|0x0
block|,
literal|0x800
block|,
literal|0x8000
block|,
literal|0x8800
block|,
literal|0x8
block|,
literal|0x808
block|,
literal|0x8008
block|,
literal|0x8808
block|,
literal|0x80
block|,
literal|0x880
block|,
literal|0x8080
block|,
literal|0x8880
block|,
literal|0x88
block|,
literal|0x888
block|,
literal|0x8088
block|,
literal|0x8888
block|}
decl_stmt|;
name|set_g_read_plane
argument_list|(
name|plane
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|width
condition|;
name|i
operator|+=
literal|8
operator|,
name|src
operator|++
operator|,
name|dest
operator|+=
literal|2
control|)
block|{
name|byte
name|b
init|=
operator|*
name|src
decl_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
operator|(
name|dest
index|[
literal|0
index|]
operator|>>
literal|1
operator|)
operator|+
name|spread4
index|[
name|b
operator|>>
literal|4
index|]
expr_stmt|;
name|dest
index|[
literal|1
index|]
operator|=
operator|(
name|dest
index|[
literal|1
index|]
operator|>>
literal|1
operator|)
operator|+
name|spread4
index|[
name|b
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Mask table for rectangle fill. */
end_comment

begin_decl_stmt
specifier|static
name|byte
name|rmask_tab
index|[
literal|9
index|]
init|=
block|{
literal|0x00
block|,
literal|0x80
block|,
literal|0xc0
block|,
literal|0xe0
block|,
literal|0xf0
block|,
literal|0xf8
block|,
literal|0xfc
block|,
literal|0xfe
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fill a rectangle specified by pointer into frame buffer, */
end_comment

begin_comment
comment|/* starting bit within byte, width, and height. */
end_comment

begin_comment
comment|/* Smashes rop->dest. */
end_comment

begin_function
name|private
name|void
name|fill_rectangle
parameter_list|(
specifier|register
name|rop_ptr
name|rop
parameter_list|,
name|int
name|bit
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|color
parameter_list|)
comment|/* rop: dest, draster, height */
block|{
name|set_g_const
argument_list|(
name|color
argument_list|)
expr_stmt|;
name|set_g_const_map
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|+
name|w
operator|<=
literal|8
condition|)
block|{
comment|/* Less than one byte */
name|set_g_mask
argument_list|(
name|rmask_tab
index|[
name|w
index|]
operator|>>
name|bit
argument_list|)
expr_stmt|;
name|memsetcol
argument_list|(
name|rop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
name|right_mask
decl_stmt|;
if|if
condition|(
name|bit
condition|)
block|{
name|set_g_mask
argument_list|(
literal|0xff
operator|>>
name|bit
argument_list|)
expr_stmt|;
name|memsetcol
argument_list|(
name|rop
argument_list|)
expr_stmt|;
name|rop
operator|->
name|dest
operator|++
expr_stmt|;
name|w
operator|+=
name|bit
operator|-
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|>=
literal|8
condition|)
block|{
name|set_g_mask
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
comment|/* all bits */
name|rop
operator|->
name|width
operator|=
name|w
operator|>>
literal|3
expr_stmt|;
name|memsetrect
argument_list|(
name|rop
argument_list|)
expr_stmt|;
name|rop
operator|->
name|dest
operator|+=
name|rop
operator|->
name|width
expr_stmt|;
name|w
operator|&=
literal|7
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|right_mask
operator|=
name|rmask_tab
index|[
name|w
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|set_g_mask
argument_list|(
name|right_mask
argument_list|)
expr_stmt|;
name|memsetcol
argument_list|(
name|rop
argument_list|)
expr_stmt|;
block|}
block|}
name|set_g_const_map
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill a single row specified by pointer into frame buffer, */
end_comment

begin_comment
comment|/* starting bit within byte, and width. */
end_comment

begin_comment
comment|/* Caller has already set g_const. */
end_comment

begin_define
define|#
directive|define
name|r_m_w
parameter_list|(
name|ptr
parameter_list|)
value|(*(ptr))++
end_define

begin_comment
comment|/* read& write, data irrelevant */
end_comment

begin_function
name|private
name|void
name|fill_row
parameter_list|(
name|byte
name|far
modifier|*
name|dest
parameter_list|,
name|int
name|bit
parameter_list|,
name|int
name|w
parameter_list|)
comment|/* rop: dest */
block|{
name|set_g_const_map
argument_list|(
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|+
name|w
operator|<=
literal|8
condition|)
block|{
comment|/* Less than one byte */
name|set_g_mask
argument_list|(
name|rmask_tab
index|[
name|w
index|]
operator|>>
name|bit
argument_list|)
expr_stmt|;
name|r_m_w
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
name|right_mask
decl_stmt|;
if|if
condition|(
name|bit
condition|)
block|{
name|set_g_mask
argument_list|(
literal|0xff
operator|>>
name|bit
argument_list|)
expr_stmt|;
name|r_m_w
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|dest
operator|++
expr_stmt|;
name|w
operator|+=
name|bit
operator|-
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|>=
literal|8
condition|)
block|{
name|int
name|byte_count
init|=
name|w
operator|>>
literal|3
decl_stmt|;
name|set_g_mask
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
comment|/* all bits */
name|memset
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|byte_count
argument_list|)
expr_stmt|;
comment|/* data irrelevant */
name|dest
operator|+=
name|byte_count
expr_stmt|;
name|w
operator|&=
literal|7
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|right_mask
operator|=
name|rmask_tab
index|[
name|w
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|set_g_mask
argument_list|(
name|right_mask
argument_list|)
expr_stmt|;
name|r_m_w
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
name|set_g_const_map
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

