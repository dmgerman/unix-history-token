begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zbseq.c */
end_comment

begin_comment
comment|/* Level 2 binary object sequence operators */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"save.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"bnum.h"
end_include

begin_include
include|#
directive|include
file|"btoken.h"
end_include

begin_include
include|#
directive|include
file|"bseq.h"
end_include

begin_comment
comment|/* Current binary format (in iscan.c) */
end_comment

begin_decl_stmt
specifier|extern
name|ref
name|binary_object_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* System and user name arrays. */
end_comment

begin_decl_stmt
name|ref
name|system_names
decl_stmt|,
name|user_names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Import the binary token scanner. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|scan_binary_token
argument_list|(
name|P3
argument_list|(
name|stream
operator|*
argument_list|,
name|ref
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern int (*scan_btoken_proc
end_extern

begin_expr_stmt
unit|)
operator|(
name|P3
argument_list|(
name|stream
operator|*
argument_list|,
name|ref
operator|*
argument_list|,
name|int
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|write_bin_object
argument_list|(
name|P2
argument_list|(
name|stream
operator|*
argument_list|,
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the binary object machinery. */
end_comment

begin_function
name|private
name|void
name|zbseq_init
parameter_list|()
block|{
comment|/* Initialize fake system and user name tables. */
comment|/* PostScript code will install the real ones. */
name|make_tasv
argument_list|(
operator|&
name|system_names
argument_list|,
name|t_shortarray
argument_list|,
name|a_read
operator|+
name|a_execute
argument_list|,
literal|0
argument_list|,
name|packed
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|make_tasv
argument_list|(
operator|&
name|user_names
argument_list|,
name|t_array
argument_list|,
name|a_all
argument_list|,
literal|0
argument_list|,
name|refs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|scan_btoken_proc
operator|=
name|scan_binary_token
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .installnames */
end_comment

begin_function
name|int
name|zinstallnames
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_read_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_shortarray
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_array
argument_list|)
expr_stmt|;
name|ref_assign_old
argument_list|(
operator|&
name|system_names
argument_list|,
name|op
operator|-
literal|1
argument_list|,
literal|".installnames"
argument_list|)
expr_stmt|;
name|ref_assign_old
argument_list|(
operator|&
name|user_names
argument_list|,
name|op
argument_list|,
literal|".installnames"
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currentobjectformat */
end_comment

begin_function
name|int
name|zcurrentobjectformat
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|op
operator|=
name|binary_object_format
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* printobject */
end_comment

begin_function
name|int
name|zprintobject
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|write_bin_object
argument_list|(
operator|&
name|std_files
index|[
literal|1
index|]
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* setobjectformat */
end_comment

begin_function
name|int
name|zsetobjectformat
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|intval
operator|<
literal|0
operator|||
name|op
operator|->
name|value
operator|.
name|intval
operator|>
literal|4
condition|)
return|return
name|e_rangecheck
return|;
name|ref_save
argument_list|(
operator|&
name|binary_object_format
argument_list|,
literal|"setobjectformat"
argument_list|)
expr_stmt|;
name|binary_object_format
operator|.
name|value
operator|.
name|intval
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* writeobject */
end_comment

begin_function
name|int
name|zwriteobject
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_write_file
argument_list|(
name|s
argument_list|,
name|op
operator|-
literal|2
argument_list|)
expr_stmt|;
name|code
operator|=
name|write_bin_object
argument_list|(
name|s
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|pop
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zbseq_op_defs
index|[]
init|=
block|{
block|{
literal|"2.installnames"
block|,
name|zinstallnames
block|}
block|,
block|{
literal|"0currentobjectformat"
block|,
name|zcurrentobjectformat
block|}
block|,
block|{
literal|"2printobject"
block|,
name|zprintobject
block|}
block|,
block|{
literal|"1setobjectformat"
block|,
name|zsetobjectformat
block|}
block|,
block|{
literal|"3writeobject"
block|,
name|zwriteobject
block|}
block|,
name|op_def_end
argument_list|(
argument|zbseq_init
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|ulong
name|refs
decl_stmt|,
name|chars
decl_stmt|;
block|}
name|bin_space
typedef|;
end_typedef

begin_comment
comment|/* Compute the size of a binary object sequence */
end_comment

begin_function
name|private
name|int
name|bin_seq_space
parameter_list|(
name|ref
modifier|*
name|op
parameter_list|,
name|int
name|array_ok
parameter_list|,
name|bin_space
modifier|*
name|sp
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_null
case|:
case|case
name|t_integer
case|:
case|case
name|t_real
case|:
case|case
name|t_boolean
case|:
case|case
name|t_mark
case|:
name|sp
operator|->
name|refs
operator|++
expr_stmt|;
break|break;
case|case
name|t_string
case|:
name|sp
operator|->
name|refs
operator|++
expr_stmt|;
name|sp
operator|->
name|chars
operator|+=
name|r_size
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_name
case|:
name|sp
operator|->
name|refs
operator|++
expr_stmt|;
block|{
name|ref
name|nstr
decl_stmt|;
name|name_string_ref
argument_list|(
name|op
argument_list|,
operator|&
name|nstr
argument_list|)
expr_stmt|;
name|sp
operator|->
name|chars
operator|+=
name|r_size
argument_list|(
operator|&
name|nstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|t_array
case|:
if|if
condition|(
operator|!
name|array_ok
condition|)
return|return
name|e_limitcheck
return|;
block|{
name|uint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r_size
argument_list|(
name|op
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|code
init|=
name|bin_seq_space
argument_list|(
name|op
operator|->
name|value
operator|.
name|refs
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|sp
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
block|}
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write the objects part of a binary object sequence. */
end_comment

begin_comment
comment|/* Return the new offset in the string part. */
end_comment

begin_function
name|private
name|uint
name|bin_seq_write_objects
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|,
name|ref
modifier|*
name|op
parameter_list|,
name|byte
name|tag
parameter_list|,
name|uint
name|spos
parameter_list|)
block|{
name|bin_seq_obj
name|ob
decl_stmt|;
name|ref
name|nstr
decl_stmt|;
name|ob
operator|.
name|unused
operator|=
name|tag
expr_stmt|;
define|#
directive|define
name|swap_t
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|t = a, a = b, b = t
if|#
directive|if
name|arch_is_big_endian
define|#
directive|define
name|must_swap
parameter_list|(
name|s
parameter_list|)
value|s_is_lsb(s)
else|#
directive|else
define|#
directive|define
name|must_swap
parameter_list|(
name|s
parameter_list|)
value|s_is_msb(s)
endif|#
directive|endif
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_null
case|:
name|ob
operator|.
name|tx
operator|=
operator|(
name|byte
operator|)
name|bs_null
expr_stmt|;
break|break;
case|case
name|t_mark
case|:
name|ob
operator|.
name|tx
operator|=
operator|(
name|byte
operator|)
name|bs_mark
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
name|ob
operator|.
name|tx
operator|=
operator|(
name|byte
operator|)
name|bs_integer
expr_stmt|;
name|ob
operator|.
name|value
operator|.
name|w
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
name|num
label|:
name|ob
operator|.
name|size
operator|.
name|w
operator|=
literal|0
expr_stmt|;
comment|/* (matters for reals) */
name|swb
label|:
comment|/* swap bytes of value if needed */
if|if
condition|(
name|must_swap
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|byte
name|t
decl_stmt|;
name|swap_t
argument_list|(
name|ob
operator|.
name|value
operator|.
name|b
index|[
literal|0
index|]
argument_list|,
name|ob
operator|.
name|value
operator|.
name|b
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|swap_t
argument_list|(
name|ob
operator|.
name|value
operator|.
name|b
index|[
literal|1
index|]
argument_list|,
name|ob
operator|.
name|value
operator|.
name|b
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|t_real
case|:
name|ob
operator|.
name|tx
operator|=
operator|(
name|byte
operator|)
name|bs_real
expr_stmt|;
name|ob
operator|.
name|value
operator|.
name|f
operator|=
name|op
operator|->
name|value
operator|.
name|realval
expr_stmt|;
comment|/***** handle non-IEEE native *****/
goto|goto
name|num
goto|;
case|case
name|t_boolean
case|:
name|ob
operator|.
name|tx
operator|=
operator|(
name|byte
operator|)
name|bs_boolean
expr_stmt|;
name|ob
operator|.
name|value
operator|.
name|w
operator|=
name|op
operator|->
name|value
operator|.
name|index
expr_stmt|;
goto|goto
name|num
goto|;
case|case
name|t_array
case|:
block|{
name|uint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r_size
argument_list|(
name|op
argument_list|)
condition|;
name|i
operator|++
control|)
name|spos
operator|=
name|bin_seq_write_objects
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|value
operator|.
name|refs
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|spos
argument_list|)
expr_stmt|;
block|}
return|return
name|spos
return|;
case|case
name|t_string
case|:
name|ob
operator|.
name|tx
operator|=
operator|(
name|byte
operator|)
name|bs_string
expr_stmt|;
if|if
condition|(
name|r_has_attr
argument_list|(
name|op
argument_list|,
name|a_executable
argument_list|)
condition|)
name|ob
operator|.
name|tx
operator|+=
operator|(
name|byte
operator|)
name|bs_executable
expr_stmt|;
name|nos
label|:
name|ob
operator|.
name|size
operator|.
name|w
operator|=
name|r_size
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_swap
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|byte
name|t
decl_stmt|;
name|swap_t
argument_list|(
name|ob
operator|.
name|size
operator|.
name|b
index|[
literal|0
index|]
argument_list|,
name|ob
operator|.
name|size
operator|.
name|b
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|ob
operator|.
name|value
operator|.
name|w
operator|=
name|spos
expr_stmt|;
name|spos
operator|+=
name|r_size
argument_list|(
name|op
argument_list|)
expr_stmt|;
goto|goto
name|swb
goto|;
case|case
name|t_name
case|:
name|ob
operator|.
name|tx
operator|=
operator|(
name|byte
operator|)
name|bs_name
expr_stmt|;
name|name_string_ref
argument_list|(
name|op
argument_list|,
operator|&
name|nstr
argument_list|)
expr_stmt|;
name|op
operator|=
operator|&
name|nstr
expr_stmt|;
goto|goto
name|nos
goto|;
block|}
name|sputs
argument_list|(
name|s
argument_list|,
operator|(
name|byte
operator|*
operator|)
operator|&
name|ob
argument_list|,
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|spos
return|;
block|}
end_function

begin_comment
comment|/* Write the string part of a binary object sequence */
end_comment

begin_function
name|private
name|void
name|bin_seq_write_strings
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|,
name|ref
modifier|*
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_array
case|:
block|{
name|uint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r_size
argument_list|(
name|op
argument_list|)
condition|;
name|i
operator|++
control|)
name|bin_seq_write_strings
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|value
operator|.
name|refs
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|t_name
case|:
block|{
name|ref
name|nstr
decl_stmt|;
name|name_string_ref
argument_list|(
name|op
argument_list|,
operator|&
name|nstr
argument_list|)
expr_stmt|;
name|sputs
argument_list|(
name|s
argument_list|,
name|nstr
operator|.
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
operator|&
name|nstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|t_string
case|:
name|sputs
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Top-level routine for writing an object (printobject/writeobject) */
end_comment

begin_function
name|private
name|int
name|write_bin_object
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|bin_format
init|=
operator|(
name|int
operator|)
name|binary_object_format
operator|.
name|value
operator|.
name|intval
operator|-
literal|1
decl_stmt|;
name|bin_space
name|space
decl_stmt|;
name|int
name|code
decl_stmt|;
name|ulong
name|total
decl_stmt|;
name|byte
name|tag
decl_stmt|;
name|os_ptr
name|op1
init|=
name|op
operator|-
literal|1
decl_stmt|;
specifier|static
name|int
name|nfs
index|[
literal|4
index|]
init|=
block|{
name|num_float_IEEE
operator|+
name|num_msb
block|,
name|num_float_IEEE
operator|+
name|num_lsb
block|,
name|num_float_native
operator|+
name|num_msb
block|,
name|num_float_native
operator|+
name|num_lsb
block|}
decl_stmt|;
if|if
condition|(
name|bin_format
operator|<
literal|0
condition|)
return|return
name|e_undefined
return|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|intval
operator|<
literal|0
operator|||
name|op
operator|->
name|value
operator|.
name|intval
operator|>
literal|255
condition|)
return|return
name|e_rangecheck
return|;
name|tag
operator|=
operator|(
name|byte
operator|)
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
name|space
operator|.
name|refs
operator|=
name|space
operator|.
name|chars
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|bin_seq_space
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|,
operator|&
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* Object has been validated, only possible error now is */
comment|/* ioerror (which we don't check for). */
name|total
operator|=
name|space
operator|.
name|refs
operator|*
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
operator|+
name|space
operator|.
name|chars
expr_stmt|;
if|if
condition|(
name|r_has_type
argument_list|(
name|op1
argument_list|,
name|t_array
argument_list|)
condition|)
name|total
operator|+=
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|>
literal|0xffff
operator|-
literal|4
condition|)
return|return
name|e_limitcheck
return|;
name|s
operator|->
name|num_format
operator|=
name|nfs
index|[
name|bin_format
index|]
expr_stmt|;
name|sputc
argument_list|(
name|s
argument_list|,
operator|(
name|byte
operator|)
name|bt_seq
operator|+
name|bin_format
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sputshort
argument_list|(
name|s
argument_list|,
operator|(
name|ushort
operator|)
name|total
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_has_type
argument_list|(
name|op1
argument_list|,
name|t_array
argument_list|)
condition|)
block|{
name|sputc
argument_list|(
name|s
argument_list|,
operator|(
name|byte
operator|)
name|bs_array
operator|+
operator|(
name|r_has_attr
argument_list|(
name|op1
argument_list|,
name|a_executable
argument_list|)
condition|?
operator|(
name|byte
operator|)
name|bs_executable
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|s
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|sputshort
argument_list|(
name|s
argument_list|,
name|r_size
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|sputlong
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|bin_seq_obj
argument_list|)
argument_list|)
expr_stmt|;
name|tag
operator|=
literal|0
expr_stmt|;
block|}
name|bin_seq_write_objects
argument_list|(
name|s
argument_list|,
name|op1
argument_list|,
name|tag
argument_list|,
call|(
name|uint
call|)
argument_list|(
name|total
operator|-
name|space
operator|.
name|chars
argument_list|)
argument_list|)
expr_stmt|;
name|bin_seq_write_strings
argument_list|(
name|s
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

