begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gschar0.c */
end_comment

begin_comment
comment|/* Composite font decoding for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_comment
comment|/* for gzstate.h */
end_comment

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_comment
comment|/* must precede gzdevice */
end_comment

begin_include
include|#
directive|include
file|"gzdevice.h"
end_include

begin_comment
comment|/* must precede gxchar */
end_comment

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_include
include|#
directive|include
file|"gxchar.h"
end_include

begin_include
include|#
directive|include
file|"gxfont.h"
end_include

begin_comment
comment|/* Get the next character and font from a composite string. */
end_comment

begin_comment
comment|/* If we run off the end of the string in the middle of a */
end_comment

begin_comment
comment|/* multi-byte sequence, return gs_error_rangecheck. */
end_comment

begin_comment
comment|/* If the string is empty, return 1.  Otherwise, return 0. */
end_comment

begin_function
name|int
name|gs_type0_next
parameter_list|(
name|gs_show_enum
modifier|*
name|penum
parameter_list|,
name|ulong
modifier|*
name|pchar
parameter_list|)
block|{
name|uint
name|index
init|=
name|penum
operator|->
name|index
decl_stmt|;
name|byte
modifier|*
name|p
init|=
name|penum
operator|->
name|str
operator|+
name|index
decl_stmt|;
name|uint
name|size
init|=
name|penum
operator|->
name|size
decl_stmt|;
name|uint
name|left
decl_stmt|;
name|gs_font
modifier|*
name|pfont
init|=
name|penum
operator|->
name|fstack
index|[
name|penum
operator|->
name|fdepth
index|]
decl_stmt|;
name|gs_type0_data
modifier|*
name|pdata
init|=
operator|&
name|pfont
operator|->
name|data
operator|.
name|type0_data
decl_stmt|;
name|uint
name|fidx
decl_stmt|;
name|int
name|modal_mapping
decl_stmt|;
name|top
label|:
if|if
condition|(
operator|(
name|left
operator|=
name|size
operator|-
name|index
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
define|#
directive|define
name|need_left
parameter_list|(
name|n
parameter_list|)
define|\
value|if ( left< n ) return_error(gs_error_rangecheck)
switch|switch
condition|(
name|pdata
operator|->
name|FMapType
condition|)
block|{
default|default:
comment|/* can't happen */
name|return_error
argument_list|(
name|gs_error_invalidfont
argument_list|)
expr_stmt|;
comment|/* ------ Non-modal mappings ------ */
case|case
literal|2
case|:
comment|/* 8/8 mapping */
name|modal_mapping
operator|=
literal|0
expr_stmt|;
name|need_left
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fidx
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|pchar
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* 1/7 mapping */
name|modal_mapping
operator|=
literal|0
expr_stmt|;
name|fidx
operator|=
operator|*
name|p
operator|>>
literal|7
expr_stmt|;
operator|*
name|pchar
operator|=
operator|*
name|p
operator|++
operator|&
literal|0x7f
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* 9/7 mapping */
name|modal_mapping
operator|=
literal|0
expr_stmt|;
name|need_left
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fidx
operator|=
operator|(
operator|(
name|uint
operator|)
operator|*
name|p
operator|<<
literal|1
operator|)
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|>>
literal|7
operator|)
expr_stmt|;
operator|*
name|pchar
operator|=
name|p
index|[
literal|1
index|]
operator|&
literal|0x7f
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* SubsVector mapping */
name|modal_mapping
operator|=
literal|0
expr_stmt|;
block|{
name|uint
name|subs_count
init|=
name|pdata
operator|->
name|subs_size
decl_stmt|;
name|byte
modifier|*
name|psv
init|=
name|pdata
operator|->
name|SubsVector
decl_stmt|;
name|need_left
argument_list|(
name|pdata
operator|->
name|subs_width
argument_list|)
expr_stmt|;
define|#
directive|define
name|subs_loop
parameter_list|(
name|subs_elt
parameter_list|,
name|width
parameter_list|)
define|\
value|while ( subs_count != 0&& chr>= (schr = subs_elt) )\     subs_count--, chr -= schr, psv += width;\   *pchar = chr; break
switch|switch
condition|(
name|pdata
operator|->
name|subs_width
condition|)
block|{
default|default:
comment|/* can't happen */
name|return_error
argument_list|(
name|gs_error_invalidfont
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
block|{
name|byte
name|chr
init|=
operator|*
name|p
decl_stmt|,
name|schr
decl_stmt|;
name|subs_loop
argument_list|(
operator|*
name|psv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
case|case
literal|2
case|:
define|#
directive|define
name|w2
parameter_list|(
name|p
parameter_list|)
value|(((ushort)*p<< 8) + p[1])
block|{
name|ushort
name|chr
init|=
name|w2
argument_list|(
name|p
argument_list|)
decl_stmt|,
name|schr
decl_stmt|;
name|subs_loop
argument_list|(
name|w2
argument_list|(
name|psv
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|w2
case|case
literal|3
case|:
define|#
directive|define
name|w3
parameter_list|(
name|p
parameter_list|)
value|(((ulong)*p<< 16) + ((uint)p[1]<< 8) + p[2])
block|{
name|ulong
name|chr
init|=
name|w3
argument_list|(
name|p
argument_list|)
decl_stmt|,
name|schr
decl_stmt|;
name|subs_loop
argument_list|(
name|w3
argument_list|(
name|psv
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|w3
case|case
literal|4
case|:
define|#
directive|define
name|w4
parameter_list|(
name|p
parameter_list|)
define|\
value|(((ulong)*p<< 24) + ((ulong)p[1]<< 16) + ((uint)p[1]<< 8) + p[2])
block|{
name|ulong
name|chr
init|=
name|w4
argument_list|(
name|p
argument_list|)
decl_stmt|,
name|schr
decl_stmt|;
name|subs_loop
argument_list|(
name|w4
argument_list|(
name|psv
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|w4
undef|#
directive|undef
name|subs_loop
block|}
name|p
operator|+=
name|pdata
operator|->
name|subs_width
expr_stmt|;
break|break;
block|}
comment|/* ------ Modal mappings ------ */
case|case
literal|3
case|:
comment|/* escape mapping */
name|modal_mapping
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|pdata
operator|->
name|EscChar
condition|)
block|{
name|need_left
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fidx
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
goto|goto
name|remap
goto|;
block|}
goto|goto
name|modal
goto|;
case|case
literal|7
case|:
comment|/* double escape mapping */
name|modal_mapping
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|pdata
operator|->
name|EscChar
condition|)
block|{
name|need_left
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|pdata
operator|->
name|EscChar
condition|)
block|{
name|need_left
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|fidx
operator|=
name|p
index|[
literal|2
index|]
operator|+
literal|256
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
goto|goto
name|remap
goto|;
block|}
name|fidx
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
goto|goto
name|remap
goto|;
block|}
goto|goto
name|modal
goto|;
case|case
literal|8
case|:
comment|/* shift mapping */
name|modal_mapping
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|pdata
operator|->
name|ShiftIn
condition|)
block|{
name|fidx
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
goto|goto
name|remap
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
name|pdata
operator|->
name|ShiftOut
condition|)
block|{
name|fidx
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
goto|goto
name|remap
goto|;
block|}
name|modal
label|:
operator|*
name|pchar
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|penum
operator|->
name|index
operator|=
name|p
operator|-
name|penum
operator|->
name|str
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Control continues here for non-modal mappings, */
comment|/* or for modal mappings after a font change. */
name|remap
label|:
if|if
condition|(
name|fidx
operator|>=
name|pdata
operator|->
name|encoding_size
condition|)
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
name|fidx
operator|=
name|pdata
operator|->
name|Encoding
index|[
name|fidx
index|]
expr_stmt|;
name|penum
operator|->
name|index
operator|=
name|p
operator|-
name|penum
operator|->
name|str
expr_stmt|;
comment|/* We pre-checked the encoding vector, so we know that */
comment|/* fidx is now a legal subscript for FDepVector. */
name|pfont
operator|=
name|pdata
operator|->
name|FDepVector
index|[
name|fidx
index|]
expr_stmt|;
if|if
condition|(
name|modal_mapping
condition|)
block|{
if|if
condition|(
name|penum
operator|->
name|index
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|pfont
operator|->
name|FontType
operator|==
name|ft_composite
condition|)
block|{
name|penum
operator|->
name|fstack
index|[
operator|++
name|penum
operator|->
name|fdepth
index|]
operator|=
name|pfont
expr_stmt|;
goto|goto
name|top
goto|;
block|}
operator|*
name|pchar
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|penum
operator|->
name|index
operator|--
expr_stmt|;
block|}
else|else
block|{
name|penum
operator|->
name|pfont
operator|=
name|pfont
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

