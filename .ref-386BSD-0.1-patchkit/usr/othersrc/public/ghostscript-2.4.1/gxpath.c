begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gxpath.c */
end_comment

begin_comment
comment|/* Private path routines for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_comment
comment|/* These routines all assume that all points are */
end_comment

begin_comment
comment|/* already in device coordinates, and in fixed representation. */
end_comment

begin_comment
comment|/* As usual, they return either 0 or a (negative) error code. */
end_comment

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|subpath
modifier|*
name|path_alloc_copy
argument_list|(
name|P1
argument_list|(
name|gx_path
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|gx_path_new_subpath
argument_list|(
name|P1
argument_list|(
name|gx_path
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|void
name|gx_print_segment
argument_list|(
name|P1
argument_list|(
name|segment
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------ Initialize/free paths ------ */
end_comment

begin_comment
comment|/* Initialize a path */
end_comment

begin_function
name|void
name|gx_path_init
parameter_list|(
specifier|register
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|gs_memory_procs
modifier|*
name|pprocs
parameter_list|)
block|{
name|ppath
operator|->
name|memory_procs
operator|=
operator|*
name|pprocs
expr_stmt|;
name|ppath
operator|->
name|box_last
operator|=
literal|0
expr_stmt|;
name|ppath
operator|->
name|position_valid
operator|=
literal|0
expr_stmt|;
name|ppath
operator|->
name|first_subpath
operator|=
name|ppath
operator|->
name|current_subpath
operator|=
literal|0
expr_stmt|;
name|ppath
operator|->
name|subpath_count
operator|=
literal|0
expr_stmt|;
name|ppath
operator|->
name|curve_count
operator|=
literal|0
expr_stmt|;
name|ppath
operator|->
name|subpath_open
operator|=
literal|0
expr_stmt|;
name|ppath
operator|->
name|shares_segments
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release the contents of a path.  We do this in reverse order */
end_comment

begin_comment
comment|/* so as to maximize LIFO allocator behavior. */
end_comment

begin_function
name|void
name|gx_path_release
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
name|segment
modifier|*
name|pseg
decl_stmt|;
if|if
condition|(
name|ppath
operator|->
name|first_subpath
operator|==
literal|0
condition|)
return|return;
comment|/* empty path */
if|if
condition|(
name|ppath
operator|->
name|shares_segments
condition|)
return|return;
comment|/* segments are shared */
name|pseg
operator|=
operator|(
name|segment
operator|*
operator|)
name|ppath
operator|->
name|current_subpath
operator|->
name|last
expr_stmt|;
while|while
condition|(
name|pseg
condition|)
block|{
name|segment
modifier|*
name|prev
init|=
name|pseg
operator|->
name|prev
decl_stmt|;
specifier|static
name|uint
name|sizes
index|[]
init|=
block|{
name|segment_type_sizes
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'p'
index|]
condition|)
name|dprintf
argument_list|(
literal|"[p]release"
argument_list|)
operator|,
name|gx_print_segment
argument_list|(
name|pseg
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|ppath
operator|->
name|memory_procs
operator|.
name|free
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pseg
argument_list|,
literal|1
argument_list|,
name|sizes
index|[
operator|(
name|int
operator|)
name|pseg
operator|->
name|type
index|]
argument_list|,
literal|"gx_path_release"
argument_list|)
expr_stmt|;
name|pseg
operator|=
name|prev
expr_stmt|;
block|}
name|ppath
operator|->
name|first_subpath
operator|=
literal|0
expr_stmt|;
comment|/* prevent re-release */
block|}
end_function

begin_comment
comment|/* Mark a path as shared */
end_comment

begin_function
name|void
name|gx_path_share
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
if|if
condition|(
name|ppath
operator|->
name|first_subpath
condition|)
name|ppath
operator|->
name|shares_segments
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Incremental path building ------ */
end_comment

begin_comment
comment|/* Macro for opening the current subpath. */
end_comment

begin_comment
comment|/* ppath points to the path; psub has been set to ppath->current_subpath. */
end_comment

begin_define
define|#
directive|define
name|path_open
parameter_list|()
define|\
value|if ( !ppath->subpath_open )\ 	   {	int code;\ 		if ( !ppath->position_valid )\ 		  return_error(gs_error_nocurrentpoint);\ 		code = gx_path_new_subpath(ppath);\ 		if ( code< 0 ) return code;\ 		psub = ppath->current_subpath;\ 	   }
end_define

begin_comment
comment|/* Macros for allocating path segments. */
end_comment

begin_comment
comment|/* Note that they assume that ppath points to the path, */
end_comment

begin_comment
comment|/* and that psub points to the current subpath. */
end_comment

begin_comment
comment|/* We have to split the macro into two because of limitations */
end_comment

begin_comment
comment|/* on the size of a single statement (sigh). */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|p_alloc
parameter_list|(
name|pseg
parameter_list|,
name|size
parameter_list|)
define|\
value|if ( gs_debug['A'] ) dprintf2("[p]%lx<%u>\n", (ulong)pseg, size)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|p_alloc
parameter_list|(
name|pseg
parameter_list|,
name|size
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|path_unshare
parameter_list|()
define|\
value|if(ppath->shares_segments)\     if(!(psub = path_alloc_copy(ppath)))return_error(gs_error_limitcheck)
end_define

begin_define
define|#
directive|define
name|path_alloc_segment
parameter_list|(
name|pseg
parameter_list|,
name|ctype
parameter_list|,
name|stype
parameter_list|,
name|cname
parameter_list|)
define|\
value|path_unshare();\   if( !(pseg = (ctype *)(*ppath->memory_procs.alloc)(1, sizeof(ctype), cname)) )\     return_error(gs_error_limitcheck);\   p_alloc((char *)pseg, sizeof(ctype));\   pseg->type = stype, pseg->next = 0
end_define

begin_define
define|#
directive|define
name|path_alloc_link
parameter_list|(
name|pseg
parameter_list|)
define|\
value|{ segment *prev = psub->last;\     prev->next = (segment *)pseg;\     pseg->prev = prev;\     psub->last = (segment *)pseg;\   }
end_define

begin_comment
comment|/* Open a new subpath */
end_comment

begin_function
name|private
name|int
name|gx_path_new_subpath
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
name|subpath
modifier|*
name|psub
init|=
name|ppath
operator|->
name|current_subpath
decl_stmt|;
specifier|register
name|subpath
modifier|*
name|spp
decl_stmt|;
name|path_alloc_segment
argument_list|(
name|spp
argument_list|,
name|subpath
argument_list|,
name|s_start
argument_list|,
literal|"gx_path_new_subpath"
argument_list|)
expr_stmt|;
name|spp
operator|->
name|last
operator|=
operator|(
name|segment
operator|*
operator|)
name|spp
expr_stmt|;
name|spp
operator|->
name|curve_count
operator|=
literal|0
expr_stmt|;
name|spp
operator|->
name|closed
operator|=
literal|0
expr_stmt|;
name|spp
operator|->
name|pt
operator|=
name|ppath
operator|->
name|position
expr_stmt|;
name|ppath
operator|->
name|subpath_open
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|psub
condition|)
comment|/* first subpath */
block|{
name|ppath
operator|->
name|first_subpath
operator|=
name|spp
expr_stmt|;
name|spp
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|segment
modifier|*
name|prev
init|=
name|psub
operator|->
name|last
decl_stmt|;
name|prev
operator|->
name|next
operator|=
operator|(
name|segment
operator|*
operator|)
name|spp
expr_stmt|;
name|spp
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
block|}
name|ppath
operator|->
name|current_subpath
operator|=
name|spp
expr_stmt|;
name|ppath
operator|->
name|subpath_count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'p'
index|]
condition|)
name|dprintf
argument_list|(
literal|"[p]"
argument_list|)
operator|,
name|gx_print_segment
argument_list|(
operator|(
name|segment
operator|*
operator|)
name|spp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a point to the current path (moveto). */
end_comment

begin_function
name|int
name|gx_path_add_point
parameter_list|(
specifier|register
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|fixed
name|x
parameter_list|,
name|fixed
name|y
parameter_list|)
block|{
name|ppath
operator|->
name|subpath_open
operator|=
literal|0
expr_stmt|;
name|ppath
operator|->
name|position_valid
operator|=
literal|1
expr_stmt|;
name|ppath
operator|->
name|position
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|ppath
operator|->
name|position
operator|.
name|y
operator|=
name|y
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a relative point to the current path (rmoveto). */
end_comment

begin_function
name|int
name|gx_path_add_relative_point
parameter_list|(
specifier|register
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|fixed
name|dx
parameter_list|,
name|fixed
name|dy
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ppath
operator|->
name|position_valid
condition|)
name|return_error
argument_list|(
name|gs_error_nocurrentpoint
argument_list|)
expr_stmt|;
name|ppath
operator|->
name|subpath_open
operator|=
literal|0
expr_stmt|;
name|ppath
operator|->
name|position
operator|.
name|x
operator|+=
name|dx
expr_stmt|;
name|ppath
operator|->
name|position
operator|.
name|y
operator|+=
name|dy
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set the segment point and the current point in the path. */
end_comment

begin_comment
comment|/* Assumes ppath points to the path. */
end_comment

begin_define
define|#
directive|define
name|path_set_point
parameter_list|(
name|pseg
parameter_list|,
name|fx
parameter_list|,
name|fy
parameter_list|)
define|\
value|(pseg)->pt.x = ppath->position.x = (fx),\ 	(pseg)->pt.y = ppath->position.y = (fy)
end_define

begin_comment
comment|/* Add a line to the current path (lineto). */
end_comment

begin_function
name|int
name|gx_path_add_line
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|fixed
name|x
parameter_list|,
name|fixed
name|y
parameter_list|)
block|{
name|subpath
modifier|*
name|psub
init|=
name|ppath
operator|->
name|current_subpath
decl_stmt|;
specifier|register
name|line_segment
modifier|*
name|lp
decl_stmt|;
name|path_open
argument_list|()
expr_stmt|;
name|path_alloc_segment
argument_list|(
name|lp
argument_list|,
name|line_segment
argument_list|,
name|s_line
argument_list|,
literal|"gx_path_add_line"
argument_list|)
expr_stmt|;
name|path_alloc_link
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|path_set_point
argument_list|(
name|lp
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'p'
index|]
condition|)
name|dprintf
argument_list|(
literal|"[p]"
argument_list|)
operator|,
name|gx_print_segment
argument_list|(
operator|(
name|segment
operator|*
operator|)
name|lp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a rectangle to the current path. */
end_comment

begin_comment
comment|/* This is a special case of adding a parallelogram. */
end_comment

begin_function
name|int
name|gx_path_add_rectangle
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|fixed
name|x0
parameter_list|,
name|fixed
name|y0
parameter_list|,
name|fixed
name|x1
parameter_list|,
name|fixed
name|y1
parameter_list|)
block|{
return|return
name|gx_path_add_pgram
argument_list|(
name|ppath
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|x0
argument_list|,
name|y1
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a parallelogram to the current path. */
end_comment

begin_comment
comment|/* This is equivalent to an add_point, three add_lines, */
end_comment

begin_comment
comment|/* and a close_subpath. */
end_comment

begin_function
name|int
name|gx_path_add_pgram
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|fixed
name|x0
parameter_list|,
name|fixed
name|y0
parameter_list|,
name|fixed
name|x1
parameter_list|,
name|fixed
name|y1
parameter_list|,
name|fixed
name|x2
parameter_list|,
name|fixed
name|y2
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gx_path_add_point
argument_list|(
name|ppath
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|x0
operator|+
name|x2
operator|-
name|x1
argument_list|,
name|y0
operator|+
name|y2
operator|-
name|y1
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_close_subpath
argument_list|(
name|ppath
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a curve to the current path (curveto). */
end_comment

begin_function
name|int
name|gx_path_add_curve
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|fixed
name|x1
parameter_list|,
name|fixed
name|y1
parameter_list|,
name|fixed
name|x2
parameter_list|,
name|fixed
name|y2
parameter_list|,
name|fixed
name|x3
parameter_list|,
name|fixed
name|y3
parameter_list|)
block|{
name|subpath
modifier|*
name|psub
init|=
name|ppath
operator|->
name|current_subpath
decl_stmt|;
specifier|register
name|curve_segment
modifier|*
name|lp
decl_stmt|;
name|path_open
argument_list|()
expr_stmt|;
name|path_alloc_segment
argument_list|(
name|lp
argument_list|,
name|curve_segment
argument_list|,
name|s_curve
argument_list|,
literal|"gx_path_add_curve"
argument_list|)
expr_stmt|;
name|path_alloc_link
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|lp
operator|->
name|p1
operator|.
name|x
operator|=
name|x1
expr_stmt|;
name|lp
operator|->
name|p1
operator|.
name|y
operator|=
name|y1
expr_stmt|;
name|lp
operator|->
name|p2
operator|.
name|x
operator|=
name|x2
expr_stmt|;
name|lp
operator|->
name|p2
operator|.
name|y
operator|=
name|y2
expr_stmt|;
name|path_set_point
argument_list|(
name|lp
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
expr_stmt|;
name|psub
operator|->
name|curve_count
operator|++
expr_stmt|;
name|ppath
operator|->
name|curve_count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'p'
index|]
condition|)
name|dprintf
argument_list|(
literal|"[p]"
argument_list|)
operator|,
name|gx_print_segment
argument_list|(
operator|(
name|segment
operator|*
operator|)
name|lp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add an approximation of an arc to the current path.  * Parameters are the initial and final points of the arc,  * and the point at which the extended tangents meet.  * We assume that the arc is less than a semicircle.  * The arc may go either clockwise or counterclockwise.  * The approximation is a very simple one: a single curve  * whose other two control points are a fraction F of the way  * to the intersection of the tangents, where  *	F = (4/3)(1 / (1 + sqrt(1+(d/r)^2)))  * where r is the radius and d is the distance from either tangent  * point to the intersection of the tangents.  This produces  * a curve whose center point, as well as its ends, lies on  * the desired arc.  *  * Because F has to be computed in user space, we let the client  * compute it and pass it in as an argument.  */
end_comment

begin_function
name|int
name|gx_path_add_arc
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|fixed
name|x0
parameter_list|,
name|fixed
name|y0
parameter_list|,
name|fixed
name|x3
parameter_list|,
name|fixed
name|y3
parameter_list|,
name|fixed
name|xt
parameter_list|,
name|fixed
name|yt
parameter_list|,
name|floatp
name|fraction
parameter_list|)
block|{
return|return
name|gx_path_add_curve
argument_list|(
name|ppath
argument_list|,
name|x0
operator|+
call|(
name|fixed
call|)
argument_list|(
operator|(
name|xt
operator|-
name|x0
operator|)
operator|*
name|fraction
argument_list|)
argument_list|,
name|y0
operator|+
call|(
name|fixed
call|)
argument_list|(
operator|(
name|yt
operator|-
name|y0
operator|)
operator|*
name|fraction
argument_list|)
argument_list|,
name|x3
operator|+
call|(
name|fixed
call|)
argument_list|(
operator|(
name|xt
operator|-
name|x3
operator|)
operator|*
name|fraction
argument_list|)
argument_list|,
name|y3
operator|+
call|(
name|fixed
call|)
argument_list|(
operator|(
name|yt
operator|-
name|y3
operator|)
operator|*
name|fraction
argument_list|)
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Append a path to another path, and reset the first path. */
end_comment

begin_comment
comment|/* Currently this is only used to append a path to its parent */
end_comment

begin_comment
comment|/* (the path in the previous graphics context). */
end_comment

begin_function
name|int
name|gx_path_add_path
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|gx_path
modifier|*
name|ppfrom
parameter_list|)
block|{
name|subpath
modifier|*
name|psub
init|=
name|ppath
operator|->
name|current_subpath
decl_stmt|;
name|path_unshare
argument_list|()
expr_stmt|;
if|if
condition|(
name|ppfrom
operator|->
name|first_subpath
condition|)
comment|/* i.e. ppfrom not empty */
block|{
if|if
condition|(
name|ppath
operator|->
name|first_subpath
condition|)
comment|/* i.e. ppath not empty */
block|{
name|segment
modifier|*
name|pseg
init|=
name|psub
operator|->
name|last
decl_stmt|;
name|segment
modifier|*
name|pfseg
init|=
operator|(
name|segment
operator|*
operator|)
name|ppfrom
operator|->
name|first_subpath
decl_stmt|;
name|pseg
operator|->
name|next
operator|=
name|pfseg
expr_stmt|;
name|pfseg
operator|->
name|prev
operator|=
name|pseg
expr_stmt|;
block|}
else|else
name|ppath
operator|->
name|first_subpath
operator|=
name|ppfrom
operator|->
name|first_subpath
expr_stmt|;
name|ppath
operator|->
name|current_subpath
operator|=
name|ppfrom
operator|->
name|current_subpath
expr_stmt|;
block|}
comment|/* Transfer the remaining state. */
name|ppath
operator|->
name|subpath_count
operator|+=
name|ppfrom
operator|->
name|subpath_count
expr_stmt|;
name|ppath
operator|->
name|curve_count
operator|+=
name|ppfrom
operator|->
name|curve_count
expr_stmt|;
name|ppath
operator|->
name|position
operator|=
name|ppfrom
operator|->
name|position
expr_stmt|;
name|ppath
operator|->
name|position_valid
operator|=
name|ppfrom
operator|->
name|position_valid
expr_stmt|;
name|ppath
operator|->
name|subpath_open
operator|=
name|ppfrom
operator|->
name|subpath_open
expr_stmt|;
comment|/* Reset the source path. */
name|ppfrom
operator|->
name|first_subpath
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Close the current subpath. */
end_comment

begin_function
name|int
name|gx_path_close_subpath
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
name|subpath
modifier|*
name|psub
init|=
name|ppath
operator|->
name|current_subpath
decl_stmt|;
specifier|register
name|line_close_segment
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
operator|!
name|ppath
operator|->
name|subpath_open
condition|)
return|return
literal|0
return|;
name|path_alloc_segment
argument_list|(
name|lp
argument_list|,
name|line_close_segment
argument_list|,
name|s_line_close
argument_list|,
literal|"gx_path_close_subpath"
argument_list|)
expr_stmt|;
name|path_alloc_link
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|path_set_point
argument_list|(
name|lp
argument_list|,
name|psub
operator|->
name|pt
operator|.
name|x
argument_list|,
name|psub
operator|->
name|pt
operator|.
name|y
argument_list|)
expr_stmt|;
name|lp
operator|->
name|sub
operator|=
name|psub
expr_stmt|;
name|psub
operator|->
name|closed
operator|=
literal|1
expr_stmt|;
name|ppath
operator|->
name|subpath_open
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'p'
index|]
condition|)
if|if
condition|(
name|lp
operator|!=
literal|0
condition|)
name|dprintf
argument_list|(
literal|"[p]"
argument_list|)
operator|,
name|gx_print_segment
argument_list|(
operator|(
name|segment
operator|*
operator|)
name|lp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Copy the current path, because it was shared. */
end_comment

begin_comment
comment|/* Return a pointer to the current subpath, or 0. */
end_comment

begin_function
name|private
name|subpath
modifier|*
name|path_alloc_copy
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
name|gx_path
name|path_new
decl_stmt|;
name|int
name|code
decl_stmt|;
name|code
operator|=
name|gx_path_copy
argument_list|(
name|ppath
argument_list|,
operator|&
name|path_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
literal|0
return|;
operator|*
name|ppath
operator|=
name|path_new
expr_stmt|;
name|ppath
operator|->
name|shares_segments
operator|=
literal|0
expr_stmt|;
return|return
name|ppath
operator|->
name|current_subpath
return|;
block|}
end_function

begin_comment
comment|/* ------ Debugging printout ------ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* Print out a path with a label */
end_comment

begin_function
name|void
name|gx_dump_path
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|dprintf2
argument_list|(
literal|"[p]Path %lx %s:\n"
argument_list|,
operator|(
name|ulong
operator|)
name|ppath
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|gx_path_print
argument_list|(
name|ppath
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a path */
end_comment

begin_function
name|void
name|gx_path_print
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
name|segment
modifier|*
name|pseg
init|=
operator|(
name|segment
operator|*
operator|)
name|ppath
operator|->
name|first_subpath
decl_stmt|;
name|dprintf4
argument_list|(
literal|"   subpaths=%d, curves=%d, point=(%f,%f)\n"
argument_list|,
name|ppath
operator|->
name|subpath_count
argument_list|,
name|ppath
operator|->
name|curve_count
argument_list|,
name|fixed2float
argument_list|(
name|ppath
operator|->
name|position
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|ppath
operator|->
name|position
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf5
argument_list|(
literal|"   box=(%f,%f),(%f,%f) last=%lx\n"
argument_list|,
name|fixed2float
argument_list|(
name|ppath
operator|->
name|bbox
operator|.
name|p
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|ppath
operator|->
name|bbox
operator|.
name|p
operator|.
name|y
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|ppath
operator|->
name|bbox
operator|.
name|q
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|ppath
operator|->
name|bbox
operator|.
name|q
operator|.
name|y
argument_list|)
argument_list|,
operator|(
name|ulong
operator|)
name|ppath
operator|->
name|box_last
argument_list|)
expr_stmt|;
while|while
condition|(
name|pseg
condition|)
block|{
name|gx_print_segment
argument_list|(
name|pseg
argument_list|)
expr_stmt|;
name|pseg
operator|=
name|pseg
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gx_print_segment
parameter_list|(
name|segment
modifier|*
name|pseg
parameter_list|)
block|{
name|char
name|out
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|out
argument_list|,
literal|"   %lx<%lx,%lx>: %%s (%6g,%6g) "
argument_list|,
operator|(
name|ulong
operator|)
name|pseg
argument_list|,
operator|(
name|ulong
operator|)
name|pseg
operator|->
name|prev
argument_list|,
operator|(
name|ulong
operator|)
name|pseg
operator|->
name|next
argument_list|,
name|fixed2float
argument_list|(
name|pseg
operator|->
name|pt
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pseg
operator|->
name|pt
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pseg
operator|->
name|type
condition|)
block|{
case|case
name|s_start
case|:
define|#
directive|define
name|psub
value|((subpath *)pseg)
name|dprintf1
argument_list|(
name|out
argument_list|,
literal|"start"
argument_list|)
expr_stmt|;
name|dprintf2
argument_list|(
literal|"#curves=%d last=%lx"
argument_list|,
name|psub
operator|->
name|curve_count
argument_list|,
operator|(
name|ulong
operator|)
name|psub
operator|->
name|last
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|psub
break|break;
case|case
name|s_curve
case|:
name|dprintf1
argument_list|(
name|out
argument_list|,
literal|"curve"
argument_list|)
expr_stmt|;
define|#
directive|define
name|pcur
value|((curve_segment *)pseg)
name|dprintf4
argument_list|(
literal|"\n\tp1=(%f,%f) p2=(%f,%f)"
argument_list|,
name|fixed2float
argument_list|(
name|pcur
operator|->
name|p1
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pcur
operator|->
name|p1
operator|.
name|y
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pcur
operator|->
name|p2
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pcur
operator|->
name|p2
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|pcur
break|break;
case|case
name|s_line
case|:
name|dprintf1
argument_list|(
name|out
argument_list|,
literal|"line"
argument_list|)
expr_stmt|;
break|break;
case|case
name|s_line_close
case|:
define|#
directive|define
name|plc
value|((line_close_segment *)pseg)
name|dprintf1
argument_list|(
name|out
argument_list|,
literal|"close"
argument_list|)
expr_stmt|;
name|dprintf1
argument_list|(
literal|" %lx"
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|plc
operator|->
name|sub
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|plc
break|break;
default|default:
block|{
name|char
name|t
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"type 0x%x"
argument_list|,
name|pseg
operator|->
name|type
argument_list|)
expr_stmt|;
name|dprintf1
argument_list|(
name|out
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|dputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a clipping path */
end_comment

begin_function
name|void
name|gx_cpath_print
parameter_list|(
name|gx_clip_path
modifier|*
name|pcpath
parameter_list|)
block|{
if|if
condition|(
name|pcpath
operator|->
name|segments_valid
condition|)
name|gx_path_print
argument_list|(
operator|&
name|pcpath
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
name|dputs
argument_list|(
literal|"   (segments not valid)\n"
argument_list|)
expr_stmt|;
name|dprintf5
argument_list|(
literal|"   cbox=(%f,%f),(%f,%f) count=%d\n"
argument_list|,
name|fixed2float
argument_list|(
name|pcpath
operator|->
name|cbox
operator|.
name|p
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pcpath
operator|->
name|cbox
operator|.
name|p
operator|.
name|y
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pcpath
operator|->
name|cbox
operator|.
name|q
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pcpath
operator|->
name|cbox
operator|.
name|q
operator|.
name|y
argument_list|)
argument_list|,
name|pcpath
operator|->
name|list
operator|.
name|count
argument_list|)
expr_stmt|;
comment|/****** SHOULD PRINT CLIP LIST ******/
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

