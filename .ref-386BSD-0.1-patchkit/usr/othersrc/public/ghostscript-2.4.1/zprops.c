begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zprops.c */
end_comment

begin_comment
comment|/* Device property operators */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"gsprops.h"
end_include

begin_include
include|#
directive|include
file|"gsmatrix.h"
end_include

begin_comment
comment|/* for gxdevice.h */
end_comment

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_comment
comment|/* Imported procedures */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|array_get
argument_list|(
name|P3
argument_list|(
name|ref
operator|*
argument_list|,
name|long
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|props_to_stack
argument_list|(
name|P3
argument_list|(
name|gs_prop_item
operator|*
argument_list|,
name|os_ptr
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|props_from_stack
argument_list|(
name|P3
argument_list|(
name|gs_prop_item
operator|*
argument_list|,
name|os_ptr
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* getdeviceprops */
end_comment

begin_function
name|int
name|zgetdeviceprops
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|gx_device
modifier|*
name|dev
decl_stmt|;
name|gs_prop_item
modifier|*
name|plist
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_device
argument_list|)
expr_stmt|;
name|dev
operator|=
name|op
operator|->
name|value
operator|.
name|pdevice
expr_stmt|;
name|count
operator|=
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|get_props
call|)
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|plist
operator|=
operator|(
name|gs_prop_item
operator|*
operator|)
name|alloc
argument_list|(
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_prop_item
argument_list|)
argument_list|,
literal|"getdeviceprops"
argument_list|)
expr_stmt|;
if|if
condition|(
name|plist
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|e_VMerror
argument_list|)
expr_stmt|;
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|get_props
call|)
argument_list|(
name|dev
argument_list|,
name|plist
argument_list|)
expr_stmt|;
name|code
operator|=
name|props_to_stack
argument_list|(
name|plist
argument_list|,
name|op
operator|+
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|plist
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_prop_item
argument_list|)
argument_list|,
literal|"getdeviceprops"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|make_mark
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* putdeviceprops */
end_comment

begin_function
name|int
name|zputdeviceprops
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|gx_device
modifier|*
name|dev
decl_stmt|;
name|gs_prop_item
modifier|*
name|plist
decl_stmt|;
name|os_ptr
name|mp
decl_stmt|;
name|int
name|count
decl_stmt|,
name|acount
init|=
literal|0
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_device
argument_list|)
expr_stmt|;
name|dev
operator|=
name|op
operator|->
name|value
operator|.
name|pdevice
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|op
operator|-
literal|1
init|;
operator|!
name|r_has_type
argument_list|(
name|mp
argument_list|,
name|t_mark
argument_list|)
condition|;
name|mp
operator|--
control|)
block|{
if|if
condition|(
name|mp
operator|<=
name|osbot
condition|)
return|return
name|e_unmatchedmark
return|;
switch|switch
condition|(
name|r_type
argument_list|(
name|mp
argument_list|)
condition|)
block|{
case|case
name|t_array
case|:
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
name|acount
operator|+=
name|r_size
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
name|count
operator|=
name|op
operator|-
name|mp
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|count
operator|&
literal|1
condition|)
return|return
name|e_rangecheck
return|;
name|count
operator|>>=
literal|1
expr_stmt|;
name|plist
operator|=
operator|(
name|gs_prop_item
operator|*
operator|)
name|alloc
argument_list|(
name|count
operator|+
name|acount
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_prop_item
argument_list|)
argument_list|,
literal|"putdeviceprops"
argument_list|)
expr_stmt|;
if|if
condition|(
name|plist
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|e_VMerror
argument_list|)
expr_stmt|;
name|code
operator|=
name|props_from_stack
argument_list|(
name|plist
argument_list|,
name|mp
operator|+
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|code
operator|=
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|put_props
call|)
argument_list|(
name|dev
argument_list|,
name|plist
argument_list|,
name|count
operator|+
name|acount
argument_list|)
expr_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|plist
argument_list|,
name|count
operator|+
name|acount
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_prop_item
argument_list|)
argument_list|,
literal|"putdeviceprops"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
operator|*
name|mp
operator|=
operator|*
name|op
expr_stmt|;
name|osp
operator|=
name|op
operator|=
name|mp
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zprops_op_defs
index|[]
init|=
block|{
block|{
literal|"1getdeviceprops"
block|,
name|zgetdeviceprops
block|}
block|,
block|{
literal|"2putdeviceprops"
block|,
name|zputdeviceprops
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Get properties from a property list to the stack. */
end_comment

begin_function
name|private
name|int
name|props_to_stack
parameter_list|(
name|gs_prop_item
modifier|*
name|plist
parameter_list|,
name|os_ptr
name|op0
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|gs_prop_item
modifier|*
name|pi
decl_stmt|;
name|os_ptr
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|code
decl_stmt|;
for|for
control|(
name|op
operator|=
name|op0
operator|,
name|pi
operator|=
name|plist
operator|,
name|i
operator|=
name|count
init|;
name|i
operator|!=
literal|0
condition|;
name|pi
operator|++
operator|,
name|i
operator|--
control|)
block|{
name|ref
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|nstr
init|=
name|pi
operator|->
name|pname
decl_stmt|;
name|int
name|nlen
init|=
name|pi
operator|->
name|name_size
decl_stmt|;
if|if
condition|(
name|nstr
operator|==
literal|0
condition|)
continue|continue;
comment|/* no name, skip */
if|if
condition|(
name|ostop
operator|-
name|op
operator|<
literal|2
condition|)
return|return
name|e_stackoverflow
return|;
if|if
condition|(
name|nlen
operator|<
literal|0
condition|)
name|nlen
operator|=
name|strlen
argument_list|(
name|nstr
argument_list|)
expr_stmt|;
name|code
operator|=
name|name_ref
argument_list|(
operator|(
specifier|const
name|byte
operator|*
operator|)
name|nstr
argument_list|,
name|nlen
argument_list|,
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
switch|switch
condition|(
name|pi
operator|->
name|type
condition|)
block|{
case|case
operator|(
name|int
operator|)
name|prt_int
case|:
name|make_int
argument_list|(
operator|&
name|value
argument_list|,
name|pi
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|int
operator|)
name|prt_float
case|:
name|make_real
argument_list|(
operator|&
name|value
argument_list|,
name|pi
operator|->
name|value
operator|.
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|int
operator|)
name|prt_bool
case|:
name|make_bool
argument_list|(
operator|&
name|value
argument_list|,
name|pi
operator|->
name|value
operator|.
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|int
operator|)
name|prt_string
case|:
block|{
name|ushort
name|size
init|=
name|pi
operator|->
name|value
operator|.
name|a
operator|.
name|size
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|size
operator|==
call|(
name|ushort
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|pi
operator|->
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|s
argument_list|)
expr_stmt|;
name|str
operator|=
name|alloc
argument_list|(
name|size
argument_list|,
literal|1
argument_list|,
literal|"props_to_stack(string)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|pi
operator|->
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|make_tasv
argument_list|(
operator|&
name|value
argument_list|,
name|t_string
argument_list|,
name|a_all
argument_list|,
name|size
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|int
operator|)
name|prt_int_array
case|:
case|case
operator|(
name|int
operator|)
name|prt_float_array
case|:
block|{
name|uint
name|size
init|=
name|pi
operator|->
name|value
operator|.
name|a
operator|.
name|size
decl_stmt|;
name|ref
modifier|*
name|arefs
init|=
name|alloc_refs
argument_list|(
name|size
argument_list|,
literal|"props_to_stack(array)"
argument_list|)
decl_stmt|;
name|uint
name|j
decl_stmt|;
name|gs_prop_item
modifier|*
name|pv
init|=
name|pi
operator|->
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|v
decl_stmt|;
if|if
condition|(
name|arefs
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|make_tasv_new
argument_list|(
operator|&
name|value
argument_list|,
name|t_array
argument_list|,
name|a_all
argument_list|,
name|size
argument_list|,
name|refs
argument_list|,
name|arefs
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
operator|,
name|arefs
operator|++
operator|,
name|pv
operator|++
control|)
if|if
condition|(
name|pi
operator|->
name|type
operator|==
name|prt_int_array
condition|)
name|make_int_new
argument_list|(
name|arefs
argument_list|,
name|pv
operator|->
name|value
operator|.
name|i
argument_list|)
expr_stmt|;
else|else
name|make_real_new
argument_list|(
name|arefs
argument_list|,
name|pv
operator|->
name|value
operator|.
name|f
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
name|ref_assign
argument_list|(
name|op
operator|+
literal|1
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|op
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|op
operator|-
name|op0
return|;
block|}
end_function

begin_comment
comment|/* Set properties from the stack. */
end_comment

begin_comment
comment|/* Returns the number of elements copied. */
end_comment

begin_comment
comment|/* Entries with non-name keys are not copied; */
end_comment

begin_comment
comment|/* entries with invalid values are copied with status = pv_typecheck. */
end_comment

begin_function
name|private
name|int
name|props_from_stack
parameter_list|(
name|gs_prop_item
modifier|*
name|plist
comment|/* [count + acount] */
parameter_list|,
name|os_ptr
name|op0
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|gs_prop_item
modifier|*
name|pi
init|=
name|plist
decl_stmt|;
name|gs_prop_item
modifier|*
name|pai
init|=
name|plist
operator|+
name|count
decl_stmt|;
name|os_ptr
name|op
init|=
name|op0
operator|+
literal|1
decl_stmt|;
for|for
control|(
init|;
name|count
condition|;
name|op
operator|+=
literal|2
operator|,
name|count
operator|--
control|)
block|{
name|ref
name|sref
decl_stmt|;
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|t_name
argument_list|)
condition|)
return|return
name|e_typecheck
return|;
name|name_string_ref
argument_list|(
name|op
operator|-
literal|1
argument_list|,
operator|&
name|sref
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pname
operator|=
operator|(
name|char
operator|*
operator|)
name|sref
operator|.
name|value
operator|.
name|bytes
expr_stmt|;
name|pi
operator|->
name|name_size
operator|=
name|r_size
argument_list|(
operator|&
name|sref
argument_list|)
expr_stmt|;
name|pi
operator|->
name|status
operator|=
name|pv_set
expr_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_null
case|:
name|pi
operator|->
name|type
operator|=
name|prt_null
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
name|pi
operator|->
name|type
operator|=
name|prt_int
expr_stmt|;
name|pi
operator|->
name|value
operator|.
name|i
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
break|break;
case|case
name|t_real
case|:
name|pi
operator|->
name|type
operator|=
name|prt_float
expr_stmt|;
name|pi
operator|->
name|value
operator|.
name|f
operator|=
name|op
operator|->
name|value
operator|.
name|realval
expr_stmt|;
break|break;
case|case
name|t_boolean
case|:
name|pi
operator|->
name|type
operator|=
name|prt_bool
expr_stmt|;
name|pi
operator|->
name|value
operator|.
name|b
operator|=
name|op
operator|->
name|value
operator|.
name|index
expr_stmt|;
break|break;
case|case
name|t_name
case|:
name|name_string_ref
argument_list|(
name|op
argument_list|,
operator|&
name|sref
argument_list|)
expr_stmt|;
goto|goto
name|nst
goto|;
case|case
name|t_string
case|:
name|ref_assign
argument_list|(
operator|&
name|sref
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|pi
operator|->
name|type
operator|=
name|prt_string
expr_stmt|;
name|pi
operator|->
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|value
operator|.
name|bytes
expr_stmt|;
name|nst
label|:
name|pi
operator|->
name|value
operator|.
name|a
operator|.
name|size
operator|=
name|r_size
argument_list|(
operator|&
name|sref
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_array
case|:
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
block|{
name|uint
name|size
init|=
name|r_size
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|uint
name|i
decl_stmt|;
name|gs_prop_item
modifier|*
name|pv
decl_stmt|;
name|gs_prop_type
name|tv
init|=
name|prt_int
decl_stmt|;
name|pi
operator|->
name|type
operator|=
name|prt_int_array
expr_stmt|;
name|pi
operator|->
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|v
operator|=
name|pai
expr_stmt|;
name|pi
operator|->
name|value
operator|.
name|a
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|top
label|:
name|pv
operator|=
name|pai
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|ref
name|rnum
decl_stmt|;
name|array_get
argument_list|(
name|op
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
operator|&
name|rnum
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pname
operator|=
literal|0
expr_stmt|;
name|pv
operator|->
name|type
operator|=
name|tv
expr_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
operator|&
name|rnum
argument_list|)
condition|)
block|{
case|case
name|t_real
case|:
if|if
condition|(
name|tv
operator|==
name|prt_int
condition|)
block|{
name|tv
operator|=
name|prt_float
expr_stmt|;
name|pi
operator|->
name|type
operator|=
name|prt_float_array
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|pv
operator|++
operator|->
name|value
operator|.
name|f
operator|=
name|rnum
operator|.
name|value
operator|.
name|realval
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
if|if
condition|(
name|tv
operator|==
name|prt_int
condition|)
name|pv
operator|++
operator|->
name|value
operator|.
name|i
operator|=
name|rnum
operator|.
name|value
operator|.
name|intval
expr_stmt|;
else|else
name|pv
operator|++
operator|->
name|value
operator|.
name|f
operator|=
name|rnum
operator|.
name|value
operator|.
name|intval
expr_stmt|;
break|break;
default|default:
name|pi
operator|->
name|status
operator|=
name|pv_typecheck
expr_stmt|;
block|}
block|}
name|pai
operator|=
name|pv
expr_stmt|;
block|}
break|break;
default|default:
name|pi
operator|->
name|status
operator|=
name|pv_typecheck
expr_stmt|;
block|}
name|pi
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

