begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* iutil.c */
end_comment

begin_comment
comment|/* Utilities for Ghostscript interpreter */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"iutil.h"
end_include

begin_comment
comment|/* for checking prototypes */
end_comment

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"ostack.h"
end_include

begin_comment
comment|/* for opdef.h */
end_comment

begin_include
include|#
directive|include
file|"opdef.h"
end_include

begin_comment
comment|/* for obj_cvs */
end_comment

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"gsmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_comment
comment|/* for gx_color_index */
end_comment

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_comment
comment|/* ------ Object utilities ------ */
end_comment

begin_comment
comment|/* Copy refs from one place to another. */
end_comment

begin_function
name|void
name|refcpy_to_old
parameter_list|(
specifier|register
name|ref
modifier|*
name|to
parameter_list|,
specifier|register
specifier|const
name|ref
modifier|*
name|from
parameter_list|,
specifier|register
name|uint
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|cname
parameter_list|)
block|{
while|while
condition|(
name|size
operator|--
condition|)
name|ref_assign_old
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|cname
argument_list|)
operator|,
name|to
operator|++
operator|,
name|from
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|refcpy_to_new
parameter_list|(
specifier|register
name|ref
modifier|*
name|to
parameter_list|,
specifier|register
specifier|const
name|ref
modifier|*
name|from
parameter_list|,
specifier|register
name|uint
name|size
parameter_list|)
block|{
while|while
condition|(
name|size
operator|--
condition|)
name|ref_assign_new
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
operator|,
name|to
operator|++
operator|,
name|from
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill a new object with nulls. */
end_comment

begin_function
name|void
name|refset_null
parameter_list|(
specifier|register
name|ref
modifier|*
name|to
parameter_list|,
specifier|register
name|uint
name|size
parameter_list|)
block|{
while|while
condition|(
name|size
operator|--
condition|)
name|make_null_new
argument_list|(
name|to
argument_list|)
operator|,
name|to
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare two objects for equality.  Return 1 if equal, 0 if not. */
end_comment

begin_function
name|int
name|obj_eq
parameter_list|(
specifier|register
specifier|const
name|ref
modifier|*
name|pref1
parameter_list|,
specifier|register
specifier|const
name|ref
modifier|*
name|pref2
parameter_list|)
block|{
name|ref
name|nref
decl_stmt|;
if|if
condition|(
name|r_btype
argument_list|(
name|pref1
argument_list|)
operator|!=
name|r_btype
argument_list|(
name|pref2
argument_list|)
condition|)
block|{
comment|/* Only a few cases need be considered here: */
comment|/* integer/real, name/string, and vice versa. */
switch|switch
condition|(
name|r_type
argument_list|(
name|pref1
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
return|return
operator|(
name|r_has_type
argument_list|(
name|pref2
argument_list|,
name|t_real
argument_list|)
operator|&&
name|pref2
operator|->
name|value
operator|.
name|realval
operator|==
name|pref1
operator|->
name|value
operator|.
name|intval
operator|)
return|;
case|case
name|t_real
case|:
return|return
operator|(
name|r_has_type
argument_list|(
name|pref2
argument_list|,
name|t_integer
argument_list|)
operator|&&
name|pref2
operator|->
name|value
operator|.
name|intval
operator|==
name|pref1
operator|->
name|value
operator|.
name|realval
operator|)
return|;
case|case
name|t_name
case|:
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|pref2
argument_list|,
name|t_string
argument_list|)
condition|)
return|return
literal|0
return|;
name|name_string_ref
argument_list|(
name|pref1
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
name|pref1
operator|=
operator|&
name|nref
expr_stmt|;
break|break;
case|case
name|t_string
case|:
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|pref2
argument_list|,
name|t_name
argument_list|)
condition|)
return|return
literal|0
return|;
name|name_string_ref
argument_list|(
name|pref2
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
name|pref2
operator|=
operator|&
name|nref
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
comment|/* Now do a type-dependent comparison. */
comment|/* This would be very simple if we always filled in */
comment|/* all 8 bytes of a ref, but we currently don't. */
switch|switch
condition|(
name|r_btype
argument_list|(
name|pref1
argument_list|)
condition|)
block|{
case|case
name|t_array
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|refs
operator|==
name|pref2
operator|->
name|value
operator|.
name|refs
operator|&&
name|r_size
argument_list|(
name|pref1
argument_list|)
operator|==
name|r_size
argument_list|(
name|pref2
argument_list|)
operator|)
return|;
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|packed
operator|==
name|pref2
operator|->
name|value
operator|.
name|packed
operator|&&
name|r_size
argument_list|(
name|pref1
argument_list|)
operator|==
name|r_size
argument_list|(
name|pref2
argument_list|)
operator|)
return|;
case|case
name|t_boolean
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|index
operator|==
name|pref2
operator|->
name|value
operator|.
name|index
operator|)
return|;
case|case
name|t_condition
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|pcond
operator|==
name|pref2
operator|->
name|value
operator|.
name|pcond
operator|)
return|;
case|case
name|t_dictionary
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|pdict
operator|==
name|pref2
operator|->
name|value
operator|.
name|pdict
operator|)
return|;
case|case
name|t_file
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|pfile
operator|==
name|pref2
operator|->
name|value
operator|.
name|pfile
operator|)
return|;
case|case
name|t_fontID
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|pfont
operator|==
name|pref2
operator|->
name|value
operator|.
name|pfont
operator|)
return|;
case|case
name|t_gstate
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|pgstate
operator|==
name|pref2
operator|->
name|value
operator|.
name|pgstate
operator|)
return|;
case|case
name|t_integer
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|intval
operator|==
name|pref2
operator|->
name|value
operator|.
name|intval
operator|)
return|;
case|case
name|t_lock
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|plock
operator|==
name|pref2
operator|->
name|value
operator|.
name|plock
operator|)
return|;
case|case
name|t_mark
case|:
case|case
name|t_null
case|:
return|return
literal|1
return|;
case|case
name|t_name
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|pname
operator|==
name|pref2
operator|->
name|value
operator|.
name|pname
operator|)
return|;
case|case
name|t_oparray
case|:
case|case
name|t_operator
case|:
return|return
operator|(
name|op_index
argument_list|(
name|pref1
argument_list|)
operator|==
name|op_index
argument_list|(
name|pref2
argument_list|)
operator|)
return|;
case|case
name|t_real
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|realval
operator|==
name|pref2
operator|->
name|value
operator|.
name|realval
operator|)
return|;
case|case
name|t_save
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|psave
operator|==
name|pref2
operator|->
name|value
operator|.
name|psave
operator|)
return|;
case|case
name|t_string
case|:
return|return
operator|(
operator|!
name|bytes_compare
argument_list|(
name|pref1
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|pref1
argument_list|)
argument_list|,
name|pref2
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|pref2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|t_color
case|:
block|{
name|struct
name|gs_color_s
modifier|*
name|pc1
init|=
name|pref1
operator|->
name|value
operator|.
name|pcolor
decl_stmt|,
modifier|*
name|pc2
init|=
name|pref2
operator|->
name|value
operator|.
name|pcolor
decl_stmt|;
return|return
operator|(
name|pc1
operator|->
name|red
operator|==
name|pc2
operator|->
name|red
operator|&&
name|pc1
operator|->
name|green
operator|==
name|pc2
operator|->
name|green
operator|&&
name|pc1
operator|->
name|blue
operator|==
name|pc2
operator|->
name|blue
operator|&&
name|pc1
operator|->
name|not_black
operator|==
name|pc2
operator|->
name|not_black
operator|)
return|;
block|}
case|case
name|t_device
case|:
return|return
operator|(
name|pref1
operator|->
name|value
operator|.
name|pdevice
operator|==
name|pref2
operator|->
name|value
operator|.
name|pdevice
operator|)
return|;
block|}
return|return
literal|0
return|;
comment|/* shouldn't happen! */
block|}
end_function

begin_comment
comment|/* Create a printable representation of an object, a la cvs. */
end_comment

begin_comment
comment|/* Return 0 if OK,<0 if the destination wasn't large enough. */
end_comment

begin_function
name|int
name|obj_cvs
parameter_list|(
specifier|const
name|ref
modifier|*
name|op
parameter_list|,
name|byte
modifier|*
name|str
parameter_list|,
name|uint
name|len
parameter_list|,
name|uint
modifier|*
name|prlen
parameter_list|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
comment|/* big enough for any float */
name|byte
modifier|*
name|pstr
init|=
operator|(
name|byte
operator|*
operator|)
name|buf
decl_stmt|;
name|uint
name|plen
decl_stmt|;
name|ref
name|nref
decl_stmt|;
switch|switch
condition|(
name|r_btype
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_boolean
case|:
name|pstr
operator|=
operator|(
name|byte
operator|*
operator|)
operator|(
name|op
operator|->
name|value
operator|.
name|index
condition|?
literal|"true"
else|:
literal|"false"
operator|)
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|op
operator|->
name|value
operator|.
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_name
case|:
name|name_string_ref
argument_list|(
name|op
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
comment|/* name string */
name|cvname
label|:
name|pstr
operator|=
name|nref
operator|.
name|value
operator|.
name|bytes
expr_stmt|;
name|plen
operator|=
name|r_size
argument_list|(
operator|&
name|nref
argument_list|)
expr_stmt|;
goto|goto
name|nl
goto|;
case|case
name|t_oparray
case|:
name|name_index_ref
argument_list|(
name|op_array_nx_table
index|[
name|op_index
argument_list|(
name|op
argument_list|)
operator|-
name|op_def_count
index|]
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
name|name_string_ref
argument_list|(
operator|&
name|nref
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
goto|goto
name|cvname
goto|;
case|case
name|t_operator
case|:
block|{
comment|/* Recover the name from the initialization table. */
name|uint
name|index
init|=
name|op_index
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|0
condition|)
block|{
name|pstr
operator|=
operator|(
name|byte
operator|*
operator|)
operator|(
name|op_def_table
index|[
name|index
index|]
operator|->
name|oname
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Internal operator, no name. */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"operator_%lx"
argument_list|,
operator|(
name|ulong
operator|)
name|op
operator|->
name|value
operator|.
name|opproc
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_real
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%g"
argument_list|,
name|op
operator|->
name|value
operator|.
name|realval
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_string
case|:
name|pstr
operator|=
name|op
operator|->
name|value
operator|.
name|bytes
expr_stmt|;
name|plen
operator|=
name|r_size
argument_list|(
name|op
argument_list|)
expr_stmt|;
goto|goto
name|nl
goto|;
default|default:
name|pstr
operator|=
operator|(
name|byte
operator|*
operator|)
literal|"--nostringval--"
expr_stmt|;
block|}
name|plen
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pstr
argument_list|)
expr_stmt|;
name|nl
label|:
if|if
condition|(
name|plen
operator|>
name|len
condition|)
return|return
name|e_rangecheck
return|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|pstr
argument_list|,
name|plen
argument_list|)
expr_stmt|;
operator|*
name|prlen
operator|=
name|plen
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ String utilities ------ */
end_comment

begin_comment
comment|/* Convert a C string to a Ghostscript string */
end_comment

begin_function
name|int
name|string_to_ref
parameter_list|(
specifier|const
name|char
modifier|*
name|cstr
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|,
specifier|const
name|char
modifier|*
name|cname
parameter_list|)
block|{
name|uint
name|size
init|=
name|strlen
argument_list|(
name|cstr
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|alloc
argument_list|(
name|size
argument_list|,
literal|1
argument_list|,
name|cname
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|cstr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|make_tasv
argument_list|(
name|pref
argument_list|,
name|t_string
argument_list|,
name|a_all
argument_list|,
name|size
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert a Ghostscript string to a C string. */
end_comment

begin_comment
comment|/* Return 0 iff the buffer can't be allocated. */
end_comment

begin_function
name|char
modifier|*
name|ref_to_string
parameter_list|(
specifier|const
name|ref
modifier|*
name|pref
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
name|uint
name|size
init|=
name|r_size
argument_list|(
name|pref
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|alloc
argument_list|(
name|size
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|client_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pref
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|str
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* ------ Operand utilities ------ */
end_comment

begin_comment
comment|/* Get N numeric operands from the stack. */
end_comment

begin_comment
comment|/* Return a bit-mask indicating which ones are integers, */
end_comment

begin_comment
comment|/* or a (negative) error indication. */
end_comment

begin_comment
comment|/* The 1-bit in the bit-mask refers to the bottommost stack entry. */
end_comment

begin_comment
comment|/* Store float versions of the operands at pval. */
end_comment

begin_function
name|int
name|num_params
parameter_list|(
specifier|const
name|ref
modifier|*
name|op
parameter_list|,
name|int
name|count
parameter_list|,
name|float
modifier|*
name|pval
parameter_list|)
block|{
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|pval
operator|+=
name|count
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|mask
operator|<<=
literal|1
expr_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_real
case|:
operator|*
operator|--
name|pval
operator|=
name|op
operator|->
name|value
operator|.
name|realval
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
operator|*
operator|--
name|pval
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
name|mask
operator|++
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
name|op
operator|--
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Get a real parameter. */
end_comment

begin_comment
comment|/* If an error is returned, the return value is not updated. */
end_comment

begin_function
name|int
name|real_param
parameter_list|(
specifier|const
name|ref
modifier|*
name|op
parameter_list|,
name|float
modifier|*
name|pparam
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
operator|*
name|pparam
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
break|break;
case|case
name|t_real
case|:
operator|*
name|pparam
operator|=
name|op
operator|->
name|value
operator|.
name|realval
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Matrix utilities ------ */
end_comment

begin_comment
comment|/* Check for a matrix operand with read access. */
end_comment

begin_comment
comment|/* Return 0 if OK, error code if not. */
end_comment

begin_comment
comment|/* Store an all-float version of the matrix in *pmat. */
end_comment

begin_function
name|int
name|read_matrix
parameter_list|(
specifier|const
name|ref
modifier|*
name|op
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_array
case|:
empty_stmt|;
block|}
if|if
condition|(
name|r_size
argument_list|(
name|op
argument_list|)
operator|!=
literal|6
condition|)
return|return
name|e_rangecheck
return|;
if|if
condition|(
operator|!
name|r_has_attr
argument_list|(
name|op
argument_list|,
name|a_read
argument_list|)
condition|)
return|return
name|e_invalidaccess
return|;
operator|*
name|pmat
operator|=
operator|*
operator|(
name|gs_matrix
operator|*
operator|)
name|op
operator|->
name|value
operator|.
name|refs
expr_stmt|;
block|{
name|ref
modifier|*
name|pel
init|=
operator|(
name|ref
operator|*
operator|)
name|pmat
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|pel
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_integer
case|:
name|make_real
argument_list|(
name|pel
argument_list|,
name|pel
operator|->
name|value
operator|.
name|intval
argument_list|)
expr_stmt|;
case|case
name|t_real
case|:
empty_stmt|;
block|}
name|pel
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check for a matrix operand with write access. */
end_comment

begin_comment
comment|/* Return 0 if OK, error code if not. */
end_comment

begin_comment
comment|/* Initialize the matrix to an identity matrix */
end_comment

begin_comment
comment|/* (to set the types and attributes properly.) */
end_comment

begin_function
name|int
name|write_matrix
parameter_list|(
specifier|register
name|ref
modifier|*
name|op
parameter_list|)
block|{
name|ref
modifier|*
name|aptr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|op
argument_list|,
name|t_array
argument_list|)
condition|)
return|return
name|e_typecheck
return|;
if|if
condition|(
operator|!
name|r_has_attr
argument_list|(
name|op
argument_list|,
name|a_write
argument_list|)
condition|)
return|return
name|e_invalidaccess
return|;
if|if
condition|(
name|r_size
argument_list|(
name|op
argument_list|)
operator|!=
literal|6
condition|)
return|return
name|e_rangecheck
return|;
name|aptr
operator|=
name|op
operator|->
name|value
operator|.
name|refs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|5
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|aptr
operator|++
control|)
block|{
name|ref_save
argument_list|(
name|aptr
argument_list|,
literal|"write_matrix"
argument_list|)
expr_stmt|;
comment|/* we're going to overwrite */
block|}
name|gs_make_identity
argument_list|(
operator|(
name|gs_matrix
operator|*
operator|)
name|op
operator|->
name|value
operator|.
name|refs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

