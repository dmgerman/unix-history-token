begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zchar.c */
end_comment

begin_comment
comment|/* Character operators for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_comment
comment|/* for gstype1.h */
end_comment

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_comment
comment|/* for font.h */
end_comment

begin_include
include|#
directive|include
file|"gschar.h"
end_include

begin_include
include|#
directive|include
file|"gstype1.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_comment
comment|/* for gxfont.h */
end_comment

begin_include
include|#
directive|include
file|"gxfont.h"
end_include

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_comment
comment|/* for type1addpath: see below */
end_comment

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"dstack.h"
end_include

begin_comment
comment|/* for systemdict */
end_comment

begin_include
include|#
directive|include
file|"font.h"
end_include

begin_include
include|#
directive|include
file|"estack.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* All the character rendering operators use the execution stack */
end_comment

begin_comment
comment|/* for loop control -- see estack.h for details. */
end_comment

begin_comment
comment|/* The information pushed by these operators is as follows: */
end_comment

begin_comment
comment|/*	the enumerator (t_string, but points to a gs_show_enum); */
end_comment

begin_comment
comment|/*	a slot for the procedure for kshow, unused otherwise; */
end_comment

begin_comment
comment|/*	the procedure to be called at the end of the enumeration */
end_comment

begin_comment
comment|/*		(t_operator, but called directly, not by the interpreter); */
end_comment

begin_comment
comment|/*	the usual e-stack mark (t_null). */
end_comment

begin_define
define|#
directive|define
name|snumpush
value|4
end_define

begin_define
define|#
directive|define
name|senum
value|(gs_show_enum *)(esp->value.bytes)
end_define

begin_define
define|#
directive|define
name|sslot
value|esp[-1]
end_define

begin_define
define|#
directive|define
name|seproc
value|esp[-2]
end_define

begin_comment
comment|/* Imports */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|array_get
argument_list|(
name|P3
argument_list|(
name|ref
operator|*
argument_list|,
name|long
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ref
name|name_StandardEncoding
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|setup_show
argument_list|(
name|P3
argument_list|(
name|ref
operator|*
argument_list|,
name|op_proc_p
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|show_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|i_show_continue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|finish_show
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|i_finish_show
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|finish_stringwidth
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|i_finish_stringwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gs_show_enum
modifier|*
name|find_show
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|free_show
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show */
end_comment

begin_function
name|int
name|zshow
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|setup_show
argument_list|(
name|op
argument_list|,
name|finish_show
argument_list|,
name|i_finish_show
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_show_n_init
argument_list|(
name|senum
argument_list|,
name|igs
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free_show
argument_list|()
expr_stmt|;
return|return
name|code
return|;
block|}
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|op
operator|--
expr_stmt|;
return|return
name|show_continue
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ashow */
end_comment

begin_function
name|int
name|zashow
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|float
name|axy
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|num_params
argument_list|(
name|op
operator|-
literal|1
argument_list|,
literal|2
argument_list|,
name|axy
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|setup_show
argument_list|(
name|op
argument_list|,
name|finish_show
argument_list|,
name|i_finish_show
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_ashow_n_init
argument_list|(
name|senum
argument_list|,
name|igs
argument_list|,
name|axy
index|[
literal|0
index|]
argument_list|,
name|axy
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free_show
argument_list|()
expr_stmt|;
return|return
name|code
return|;
block|}
name|pop
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|op
operator|-=
literal|3
expr_stmt|;
return|return
name|show_continue
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* widthshow */
end_comment

begin_function
name|int
name|zwidthshow
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|float
name|cxy
index|[
literal|2
index|]
decl_stmt|;
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|ulong
call|)
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
argument_list|)
operator|>
literal|255
condition|)
return|return
name|e_rangecheck
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|num_params
argument_list|(
name|op
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
name|cxy
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|setup_show
argument_list|(
name|op
argument_list|,
name|finish_show
argument_list|,
name|i_finish_show
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_widthshow_n_init
argument_list|(
name|senum
argument_list|,
name|igs
argument_list|,
name|cxy
index|[
literal|0
index|]
argument_list|,
name|cxy
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|)
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free_show
argument_list|()
expr_stmt|;
return|return
name|code
return|;
block|}
name|pop
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|op
operator|-=
literal|4
expr_stmt|;
return|return
name|show_continue
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* awidthshow */
end_comment

begin_function
name|int
name|zawidthshow
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|float
name|cxy
index|[
literal|2
index|]
decl_stmt|,
name|axy
index|[
literal|2
index|]
decl_stmt|;
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|3
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|ulong
call|)
argument_list|(
name|op
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|intval
argument_list|)
operator|>
literal|255
condition|)
return|return
name|e_rangecheck
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|num_params
argument_list|(
name|op
operator|-
literal|4
argument_list|,
literal|2
argument_list|,
name|cxy
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|num_params
argument_list|(
name|op
operator|-
literal|1
argument_list|,
literal|2
argument_list|,
name|axy
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|setup_show
argument_list|(
name|op
argument_list|,
name|finish_show
argument_list|,
name|i_finish_show
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_awidthshow_n_init
argument_list|(
name|senum
argument_list|,
name|igs
argument_list|,
name|cxy
index|[
literal|0
index|]
argument_list|,
name|cxy
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|)
name|op
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|intval
argument_list|,
name|axy
index|[
literal|0
index|]
argument_list|,
name|axy
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free_show
argument_list|()
expr_stmt|;
return|return
name|code
return|;
block|}
name|pop
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|op
operator|-=
literal|6
expr_stmt|;
return|return
name|show_continue
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* kshow */
end_comment

begin_function
name|int
name|zkshow
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|check_proc
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|setup_show
argument_list|(
name|op
argument_list|,
name|finish_show
argument_list|,
name|i_finish_show
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_kshow_n_init
argument_list|(
name|senum
argument_list|,
name|igs
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free_show
argument_list|()
expr_stmt|;
return|return
name|code
return|;
block|}
name|sslot
operator|=
name|op
index|[
operator|-
literal|1
index|]
expr_stmt|;
comment|/* save kerning proc */
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|op
operator|-=
literal|2
expr_stmt|;
return|return
name|show_continue
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Common finish procedure for all show operations. */
end_comment

begin_comment
comment|/* Doesn't have to do anything. */
end_comment

begin_function
name|private
name|int
name|finish_show
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* stringwidth */
end_comment

begin_function
name|int
name|zstringwidth
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|setup_show
argument_list|(
name|op
argument_list|,
name|finish_stringwidth
argument_list|,
name|i_finish_stringwidth
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_stringwidth_n_init
argument_list|(
name|senum
argument_list|,
name|igs
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free_show
argument_list|()
expr_stmt|;
return|return
name|code
return|;
block|}
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|op
operator|--
expr_stmt|;
return|return
name|show_continue
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finishing procedure for stringwidth. */
end_comment

begin_comment
comment|/* Pushes the accumulated width. */
end_comment

begin_function
name|private
name|int
name|finish_stringwidth
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_point
name|width
decl_stmt|;
name|gs_show_width
argument_list|(
name|senum
argument_list|,
operator|&
name|width
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|width
operator|.
name|x
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|op
argument_list|,
name|width
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* charpath */
end_comment

begin_function
name|int
name|zcharpath
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_boolean
argument_list|)
expr_stmt|;
name|code
operator|=
name|setup_show
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|finish_show
argument_list|,
name|i_finish_show
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_charpath_n_init
argument_list|(
name|senum
argument_list|,
name|igs
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
operator|-
literal|1
argument_list|)
argument_list|,
name|op
operator|->
name|value
operator|.
name|index
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free_show
argument_list|()
expr_stmt|;
return|return
name|code
return|;
block|}
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|op
operator|-=
literal|2
expr_stmt|;
return|return
name|show_continue
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* setcachedevice */
end_comment

begin_function
name|int
name|zsetcachedevice
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|wbox
index|[
literal|6
index|]
decl_stmt|;
name|int
name|npop
init|=
literal|6
decl_stmt|;
name|gs_show_enum
modifier|*
name|penum
init|=
name|find_show
argument_list|()
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|6
argument_list|,
name|wbox
argument_list|)
decl_stmt|;
if|if
condition|(
name|penum
operator|==
literal|0
condition|)
return|return
name|e_undefined
return|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
block|{
comment|/* P*stScr*pt implementations apparently allow the */
comment|/* bounding box to be specified as a 4-element array. */
comment|/* Check for this here. */
name|check_array
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_size
argument_list|(
name|op
argument_list|)
operator|!=
literal|4
operator|||
name|num_params
argument_list|(
name|op
operator|-
literal|1
argument_list|,
literal|2
argument_list|,
name|wbox
argument_list|)
operator|<
literal|0
operator|||
name|num_params
argument_list|(
name|op
operator|->
name|value
operator|.
name|refs
operator|+
literal|3
argument_list|,
literal|4
argument_list|,
name|wbox
operator|+
literal|2
argument_list|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|npop
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|code
operator|=
name|gs_setcachedevice
argument_list|(
name|penum
argument_list|,
name|igs
argument_list|,
name|wbox
index|[
literal|0
index|]
argument_list|,
name|wbox
index|[
literal|1
index|]
argument_list|,
name|wbox
index|[
literal|2
index|]
argument_list|,
name|wbox
index|[
literal|3
index|]
argument_list|,
name|wbox
index|[
literal|4
index|]
argument_list|,
name|wbox
index|[
literal|5
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
name|npop
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* setcharwidth */
end_comment

begin_function
name|int
name|zsetcharwidth
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|width
index|[
literal|2
index|]
decl_stmt|;
name|gs_show_enum
modifier|*
name|penum
init|=
name|find_show
argument_list|()
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|2
argument_list|,
name|width
argument_list|)
decl_stmt|;
if|if
condition|(
name|penum
operator|==
literal|0
condition|)
return|return
name|e_undefined
return|;
if|if
condition|(
name|code
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_setcharwidth
argument_list|(
name|penum
argument_list|,
name|igs
argument_list|,
name|width
index|[
literal|0
index|]
argument_list|,
name|width
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* setmetrics */
end_comment

begin_function
name|int
name|zsetmetrics
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|params
index|[
literal|4
index|]
decl_stmt|;
name|gs_point
name|sb
decl_stmt|,
name|w
decl_stmt|;
name|gs_show_enum
modifier|*
name|penum
init|=
name|find_show
argument_list|()
decl_stmt|;
name|int
name|code
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|penum
operator|==
literal|0
condition|)
return|return
name|e_undefined
return|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_array
case|:
switch|switch
condition|(
operator|(
name|size
operator|=
name|r_size
argument_list|(
name|op
argument_list|)
operator|)
condition|)
block|{
case|case
literal|2
case|:
case|case
literal|4
case|:
break|break;
default|default:
return|return
name|e_invalidfont
return|;
block|}
name|code
operator|=
name|num_params
argument_list|(
name|op
operator|->
name|value
operator|.
name|refs
operator|+
name|size
operator|-
literal|1
argument_list|,
name|size
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|sb
operator|.
name|x
operator|=
name|params
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|sb
operator|.
name|y
operator|=
name|params
index|[
literal|1
index|]
operator|,
name|w
operator|.
name|x
operator|=
name|params
index|[
literal|2
index|]
operator|,
name|w
operator|.
name|y
operator|=
name|params
index|[
literal|3
index|]
expr_stmt|;
else|else
name|sb
operator|.
name|y
operator|=
literal|0
operator|,
name|w
operator|.
name|x
operator|=
name|params
index|[
literal|1
index|]
operator|,
name|w
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|gs_setmetrics
argument_list|(
name|penum
argument_list|,
name|igs
argument_list|,
operator|&
name|sb
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
break|break;
default|default:
name|code
operator|=
name|real_param
argument_list|(
name|op
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|w
operator|.
name|x
operator|=
name|params
index|[
literal|0
index|]
expr_stmt|;
name|w
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|gs_setmetrics
argument_list|(
name|penum
argument_list|,
name|igs
argument_list|,
literal|0
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* type1addpath */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|gs_font
modifier|*
name|pfont
decl_stmt|;
name|fixed
modifier|*
name|osptr
decl_stmt|;
comment|/* fake interpreter operand stack */
name|fixed
name|ostack
index|[
literal|2
index|]
decl_stmt|;
block|}
name|z1_data
typedef|;
end_typedef

begin_function
name|int
name|ztype1addpath
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|,
name|value
decl_stmt|;
name|gs_show_enum
modifier|*
name|penum
init|=
name|find_show
argument_list|()
decl_stmt|;
name|gs_font
modifier|*
name|pfont
init|=
name|gs_currentfont
argument_list|(
name|igs
argument_list|)
decl_stmt|;
name|font_data
modifier|*
name|pfdata
init|=
operator|(
name|font_data
operator|*
operator|)
name|pfont
operator|->
name|client_data
decl_stmt|;
name|gs_type1_state
modifier|*
name|pis
decl_stmt|;
name|fixed
name|discard
decl_stmt|;
name|gs_fixed_point
name|spt
decl_stmt|,
name|ept
decl_stmt|;
name|int
name|flex_path_was_open
decl_stmt|;
name|gs_type1_data
name|tdata
decl_stmt|;
name|z1_data
name|zdata
decl_stmt|;
name|byte
modifier|*
name|charstring
init|=
literal|0
decl_stmt|;
name|ref
name|enc_entry
decl_stmt|;
if|if
condition|(
name|penum
operator|==
literal|0
condition|)
return|return
name|e_undefined
return|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|tdata
operator|=
name|pfont
operator|->
name|data
operator|.
name|base
operator|.
name|type1_data
expr_stmt|;
name|zdata
operator|.
name|pfont
operator|=
name|pfont
expr_stmt|;
name|zdata
operator|.
name|osptr
operator|=
name|zdata
operator|.
name|ostack
expr_stmt|;
name|tdata
operator|.
name|proc_data
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|zdata
expr_stmt|;
if|if
condition|(
name|r_size
argument_list|(
name|op
argument_list|)
operator|<=
name|tdata
operator|.
name|lenIV
condition|)
block|{
comment|/* String is empty, or too short.  Just ignore it. */
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pis
operator|=
operator|(
name|gs_type1_state
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
name|gs_type1_state_sizeof
argument_list|,
literal|"type1addpath"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pis
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|code
operator|=
name|gs_type1_init
argument_list|(
name|pis
argument_list|,
name|penum
argument_list|,
name|gs_show_in_charpath
argument_list|(
name|penum
argument_list|)
argument_list|,
name|tdata
operator|.
name|PaintType
argument_list|,
operator|&
name|tdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
block|{
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pis
argument_list|,
literal|1
argument_list|,
name|gs_type1_state_sizeof
argument_list|,
literal|"type1addpath"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
name|charstring
operator|=
name|op
operator|->
name|value
operator|.
name|bytes
expr_stmt|;
name|more
label|:
name|code
operator|=
name|gs_type1_interpret
argument_list|(
name|pis
argument_list|,
name|charstring
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|charstring
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|type1_result_seac
case|:
block|{
name|ref
modifier|*
name|pstdenc
decl_stmt|,
modifier|*
name|pcstr
decl_stmt|;
if|if
condition|(
name|dict_find
argument_list|(
operator|&
name|systemdict
argument_list|,
operator|&
name|name_StandardEncoding
argument_list|,
operator|&
name|pstdenc
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|e_undefined
return|;
name|code
operator|=
name|array_get
argument_list|(
name|pstdenc
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|,
operator|&
name|enc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|dict_find
argument_list|(
operator|&
name|pfdata
operator|->
name|CharStrings
argument_list|,
operator|&
name|enc_entry
argument_list|,
operator|&
name|pcstr
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|e_undefined
return|;
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|pcstr
argument_list|,
name|t_string
argument_list|)
condition|)
return|return
name|e_invalidfont
return|;
name|charstring
operator|=
name|pcstr
operator|->
name|value
operator|.
name|bytes
expr_stmt|;
block|}
goto|goto
name|more
goto|;
case|case
name|type1_result_callothersubr
case|:
block|{
comment|/* We aren't prepared to call the interpreter here, */
comment|/* so we fake the Flex feature. */
name|gx_path
modifier|*
name|ppath
init|=
name|igs
operator|->
name|path
decl_stmt|;
name|gs_type1_pop
argument_list|(
name|pis
argument_list|,
operator|&
name|discard
argument_list|)
expr_stmt|;
comment|/* pop # of args */
switch|switch
condition|(
name|value
condition|)
block|{
case|case
literal|0
case|:
comment|/* We have to do something really sleazy here, */
comment|/* namely, make it look as though the rmovetos */
comment|/* never really happened, because we don't want */
comment|/* to interrupt the current subpath. */
name|gx_path_current_point
argument_list|(
name|ppath
argument_list|,
operator|&
name|ept
argument_list|)
expr_stmt|;
name|gx_path_add_point
argument_list|(
name|ppath
argument_list|,
name|spt
operator|.
name|x
argument_list|,
name|spt
operator|.
name|y
argument_list|)
expr_stmt|;
name|ppath
operator|->
name|subpath_open
operator|=
name|flex_path_was_open
expr_stmt|;
comment|/* ^--- sleaze */
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|ept
operator|.
name|x
argument_list|,
name|ept
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* Transfer endpoint coordinates to 'ostack' */
name|gs_type1_pop
argument_list|(
name|pis
argument_list|,
operator|&
name|zdata
operator|.
name|ostack
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gs_type1_pop
argument_list|(
name|pis
argument_list|,
operator|&
name|zdata
operator|.
name|ostack
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gs_type1_pop
argument_list|(
name|pis
argument_list|,
operator|&
name|discard
argument_list|)
expr_stmt|;
name|zdata
operator|.
name|osptr
operator|=
operator|&
name|zdata
operator|.
name|ostack
index|[
literal|2
index|]
expr_stmt|;
goto|goto
name|more
goto|;
case|case
literal|1
case|:
name|gx_path_current_point
argument_list|(
name|ppath
argument_list|,
operator|&
name|spt
argument_list|)
expr_stmt|;
name|flex_path_was_open
operator|=
name|ppath
operator|->
name|subpath_open
expr_stmt|;
comment|/* ^--- more sleaze */
goto|goto
name|more
goto|;
case|case
literal|2
case|:
goto|goto
name|more
goto|;
case|case
literal|3
case|:
name|gs_type1_pop
argument_list|(
name|pis
argument_list|,
operator|&
name|discard
argument_list|)
expr_stmt|;
comment|/* pop subr# */
name|zdata
operator|.
name|ostack
index|[
literal|0
index|]
operator|=
name|int2fixed
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|zdata
operator|.
name|osptr
operator|=
operator|&
name|zdata
operator|.
name|ostack
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|more
goto|;
block|}
comment|/* Unrecognized othersubr */
name|code
operator|=
name|e_rangecheck
expr_stmt|;
block|}
break|break;
block|}
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pis
argument_list|,
literal|1
argument_list|,
name|gs_type1_state_sizeof
argument_list|,
literal|"type1addpath"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* type1imagepath */
end_comment

begin_function
name|int
name|ztype1imagepath
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|woxy
index|[
literal|4
index|]
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|7
index|]
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|6
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|5
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|num_params
argument_list|(
name|op
operator|-
literal|1
argument_list|,
literal|4
argument_list|,
name|woxy
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|check_write_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|code
operator|=
name|gs_type1imagepath
argument_list|(
name|igs
argument_list|,
name|op
index|[
operator|-
literal|7
index|]
operator|.
name|value
operator|.
name|bytes
argument_list|,
operator|(
name|int
operator|)
name|op
index|[
operator|-
literal|6
index|]
operator|.
name|value
operator|.
name|intval
argument_list|,
operator|(
name|int
operator|)
name|op
index|[
operator|-
literal|5
index|]
operator|.
name|value
operator|.
name|intval
argument_list|,
name|woxy
index|[
literal|0
index|]
argument_list|,
name|woxy
index|[
literal|1
index|]
argument_list|,
name|woxy
index|[
literal|2
index|]
argument_list|,
name|woxy
index|[
literal|3
index|]
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|op
index|[
operator|-
literal|7
index|]
operator|=
operator|*
name|op
expr_stmt|;
name|r_set_size
argument_list|(
name|op
operator|-
literal|7
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|7
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Auxiliary procedures for type 1 fonts ------ */
end_comment

begin_function
name|int
name|z1_subr_proc
parameter_list|(
name|gs_type1_data
modifier|*
name|pdata
parameter_list|,
name|int
name|index
parameter_list|,
name|byte
modifier|*
modifier|*
name|pstr
parameter_list|)
block|{
name|gs_font
modifier|*
name|pfont
init|=
operator|(
operator|(
name|z1_data
operator|*
operator|)
operator|(
name|pdata
operator|->
name|proc_data
operator|)
operator|)
operator|->
name|pfont
decl_stmt|;
name|font_data
modifier|*
name|pfdata
init|=
operator|(
name|font_data
operator|*
operator|)
operator|(
name|pfont
operator|->
name|client_data
operator|)
decl_stmt|;
name|ref
modifier|*
name|psubr
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|r_size
argument_list|(
operator|&
name|pfdata
operator|->
name|Subrs
argument_list|)
condition|)
return|return
name|e_rangecheck
return|;
name|psubr
operator|=
name|pfdata
operator|->
name|Subrs
operator|.
name|value
operator|.
name|refs
operator|+
name|index
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|psubr
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
operator|*
name|pstr
operator|=
name|psubr
operator|->
name|value
operator|.
name|bytes
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|z1_pop_proc
parameter_list|(
name|gs_type1_data
modifier|*
name|pdata
parameter_list|,
name|fixed
modifier|*
name|pf
parameter_list|)
block|{
operator|*
name|pf
operator|=
operator|*
operator|--
operator|(
operator|(
operator|(
name|z1_data
operator|*
operator|)
operator|(
name|pdata
operator|->
name|proc_data
operator|)
operator|)
operator|->
name|osptr
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zchar_op_defs
index|[]
init|=
block|{
block|{
literal|"3ashow"
block|,
name|zashow
block|}
block|,
block|{
literal|"6awidthshow"
block|,
name|zawidthshow
block|}
block|,
block|{
literal|"2charpath"
block|,
name|zcharpath
block|}
block|,
block|{
literal|"2kshow"
block|,
name|zkshow
block|}
block|,
block|{
literal|"3setcachedevice"
block|,
name|zsetcachedevice
block|}
block|,
block|{
literal|"2setcharwidth"
block|,
name|zsetcharwidth
block|}
block|,
block|{
literal|"1.setmetrics"
block|,
name|zsetmetrics
block|}
block|,
block|{
literal|"1show"
block|,
name|zshow
block|}
block|,
block|{
literal|"1stringwidth"
block|,
name|zstringwidth
block|}
block|,
block|{
literal|"1type1addpath"
block|,
name|ztype1addpath
block|}
block|,
block|{
literal|"8type1imagepath"
block|,
name|ztype1imagepath
block|}
block|,
block|{
literal|"4widthshow"
block|,
name|zwidthshow
block|}
block|,
comment|/* Internal operators */
block|{
literal|"0%finish_show"
block|,
name|finish_show
block|,
operator|&
name|i_finish_show
block|}
block|,
block|{
literal|"0%finish_stringwidth"
block|,
name|finish_stringwidth
block|,
operator|&
name|i_finish_stringwidth
block|}
block|,
block|{
literal|"0%show_continue"
block|,
name|show_continue
block|,
operator|&
name|i_show_continue
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Set up for a show operator. */
end_comment

begin_comment
comment|/* The top stack element must be the string to be scanned. */
end_comment

begin_comment
comment|/* The caller has already done all other argument checking. */
end_comment

begin_function
name|private
name|int
name|setup_show
parameter_list|(
name|ref
modifier|*
name|op
parameter_list|,
name|op_proc_p
name|endproc
comment|/* end procedure */
parameter_list|,
name|int
name|proc_index
parameter_list|)
block|{
name|gs_show_enum
modifier|*
name|penum
decl_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|check_estack
argument_list|(
name|snumpush
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|penum
operator|=
operator|(
name|gs_show_enum
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
name|gs_show_enum_sizeof
argument_list|,
literal|"setup_show"
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|mark_estack
argument_list|(
name|es_show
argument_list|)
expr_stmt|;
name|push_op_estack
argument_list|(
name|endproc
argument_list|,
name|proc_index
argument_list|)
expr_stmt|;
operator|++
name|esp
expr_stmt|;
name|make_tv
argument_list|(
name|esp
argument_list|,
name|t_null
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reserve slot */
operator|++
name|esp
expr_stmt|;
name|make_tasv
argument_list|(
name|esp
argument_list|,
name|t_string
argument_list|,
literal|0
argument_list|,
name|gs_show_enum_sizeof
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|penum
argument_list|)
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* Continuation operator for character rendering. */
end_comment

begin_function
name|private
name|int
name|show_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_show_enum
modifier|*
name|penum
init|=
name|senum
decl_stmt|;
name|int
name|code
init|=
name|gs_show_next
argument_list|(
name|penum
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
comment|/* all done */
name|code
operator|=
operator|(
operator|*
name|real_opproc
argument_list|(
operator|&
name|seproc
argument_list|)
operator|)
operator|(
name|op
operator|)
expr_stmt|;
name|free_show
argument_list|()
expr_stmt|;
return|return
operator|(
name|code
operator|>=
literal|0
condition|?
name|o_pop_estack
else|:
name|code
operator|)
return|;
case|case
name|gs_show_kern
case|:
block|{
name|ref
modifier|*
name|pslot
init|=
operator|&
name|sslot
decl_stmt|;
name|push
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|gs_kshow_previous_char
argument_list|(
name|penum
argument_list|)
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|gs_kshow_next_char
argument_list|(
name|penum
argument_list|)
argument_list|)
expr_stmt|;
name|push_op_estack
argument_list|(
name|show_continue
argument_list|,
name|i_show_continue
argument_list|)
expr_stmt|;
comment|/* continue after kerning */
operator|*
operator|++
name|esp
operator|=
operator|*
name|pslot
expr_stmt|;
comment|/* kerning procedure */
block|}
return|return
name|o_push_estack
return|;
case|case
name|gs_show_render
case|:
block|{
name|font_data
modifier|*
name|pfont
init|=
operator|(
name|font_data
operator|*
operator|)
name|gs_currentfont
argument_list|(
name|igs
argument_list|)
operator|->
name|client_data
decl_stmt|;
name|push
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|op
index|[
operator|-
literal|1
index|]
operator|=
name|pfont
operator|->
name|dict
expr_stmt|;
comment|/* push the font */
name|make_int
argument_list|(
name|op
argument_list|,
name|gs_show_current_char
argument_list|(
name|penum
argument_list|)
argument_list|)
expr_stmt|;
name|push_op_estack
argument_list|(
name|show_continue
argument_list|,
name|i_show_continue
argument_list|)
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
name|pfont
operator|->
name|BuildChar
expr_stmt|;
block|}
return|return
name|o_push_estack
return|;
default|default:
comment|/* error */
name|free_show
argument_list|()
expr_stmt|;
return|return
name|code
return|;
block|}
block|}
end_function

begin_comment
comment|/* Find the current show enumerator on the e-stack. */
end_comment

begin_function
name|private
name|gs_show_enum
modifier|*
name|find_show
parameter_list|()
block|{
name|es_ptr
name|ep
init|=
name|esp
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|r_has_type
argument_list|(
name|ep
argument_list|,
name|t_null
argument_list|)
operator|&&
name|ep
operator|->
name|value
operator|.
name|index
operator|==
name|es_show
operator|)
condition|)
block|{
if|if
condition|(
operator|--
name|ep
operator|<
name|esbot
condition|)
return|return
literal|0
return|;
comment|/* no mark */
block|}
return|return
operator|(
name|gs_show_enum
operator|*
operator|)
name|ep
index|[
name|snumpush
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|bytes
return|;
block|}
end_function

begin_comment
comment|/* Discard the show record (after an error, or at the end). */
end_comment

begin_function
name|private
name|void
name|free_show
parameter_list|()
block|{
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|senum
argument_list|,
literal|1
argument_list|,
name|gs_show_enum_sizeof
argument_list|,
literal|"free_show"
argument_list|)
expr_stmt|;
name|esp
operator|-=
name|snumpush
expr_stmt|;
block|}
end_function

end_unit

