begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gxcpath.c */
end_comment

begin_comment
comment|/* Implementation of clipping paths */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_include
include|#
directive|include
file|"gxcpath.h"
end_include

begin_define
define|#
directive|define
name|min_int
value|(-1<< (sizeof(int) * 8 - 1))
end_define

begin_define
define|#
directive|define
name|max_int
value|(~min_int)
end_define

begin_decl_stmt
specifier|const
name|uint
name|gs_clip_path_sizeof
init|=
sizeof|sizeof
argument_list|(
name|gx_clip_path
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Imported procedures */
end_comment

begin_decl_stmt
name|gx_device
modifier|*
name|gs_currentdevice
argument_list|(
name|P1
argument_list|(
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|gx_set_device_only
argument_list|(
name|P2
argument_list|(
name|gs_state
operator|*
argument_list|,
name|gx_device
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|void
name|clip_prepare
argument_list|(
name|P1
argument_list|(
name|gx_clip_list
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
specifier|const
name|gx_clip_list
name|clip_list_empty
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
name|min_int
block|,
name|min_int
block|,
name|min_int
block|,
name|min_int
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|min_int
block|,
name|max_int
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|max_int
block|,
name|max_int
block|,
name|max_int
block|,
name|max_int
block|}
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|clip_rect_print
parameter_list|(
name|str
parameter_list|,
name|ar
parameter_list|)
define|\
value|if ( gs_debug['q'] )\ 	dprintf6("[q]%s %lx: (%d,%d),(%d,%d)\n", str, (ulong)ar,\ 		 (ar)->xmin, (ar)->ymin, (ar)->xmax, (ar)->ymax)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|clip_rect_print
parameter_list|(
name|s
parameter_list|,
name|ar
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* Validate a clipping path that has gone through clip_prepare. */
end_comment

begin_function
name|private
name|void
name|clip_list_validate
parameter_list|(
name|gx_clip_list
modifier|*
name|clp
parameter_list|)
block|{
name|gx_clip_rect
modifier|*
name|prev
init|=
operator|&
name|clp
operator|->
name|first
decl_stmt|;
name|gx_clip_rect
modifier|*
name|ptr
init|=
name|prev
decl_stmt|;
name|int
name|wrong
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|ymin
operator|>
name|ptr
operator|->
name|ymax
operator|||
name|ptr
operator|->
name|xmin
operator|>
name|ptr
operator|->
name|xmax
operator|||
operator|!
operator|(
name|ptr
operator|->
name|ymin
operator|>=
name|prev
operator|->
name|ymax
operator|||
name|ptr
operator|->
name|ymin
operator|==
name|prev
operator|->
name|ymin
operator|&&
name|ptr
operator|->
name|ymax
operator|==
name|prev
operator|->
name|ymax
operator|&&
name|ptr
operator|->
name|xmin
operator|>=
name|prev
operator|->
name|xmax
operator|)
condition|)
block|{
name|clip_rect_print
argument_list|(
literal|"WRONG:"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|wrong
operator|=
literal|1
expr_stmt|;
block|}
name|prev
operator|=
name|ptr
operator|,
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------ Clipping path accessing ------ */
end_comment

begin_comment
comment|/* Return the path of a clipping path. */
end_comment

begin_function
name|int
name|gx_cpath_path
parameter_list|(
name|gx_clip_path
modifier|*
name|pcpath
parameter_list|,
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pcpath
operator|->
name|segments_valid
condition|)
block|{
name|int
name|code
init|=
name|gx_clip_list_add_to_path
argument_list|(
operator|&
name|pcpath
operator|->
name|list
argument_list|,
operator|&
name|pcpath
operator|->
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pcpath
operator|->
name|segments_valid
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|ppath
operator|=
name|pcpath
operator|->
name|path
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the quick-check rectangle for a clipping path. */
end_comment

begin_function
name|int
name|gx_cpath_box_for_check
parameter_list|(
name|gx_clip_path
modifier|*
name|pcpath
parameter_list|,
name|gs_fixed_rect
modifier|*
name|pbox
parameter_list|)
block|{
operator|*
name|pbox
operator|=
name|pcpath
operator|->
name|cbox
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Test if a clipping path includes a rectangle. */
end_comment

begin_comment
comment|/* The rectangle need not be oriented correctly, i.e. x0> x1 is OK. */
end_comment

begin_function
name|int
name|gx_cpath_includes_rectangle
parameter_list|(
specifier|register
name|gx_clip_path
modifier|*
name|pcpath
parameter_list|,
name|fixed
name|x0
parameter_list|,
name|fixed
name|y0
parameter_list|,
name|fixed
name|x1
parameter_list|,
name|fixed
name|y1
parameter_list|)
block|{
return|return
operator|(
name|x0
operator|<=
name|x1
condition|?
operator|(
name|pcpath
operator|->
name|cbox
operator|.
name|p
operator|.
name|x
operator|<=
name|x0
operator|&&
name|x1
operator|<=
name|pcpath
operator|->
name|cbox
operator|.
name|q
operator|.
name|x
operator|)
else|:
operator|(
name|pcpath
operator|->
name|cbox
operator|.
name|p
operator|.
name|x
operator|<=
name|x1
operator|&&
name|x0
operator|<=
name|pcpath
operator|->
name|cbox
operator|.
name|q
operator|.
name|x
operator|)
operator|)
operator|&&
operator|(
name|y0
operator|<=
name|y1
condition|?
operator|(
name|pcpath
operator|->
name|cbox
operator|.
name|p
operator|.
name|y
operator|<=
name|y0
operator|&&
name|y1
operator|<=
name|pcpath
operator|->
name|cbox
operator|.
name|q
operator|.
name|y
operator|)
else|:
operator|(
name|pcpath
operator|->
name|cbox
operator|.
name|p
operator|.
name|y
operator|<=
name|y1
operator|&&
name|y0
operator|<=
name|pcpath
operator|->
name|cbox
operator|.
name|q
operator|.
name|y
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Release a clipping path. */
end_comment

begin_function
name|void
name|gx_cpath_release
parameter_list|(
name|gx_clip_path
modifier|*
name|pcpath
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pcpath
operator|->
name|shares_list
condition|)
name|gx_clip_list_free
argument_list|(
operator|&
name|pcpath
operator|->
name|list
argument_list|,
operator|&
name|pcpath
operator|->
name|path
operator|.
name|memory_procs
argument_list|)
expr_stmt|;
name|gx_path_release
argument_list|(
operator|&
name|pcpath
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Share a clipping path. */
end_comment

begin_function
name|void
name|gx_cpath_share
parameter_list|(
name|gx_clip_path
modifier|*
name|pcpath
parameter_list|)
block|{
name|gx_path_share
argument_list|(
operator|&
name|pcpath
operator|->
name|path
argument_list|)
expr_stmt|;
name|pcpath
operator|->
name|shares_list
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a rectangular clipping path. */
end_comment

begin_comment
comment|/* The supplied rectangle may not be oriented correctly, */
end_comment

begin_comment
comment|/* but it will be oriented correctly upon return. */
end_comment

begin_function
name|int
name|gx_cpath_from_rectangle
parameter_list|(
name|gx_clip_path
modifier|*
name|pcpath
parameter_list|,
name|gs_fixed_rect
modifier|*
name|pbox
parameter_list|,
name|gs_memory_procs
modifier|*
name|mp
parameter_list|)
block|{
name|gx_clip_list_from_rectangle
argument_list|(
operator|&
name|pcpath
operator|->
name|list
argument_list|,
name|pbox
argument_list|)
expr_stmt|;
name|pcpath
operator|->
name|cbox
operator|=
operator|*
name|pbox
expr_stmt|;
name|pcpath
operator|->
name|segments_valid
operator|=
literal|0
expr_stmt|;
name|pcpath
operator|->
name|shares_list
operator|=
literal|0
expr_stmt|;
name|gx_path_init
argument_list|(
operator|&
name|pcpath
operator|->
name|path
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|pcpath
operator|->
name|path
operator|.
name|bbox
operator|=
operator|*
name|pbox
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Intersect a new clipping path with an old one. */
end_comment

begin_comment
comment|/* Note that it may overwrite its path argument. */
end_comment

begin_function
name|int
name|gx_cpath_intersect
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gx_clip_path
modifier|*
name|pcpath
parameter_list|,
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|int
name|rule
parameter_list|)
block|{
name|gs_fixed_rect
name|old_box
decl_stmt|,
name|new_box
decl_stmt|;
if|if
condition|(
name|gx_cpath_is_rectangle
argument_list|(
name|pcpath
argument_list|,
operator|&
name|old_box
argument_list|)
operator|&&
name|gx_path_is_rectangle
argument_list|(
name|ppath
argument_list|,
operator|&
name|new_box
argument_list|)
condition|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
comment|/* Intersect the two rectangles if necessary. */
if|if
condition|(
name|old_box
operator|.
name|p
operator|.
name|x
operator|>
name|new_box
operator|.
name|p
operator|.
name|x
condition|)
name|new_box
operator|.
name|p
operator|.
name|x
operator|=
name|old_box
operator|.
name|p
operator|.
name|x
operator|,
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|old_box
operator|.
name|p
operator|.
name|y
operator|>
name|new_box
operator|.
name|p
operator|.
name|y
condition|)
name|new_box
operator|.
name|p
operator|.
name|y
operator|=
name|old_box
operator|.
name|p
operator|.
name|y
operator|,
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|old_box
operator|.
name|q
operator|.
name|x
operator|<
name|new_box
operator|.
name|q
operator|.
name|x
condition|)
name|new_box
operator|.
name|q
operator|.
name|x
operator|=
name|old_box
operator|.
name|q
operator|.
name|x
operator|,
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|old_box
operator|.
name|q
operator|.
name|y
operator|<
name|new_box
operator|.
name|q
operator|.
name|y
condition|)
name|new_box
operator|.
name|q
operator|.
name|y
operator|=
name|old_box
operator|.
name|q
operator|.
name|y
operator|,
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
comment|/* Store the new rectangle back into the new path. */
specifier|register
name|segment
modifier|*
name|pseg
init|=
operator|(
name|segment
operator|*
operator|)
name|ppath
operator|->
name|first_subpath
decl_stmt|;
define|#
directive|define
name|set_pt
parameter_list|(
name|pqx
parameter_list|,
name|pqy
parameter_list|)
define|\
value|pseg->pt.x = new_box.pqx.x, pseg->pt.y = new_box.pqy.y
name|set_pt
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|pseg
operator|=
name|pseg
operator|->
name|next
expr_stmt|;
name|set_pt
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|pseg
operator|=
name|pseg
operator|->
name|next
expr_stmt|;
name|set_pt
argument_list|(
name|q
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|pseg
operator|=
name|pseg
operator|->
name|next
expr_stmt|;
name|set_pt
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|pseg
operator|=
name|pseg
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|pseg
operator|!=
literal|0
condition|)
comment|/* might be an open rectangle */
name|set_pt
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|set_pt
block|}
name|ppath
operator|->
name|bbox
operator|=
name|new_box
expr_stmt|;
name|gx_clip_list_from_rectangle
argument_list|(
operator|&
name|pcpath
operator|->
name|list
argument_list|,
operator|&
name|new_box
argument_list|)
expr_stmt|;
name|pcpath
operator|->
name|cbox
operator|=
name|new_box
expr_stmt|;
name|pcpath
operator|->
name|path
operator|=
operator|*
name|ppath
expr_stmt|;
name|pcpath
operator|->
name|segments_valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Not a rectangle.  Intersect the slow way. */
name|gx_device_accum
name|adev
decl_stmt|;
name|gx_device_color
name|devc
decl_stmt|;
name|gx_device
modifier|*
name|save_dev
init|=
name|gs_currentdevice
argument_list|(
name|pgs
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
name|adev
operator|=
name|gs_accum_device
expr_stmt|;
name|adev
operator|.
name|memory_procs
operator|=
name|pcpath
operator|->
name|path
operator|.
name|memory_procs
expr_stmt|;
call|(
modifier|*
name|adev
operator|.
name|procs
operator|->
name|open_device
call|)
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
operator|&
name|adev
argument_list|)
expr_stmt|;
name|devc
operator|.
name|color1
operator|=
name|devc
operator|.
name|color2
operator|=
literal|0
expr_stmt|;
comment|/* arbitrary, but not */
comment|/* transparent */
name|devc
operator|.
name|halftone_level
operator|=
literal|0
expr_stmt|;
name|gx_set_device_only
argument_list|(
name|pgs
argument_list|,
operator|(
name|gx_device
operator|*
operator|)
operator|&
name|adev
argument_list|)
expr_stmt|;
name|code
operator|=
name|gx_fill_path
argument_list|(
name|ppath
argument_list|,
operator|&
name|devc
argument_list|,
name|pgs
argument_list|,
name|rule
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|)
expr_stmt|;
name|gx_set_device_only
argument_list|(
name|pgs
argument_list|,
name|save_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|code
operator|=
call|(
modifier|*
name|adev
operator|.
name|procs
operator|->
name|close_device
call|)
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
operator|&
name|adev
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pcpath
operator|->
name|list
operator|=
name|adev
operator|.
name|list
expr_stmt|;
name|gx_path_init
argument_list|(
operator|&
name|pcpath
operator|->
name|path
argument_list|,
operator|&
name|pcpath
operator|->
name|path
operator|.
name|memory_procs
argument_list|)
expr_stmt|;
name|pcpath
operator|->
name|path
operator|.
name|bbox
operator|.
name|p
operator|.
name|x
operator|=
name|int2fixed
argument_list|(
name|adev
operator|.
name|bbox
operator|.
name|p
operator|.
name|x
argument_list|)
expr_stmt|;
name|pcpath
operator|->
name|path
operator|.
name|bbox
operator|.
name|p
operator|.
name|y
operator|=
name|int2fixed
argument_list|(
name|adev
operator|.
name|bbox
operator|.
name|p
operator|.
name|y
argument_list|)
expr_stmt|;
name|pcpath
operator|->
name|path
operator|.
name|bbox
operator|.
name|q
operator|.
name|x
operator|=
name|int2fixed
argument_list|(
name|adev
operator|.
name|bbox
operator|.
name|q
operator|.
name|x
argument_list|)
expr_stmt|;
name|pcpath
operator|->
name|path
operator|.
name|bbox
operator|.
name|q
operator|.
name|y
operator|=
name|int2fixed
argument_list|(
name|adev
operator|.
name|bbox
operator|.
name|q
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* Note that the result of the intersection might be */
comment|/* a single rectangle.  This will cause clip_path_is_rect.. */
comment|/* to return true.  This, in turn, requires that */
comment|/* we set pcpath->cbox correctly. */
if|if
condition|(
name|clip_list_is_rectangle
argument_list|(
operator|&
name|adev
operator|.
name|list
argument_list|)
condition|)
name|pcpath
operator|->
name|cbox
operator|=
name|pcpath
operator|->
name|path
operator|.
name|bbox
expr_stmt|;
else|else
block|{
comment|/* The quick check must fail. */
name|pcpath
operator|->
name|cbox
operator|.
name|p
operator|.
name|x
operator|=
name|pcpath
operator|->
name|cbox
operator|.
name|p
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|pcpath
operator|->
name|cbox
operator|.
name|q
operator|.
name|x
operator|=
name|pcpath
operator|->
name|cbox
operator|.
name|q
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
name|pcpath
operator|->
name|segments_valid
operator|=
literal|0
expr_stmt|;
name|pcpath
operator|->
name|shares_list
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Clipping list routines ------ */
end_comment

begin_comment
comment|/* Initialize a clip list. */
end_comment

begin_function
name|void
name|gx_clip_list_init
parameter_list|(
name|gx_clip_list
modifier|*
name|clp
parameter_list|)
block|{
operator|*
name|clp
operator|=
name|clip_list_empty
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize a clip list to a rectangle. */
end_comment

begin_comment
comment|/* The supplied rectangle may not be oriented correctly, */
end_comment

begin_comment
comment|/* but it will be oriented correctly upon return. */
end_comment

begin_function
name|void
name|gx_clip_list_from_rectangle
parameter_list|(
name|gx_clip_list
modifier|*
name|clp
parameter_list|,
specifier|register
name|gs_fixed_rect
modifier|*
name|rp
parameter_list|)
block|{
name|gx_clip_list_init
argument_list|(
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|p
operator|.
name|x
operator|>
name|rp
operator|->
name|q
operator|.
name|x
condition|)
block|{
name|fixed
name|t
init|=
name|rp
operator|->
name|p
operator|.
name|x
decl_stmt|;
name|rp
operator|->
name|p
operator|.
name|x
operator|=
name|rp
operator|->
name|q
operator|.
name|x
expr_stmt|;
name|rp
operator|->
name|q
operator|.
name|x
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|p
operator|.
name|y
operator|>
name|rp
operator|->
name|q
operator|.
name|y
condition|)
block|{
name|fixed
name|t
init|=
name|rp
operator|->
name|p
operator|.
name|y
decl_stmt|;
name|rp
operator|->
name|p
operator|.
name|y
operator|=
name|rp
operator|->
name|q
operator|.
name|y
expr_stmt|;
name|rp
operator|->
name|q
operator|.
name|y
operator|=
name|t
expr_stmt|;
block|}
name|clp
operator|->
name|sole
operator|.
name|xmin
operator|=
name|fixed2int_var_rounded
argument_list|(
name|rp
operator|->
name|p
operator|.
name|x
argument_list|)
expr_stmt|;
name|clp
operator|->
name|sole
operator|.
name|ymin
operator|=
name|fixed2int_var_rounded
argument_list|(
name|rp
operator|->
name|p
operator|.
name|y
argument_list|)
expr_stmt|;
name|clp
operator|->
name|sole
operator|.
name|xmax
operator|=
name|fixed2int_var_rounded
argument_list|(
name|rp
operator|->
name|q
operator|.
name|x
argument_list|)
expr_stmt|;
name|clp
operator|->
name|sole
operator|.
name|ymax
operator|=
name|fixed2int_var_rounded
argument_list|(
name|rp
operator|->
name|q
operator|.
name|y
argument_list|)
expr_stmt|;
name|clp
operator|->
name|count
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a clip list to a path. */
end_comment

begin_comment
comment|/* The current implementation is very inefficient. */
end_comment

begin_function
name|int
name|gx_clip_list_add_to_path
parameter_list|(
name|gx_clip_list
modifier|*
name|clp
parameter_list|,
name|gx_path
modifier|*
name|ppath
parameter_list|)
block|{
name|gx_clip_rect
modifier|*
name|rp
decl_stmt|;
name|int
name|code
decl_stmt|;
name|clip_prepare
argument_list|(
name|clp
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
operator|&
name|clp
operator|->
name|first
init|;
name|rp
operator|!=
literal|0
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rp
operator|->
name|xmin
operator|<
name|rp
operator|->
name|xmax
operator|&&
name|rp
operator|->
name|ymin
operator|<
name|rp
operator|->
name|ymax
condition|)
block|{
name|code
operator|=
name|gx_path_add_rectangle
argument_list|(
name|ppath
argument_list|,
name|int2fixed
argument_list|(
name|rp
operator|->
name|xmin
argument_list|)
argument_list|,
name|int2fixed
argument_list|(
name|rp
operator|->
name|ymin
argument_list|)
argument_list|,
name|int2fixed
argument_list|(
name|rp
operator|->
name|xmax
argument_list|)
argument_list|,
name|int2fixed
argument_list|(
name|rp
operator|->
name|ymax
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free a clip list. */
end_comment

begin_function
name|void
name|gx_clip_list_free
parameter_list|(
name|gx_clip_list
modifier|*
name|clp
parameter_list|,
name|gs_memory_procs
modifier|*
name|mp
parameter_list|)
block|{
name|gx_clip_rect
modifier|*
name|rp
init|=
name|clp
operator|->
name|last
operator|.
name|prev
decl_stmt|;
if|if
condition|(
name|clp
operator|->
name|count
operator|<=
literal|1
condition|)
return|return;
name|clip_prepare
argument_list|(
name|clp
argument_list|)
expr_stmt|;
while|while
condition|(
name|rp
operator|!=
operator|&
name|clp
operator|->
name|first
condition|)
block|{
name|gx_clip_rect
modifier|*
name|prev
init|=
name|rp
operator|->
name|prev
decl_stmt|;
call|(
modifier|*
name|mp
operator|->
name|free
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|gx_clip_rect
argument_list|)
argument_list|,
literal|"gx_clip_list_free"
argument_list|)
expr_stmt|;
name|rp
operator|=
name|prev
expr_stmt|;
block|}
name|gx_clip_list_init
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare a clip list for enumeration, */
end_comment

begin_comment
comment|/* by splicing pointers to account for possible relocation. */
end_comment

begin_function
name|private
name|void
name|clip_prepare
parameter_list|(
specifier|register
name|gx_clip_list
modifier|*
name|clp
parameter_list|)
block|{
if|if
condition|(
name|clp
operator|->
name|count
operator|<=
literal|1
condition|)
block|{
name|clp
operator|->
name|first
operator|.
name|next
operator|=
name|clp
operator|->
name|last
operator|.
name|prev
operator|=
operator|&
name|clp
operator|->
name|sole
expr_stmt|;
name|clp
operator|->
name|sole
operator|.
name|prev
operator|=
operator|&
name|clp
operator|->
name|first
expr_stmt|;
name|clp
operator|->
name|sole
operator|.
name|next
operator|=
operator|&
name|clp
operator|->
name|last
expr_stmt|;
block|}
else|else
block|{
name|clp
operator|->
name|first
operator|.
name|next
operator|->
name|prev
operator|=
operator|&
name|clp
operator|->
name|first
expr_stmt|;
name|clp
operator|->
name|last
operator|.
name|prev
operator|->
name|next
operator|=
operator|&
name|clp
operator|->
name|last
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------ Rectangle list accumulator ------ */
end_comment

begin_comment
comment|/* Device for accumulating a clipping region. */
end_comment

begin_function_decl
name|private
name|dev_proc_open_device
parameter_list|(
name|accum_open
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_close_device
parameter_list|(
name|accum_close
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_fill_rectangle
parameter_list|(
name|accum_fill_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The device descriptor */
end_comment

begin_comment
comment|/* Many of these procedures won't be called; they are set to NULL. */
end_comment

begin_decl_stmt
name|private
name|gx_device_procs
name|accum_procs
init|=
block|{
name|accum_open
block|,
name|NULL
block|,
comment|/* get_initial_matrix */
name|NULL
block|,
comment|/* sync_output */
name|NULL
block|,
comment|/* output_page */
name|accum_close
block|,
name|NULL
block|,
comment|/* map_rgb_color */
name|NULL
block|,
comment|/* map_color_rgb */
name|accum_fill_rectangle
block|,
name|NULL
block|,
comment|/* tile_rectangle */
name|NULL
block|,
comment|/* copy_mono */
name|NULL
block|,
comment|/* copy_color */
name|NULL
block|,
comment|/* draw_line */
name|NULL
block|,
comment|/* get_bits */
name|NULL
block|,
comment|/* get_props */
name|NULL
comment|/* put_props */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_accum
name|gs_accum_device
init|=
block|{
sizeof|sizeof
argument_list|(
name|gx_device_accum
argument_list|)
block|,
operator|&
name|accum_procs
block|,
literal|"clip list accumulator"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
name|no_margins
block|,
name|dci_black_and_white
block|,
literal|0
comment|/* generic */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|adev
value|((gx_device_accum *)dev)
end_define

begin_comment
comment|/* Initialize the accumulation device. */
end_comment

begin_function
name|private
name|int
name|accum_open
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|gx_clip_list_init
argument_list|(
operator|&
name|adev
operator|->
name|list
argument_list|)
expr_stmt|;
name|adev
operator|->
name|last
operator|=
operator|&
name|adev
operator|->
name|list
operator|.
name|first
expr_stmt|;
name|adev
operator|->
name|bbox
operator|.
name|p
operator|.
name|x
operator|=
name|adev
operator|->
name|bbox
operator|.
name|p
operator|.
name|y
operator|=
name|max_int
expr_stmt|;
name|adev
operator|->
name|bbox
operator|.
name|q
operator|.
name|x
operator|=
name|adev
operator|->
name|bbox
operator|.
name|q
operator|.
name|y
operator|=
name|min_int
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Close the accumulation device. */
end_comment

begin_function
name|private
name|int
name|accum_close
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|adev
operator|->
name|list
operator|.
name|count
operator|>=
literal|2
condition|)
block|{
comment|/* 'sole' isn't good for much of anything, */
comment|/* and it complicates the bookkeeping.... */
name|gx_clip_rect
modifier|*
name|last
init|=
name|adev
operator|->
name|last
decl_stmt|;
name|gx_clip_rect
modifier|*
name|ar
init|=
operator|(
name|gx_clip_rect
operator|*
operator|)
call|(
modifier|*
name|adev
operator|->
name|memory_procs
operator|.
name|alloc
call|)
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|gx_clip_rect
argument_list|)
argument_list|,
literal|"accum_close"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ar
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
operator|*
name|ar
operator|=
name|adev
operator|->
name|list
operator|.
name|sole
expr_stmt|;
name|adev
operator|->
name|list
operator|.
name|sole
operator|.
name|prev
operator|->
name|next
operator|=
name|ar
expr_stmt|;
if|if
condition|(
name|last
operator|==
operator|&
name|adev
operator|->
name|list
operator|.
name|sole
condition|)
name|last
operator|=
name|ar
expr_stmt|;
else|else
name|adev
operator|->
name|list
operator|.
name|sole
operator|.
name|next
operator|->
name|prev
operator|=
name|ar
expr_stmt|;
name|adev
operator|->
name|list
operator|.
name|last
operator|.
name|prev
operator|=
name|last
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'q'
index|]
condition|)
block|{
name|gx_clip_rect
modifier|*
name|rp
init|=
operator|&
name|adev
operator|->
name|list
operator|.
name|first
decl_stmt|;
name|adev
operator|->
name|last
operator|->
name|next
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
name|clip_rect_print
argument_list|(
literal|"   "
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rp
operator|->
name|next
expr_stmt|;
block|}
block|}
name|clip_prepare
argument_list|(
operator|&
name|adev
operator|->
name|list
argument_list|)
expr_stmt|;
comment|/* just for clip_list_validate */
name|clip_list_validate
argument_list|(
operator|&
name|adev
operator|->
name|list
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Accumulate one rectangle. */
end_comment

begin_define
define|#
directive|define
name|accum_alloc
parameter_list|(
name|s
parameter_list|,
name|ar
parameter_list|,
name|px
parameter_list|,
name|py
parameter_list|,
name|qx
parameter_list|,
name|qy
parameter_list|)
define|\
value|{	ar = (adev->list.count == 0 ?&adev->list.sole :\ 	   (gx_clip_rect *)(*adev->memory_procs.alloc)(1, sizeof(gx_clip_rect), "accum_rect"));\ 	if ( ar == 0 ) return_error(gs_error_VMerror);\ 	ar->xmin = px, ar->ymin = py, ar->xmax = qx, ar->ymax = qy;\ 	adev->list.count++;\ 	clip_rect_print(s, ar);\    }
end_define

begin_define
define|#
directive|define
name|accum_add_last
parameter_list|(
name|ar
parameter_list|)
define|\
value|adev->last->next = ar, ar->prev = adev->last, adev->last = ar
end_define

begin_define
define|#
directive|define
name|accum_add_after
parameter_list|(
name|ar
parameter_list|,
name|rprev
parameter_list|)
define|\
value|ar->prev = rprev, ar->next = rprev->next;\ 	if ( rprev != adev->last ) rprev->next->prev = ar;\ 	else adev->last = ar;\ 	rprev->next = ar
end_define

begin_define
define|#
directive|define
name|accum_add_before
parameter_list|(
name|ar
parameter_list|,
name|rnext
parameter_list|)
define|\
value|ar->prev = rnext->prev, ar->next = rnext,\ 	  rnext->prev->next = ar, rnext->prev = ar
end_define

begin_comment
comment|/* Add a rectangle to the list.  It would be wonderful if rectangles */
end_comment

begin_comment
comment|/* were always presented in the correct order, but they aren't, */
end_comment

begin_comment
comment|/* because the fill loop works by trapezoids, not by scan lines. */
end_comment

begin_comment
comment|/* All we can count on is that they are disjoint and *approximately* */
end_comment

begin_comment
comment|/* in order. */
end_comment

begin_undef
undef|#
directive|undef
name|adev
end_undef

begin_function
name|private
name|int
name|accum_add_rect
parameter_list|(
name|gx_device_accum
modifier|*
name|adev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|xe
parameter_list|,
name|int
name|ye
parameter_list|)
block|{
name|gx_clip_rect
modifier|*
name|nr
decl_stmt|,
modifier|*
name|ar
decl_stmt|,
modifier|*
name|rptr
decl_stmt|;
name|int
name|ymin
decl_stmt|,
name|ymax
decl_stmt|;
name|top
label|:
name|rptr
operator|=
name|adev
operator|->
name|last
expr_stmt|;
name|accum_alloc
argument_list|(
literal|"accum"
argument_list|,
name|nr
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|rptr
operator|->
name|ymax
operator|||
name|y
operator|==
name|rptr
operator|->
name|ymin
operator|&&
name|ye
operator|==
name|rptr
operator|->
name|ymax
operator|&&
name|x
operator|>=
name|rptr
operator|->
name|xmax
condition|)
block|{
name|accum_add_last
argument_list|(
name|nr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Work backwards till we find the insertion point. */
while|while
condition|(
name|ye
operator|<=
name|rptr
operator|->
name|ymin
condition|)
name|rptr
operator|=
name|rptr
operator|->
name|prev
expr_stmt|;
name|ymin
operator|=
name|rptr
operator|->
name|ymin
expr_stmt|;
name|ymax
operator|=
name|rptr
operator|->
name|ymax
expr_stmt|;
if|if
condition|(
name|ye
operator|>
name|ymax
condition|)
block|{
if|if
condition|(
name|y
operator|>=
name|ymax
condition|)
block|{
comment|/* Insert between two bands. */
name|accum_add_after
argument_list|(
name|nr
argument_list|,
name|rptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Split off the top part of the new rectangle. */
name|accum_alloc
argument_list|(
literal|"a.top"
argument_list|,
name|ar
argument_list|,
name|x
argument_list|,
name|ymax
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
expr_stmt|;
name|accum_add_after
argument_list|(
name|ar
argument_list|,
name|rptr
argument_list|)
expr_stmt|;
name|ye
operator|=
name|nr
operator|->
name|ymax
operator|=
name|ymax
expr_stmt|;
name|clip_rect_print
argument_list|(
literal|" ymax"
argument_list|,
name|nr
argument_list|)
expr_stmt|;
block|}
comment|/* Here we know ymin< ye<= ymax; */
comment|/* rptr points to the last node with this value of ymin/ymax. */
comment|/* Split the existing band if necessary. */
if|if
condition|(
name|ye
operator|<
name|ymax
condition|)
block|{
name|gx_clip_rect
modifier|*
name|rsplit
init|=
name|rptr
decl_stmt|;
while|while
condition|(
name|rsplit
operator|->
name|ymax
operator|==
name|ymax
condition|)
block|{
name|accum_alloc
argument_list|(
literal|"s.top"
argument_list|,
name|ar
argument_list|,
name|rsplit
operator|->
name|xmin
argument_list|,
name|ye
argument_list|,
name|rsplit
operator|->
name|xmax
argument_list|,
name|ymax
argument_list|)
expr_stmt|;
name|accum_add_after
argument_list|(
name|ar
argument_list|,
name|rptr
argument_list|)
expr_stmt|;
name|rsplit
operator|->
name|ymax
operator|=
name|ye
expr_stmt|;
name|rsplit
operator|=
name|rsplit
operator|->
name|prev
expr_stmt|;
block|}
name|ymax
operator|=
name|ye
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|>
name|ymin
condition|)
block|{
name|gx_clip_rect
modifier|*
name|rbot
init|=
name|rptr
decl_stmt|,
modifier|*
name|rsplit
decl_stmt|;
while|while
condition|(
name|rbot
operator|->
name|prev
operator|->
name|ymin
operator|==
name|ymin
condition|)
name|rbot
operator|=
name|rbot
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|rsplit
operator|=
name|rbot
init|;
condition|;
control|)
block|{
name|accum_alloc
argument_list|(
literal|"s.bot"
argument_list|,
name|ar
argument_list|,
name|rsplit
operator|->
name|xmin
argument_list|,
name|ymin
argument_list|,
name|rsplit
operator|->
name|xmax
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|accum_add_before
argument_list|(
name|ar
argument_list|,
name|rbot
argument_list|)
expr_stmt|;
name|rsplit
operator|->
name|ymin
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|rsplit
operator|==
name|rptr
condition|)
break|break;
name|rsplit
operator|=
name|rsplit
operator|->
name|next
expr_stmt|;
block|}
name|ymin
operator|=
name|y
expr_stmt|;
block|}
comment|/* Search for the X insertion point. */
comment|/* The new rectangle is guaranteed disjoint from all the old ones. */
while|while
condition|(
name|rptr
operator|->
name|ymin
operator|==
name|ymin
operator|&&
name|x
operator|<
name|rptr
operator|->
name|xmax
condition|)
block|{
name|rptr
operator|=
name|rptr
operator|->
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
name|ymin
condition|)
block|{
comment|/* Continue with the bottom part of the new rectangle. */
name|nr
operator|->
name|ymin
operator|=
name|ymin
expr_stmt|;
name|clip_rect_print
argument_list|(
literal|" ymin"
argument_list|,
name|nr
argument_list|)
expr_stmt|;
name|accum_add_after
argument_list|(
name|nr
argument_list|,
name|rptr
argument_list|)
expr_stmt|;
name|ye
operator|=
name|ymin
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|accum_add_after
argument_list|(
name|nr
argument_list|,
name|rptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|adev
value|((gx_device_accum *)dev)
end_define

begin_function
name|private
name|int
name|accum_fill_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|int
name|xe
decl_stmt|,
name|ye
decl_stmt|;
if|if
condition|(
name|w
operator|<=
literal|0
operator|||
name|h
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|xe
operator|=
name|x
operator|+
name|w
operator|,
name|ye
operator|=
name|y
operator|+
name|h
expr_stmt|;
comment|/* Update the bounding box. */
if|if
condition|(
name|x
operator|<
name|adev
operator|->
name|bbox
operator|.
name|p
operator|.
name|x
condition|)
name|adev
operator|->
name|bbox
operator|.
name|p
operator|.
name|x
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|adev
operator|->
name|bbox
operator|.
name|p
operator|.
name|y
condition|)
name|adev
operator|->
name|bbox
operator|.
name|p
operator|.
name|y
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|xe
operator|>
name|adev
operator|->
name|bbox
operator|.
name|q
operator|.
name|x
condition|)
name|adev
operator|->
name|bbox
operator|.
name|q
operator|.
name|x
operator|=
name|xe
expr_stmt|;
if|if
condition|(
name|ye
operator|>
name|adev
operator|->
name|bbox
operator|.
name|q
operator|.
name|y
condition|)
name|adev
operator|->
name|bbox
operator|.
name|q
operator|.
name|y
operator|=
name|ye
expr_stmt|;
return|return
name|accum_add_rect
argument_list|(
name|adev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------ Rectangle list clipper ------ */
end_comment

begin_comment
comment|/* Device for clipping with a region. */
end_comment

begin_function_decl
name|private
name|dev_proc_open_device
parameter_list|(
name|clip_open
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_map_rgb_color
parameter_list|(
name|clip_map_rgb_color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_map_color_rgb
parameter_list|(
name|clip_map_color_rgb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_fill_rectangle
parameter_list|(
name|clip_fill_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_tile_rectangle
parameter_list|(
name|clip_tile_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_copy_mono
parameter_list|(
name|clip_copy_mono
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_copy_color
parameter_list|(
name|clip_copy_color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_get_bits
parameter_list|(
name|clip_get_bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_get_props
parameter_list|(
name|clip_get_props
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_put_props
parameter_list|(
name|clip_put_props
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The device descriptor. */
end_comment

begin_decl_stmt
name|private
name|gx_device_procs
name|clip_procs
init|=
block|{
name|clip_open
block|,
name|gx_default_get_initial_matrix
block|,
name|gx_default_sync_output
block|,
name|gx_default_output_page
block|,
name|gx_default_close_device
block|,
name|clip_map_rgb_color
block|,
name|clip_map_color_rgb
block|,
name|clip_fill_rectangle
block|,
name|clip_tile_rectangle
block|,
name|clip_copy_mono
block|,
name|clip_copy_color
block|,
name|gx_default_draw_line
block|,
name|clip_get_bits
block|,
name|clip_get_props
block|,
name|clip_put_props
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_clip
name|gs_clip_device
init|=
block|{
sizeof|sizeof
argument_list|(
name|gx_device_clip
argument_list|)
block|,
operator|&
name|clip_procs
block|,
literal|"clipper"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
name|no_margins
block|,
name|dci_black_and_white
block|,
literal|0
comment|/* generic */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|rdev
value|((gx_device_clip *)dev)
end_define

begin_comment
comment|/* Declare and initialize the cursor variables. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|private
name|ulong
name|clip_in
decl_stmt|,
name|clip_down
decl_stmt|,
name|clip_down2
decl_stmt|,
name|clip_up
decl_stmt|,
name|clip_x
decl_stmt|,
name|clip_no_x
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|inc
parameter_list|(
name|v
parameter_list|)
value|v++
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|inc
parameter_list|(
name|v
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DECLARE_CLIP
define|\
value|register gx_clip_rect *rptr = rdev->current.rptr;\   gx_device *tdev = rdev->target;
end_define

begin_comment
comment|/* Check whether the rectangle x,y,w,h falls within the current entry. */
end_comment

begin_define
define|#
directive|define
name|xywh_in_ryptr
parameter_list|()
define|\
value|((y>= rptr->ymin&& y + h<= rptr->ymax&&\     x>= rptr->xmin&& x + w<= rptr->xmax) ? (inc(clip_in), 1) : 0)
end_define

begin_comment
comment|/*  * Warp the cursor forward or backward to the first rectangle row that  * could include a given y value.  Assumes rptr is set, and updates it.  * Specifically, after warp_cursor, y< rptr->ymax and y>= rptr->prev->ymax.  * Note that ye<= rptr->ymin is possible.  */
end_comment

begin_define
define|#
directive|define
name|warp_cursor
parameter_list|(
name|y
parameter_list|)
define|\
value|while ( (y)>= rptr->ymax ) { inc(clip_up); rptr = rptr->next; };\   while ( rptr->prev != 0&& (y)< rptr->prev->ymax )\    { inc(clip_down); rptr = rptr->prev; }
end_define

begin_comment
comment|/*  * Enumerate the rectangles of the x,w,y,h argument that fall within  * the clipping region.  Usage:  *	BEGIN_CLIP  *		... xc, yc, xec, yec ... [must be an expression statement]  *	NEXT_CLIP  *		(about to set yc to yec)  *	END_CLIP  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|clip_2_print
parameter_list|(
name|str
parameter_list|,
name|v1
parameter_list|,
name|v2
parameter_list|)
define|\
value|if ( gs_debug['q'] ) dprintf2(str, v1, v2)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|clip_2_print
parameter_list|(
name|str
parameter_list|,
name|v1
parameter_list|,
name|v2
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BEGIN_CLIP
define|\
value|if ( w<= 0 || h<= 0 ) return 0;\    {	int yc;\ 	const int xe = x + w, ye = y + h;\ 	warp_cursor(y);\ 	rdev->current.rptr = rptr;\ 	yc = rptr->ymin;\ 	if ( yc< y ) yc = y;\ 	else if ( yc>= ye ) return 0;\ 	for ( ; ; )\ 	   {	const int ymax = rptr->ymax;\ 		int yec = ymax;\ 		if ( yec> ye ) yec = ye;\ 		clip_2_print("[q]yc=%d yec=%d\n", yc, yec);\ 		do \ 		   {	int xc = rptr->xmin;\ 			int xec = rptr->xmax;\ 			if ( xc< x ) xc = x;\ 			if ( xec> xe ) xec = xe;\ 			if ( xec> xc )\ 			   {	int code;\ 				clip_rect_print("match", rptr);\ 				clip_2_print("[q]xc=%d xec=%d\n", xc, xec);\ 				inc(clip_x);\ 				code =
end_define

begin_define
define|#
directive|define
name|NEXT_CLIP
define|\
value|if ( code< 0 ) return code;\ 			   }\ 			else inc(clip_no_x);\ 		   }\ 		while ( (rptr = rptr->next) != 0&& rptr->ymax == ymax );\ 		if ( rptr == 0 || (yec = rptr->ymin)>= ye ) break;
end_define

begin_define
define|#
directive|define
name|END_CLIP
define|\
value|yc = yec;\ 	   }\    }
end_define

begin_comment
comment|/* Open a clipping device */
end_comment

begin_function
name|private
name|int
name|clip_open
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|gx_device
modifier|*
name|tdev
init|=
name|rdev
operator|->
name|target
decl_stmt|;
comment|/* Fix up possible dangling pointers. */
name|clip_prepare
argument_list|(
operator|&
name|rdev
operator|->
name|list
argument_list|)
expr_stmt|;
comment|/* Initialize the cursor. */
name|rdev
operator|->
name|current
operator|.
name|rptr
operator|=
operator|&
name|rdev
operator|->
name|list
operator|.
name|first
expr_stmt|;
name|rdev
operator|->
name|color_info
operator|=
name|tdev
operator|->
name|color_info
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Forward non-displaying operations to the target device. */
end_comment

begin_function
name|private
name|gx_color_index
name|clip_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_value
name|r
parameter_list|,
name|gx_color_value
name|g
parameter_list|,
name|gx_color_value
name|b
parameter_list|)
block|{
name|gx_device
modifier|*
name|tdev
init|=
name|rdev
operator|->
name|target
decl_stmt|;
return|return
call|(
modifier|*
name|tdev
operator|->
name|procs
operator|->
name|map_rgb_color
call|)
argument_list|(
name|tdev
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|clip_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|gx_color_value
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
name|gx_device
modifier|*
name|tdev
init|=
name|rdev
operator|->
name|target
decl_stmt|;
return|return
call|(
modifier|*
name|tdev
operator|->
name|procs
operator|->
name|map_color_rgb
call|)
argument_list|(
name|tdev
argument_list|,
name|color
argument_list|,
name|prgb
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|clip_get_props
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gs_prop_item
modifier|*
name|plist
parameter_list|)
block|{
name|gx_device
modifier|*
name|tdev
init|=
name|rdev
operator|->
name|target
decl_stmt|;
return|return
call|(
modifier|*
name|tdev
operator|->
name|procs
operator|->
name|get_props
call|)
argument_list|(
name|tdev
argument_list|,
name|plist
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|clip_put_props
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gs_prop_item
modifier|*
name|plist
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|gx_device
modifier|*
name|tdev
init|=
name|rdev
operator|->
name|target
decl_stmt|;
return|return
call|(
modifier|*
name|tdev
operator|->
name|procs
operator|->
name|put_props
call|)
argument_list|(
name|tdev
argument_list|,
name|plist
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fill a rectangle */
end_comment

begin_function
name|private
name|int
name|clip_fill_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|DECLARE_CLIP
name|dev_proc_fill_rectangle
argument_list|(
operator|(
operator|*
name|fill
operator|)
argument_list|)
init|=
name|tdev
operator|->
name|procs
operator|->
name|fill_rectangle
decl_stmt|;
if|if
condition|(
name|xywh_in_ryptr
argument_list|()
condition|)
return|return
call|(
modifier|*
name|fill
call|)
argument_list|(
name|tdev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|color
argument_list|)
return|;
name|BEGIN_CLIP
argument_list|(
operator|*
name|fill
argument_list|)
argument_list|(
name|tdev
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|xec
operator|-
name|xc
argument_list|,
name|yec
operator|-
name|yc
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|NEXT_CLIP
name|END_CLIP
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Tile a rectangle */
end_comment

begin_function
name|private
name|int
name|clip_tile_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_bitmap
modifier|*
name|tile
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color0
parameter_list|,
name|gx_color_index
name|color1
parameter_list|,
name|int
name|phase_x
parameter_list|,
name|int
name|phase_y
parameter_list|)
block|{
name|DECLARE_CLIP
name|dev_proc_tile_rectangle
argument_list|(
operator|(
operator|*
name|fill
operator|)
argument_list|)
init|=
name|tdev
operator|->
name|procs
operator|->
name|tile_rectangle
decl_stmt|;
if|if
condition|(
name|xywh_in_ryptr
argument_list|()
condition|)
return|return
call|(
modifier|*
name|fill
call|)
argument_list|(
name|tdev
argument_list|,
name|tile
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|color0
argument_list|,
name|color1
argument_list|,
name|phase_x
argument_list|,
name|phase_y
argument_list|)
return|;
name|BEGIN_CLIP
argument_list|(
operator|*
name|fill
argument_list|)
argument_list|(
name|tdev
argument_list|,
name|tile
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|xec
operator|-
name|xc
argument_list|,
name|yec
operator|-
name|yc
argument_list|,
name|color0
argument_list|,
name|color1
argument_list|,
name|phase_x
argument_list|,
name|phase_y
argument_list|)
expr_stmt|;
name|NEXT_CLIP
name|END_CLIP
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a monochrome rectangle */
end_comment

begin_function
name|private
name|int
name|clip_copy_mono
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color0
parameter_list|,
name|gx_color_index
name|color1
parameter_list|)
block|{
name|DECLARE_CLIP
name|dev_proc_copy_mono
argument_list|(
operator|(
operator|*
name|copy
operator|)
argument_list|)
init|=
name|tdev
operator|->
name|procs
operator|->
name|copy_mono
decl_stmt|;
if|if
condition|(
name|xywh_in_ryptr
argument_list|()
condition|)
return|return
call|(
modifier|*
name|copy
call|)
argument_list|(
name|tdev
argument_list|,
name|data
argument_list|,
name|sourcex
argument_list|,
name|raster
argument_list|,
name|id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|color0
argument_list|,
name|color1
argument_list|)
return|;
name|BEGIN_CLIP
argument_list|(
operator|*
name|copy
argument_list|)
argument_list|(
name|tdev
argument_list|,
name|data
argument_list|,
name|sourcex
operator|+
name|xc
operator|-
name|x
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|xec
operator|-
name|xc
argument_list|,
name|yec
operator|-
name|yc
argument_list|,
name|color0
argument_list|,
name|color1
argument_list|)
expr_stmt|;
name|NEXT_CLIP
name|data
operator|+=
operator|(
name|yec
operator|-
name|yc
operator|)
operator|*
name|raster
expr_stmt|;
name|END_CLIP
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a color rectangle */
end_comment

begin_function
name|private
name|int
name|clip_copy_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|DECLARE_CLIP
name|dev_proc_copy_color
argument_list|(
operator|(
operator|*
name|copy
operator|)
argument_list|)
init|=
name|tdev
operator|->
name|procs
operator|->
name|copy_color
decl_stmt|;
if|if
condition|(
name|xywh_in_ryptr
argument_list|()
condition|)
return|return
call|(
modifier|*
name|copy
call|)
argument_list|(
name|tdev
argument_list|,
name|data
argument_list|,
name|sourcex
argument_list|,
name|raster
argument_list|,
name|id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
return|;
name|BEGIN_CLIP
argument_list|(
operator|*
name|copy
argument_list|)
argument_list|(
name|tdev
argument_list|,
name|data
argument_list|,
name|sourcex
operator|+
name|xc
operator|-
name|x
argument_list|,
name|raster
argument_list|,
name|gx_no_bitmap_id
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|xec
operator|-
name|xc
argument_list|,
name|yec
operator|-
name|yc
argument_list|)
expr_stmt|;
name|NEXT_CLIP
name|data
operator|+=
operator|(
name|yec
operator|-
name|yc
operator|)
operator|*
name|raster
expr_stmt|;
name|END_CLIP
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get bits back from the device. */
end_comment

begin_function
name|private
name|int
name|clip_get_bits
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|y
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|size
parameter_list|,
name|int
name|pad
parameter_list|)
block|{
name|gx_device
modifier|*
name|tdev
init|=
name|rdev
operator|->
name|target
decl_stmt|;
return|return
call|(
modifier|*
name|tdev
operator|->
name|procs
operator|->
name|get_bits
call|)
argument_list|(
name|tdev
argument_list|,
name|y
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|pad
argument_list|)
return|;
block|}
end_function

end_unit

