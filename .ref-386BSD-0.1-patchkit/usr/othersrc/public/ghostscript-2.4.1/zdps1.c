begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1990, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zdps1.c */
end_comment

begin_comment
comment|/* Display PostScript graphics extensions */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"gsmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gspath.h"
end_include

begin_include
include|#
directive|include
file|"gsstate.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_include
include|#
directive|include
file|"bnum.h"
end_include

begin_comment
comment|/* ------ Graphics states ------ */
end_comment

begin_comment
comment|/* Structure for saving a graphics state. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|gstate_obj_s
block|{
name|int_gstate
name|istate
decl_stmt|;
name|gs_state
modifier|*
name|pgs
decl_stmt|;
block|}
name|gstate_obj
typedef|;
end_typedef

begin_comment
comment|/* gstate */
end_comment

begin_function
name|int
name|zgstate
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_state
modifier|*
name|pnew
init|=
name|gs_gstate
argument_list|(
name|igs
argument_list|)
decl_stmt|;
name|gstate_obj
modifier|*
name|pso
init|=
operator|(
name|gstate_obj
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|gstate_obj
argument_list|)
argument_list|,
literal|"gstate"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pnew
operator|==
literal|0
operator|||
name|pso
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|pso
operator|->
name|istate
operator|=
name|istate
expr_stmt|;
name|int_gstate_map_refs
argument_list|(
operator|&
name|pso
operator|->
name|istate
argument_list|,
name|ref_mark_new
argument_list|)
expr_stmt|;
name|pso
operator|->
name|pgs
operator|=
name|pnew
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_tv
argument_list|(
name|op
argument_list|,
name|t_gstate
argument_list|,
name|pgstate
argument_list|,
name|pso
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currentgstate */
end_comment

begin_function
name|int
name|zcurrentgstate
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|int_gstate
modifier|*
name|pistate
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_gstate
argument_list|)
expr_stmt|;
comment|/****** DOESN'T GET FULLY UNDONE BY RESTORE ******/
name|code
operator|=
name|gs_currentgstate
argument_list|(
name|op
operator|->
name|value
operator|.
name|pgstate
operator|->
name|pgs
argument_list|,
name|igs
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pistate
operator|=
operator|&
name|op
operator|->
name|value
operator|.
name|pgstate
operator|->
name|istate
expr_stmt|;
define|#
directive|define
name|gsref_save
parameter_list|(
name|p
parameter_list|)
value|ref_save(p, "currentgstate")
name|int_gstate_map_refs
argument_list|(
name|pistate
argument_list|,
name|gsref_save
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|gsref_save
operator|*
name|pistate
operator|=
name|istate
expr_stmt|;
name|int_gstate_map_refs
argument_list|(
name|pistate
argument_list|,
name|ref_mark_new
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* setgstate */
end_comment

begin_function
name|int
name|zsetgstate
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_gstate
argument_list|)
expr_stmt|;
name|code
operator|=
name|gs_setgstate
argument_list|(
name|igs
argument_list|,
name|op
operator|->
name|value
operator|.
name|pgstate
operator|->
name|pgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|istate
operator|=
name|op
operator|->
name|value
operator|.
name|pgstate
operator|->
name|istate
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Rectangles ------- */
end_comment

begin_comment
comment|/* We preallocate a short list for rectangles, because */
end_comment

begin_comment
comment|/* the rectangle operators usually will involve very few rectangles. */
end_comment

begin_define
define|#
directive|define
name|max_local_rect
value|5
end_define

begin_typedef
typedef|typedef
struct|struct
name|local_rects_s
block|{
name|gs_rect
modifier|*
name|pr
decl_stmt|;
name|uint
name|count
decl_stmt|;
name|gs_rect
name|rl
index|[
name|max_local_rect
index|]
decl_stmt|;
block|}
name|local_rects
typedef|;
end_typedef

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|rect_get
argument_list|(
name|P2
argument_list|(
name|local_rects
operator|*
argument_list|,
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|rect_release
argument_list|(
name|P1
argument_list|(
name|local_rects
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rectappend */
end_comment

begin_function
name|int
name|zrectappend
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|local_rects
name|lr
decl_stmt|;
name|int
name|npop
init|=
name|rect_get
argument_list|(
operator|&
name|lr
argument_list|,
name|op
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|npop
operator|<
literal|0
condition|)
return|return
name|npop
return|;
name|code
operator|=
name|gs_rectappend
argument_list|(
name|igs
argument_list|,
name|lr
operator|.
name|pr
argument_list|,
name|lr
operator|.
name|count
argument_list|)
expr_stmt|;
name|rect_release
argument_list|(
operator|&
name|lr
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
name|npop
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* rectclip */
end_comment

begin_function
name|int
name|zrectclip
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|local_rects
name|lr
decl_stmt|;
name|int
name|npop
init|=
name|rect_get
argument_list|(
operator|&
name|lr
argument_list|,
name|op
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|npop
operator|<
literal|0
condition|)
return|return
name|npop
return|;
name|code
operator|=
name|gs_rectclip
argument_list|(
name|igs
argument_list|,
name|lr
operator|.
name|pr
argument_list|,
name|lr
operator|.
name|count
argument_list|)
expr_stmt|;
name|rect_release
argument_list|(
operator|&
name|lr
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
name|npop
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* rectfill */
end_comment

begin_function
name|int
name|zrectfill
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|local_rects
name|lr
decl_stmt|;
name|int
name|npop
init|=
name|rect_get
argument_list|(
operator|&
name|lr
argument_list|,
name|op
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|npop
operator|<
literal|0
condition|)
return|return
name|npop
return|;
name|code
operator|=
name|gs_rectfill
argument_list|(
name|igs
argument_list|,
name|lr
operator|.
name|pr
argument_list|,
name|lr
operator|.
name|count
argument_list|)
expr_stmt|;
name|rect_release
argument_list|(
operator|&
name|lr
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
name|npop
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* rectstroke */
end_comment

begin_function
name|int
name|zrectstroke
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_matrix
name|mat
decl_stmt|;
name|local_rects
name|lr
decl_stmt|;
name|int
name|npop
decl_stmt|,
name|code
decl_stmt|;
if|if
condition|(
name|read_matrix
argument_list|(
name|op
argument_list|,
operator|&
name|mat
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Concatenate the matrix to the CTM just before */
comment|/* stroking the path. */
name|npop
operator|=
name|rect_get
argument_list|(
operator|&
name|lr
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|npop
operator|<
literal|0
condition|)
return|return
name|npop
return|;
name|code
operator|=
name|gs_rectstroke
argument_list|(
name|igs
argument_list|,
name|lr
operator|.
name|pr
argument_list|,
name|lr
operator|.
name|count
argument_list|,
operator|&
name|mat
argument_list|)
expr_stmt|;
name|npop
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* No matrix. */
name|npop
operator|=
name|rect_get
argument_list|(
operator|&
name|lr
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|npop
operator|<
literal|0
condition|)
return|return
name|npop
return|;
name|code
operator|=
name|gs_rectstroke
argument_list|(
name|igs
argument_list|,
name|lr
operator|.
name|pr
argument_list|,
name|lr
operator|.
name|count
argument_list|,
operator|(
name|gs_matrix
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|rect_release
argument_list|(
operator|&
name|lr
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
name|npop
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --- Internal routines --- */
end_comment

begin_comment
comment|/* Get rectangles from the stack. */
end_comment

begin_comment
comment|/* Return the number of elements to pop (>0) if OK,<0 if error. */
end_comment

begin_function
name|private
name|int
name|rect_get
parameter_list|(
name|local_rects
modifier|*
name|plr
parameter_list|,
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|,
name|npop
decl_stmt|;
name|stream
name|st
decl_stmt|;
name|uint
name|n
decl_stmt|,
name|count
decl_stmt|;
name|gs_rect
modifier|*
name|pr
decl_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_array
case|:
case|case
name|t_string
case|:
name|code
operator|=
name|sread_num_array
argument_list|(
operator|&
name|st
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|count
operator|=
name|scount_num_stream
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|%
literal|4
condition|)
return|return
name|e_typecheck
return|;
name|count
operator|/=
literal|4
operator|,
name|npop
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* better be 4 numbers */
name|sread_string
argument_list|(
operator|&
name|st
argument_list|,
operator|(
name|byte
operator|*
operator|)
operator|(
name|op
operator|-
literal|3
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|st
operator|.
name|num_format
operator|=
name|num_array
expr_stmt|;
name|count
operator|=
literal|1
operator|,
name|npop
operator|=
literal|4
expr_stmt|;
break|break;
block|}
name|plr
operator|->
name|count
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|<=
name|max_local_rect
condition|)
name|pr
operator|=
name|plr
operator|->
name|rl
expr_stmt|;
else|else
block|{
name|pr
operator|=
operator|(
name|gs_rect
operator|*
operator|)
name|alloc
argument_list|(
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_rect
argument_list|)
argument_list|,
literal|"rect_get"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
block|}
name|plr
operator|->
name|pr
operator|=
name|pr
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
operator|,
name|pr
operator|++
control|)
block|{
name|ref
name|rnum
decl_stmt|;
name|float
name|rv
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|code
operator|=
name|sget_encoded_number
argument_list|(
operator|&
name|st
argument_list|,
operator|&
name|rnum
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
name|rv
index|[
name|i
index|]
operator|=
name|rnum
operator|.
name|value
operator|.
name|intval
expr_stmt|;
break|break;
case|case
name|t_real
case|:
name|rv
index|[
name|i
index|]
operator|=
name|rnum
operator|.
name|value
operator|.
name|realval
expr_stmt|;
break|break;
default|default:
comment|/* code< 0 */
return|return
name|code
return|;
block|}
block|}
name|pr
operator|->
name|q
operator|.
name|x
operator|=
operator|(
name|pr
operator|->
name|p
operator|.
name|x
operator|=
name|rv
index|[
literal|0
index|]
operator|)
operator|+
name|rv
index|[
literal|2
index|]
expr_stmt|;
name|pr
operator|->
name|q
operator|.
name|y
operator|=
operator|(
name|pr
operator|->
name|p
operator|.
name|y
operator|=
name|rv
index|[
literal|1
index|]
operator|)
operator|+
name|rv
index|[
literal|3
index|]
expr_stmt|;
block|}
return|return
name|npop
return|;
block|}
end_function

begin_comment
comment|/* Release the rectangle list if needed. */
end_comment

begin_function
name|private
name|void
name|rect_release
parameter_list|(
name|local_rects
modifier|*
name|plr
parameter_list|)
block|{
if|if
condition|(
name|plr
operator|->
name|pr
operator|!=
name|plr
operator|->
name|rl
condition|)
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|plr
operator|->
name|pr
argument_list|,
name|plr
operator|->
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_rect
argument_list|)
argument_list|,
literal|"rect_release"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Graphics state ------ */
end_comment

begin_comment
comment|/* currentstrokeadjust */
end_comment

begin_function
name|int
name|zcurrentstrokeadjust
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
name|gs_currentstrokeadjust
argument_list|(
name|igs
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* setbbox */
end_comment

begin_function
name|int
name|zsetbbox
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|box
index|[
literal|4
index|]
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|4
argument_list|,
name|box
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_setbbox
argument_list|(
name|igs
argument_list|,
name|box
index|[
literal|0
index|]
argument_list|,
name|box
index|[
literal|1
index|]
argument_list|,
name|box
index|[
literal|2
index|]
argument_list|,
name|box
index|[
literal|3
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* setstrokeadjust */
end_comment

begin_function
name|int
name|zsetstrokeadjust
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_boolean
argument_list|)
expr_stmt|;
name|gs_setstrokeadjust
argument_list|(
name|igs
argument_list|,
name|op
operator|->
name|value
operator|.
name|index
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zdps1_op_defs
index|[]
init|=
block|{
comment|/* Graphics state objects */
block|{
literal|"0gstate"
block|,
name|zgstate
block|}
block|,
block|{
literal|"1currentgstate"
block|,
name|zcurrentgstate
block|}
block|,
block|{
literal|"1setgstate"
block|,
name|zsetgstate
block|}
block|,
comment|/* Rectangles */
block|{
literal|"1rectappend"
block|,
name|zrectappend
block|}
block|,
block|{
literal|"1rectclip"
block|,
name|zrectclip
block|}
block|,
block|{
literal|"1rectfill"
block|,
name|zrectfill
block|}
block|,
block|{
literal|"1rectstroke"
block|,
name|zrectstroke
block|}
block|,
comment|/* Graphics state components */
block|{
literal|"0currentstrokeadjust"
block|,
name|zcurrentstrokeadjust
block|}
block|,
block|{
literal|"4setbbox"
block|,
name|zsetbbox
block|}
block|,
block|{
literal|"1setstrokeadjust"
block|,
name|zsetstrokeadjust
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

