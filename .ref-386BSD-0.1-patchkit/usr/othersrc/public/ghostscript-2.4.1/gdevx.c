begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevx.c */
end_comment

begin_comment
comment|/* X Windows driver for Ghostscript library */
end_comment

begin_comment
comment|/* The X include files include<sys/types.h>, which, on some machines */
end_comment

begin_comment
comment|/* at least, define uint, ushort, and ulong, which std.h also defines. */
end_comment

begin_comment
comment|/* std.h has taken care of this. */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_comment
comment|/* for gx_bitmap; includes std.h */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"x_.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_include
include|#
directive|include
file|"gdevx.h"
end_include

begin_comment
comment|/* Flags for patching around bugs in the X library */
end_comment

begin_decl_stmt
name|private
name|int
name|use_XPutImage
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|use_XSetTile
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the maximum size of the temporary pixmap for copy_mono */
end_comment

begin_comment
comment|/* that we are willing to leave lying around in the server */
end_comment

begin_comment
comment|/* between uses.  (Assume 32-bit ints here!) */
end_comment

begin_decl_stmt
name|private
name|int
name|max_temp_pixmap
init|=
literal|20000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|set_tile
argument_list|(
name|P2
argument_list|(
name|gx_device
operator|*
argument_list|,
name|gx_bitmap
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|free_cp
argument_list|(
name|P1
argument_list|(
name|gx_device
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Screen updating machinery */
end_comment

begin_define
define|#
directive|define
name|update_init
parameter_list|(
name|dev
parameter_list|)
define|\
value|((gx_device_X *)(dev))->up_area = 0,\   ((gx_device_X *)(dev))->up_count = 0
end_define

begin_define
define|#
directive|define
name|update_flush
parameter_list|(
name|dev
parameter_list|)
define|\
value|if ( ((gx_device_X *)(dev))->up_area != 0 ) update_do_flush(dev)
end_define

begin_decl_stmt
name|private
name|void
name|update_do_flush
argument_list|(
name|P1
argument_list|(
name|gx_device
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|update_add
argument_list|(
name|P5
argument_list|(
name|gx_device
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|send_event
argument_list|(
name|P2
argument_list|(
name|gx_device
operator|*
argument_list|,
name|Atom
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Procedures */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|gdev_x_open
argument_list|(
name|P1
argument_list|(
name|gx_device_X
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|private
name|dev_proc_open_device
parameter_list|(
name|x_open
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_get_initial_matrix
parameter_list|(
name|x_get_initial_matrix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_sync_output
parameter_list|(
name|x_sync
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_output_page
parameter_list|(
name|x_output_page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_close_device
parameter_list|(
name|x_close
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_map_rgb_color
parameter_list|(
name|x_map_rgb_color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_map_color_rgb
parameter_list|(
name|x_map_color_rgb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_fill_rectangle
parameter_list|(
name|x_fill_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_tile_rectangle
parameter_list|(
name|x_tile_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_copy_mono
parameter_list|(
name|x_copy_mono
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_copy_color
parameter_list|(
name|x_copy_color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_draw_line
parameter_list|(
name|x_draw_line
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The device descriptor */
end_comment

begin_decl_stmt
name|private
name|gx_device_procs
name|x_procs
init|=
block|{
name|x_open
block|,
name|x_get_initial_matrix
block|,
name|x_sync
block|,
name|x_output_page
block|,
name|x_close
block|,
name|x_map_rgb_color
block|,
name|x_map_color_rgb
block|,
name|x_fill_rectangle
block|,
name|x_tile_rectangle
block|,
name|x_copy_mono
block|,
name|x_copy_color
block|,
name|x_draw_line
block|,
name|gx_default_get_bits
block|,
name|gx_default_get_props
block|,
name|gx_default_put_props
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The instance is public. */
end_comment

begin_decl_stmt
name|gx_device_X
name|gs_x11_device
init|=
block|{
sizeof|sizeof
argument_list|(
name|gx_device_X
argument_list|)
block|,
operator|&
name|x_procs
block|,
literal|"x11"
block|,
call|(
name|int
call|)
argument_list|(
name|FAKE_RES
operator|*
name|DEFAULT_WIDTH_INCHES
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
name|FAKE_RES
operator|*
name|DEFAULT_HEIGHT_INCHES
argument_list|)
block|,
comment|/* x and y extent (nominal) */
name|FAKE_RES
block|,
name|FAKE_RES
block|,
comment|/* x and y density (nominal) */
name|no_margins
block|,
name|dci_black_and_white
block|,
literal|0
block|,
comment|/* connection not initialized */
block|{
comment|/* image */
literal|0
block|,
literal|0
block|,
comment|/* width, height */
literal|0
block|,
name|XYBitmap
block|,
name|NULL
block|,
comment|/* xoffset, format, data */
name|LSBFirst
block|,
literal|8
block|,
comment|/* byte-order, bitmap-unit */
name|MSBFirst
block|,
literal|8
block|,
literal|1
block|,
comment|/* bitmap-bit-order, bitmap-pad, depth */
literal|0
block|,
literal|1
block|,
comment|/* bytes_per_line, bits_per_pixel */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* red_mask, green_mask, blue_mask */
name|NULL
block|,
comment|/* *obdata */
block|{
name|NULL
block|,
comment|/* *(*create_image)() */
name|NULL
block|,
comment|/* (*destroy_image)() */
name|NULL
block|,
comment|/* (*get_pixel)() */
name|NULL
block|,
comment|/* (*put_pixel)() */
name|NULL
block|,
comment|/* *(*sub_image)() */
name|NULL
comment|/* (*add_pixel)() */
block|}
block|, 	}
block|,
name|NULL
block|,
name|NULL
block|,
comment|/* dpy, scr */
comment|/* (connection not initialized) */
name|NULL
block|,
comment|/* vinfo */
operator|(
name|Colormap
operator|)
name|None
block|,
comment|/* cmap */
operator|(
name|Window
operator|)
name|None
block|,
comment|/* win */
name|NULL
block|,
comment|/* gc */
operator|(
name|Pixmap
operator|)
literal|0
block|,
comment|/* bpixmap */
literal|0
block|,
comment|/* ghostview */
operator|(
name|Window
operator|)
name|None
block|,
comment|/* mwin */
if|#
directive|if
name|HaveStdCMap
name|NULL
block|,
comment|/* std_cmap */
endif|#
directive|endif
name|identity_matrix_body
block|,
comment|/* initial matrix (filled in) */
operator|(
name|Atom
operator|)
literal|0
block|,
operator|(
name|Atom
operator|)
literal|0
block|,
operator|(
name|Atom
operator|)
literal|0
block|,
comment|/* Atoms: NEXT, PAGE, DONE */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
comment|/* update, up_area, up_count */
operator|(
name|Pixmap
operator|)
literal|0
block|,
comment|/* dest */
literal|0L
block|,
operator|~
literal|0L
block|,
comment|/* colors_or, colors_and */
block|{
comment|/* cp */
operator|(
name|Pixmap
operator|)
literal|0
block|,
comment|/* pixmap */
name|NULL
block|,
comment|/* gc */
operator|-
literal|1
block|,
operator|-
literal|1
comment|/* raster, height */
block|}
block|,
block|{
comment|/* ht */
operator|(
name|Pixmap
operator|)
name|None
block|,
comment|/* pixmap */
operator|(
name|Pixmap
operator|)
name|None
block|,
comment|/* no_pixmap */
name|gx_no_bitmap_id
block|,
comment|/* id */
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* width, height, raster */
literal|0
block|,
literal|0
comment|/* fore_c, back_c */
block|}
block|,
name|GXcopy
block|,
comment|/* function */
name|FillSolid
block|,
comment|/* fill_style */
literal|0
block|,
comment|/* pixel_fix */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* colors[8] */
literal|0
block|,
literal|0
comment|/* back_color, fore_color */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro for casting gx_device argument */
end_comment

begin_define
define|#
directive|define
name|xdev
value|((gx_device_X *)dev)
end_define

begin_comment
comment|/* Macros to validate and coerce arguments */
end_comment

begin_define
define|#
directive|define
name|check_rect_extent
parameter_list|()
define|\
value|if ( x + w> xdev->width ) w = xdev->width - x;\ 	if ( y + h> xdev->height ) h = xdev->height - y;\ 	if ( w<= 0 || h<= 0 ) return 0
end_define

begin_define
define|#
directive|define
name|check_rect
parameter_list|()
define|\
value|if ( x< 0 ) w += x, x = 0;\ 	if ( y< 0 ) h += y, y = 0;\ 	check_rect_extent()
end_define

begin_comment
comment|/* If XPutImage doesn't work, do it ourselves. */
end_comment

begin_function_decl
name|private
name|void
name|alt_put_image
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|put_image
parameter_list|(
name|dpy
parameter_list|,
name|win
parameter_list|,
name|gc
parameter_list|,
name|im
parameter_list|,
name|sx
parameter_list|,
name|sy
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|,
name|h
parameter_list|)
define|\
value|if ( use_XPutImage) XPutImage(dpy,win,gc,im,sx,sy,x,y,w,h);\   else alt_put_image(dev,dpy,win,gc,im,sx,sy,x,y,w,h)
end_define

begin_comment
comment|/* Open the device.  Most of the code is in gdevxini.c. */
end_comment

begin_function
name|private
name|int
name|x_open
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|code
init|=
name|gdev_x_open
argument_list|(
name|xdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|update_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Close the device.  NOT SURE WHAT TO DO HERE YET. */
end_comment

begin_function
name|private
name|int
name|x_close
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|xdev
operator|->
name|ghostview
condition|)
block|{
name|send_event
argument_list|(
name|dev
argument_list|,
name|xdev
operator|->
name|done
argument_list|)
expr_stmt|;
block|}
name|XCloseDisplay
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Map a color.  The "device colors" are just r,g,b packed together. */
end_comment

begin_function
name|private
name|gx_color_index
name|x_map_rgb_color
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_value
name|r
parameter_list|,
name|gx_color_value
name|g
parameter_list|,
name|gx_color_value
name|b
parameter_list|)
block|{
if|#
directive|if
name|HaveStdCMap
if|if
condition|(
name|xdev
operator|->
name|std_cmap
condition|)
block|{
name|XStandardColormap
modifier|*
name|cmap
init|=
name|xdev
operator|->
name|std_cmap
decl_stmt|;
name|x_pixel
name|color
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|g
operator|==
literal|0
operator|&&
name|b
operator|==
literal|0
condition|)
return|return
name|pixel_black
return|;
if|if
condition|(
name|r
operator|==
name|gx_max_color_value
operator|&&
name|g
operator|==
name|gx_max_color_value
operator|&&
name|b
operator|==
name|gx_max_color_value
condition|)
return|return
name|pixel_white
return|;
define|#
directive|define
name|cv_denom
value|(gx_max_color_value + 1)
name|color
operator|=
operator|(
name|gx_device_has_color
argument_list|(
name|xdev
argument_list|)
condition|?
operator|(
name|r
operator|*
operator|(
name|cmap
operator|->
name|red_max
operator|+
literal|1
operator|)
operator|/
name|cv_denom
operator|*
name|cmap
operator|->
name|red_mult
operator|)
operator|+
operator|(
name|g
operator|*
operator|(
name|cmap
operator|->
name|green_max
operator|+
literal|1
operator|)
operator|/
name|cv_denom
operator|*
name|cmap
operator|->
name|green_mult
operator|)
operator|+
operator|(
name|b
operator|*
operator|(
name|cmap
operator|->
name|blue_max
operator|+
literal|1
operator|)
operator|/
name|cv_denom
operator|*
name|cmap
operator|->
name|blue_mult
operator|)
else|:
operator|(
name|r
operator|*
operator|(
name|xdev
operator|->
name|color_info
operator|.
name|max_gray
operator|+
literal|1
operator|)
operator|/
name|cv_denom
operator|*
name|cmap
operator|->
name|red_mult
operator|)
operator|)
operator|+
name|cmap
operator|->
name|base_pixel
expr_stmt|;
undef|#
directive|undef
name|cv_denom
return|return
name|pixel_to_color_index
argument_list|(
name|color
argument_list|)
return|;
block|}
else|else
endif|#
directive|endif
define|#
directive|define
name|cv_half
value|(gx_max_color_value / 2)
block|{
return|return
name|pixel_to_color_index
argument_list|(
name|xdev
operator|->
name|colors
index|[
operator|(
name|r
operator|>
name|cv_half
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|g
operator|>
name|cv_half
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
operator|(
name|b
operator|>
name|cv_half
condition|?
literal|1
else|:
literal|0
operator|)
index|]
argument_list|)
return|;
block|}
undef|#
directive|undef
name|cv_half
block|}
end_function

begin_comment
comment|/* Map a "device color" back to r-g-b. */
end_comment

begin_function
name|private
name|int
name|x_map_color_rgb
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|gx_color_value
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
name|x_pixel
name|pixel
init|=
name|color_index_to_pixel
argument_list|(
name|color
argument_list|)
decl_stmt|;
if|if
condition|(
name|pixel
operator|==
name|pixel_black
condition|)
block|{
name|prgb
index|[
literal|0
index|]
operator|=
name|prgb
index|[
literal|1
index|]
operator|=
name|prgb
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pixel
operator|==
name|pixel_white
condition|)
block|{
name|prgb
index|[
literal|0
index|]
operator|=
name|prgb
index|[
literal|1
index|]
operator|=
name|prgb
index|[
literal|2
index|]
operator|=
name|gx_max_color_value
expr_stmt|;
block|}
if|#
directive|if
name|HaveStdCMap
elseif|else
if|if
condition|(
name|xdev
operator|->
name|std_cmap
condition|)
block|{
name|XStandardColormap
modifier|*
name|cmap
init|=
name|xdev
operator|->
name|std_cmap
decl_stmt|;
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|xdev
argument_list|)
condition|)
block|{
name|prgb
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|pixel
operator|-
name|cmap
operator|->
name|base_pixel
operator|)
operator|/
name|cmap
operator|->
name|red_mult
operator|)
operator|%
operator|(
name|cmap
operator|->
name|red_max
operator|+
literal|1
operator|)
operator|*
name|gx_max_color_value
operator|/
name|cmap
operator|->
name|red_max
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|pixel
operator|-
name|cmap
operator|->
name|base_pixel
operator|)
operator|/
name|cmap
operator|->
name|green_mult
operator|)
operator|%
operator|(
name|cmap
operator|->
name|green_max
operator|+
literal|1
operator|)
operator|*
name|gx_max_color_value
operator|/
name|cmap
operator|->
name|green_max
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|pixel
operator|-
name|cmap
operator|->
name|base_pixel
operator|)
operator|/
name|cmap
operator|->
name|blue_mult
operator|)
operator|%
operator|(
name|cmap
operator|->
name|blue_max
operator|+
literal|1
operator|)
operator|*
name|gx_max_color_value
operator|/
name|cmap
operator|->
name|blue_max
expr_stmt|;
block|}
else|else
block|{
name|prgb
index|[
literal|0
index|]
operator|=
name|prgb
index|[
literal|1
index|]
operator|=
name|prgb
index|[
literal|2
index|]
operator|=
operator|(
name|pixel
operator|-
name|cmap
operator|->
name|base_pixel
operator|)
operator|/
name|cmap
operator|->
name|red_mult
operator|*
name|gx_max_color_value
operator|/
name|xdev
operator|->
name|color_info
operator|.
name|max_gray
expr_stmt|;
block|}
block|}
endif|#
directive|endif
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pixel
operator|==
name|xdev
operator|->
name|colors
index|[
name|i
index|]
condition|)
block|{
name|prgb
index|[
literal|0
index|]
operator|=
operator|(
name|i
operator|&
literal|4
condition|?
name|gx_max_color_value
else|:
literal|0
operator|)
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|&
literal|2
condition|?
name|gx_max_color_value
else|:
literal|0
operator|)
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
operator|(
name|i
operator|&
literal|1
condition|?
name|gx_max_color_value
else|:
literal|0
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get initial matrix for X device */
end_comment

begin_function
name|private
name|void
name|x_get_initial_matrix
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
specifier|register
name|gs_matrix
modifier|*
name|pmat
parameter_list|)
block|{
name|pmat
operator|->
name|xx
operator|=
name|xdev
operator|->
name|initial_matrix
operator|.
name|xx
expr_stmt|;
name|pmat
operator|->
name|xy
operator|=
name|xdev
operator|->
name|initial_matrix
operator|.
name|xy
expr_stmt|;
name|pmat
operator|->
name|yx
operator|=
name|xdev
operator|->
name|initial_matrix
operator|.
name|yx
expr_stmt|;
name|pmat
operator|->
name|yy
operator|=
name|xdev
operator|->
name|initial_matrix
operator|.
name|yy
expr_stmt|;
name|pmat
operator|->
name|tx
operator|=
name|xdev
operator|->
name|initial_matrix
operator|.
name|tx
expr_stmt|;
name|pmat
operator|->
name|ty
operator|=
name|xdev
operator|->
name|initial_matrix
operator|.
name|ty
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Synchronize the display with the commands already given */
end_comment

begin_function
name|private
name|int
name|x_sync
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|update_flush
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|XSync
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Send event to ghostview process */
end_comment

begin_function
name|private
name|void
name|send_event
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|Atom
name|msg
parameter_list|)
block|{
name|XEvent
name|event
decl_stmt|;
name|event
operator|.
name|xclient
operator|.
name|type
operator|=
name|ClientMessage
expr_stmt|;
name|event
operator|.
name|xclient
operator|.
name|display
operator|=
name|xdev
operator|->
name|dpy
expr_stmt|;
name|event
operator|.
name|xclient
operator|.
name|window
operator|=
name|xdev
operator|->
name|win
expr_stmt|;
name|event
operator|.
name|xclient
operator|.
name|message_type
operator|=
name|msg
expr_stmt|;
name|event
operator|.
name|xclient
operator|.
name|format
operator|=
literal|32
expr_stmt|;
name|event
operator|.
name|xclient
operator|.
name|data
operator|.
name|l
index|[
literal|0
index|]
operator|=
name|xdev
operator|->
name|mwin
expr_stmt|;
name|event
operator|.
name|xclient
operator|.
name|data
operator|.
name|l
index|[
literal|1
index|]
operator|=
name|xdev
operator|->
name|dest
expr_stmt|;
name|XSendEvent
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
name|False
argument_list|,
literal|0
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output "page" */
end_comment

begin_function
name|private
name|int
name|x_output_page
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|num_copies
parameter_list|,
name|int
name|flush
parameter_list|)
block|{
name|x_sync
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Send ghostview a "page" client event */
comment|/* Wait for a "next" client event */
if|if
condition|(
name|xdev
operator|->
name|ghostview
condition|)
block|{
name|XEvent
name|event
decl_stmt|;
name|send_event
argument_list|(
name|dev
argument_list|,
name|xdev
operator|->
name|page
argument_list|)
expr_stmt|;
name|XNextEvent
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
while|while
condition|(
name|event
operator|.
name|type
operator|!=
name|ClientMessage
operator|||
name|event
operator|.
name|xclient
operator|.
name|message_type
operator|!=
name|xdev
operator|->
name|next
condition|)
block|{
name|XNextEvent
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fill a rectangle with a color. */
end_comment

begin_function
name|private
name|int
name|x_fill_rectangle
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|check_rect
argument_list|()
expr_stmt|;
name|set_fill_style
argument_list|(
name|FillSolid
argument_list|)
expr_stmt|;
name|set_fore_color
argument_list|(
name|color_index_to_pixel
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
name|set_function
argument_list|(
name|GXcopy
argument_list|)
expr_stmt|;
name|XFillRectangle
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|dest
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* If we are filling the entire screen, reset */
comment|/* colors_or and colors_and.  It's wasteful to do this */
comment|/* on every operation, but there's no separate driver routine */
comment|/* for erasepage (yet). */
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
operator|&&
name|w
operator|==
name|xdev
operator|->
name|width
operator|&&
name|h
operator|==
name|xdev
operator|->
name|height
condition|)
block|{
name|xdev
operator|->
name|colors_or
operator|=
name|xdev
operator|->
name|colors_and
operator|=
name|color_index_to_pixel
argument_list|(
name|color
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xdev
operator|->
name|bpixmap
operator|!=
operator|(
name|Pixmap
operator|)
literal|0
condition|)
block|{
name|update_add
argument_list|(
name|dev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'F'
index|]
condition|)
name|dprintf5
argument_list|(
literal|"[F] fill (%d,%d):(%d,%d) %ld\n"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
operator|(
name|long
operator|)
name|color
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Tile a rectangle. */
end_comment

begin_function
name|private
name|int
name|x_tile_rectangle
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_bitmap
modifier|*
name|tile
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|zero
parameter_list|,
name|gx_color_index
name|one
parameter_list|,
name|int
name|px
parameter_list|,
name|int
name|py
parameter_list|)
block|{
name|x_pixel
name|p_zero
init|=
name|color_index_to_pixel
argument_list|(
name|zero
argument_list|)
decl_stmt|,
name|p_one
init|=
name|color_index_to_pixel
argument_list|(
name|one
argument_list|)
decl_stmt|;
name|check_rect
argument_list|()
expr_stmt|;
comment|/* Check for a colored tile.  We should implement this */
comment|/* properly someday, since X can handle it. */
if|if
condition|(
name|one
operator|==
name|gx_no_color_index
operator|&&
name|zero
operator|==
name|gx_no_color_index
condition|)
return|return
operator|-
literal|1
return|;
comment|/* For the moment, give up if the phase is non-zero. */
if|if
condition|(
name|px
operator||
name|py
condition|)
return|return
operator|-
literal|1
return|;
comment|/*  	 * Remember, an X tile is already filled with particular 	 * pixel values (i.e., colors).  Therefore if we are changing 	 * fore/background color, we must invalidate the tile (using 	 * the same technique as in set_tile).  This problem only 	 * bites when using grayscale -- you may want to change 	 * fg/bg but use the same halftone screen. 	 */
if|if
condition|(
operator|(
name|p_zero
operator|!=
name|xdev
operator|->
name|ht
operator|.
name|back_c
operator|)
operator|||
operator|(
name|p_one
operator|!=
name|xdev
operator|->
name|ht
operator|.
name|fore_c
operator|)
condition|)
name|xdev
operator|->
name|ht
operator|.
name|id
operator|=
operator|~
name|tile
operator|->
name|id
expr_stmt|;
comment|/* force reload */
name|set_back_color
argument_list|(
name|p_zero
argument_list|)
expr_stmt|;
name|set_fore_color
argument_list|(
name|p_one
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_tile
argument_list|(
name|dev
argument_list|,
name|tile
argument_list|)
condition|)
block|{
comment|/* Bad news.  Fall back to the default algorithm. */
return|return
name|gx_default_tile_rectangle
argument_list|(
name|dev
argument_list|,
name|tile
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|zero
argument_list|,
name|one
argument_list|,
name|px
argument_list|,
name|py
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Use the tile to fill the rectangle */
name|set_fill_style
argument_list|(
name|FillTiled
argument_list|)
expr_stmt|;
name|set_function
argument_list|(
name|GXcopy
argument_list|)
expr_stmt|;
name|XFillRectangle
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|dest
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|bpixmap
operator|!=
operator|(
name|Pixmap
operator|)
literal|0
condition|)
block|{
name|update_add
argument_list|(
name|dev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'F'
index|]
condition|)
name|dprintf6
argument_list|(
literal|"[F] tile (%d,%d):(%d,%d) %ld,%ld\n"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
operator|(
name|long
operator|)
name|zero
argument_list|,
operator|(
name|long
operator|)
name|one
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set up with a specified tile. */
end_comment

begin_comment
comment|/* Return false if we can't do it for some reason. */
end_comment

begin_function
name|private
name|int
name|set_tile
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
specifier|register
name|gx_bitmap
modifier|*
name|tile
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'T'
index|]
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|tile
operator|->
name|id
operator|==
name|xdev
operator|->
name|ht
operator|.
name|id
operator|&&
name|tile
operator|->
name|id
operator|!=
name|gx_no_bitmap_id
condition|)
return|return
name|use_XSetTile
return|;
comment|/* Set up the tile Pixmap */
if|if
condition|(
name|tile
operator|->
name|size
operator|.
name|x
operator|!=
name|xdev
operator|->
name|ht
operator|.
name|width
operator|||
name|tile
operator|->
name|size
operator|.
name|y
operator|!=
name|xdev
operator|->
name|ht
operator|.
name|height
operator|||
name|xdev
operator|->
name|ht
operator|.
name|pixmap
operator|==
operator|(
name|Pixmap
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|xdev
operator|->
name|ht
operator|.
name|pixmap
operator|!=
operator|(
name|Pixmap
operator|)
literal|0
condition|)
name|XFreePixmap
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|ht
operator|.
name|pixmap
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|ht
operator|.
name|pixmap
operator|=
name|XCreatePixmap
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
name|tile
operator|->
name|size
operator|.
name|x
argument_list|,
name|tile
operator|->
name|size
operator|.
name|y
argument_list|,
name|xdev
operator|->
name|vinfo
operator|->
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|ht
operator|.
name|pixmap
operator|==
operator|(
name|Pixmap
operator|)
literal|0
condition|)
return|return
literal|0
return|;
name|xdev
operator|->
name|ht
operator|.
name|width
operator|=
name|tile
operator|->
name|size
operator|.
name|x
operator|,
name|xdev
operator|->
name|ht
operator|.
name|height
operator|=
name|tile
operator|->
name|size
operator|.
name|y
expr_stmt|;
name|xdev
operator|->
name|ht
operator|.
name|raster
operator|=
name|tile
operator|->
name|raster
expr_stmt|;
block|}
name|xdev
operator|->
name|ht
operator|.
name|fore_c
operator|=
name|xdev
operator|->
name|fore_color
expr_stmt|;
name|xdev
operator|->
name|ht
operator|.
name|back_c
operator|=
name|xdev
operator|->
name|back_color
expr_stmt|;
comment|/* Copy the tile into the Pixmap */
name|xdev
operator|->
name|image
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|tile
operator|->
name|data
expr_stmt|;
name|xdev
operator|->
name|image
operator|.
name|width
operator|=
name|tile
operator|->
name|size
operator|.
name|x
expr_stmt|;
name|xdev
operator|->
name|image
operator|.
name|height
operator|=
name|tile
operator|->
name|size
operator|.
name|y
expr_stmt|;
name|xdev
operator|->
name|image
operator|.
name|bytes_per_line
operator|=
name|tile
operator|->
name|raster
expr_stmt|;
name|xdev
operator|->
name|image
operator|.
name|format
operator|=
name|XYBitmap
expr_stmt|;
name|set_fill_style
argument_list|(
name|FillSolid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'H'
index|]
condition|)
block|{
name|int
name|i
decl_stmt|;
name|dprintf4
argument_list|(
literal|"[H] 0x%x: width=%d height=%d raster=%d\n"
argument_list|,
name|tile
operator|->
name|data
argument_list|,
name|tile
operator|->
name|size
operator|.
name|x
argument_list|,
name|tile
operator|->
name|size
operator|.
name|y
argument_list|,
name|tile
operator|->
name|raster
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tile
operator|->
name|raster
operator|*
name|tile
operator|->
name|size
operator|.
name|y
condition|;
name|i
operator|++
control|)
name|dprintf1
argument_list|(
literal|" %02x"
argument_list|,
name|tile
operator|->
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|XSetTile
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|xdev
operator|->
name|ht
operator|.
name|no_pixmap
argument_list|)
expr_stmt|;
comment|/* *** X bug *** */
name|set_function
argument_list|(
name|GXcopy
argument_list|)
expr_stmt|;
name|put_image
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|ht
operator|.
name|pixmap
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
operator|&
name|xdev
operator|->
name|image
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tile
operator|->
name|size
operator|.
name|x
argument_list|,
name|tile
operator|->
name|size
operator|.
name|y
argument_list|)
expr_stmt|;
name|XSetTile
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|xdev
operator|->
name|ht
operator|.
name|pixmap
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|ht
operator|.
name|id
operator|=
name|tile
operator|->
name|id
expr_stmt|;
return|return
name|use_XSetTile
return|;
block|}
end_function

begin_comment
comment|/* Copy a monochrome bitmap. */
end_comment

begin_function
name|private
name|int
name|x_copy_mono
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|zero
parameter_list|,
name|gx_color_index
name|one
parameter_list|)
comment|/*  * X doesn't directly support the simple operation of writing a color  * through a mask specified by an image.  The plot is the following:   *  If neither color is gx_no_color_index ("transparent"),  *	use XPutImage with the "copy" function as usual.  *  If the color either bitwise-includes or is bitwise-included-in  *      every color written to date  *      (a special optimization for writing black/white on color displays),  *	use XPutImage with an appropriate Boolean function.  *  Otherwise, do the following complicated stuff:  *	Create pixmap of depth 1 if necessary.  *	If foreground color is "transparent" then  *	  invert the raster data.  *	Use XPutImage to copy the raster image to the newly  *	  created Pixmap.  *	Install the Pixmap as the clip_mask in the X GC and  *	  tweak the clip origin.  *	Do an XFillRectangle, fill style=solid, specifying a  *	  rectangle the same size as the original raster data.  *	De-install the clip_mask.  */
block|{
name|int
name|function
init|=
name|GXcopy
decl_stmt|;
name|x_pixel
name|p_zero
init|=
name|color_index_to_pixel
argument_list|(
name|zero
argument_list|)
decl_stmt|,
name|p_one
init|=
name|color_index_to_pixel
argument_list|(
name|one
argument_list|)
decl_stmt|;
name|x_pixel
name|bc
init|=
name|p_zero
decl_stmt|,
name|fc
init|=
name|p_one
decl_stmt|;
comment|/* We need a different version of check_rect, because */
comment|/* we have to adjust the source coordinates too. */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|w
operator|+=
name|x
operator|,
name|sourcex
operator|-=
name|x
operator|,
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|h
operator|+=
name|y
operator|,
name|base
operator|-=
name|y
operator|*
name|raster
operator|,
name|y
operator|=
literal|0
expr_stmt|;
name|check_rect_extent
argument_list|()
expr_stmt|;
name|xdev
operator|->
name|image
operator|.
name|width
operator|=
name|raster
operator|<<
literal|3
expr_stmt|;
name|xdev
operator|->
name|image
operator|.
name|height
operator|=
name|h
expr_stmt|;
name|xdev
operator|->
name|image
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|base
expr_stmt|;
name|xdev
operator|->
name|image
operator|.
name|bytes_per_line
operator|=
name|raster
expr_stmt|;
name|set_fill_style
argument_list|(
name|FillSolid
argument_list|)
expr_stmt|;
comment|/* Check for null, easy 1-color, hard 1-color, and 2-color cases. */
if|if
condition|(
name|zero
operator|!=
name|gx_no_color_index
condition|)
block|{
if|if
condition|(
name|one
operator|!=
name|gx_no_color_index
condition|)
block|{
comment|/* 2-color case. */
comment|/* Simply replace existing bits with what's in the image. */
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
operator|~
name|xdev
operator|->
name|colors_and
operator|&
name|bc
operator|)
condition|)
name|function
operator|=
name|GXand
operator|,
name|fc
operator|=
operator|~
operator|(
name|x_pixel
operator|)
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
operator|~
name|bc
operator|&
name|xdev
operator|->
name|colors_or
operator|)
condition|)
name|function
operator|=
name|GXor
operator|,
name|fc
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|hard
goto|;
block|}
else|else
block|{
if|if
condition|(
name|one
operator|==
name|gx_no_color_index
condition|)
comment|/* no-op */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|!
operator|(
operator|~
name|xdev
operator|->
name|colors_and
operator|&
name|fc
operator|)
condition|)
name|function
operator|=
name|GXand
operator|,
name|bc
operator|=
operator|~
operator|(
name|x_pixel
operator|)
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
operator|~
name|fc
operator|&
name|xdev
operator|->
name|colors_or
operator|)
condition|)
name|function
operator|=
name|GXor
operator|,
name|bc
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|hard
goto|;
block|}
name|xdev
operator|->
name|image
operator|.
name|format
operator|=
name|XYBitmap
expr_stmt|;
name|set_function
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc
operator|!=
name|xdev
operator|->
name|back_color
condition|)
name|XSetBackground
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
operator|(
name|xdev
operator|->
name|back_color
operator|=
name|bc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|!=
name|xdev
operator|->
name|fore_color
condition|)
name|XSetForeground
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
operator|(
name|xdev
operator|->
name|fore_color
operator|=
name|fc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero
operator|!=
name|gx_no_color_index
condition|)
name|note_color
argument_list|(
name|p_zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|one
operator|!=
name|gx_no_color_index
condition|)
name|note_color
argument_list|(
name|p_one
argument_list|)
expr_stmt|;
name|put_image
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|dest
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
operator|&
name|xdev
operator|->
name|image
argument_list|,
name|sourcex
argument_list|,
literal|0
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
name|hard
label|:
comment|/* Handle the hard 1-color case. */
if|if
condition|(
name|raster
operator|>
name|xdev
operator|->
name|cp
operator|.
name|raster
operator|||
name|h
operator|>
name|xdev
operator|->
name|cp
operator|.
name|height
condition|)
block|{
comment|/* Must allocate a new pixmap and GC. */
comment|/* Release the old ones first. */
name|free_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Create the clipping pixmap, depth must be 1. */
name|xdev
operator|->
name|cp
operator|.
name|pixmap
operator|=
name|XCreatePixmap
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
name|raster
operator|<<
literal|3
argument_list|,
name|h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|cp
operator|.
name|pixmap
operator|==
operator|(
name|Pixmap
operator|)
literal|0
condition|)
block|{
name|lprintf
argument_list|(
literal|"x_copy_mono: can't allocate pixmap\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|xdev
operator|->
name|cp
operator|.
name|gc
operator|=
name|XCreateGC
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cp
operator|.
name|pixmap
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|cp
operator|.
name|gc
operator|==
operator|(
name|GC
operator|)
literal|0
condition|)
block|{
name|lprintf
argument_list|(
literal|"x_copy_mono: can't allocate GC\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|xdev
operator|->
name|cp
operator|.
name|raster
operator|=
name|raster
expr_stmt|;
name|xdev
operator|->
name|cp
operator|.
name|height
operator|=
name|h
expr_stmt|;
block|}
comment|/* Initialize static mask image params */
name|xdev
operator|->
name|image
operator|.
name|format
operator|=
name|ZPixmap
expr_stmt|;
comment|/* Select polarity based on fg/bg transparency. */
if|if
condition|(
name|one
operator|==
name|gx_no_color_index
condition|)
comment|/* invert */
block|{
name|XSetBackground
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cp
operator|.
name|gc
argument_list|,
operator|(
name|x_pixel
operator|)
literal|1
argument_list|)
expr_stmt|;
name|XSetForeground
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cp
operator|.
name|gc
argument_list|,
operator|(
name|x_pixel
operator|)
literal|0
argument_list|)
expr_stmt|;
name|set_fore_color
argument_list|(
name|p_zero
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XSetBackground
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cp
operator|.
name|gc
argument_list|,
operator|(
name|x_pixel
operator|)
literal|0
argument_list|)
expr_stmt|;
name|XSetForeground
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cp
operator|.
name|gc
argument_list|,
operator|(
name|x_pixel
operator|)
literal|1
argument_list|)
expr_stmt|;
name|set_fore_color
argument_list|(
name|p_one
argument_list|)
expr_stmt|;
block|}
name|put_image
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cp
operator|.
name|pixmap
argument_list|,
name|xdev
operator|->
name|cp
operator|.
name|gc
argument_list|,
operator|&
name|xdev
operator|->
name|image
argument_list|,
name|sourcex
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Install as clipmask. */
name|XSetClipMask
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|xdev
operator|->
name|cp
operator|.
name|pixmap
argument_list|)
expr_stmt|;
name|XSetClipOrigin
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* 	 * Draw a solid rectangle through the raster clip mask. 	 * Note fill style is guaranteed to be solid from above. 	 */
name|XFillRectangle
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|dest
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Tidy up.  Free the pixmap if it's big. */
name|XSetClipMask
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|None
argument_list|)
expr_stmt|;
if|if
condition|(
name|raster
operator|*
name|h
operator|>
name|max_temp_pixmap
condition|)
name|free_cp
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|xdev
operator|->
name|bpixmap
operator|!=
operator|(
name|Pixmap
operator|)
literal|0
condition|)
block|{
comment|/* We wrote to the pixmap, so update the display now. */
name|update_add
argument_list|(
name|dev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internal routine to free the GC and pixmap used for copying. */
end_comment

begin_function
name|private
name|void
name|free_cp
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|xdev
operator|->
name|cp
operator|.
name|gc
operator|!=
name|NULL
condition|)
block|{
name|XFreeGC
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cp
operator|.
name|gc
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|cp
operator|.
name|gc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|xdev
operator|->
name|cp
operator|.
name|pixmap
operator|!=
operator|(
name|Pixmap
operator|)
literal|0
condition|)
block|{
name|XFreePixmap
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|cp
operator|.
name|pixmap
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|cp
operator|.
name|pixmap
operator|=
operator|(
name|Pixmap
operator|)
literal|0
expr_stmt|;
block|}
name|xdev
operator|->
name|cp
operator|.
name|raster
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* mark as unallocated */
block|}
end_function

begin_comment
comment|/* Copy a "color" bitmap.  Since "color" is the same as monochrome, */
end_comment

begin_comment
comment|/* this just reduces to copying a monochrome bitmap. */
end_comment

begin_comment
comment|/****** THIS ROUTINE IS COMPLETELY WRONG, SINCE WE DO SUPPORT COLOR. ******/
end_comment

begin_comment
comment|/* Fortunately, no one uses it at the moment. */
end_comment

begin_function
name|private
name|int
name|x_copy_color
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
return|return
name|x_copy_mono
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|sourcex
argument_list|,
name|raster
argument_list|,
name|id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|pixel_to_color_index
argument_list|(
name|pixel_black
argument_list|)
argument_list|,
name|pixel_to_color_index
argument_list|(
name|pixel_white
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Draw a line */
end_comment

begin_function
name|private
name|int
name|x_draw_line
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x0
parameter_list|,
name|int
name|y0
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|set_fore_color
argument_list|(
name|color_index_to_pixel
argument_list|(
name|color
argument_list|)
argument_list|)
expr_stmt|;
name|set_fill_style
argument_list|(
name|FillSolid
argument_list|)
expr_stmt|;
name|set_function
argument_list|(
name|GXcopy
argument_list|)
expr_stmt|;
name|XDrawLine
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|dest
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|bpixmap
operator|!=
operator|(
name|Pixmap
operator|)
literal|0
condition|)
block|{
name|int
name|x
init|=
name|x0
decl_stmt|,
name|y
init|=
name|y0
decl_stmt|,
name|w
init|=
name|x1
operator|-
name|x0
decl_stmt|,
name|h
init|=
name|y1
operator|-
name|y0
decl_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
name|x
operator|=
name|x1
operator|,
name|w
operator|=
operator|-
name|w
expr_stmt|;
if|if
condition|(
name|h
operator|<
literal|0
condition|)
name|y
operator|=
name|y1
operator|,
name|h
operator|=
operator|-
name|h
expr_stmt|;
name|w
operator|++
expr_stmt|;
name|h
operator|++
expr_stmt|;
name|check_rect
argument_list|()
expr_stmt|;
name|update_add
argument_list|(
name|dev
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Screen update procedures ------ */
end_comment

begin_comment
comment|/* Flush updates to the screen if needed. */
end_comment

begin_function
name|private
name|void
name|update_do_flush
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|xo
init|=
name|xdev
operator|->
name|update
operator|.
name|xo
decl_stmt|,
name|yo
init|=
name|xdev
operator|->
name|update
operator|.
name|yo
decl_stmt|;
name|set_function
argument_list|(
name|GXcopy
argument_list|)
expr_stmt|;
name|XCopyArea
argument_list|(
name|xdev
operator|->
name|dpy
argument_list|,
name|xdev
operator|->
name|bpixmap
argument_list|,
name|xdev
operator|->
name|win
argument_list|,
name|xdev
operator|->
name|gc
argument_list|,
name|xo
argument_list|,
name|yo
argument_list|,
name|xdev
operator|->
name|update
operator|.
name|xe
operator|-
name|xo
argument_list|,
name|xdev
operator|->
name|update
operator|.
name|ye
operator|-
name|yo
argument_list|,
name|xo
argument_list|,
name|yo
argument_list|)
expr_stmt|;
name|update_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a region to be updated. */
end_comment

begin_comment
comment|/* This is only called if xdev->bpixmap != 0. */
end_comment

begin_function
name|private
name|void
name|update_add
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|xo
parameter_list|,
name|int
name|yo
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|int
name|xe
init|=
name|xo
operator|+
name|w
decl_stmt|,
name|ye
init|=
name|yo
operator|+
name|h
decl_stmt|;
name|long
name|new_area
init|=
operator|(
name|long
operator|)
name|w
operator|*
name|h
decl_stmt|;
operator|++
name|xdev
operator|->
name|up_count
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|up_area
operator|!=
literal|0
condition|)
block|{
comment|/* See whether adding this rectangle */
comment|/* would result in too much being copied unnecessarily. */
name|long
name|old_area
init|=
name|xdev
operator|->
name|up_area
decl_stmt|;
name|long
name|new_up_area
decl_stmt|;
name|rect
name|u
decl_stmt|;
name|u
operator|.
name|xo
operator|=
name|min
argument_list|(
name|xo
argument_list|,
name|xdev
operator|->
name|update
operator|.
name|xo
argument_list|)
expr_stmt|;
name|u
operator|.
name|yo
operator|=
name|min
argument_list|(
name|yo
argument_list|,
name|xdev
operator|->
name|update
operator|.
name|yo
argument_list|)
expr_stmt|;
name|u
operator|.
name|xe
operator|=
name|max
argument_list|(
name|xe
argument_list|,
name|xdev
operator|->
name|update
operator|.
name|xe
argument_list|)
expr_stmt|;
name|u
operator|.
name|ye
operator|=
name|max
argument_list|(
name|ye
argument_list|,
name|xdev
operator|->
name|update
operator|.
name|ye
argument_list|)
expr_stmt|;
name|new_up_area
operator|=
call|(
name|long
call|)
argument_list|(
name|u
operator|.
name|xe
operator|-
name|u
operator|.
name|xo
argument_list|)
operator|*
operator|(
name|u
operator|.
name|ye
operator|-
name|u
operator|.
name|yo
operator|)
expr_stmt|;
if|if
condition|(
name|new_up_area
operator|>
literal|100
operator|&&
name|old_area
operator|+
name|new_area
operator|<
name|new_up_area
operator|*
literal|2
operator|/
literal|3
operator|||
name|xdev
operator|->
name|up_count
operator|>=
literal|200
condition|)
name|update_do_flush
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
block|{
name|xdev
operator|->
name|update
operator|=
name|u
expr_stmt|;
name|xdev
operator|->
name|up_area
operator|=
name|new_up_area
expr_stmt|;
return|return;
block|}
block|}
name|xdev
operator|->
name|update
operator|.
name|xo
operator|=
name|xo
expr_stmt|;
name|xdev
operator|->
name|update
operator|.
name|yo
operator|=
name|yo
expr_stmt|;
name|xdev
operator|->
name|update
operator|.
name|xe
operator|=
name|xe
expr_stmt|;
name|xdev
operator|->
name|update
operator|.
name|ye
operator|=
name|ye
expr_stmt|;
name|xdev
operator|->
name|up_area
operator|=
name|new_area
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Internal procedures ------ */
end_comment

begin_comment
comment|/* Substitute for XPutImage using XFillRectangle. */
end_comment

begin_comment
comment|/* This is a total hack to get around an apparent bug */
end_comment

begin_comment
comment|/* in some X servers.  It only works with the specific */
end_comment

begin_comment
comment|/* parameters (bit/byte order, padding) used above. */
end_comment

begin_function
name|private
name|void
name|alt_put_image
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|Display
modifier|*
name|dpy
parameter_list|,
name|Drawable
name|win
parameter_list|,
name|GC
name|gc
parameter_list|,
name|XImage
modifier|*
name|pi
parameter_list|,
name|int
name|sx
parameter_list|,
name|int
name|sy
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|unsigned
name|w
parameter_list|,
name|unsigned
name|h
parameter_list|)
block|{
name|int
name|raster
init|=
name|pi
operator|->
name|bytes_per_line
decl_stmt|;
name|byte
modifier|*
name|data
init|=
operator|(
name|byte
operator|*
operator|)
name|pi
operator|->
name|data
operator|+
name|sy
operator|*
name|raster
operator|+
operator|(
name|sx
operator|>>
literal|3
operator|)
decl_stmt|;
name|int
name|init_mask
init|=
literal|0x80
operator|>>
operator|(
name|sx
operator|&
literal|7
operator|)
decl_stmt|;
name|int
name|invert
decl_stmt|;
name|int
name|yi
decl_stmt|;
define|#
directive|define
name|nrects
value|40
name|XRectangle
name|rects
index|[
name|nrects
index|]
decl_stmt|;
name|XRectangle
modifier|*
name|rp
init|=
name|rects
decl_stmt|;
if|if
condition|(
name|xdev
operator|->
name|fore_color
operator|!=
name|gx_no_color_index
condition|)
block|{
if|if
condition|(
name|xdev
operator|->
name|back_color
operator|!=
name|gx_no_color_index
condition|)
block|{
name|XSetForeground
argument_list|(
name|dpy
argument_list|,
name|gc
argument_list|,
name|xdev
operator|->
name|back_color
argument_list|)
expr_stmt|;
name|XFillRectangle
argument_list|(
name|dpy
argument_list|,
name|win
argument_list|,
name|gc
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|w
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
name|XSetForeground
argument_list|(
name|dpy
argument_list|,
name|gc
argument_list|,
name|xdev
operator|->
name|fore_color
argument_list|)
expr_stmt|;
name|invert
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xdev
operator|->
name|back_color
operator|!=
name|gx_no_color_index
condition|)
block|{
name|XSetForeground
argument_list|(
name|dpy
argument_list|,
name|gc
argument_list|,
name|xdev
operator|->
name|back_color
argument_list|)
expr_stmt|;
name|invert
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
return|return;
for|for
control|(
name|yi
operator|=
literal|0
init|;
name|yi
operator|<
name|h
condition|;
name|yi
operator|++
operator|,
name|data
operator|+=
name|raster
control|)
block|{
specifier|register
name|int
name|mask
init|=
name|init_mask
decl_stmt|;
specifier|register
name|byte
modifier|*
name|dp
init|=
name|data
decl_stmt|;
specifier|register
name|int
name|xi
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|xi
operator|<
name|w
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|dp
operator|^
name|invert
operator|)
operator|&
name|mask
condition|)
block|{
name|int
name|xleft
init|=
name|xi
decl_stmt|;
if|if
condition|(
name|rp
operator|==
operator|&
name|rects
index|[
name|nrects
index|]
condition|)
block|{
name|XFillRectangles
argument_list|(
name|dpy
argument_list|,
name|win
argument_list|,
name|gc
argument_list|,
name|rects
argument_list|,
name|nrects
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rects
expr_stmt|;
block|}
comment|/* Scan over a run of 1-bits */
name|rp
operator|->
name|x
operator|=
name|dx
operator|+
name|xi
operator|,
name|rp
operator|->
name|y
operator|=
name|dy
operator|+
name|yi
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|mask
operator|>>=
literal|1
operator|)
condition|)
name|mask
operator|=
literal|0x80
operator|,
name|dp
operator|++
expr_stmt|;
name|xi
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|xi
operator|<
name|w
operator|&&
operator|(
operator|*
name|dp
operator|&
name|mask
operator|)
condition|)
do|;
name|rp
operator|->
name|width
operator|=
name|xi
operator|-
name|xleft
operator|,
name|rp
operator|->
name|height
operator|=
literal|1
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|mask
operator|>>=
literal|1
operator|)
condition|)
name|mask
operator|=
literal|0x80
operator|,
name|dp
operator|++
expr_stmt|;
name|xi
operator|++
expr_stmt|;
block|}
block|}
block|}
name|XFillRectangles
argument_list|(
name|dpy
argument_list|,
name|win
argument_list|,
name|gc
argument_list|,
name|rects
argument_list|,
name|rp
operator|-
name|rects
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

