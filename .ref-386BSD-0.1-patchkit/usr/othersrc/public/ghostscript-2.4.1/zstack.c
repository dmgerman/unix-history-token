begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zstack.c */
end_comment

begin_comment
comment|/* Operand stack operators for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* pop */
end_comment

begin_function
name|int
name|zpop
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_op
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* exch */
end_comment

begin_function
name|int
name|zexch
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|ref
name|next
decl_stmt|;
name|check_op
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ref_assign
argument_list|(
operator|&
name|next
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ref_assign
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ref_assign
argument_list|(
name|op
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* dup */
end_comment

begin_function
name|int
name|zdup
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_op
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ref_assign
argument_list|(
name|op
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* index */
end_comment

begin_function
name|int
name|zindex
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|opn
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ulong
operator|)
name|op
operator|->
name|value
operator|.
name|intval
operator|>=
name|op
operator|-
name|osbot
condition|)
return|return
name|e_rangecheck
return|;
name|opn
operator|=
name|op
operator|+
operator|~
operator|(
name|int
operator|)
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
name|ref_assign
argument_list|(
name|op
argument_list|,
name|opn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* roll */
end_comment

begin_function
name|int
name|zroll
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|op1
init|=
name|op
operator|-
literal|1
decl_stmt|;
name|int
name|count
decl_stmt|,
name|mod
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op1
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ulong
operator|)
name|op1
operator|->
name|value
operator|.
name|intval
operator|>
name|op1
operator|-
name|osbot
condition|)
return|return
name|e_rangecheck
return|;
name|count
operator|=
name|op1
operator|->
name|value
operator|.
name|intval
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* no action */
name|mod
operator|=
name|op
operator|->
name|value
operator|.
name|intval
operator|%
name|count
expr_stmt|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* we're OK now */
name|op
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|mod
operator|<
literal|0
condition|)
name|mod
operator|+=
name|count
expr_stmt|;
comment|/* can't assume % means mod! */
comment|/* The elegant approach, requiring no extra space, would be to */
comment|/* rotate the elements in chains separated by mod elements. */
comment|/* Instead, we simply check to make sure there is enough space */
comment|/* above op to do the roll in two block moves. */
comment|/* Unfortunately, we can't count on memcpy doing the right thing */
comment|/* in *either* direction. */
block|{
specifier|register
name|os_ptr
name|from
decl_stmt|,
name|to
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|mod
operator|==
literal|1
condition|)
comment|/* common special case */
block|{
for|for
control|(
name|from
operator|=
name|op
operator|,
name|n
operator|=
name|count
init|;
name|n
operator|--
condition|;
name|from
operator|--
control|)
name|from
index|[
literal|1
index|]
operator|=
operator|*
name|from
expr_stmt|;
name|from
index|[
literal|1
index|]
operator|=
name|op
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mod
operator|<=
name|count
operator|>>
literal|1
condition|)
block|{
comment|/* Move everything up, then top elements down. */
if|if
condition|(
name|mod
operator|>=
name|ostop
operator|-
name|op
condition|)
return|return
name|e_stackoverflow
return|;
for|for
control|(
name|to
operator|=
name|op
operator|+
name|mod
operator|,
name|from
operator|=
name|op
operator|,
name|n
operator|=
name|count
init|;
name|n
operator|--
condition|;
name|to
operator|--
operator|,
name|from
operator|--
control|)
operator|*
name|to
operator|=
operator|*
name|from
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|from
operator|+
literal|1
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|op
operator|+
literal|1
operator|)
argument_list|,
name|mod
operator|*
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Move bottom elements up, then everything down. */
name|os_ptr
name|base
init|=
name|op
operator|-
name|count
operator|+
literal|1
decl_stmt|;
name|mod
operator|=
name|count
operator|-
name|mod
expr_stmt|;
if|if
condition|(
name|mod
operator|==
literal|1
condition|)
comment|/* common special case */
block|{
name|op
index|[
literal|1
index|]
operator|=
operator|*
name|base
expr_stmt|;
for|for
control|(
name|to
operator|=
name|base
operator|,
name|n
operator|=
name|count
init|;
name|n
operator|--
condition|;
name|to
operator|++
control|)
operator|*
name|to
operator|=
name|to
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mod
operator|>=
name|ostop
operator|-
name|op
condition|)
return|return
name|e_stackoverflow
return|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|op
operator|+
literal|1
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|base
argument_list|,
name|mod
operator|*
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|to
operator|=
name|base
operator|,
name|from
operator|=
name|base
operator|+
name|mod
operator|,
name|n
operator|=
name|count
init|;
name|n
operator|--
condition|;
name|to
operator|++
operator|,
name|from
operator|++
control|)
operator|*
name|to
operator|=
operator|*
name|from
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* clear */
end_comment

begin_comment
comment|/* The function name is changed, because the IRIS library has */
end_comment

begin_comment
comment|/* a function called zclear. */
end_comment

begin_function
name|int
name|zclear_stack
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|osp
operator|=
name|osbot
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* count */
end_comment

begin_function
name|int
name|zcount
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|op
operator|-
name|osbot
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* cleartomark */
end_comment

begin_function
name|int
name|zcleartomark
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
while|while
condition|(
name|op
operator|>=
name|osbot
condition|)
block|{
if|if
condition|(
name|r_has_type
argument_list|(
name|op
argument_list|,
name|t_mark
argument_list|)
condition|)
block|{
name|osp
operator|=
name|op
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|op
operator|--
expr_stmt|;
block|}
return|return
name|e_unmatchedmark
return|;
block|}
end_function

begin_comment
comment|/* counttomark */
end_comment

begin_function
name|int
name|zcounttomark
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
specifier|register
name|os_ptr
name|mp
init|=
name|op
decl_stmt|;
while|while
condition|(
name|mp
operator|>=
name|osbot
condition|)
block|{
if|if
condition|(
name|r_has_type
argument_list|(
name|mp
argument_list|,
name|t_mark
argument_list|)
condition|)
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|op
operator|-
name|mp
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mp
operator|--
expr_stmt|;
block|}
return|return
name|e_unmatchedmark
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zstack_op_defs
index|[]
init|=
block|{
block|{
literal|"0clear"
block|,
name|zclear_stack
block|}
block|,
block|{
literal|"0cleartomark"
block|,
name|zcleartomark
block|}
block|,
block|{
literal|"0count"
block|,
name|zcount
block|}
block|,
block|{
literal|"0counttomark"
block|,
name|zcounttomark
block|}
block|,
block|{
literal|"1dup"
block|,
name|zdup
block|}
block|,
block|{
literal|"2exch"
block|,
name|zexch
block|}
block|,
block|{
literal|"2index"
block|,
name|zindex
block|}
block|,
block|{
literal|"1pop"
block|,
name|zpop
block|}
block|,
block|{
literal|"2roll"
block|,
name|zroll
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

