begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevpjet.c */
end_comment

begin_comment
comment|/* H-P PaintJet driver for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"gdevprn.h"
end_include

begin_include
include|#
directive|include
file|"gdevpcl.h"
end_include

begin_comment
comment|/* X_DPI and Y_DPI must be the same, and may be either 90 or 180. */
end_comment

begin_define
define|#
directive|define
name|X_DPI
value|180
end_define

begin_define
define|#
directive|define
name|Y_DPI
value|180
end_define

begin_comment
comment|/* We round up LINE_SIZE to a multiple of 8 bytes */
end_comment

begin_comment
comment|/* because that's the unit of transposition from pixels to planes. */
end_comment

begin_define
define|#
directive|define
name|LINE_SIZE
value|((X_DPI * 85 / 10 + 63) / 64 * 8)
end_define

begin_comment
comment|/* The device descriptor */
end_comment

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|paintjet_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|gx_device_procs
name|paintjet_procs
init|=
name|prn_color_procs
argument_list|(
name|gdev_prn_open
argument_list|,
name|gdev_prn_output_page
argument_list|,
name|gdev_prn_close
argument_list|,
name|gdev_pcl_3bit_map_rgb_color
argument_list|,
name|gdev_pcl_3bit_map_color_rgb
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_printer
name|gs_paintjet_device
init|=
name|prn_device
argument_list|(
name|paintjet_procs
argument_list|,
literal|"paintjet"
argument_list|,
literal|85
argument_list|,
comment|/* width_10ths, 8.5" */
literal|110
argument_list|,
comment|/* height_10ths, 11" */
name|X_DPI
argument_list|,
name|Y_DPI
argument_list|,
literal|0.25
argument_list|,
literal|0
argument_list|,
literal|0.25
argument_list|,
literal|0
argument_list|,
comment|/* margins */
literal|3
argument_list|,
name|paintjet_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|compress1_row
argument_list|(
name|P3
argument_list|(
argument|byte _ss *
argument_list|,
argument|byte _ss *
argument_list|,
argument|byte _ss *
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Send the page to the printer.  Compress each scan line. */
end_comment

begin_function
name|private
name|int
name|paintjet_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|prn_stream
parameter_list|)
block|{
define|#
directive|define
name|DATA_SIZE
value|(LINE_SIZE * 8)
name|byte
name|data
index|[
name|DATA_SIZE
index|]
decl_stmt|;
name|byte
name|plane_data
index|[
name|LINE_SIZE
operator|*
literal|3
index|]
decl_stmt|;
comment|/* ends raster graphics to set raster graphics resolution */
name|fputs
argument_list|(
literal|"\033*rB"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* set raster graphics resolution -- 90 or 180 dpi */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033*t%dR"
argument_list|,
name|X_DPI
argument_list|)
expr_stmt|;
comment|/* set the line width */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033*r%dS"
argument_list|,
name|DATA_SIZE
argument_list|)
expr_stmt|;
comment|/* set the number of color planes */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033*r%dU"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* always 3 */
comment|/* move to top left of page */
name|fputs
argument_list|(
literal|"\033&a0H\033&a0V"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* select data compression */
name|fputs
argument_list|(
literal|"\033*b1M"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* start raster graphics */
name|fputs
argument_list|(
literal|"\033*r1A"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* Send each scan line in turn */
block|{
name|int
name|lnum
decl_stmt|;
name|int
name|line_size
init|=
name|gdev_mem_bytes_per_scan_line
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|pdev
argument_list|)
decl_stmt|;
name|int
name|num_blank_lines
init|=
literal|0
decl_stmt|;
for|for
control|(
name|lnum
operator|=
literal|0
init|;
name|lnum
operator|<
name|pdev
operator|->
name|height
condition|;
name|lnum
operator|++
control|)
block|{
name|byte
name|_ss
modifier|*
name|end_data
init|=
name|data
operator|+
name|line_size
decl_stmt|;
name|gdev_prn_copy_scan_lines
argument_list|(
name|pdev
argument_list|,
name|lnum
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|data
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
comment|/* Remove trailing 0s. */
while|while
condition|(
name|end_data
operator|>
name|data
operator|&&
name|end_data
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|end_data
operator|--
expr_stmt|;
if|if
condition|(
name|end_data
operator|==
name|data
condition|)
block|{
comment|/* Blank line */
name|num_blank_lines
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|byte
name|_ss
modifier|*
name|odp
decl_stmt|;
name|byte
name|_ss
modifier|*
name|row
decl_stmt|;
comment|/* Pad with 0s to fill out the last */
comment|/* block of 8 bytes. */
name|memset
argument_list|(
name|end_data
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Transpose the data to get pixel planes. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|odp
operator|=
name|plane_data
init|;
name|i
operator|<
name|DATA_SIZE
condition|;
name|i
operator|+=
literal|8
operator|,
name|odp
operator|++
control|)
block|{
comment|/* The following is for 16-bit machines */
define|#
directive|define
name|spread3
parameter_list|(
name|c
parameter_list|)
define|\
value|{ 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }
specifier|static
name|ulong
name|spr40
index|[
literal|8
index|]
init|=
name|spread3
argument_list|(
literal|0x40
argument_list|)
decl_stmt|;
specifier|static
name|ulong
name|spr8
index|[
literal|8
index|]
init|=
name|spread3
argument_list|(
literal|8
argument_list|)
decl_stmt|;
specifier|static
name|ulong
name|spr2
index|[
literal|8
index|]
init|=
name|spread3
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|register
name|byte
name|_ss
modifier|*
name|dp
init|=
name|data
operator|+
name|i
decl_stmt|;
specifier|register
name|ulong
name|pword
init|=
operator|(
name|spr40
index|[
name|dp
index|[
literal|0
index|]
index|]
operator|<<
literal|1
operator|)
operator|+
operator|(
name|spr40
index|[
name|dp
index|[
literal|1
index|]
index|]
operator|)
operator|+
operator|(
name|spr40
index|[
name|dp
index|[
literal|2
index|]
index|]
operator|>>
literal|1
operator|)
operator|+
operator|(
name|spr8
index|[
name|dp
index|[
literal|3
index|]
index|]
operator|<<
literal|1
operator|)
operator|+
operator|(
name|spr8
index|[
name|dp
index|[
literal|4
index|]
index|]
operator|)
operator|+
operator|(
name|spr8
index|[
name|dp
index|[
literal|5
index|]
index|]
operator|>>
literal|1
operator|)
operator|+
operator|(
name|spr2
index|[
name|dp
index|[
literal|6
index|]
index|]
operator|)
operator|+
operator|(
name|spr2
index|[
name|dp
index|[
literal|7
index|]
index|]
operator|>>
literal|1
operator|)
decl_stmt|;
name|odp
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|pword
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|odp
index|[
name|LINE_SIZE
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|pword
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|odp
index|[
name|LINE_SIZE
operator|*
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|pword
argument_list|)
expr_stmt|;
block|}
comment|/* Skip blank lines if any */
if|if
condition|(
name|num_blank_lines
operator|>
literal|0
condition|)
block|{
comment|/* move down from current position */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033&a+%dV"
argument_list|,
name|num_blank_lines
operator|*
operator|(
literal|720
operator|/
name|Y_DPI
operator|)
argument_list|)
expr_stmt|;
name|num_blank_lines
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Transfer raster graphics */
comment|/* in the order R, G, B. */
for|for
control|(
name|row
operator|=
name|plane_data
operator|+
name|LINE_SIZE
operator|*
literal|2
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|row
operator|-=
name|LINE_SIZE
operator|,
name|i
operator|++
control|)
block|{
name|byte
name|temp
index|[
name|LINE_SIZE
operator|*
literal|2
index|]
decl_stmt|;
name|int
name|count
init|=
name|compress1_row
argument_list|(
name|row
argument_list|,
name|row
operator|+
name|LINE_SIZE
argument_list|,
name|temp
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033*b%d%c"
argument_list|,
name|count
argument_list|,
literal|"VVW"
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
argument_list|,
name|count
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end raster graphics */
name|fputs
argument_list|(
literal|"\033*r0B"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* eject page */
name|fputs
argument_list|(
literal|"\014"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Row compression for the H-P PaintJet.  * Compresses data from row up to end_row, storing the result  * starting at compressed.  Returns the number of bytes stored.  * The compressed format consists of a byte N followed by a  * data byte that is to be repeated N+1 times.  * In the worst case, the `compressed' representation is  * twice as large as the input.  * We complement the bytes at the same time, because  * we accumulated the image in complemented form.  */
end_comment

begin_function
name|private
name|int
name|compress1_row
parameter_list|(
name|byte
name|_ss
modifier|*
name|row
parameter_list|,
name|byte
name|_ss
modifier|*
name|end_row
parameter_list|,
name|byte
name|_ss
modifier|*
name|compressed
parameter_list|)
block|{
specifier|register
name|byte
name|_ss
modifier|*
name|in
init|=
name|row
decl_stmt|;
specifier|register
name|byte
name|_ss
modifier|*
name|out
init|=
name|compressed
decl_stmt|;
while|while
condition|(
name|in
operator|<
name|end_row
condition|)
block|{
name|byte
name|test
init|=
operator|*
name|in
operator|++
decl_stmt|;
name|byte
name|_ss
modifier|*
name|run
init|=
name|in
decl_stmt|;
while|while
condition|(
name|in
operator|<
name|end_row
operator|&&
operator|*
name|in
operator|==
name|test
condition|)
name|in
operator|++
expr_stmt|;
comment|/* Note that in - run + 1 is the repetition count. */
while|while
condition|(
name|in
operator|-
name|run
operator|>
literal|255
condition|)
block|{
operator|*
name|out
operator|++
operator|=
literal|255
expr_stmt|;
operator|*
name|out
operator|++
operator|=
operator|~
name|test
expr_stmt|;
name|run
operator|+=
literal|256
expr_stmt|;
block|}
operator|*
name|out
operator|++
operator|=
name|in
operator|-
name|run
expr_stmt|;
operator|*
name|out
operator|++
operator|=
operator|~
name|test
expr_stmt|;
block|}
return|return
name|out
operator|-
name|compressed
return|;
block|}
end_function

end_unit

