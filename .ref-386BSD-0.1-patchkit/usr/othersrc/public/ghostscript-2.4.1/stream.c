begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* stream.c */
end_comment

begin_comment
comment|/* Stream package for Ghostscript interpreter */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_include
include|#
directive|include
file|"scanchar.h"
end_include

begin_comment
comment|/* Forward declarations */
end_comment

begin_comment
comment|/* Generic */
end_comment

begin_comment
comment|/* Export these for filters */
end_comment

begin_decl_stmt
name|void
name|s_std_init
argument_list|(
name|P5
argument_list|(
name|stream
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|uint
argument_list|,
name|stream_procs
operator|*
argument_list|,
name|int
comment|/*mode*/
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s_std_null
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|s_std_noavailable
argument_list|(
name|P2
argument_list|(
name|stream
operator|*
argument_list|,
name|long
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|s_std_close
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Strings */
end_comment

begin_decl_stmt
name|private
name|int
name|s_string_read_buf
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|s_string_write_buf
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|s_string_available
argument_list|(
name|P2
argument_list|(
name|stream
operator|*
argument_list|,
name|long
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|s_string_seek
argument_list|(
name|P2
argument_list|(
name|stream
operator|*
argument_list|,
name|long
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|s_string_init
argument_list|(
name|P4
argument_list|(
name|stream
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|uint
argument_list|,
name|stream_procs
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Files */
end_comment

begin_decl_stmt
name|private
name|int
name|s_file_read_buf
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|s_file_available
argument_list|(
name|P2
argument_list|(
name|stream
operator|*
argument_list|,
name|long
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|s_file_read_seek
argument_list|(
name|P2
argument_list|(
name|stream
operator|*
argument_list|,
name|long
argument_list|)
argument_list|)
decl_stmt|,
name|s_file_read_close
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|s_file_write_buf
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|s_file_write_seek
argument_list|(
name|P2
argument_list|(
name|stream
operator|*
argument_list|,
name|long
argument_list|)
argument_list|)
decl_stmt|,
name|s_file_write_flush
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|s_file_write_close
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Generic procedures ------ */
end_comment

begin_comment
comment|/* Standard stream initialization */
end_comment

begin_function
name|void
name|s_std_init
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|byte
modifier|*
name|ptr
parameter_list|,
name|uint
name|len
parameter_list|,
name|stream_procs
modifier|*
name|pp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|s
operator|->
name|cbuf
operator|=
name|ptr
expr_stmt|;
name|s
operator|->
name|cptr
operator|=
name|ptr
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|endptr
operator|=
operator|(
name|mode
operator|==
name|s_mode_write
condition|?
name|s
operator|->
name|cptr
operator|+
name|len
else|:
name|s
operator|->
name|cptr
operator|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|s
operator|->
name|end_status
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|bsize
operator|=
name|s
operator|->
name|cbsize
operator|=
name|len
expr_stmt|;
name|s
operator|->
name|strm
operator|=
literal|0
expr_stmt|;
comment|/* not a filter */
name|s
operator|->
name|procs
operator|=
operator|*
name|pp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement a stream procedure as a no-op. */
end_comment

begin_function
name|int
name|s_std_null
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Indicate an error when asked for available input bytes. */
end_comment

begin_function
name|int
name|s_std_noavailable
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|,
name|long
modifier|*
name|pl
parameter_list|)
block|{
return|return
name|ERRC
return|;
block|}
end_function

begin_comment
comment|/* Standard stream finalization.  Disable the stream. */
end_comment

begin_function
name|int
name|s_std_close
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|s_disable
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|s_disable
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|bsize
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
comment|/****** SHOULD DO MORE THAN THIS ******/
block|}
end_function

begin_comment
comment|/* ------ Implementation-independent procedures ------ */
end_comment

begin_comment
comment|/* Implement sgetc when the buffer is empty, */
end_comment

begin_comment
comment|/* by refilling the buffer and then reading a byte. */
end_comment

begin_function
name|int
name|spgetc
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|end_status
condition|)
return|return
name|s
operator|->
name|end_status
return|;
name|code
operator|=
call|(
modifier|*
name|s
operator|->
name|procs
operator|.
name|read_buf
call|)
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|sendbufp
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
name|s
operator|->
name|end_status
condition|?
name|s
operator|->
name|end_status
else|:
name|EOFC
operator|)
return|;
return|return
operator|*
operator|++
operator|(
name|s
operator|->
name|cptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Implementing sputc when the buffer is full, */
end_comment

begin_comment
comment|/* by flushing the buffer and then writing the byte. */
end_comment

begin_function
name|int
name|spputc
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|byte
name|b
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|end_status
condition|)
return|return
name|s
operator|->
name|end_status
return|;
name|code
operator|=
call|(
modifier|*
name|s
operator|->
name|procs
operator|.
name|write_buf
call|)
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
name|sputc
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Push back a character onto a (read) stream. */
end_comment

begin_comment
comment|/* Return 0 on success, ERRC on failure. */
end_comment

begin_function
name|int
name|sungetc
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|byte
name|c
parameter_list|)
block|{
if|if
condition|(
operator|!
name|s_is_reading
argument_list|(
name|s
argument_list|)
operator|||
name|s
operator|->
name|cptr
operator|<
name|s
operator|->
name|cbuf
condition|)
return|return
name|ERRC
return|;
operator|*
operator|(
name|s
operator|->
name|cptr
operator|)
operator|--
operator|=
name|c
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read a string from a stream. */
end_comment

begin_comment
comment|/* Return the number of bytes read. */
end_comment

begin_function
name|uint
name|sgets
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|byte
modifier|*
name|str
parameter_list|,
name|uint
name|rlen
parameter_list|)
block|{
name|uint
name|len
init|=
name|rlen
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|uint
name|count
init|=
name|sbufavailable
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|end_status
condition|)
return|return
name|rlen
operator|-
name|len
return|;
name|code
operator|=
call|(
modifier|*
name|s
operator|->
name|procs
operator|.
name|read_buf
call|)
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
operator|||
name|sendbufp
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|rlen
operator|-
name|len
return|;
continue|continue;
block|}
if|if
condition|(
name|count
operator|>
name|len
condition|)
name|count
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|s
operator|->
name|cptr
operator|+
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|->
name|cptr
operator|+=
name|count
expr_stmt|;
name|str
operator|+=
name|count
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
block|}
return|return
name|rlen
return|;
block|}
end_function

begin_comment
comment|/* Write a string on a stream. */
end_comment

begin_comment
comment|/* Return the number of bytes written. */
end_comment

begin_function
name|uint
name|sputs
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
specifier|const
name|byte
modifier|*
name|str
parameter_list|,
name|uint
name|wlen
parameter_list|)
block|{
name|uint
name|len
init|=
name|wlen
decl_stmt|;
if|if
condition|(
name|wlen
operator|>
name|s
operator|->
name|bsize
operator|&&
name|s
operator|->
name|procs
operator|.
name|write_buf
operator|==
name|s_file_write_buf
condition|)
block|{
comment|/* Write directly on the file. */
name|uint
name|write_count
decl_stmt|;
call|(
modifier|*
name|s
operator|->
name|procs
operator|.
name|write_buf
call|)
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|write_count
operator|=
name|fwrite
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|wlen
argument_list|,
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|position
operator|>=
literal|0
condition|)
comment|/* file is positionable */
name|s
operator|->
name|position
operator|=
name|ftell
argument_list|(
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
name|write_count
return|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|uint
name|count
init|=
name|sbufavailable
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>
name|len
condition|)
name|count
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|cptr
operator|+
literal|1
argument_list|,
name|str
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|->
name|cptr
operator|+=
name|count
expr_stmt|;
name|str
operator|+=
name|count
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
block|}
else|else
block|{
name|byte
name|ch
init|=
operator|*
name|str
operator|++
decl_stmt|;
name|sputc
argument_list|(
name|s
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|end_status
condition|)
return|return
name|wlen
operator|-
name|len
return|;
name|len
operator|--
expr_stmt|;
block|}
block|}
return|return
name|wlen
return|;
block|}
end_function

begin_comment
comment|/* Read a hex string from a stream. */
end_comment

begin_comment
comment|/* Answer EOFC if we reached end-of-file before filling the string, */
end_comment

begin_comment
comment|/* 0 if we filled the string first, or ERRC on error. */
end_comment

begin_comment
comment|/* s->odd should be -1 initially: */
end_comment

begin_comment
comment|/* if an odd number of hex digits was read, s->odd is set to */
end_comment

begin_comment
comment|/* the odd digit value, otherwise s->odd is set to -1. */
end_comment

begin_comment
comment|/* If ignore_garbage is true, characters other than hex digits are ignored; */
end_comment

begin_comment
comment|/* if ignore_garbage is false, characters other than hex digits or */
end_comment

begin_comment
comment|/* whitespace return an error. */
end_comment

begin_function
name|int
name|sreadhex
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|,
name|byte
modifier|*
name|str
parameter_list|,
name|uint
name|rlen
parameter_list|,
name|uint
modifier|*
name|nread
parameter_list|,
name|int
modifier|*
name|odd_digit
parameter_list|,
name|int
name|ignore_garbage
parameter_list|)
block|{
name|byte
modifier|*
name|ptr
init|=
name|str
decl_stmt|;
name|byte
modifier|*
name|limit
init|=
name|ptr
operator|+
name|rlen
decl_stmt|;
name|byte
name|val1
init|=
operator|(
name|byte
operator|)
operator|*
name|odd_digit
decl_stmt|;
name|byte
name|val2
decl_stmt|;
name|byte
name|save_last
decl_stmt|;
specifier|register
name|byte
name|_ds
modifier|*
name|decoder
init|=
name|scan_char_decoder
decl_stmt|;
specifier|register
name|byte
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|code
decl_stmt|;
define|#
directive|define
name|begin_inline
parameter_list|(
name|sptr
parameter_list|,
name|endp
parameter_list|,
name|s
parameter_list|)
define|\
value|(sptr = s->cptr, endp = s->endptr - 1)
define|#
directive|define
name|sgetc_inline
parameter_list|(
name|sptr
parameter_list|,
name|endp
parameter_list|,
name|s
parameter_list|)
define|\
value|(sptr<= endp ? *++sptr :\    (end_inline(sptr, s), ch = spgetc(s), begin_inline(sptr, endp, s), ch))
define|#
directive|define
name|end_inline
parameter_list|(
name|sptr
parameter_list|,
name|s
parameter_list|)
define|\
value|(s->cptr = sptr)
if|if
condition|(
name|rlen
operator|==
literal|0
condition|)
block|{
operator|*
name|nread
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|begin_inline
argument_list|(
name|sptr
argument_list|,
name|endp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|val1
operator|<=
literal|0xf
condition|)
goto|goto
name|d2
goto|;
name|d1
label|:
comment|/* Fast check for common case */
if|if
condition|(
name|sptr
operator|>=
name|endp
condition|)
goto|goto
name|x1
goto|;
comment|/* no last char to save */
name|save_last
operator|=
operator|*
name|endp
expr_stmt|;
operator|*
name|endp
operator|=
literal|' '
expr_stmt|;
comment|/* force exit from fast loop */
name|f1
label|:
if|if
condition|(
operator|(
name|val1
operator|=
name|decoder
index|[
name|sptr
index|[
literal|1
index|]
index|]
operator|)
operator|<=
literal|0xf
operator|&&
operator|(
name|val2
operator|=
name|decoder
index|[
name|sptr
index|[
literal|2
index|]
index|]
operator|)
operator|<=
literal|0xf
condition|)
block|{
name|sptr
operator|+=
literal|2
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
operator|(
name|val1
operator|<<
literal|4
operator|)
operator|+
name|val2
expr_stmt|;
if|if
condition|(
name|ptr
operator|<
name|limit
condition|)
goto|goto
name|f1
goto|;
operator|*
name|endp
operator|=
name|save_last
expr_stmt|;
goto|goto
name|px
goto|;
block|}
operator|*
name|endp
operator|=
name|save_last
expr_stmt|;
name|x1
label|:
while|while
condition|(
operator|(
name|val1
operator|=
name|decoder
index|[
name|sgetc_inline
argument_list|(
name|sptr
argument_list|,
name|endp
argument_list|,
name|s
argument_list|)
index|]
operator|)
operator|>
literal|0xf
condition|)
block|{
if|if
condition|(
name|val1
operator|==
name|ctype_eof
condition|)
block|{
name|code
operator|=
name|ch
expr_stmt|;
operator|*
name|odd_digit
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|ended
goto|;
block|}
elseif|else
if|if
condition|(
name|val1
operator|!=
name|ctype_space
operator|&&
operator|!
name|ignore_garbage
condition|)
block|{
name|sptr
operator|--
expr_stmt|;
operator|*
name|odd_digit
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|d2
label|:
while|while
condition|(
operator|(
name|val2
operator|=
name|decoder
index|[
name|sgetc_inline
argument_list|(
name|sptr
argument_list|,
name|endp
argument_list|,
name|s
argument_list|)
index|]
operator|)
operator|>
literal|0xf
condition|)
block|{
if|if
condition|(
name|val2
operator|==
name|ctype_eof
condition|)
block|{
name|code
operator|=
name|ch
expr_stmt|;
operator|*
name|odd_digit
operator|=
name|val1
expr_stmt|;
goto|goto
name|ended
goto|;
block|}
elseif|else
if|if
condition|(
name|val2
operator|!=
name|ctype_space
operator|&&
operator|!
name|ignore_garbage
condition|)
block|{
name|sptr
operator|--
expr_stmt|;
operator|*
name|odd_digit
operator|=
name|val1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
operator|*
name|ptr
operator|++
operator|=
operator|(
name|val1
operator|<<
literal|4
operator|)
operator|+
name|val2
expr_stmt|;
if|if
condition|(
name|ptr
operator|<
name|limit
condition|)
goto|goto
name|d1
goto|;
name|px
label|:
operator|*
name|nread
operator|=
name|rlen
expr_stmt|;
name|end_inline
argument_list|(
name|sptr
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|code
operator|=
name|ERRC
expr_stmt|;
name|ended
label|:
operator|*
name|nread
operator|=
name|ptr
operator|-
name|str
expr_stmt|;
name|end_inline
argument_list|(
name|sptr
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ String streams ------ */
end_comment

begin_comment
comment|/* Initialize a stream for reading a string. */
end_comment

begin_function
name|void
name|sread_string
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|byte
modifier|*
name|ptr
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
specifier|static
name|stream_procs
name|p
init|=
block|{
name|s_string_available
block|,
name|s_string_seek
block|,
name|s_std_null
block|,
name|s_std_null
block|,
name|s_string_read_buf
block|,
name|NULL
block|}
decl_stmt|;
name|s_string_init
argument_list|(
name|s
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|s_mode_read
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle end-of-buffer when reading from a string. */
end_comment

begin_function
name|private
name|int
name|s_string_read_buf
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|endptr
expr_stmt|;
name|s
operator|->
name|end_status
operator|=
name|EOFC
expr_stmt|;
return|return
name|EOFC
return|;
block|}
end_function

begin_comment
comment|/* Return the number of available bytes when reading from a string. */
end_comment

begin_function
name|private
name|int
name|s_string_available
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|,
name|long
modifier|*
name|pl
parameter_list|)
block|{
operator|*
name|pl
operator|=
name|sbufavailable
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pl
operator|==
literal|0
condition|)
operator|*
name|pl
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* EOF */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Initialize a stream for writing a string. */
end_comment

begin_function
name|void
name|swrite_string
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|byte
modifier|*
name|ptr
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
specifier|static
name|stream_procs
name|p
init|=
block|{
name|s_std_noavailable
block|,
name|s_string_seek
block|,
name|s_std_null
block|,
name|s_std_null
block|,
name|NULL
block|,
name|s_string_write_buf
block|}
decl_stmt|;
name|s_string_init
argument_list|(
name|s
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|s_mode_write
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle end-of-buffer when writing a string. */
end_comment

begin_function
name|private
name|int
name|s_string_write_buf
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|endptr
expr_stmt|;
name|s
operator|->
name|end_status
operator|=
name|EOFC
expr_stmt|;
return|return
name|EOFC
return|;
block|}
end_function

begin_comment
comment|/* Seek in a string.  Return 0 if OK, ERRC if not. */
end_comment

begin_function
name|private
name|int
name|s_string_seek
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|long
name|pos
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|<
literal|0
operator|||
name|pos
operator|>
name|s
operator|->
name|bsize
condition|)
return|return
name|ERRC
return|;
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|+
name|pos
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Private initialization */
end_comment

begin_function
name|private
name|void
name|s_string_init
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|byte
modifier|*
name|ptr
parameter_list|,
name|uint
name|len
parameter_list|,
name|stream_procs
modifier|*
name|p
parameter_list|)
block|{
name|s_std_init
argument_list|(
name|s
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|,
name|p
argument_list|,
name|s_mode_write
argument_list|)
expr_stmt|;
name|s
operator|->
name|end_status
operator|=
name|EOFC
expr_stmt|;
comment|/* this is all there is */
name|s
operator|->
name|position
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|file
operator|=
literal|0
expr_stmt|;
comment|/* not a file stream */
block|}
end_function

begin_comment
comment|/* ------ File streams ------ */
end_comment

begin_comment
comment|/* Initialize a stream for reading an OS file. */
end_comment

begin_function
name|void
name|sread_file
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|byte
modifier|*
name|buf
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
specifier|static
name|stream_procs
name|p
init|=
block|{
name|s_file_available
block|,
name|s_file_read_seek
block|,
name|s_std_null
block|,
name|s_file_read_close
block|,
name|s_file_read_buf
block|,
name|NULL
block|}
decl_stmt|;
name|s_std_init
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|p
argument_list|,
name|s_mode_read
argument_list|)
expr_stmt|;
name|s
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|s
operator|->
name|position
operator|=
operator|(
name|file
operator|==
name|stdin
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Procedures for reading from a file */
end_comment

begin_function
name|private
name|int
name|s_file_read_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|int
name|nread
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|position
operator|>=
literal|0
condition|)
comment|/* file is positionable */
name|s
operator|->
name|position
operator|=
name|ftell
argument_list|(
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
name|nread
operator|=
name|fread
argument_list|(
name|s
operator|->
name|cbuf
argument_list|,
literal|1
argument_list|,
name|s
operator|->
name|bsize
argument_list|,
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|end_status
operator|=
operator|(
name|ferror
argument_list|(
name|s
operator|->
name|file
argument_list|)
condition|?
name|ERRC
else|:
name|feof
argument_list|(
name|s
operator|->
name|file
argument_list|)
condition|?
name|EOFC
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
name|nread
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|endptr
operator|=
name|s
operator|->
name|cptr
operator|+
name|nread
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|s_file_available
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|long
modifier|*
name|pl
parameter_list|)
block|{
operator|*
name|pl
operator|=
name|sbufavailable
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sseekable
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|long
name|pos
decl_stmt|,
name|end
decl_stmt|;
name|pos
operator|=
name|ftell
argument_list|(
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|s
operator|->
name|file
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|ERRC
return|;
name|end
operator|=
name|ftell
argument_list|(
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|ERRC
return|;
operator|*
name|pl
operator|+=
name|end
operator|-
name|pos
expr_stmt|;
if|if
condition|(
operator|*
name|pl
operator|==
literal|0
condition|)
operator|*
name|pl
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* EOF */
block|}
else|else
block|{
if|if
condition|(
operator|*
name|pl
operator|==
literal|0
operator|&&
name|feof
argument_list|(
name|s
operator|->
name|file
argument_list|)
condition|)
operator|*
name|pl
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* EOF */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|s_file_read_seek
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|long
name|pos
parameter_list|)
block|{
name|uint
name|end
init|=
name|s
operator|->
name|endptr
operator|-
name|s
operator|->
name|cbuf
operator|+
literal|1
decl_stmt|;
name|long
name|offset
init|=
name|pos
operator|-
name|s
operator|->
name|position
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
operator|&&
name|offset
operator|<=
name|end
condition|)
block|{
comment|/* Staying within the same buffer */
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|+
name|offset
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fseek
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ERRC
return|;
name|s
operator|->
name|endptr
operator|=
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|end_status
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|s_file_read_close
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|)
block|{
return|return
name|fclose
argument_list|(
name|s
operator|->
name|file
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize a stream for writing an OS file. */
end_comment

begin_function
name|void
name|swrite_file
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|byte
modifier|*
name|buf
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
specifier|static
name|stream_procs
name|p
init|=
block|{
name|s_std_noavailable
block|,
name|s_file_write_seek
block|,
name|s_file_write_flush
block|,
name|s_file_write_close
block|,
name|NULL
block|,
name|s_file_write_buf
block|}
decl_stmt|;
name|s_std_init
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|p
argument_list|,
name|s_mode_write
argument_list|)
expr_stmt|;
name|s
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|s
operator|->
name|position
operator|=
operator|(
name|file
operator|==
name|stdout
operator|||
name|file
operator|==
name|stderr
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Procedures for writing on a file */
end_comment

begin_function
name|private
name|int
name|s_file_write_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|uint
name|count
init|=
name|s
operator|->
name|cptr
operator|+
literal|1
operator|-
name|s
operator|->
name|cbuf
decl_stmt|;
name|uint
name|write_count
init|=
name|fwrite
argument_list|(
name|s
operator|->
name|cbuf
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|s
operator|->
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|position
operator|>=
literal|0
condition|)
comment|/* file is positionable */
name|s
operator|->
name|position
operator|=
name|ftell
argument_list|(
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|write_count
operator|!=
name|count
condition|)
block|{
name|s
operator|->
name|end_status
operator|=
operator|(
name|ferror
argument_list|(
name|s
operator|->
name|file
argument_list|)
condition|?
name|ERRC
else|:
name|EOFC
operator|)
expr_stmt|;
name|s
operator|->
name|endptr
operator|=
name|s
operator|->
name|cptr
expr_stmt|;
block|}
else|else
name|s
operator|->
name|endptr
operator|=
name|s
operator|->
name|cptr
operator|+
name|s
operator|->
name|bsize
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|s_file_write_seek
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|,
name|long
name|pos
parameter_list|)
block|{
comment|/* Output files are not positionable */
return|return
name|ERRC
return|;
block|}
end_function

begin_function
name|private
name|int
name|s_file_write_flush
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|int
name|result
init|=
name|s_file_write_buf
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|fflush
argument_list|(
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|private
name|int
name|s_file_write_close
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|s_file_write_buf
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|fclose
argument_list|(
name|s
operator|->
name|file
argument_list|)
return|;
block|}
end_function

end_unit

