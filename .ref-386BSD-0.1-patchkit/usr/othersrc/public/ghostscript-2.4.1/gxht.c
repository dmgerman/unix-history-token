begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gxht.c */
end_comment

begin_comment
comment|/* Halftone rendering routines for Ghostscript imaging library */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_comment
comment|/* for gxdevice.h */
end_comment

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzdevice.h"
end_include

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_comment
comment|/* requires gxdevice.h */
end_comment

begin_include
include|#
directive|include
file|"gzht.h"
end_include

begin_decl_stmt
specifier|extern
name|ulong
name|gs_next_ids
argument_list|(
name|P1
argument_list|(
name|uint
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We don't want to remember all the values of the halftone screen,  * because they would take up space proportional to P^3, where P is  * the number of pixels in a cell.  Instead, we pick some number N of  * patterns to cache.  Each cache slot covers a range of (P+1)/N  * different gray levels: we "slide" the contents of the slot back and  * forth within this range by incrementally adding and dropping 1-bits.  * N>=0 (obviously); N<=P+1 (likewise); also, so that we can simplify things  * by preallocating the bookkeeping information for the cache, we define  * a constant max_cached_tiles which is an a priori maximum value for N.  *  * Note that the raster for each tile must be a multiple of 32 bits,  * to satisfy the copy_mono device routine, even though a multiple of  * 16 bits would otherwise be sufficient.  */
end_comment

begin_comment
comment|/*** Big memory machines ***/
end_comment

begin_define
define|#
directive|define
name|max_cached_tiles_LARGE
value|256
end_define

begin_define
define|#
directive|define
name|max_ht_bits_LARGE
value|35000
end_define

begin_comment
comment|/*** Small memory machines ***/
end_comment

begin_define
define|#
directive|define
name|max_cached_tiles_SMALL
value|25
end_define

begin_define
define|#
directive|define
name|max_ht_bits_SMALL
value|1000
end_define

begin_if
if|#
directive|if
name|arch_ints_are_short
end_if

begin_define
define|#
directive|define
name|max_cached_tiles
value|max_cached_tiles_SMALL
end_define

begin_define
define|#
directive|define
name|max_ht_bits
value|max_ht_bits_SMALL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|max_cached_tiles
value|max_cached_tiles_LARGE
end_define

begin_define
define|#
directive|define
name|max_ht_bits
value|max_ht_bits_LARGE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|bit_tile_s
block|{
name|int
name|level
decl_stmt|;
comment|/* the cached gray level, i.e. */
comment|/* the number of spots whitened, */
comment|/* or -1 if the cache is empty */
name|gx_bitmap
name|tile
decl_stmt|;
comment|/* the currently rendered tile */
block|}
name|bit_tile
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|gx_ht_cache_s
block|{
comment|/* The following are set when the cache is created. */
name|byte
modifier|*
name|bits
decl_stmt|;
comment|/* the base of the bits */
name|uint
name|bits_size
decl_stmt|;
comment|/* the space available for bits */
comment|/* The following are reset each time the cache is initialized */
comment|/* for a new screen. */
name|ht_bit
modifier|*
name|order
decl_stmt|;
comment|/* the cached order vector */
name|int
name|num_cached
decl_stmt|;
comment|/* actual # of cached tiles */
name|int
name|levels_per_tile
decl_stmt|;
comment|/* # of levels per cached tile */
name|bit_tile
name|tiles
index|[
name|max_cached_tiles
index|]
decl_stmt|;
comment|/* the cached tiles */
name|gx_bitmap_id
name|base_id
decl_stmt|;
comment|/* the base id, to which */
comment|/* we add the halftone level */
block|}
name|ht_cache
typedef|;
end_typedef

begin_decl_stmt
name|private
name|ht_cache
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|byte
name|cache_bits
index|[
name|max_ht_bits
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit masks for whitening vector.  The high-order byte always comes */
end_comment

begin_comment
comment|/* first.  We have to define the masks as bit16 to ensure that */
end_comment

begin_comment
comment|/* they will be properly aligned in memory on machines that care. */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|short
name|bit16
typedef|;
end_typedef

begin_if
if|#
directive|if
name|arch_is_big_endian
end_if

begin_define
define|#
directive|define
name|b2
parameter_list|(
name|hi
parameter_list|,
name|lo
parameter_list|)
value|(hi<<8)+lo
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|b2
parameter_list|(
name|hi
parameter_list|,
name|lo
parameter_list|)
value|(lo<<8)+hi
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|bit16
name|single_bits
index|[
literal|16
index|]
init|=
block|{
name|b2
argument_list|(
literal|0x80
argument_list|,
literal|0
argument_list|)
block|,
name|b2
argument_list|(
literal|0x40
argument_list|,
literal|0
argument_list|)
block|,
name|b2
argument_list|(
literal|0x20
argument_list|,
literal|0
argument_list|)
block|,
name|b2
argument_list|(
literal|0x10
argument_list|,
literal|0
argument_list|)
block|,
name|b2
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
block|,
name|b2
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
block|,
name|b2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
block|,
name|b2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|b2
argument_list|(
literal|0
argument_list|,
literal|0x80
argument_list|)
block|,
name|b2
argument_list|(
literal|0
argument_list|,
literal|0x40
argument_list|)
block|,
name|b2
argument_list|(
literal|0
argument_list|,
literal|0x20
argument_list|)
block|,
name|b2
argument_list|(
literal|0
argument_list|,
literal|0x10
argument_list|)
block|,
name|b2
argument_list|(
literal|0
argument_list|,
literal|8
argument_list|)
block|,
name|b2
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
block|,
name|b2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
block|,
name|b2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|bit16
name|mb1
index|[
literal|1
index|]
init|=
block|{
name|b2
argument_list|(
literal|0xff
argument_list|,
literal|0xff
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|bit16
name|mb2
index|[
literal|2
index|]
init|=
block|{
name|b2
argument_list|(
literal|0xaa
argument_list|,
literal|0xaa
argument_list|)
block|,
name|b2
argument_list|(
literal|0x55
argument_list|,
literal|0x55
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|bit16
name|mb3
index|[
literal|3
index|]
init|=
block|{
name|b2
argument_list|(
literal|0x92
argument_list|,
literal|0x49
argument_list|)
block|,
name|b2
argument_list|(
literal|0x49
argument_list|,
literal|0x24
argument_list|)
block|,
name|b2
argument_list|(
literal|0x24
argument_list|,
literal|0x92
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|bit16
name|mb4
index|[
literal|4
index|]
init|=
block|{
name|b2
argument_list|(
literal|0x88
argument_list|,
literal|0x88
argument_list|)
block|,
name|b2
argument_list|(
literal|0x44
argument_list|,
literal|0x44
argument_list|)
block|,
name|b2
argument_list|(
literal|0x22
argument_list|,
literal|0x22
argument_list|)
block|,
name|b2
argument_list|(
literal|0x11
argument_list|,
literal|0x11
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|bit16
name|mb5
index|[
literal|5
index|]
init|=
block|{
name|b2
argument_list|(
literal|0x84
argument_list|,
literal|0x21
argument_list|)
block|,
name|b2
argument_list|(
literal|0x42
argument_list|,
literal|0x10
argument_list|)
block|,
name|b2
argument_list|(
literal|0x21
argument_list|,
literal|0x08
argument_list|)
block|,
name|b2
argument_list|(
literal|0x10
argument_list|,
literal|0x84
argument_list|)
block|,
name|b2
argument_list|(
literal|0x08
argument_list|,
literal|0x42
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|bit16
name|mb6
index|[
literal|6
index|]
init|=
block|{
name|b2
argument_list|(
literal|0x82
argument_list|,
literal|0x08
argument_list|)
block|,
name|b2
argument_list|(
literal|0x41
argument_list|,
literal|0x04
argument_list|)
block|,
name|b2
argument_list|(
literal|0x20
argument_list|,
literal|0x82
argument_list|)
block|,
name|b2
argument_list|(
literal|0x10
argument_list|,
literal|0x41
argument_list|)
block|,
name|b2
argument_list|(
literal|0x08
argument_list|,
literal|0x20
argument_list|)
block|,
name|b2
argument_list|(
literal|0x04
argument_list|,
literal|0x10
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|bit16
name|mb7
index|[
literal|7
index|]
init|=
block|{
name|b2
argument_list|(
literal|0x81
argument_list|,
literal|0x02
argument_list|)
block|,
name|b2
argument_list|(
literal|0x40
argument_list|,
literal|0x81
argument_list|)
block|,
name|b2
argument_list|(
literal|0x20
argument_list|,
literal|0x40
argument_list|)
block|,
name|b2
argument_list|(
literal|0x10
argument_list|,
literal|0x20
argument_list|)
block|,
name|b2
argument_list|(
literal|0x08
argument_list|,
literal|0x10
argument_list|)
block|,
name|b2
argument_list|(
literal|0x04
argument_list|,
literal|0x08
argument_list|)
block|,
name|b2
argument_list|(
literal|0x02
argument_list|,
literal|0x04
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|bit16
name|mb8
index|[
literal|8
index|]
init|=
block|{
name|b2
argument_list|(
literal|0x80
argument_list|,
literal|0x80
argument_list|)
block|,
name|b2
argument_list|(
literal|0x40
argument_list|,
literal|0x40
argument_list|)
block|,
name|b2
argument_list|(
literal|0x20
argument_list|,
literal|0x20
argument_list|)
block|,
name|b2
argument_list|(
literal|0x10
argument_list|,
literal|0x10
argument_list|)
block|,
name|b2
argument_list|(
literal|0x08
argument_list|,
literal|0x08
argument_list|)
block|,
name|b2
argument_list|(
literal|0x04
argument_list|,
literal|0x04
argument_list|)
block|,
name|b2
argument_list|(
literal|0x02
argument_list|,
literal|0x02
argument_list|)
block|,
name|b2
argument_list|(
literal|0x01
argument_list|,
literal|0x01
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|b2
end_undef

begin_decl_stmt
name|private
name|bit16
modifier|*
name|multi_bits
index|[
literal|9
index|]
init|=
block|{
literal|0
block|,
name|mb1
block|,
name|mb2
block|,
name|mb3
block|,
name|mb4
block|,
name|mb5
block|,
name|mb6
block|,
name|mb7
block|,
name|mb8
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Construct the order vector.  order is an array of ht_bits: */
end_comment

begin_comment
comment|/* order[i].offset contains the index of the bit position */
end_comment

begin_comment
comment|/* that is i'th in the whitening order. */
end_comment

begin_function
name|int
name|gx_ht_construct_order
parameter_list|(
name|ht_bit
modifier|*
name|order
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|uint
name|i
decl_stmt|;
name|uint
name|size
init|=
call|(
name|uint
call|)
argument_list|(
name|width
operator|*
name|height
argument_list|)
decl_stmt|;
name|int
name|padding
init|=
operator|(
operator|-
name|width
operator|)
operator|&
literal|31
decl_stmt|;
if|if
condition|(
operator|(
name|width
operator|+
name|padding
operator|)
operator|/
literal|8
operator|*
name|height
operator|>
name|max_ht_bits
condition|)
name|return_error
argument_list|(
name|gs_error_limitcheck
argument_list|)
expr_stmt|;
comment|/* can't cache the rendering */
comment|/* Clear the cache, to avoid confusion in case */
comment|/* the address of a new order vector matches that of a */
comment|/* (deallocated) old one. */
name|cache
operator|.
name|order
operator|=
name|NULL
expr_stmt|;
name|cache
operator|.
name|bits
operator|=
name|cache_bits
expr_stmt|;
name|cache
operator|.
name|bits_size
operator|=
name|max_ht_bits
expr_stmt|;
comment|/* Convert sequential indices to */
comment|/* byte indices and mask values. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pix
init|=
name|order
index|[
name|i
index|]
operator|.
name|offset
decl_stmt|;
name|pix
operator|+=
name|pix
operator|/
name|width
operator|*
name|padding
expr_stmt|;
name|order
index|[
name|i
index|]
operator|.
name|offset
operator|=
operator|(
name|pix
operator|>>
literal|4
operator|)
operator|<<
literal|1
expr_stmt|;
name|order
index|[
name|i
index|]
operator|.
name|mask
operator|=
operator|(
name|width
operator|<=
literal|8
condition|?
name|multi_bits
index|[
name|width
index|]
index|[
name|pix
operator|&
literal|15
index|]
else|:
name|single_bits
index|[
name|pix
operator|&
literal|15
index|]
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'h'
index|]
condition|)
block|{
name|dprintf1
argument_list|(
literal|"[h]Halftone order %lx:\n"
argument_list|,
operator|(
name|ulong
operator|)
name|order
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|dprintf3
argument_list|(
literal|"%4d: %u:%x\n"
argument_list|,
name|i
argument_list|,
name|order
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|order
index|[
name|i
index|]
operator|.
name|mask
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Make the cache order current, and return whether */
end_comment

begin_comment
comment|/* there is room for all possible tiles in the cache. */
end_comment

begin_decl_stmt
name|private
name|void
name|init_ht
argument_list|(
name|P2
argument_list|(
name|ht_cache
operator|*
argument_list|,
name|halftone_params
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|gx_check_tile_cache
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|halftone_params
modifier|*
name|pht
init|=
name|pgs
operator|->
name|halftone
decl_stmt|;
if|if
condition|(
name|cache
operator|.
name|order
operator|!=
name|pht
operator|->
name|order
condition|)
name|init_ht
argument_list|(
operator|&
name|cache
argument_list|,
name|pht
argument_list|)
expr_stmt|;
return|return
name|cache
operator|.
name|levels_per_tile
operator|==
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determine whether a given (width, y, height) might fit into a */
end_comment

begin_comment
comment|/* single tile. If so, return the byte offset of the appropriate row */
end_comment

begin_comment
comment|/* from the beginning of the tile; if not, return -1. */
end_comment

begin_function
name|int
name|gx_check_tile_size
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|int
name|tsy
decl_stmt|;
define|#
directive|define
name|tile0
value|cache.tiles[0].tile
comment|/* a typical tile */
if|if
condition|(
name|h
operator|>
name|tile0
operator|.
name|rep_height
operator|||
name|w
operator|>
name|tile0
operator|.
name|rep_width
condition|)
return|return
operator|-
literal|1
return|;
name|tsy
operator|=
operator|(
name|y
operator|+
name|pgs
operator|->
name|phase_mod
operator|.
name|y
operator|)
operator|%
name|tile0
operator|.
name|rep_height
expr_stmt|;
if|if
condition|(
name|tsy
operator|+
name|h
operator|>
name|tile0
operator|.
name|size
operator|.
name|y
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Tile fits in Y, might fit in X. */
return|return
name|tsy
operator|*
name|tile0
operator|.
name|raster
return|;
undef|#
directive|undef
name|tile0
block|}
end_function

begin_comment
comment|/* Load the device color into the halftone cache if needed. */
end_comment

begin_decl_stmt
name|private
name|void
name|render_ht
argument_list|(
name|P4
argument_list|(
name|bit_tile
operator|*
argument_list|,
name|int
argument_list|,
name|halftone_params
operator|*
argument_list|,
name|gx_bitmap_id
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|gx_color_load
parameter_list|(
name|gx_device_color
modifier|*
name|pdevc
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|int
name|level
init|=
name|pdevc
operator|->
name|halftone_level
decl_stmt|;
name|halftone_params
modifier|*
name|pht
decl_stmt|;
name|bit_tile
modifier|*
name|bt
decl_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
return|return;
comment|/* no halftone */
name|pht
operator|=
name|pgs
operator|->
name|halftone
expr_stmt|;
if|if
condition|(
name|cache
operator|.
name|order
operator|!=
name|pht
operator|->
name|order
condition|)
name|init_ht
argument_list|(
operator|&
name|cache
argument_list|,
name|pht
argument_list|)
expr_stmt|;
name|bt
operator|=
operator|&
name|cache
operator|.
name|tiles
index|[
name|level
operator|/
name|cache
operator|.
name|levels_per_tile
index|]
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|level
operator|!=
name|level
condition|)
name|render_ht
argument_list|(
name|bt
argument_list|,
name|level
argument_list|,
name|pht
argument_list|,
name|cache
operator|.
name|base_id
argument_list|)
expr_stmt|;
name|pdevc
operator|->
name|tile
operator|=
operator|&
name|bt
operator|->
name|tile
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the tile cache for a given screen. */
end_comment

begin_comment
comment|/* Cache as many different levels as will fit. */
end_comment

begin_function
name|private
name|void
name|init_ht
parameter_list|(
name|ht_cache
modifier|*
name|pcache
parameter_list|,
name|halftone_params
modifier|*
name|pht
parameter_list|)
block|{
name|int
name|width
init|=
name|pht
operator|->
name|width
decl_stmt|;
name|int
name|height
init|=
name|pht
operator|->
name|height
decl_stmt|;
name|int
name|size
init|=
name|width
operator|*
name|height
decl_stmt|;
specifier|static
name|int
name|up_to_16
index|[]
init|=
comment|/* up_to_16[i] = 16 / i * i */
block|{
literal|0
block|,
literal|16
block|,
literal|16
block|,
literal|15
block|,
literal|16
block|,
literal|15
block|,
literal|12
block|,
literal|14
block|,
literal|16
block|}
decl_stmt|;
name|int
name|width_unit
init|=
operator|(
name|width
operator|<=
literal|8
condition|?
name|up_to_16
index|[
name|width
index|]
else|:
name|width
operator|)
decl_stmt|;
name|int
name|height_unit
init|=
name|height
decl_stmt|;
name|uint
name|raster
init|=
operator|(
operator|(
name|width
operator|+
literal|31
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|2
decl_stmt|;
name|uint
name|tile_bytes
init|=
name|raster
operator|*
name|height
decl_stmt|;
name|int
name|num_cached
decl_stmt|;
name|int
name|i
decl_stmt|;
name|byte
modifier|*
name|tbits
init|=
name|pcache
operator|->
name|bits
decl_stmt|;
comment|/* Make sure num_cached is within bounds */
name|num_cached
operator|=
name|max_ht_bits
operator|/
name|tile_bytes
expr_stmt|;
if|if
condition|(
name|num_cached
operator|>
name|size
condition|)
name|num_cached
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|num_cached
operator|>
name|max_cached_tiles
condition|)
name|num_cached
operator|=
name|max_cached_tiles
expr_stmt|;
if|if
condition|(
name|num_cached
operator|==
name|size
operator|&&
name|tile_bytes
operator|*
name|num_cached
operator|<=
name|max_ht_bits
operator|/
literal|2
condition|)
comment|/* was num_cached<= max_cached_tiles / 2 ) */
block|{
comment|/* We can afford to replicate every tile vertically, */
comment|/* which will reduce breakage when tiling. */
name|height_unit
operator|<<=
literal|1
operator|,
name|tile_bytes
operator|<<=
literal|1
expr_stmt|;
block|}
name|pcache
operator|->
name|base_id
operator|=
name|gs_next_ids
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_cached
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|bit_tile
modifier|*
name|bt
init|=
operator|&
name|pcache
operator|->
name|tiles
index|[
name|i
index|]
decl_stmt|;
name|bt
operator|->
name|level
operator|=
operator|-
literal|1
expr_stmt|;
name|bt
operator|->
name|tile
operator|.
name|data
operator|=
name|tbits
expr_stmt|;
name|bt
operator|->
name|tile
operator|.
name|raster
operator|=
name|raster
expr_stmt|;
name|bt
operator|->
name|tile
operator|.
name|size
operator|.
name|x
operator|=
name|width_unit
expr_stmt|;
name|bt
operator|->
name|tile
operator|.
name|size
operator|.
name|y
operator|=
name|height_unit
expr_stmt|;
name|bt
operator|->
name|tile
operator|.
name|rep_width
operator|=
name|width
expr_stmt|;
name|bt
operator|->
name|tile
operator|.
name|rep_height
operator|=
name|height
expr_stmt|;
name|tbits
operator|+=
name|tile_bytes
expr_stmt|;
block|}
name|pcache
operator|->
name|order
operator|=
name|pht
operator|->
name|order
expr_stmt|;
name|pcache
operator|->
name|num_cached
operator|=
name|num_cached
expr_stmt|;
name|pcache
operator|->
name|levels_per_tile
operator|=
operator|(
name|size
operator|+
name|num_cached
operator|-
literal|1
operator|)
operator|/
name|num_cached
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute and save the rendering of a given gray level  * with the current halftone.  The cache holds multiple tiles,  * where each tile covers a range of possible levels.  * If the tile whose range includes the desired level is already loaded,  * we adjust it incrementally: this saves a lot of time for  * the average image, where gray levels don't change abruptly.  * Note that we will never be asked to cache levels 0 or order_size,  * which correspond to black or white respectively.  */
end_comment

begin_function
name|private
name|void
name|render_ht
parameter_list|(
name|bit_tile
modifier|*
name|pbt
parameter_list|,
name|int
name|level
comment|/* [1..order_size-1] */
parameter_list|,
name|halftone_params
modifier|*
name|pht
parameter_list|,
name|gx_bitmap_id
name|base_id
parameter_list|)
block|{
name|ht_bit
modifier|*
name|order
init|=
name|pht
operator|->
name|order
decl_stmt|;
specifier|register
name|ht_bit
modifier|*
name|p
decl_stmt|;
specifier|register
name|ht_bit
modifier|*
name|endp
decl_stmt|;
specifier|register
name|byte
modifier|*
name|bits
init|=
name|pbt
operator|->
name|tile
operator|.
name|data
decl_stmt|;
name|int
name|old_level
init|=
name|pbt
operator|->
name|level
decl_stmt|;
if|if
condition|(
name|old_level
operator|<
literal|0
condition|)
block|{
comment|/* The cache is empty.  Preload it with */
comment|/* whichever of all-0s and all-1s will be faster. */
name|uint
name|tile_bytes
init|=
name|pbt
operator|->
name|tile
operator|.
name|raster
operator|*
name|pbt
operator|->
name|tile
operator|.
name|size
operator|.
name|y
decl_stmt|;
if|if
condition|(
name|level
operator|>=
name|pht
operator|->
name|order_size
operator|>>
literal|1
condition|)
block|{
name|old_level
operator|=
name|pht
operator|->
name|order_size
expr_stmt|;
name|memset
argument_list|(
name|bits
argument_list|,
literal|0xff
argument_list|,
name|tile_bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old_level
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|bits
argument_list|,
literal|0
argument_list|,
name|tile_bytes
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|level
operator|>
name|pht
operator|->
name|order_size
operator|||
name|level
operator|==
name|old_level
condition|)
block|{
name|lprintf3
argument_list|(
literal|"Error in render_ht: level=%d, old_level=%d, order_size=%d=n"
argument_list|,
name|level
argument_list|,
name|old_level
argument_list|,
name|pht
operator|->
name|order_size
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Note that we can use the same loop to turn bits either */
comment|/* on or off, using xor.  We use< to compare pointers, */
comment|/* rather than ==, because Turbo C only compares the */
comment|/* low 16 bits for< and> but compares all 32 bits for ==. */
if|if
condition|(
name|level
operator|>
name|old_level
condition|)
name|p
operator|=
operator|&
name|order
index|[
name|old_level
index|]
operator|,
name|endp
operator|=
operator|&
name|order
index|[
name|level
index|]
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|order
index|[
name|level
index|]
operator|,
name|endp
operator|=
operator|&
name|order
index|[
name|old_level
index|]
expr_stmt|;
comment|/* Invert bits between the two pointers */
do|do
block|{
operator|*
operator|(
name|bit16
operator|*
operator|)
operator|&
name|bits
index|[
name|p
operator|->
name|offset
index|]
operator|^=
name|p
operator|->
name|mask
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|p
operator|<
name|endp
condition|)
do|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'h'
index|]
condition|)
block|{
name|byte
modifier|*
name|p
init|=
name|bits
decl_stmt|;
name|int
name|wb
init|=
name|pbt
operator|->
name|tile
operator|.
name|raster
decl_stmt|;
name|byte
modifier|*
name|ptr
init|=
name|bits
operator|+
name|wb
operator|*
name|pbt
operator|->
name|tile
operator|.
name|size
operator|.
name|y
decl_stmt|;
name|dprintf7
argument_list|(
literal|"[h]Halftone cache %lx: old=%d, new=%d, w=%d(%d), h=%d(%d):\n"
argument_list|,
operator|(
name|ulong
operator|)
name|bits
argument_list|,
name|old_level
argument_list|,
name|level
argument_list|,
name|pbt
operator|->
name|tile
operator|.
name|size
operator|.
name|x
argument_list|,
name|pht
operator|->
name|width
argument_list|,
name|pbt
operator|->
name|tile
operator|.
name|size
operator|.
name|y
argument_list|,
name|pht
operator|->
name|height
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|ptr
condition|)
block|{
name|dprintf1
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|-
name|bits
operator|)
operator|%
name|wb
operator|==
literal|0
condition|)
name|dputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|pbt
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|pbt
operator|->
name|tile
operator|.
name|id
operator|=
name|base_id
operator|+
name|level
expr_stmt|;
if|if
condition|(
name|pbt
operator|->
name|tile
operator|.
name|size
operator|.
name|y
operator|>
name|pbt
operator|->
name|tile
operator|.
name|rep_height
condition|)
block|{
comment|/* Replicate the tile in Y.  We only do this when */
comment|/* all the renderings will fit in the cache, */
comment|/* so we only do it once per level, and it doesn't */
comment|/* have to be very efficient. */
name|uint
name|rh
init|=
name|pbt
operator|->
name|tile
operator|.
name|rep_height
decl_stmt|;
name|uint
name|h
init|=
name|pbt
operator|->
name|tile
operator|.
name|size
operator|.
name|y
decl_stmt|;
name|uint
name|tsize
init|=
name|pbt
operator|->
name|tile
operator|.
name|raster
operator|*
name|rh
decl_stmt|;
do|do
block|{
name|memcpy
argument_list|(
name|bits
operator|+
name|tsize
argument_list|,
name|bits
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|bits
operator|+=
name|tsize
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|h
operator|-=
name|rh
operator|)
operator|!=
literal|0
condition|)
do|;
block|}
block|}
end_function

end_unit

