begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1990, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zupath.c */
end_comment

begin_comment
comment|/* Operators related to user paths */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"dstack.h"
end_include

begin_include
include|#
directive|include
file|"iutil.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_include
include|#
directive|include
file|"bnum.h"
end_include

begin_include
include|#
directive|include
file|"gsmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gspath.h"
end_include

begin_include
include|#
directive|include
file|"gsstate.h"
end_include

begin_include
include|#
directive|include
file|"gscoord.h"
end_include

begin_include
include|#
directive|include
file|"gspaint.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_include
include|#
directive|include
file|"gxpath.h"
end_include

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|upath_append
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|upath_stroke
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Insideness testing ------ */
end_comment

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|in_test
argument_list|(
name|P2
argument_list|(
name|os_ptr
argument_list|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|P1
argument_list|(
name|gs_state
operator|*
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|in_path
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|in_path_result
argument_list|(
name|P3
argument_list|(
name|os_ptr
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|in_utest
argument_list|(
name|P2
argument_list|(
name|os_ptr
argument_list|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|P1
argument_list|(
name|gs_state
operator|*
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|in_upath
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|in_upath_result
argument_list|(
name|P3
argument_list|(
name|os_ptr
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use invalidexit, which the painting procedures cannot generate, */
end_comment

begin_comment
comment|/* as an "error" to indicate that the hit detection device found a hit. */
end_comment

begin_define
define|#
directive|define
name|e_hit
value|e_invalidexit
end_define

begin_comment
comment|/* ineofill */
end_comment

begin_function
name|int
name|zineofill
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|in_test
argument_list|(
name|op
argument_list|,
name|gs_eofill
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* infill */
end_comment

begin_function
name|int
name|zinfill
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|in_test
argument_list|(
name|op
argument_list|,
name|gs_fill
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* instroke */
end_comment

begin_function
name|int
name|zinstroke
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|in_test
argument_list|(
name|op
argument_list|,
name|gs_stroke
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* inueofill */
end_comment

begin_function
name|int
name|zinueofill
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|in_utest
argument_list|(
name|op
argument_list|,
name|gs_eofill
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* inufill */
end_comment

begin_function
name|int
name|zinufill
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|in_utest
argument_list|(
name|op
argument_list|,
name|gs_fill
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* inustroke */
end_comment

begin_function
name|int
name|zinustroke
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
comment|/* This is different because of the optional matrix operand. */
name|int
name|code
init|=
name|gs_gsave
argument_list|(
name|igs
argument_list|)
decl_stmt|;
name|int
name|spop
decl_stmt|,
name|npop
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|spop
operator|=
name|upath_stroke
argument_list|(
name|op
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|npop
operator|=
name|in_path
argument_list|(
name|op
operator|-
name|spop
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|gs_grestore
argument_list|(
name|igs
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
name|code
operator|=
name|gs_stroke
argument_list|(
name|igs
argument_list|)
expr_stmt|;
return|return
name|in_upath_result
argument_list|(
name|op
argument_list|,
name|npop
operator|+
name|spop
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Define a minimal device for insideness testing. */
end_comment

begin_comment
comment|/* It returns e_hit whenever it is asked to actually paint any pixels. */
end_comment

begin_function_decl
name|private
name|dev_proc_fill_rectangle
parameter_list|(
name|hit_fill_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|gx_device_procs
name|hit_procs
init|=
block|{
name|NULL
block|,
comment|/* open_device */
name|NULL
block|,
comment|/* get_initial_matrix */
name|NULL
block|,
comment|/* sync_output */
name|NULL
block|,
comment|/* output_page */
name|NULL
block|,
comment|/* close_device */
name|gx_default_map_rgb_color
block|,
name|gx_default_map_color_rgb
block|,
name|hit_fill_rectangle
block|,
name|NULL
block|,
comment|/* tile_rectangle */
name|NULL
block|,
comment|/* copy_mono */
name|NULL
block|,
comment|/* copy_color */
name|gx_default_draw_line
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_device
name|hit_device
init|=
block|{
sizeof|sizeof
argument_list|(
name|gx_device
argument_list|)
block|,
operator|&
name|hit_procs
block|,
literal|"hit detector"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
name|no_margins
block|,
name|dci_black_and_white
block|,
literal|0
comment|/* generic */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test for a hit when filling a rectangle. */
end_comment

begin_function
name|private
name|int
name|hit_fill_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
return|return
operator|(
name|w
operator|>
literal|0
operator|&&
name|h
operator|>
literal|0
condition|?
name|e_hit
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do the work of the non-user-path insideness operators. */
end_comment

begin_decl_stmt
name|private
name|int
name|in_test
argument_list|(
name|os_ptr
name|op
argument_list|,
name|int
argument_list|(
operator|*
name|paintproc
argument_list|)
argument_list|(
name|P1
argument_list|(
name|gs_state
operator|*
argument_list|)
argument_list|)
argument_list|)
block|{
name|int
name|npop
init|=
name|in_path
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|npop
operator|<
literal|0
condition|)
return|return
name|npop
return|;
name|code
operator|=
call|(
modifier|*
name|paintproc
call|)
argument_list|(
name|igs
argument_list|)
expr_stmt|;
return|return
name|in_path_result
argument_list|(
name|op
argument_list|,
name|npop
argument_list|,
name|code
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Set up a clipping path and device for insideness testing. */
end_comment

begin_function
name|private
name|int
name|in_path
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|gs_gsave
argument_list|(
name|igs
argument_list|)
decl_stmt|;
name|int
name|npop
decl_stmt|;
name|float
name|uxy
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|code
operator|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|2
argument_list|,
name|uxy
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
comment|/* Aperture is a single pixel. */
name|gs_point
name|dxy
decl_stmt|;
name|gs_fixed_rect
name|fr
decl_stmt|;
name|gs_transform
argument_list|(
name|igs
argument_list|,
name|uxy
index|[
literal|0
index|]
argument_list|,
name|uxy
index|[
literal|1
index|]
argument_list|,
operator|&
name|dxy
argument_list|)
expr_stmt|;
name|fr
operator|.
name|p
operator|.
name|x
operator|=
name|fixed_truncated
argument_list|(
name|float2fixed
argument_list|(
name|dxy
operator|.
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|fr
operator|.
name|p
operator|.
name|y
operator|=
name|fixed_truncated
argument_list|(
name|float2fixed
argument_list|(
name|dxy
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|fr
operator|.
name|q
operator|.
name|x
operator|=
name|fr
operator|.
name|p
operator|.
name|x
operator|+
name|int2fixed
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fr
operator|.
name|q
operator|.
name|y
operator|=
name|fr
operator|.
name|p
operator|.
name|y
operator|+
name|int2fixed
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|gx_clip_to_rectangle
argument_list|(
name|igs
argument_list|,
operator|&
name|fr
argument_list|)
expr_stmt|;
name|npop
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Aperture is a user path. */
if|if
condition|(
operator|(
name|code
operator|=
name|upath_append
argument_list|(
name|op
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|code
operator|=
name|gx_clip_to_path
argument_list|(
name|igs
argument_list|)
expr_stmt|;
name|npop
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|<
literal|0
condition|)
block|{
name|gs_grestore
argument_list|(
name|igs
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
comment|/* Install the hit detection device. */
name|gs_setgray
argument_list|(
name|igs
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|gx_set_device_only
argument_list|(
name|igs
argument_list|,
operator|&
name|hit_device
argument_list|)
expr_stmt|;
return|return
name|npop
return|;
block|}
end_function

begin_comment
comment|/* Finish an insideness test. */
end_comment

begin_function
name|private
name|int
name|in_path_result
parameter_list|(
name|os_ptr
name|op
parameter_list|,
name|int
name|npop
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|gs_grestore
argument_list|(
name|igs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|e_hit
case|:
comment|/* found a hit */
name|result
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* completed painting without a hit */
name|result
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* error */
return|return
name|code
return|;
block|}
name|npop
operator|--
expr_stmt|;
name|pop
argument_list|(
name|npop
argument_list|)
expr_stmt|;
name|op
operator|-=
name|npop
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Do the work of the user-path insideness operators. */
end_comment

begin_decl_stmt
name|private
name|int
name|in_utest
argument_list|(
name|os_ptr
name|op
argument_list|,
name|int
argument_list|(
operator|*
name|paintproc
argument_list|)
argument_list|(
name|P1
argument_list|(
name|gs_state
operator|*
argument_list|)
argument_list|)
argument_list|)
block|{
name|int
name|npop
init|=
name|in_upath
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|npop
operator|<
literal|0
condition|)
return|return
name|npop
return|;
name|code
operator|=
call|(
modifier|*
name|paintproc
call|)
argument_list|(
name|igs
argument_list|)
expr_stmt|;
return|return
name|in_upath_result
argument_list|(
name|op
argument_list|,
name|npop
argument_list|,
name|code
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Set up a clipping path and device for insideness testing */
end_comment

begin_comment
comment|/* with a user path. */
end_comment

begin_function
name|private
name|int
name|in_upath
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|gs_gsave
argument_list|(
name|igs
argument_list|)
decl_stmt|;
name|int
name|npop
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|upath_append
argument_list|(
name|op
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|npop
operator|=
name|in_path
argument_list|(
name|op
operator|-
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|gs_grestore
argument_list|(
name|igs
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
return|return
name|npop
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Finish an insideness test with a user path. */
end_comment

begin_function
name|private
name|int
name|in_upath_result
parameter_list|(
name|os_ptr
name|op
parameter_list|,
name|int
name|npop
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|gs_grestore
argument_list|(
name|igs
argument_list|)
expr_stmt|;
comment|/* undo the extra gsave */
return|return
name|in_path_result
argument_list|(
name|op
argument_list|,
name|npop
argument_list|,
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------ User paths ------ */
end_comment

begin_comment
comment|/* User path operator codes */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|upath_setbbox
init|=
literal|0
block|,
name|upath_moveto
init|=
literal|1
block|,
name|upath_rmoveto
init|=
literal|2
block|,
name|upath_lineto
init|=
literal|3
block|,
name|upath_rlineto
init|=
literal|4
block|,
name|upath_curveto
init|=
literal|5
block|,
name|upath_rcurveto
init|=
literal|6
block|,
name|upath_arc
init|=
literal|7
block|,
name|upath_arcn
init|=
literal|8
block|,
name|upath_arct
init|=
literal|9
block|,
name|upath_closepath
init|=
literal|10
block|,
name|upath_ucache
init|=
literal|11
block|}
name|upath_op
typedef|;
end_typedef

begin_define
define|#
directive|define
name|upath_op_max
value|11
end_define

begin_define
define|#
directive|define
name|upath_repeat
value|32
end_define

begin_decl_stmt
specifier|static
name|byte
name|up_nargs
index|[
name|upath_op_max
operator|+
literal|1
index|]
init|=
block|{
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|zp
parameter_list|(
name|proc
parameter_list|)
value|extern int proc(P1(os_ptr))
end_define

begin_expr_stmt
name|zp
argument_list|(
name|zsetbbox
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|zp
argument_list|(
name|zmoveto
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|zp
argument_list|(
name|zrmoveto
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|zp
argument_list|(
name|zlineto
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|zp
argument_list|(
name|zrlineto
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|zp
argument_list|(
name|zcurveto
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|zp
argument_list|(
name|zrcurveto
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|zp
argument_list|(
name|zarc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|zp
argument_list|(
name|zarcn
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|zp
argument_list|(
name|zarct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|zp
argument_list|(
name|zclosepath
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|zp
argument_list|(
name|zucache
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|zp
end_undef

begin_decl_stmt
specifier|static
name|op_proc_p
name|up_ops
index|[
name|upath_op_max
operator|+
literal|1
index|]
init|=
block|{
name|zsetbbox
block|,
name|zmoveto
block|,
name|zrmoveto
block|,
name|zlineto
block|,
name|zrlineto
block|,
name|zcurveto
block|,
name|zrcurveto
block|,
name|zarc
block|,
name|zarcn
block|,
name|zarct
block|,
name|zclosepath
block|,
name|zucache
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Imported procedures */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|array_get
argument_list|(
name|P3
argument_list|(
name|ref
operator|*
argument_list|,
name|long
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ucache */
end_comment

begin_function
name|int
name|zucache
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
comment|/* A no-op for now. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* uappend */
end_comment

begin_function
name|int
name|zuappend
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|gs_gsave
argument_list|(
name|igs
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|upath_append
argument_list|(
name|op
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|code
operator|=
name|gs_upmergepath
argument_list|(
name|igs
argument_list|)
expr_stmt|;
name|gs_grestore
argument_list|(
name|igs
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ueofill */
end_comment

begin_function
name|int
name|zueofill
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|gs_gsave
argument_list|(
name|igs
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|upath_append
argument_list|(
name|op
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|code
operator|=
name|gs_eofill
argument_list|(
name|igs
argument_list|)
expr_stmt|;
name|gs_grestore
argument_list|(
name|igs
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ufill */
end_comment

begin_function
name|int
name|zufill
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|gs_gsave
argument_list|(
name|igs
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|upath_append
argument_list|(
name|op
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|code
operator|=
name|gs_fill
argument_list|(
name|igs
argument_list|)
expr_stmt|;
name|gs_grestore
argument_list|(
name|igs
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ustroke */
end_comment

begin_function
name|int
name|zustroke
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|gs_gsave
argument_list|(
name|igs
argument_list|)
decl_stmt|;
name|int
name|npop
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|npop
operator|=
name|upath_stroke
argument_list|(
name|op
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|code
operator|=
name|gs_stroke
argument_list|(
name|igs
argument_list|)
expr_stmt|;
name|gs_grestore
argument_list|(
name|igs
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
name|npop
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ustrokepath */
end_comment

begin_function
name|int
name|zustrokepath
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|gs_gsave
argument_list|(
name|igs
argument_list|)
decl_stmt|;
name|int
name|npop
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|npop
operator|=
name|upath_stroke
argument_list|(
name|op
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_strokepath
argument_list|(
name|igs
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_upmergepath
argument_list|(
name|igs
argument_list|)
operator|)
operator|<
literal|0
condition|)
empty_stmt|;
name|gs_grestore
argument_list|(
name|igs
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
name|npop
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --- Internal routines --- */
end_comment

begin_comment
comment|/* Append a user path to the current path. */
end_comment

begin_function
name|private
name|int
name|upath_append
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|check_read
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
name|gs_newpath
argument_list|(
name|igs
argument_list|)
expr_stmt|;
comment|/****** ROUND tx AND ty ******/
if|if
condition|(
name|r_has_type
argument_list|(
name|op
argument_list|,
name|t_array
argument_list|)
operator|&&
name|r_size
argument_list|(
name|op
argument_list|)
operator|==
literal|2
operator|&&
name|r_has_type
argument_list|(
name|op
operator|->
name|value
operator|.
name|refs
operator|+
literal|1
argument_list|,
name|t_string
argument_list|)
condition|)
block|{
comment|/* 1st element is operators, 2nd is operands */
name|stream
name|st
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|repcount
init|=
literal|1
decl_stmt|;
name|byte
modifier|*
name|opp
decl_stmt|;
name|uint
name|ocount
decl_stmt|;
name|code
operator|=
name|sread_num_array
argument_list|(
operator|&
name|st
argument_list|,
name|op
operator|->
name|value
operator|.
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|opp
operator|=
name|op
operator|->
name|value
operator|.
name|refs
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|bytes
expr_stmt|;
name|ocount
operator|=
name|r_size
argument_list|(
operator|&
name|op
operator|->
name|value
operator|.
name|refs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|ocount
operator|--
condition|)
block|{
name|byte
name|opx
init|=
operator|*
name|opp
operator|++
decl_stmt|;
if|if
condition|(
name|opx
operator|>
literal|32
condition|)
name|repcount
operator|=
name|opx
operator|-
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|opx
operator|>
name|upath_op_max
condition|)
return|return
name|e_typecheck
return|;
else|else
comment|/* operator */
block|{
do|do
block|{
name|byte
name|opargs
init|=
name|up_nargs
index|[
name|opx
index|]
decl_stmt|;
while|while
condition|(
name|opargs
operator|--
condition|)
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|sget_encoded_number
argument_list|(
operator|&
name|st
argument_list|,
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|t_integer
case|:
name|r_set_type_attrs
argument_list|(
name|op
argument_list|,
name|t_integer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_real
case|:
name|r_set_type_attrs
argument_list|(
name|op
argument_list|,
name|t_real
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
block|}
name|code
operator|=
call|(
modifier|*
name|up_ops
index|[
name|opx
index|]
call|)
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|op
operator|=
name|osp
expr_stmt|;
comment|/* resync */
block|}
do|while
condition|(
operator|--
name|repcount
condition|)
do|;
name|repcount
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Ordinary executable array */
name|ref
modifier|*
name|arp
init|=
name|op
decl_stmt|;
name|ref
modifier|*
name|defp
decl_stmt|;
name|ref
name|rup
decl_stmt|;
name|uint
name|ocount
init|=
name|r_size
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|long
name|index
init|=
literal|0
decl_stmt|;
name|int
name|argcount
init|=
literal|0
decl_stmt|;
name|int
argument_list|(
operator|*
name|oproc
argument_list|)
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|opx
decl_stmt|,
name|code
decl_stmt|;
for|for
control|(
init|;
name|index
operator|<
name|ocount
condition|;
name|index
operator|++
control|)
switch|switch
condition|(
name|array_get
argument_list|(
name|arp
argument_list|,
name|index
argument_list|,
operator|&
name|rup
argument_list|)
operator|,
name|r_type
argument_list|(
operator|&
name|rup
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
case|case
name|t_real
case|:
name|argcount
operator|++
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|op
operator|=
name|rup
expr_stmt|;
break|break;
case|case
name|t_name
case|:
if|if
condition|(
operator|!
name|r_has_attr
argument_list|(
operator|&
name|rup
argument_list|,
name|a_executable
argument_list|)
condition|)
return|return
name|e_typecheck
return|;
if|if
condition|(
name|dict_find
argument_list|(
operator|&
name|systemdict
argument_list|,
operator|&
name|rup
argument_list|,
operator|&
name|defp
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|e_undefined
return|;
if|if
condition|(
name|r_btype
argument_list|(
name|defp
argument_list|)
operator|!=
name|t_operator
condition|)
return|return
name|e_typecheck
return|;
goto|goto
name|xop
goto|;
case|case
name|t_operator
case|:
name|defp
operator|=
operator|&
name|rup
expr_stmt|;
name|xop
label|:
if|if
condition|(
operator|!
name|r_has_attr
argument_list|(
name|defp
argument_list|,
name|a_executable
argument_list|)
condition|)
return|return
name|e_typecheck
return|;
name|oproc
operator|=
name|real_opproc
argument_list|(
name|defp
argument_list|)
expr_stmt|;
for|for
control|(
name|opx
operator|=
literal|0
init|;
name|opx
operator|<=
name|upath_op_max
condition|;
name|opx
operator|++
control|)
if|if
condition|(
name|oproc
operator|==
name|up_ops
index|[
name|opx
index|]
condition|)
break|break;
if|if
condition|(
name|opx
operator|>
name|upath_op_max
operator|||
name|argcount
operator|!=
name|up_nargs
index|[
name|opx
index|]
condition|)
return|return
name|e_typecheck
return|;
name|code
operator|=
call|(
modifier|*
name|oproc
call|)
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|op
operator|=
name|osp
expr_stmt|;
comment|/* resync ostack pointer */
name|argcount
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
if|if
condition|(
name|argcount
condition|)
return|return
name|e_typecheck
return|;
comment|/* leftover args */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Append a user path to the current path, and then apply */
end_comment

begin_comment
comment|/* a transformation if one is supplied. */
end_comment

begin_function
name|private
name|int
name|upath_stroke
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|,
name|npop
decl_stmt|;
name|gs_matrix
name|mat
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|read_matrix
argument_list|(
name|op
argument_list|,
operator|&
name|mat
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|=
name|upath_append
argument_list|(
name|op
operator|-
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|code
operator|=
name|gs_concat
argument_list|(
name|igs
argument_list|,
operator|&
name|mat
argument_list|)
expr_stmt|;
name|npop
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|upath_append
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|npop
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|code
operator|<
literal|0
condition|?
name|code
else|:
name|npop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zupath_op_defs
index|[]
init|=
block|{
comment|/* Insideness testing */
block|{
literal|"1ineofill"
block|,
name|zineofill
block|}
block|,
block|{
literal|"1infill"
block|,
name|zinfill
block|}
block|,
block|{
literal|"1instroke"
block|,
name|zinstroke
block|}
block|,
block|{
literal|"2inueofill"
block|,
name|zinueofill
block|}
block|,
block|{
literal|"2inufill"
block|,
name|zinufill
block|}
block|,
block|{
literal|"2inustroke"
block|,
name|zinustroke
block|}
block|,
comment|/* User paths */
block|{
literal|"1uappend"
block|,
name|zuappend
block|}
block|,
block|{
literal|"1ueofill"
block|,
name|zueofill
block|}
block|,
block|{
literal|"1ufill"
block|,
name|zufill
block|}
block|,
block|{
literal|"1ustroke"
block|,
name|zustroke
block|}
block|,
block|{
literal|"1ustrokepath"
block|,
name|zustrokepath
block|}
block|,
block|{
literal|"0ucache"
block|,
name|zucache
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

