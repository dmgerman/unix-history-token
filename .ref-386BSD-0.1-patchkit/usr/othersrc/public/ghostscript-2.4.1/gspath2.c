begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gspath2.c */
end_comment

begin_comment
comment|/* Non-constructor path routines for GhostScript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gspath.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxarith.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_include
include|#
directive|include
file|"gzdevice.h"
end_include

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|common_clip
argument_list|(
name|P2
argument_list|(
name|gs_state
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|set_clip_path
argument_list|(
name|P3
argument_list|(
name|gs_state
operator|*
argument_list|,
name|gx_clip_path
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Path enumeration structure */
end_comment

begin_struct
struct|struct
name|gs_path_enum_s
block|{
name|segment
modifier|*
name|pseg
decl_stmt|;
specifier|const
name|gs_state
modifier|*
name|pgs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Size of path enumeration structure, so clients can allocate */
end_comment

begin_decl_stmt
specifier|const
name|uint
name|gs_path_enum_sizeof
init|=
sizeof|sizeof
argument_list|(
name|gs_path_enum
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Path transformers ------ */
end_comment

begin_function
name|int
name|gs_flattenpath
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gx_path
name|fpath
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|pgs
operator|->
name|path
operator|->
name|curve_count
condition|)
return|return
literal|0
return|;
comment|/* no curves */
name|code
operator|=
name|gx_path_flatten
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|fpath
argument_list|,
name|pgs
operator|->
name|flatness
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|gx_path_release
argument_list|(
name|pgs
operator|->
name|path
argument_list|)
expr_stmt|;
operator|*
name|pgs
operator|->
name|path
operator|=
name|fpath
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|gs_reversepath
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gx_path
name|rpath
decl_stmt|;
name|int
name|code
init|=
name|gx_path_reverse
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|rpath
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|gx_path_release
argument_list|(
name|pgs
operator|->
name|path
argument_list|)
expr_stmt|;
operator|*
name|pgs
operator|->
name|path
operator|=
name|rpath
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Accessors ------ */
end_comment

begin_function
name|int
name|gs_pathbbox
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_rect
modifier|*
name|pbox
parameter_list|)
block|{
name|gs_fixed_rect
name|fbox
decl_stmt|;
comment|/* box in device coordinates */
name|gs_rect
name|dbox
decl_stmt|;
name|int
name|code
init|=
name|gx_path_bbox
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|fbox
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* Transform the result back to user coordinates. */
name|dbox
operator|.
name|p
operator|.
name|x
operator|=
name|fixed2float
argument_list|(
name|fbox
operator|.
name|p
operator|.
name|x
argument_list|)
expr_stmt|;
name|dbox
operator|.
name|p
operator|.
name|y
operator|=
name|fixed2float
argument_list|(
name|fbox
operator|.
name|p
operator|.
name|y
argument_list|)
expr_stmt|;
name|dbox
operator|.
name|q
operator|.
name|x
operator|=
name|fixed2float
argument_list|(
name|fbox
operator|.
name|q
operator|.
name|x
argument_list|)
expr_stmt|;
name|dbox
operator|.
name|q
operator|.
name|y
operator|=
name|fixed2float
argument_list|(
name|fbox
operator|.
name|q
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
name|gs_bbox_transform_inverse
argument_list|(
operator|&
name|dbox
argument_list|,
operator|&
name|ctm_only
argument_list|(
name|pgs
argument_list|)
argument_list|,
name|pbox
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------ Enumerators ------ */
end_comment

begin_comment
comment|/* Start enumerating a path */
end_comment

begin_function
name|void
name|gs_path_enum_init
parameter_list|(
name|gs_path_enum
modifier|*
name|penum
parameter_list|,
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|penum
operator|->
name|pseg
operator|=
operator|(
name|segment
operator|*
operator|)
name|pgs
operator|->
name|path
operator|->
name|first_subpath
expr_stmt|;
name|penum
operator|->
name|pgs
operator|=
name|pgs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enumerate the next element of a path. */
end_comment

begin_comment
comment|/* If the path is finished, return 0; */
end_comment

begin_comment
comment|/* otherwise, return the element type. */
end_comment

begin_function
name|int
name|gs_path_enum_next
parameter_list|(
name|gs_path_enum
modifier|*
name|penum
parameter_list|,
name|gs_point
name|ppts
index|[
literal|3
index|]
parameter_list|)
block|{
name|segment
modifier|*
name|pseg
init|=
name|penum
operator|->
name|pseg
decl_stmt|;
specifier|const
name|gs_state
modifier|*
name|pgs
init|=
name|penum
operator|->
name|pgs
decl_stmt|;
name|gs_point
name|pt
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|pseg
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* finished */
name|penum
operator|->
name|pseg
operator|=
name|pseg
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|pseg
operator|->
name|type
operator|==
name|s_line_close
condition|)
return|return
name|gs_pe_closepath
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_itransform
argument_list|(
name|pgs
argument_list|,
name|fixed2float
argument_list|(
name|pseg
operator|->
name|pt
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pseg
operator|->
name|pt
operator|.
name|y
argument_list|)
argument_list|,
operator|&
name|pt
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
switch|switch
condition|(
name|pseg
operator|->
name|type
condition|)
block|{
case|case
name|s_start
case|:
name|ppts
index|[
literal|0
index|]
operator|=
name|pt
expr_stmt|;
return|return
name|gs_pe_moveto
return|;
case|case
name|s_line
case|:
name|ppts
index|[
literal|0
index|]
operator|=
name|pt
expr_stmt|;
return|return
name|gs_pe_lineto
return|;
case|case
name|s_curve
case|:
define|#
directive|define
name|pcurve
value|((curve_segment *)pseg)
if|if
condition|(
operator|(
name|code
operator|=
name|gs_itransform
argument_list|(
name|pgs
argument_list|,
name|fixed2float
argument_list|(
name|pcurve
operator|->
name|p1
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pcurve
operator|->
name|p1
operator|.
name|y
argument_list|)
argument_list|,
operator|&
name|ppts
index|[
literal|0
index|]
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_itransform
argument_list|(
name|pgs
argument_list|,
name|fixed2float
argument_list|(
name|pcurve
operator|->
name|p2
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pcurve
operator|->
name|p2
operator|.
name|y
argument_list|)
argument_list|,
operator|&
name|ppts
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|ppts
index|[
literal|2
index|]
operator|=
name|pt
expr_stmt|;
return|return
name|gs_pe_curveto
return|;
undef|#
directive|undef
name|pcurve
default|default:
name|lprintf1
argument_list|(
literal|"bad type %x in gs_path_enum_next!\n"
argument_list|,
name|pseg
operator|->
name|type
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------ Clipping ------ */
end_comment

begin_function
name|int
name|gs_clippath
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gx_path
name|path
decl_stmt|;
name|int
name|code
init|=
name|gx_cpath_path
argument_list|(
name|pgs
operator|->
name|clip_path
argument_list|,
operator|&
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
name|gx_path_copy
argument_list|(
operator|&
name|path
argument_list|,
name|pgs
operator|->
name|path
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|gs_initclip
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
specifier|register
name|gx_device
modifier|*
name|dev
init|=
name|pgs
operator|->
name|device
operator|->
name|info
decl_stmt|;
name|gs_fixed_rect
name|box
decl_stmt|;
if|if
condition|(
name|is_fzero2
argument_list|(
name|dev
operator|->
name|l_margin
argument_list|,
name|dev
operator|->
name|r_margin
argument_list|)
operator|&&
name|is_fzero2
argument_list|(
name|dev
operator|->
name|b_margin
argument_list|,
name|dev
operator|->
name|t_margin
argument_list|)
condition|)
block|{
comment|/* Shortcut, don't need to worry about density. */
name|box
operator|.
name|p
operator|.
name|x
operator|=
name|box
operator|.
name|p
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|box
operator|.
name|q
operator|.
name|x
operator|=
name|int2fixed
argument_list|(
name|dev
operator|->
name|width
argument_list|)
expr_stmt|;
name|box
operator|.
name|q
operator|.
name|y
operator|=
name|int2fixed
argument_list|(
name|dev
operator|->
name|height
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Indent from bounding rectangle. */
name|gs_matrix_fixed
name|imat
decl_stmt|;
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|get_initial_matrix
call|)
argument_list|(
name|dev
argument_list|,
operator|(
name|gs_matrix
operator|*
operator|)
operator|&
name|imat
argument_list|)
expr_stmt|;
name|gs_update_matrix_fixed
argument_list|(
operator|&
name|imat
argument_list|)
expr_stmt|;
name|gs_point_transform2fixed
argument_list|(
operator|&
name|imat
argument_list|,
name|dev
operator|->
name|l_margin
operator|*
literal|72
argument_list|,
name|dev
operator|->
name|b_margin
operator|*
literal|72
argument_list|,
operator|&
name|box
operator|.
name|p
argument_list|)
expr_stmt|;
name|gs_point_transform2fixed
argument_list|(
operator|&
name|imat
argument_list|,
operator|(
name|dev
operator|->
name|width
operator|/
name|dev
operator|->
name|x_pixels_per_inch
operator|-
name|dev
operator|->
name|r_margin
operator|)
operator|*
literal|72
argument_list|,
operator|(
name|dev
operator|->
name|height
operator|/
name|dev
operator|->
name|y_pixels_per_inch
operator|-
name|dev
operator|->
name|t_margin
operator|)
operator|*
literal|72
argument_list|,
operator|&
name|box
operator|.
name|q
argument_list|)
expr_stmt|;
block|}
return|return
name|gx_clip_to_rectangle
argument_list|(
name|pgs
argument_list|,
operator|&
name|box
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|gs_clip
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|common_clip
argument_list|(
name|pgs
argument_list|,
name|gx_rule_winding_number
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|gs_eoclip
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|common_clip
argument_list|(
name|pgs
argument_list|,
name|gx_rule_even_odd
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|common_clip
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|int
name|rule
parameter_list|)
block|{
name|gx_path
name|fpath
decl_stmt|;
name|int
name|code
init|=
name|gx_path_flatten
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|fpath
argument_list|,
name|pgs
operator|->
name|flatness
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|code
operator|=
name|gx_cpath_intersect
argument_list|(
name|pgs
argument_list|,
name|pgs
operator|->
name|clip_path
argument_list|,
operator|&
name|fpath
argument_list|,
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
name|set_clip_path
argument_list|(
name|pgs
argument_list|,
name|pgs
operator|->
name|clip_path
argument_list|,
name|rule
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Establish a rectangle as the clipping path. */
end_comment

begin_comment
comment|/* Used by initclip and by the character cache logic. */
end_comment

begin_function
name|int
name|gx_clip_to_rectangle
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_fixed_rect
modifier|*
name|pbox
parameter_list|)
block|{
name|gx_clip_path
name|cpath
decl_stmt|;
name|int
name|code
init|=
name|gx_cpath_from_rectangle
argument_list|(
operator|&
name|cpath
argument_list|,
name|pbox
argument_list|,
operator|&
name|pgs
operator|->
name|memory_procs
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|gx_cpath_release
argument_list|(
name|pgs
operator|->
name|clip_path
argument_list|)
expr_stmt|;
return|return
name|set_clip_path
argument_list|(
name|pgs
argument_list|,
operator|&
name|cpath
argument_list|,
name|gx_rule_winding_number
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the clipping path to the current path, without intersecting. */
end_comment

begin_comment
comment|/* Currently only used by the insideness testing operators, */
end_comment

begin_comment
comment|/* but might be used by viewclip eventually. */
end_comment

begin_comment
comment|/* The algorithm is very inefficient; we'll improve it later if needed. */
end_comment

begin_function
name|int
name|gx_clip_to_path
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gs_fixed_rect
name|bbox
decl_stmt|;
name|int
name|code
decl_stmt|;
operator|(
name|code
operator|=
name|gx_path_bbox
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|bbox
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_clip_to_rectangle
argument_list|(
name|pgs
argument_list|,
operator|&
name|bbox
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_clip
argument_list|(
name|pgs
argument_list|)
operator|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Set the clipping path (internal). */
end_comment

begin_function
name|private
name|int
name|set_clip_path
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gx_clip_path
modifier|*
name|pcpath
parameter_list|,
name|int
name|rule
parameter_list|)
block|{
operator|*
name|pgs
operator|->
name|clip_path
operator|=
operator|*
name|pcpath
expr_stmt|;
name|pgs
operator|->
name|clip_rule
operator|=
name|rule
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'p'
index|]
condition|)
name|dprintf
argument_list|(
literal|"[p]Clipping path:\n"
argument_list|)
operator|,
name|gx_cpath_print
argument_list|(
name|pcpath
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

