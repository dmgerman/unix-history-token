begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* sfilter.c */
end_comment

begin_comment
comment|/* Stream functions for filters */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_include
include|#
directive|include
file|"scanchar.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_comment
comment|/* for gstype1.h */
end_comment

begin_include
include|#
directive|include
file|"gstype1.h"
end_include

begin_comment
comment|/* ------ Generic functions ------ */
end_comment

begin_comment
comment|/* Implement flushing for all encoding filters. */
end_comment

begin_function
name|int
name|s_filter_flush
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
call|(
modifier|*
name|s
operator|->
name|procs
operator|.
name|write_buf
call|)
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|sflush
argument_list|(
name|s
operator|->
name|strm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close a filter.  If this is an encoding filter, flush it first. */
end_comment

begin_function
name|int
name|s_filter_close
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|mode
operator|==
name|s_mode_write
condition|)
block|{
name|int
name|code
init|=
name|sflush
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
return|return
name|s_std_close
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------ ASCIIHexEncode ------ */
end_comment

begin_comment
comment|/* Flush the buffer */
end_comment

begin_function
name|private
name|int
name|s_AXE_write_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|hex_digits
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|register
name|stream
modifier|*
name|strm
init|=
name|s
operator|->
name|strm
decl_stmt|;
specifier|register
name|byte
modifier|*
name|p
init|=
name|s
operator|->
name|cbuf
decl_stmt|;
specifier|register
name|int
name|count
init|=
name|s
operator|->
name|cptr
operator|+
literal|1
operator|-
name|p
decl_stmt|;
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|byte
name|ch
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|sputc
argument_list|(
name|strm
argument_list|,
name|hex_digits
index|[
name|ch
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|strm
argument_list|,
name|hex_digits
index|[
name|ch
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|count
operator|&
literal|15
operator|)
condition|)
name|sputc
argument_list|(
name|strm
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Close the stream */
end_comment

begin_function
name|private
name|int
name|s_AXE_close
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
call|(
modifier|*
name|s
operator|->
name|procs
operator|.
name|write_buf
call|)
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|s
operator|->
name|strm
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
return|return
name|s_std_close
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Stream procedures */
end_comment

begin_decl_stmt
name|stream_procs
name|s_AXE_procs
init|=
block|{
name|s_std_noavailable
block|,
name|NULL
block|,
name|s_filter_flush
block|,
name|s_AXE_close
block|,
name|NULL
block|,
name|s_AXE_write_buf
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ ASCIIHexDecode ------ */
end_comment

begin_comment
comment|/* Initialize the stream */
end_comment

begin_function
name|void
name|s_AXD_init
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|odd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Refill the buffer */
end_comment

begin_function
name|private
name|int
name|s_AXD_read_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|stream
modifier|*
name|strm
init|=
name|s
operator|->
name|strm
decl_stmt|;
name|uint
name|count
decl_stmt|;
name|int
name|code
init|=
name|sreadhex
argument_list|(
name|strm
argument_list|,
name|s
operator|->
name|cbuf
argument_list|,
name|s
operator|->
name|bsize
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|s
operator|->
name|odd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|endptr
operator|=
name|s
operator|->
name|cptr
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|ERRC
condition|)
block|{
name|s
operator|->
name|end_status
operator|=
name|strm
operator|->
name|end_status
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for EOD */
if|if
condition|(
name|sgetc
argument_list|(
name|strm
argument_list|)
operator|==
literal|'>'
condition|)
comment|/* EOD */
name|s
operator|->
name|end_status
operator|=
name|EOFC
expr_stmt|;
else|else
comment|/* syntax error */
block|{
name|s
operator|->
name|end_status
operator|=
name|ERRC
expr_stmt|;
name|sputback
argument_list|(
name|strm
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Stream procedures */
end_comment

begin_decl_stmt
name|stream_procs
name|s_AXD_procs
init|=
block|{
name|s_std_noavailable
block|,
name|NULL
block|,
name|s_std_null
block|,
name|s_filter_close
block|,
name|s_AXD_read_buf
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ eexecDecode ------ */
end_comment

begin_comment
comment|/* Initialize a stream for reading and decrypting another stream. */
end_comment

begin_comment
comment|/* Decrypting streams are not positionable. */
end_comment

begin_function
name|void
name|s_exD_init
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|ushort
comment|/*crypt_state*/
name|state
parameter_list|)
block|{
name|s
operator|->
name|cstate
operator|=
name|state
expr_stmt|;
name|s
operator|->
name|odd
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|binary
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown */
block|}
end_function

begin_comment
comment|/* Refill the buffer of a decrypting stream. */
end_comment

begin_function
name|private
name|int
name|s_exD_read_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|byte
modifier|*
name|buf
init|=
name|s
operator|->
name|cbuf
decl_stmt|;
name|uint
name|nread
decl_stmt|;
name|int
name|skip
init|=
operator|(
name|s
operator|->
name|binary
operator|<
literal|0
condition|?
literal|4
else|:
literal|0
operator|)
decl_stmt|;
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|endptr
operator|=
name|buf
operator|-
literal|1
expr_stmt|;
name|top
label|:
name|nread
operator|=
name|sgets
argument_list|(
name|s
operator|->
name|strm
argument_list|,
name|buf
argument_list|,
name|s
operator|->
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
comment|/* end of stream */
block|{
name|s
operator|->
name|end_status
operator|=
name|EOFC
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|s
operator|->
name|binary
operator|<
literal|0
condition|)
block|{
comment|/* This is the very first time we're filling the buffer. */
comment|/* Determine whether this is ASCII or hex encoding. */
specifier|register
name|byte
name|_ds
modifier|*
name|decoder
init|=
name|scan_char_decoder
decl_stmt|;
if|if
condition|(
name|nread
operator|<
literal|4
condition|)
return|return
name|EOFC
return|;
if|if
condition|(
name|decoder
index|[
name|buf
index|[
literal|0
index|]
index|]
operator|==
name|ctype_space
operator|||
operator|(
name|decoder
index|[
name|buf
index|[
literal|0
index|]
index|]
operator||
name|decoder
index|[
name|buf
index|[
literal|1
index|]
index|]
operator||
name|decoder
index|[
name|buf
index|[
literal|2
index|]
index|]
operator||
name|decoder
index|[
name|buf
index|[
literal|3
index|]
index|]
operator|)
operator|<=
literal|0xf
condition|)
block|{
comment|/* Would be invalid if binary, hence must be hex. */
name|s
operator|->
name|binary
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|s
operator|->
name|binary
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
operator|->
name|binary
condition|)
block|{
comment|/* Convert the buffer from binary to hex in place. */
name|stream
name|sst
decl_stmt|;
name|sread_string
argument_list|(
operator|&
name|sst
argument_list|,
name|buf
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|sreadhex
argument_list|(
operator|&
name|sst
argument_list|,
name|buf
argument_list|,
name|nread
argument_list|,
operator|&
name|nread
argument_list|,
operator|&
name|s
operator|->
name|odd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
goto|goto
name|top
goto|;
comment|/* try again */
block|}
comment|/* Now decrypt the buffer. */
name|gs_type1_decrypt
argument_list|(
name|buf
argument_list|,
name|buf
argument_list|,
name|nread
argument_list|,
operator|(
name|crypt_state
operator|*
operator|)
operator|&
name|s
operator|->
name|cstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
comment|/* Very first buffer-load, strip off leading bytes. */
if|if
condition|(
name|nread
operator|<
name|skip
condition|)
return|return
name|EOFC
return|;
name|s
operator|->
name|cptr
operator|+=
name|skip
expr_stmt|;
name|nread
operator|-=
name|skip
expr_stmt|;
block|}
name|s
operator|->
name|endptr
operator|=
name|s
operator|->
name|cptr
operator|+
name|nread
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Estimate the number of remaining bytes in a decrypting stream. */
end_comment

begin_function
name|private
name|int
name|s_exD_available
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|,
name|long
modifier|*
name|pl
parameter_list|)
block|{
if|if
condition|(
name|savailable
argument_list|(
name|s
operator|->
name|strm
argument_list|,
name|pl
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ERRC
return|;
if|if
condition|(
operator|*
name|pl
operator|>=
literal|0
condition|)
operator|*
name|pl
operator|/=
literal|2
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Stream procedures */
end_comment

begin_decl_stmt
name|stream_procs
name|s_exD_procs
init|=
block|{
name|s_exD_available
block|,
name|NULL
block|,
name|s_std_null
block|,
name|s_filter_close
block|,
name|s_exD_read_buf
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ PFBDecode ------ */
end_comment

begin_comment
comment|/* Initialize the stream */
end_comment

begin_function
name|void
name|s_PFBD_init
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|record_type
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Refill the buffer */
end_comment

begin_function
name|private
name|int
name|s_PFBD_read_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|stream
modifier|*
name|strm
init|=
name|s
operator|->
name|strm
decl_stmt|;
specifier|register
name|byte
modifier|*
name|ptr
init|=
name|s
operator|->
name|cbuf
decl_stmt|;
name|uint
name|count
decl_stmt|;
name|int
name|c
decl_stmt|;
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|endptr
operator|=
name|s
operator|->
name|cbuf
operator|-
literal|1
expr_stmt|;
name|top
label|:
name|count
operator|=
name|s
operator|->
name|bsize
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|record_type
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* new record */
name|c
operator|=
name|sgetc
argument_list|(
name|strm
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0x80
condition|)
goto|goto
name|err
goto|;
name|c
operator|=
name|sgetc
argument_list|(
name|strm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
name|s
operator|->
name|record_type
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
name|EOFC
case|:
name|s
operator|->
name|end_status
operator|=
name|EOFC
expr_stmt|;
return|return
literal|0
return|;
default|default:
goto|goto
name|err
goto|;
block|}
name|s
operator|->
name|record_left
operator|=
name|sgetc
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|s
operator|->
name|record_left
operator|+=
operator|(
name|ulong
operator|)
name|sgetc
argument_list|(
name|strm
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|s
operator|->
name|record_left
operator|+=
operator|(
name|ulong
operator|)
name|sgetc
argument_list|(
name|strm
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|s
operator|->
name|record_left
operator|+=
operator|(
name|ulong
operator|)
name|sgetc
argument_list|(
name|strm
argument_list|)
operator|<<
literal|24
expr_stmt|;
goto|goto
name|top
goto|;
case|case
literal|1
case|:
comment|/* translate \r to \n */
if|if
condition|(
name|count
operator|>
name|s
operator|->
name|record_left
condition|)
name|count
operator|=
name|s
operator|->
name|record_left
expr_stmt|;
block|{
name|uint
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|count
init|;
name|n
operator|!=
literal|0
operator|&&
operator|(
name|c
operator|=
name|sgetc
argument_list|(
name|strm
argument_list|)
operator|)
operator|!=
name|EOFC
condition|;
name|n
operator|--
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
operator|(
name|c
operator|==
literal|'\r'
condition|?
literal|'\n'
else|:
name|c
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|2
case|:
comment|/* translate binary to hex */
block|{
specifier|static
name|char
modifier|*
name|hex_digits
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|uint
name|n
decl_stmt|;
name|count
operator|>>=
literal|1
expr_stmt|;
comment|/* 2 chars per input byte */
if|if
condition|(
name|count
operator|>
name|s
operator|->
name|record_left
condition|)
name|count
operator|=
name|s
operator|->
name|record_left
expr_stmt|;
for|for
control|(
name|n
operator|=
name|count
init|;
name|n
operator|!=
literal|0
operator|&&
operator|(
name|c
operator|=
name|sgetc
argument_list|(
name|strm
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|hex_digits
index|[
name|c
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hex_digits
index|[
name|c
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|record_type
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|s
operator|->
name|record_left
operator|-=
name|count
expr_stmt|;
name|s
operator|->
name|endptr
operator|=
name|ptr
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|s
operator|->
name|end_status
operator|=
name|ERRC
expr_stmt|;
name|s
operator|->
name|endptr
operator|=
name|ptr
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Stream procedures */
end_comment

begin_decl_stmt
name|stream_procs
name|s_PFBD_procs
init|=
block|{
name|s_std_noavailable
block|,
name|NULL
block|,
name|s_std_null
block|,
name|s_filter_close
block|,
name|s_PFBD_read_buf
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

